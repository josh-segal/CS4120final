<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:54+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Aggregate Queries for Discrete and Continuous Probabilistic XML *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>March 22-25, 2010</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
							<email>serge.abiteboul@inria.fr</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T.-H</forename><forename type="middle">Hubert</forename><surname>Chan</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Evgeny</forename><surname>Kharlamov</surname></persName>
							<email>kharlamov@inf.unibz.it</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Werner</forename><surname>Nutt</surname></persName>
							<email>nutt@inf.unibz.it</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pierre</forename><surname>Senellart</surname></persName>
							<email>pierre@senellart.com</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution">INRIA</orgName>
								<address>
									<addrLine>Saclay 4 rue J.Monod</addrLine>
									<postCode>91893</postCode>
									<settlement>Orsay Cedex</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">The University of Hong</orgName>
								<address>
									<addrLine>Kong Pokfulam Road</addrLine>
									<settlement>Hong Kong</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Free University of Bozen-Bolzano Dominikanerplatz</orgName>
								<address>
									<postCode>39100</postCode>
									<settlement>Bozen</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="laboratory">Institut Télécom; Télécom ParisTech CNRS LTCI</orgName>
								<orgName type="institution">Free University of Bozen-Bolzano Dominikanerplatz</orgName>
								<address>
									<addrLine>3, 46 rue Barrault</addrLine>
									<postCode>39100, 75634</postCode>
									<settlement>Bozen, Paris</settlement>
									<country>Italy, France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Aggregate Queries for Discrete and Continuous Probabilistic XML *</title>
					</analytic>
					<monogr>
						<title level="m">ICDT 2010</title>
						<meeting> <address><addrLine>Lausanne, Switzerland</addrLine></address>
						</meeting>
						<imprint>
							<date type="published">March 22-25, 2010</date>
						</imprint>
					</monogr>
					<note>Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H23 [Database Management]: Logical Design</term>
					<term>Lang- uages-data models</term>
					<term>query languages; F20 [Analysis of * Algorithms and Problem Complexity]: General General Terms Algorithms</term>
					<term>Theory Keywords XML</term>
					<term>probabilistic databases</term>
					<term>aggregation</term>
					<term>complexity</term>
					<term>algo- rithms</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Sources of data uncertainty and imprecision are numerous. A way to handle this uncertainty is to associate probabilis-tic annotations to data. Many such probabilistic database models have been proposed, both in the relational and in the semi-structured setting. The latter is particularly well adapted to the management of uncertain data coming from a variety of automatic processes. An important problem, in the context of probabilistic XML databases, is that of answering aggregate queries (count, sum, avg, etc.), which has received limited attention so far. In a model unifying the various (discrete) semi-structured probabilistic models studied up to now, we present algorithms to compute the distribution of the aggregation values (exploiting some regularity properties of the aggregate functions) and probabilistic moments (especially, expectation and variance) of this distribution. We also prove the intractability of some of these problems and investigate approximation techniques. We finally extend the discrete model to a continuous one, in order to take into account continuous data values, such as measurements from sensor networks, and present algorithms to compute distribution functions and moments for various classes of continuous distributions of data values.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>The (HTML or XML) Web is an important source of uncertain data, for instance generated by imprecise automatic tasks such as information extraction. A natural way to model this uncertainty is to annotate semistructured data with probabilities. This is the basis of recent works that consider queries over such imprecise hierarchical information <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b27">28]</ref>. An essential aspect of query processing has been ignored in all these works, namely, aggregate queries. This is the problem we consider here. We provide a comprehensive study of query processing for a very general model of imprecise data and a very large class of aggregate queries.</p><p>We consider probabilistic XML documents and the unifying representation model of p-documents <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b18">19]</ref>. A p-document can be viewed as a probabilistic process that randomly generates XML documents. Some nodes, namely distributional nodes, specify how to perform this random generation. We consider three kinds of distributional operators: cie, mux, det, respectively for conjunction of independent events (a node is selected if a conjunction of some probabilistic conditional events holds), mutually exclusive (at most one node selected from a set of a nodes), and deterministic (all nodes selected). This model, introduced in <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b18">19]</ref>, captures a very large class of models for probabilistic trees that had been previously studied. For queries, we consider tree-pattern queries possibly with value joins and the restricted case of single-path queries. For aggregate functions, we consider the standard ones, namely, sum, count, min, max, countd (count distinct) and avg (average).</p><p>A p-document is a (possibly very compact) representation of a probabilistic space of (ordinary) documents, i.e., a finite set of possible documents, each with a particular probability. In the absence of a grouping operation à la SQL (GROUP BY), the result of an aggregate query is a single value for each possible document. Therefore, an aggregate query over a pdocument is a random variable and the result is a distribution, that is, the set of possible values, each with its probability. It is also interesting to consider summaries of the distribution of the result random variable (that is possibly very large), and in particular, its expected value and other probabilistic moments. When grouping is considered, a single value (again a random variable) is obtained for each match of the grouping part of the query. We investigate the computation of the distributions of random variables (in presence of grouping or not) and of their moments.</p><p>Our results highlight an (expectable) aspect of the different operators in p-documents: the use of cie (a much richer means of capturing complex situations) leads to an increase in complexity. For documents with cie nodes, we show the problems are hard (typically NP-or FP #P -complete). For count and sum, in the restricted setting of single-path queries, we show how to obtain moments in P. We also present Monte-Carlo methods that allow tractable approximations of probabilities and moments. On the other hand, with the milder forms of imprecision, namely mux and det, the complexity is lower. Computing the distribution for treepattern queries involving count, min and max is in P. The result distribution of sum may be exponentially large, but the computation is still in P in both input and output. On the other hand, computing avg or countd is FP #P -complete. On the positive side, we can compute expected values (and moments) for most aggregate tree-pattern queries in P. When we move to queries involving joins, the complexity of moment and distribution computation becomes FP #P -complete.</p><p>A main novelty of this work is that we also consider probabilistic XML documents involving continuous probability distributions, which captures a very frequent situation occurring in practice. We formally extend the probabilistic XML model by introducing leaves representing continuous value distributions. We explain how the techniques for the discrete case can be adapted to the continuous case and illustrate the approach by results that can be obtained.</p><p>The paper is organized as follows. After presenting preliminaries and introducing the problems in Sections 2 and 3, we consider cie nodes in Section 4. In Section 5, we consider monoid aggregate functions in the context of mux and det nodes. Continuing with this model, we study complexity of distributions and moments in Section 6. We briefly discuss approximation algorithms in Section 7. Continuous probability distributions are considered in Section 8. Finally, we present related work and conclude in Section 9.</p><p>A preliminary version of some of this work appeared in <ref type="bibr" target="#b0">[1]</ref> (a national conference without proceedings).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">DETERMINISTIC DATA AND QUERIES</head><p>We recall the data model and query languages we use. We assume a countable set of identifiers I and one of labels L, such that I ∩ L = ∅. The set of labels includes a set of data values (e.g., the integers, on which the aggregate functions will be defined). A document is a pair d = (t, θ), consisting of a finite, unordered 1 tree t, where each node has <ref type="bibr" target="#b0">1</ref> Ignoring the ordering of the children of nodes is a common simplification over the XML model that does not significantly <ref type="bibr">[54]</ref> [26] <ref type="bibr" target="#b24">[25]</ref> [12]</p><p>[55] <ref type="bibr">[41]</ref> [32] 50</p><p>[5] bonus <ref type="bibr" target="#b1">[2]</ref> person <ref type="bibr" target="#b2">[3]</ref> person a unique identifier v and a label θ(v). We use the standard notions child and parent, descendant and ancestor, root and leaf in the usual way. To simplify the presentation, we assume that the leaves of documents are labeled with data values and the other nodes by non-data labels, that are called tags. The sets of nodes and edges of d are denoted, respectively, by</p><formula xml:id="formula_0">Mary [31] pda</formula><formula xml:id="formula_1">I(d) and E(d), where E(d) ⊆ I(d) × I(d).</formula><p>We denote the root of d by root(d) and the empty tree, that is, the tree with no nodes, by ε. Example 1. Consider the document d in <ref type="figure" target="#fig_0">Figure 1</ref>. Identifiers appear inside square brackets before labels. The document describes the personnel of an IT department and the bonuses distributed for different projects. The document d indicates John worked under two projects (laptop and pda) and got bonuses of 37 and 50 in the former project and 50 in the latter one.</p><p>An aggregate function maps a finite bag of values (e.g., rationals) into some domain (possibly the same or different). In particular, we assume that any aggregate function is defined on the empty bag. In the paper we study the common functions: sum, count, min, countd (count distinct), and avg (average) under the usual semantics. Our results easily extend to max and topK .</p><p>Aggregate functions can be naturally extended to work on documents d: the result α(d) is α(B) where B is the bag of the labels of all leaves in d. This makes the assumption that all leaves are of the type required by the aggregate function, e.g., rational numbers for sum. Again to simplify, we ignore this issue here and assume they all have the proper type. It is straightforward to extend our models and results with a more refined treatment of typing.</p><p>As we will see some particular aggregate functions, the so-called monoid ones <ref type="bibr" target="#b9">[10]</ref>, play a particular role in our investigation, because they can be handled by a divide-andconquer strategy. Formally, a structure (M, ⊕, ⊥) is called an abelian monoid if ⊕ is an associative and commutative binary operation with ⊥ as identity element. If no confusion arises, we speak of the monoid M . An aggregate function is a monoid one if for some monoid M and any a1, . . . , an ∈ M :</p><formula xml:id="formula_2">α({|a1, . . . , an| }) = α({|a1| }) ⊕ · · · ⊕ α({|an| }).</formula><p>It turns out that sum, count, min, max and topK are monoid aggregate functions. For sum, min, max: α({|a| }) = a and ⊕ is the corresponding obvious operation. For count: α({|a| }) = 1 and ⊕ is +. On the other hand, it is easy to check that neither avg nor countd are monoid aggregate functions.</p><p>change the results of this paper.</p><p>Finally, we introduce tree pattern queries with joins, with join-free queries and single-path queries as special cases. We then extend them to aggregate queries.</p><p>We assume a countable set of variables Var. A tree pattern (with joins), denoted Q, is a tree with two types of edges: child-edges, denoted E / , and descendent edges, denoted E // . The nodes of the tree are labeled by a labeling function 2 λ with either labels from L or with variables from Var. Variables that occur more than once are called join variables. We refer to nodes of Q as n, m in order to distinguish them from the nodes of documents.</p><p>A tree pattern query with joins has the form Q[¯ n], where Q is a tree pattern with joins and ¯ n is a tuple of nodes of Q (defining its output). We sometimes identify the query with the pattern and write Q instead of Q[¯ n] if ¯ n is not important or clear from the context. If ¯ n is the empty tuple, we say that the query is Boolean. A query is join-free if every variable in its pattern occurs only once. If the set of edges E / ∪ E // of a query is a linear order, the query is a single-path query. We denote the set of all tree pattern queries, which may have joins, as TPJ. The subclasses of join-free and single path queries are denoted as TP and SP, respectively.</p><p>A valuation ν maps query nodes to document nodes. A document satisfies a query if there exists a satisfying valuation, which maps query nodes to the document nodes in a way that is consistent with the edge types, the labeling, and the variable occurrences. That is, (1) nodes connected by child/descendant edges are mapped to nodes that are children/descendants of each other; (2) query nodes with label a are mapped to document nodes with label a; and (3) two query nodes with the same variable are mapped to document nodes with the same label.</p><p>Slightly differently from other work, we define that applying a query Q[¯ n] to a document d returns a set of tuples of nodes: Q(d) := {ν(¯ n) | ν satisfies Q}. One obtains the more common semantics, according to which a query returns a set of tuples of labels, by applying the labeling function of d to the tuples in Q(d).</p><p>An aggregate TPJ-query has the form Q[α(n)], where Q is a tree pattern, n is a node of Q and α is an aggregate function. We evaluate such a Q[α(n)] in three steps: First, the non-aggregate query Q := Q[n] over d, obtaining a set of nodes Q (d). We then compute the bag B of labels of Q (d), that is B := {|θ(n) | n ∈ Q (d)| }. Finally we apply α to B. Identifying the aggregate query with its pattern, we denote the value resulting from evaluating Q over d as Q(d).</p><p>If Q[n] is a non-aggregate query and α an aggregate function, we use the shorthand Q α to denote the aggregate query Q[α(n)]. More generally, we denote the set of aggregate queries obtained from queries in TPJ, SP, TP and some function α, as TPJ α , SP α , TP α , respectively.</p><p>The syntax and semantics above can be generalized in a straightforward fashion to aggregate queries with SQL-like GROUP BY. Such queries are written Q[¯ n, α(n)] and return an aggregate value for every binding of ¯ n to a tuple of document nodes. Since we can reduce the evaluation of such queries to the evaluation of several simpler queries of the kind defined before, while increasing the data complexity by no more than a polynomial factor, we restrict ourselves to that simpler case. Example 2. Continuing with Example 1, one may want to compute the sum of bonuses for each person in the department. A TP sum query Q that computes bonuses for Mary is in <ref type="figure" target="#fig_1">Figure 2</ref>. The query result Q(d) is 59.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">DISCRETE PROBABILISTIC DATA</head><p>We next present discrete probability spaces over data trees (see <ref type="bibr" target="#b1">[2]</ref> for a more detailed presentation) and formalize the problems we will study in the following sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">px-Spaces and p-Documents</head><p>A finite probability space over documents, px-space for short, is a pair S = (D, Pr), where D is a finite set of documents and Pr maps each document to a probability</p><formula xml:id="formula_3">Pr(d) such that {Pr(d) | d ∈ D} = 1.</formula><p>p-Documents: Syntax. Following <ref type="bibr" target="#b1">[2]</ref>, we now introduce a very general syntax for representing compactly px-spaces, called p-documents. A p-document is similar to a document, with the difference that it has two types of nodes: ordinary and distributional. Distributional nodes are used for defining the probabilistic process that generates random documents but they do not actually occur in these. Ordinary nodes have labels and they may appear in random documents. We require the leaves to be ordinary nodes <ref type="bibr" target="#b2">3</ref> .</p><p>More precisely, we assume given a set X of independent Boolean random variables with some specified probability distribution ∆ over them. A p-document, denoted by P, is an unranked, unordered, labeled tree. Each node has a unique identifier v and a label µ(v) in L ∪ {cie(E)}E ∪ {mux(Pr)} Pr ∪ {det} where L are labels of ordinary nodes, and the others are labels of distributional nodes. We consider three kinds of the latter labels: cie(E) (for conjunction of independent events), mux(Pr) (for mutually exclusive), and det (for deterministic). We will refer to distributional nodes labeled with these labels, respectively, as cie, mux and det nodes. If a node v is labeled with cie(E), then E is a function that assigns to each child of v a conjunction e1 ∧ · · · ∧ e k of literals (x or ¬x, for x ∈ X ). If v is labeled with mux(Pr), then Pr assigns to each child of v a probability with the sum equal to 1.</p><p>Example 3. Two p-documents are shown in <ref type="figure" target="#fig_2">Figures 3  and 4</ref>. The first one has only cie distributional nodes. For example, node n21 has label cie(E) and two children n22 and n 24 , such that E(n22) = ¬x and E(n 24 ) = x. The second p-document has only mux and det distributional nodes. Node n52 has label mux(Pr) and two children n53 and n56, such that Pr(n53) = 0.7 and Pr(n56) = 0.3.</p><p>x, z <ref type="bibr" target="#b24">[25]</ref> [56]</p><p>[8]</p><p>x <ref type="bibr" target="#b10">[11]</ref> z ¬z, x <ref type="bibr" target="#b12">[13]</ref> [52]</p><p>[41]</p><p>x <ref type="bibr">[55]</ref> ¬x ¬x <ref type="bibr" target="#b22">[23]</ref> [32]</p><p>[54] <ref type="bibr" target="#b25">[26]</ref> [21] cie <ref type="bibr">[31]</ref>   We denote classes of p-documents by PrXML with a superscript denoting the types of distributional nodes that are allowed for the documents in the class. For instance, PrXML mux,det is the class of p-documents with only mux and det distributional nodes, like P on <ref type="figure" target="#fig_3">Figure 4</ref>. p-Documents: Semantics. The semantics of a p-document P, denoted by P, is a px-space over random documents, where the documents are denoted by P and are obtainable from P by a randomized three-step process.</p><p>1. We choose a valuation ν of the variables in X . The probability of the choice, according to the distribution ∆, is</p><formula xml:id="formula_4">pν = x in P,ν(x)=true ∆(x) · x in P,ν(x)=false (1 − ∆(x)). 2.</formula><p>For each cie node labeled cie(E), we delete its children v where ν(E(v)) is false, and their descendants. Then, independently for each mux node v labeled mux(Pr), we select one of its children v according to the corresponding probability distribution Pr and delete the other children and their descendants, the probability of the choice is Pr(v ). We do not delete any of the children of det nodes. <ref type="bibr" target="#b3">4</ref> 3. We then remove in turn each distributional node, connecting each ordinary child v of a deleted distributional node with its lowest ordinary ancestor v , or, if no such v exists, we turn this child into a root.</p><p>The result of this third step is a random document P. The probability Pr(P) is defined as the product of pν , the probability of the variable assignment we chose in the first step, with all Pr(v ), the probabilities of the choices that we made in the second step for the mux nodes.</p><p>Example 4. One can obtain the document d in <ref type="figure" target="#fig_0">Figure 1</ref> by applying the randomized process to the p-document in Remark. In our analysis, we only consider distributional nodes of the types cie, mux, and det. In <ref type="bibr" target="#b1">[2]</ref> two more types of distributional nodes (ind and exp) are considered. As shown there, the first kind can be captured by mux and <ref type="bibr" target="#b7">[8]</ref> [55] <ref type="bibr" target="#b20">[21]</ref> [54] <ref type="bibr" target="#b12">[13]</ref> [11] <ref type="bibr">[41]</ref> 0.7 0.3</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>0.75</head><p>[52]</p><p>[53] <ref type="bibr" target="#b24">[25]</ref> 0.25 0.1 0.9</p><p>[23]</p><p>[32]</p><p>[26]</p><p>[56]15  det, while the second is a generalization of mux and det and most results of PrXML mux,det can be extended to PrXML exp . As proved in <ref type="bibr" target="#b1">[2]</ref>, PrXML cie is strictly more expressive than PrXML mux,det . It was shown in <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b19">20]</ref> that data complexity of answering TP-queries is intractable for PrXML cie (FP #P -complete) whereas it is polynomial for PrXML mux,det .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Aggregating Discrete Probabilistic Data</head><p>Let Q α be an aggregate query and S = (D, Pr) be a px-space of documents. Since Q α maps elements of the probability space S to values in the range of α, we can see Q α as a random variable.</p><p>We therefore define the result of applying Q α to S as the distribution of this random variable, that is</p><formula xml:id="formula_5">(Q α (S))(c) = Pr(d) d ∈ D, Q α (d) = c ,</formula><p>for c in the range of α.</p><p>Since in applications px-spaces are given under the form of p-documents, we further extend the definition to p-documents by defining Q α ( P) := Q α ( P). We denote the random variable over the p-document P corresponding to Q as Q(P).</p><p>Example 5. Evaluation of the query Q[sum(n)] from Example 2 over the cie-document in <ref type="figure" target="#fig_2">Figure 3</ref> gives the distribution {(0, 0.14175), (15, 0.80325), (44, 0.00825) (59, 0.04675)}, while evaluation over the mux-det-document in <ref type="figure" target="#fig_3">Figure 4</ref> gives the distribution {(15, 0.3), (59, 0.7)}.</p><p>Computational Problems. For an aggregate query Q, we are interested in the following three problems, where the input parameters are a p-document P with corresponding random document P and possibly a number c:</p><p>Membership: Given a number c, is c in the carrier of Q(P),</p><p>i.e., is Pr(Q(P) = c) &gt; 0? Probability computation: Given a number c, compute</p><p>Pr(Q(P) = c).</p><formula xml:id="formula_6">Moment computation: Compute the moment E(Q(P) k ),</formula><p>where E is the expected value.</p><p>Membership and probability computation can be used to return to a user the distribution Q( P) of an aggregate query. Computing the entire distributions may be too costly or the user may prefer a summary of the distributions. For example, a user may want to know its expected value E(Q(P)) and the variance Var(Q(P)). In general the summary can be an arbitrary k-th moment E(Q(P) k ) and the moment computation problem addresses this issue. <ref type="bibr" target="#b4">5</ref> In the following, we investigate these problems for the classes of cie documents and mux-det documents. For each class, we further distinguish between aggregate queries of the types SP, TP, and TPJ with the functions min, count, sum, countd and avg. We do not discuss max and topK since they behave similarly as min. In the paper we mainly speak about data-complexity, when the input is a p-document and the query is fixed. Occasionally we also consider combined complexity, when both the p-document and the query are inputs of the problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">AGGREGATING PrXML cie</head><p>We now study the problems introduced in Section 3 for the most general class of p-documents, PrXML cie . By definition, one approach is to first construct the entire px-space of a p-document P, then to apply the aggregate query Q to each document in P separately, and finally combine the results to obtain the distribution Q( P). This approach is expensive, since the number of possible documents is exponential in the number of variables occurring in</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P.</head><p>Our complexity results show that for practically all functions and all problems nothing can be done that would be significantly more efficient. All the decision problems are NP-complete while computational problems are NP-hard or FP #P -complete. The only exception is the computation of moments for aggregate single-path queries with sum and count. The intractability is due to dependencies between nodes of p-documents expressed using variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Principles</head><p>We now show several general principles for p-documents that are used later on to support the results.</p><p>Functions in #P and FP #P . We recall here the definitions of some classical complexity classes (see, e.g., <ref type="bibr" target="#b23">[24]</ref>) that characterize the complexity of aggregate functions on PrXML cie . An N-valued function f is in #P if there is a non-deterministic polynomial-time Turing machine T such that for every input w, the number of accepting runs of T is the same as f (w). A function is in FP #P if it is computable in polynomial time using an oracle for some function in #P. Following <ref type="bibr" target="#b8">[9]</ref>, we say that a function is FP #P -hard if there is a polynomial-time Turing reduction (that is, a reduction with access to an oracle to the problem reduced to) from every function in FP #P to it. Hardness for #P is defined in a standard way using Karp (many-one) reductions. For example, the function that counts for every propositional 2-DNF formula the number of satisfying assignments is in #P and #P-hard <ref type="bibr" target="#b24">[25]</ref>, hence #P-complete. We notice that the usage of Turing reductions in the definition of FP #P -hardness implies that any #P-hard problem is also FP #P -hard. Therefore, to prove FP #P -completeness it is enough to show FP #P -membership and #P-hardness. Note also that #P-hardness clearly implies NP-hardness.</p><p>We now consider membership in FP #P . We say that an aggregate function α is scalable if for every p-document P ∈ PrXML cie , one can compute in polynomial time a natural <ref type="bibr" target="#b4">5</ref> The variance is the central moment of order 2; it is known that the central moment of order k can be tractably computed from the regular moments of order k.</p><formula xml:id="formula_7">number M such that for every d ∈ P the product M · α(d)</formula><p>is a natural number. The following result is obtained by adapting proof techniques of <ref type="bibr" target="#b12">[13]</ref>.</p><p>Proposition 6. Let α be an aggregate function that is computable in polynomial time and Q be an aggregate TPJquery using α. If α is scalable, then the following functions mapping p-documents to rational numbers are in FP #P :</p><p>1. for every c ∈ Q the function P → Pr(Q(P) = c);</p><p>2. for every k 1, the function</p><formula xml:id="formula_8">P → E(Q(P) k ).</formula><p>The proposition above shows membership in FP #P of both probability and moment computation for aggregate queries in TPJ with all aggregate functions mentioned in the paper.</p><p>Reducing Query Evaluation to Aggregation. Now we show that for answering aggregate SP-queries it is possible to isolate aggregation from query processing. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Let</head><formula xml:id="formula_9">Pr(P |= Q) = Pr(Q α (P ) = 1) = E(Q α (P ) k ). Moreover, 1. if Q ∈ TP, then Q α ∈ TP α ;</formula><p>2. if P ∈ PrXML cie , then P ∈ PrXML cie ;</p><p>3. if P ∈ PrXML mux,det , then</p><formula xml:id="formula_10">P ∈ PrXML mux,det .</formula><p>In <ref type="bibr" target="#b18">[19]</ref> it has been proved that for every non-trivial Boolean tree pattern query, computing the probability to match ciedocuments is #P-hard. By reducing #2DNF, we can show that for the more restricted case of mux-det documents, evaluation of tree pattern queries with joins can be #P-hard.</p><p>Lemma 9. There is a Boolean TPJ-query with #P-hard data complexity over PrXML mux,det .</p><p>The result in <ref type="bibr" target="#b18">[19]</ref> and the previous lemma yield immediately the following complexity lower bounds for probability and moment computation for TP and TPJ.</p><p>Corollary 10. For any faithful aggregate function α, there exist an aggregate TP-query Q1 and an aggregate TPJquery Q2, both with function α, such that each of the following computation problems is #P-hard:</p><p>1. probability computation for Q1 over PrXML cie ; 2. k-th moments of Q1 over PrXML cie , for any k 1; 3. probability computation for Q2 over PrXML mux,det ; 4. k-th moments of Q2 over PrXML mux,det , for any k 1.</p><p>We are ready to present aggregation of PrXML cie .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Computational Problems</head><p>We first show how to check for membership over PrXML cie .</p><p>Theorem 11 (Membership). Let α be one of sum, min, count, avg, and countd. Then membership over PrXML cie is in NP for the class TPJ α . Moreover, the problem is NP-hard for any aggregate query in SP α .</p><p>The upper bound holds because, given a query, guessing a world and evaluating the query takes no more than polynomial time. The lower bound follows from the next lemma. We next show how to compute probability over PrXML cie .</p><p>Theorem 13 (Probability). Let α be one of sum, count, min, avg, and countd. Then probability computation over PrXML cie is in FP #P for the class TPJ α . Moreover, the problem is #P-hard for every query in SP α .</p><p>Proof. (Sketch) The FP #P upper bound follows from Proposition 6 and #P-hardness can be shown by a reduction of probability computation for DNF propositional formulas (that is known to be #P-hard), see the following lemma.</p><p>The following lemma supports Theorems 13 and 15.</p><p>Lemma 14. Let α be one of sum, count, min, avg, countd, and β be one of min, avg, countd. Let Q α and Q β be SP-queries. Then for every propositional DNF formula ϕ, one can compute in polynomial time a p-document Pϕ ∈ PrXML cie such that the following are equivalent: Proof. Again, as for Theorem 13, the FP #P upper bound follows from Proposition 6. Claim 2 follows from Lemma 14 and its analogues for min, countd, and avg. Claim 3 follows from Corollary 10.</p><formula xml:id="formula_11">1. Pr(Q α (Pϕ) = 0) = 1 − Pr(ϕ); 2. E(Q β (Pϕ) k ) = 1 − Pr(ϕ) for any k 1.</formula><p>To prove Claim 1, we rely on Proposition 7, which reduces answering aggregate SP-queries to evaluating aggregate functions, and the following lemmas.</p><p>The next lemma shows that the computation of the expected value for sum over a px-space, regardless whether it can be represented by a p-document, can be polynomially reduced to computation of an auxiliary probability.</p><p>Lemma 16. Let S be a px-space and V be the set of all leaves occurring in the documents of S. Suppose that the function θ labels all leaves in V with rational numbers and let sum(S) be the random variable defined by sum on S. Then</p><formula xml:id="formula_12">E(sum(S) k ) = (v 1 ,...,v k )∈V k k i=1 θ(vi) × Pr ({d ∈ S | v1, . . . , v k occur in d}) ,</formula><p>where the last term denotes the probability that a random document d ∈ S contains all the nodes v1, . . . , v k .</p><p>Intuitively, the proof exploits the fact that E(sum(S)) is a sum over documents of sums over nodes, which can be rearranged as a sum over nodes of sums over documents.</p><p>The auxiliary probability introduced in the previous lemma can be in fact computed in polynomial time for px-spaces θ(vi), can be computed in time at most | P| k . By Lemma 17, the second term can be computed in polynomial time. This shows that for every k 1, the k-th moment of sum can be computed in polynomial time. The claim for count follows as a special case, where all leaves carry the label 1. <ref type="table">Table 1</ref> gives an overview of the data complexity results of this section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">MONOID AGGREGATES</head><p>The previous section highlighted the inherent difficulty of computing aggregate queries over cie-documents. The intuitive reason for this difficulty is that the event variables used in a p-document can impose constraints between the structure of subdocuments in very different locations. In contrast, mux,det-documents only express "local" dependencies. As a consequence, for the special case of single path queries and monoid aggregate functions, mux-det documents allow for a conceptually simpler computation of distributions, which in a number of cases is also computationally efficient.</p><p>The key to developing methods in this setting is Proposition 7, which reduces the evaluation of a single path aggregate We are going to show how a mux,det-document P can be seen as a recipe for constructing the px-space P in a bottomup fashion, starting from elementary spaces represented by the leaves and using essentially two kinds of operations, convex union and product. Convex union corresponds to mux-nodes and product corresponds to det-nodes and regular nodes. (To be formally correct, we would need to distinguish between two slightly different versions of product for det and regular nodes. However, to simplify our exposition, we only discuss the case of regular nodes and briefly indicate below the changes necessary to deal with det-nodes.)</p><p>For any α, the distribution over the space described by a leaf of P is a Dirac distribution, that is, a distribution of the form δa, where δa(b) = 1 if and only if a = b. For monoid functions α, the two operations on spaces, convex union and product, have as counterparts two operations on distributions, convex sum and convolution, by which one can construct the distribution α( P) from the Dirac distributions of the leaves of P. We sketch in the following both the operations on spaces and on distributions, and the way in which they are related.</p><p>As the base case, consider a leaf node v with label l. This is the simplest p-document possible, which constitutes an elementary px-space that contains one document, namely node v with label l, and assigns the probability 1 to that document. Over this space, α evaluates with probability 1 to α({|l| }), hence, the probability distribution is δ α({ |l| }) . As a special case, if α is a monoid aggregation function over M , the distribution of α over the space containing only the empty document ε is δ ⊥ , where ⊥ is the identity of M . Inductively, suppose that v is a mux-node in P, the subtrees below v are P1, . . . ,</p><p>Pn, and the probability of the i-th subtree Pi is pi (see <ref type="figure" target="#fig_9">Figure 5</ref>, left). Without loss of generality we can assume that the pi are convex coefficients, that is, p1 + · · · + pn = 1, since we admit the empty tree as a special p-document.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Let</head><p>Pv denote the subtree rooted at v. Then the semantics of mux-nodes implies that the px-space</p><formula xml:id="formula_13">Pv = (Dv, Prv)</formula><p>is the convex union of the spaces Pi = (Di, Pri), which means the following: (1) Dv is the disjoint union of the Di (in other words, for any d ∈ Dv, there is exactly one Di such that d ∈ Di); (2) for any document d ∈ Dv, we have that The set of surviving children in Pv is exactly the union of the sets of children having survived in each Pi and, consequently, for the probability q := Prv(d) we have that q = q1 · · · qn. In summary, this shows that the probability space (Dv, Prv) is structurally the same as the product of the spaces (Di, Pri).</p><formula xml:id="formula_14">Prv(d) = piPri(d), where d ∈ Di.</formula><p>Suppose now that, in addition, α is a monoid aggregate function taking values in (M, ⊕, ⊥). Then for any document</p><formula xml:id="formula_15">d = v l (d1, . . . , dn) ∈ Pv we have that α(d) = α(d1) ⊕ · · · ⊕ α(dn).</formula><p>Hence, the probability that α(Pv) = c is the sum of all products Pr(α(P1) = c1) · · · Pr(α(Pn) = cn) such that c = c1 ⊕ · · · ⊕ cn. Motivated by this observation, we define the following operation. For any functions f , g : M → R, the convolution of f and g with respect to M is the function</p><formula xml:id="formula_16">f * M g : M → R such that (f * M g)(m) = m 1 ,m 2 ∈M : m 1 ⊕m 2 =M f (m1)g(m2).<label>(1)</label></formula><p>From our observation above it follows that the distribution α( Pv) is the convolution of the distributions α(</p><p>Pi) with respect to M , that is,</p><formula xml:id="formula_17">α( Pv) = α( P1) * M · · · * M α( Pn).<label>(2)</label></formula><p>For det-nodes v, the same equation applies, although the supporting arguments are a bit more complicated. The crucial difference is that for det-nodes, Pv is a space of forests, not trees, since the trees (or forests) in the Pi are combined without attaching them to a new root.</p><p>We summarize how one can use the operations introduced to obtain the distribution of a monoid aggregate function over a mux-det document. Essentially the same relationship between distributions as spelled out in Theorem 18 exists also if we allow continuous distributions at the leaves of documents. An evaluation algorithm then has to compute convex sums and convolutions, starting from continuous instead of Dirac distributions (we will discuss this in detail in Section 8).</p><p>The carrier of a function f : M → R is the set of elements m ∈ M such that f (m) = 0. Since for any P the carrier of min( P) and of count( P) has at most as many elements as there are leaves in P, we can draw some immediate conclusions from Theorem 18. Proof. (Sketch) Claim 1 holds because computing a convex sum and convolutions with respect to "+" and min of two distributions is polynomial and all distributions involved in computing count( P) and min( P) have size O(| P|). Claim 2 holds because, in addition, a convex sum and the convolution with respect to "+" of two distributions have at least the size of the largest of the two arguments.  Remark. This principle has also been applied in <ref type="bibr" target="#b25">[26]</ref> in the context of queries with aggregation constraints over probabilistic relational databases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">AGGREGATING PrXML mux,det</head><p>We investigate the three computational problems for aggregate queries for the restricted class of PrXML mux,det , drawing upon the principles developed in the preceding section.</p><p>Theorem 20 (Membership). Let α be one of sum, count, min, avg, and countd. Then membership over PrXML mux,det is in NP for the class TPJ α . Moreover, the problem is 1. NP-hard for every query in SP sum , SP avg and SP countd ; 2. of polynomial combined complexity for the classes SP min and SP count ; 3. of polynomial data complexity for any query in TP min and TP count .</p><p>Proof. (Sketch) The NP upper bound is inherited from the cie-case (Theorem 11). Claim 1 can be shown by a reduction of subset-sum and exact cover by 3-sets. Claims 2 and 3 follow from their counterparts (Claims 1 and 2, respectively) in Theorem 21.</p><p>We next consider probability computation. Proof. (Sketch) The FP #P upper bound is inherited from the cie-case (Theorem 13). Claim 1 follows from Corollary 19, since, due to Proposition 7, for an aggregate SP-query Q α we have that Q α ( P) = α( PQ). Regarding Claim 2, algorithms for count and min can be developed in a straightforward way, applying the techniques in <ref type="bibr" target="#b7">[8]</ref> to evaluate TP-queries with aggregate constraints. For a given p-document, there are only linearly many possible values for min and count, the probability of which can be computed in polynomial time by incorporating them in constraints. Consequently, the entire distribution of min or count can be computed in polynomial time.</p><p>Claim 3 can be shown by a reduction of the #K-cover problem for countd and the #Non-Negative-Subset-Average problem for avg. 6 Claim 5 follows from Corollary 10.</p><p>Finally, we consider moments over PrXML mux,det .</p><p>Theorem 22 (Moments). Let α be one of sum, count, min, avg, and countd. Then computation of moments of any degree over PrXML mux,det is in FP #P for the class TPJ α . Moreover, the problem is 1. of polynomial combined complexity for the class SP α ; 2. of polynomial data complexity for the class TP α , if α = avg; 3. #P-hard for some query in TPJ α .</p><p>Proof. The FP #P upper bound is inherited from the cie-case (Theorem 15). Claim 3 follows from Corollary 10.</p><p>Regarding Claim 1, all our algorithms first reduce aggregate query answering to function evaluation (see Proposition 7). The algorithm for count and sum is a refinement for the one for the cie-case (Theorem 15). The algorithm for min works on the entire distribution, which can be computed in polynomial time <ref type="bibr">(Corollary 19</ref>).</p><p>For countd we apply similar techniques of regrouping sums to those that we used for sum in Lemma 16. In doing so, we exploit the fact that the probability for a value (or sets of values of fixed cardinality) to occur in a query result over a mux,det-document can be computed in polynomial time, which follows from work in <ref type="bibr" target="#b18">[19]</ref>.</p><p>The algorithm for avg traverses p-documents in a bottomup fashion. It maintains conditional moments of sum for each possible value of count and combines them in two possible ways, according to the node types. <ref type="bibr" target="#b6">7</ref> Regarding Claim 2, moments for count and min can be computed directly from the distributions, which can be constructed in polynomial time as sketched in the proof of Theorem 21.2.</p><p>Algorithms for sum and countd can be based on a generalisation of the principle of regrouping sums (see Lemma 16) for tree pattern queries. Analogously as for the case of singlepath queries, the crucial element for the complexity of the sum-algorithm is the difficulty of computing the probability that a node (or sets of nodes of fixed cardinality) occur in a query result. For tree pattern queries without joins, these probabilities can be computed in polynomial time adapting the techniques in <ref type="bibr" target="#b18">[19]</ref>. A variation of this principle, where the probabilities of a given set of values to occur in a query result is computed, gives an algorithm for countd. <ref type="bibr" target="#b5">6</ref> The same problems has been used earlier in <ref type="bibr" target="#b25">[26]</ref> to show #P-hardness of evaluating relational queries with countd and avg-constraints. <ref type="bibr" target="#b6">7</ref> A technique that is similar in spirit has been presented in <ref type="bibr" target="#b17">[18]</ref> for probabilistic streams. <ref type="table" target="#tab_5">Table 2</ref> gives an overview of data complexity results of this section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">APPROXIMATIONS AND SAMPLING</head><p>Without loss of generality, we only discuss how to estimate cumulative distributions Pr(Q α (P) c) and moments E(Q α (P) k ) for aggregate TPJ-queries. Notice that by using cumulative distributions one can also approximate the probability of individual values: to estimate Pr(Q α (P) = c), we estimate Pr(Q α (P) c + γ) and Pr(Q α (P) c − γ) for a small γ (that depends on α and P) and subtract the second from the first.</p><p>For instance, in order to approximate the cumulative probability Pr(Q countd (P) 100), one evaluates the query on independent random samples of worlds of P, and then use the ratio of resulting samples where countd is at most 100 as an estimator. Similarly, for approximating E(Q countd (P)), one returns the average of countd over the results.</p><p>Using Hoeffding's Bound <ref type="bibr" target="#b13">[14]</ref> we obtain the following two propositions for approximating a point for the cumulative distribution of an aggregate query and moments of any degree, respectively.</p><p>Proposition 23. Let Q be an aggregate TPJ-query, P ∈ PrXML cie,mux,det a p-document and x ∈ Q. Then for any rationals ε, δ &gt; 0, it is sufficient to have O( 1 ε 2 log 1 δ ) samples so that with probability at least 1 − δ, the quantity Pr(Q(P) x) can be estimated with an additive error of ε.</p><p>Observe that the number of samples in Proposition 23</p><p>is independent of the size of</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P. A problem may arise if</head><p>Pr(Q(P) x) ε, since then an additive error of ε makes the estimate useless. However, for probabilities above a threshold p0, it is enough to have the number of samples proportional to 1/p 2 0 (with additive error, say p0/10).</p><p>Proposition 24. Let Q be an aggregate TPJ-query, f a function mapping Q to Q, such that f (Q(P)) ranges over an interval of width R and P ∈ PrXML cie a p-document. Then, for any rationals ε, δ &gt; 0, it is sufficient to have O( R 2 ε 2 log 1 δ ) samples so that, with probability at least 1 − δ, the quantity E(f (Q(P))) can be estimated with additive error of ε.</p><p>As a consequence, if Q takes values in <ref type="bibr">[0, R]</ref>, choosing f (x) := x k yields that the k-th moment of Q(P) around zero can be estimated with O( R 2k ε 2 log 1 δ ) samples. Observe that if the range R has magnitude polynomial in size of P, then we have a polynomial-time estimation algorithm. For example, to approximate E(Q countd ( P)) it is enough to draw a quadratic number of samples, since the range R is at most the number of the leaves in P.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONTINUOUS PROBABILISTIC DATA</head><p>We generalize p-documents to documents whose leaves are labeled with (representations of) probability distributions over the reals, instead of single values. We give semantics to such documents in terms of continuous distributions over documents with real numbers on their leaves.</p><p>Continuous px-Spaces. In the discrete case, a p-document defines a finite set of trees and probabilities assigned to them.</p><p>In the continuous case, a p-document defines an uncountably infinite set of trees with a continuous distribution, which assigns probabilities to (typically infinite) sets of trees, the possible events, which form a σ-algebra. We refer to a textbook on measure and probability theory such as <ref type="bibr" target="#b4">[5]</ref> for the definitions of the concepts used in this section.</p><p>From now on, we consider only documents whose leaves are labeled with real numbers. We say that two documents d = (t, θ) and d = (t , θ ) are structurally equivalent, denoted d ∼st d , if t = t and θ(v) = θ(v ) for every v that is not a leaf of t. That is, d and d differ only in the labels of the leaves. Obviously, ∼st is an equivalence relation on the set of all documents. Intuitively, the structure and the labels of inner nodes fix the structure of a document while the leaves contain values.</p><p>A set of documents D is structurally finite (or sf for short) if (1) for any document d ∈ D and any d that is structurally equivalent to d, we have d ∈ D; (2) D consists only of finitely many ∼st-equivalence classes. That is, intuitively, if it contains a document d, then it contains also all documents that have the same structure, but different values, and it contains only finitely many structurally distinct documents.</p><p>Let D be an sf set of documents. We define a σ-algebra AD on D and then probabilities on AD by doing so first for each ∼st-class and then for D as a whole.</p><p>Let d0 = (t0, θ0) be a document, ¯ l := (l1, . . . , l k ) a tuple consisting of the leaf nodes of d0, and [d0]∼ st the equivalence class of d0 under ∼st. For every document d = (t, θ) with</p><formula xml:id="formula_18">d ∈ [d0]∼ st we define θ( ¯ l) := (θ(l1), . . . , θ(l k )) a k-tuple of real numbers.</formula><p>In fact, this mapping of tuples of leaf values to tuples of numbers is a bĳection between [d0]∼ st and R k , which we denote as β. The standard σ-algebra on R k is the algebra of Borel sets. We use β to introduce a σ-algebra A0 on [d0]∼ st . We say that D0 ∈ A0 for a set D0 ⊆ [d0]∼ st if and only if β maps D0 to a Borel set of R k . In the same vein, we can identify probability distributions over R k with distributions over [d0]∼ st . Note that, due to symmetry, the definition of A0 does not depend on the specific order of the leaves that is used by β. Now, suppose that D = n i=1</p><p>[di]∼ st and that Ai is the σ-algebra on [di]∼ st defined above. Then we define</p><formula xml:id="formula_19">AD := {D1 ∪ · · · ∪ Dn | Di ∈ Ai}.</formula><p>Clearly, since all the Ai are σ-algebras, AD is a σ-algebra. Moreover, suppose that for each equivalence class <ref type="bibr">[di]</ref>∼ st we have a probability distribution Pri and that p1, . . . , pn are convex coefficients (that is, pi 0 and p1 + · · · + pn = 1). Then we define for every D ∈ AD</p><formula xml:id="formula_20">Pr(D ) := n i=1 pi · Pri(D ∩ [di]∼ st ).</formula><p>Clearly, Pr is a probability on AD. Conversely, every probability Pr over (D, AD) can be uniquely decomposed into probabilities Pri over the ∼st-classes of D such that Pr can be obtained from the Pri as described above. Moreover, each Pri is essentially a probability over some R k .</p><p>p-documents. To support (possibly continuous) distributions on leaves, we extend the syntax of p-documents by an additional type of distributional nodes, the cont nodes. A cont node has the form cont(D), where D is a representation of a probability distribution over the real numbers. In 0.6 <ref type="bibr" target="#b10">[11]</ref> 0.25 0.75 <ref type="bibr">[56]</ref> [51]</p><p>[52]</p><p>[53]  contrast to the distribution nodes introduced earlier, a cont node can only appear as a leaf.</p><p>Example 25. Consider the PrXML cont,mux,det p-document in <ref type="figure" target="#fig_13">Figure 6</ref>. The document collects results of (e.g., temperature) monitoring by sensors sa, sb and sc. The data in the document are measurements at time 3 by sb and at time 5 by either sa or sc. At time 3 the measurement is either 17, or a value in the interval from 15 to 19. The fact the latter value is unknown and can be anywhere between 15 and 19 is represented by a continuous node cont(U ( <ref type="bibr">[15; 19]</ref>), where U stands for the uniform distribution. We know that both sensors sa and sc have an inherent imprecision and the real measurement is normally distributed around the one they sent. We model it by a continuous node with a normal distribution cont(N (25; 1)) with mean 25 and variance 1. </p><formula xml:id="formula_21">∞ −∞ f = 1</formula><p>is the density function of a probability. Clearly, in this case f |I 1 and f |Im are identical to 0. Note that distributions defined by piecewise polynomial densities are a generalization of uniform distributions. Piecewise polynomials are an example of a class of functions stable under convex sum, (classical) convolution, product, and integration. We shall use this stability property to compute the distribution of aggregate query answers.</p><p>When the symbol cont appears as a superscript of PrXML, possibly in combination with other symbols, it indicates a class of p-documents that have distributions on their leaves. The symbol cont can be used with class symbols like the three above as arguments to specify the kind of distributions that can appear. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Pi.</head><p>We define then a continuous probability distribution Pri over R k as the product distribution <ref type="bibr" target="#b4">[5]</ref> of the Dij's, i.e., the unique distribution such that</p><formula xml:id="formula_22">Pri(X1 × · · · × X k ) = Di1(X1) × · · · × D ik (X k ).</formula><p>Using the inverse of the bĳection β discussed earlier, Pri can be translated into a probability distribution over <ref type="bibr">[di]</ref>∼ st , the equivalence class of di under ∼st.</p><formula xml:id="formula_23">Let D = ∪ n i=1 [di]∼ st .</formula><p>We then define as already discussed the probability distribution Pr of P on the σ-algebra AD as:</p><formula xml:id="formula_24">Pr(D ) := n i=1 pi · Pri(D ∩ [di]∼ st ).</formula><p>Aggregating Continuous Probabilistic Data . Having defined the semantics of continuous p-documents, we now show how the results for aggregate queries obtained in the discrete case can be lifted to the continuous case. Our purpose here is not to give a comprehensive picture of the complexity, as in the discrete case, but to see what kind of tractability results can be obtained. Let us restrict ourself to monoid aggregate functions, and p-documents of PrXML cont,mux,det , which is our main case of tractability in the discrete case. For simplicity, we only deal with single-path queries.</p><p>The following result is at the basis of the tractability of monoid aggregate query evaluation in PrXML cont,mux,det . </p><formula xml:id="formula_25">(X, Y ) is F × G. 3. The cumulative distribution function of min(X, Y ) is F + G − F × G.</formula><p>Obviously, there is no hope of computing probabilities of aggregate query answers if it is not possible to somehow combine (either symbolically or numerically) the probability distributions of the leaves. The preceding result hints that if we are able to efficiently apply a number of basic operations on our probability distribution functions, we are able to compute the distribution of the min, max or sum. The following operations are required: convex sums (for mux nodes); convolution (for sum, in conjunction with det nodes); integration and multiplication (for min and max, in conjunction with det nodes). One simple case where we can perform these operations efficiently is when cont leaves are piece-wise polynomials of a bounded degree. For a fixed K &gt; 0 let PP(K) be the set of all piecewise polynomial probability distributions whose polynomials have degree K. It is reasonable to assume that such a bound K exists for every application. This bound ensures that the piecewise polynomial representing the distribution of the query answer has degree polynomial in the size of the document. Hence:</p><p>Theorem 27. For p-documents in PrXML cont,mux,det that are labeled with distributions in PP(K) we have:</p><p>1. The distribution of results of queries in SP sum can be computed in polynomial time in the combined size of the input and the output.</p><p>2. The distribution of results of queries in SP max and SP min can be computed in polynomial time. 3. All moments of results of queries in SP sum , SP max , and SP min can be computed in polynomial time.</p><p>Other results from the discrete case can be generalized to the continuous case. For example, it can be shown that moments of queries in TP sum can be computed in polynomial time over PrXML cont,mux,det (and similarly for SP sum and PrXML cont,cie ), by replacing the cont nodes by the expected value of the represented distribution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">RELATED WORK AND CONCLUSION</head><p>Related Work. The probabilistic XML models that have been proposed in the literature can be grouped in two main categories, depending on the kind of supported probabilistic dependencies: PrXML mux,det -like local dependencies <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b27">28]</ref>, or PrXML cie -like global dependencies <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b26">27]</ref>, in the spirit of c-tables <ref type="bibr" target="#b16">[17]</ref>. We used here the unifying framework of <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b18">19]</ref>.</p><p>The complexity of non-aggregate query answering over PrXML mux,det and PrXML cie has been investigated in <ref type="bibr">[19- 21, 27]</ref>. Several results presented here either extend or use these works. The dynamic-programming algorithm for computing the probability of a Boolean tree-pattern query from <ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b19">[20]</ref><ref type="bibr" target="#b20">[21]</ref> is in particular used for Claim 2 of Theorem 22. The same authors have also studied in <ref type="bibr" target="#b7">[8]</ref> the problem of treepattern query answering over PrXML mux,det documents with constraints expressed using aggregate functions, i.e., something similar to the HAVING queries of SQL. We use their results for proving Claim 2 of Theorem 21.</p><p>Only a few works have considered aggregate queries in a setting of incomplete data. In non-probabilistic settings aggregate queries were studied for conditional tables <ref type="bibr" target="#b21">[22]</ref>, for data exchange <ref type="bibr" target="#b3">[4]</ref> and for ontologies <ref type="bibr" target="#b5">[6]</ref>. In probabilistic settings, to the best of our knowledge, in addition to the aforementioned <ref type="bibr" target="#b7">[8]</ref>, only <ref type="bibr" target="#b25">[26]</ref> studies aggregate queries. Ré and Suciu consider the problem of evaluating HAVING queries (using aggregate functions) in "block-independent databases", which are roughly PrXML mux,det restricted to relations (limited-depth trees). The complexity bounds of Claim 3 of Theorem 21 use similar arguments than the corresponding results for block-independent databases presented in <ref type="bibr" target="#b25">[26]</ref>. In both <ref type="bibr" target="#b7">[8]</ref> and <ref type="bibr" target="#b25">[26]</ref>, the authors discuss the filtering of possible words that do not satisfy a condition expressed using aggregate functions, and do not consider the problem of computing the distribution of the aggregation, or moments thereof. Computation of the expected value of aggregate functions over a data stream of probabilistically independent data items is considered in <ref type="bibr" target="#b17">[18]</ref>. This is a simpler setting than ours, but we use similar techniques in the proof of Theorem 22.</p><p>There is very little earlier work on querying continuous probability distributions. The authors of <ref type="bibr" target="#b11">[12]</ref> build a (continuous) probabilistic model of a sensor network to run subsequent queries on the model instead of the original data. In <ref type="bibr" target="#b6">[7]</ref>, algorithms are proposed for answering simple classes of queries over uncertain information, typically given by a sensor network. As noted in a recent survey on probabilistic relational databases <ref type="bibr" target="#b10">[11]</ref>, "although probabilistic databases with continuous attributes are needed in some applications, no formal semantics in terms of possible worlds has been proposed so far". We proposed in Section 8 such a formal semantics.</p><p>Conclusion. We provided algorithms for, and a characterization of the complexity of, computing aggregate queries for both PrXML mux,det and PrXML cie models, i.e., very general and most interesting probabilistic XML models. We also considered the expected value and other moments, i.e., summaries of the probability distribution of the results of aggregate functions. In the case of PrXML mux,det , we have identified a fundamental property of aggregate functions, that of being monoid, that entails tractability. The complexity of aggregate computations in many cases has led us to introduce polynomial-time randomized approximation schemes. Finally, a last original contribution has been the definition of a formal continuous extension of probabilistic XML models. We have shown how some of the results of the discrete case can be adapted.</p><p>Because our work has many facets, it may be extended in a number of directions. First, we intend to implement a system that manages imprecise data with aggregate functions. In particular, we want the system to handle continuous probabilities, which are quite useful in practice. A main novelty of the present work is the use of continuous probabilities for data values. We are currently developing the theory in this direction. Finally, observe that although a p-document (with continuous probabilities) represents uncountably infinite possible worlds, they only have finitely many possible structural equivalence classes, and in particular, they all are of bounded height and width. It would be interesting to investigate extensions of the model without this restriction.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Document d: personnel in IT department.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Query: sum of bonuses for Mary.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: PrXML cie p-document: IT department.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Then the probability of d is Pr(d) = .75 × .9 × .7 = .4725. One can also obtain d from the p-document in Figure 3, assuming that Pr(x) = .85 and Pr(z) = .055, by assigning {x/1, z/1}. In this case the probability of d is Pr(d) = .85 × .055 = .04675.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: PrXML mux,det p-document: IT department.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Lemma 12 .</head><label>12</label><figDesc>Let Q be an SP-query with one free variable and let AGG = {sum, count, min, countd, avg}. For every propositional DNF formula ϕ, one can compute in polynomial time a p-document Pϕ ∈ PrXML cie such that the following are equivalent: (1) ϕ is falsifiable, (2) Pr(Q α (P) = 1) &gt; 0 over Pϕ for some α ∈ AGG, (3) Pr(Q α (P) = 1) &gt; 0 over Pϕ for all α ∈ AGG.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>represented by P ∈ PrXML cie . Lemma 17. There is a polynomial time algorithm that computes, given a p-document P ∈ PrXML cie and leaves v1, . . . , v k occurring in P, the probability Pr {d ∈ P | v1, . . . , v k occur in d} . Now we are ready to conclude the proof of the theorem. Proof. of Theorem 15.1 By Lemma 16, the k-th moment of sum over P is the sum of |V | k products, where V is the set of leaves of P. The first term of each product, k i=1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>query</head><label></label><figDesc>Q α over P to the evaluation of the function α over the document PQ. Note that PQ is again a mux-det document if P is one. Therefore, we can concentrate on the question of evaluating α over mux,det-documents.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 5 : Distribution of monoid functions over com- posed PrXML mux,det documents.</head><label>5</label><figDesc>Figure 5: Distribution of monoid functions over composed PrXML mux,det documents.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>As a consequence, α( Pv)(c), the probability that α has the value c over Pv, equals the weighted sum p1α( P1)(c) + · · · + pnα( Pn)(c) of the probabilities that α has the value c over P1, . . . , Pn. In a more compact notation we can write this as α( Pv) = p1α( P1) + · · · + pnα( Pn), which means that the distribution α( Pv) is a convex sum of the α( Pi). For the second induction step, suppose that v is a regular non-leaf node in P, with the label l. (see Figure 5, right). Similar to the previous case, suppose that the subtrees below v are P1, . . . , Pn, that Pv = (Dv, Prv) and that Pi = (Di, Pri) for 1 i n. Moreover, the Di are mutually disjoint. Every document d ∈ Dv has as root the node v, which car- ries the label l, and subtrees d1, . . . , dn, where di ∈ Di. We denote such a document as d = v l ({d1, . . . , dn}). Conversely, according to the semantics of regular nodes in mux-det docu- ments, every combination {d1, . . . , dn} of documents di ∈ Di gives rise to an element v l ({d1, . . . , dn}) ∈ Dv. (Note that, due to the mutual disjointness of the Di, the elements of Dv are in bĳection with the tuples in the Cartesian product D1 × · · · × Dn.) Consider a collection of documents di ∈ Di, 1 i n, with probabilities qi := Pri(di). Each di is the result of dropping some children of mux-nodes in Pi and qi is the product of the probabilities of the surviving children. Then d := v l (d1, . . . , dn) is the result of dropping simultaneously the same children of those mux-nodes, this time within Pv.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Corollary 19 .</head><label>19</label><figDesc>For any mux,det-document P, 1. the distributions count( P) and min( P) can be computed in time polynomial in | P|; 2. the distribution sum( P) can be computed in time poly- nomial in | P| + |sum( P)|.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>For the monoid of integers with addition, (1) is the same as the well-known discrete convolution. (2) is in fact a special case of a general principle: If X and Y are two M -valued random variables on the probability spaces X , Y, with distributions f , g, respectively, then the distribution of X ⊕ Y : X × Y → M is the convolution f * M g of f and g.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: PrXML cont,mux,det p-document: monitoring.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Any</head><label></label><figDesc>finitely representable distribution can appear in a cont node. As an example, we consider in the following piecewise polynomial distributions. A function f : R → R is piecewise polynomial if there are points −∞ = x0 &lt; x1 &lt; . . . &lt; xm = ∞ such that for each interval Ii := ]xi−1, xi[, 1 i m, the restriction f |I i of f to Ii is a polynomial. (The points x1, . . . , xn−1 are the partition points and the intervals I1, . . . , Im are the partition intervals of f .) Every piecewise polynomial function f 1 with</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>We define the semantics P of continuous p-documents of PrXML cont,cie,mux,det as a continuous px-space as defined earlier. More precisely, let P ∈ PrXML cont,cie,mux,det and P ∈ PrXML cie,mux,det be the p-document obtained from P by replacing every continuous node with an arbitrary value, say, 0. P is a (discrete) px-space ({d1 . . . dn}, {p1 . . . pn}) with pi = 1. For a given 1 i n, we consider the document Pi of PrXML cont obtained by putting back in di the continuous nodes of P, where the corresponding leaves still exist. Let Di1 . . . D ik be the k probability distributions over the real numbers represented in the cont nodes of</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Proposition 26 .</head><label>26</label><figDesc>Let X, Y be independent real-valued random variables with probability density functions f , g and cumulative distribution functions F , G (i.e., F = f , G = g). We have: 1. The density function of X + Y is f * g, the convolution of f and g. 2. The cumulative distribution function of max</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>P be in PrXML cie . If Q is an SP-query, we can apply it naively to P, ignoring the distributional nodes. The result PQ is the subtree of P containing the original root and as leaves the nodes satisfying Q (i.e., the nodes matched by the free variable of Q). Interestingly, it turns out that for all aggregate functions α, evaluating Q α over P is the same as applying α to PQ. If P is in PrXML mux,det , then PQ can be obtained analogously and, again, evaluating Q α over PQ can be reduced to evaluating α over PQ. Therefore, answering an aggregate SP-query Q α over P in PrXML cie,mux,det can be done in two steps, first one queries P with the non-aggregate part Q, which results in a p-document PQ, and then one aggregates all the leaves of PQ. The previous discussion leads to the following result. Proposition 7. Let Q[¯ n] be a non-aggregate SP-query.is faithful if α({|1| }) = 1.</head><label></label><figDesc></figDesc><table>Then for every p-document 

P ∈ PrXML cie,mux,det we can 

compute in time quadratic in |Q| + | 
P| a p-subdocument 

PQ 

of 

P such that for every aggregate function α we have: 

Q α ( 
P) = α( 

PQ). 

Hardness Results for Branching Queries. With the next 

lemma, we can translate data complexity results for non-
aggregate queries to lower bounds of the complexity of com-
puting probabilities of aggregate values and moments of dis-
tributions. An aggregate function α Lemma 8. Let Q be TPJ-query, 

P a p-document and α a 
faithful aggregate function. Then one can construct in linear 
time an aggregate TPJ-query Q 
α with the function α and a 

p-document 

P such that for any k 1, 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>sum, count, min, avg, and countd. Then computation of moments of any degree over PrXML cie is in FP #P for the class TPJ α . Moreover, the problem is 1. of polynomial combined complexity for the classes SP sum and SP count ; 2. #P-hard for any query in the classes SP min , SP avg and SP countd ; 3. #P-hard for some query in TP sum and TP count .</head><label></label><figDesc></figDesc><table>PrXML cie 
Aggregate query language 

SP 
TP 
TPJ 

Membership 
NP-c 
NP-c 
NP-c 

Probability 
FP #P -c 
FP #P -c FP #P -c 

Moments 
count, sum P 
others FP #P -c 
FP #P -c FP #P -c 

Table 1: Data complexity of query evaluation over 
PrXML cie . NP-c means NP-complete. 

We finally show how to compute moments over PrXML cie . 

Theorem 15 (Moments). Let α be one of </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>PrXML mux,det Aggregate query language SP, TP TPJ</head><label>PrXML</label><figDesc></figDesc><table>Membership 
sum, avg, countd NP-c 
count, min P 
count, min NP 

Probability 
avg, countd FP #P -c 
count, min P 
FP #P -c 

Probability 
SP 
TP 
FP #P -c 
(for sum) 
P  *  
FP #P 

SP 
TP 

Moments 
P 
avg FP #P 
others P 
FP #P -c 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Data complexity of query evaluation over 
PrXML mux,det . NP-c means NP-complete, NP means 
membership in NP and * means in the size of |in-
put|+|distribution|. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>Theorem 21 (Probability). Let α be one of sum, count, min, avg, and countd. Then probability computation over PrXML mux,det is in FP #P for the class TPJ α . Moreover, the problem is 1. of polynomial combined complexity for the classes SP min and SP count ; 2. of polynomial data complexity for any query in TP min and TP count ; 3. #P-hard for any query in SP avg and SP countd ; 4. #P-hard for some query in TPJ sum , TPJ count and TPJ min .</head><label>21</label><figDesc></figDesc><table></table></figure>

			<note place="foot" n="2"> We denote the labeling function for queries as λ in order to distinguish it from the labeling function θ for documents.</note>

			<note place="foot" n="3"> In [2], the root is also required to be ordinary. For technical reasons, we do not use that restriction here.</note>

			<note place="foot" n="4"> It may seem that using det nodes is redundant, but actually they increase the expressive power when used together with mux and other types of distributional nodes [2]: mux alone can express that subtrees are mutually exclusive, but in combination with det it can also express this on subforests.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Agrégation de documents XML probabilistes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T.-H</forename><forename type="middle">H</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kharlamov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Nutt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Senellart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. BDA</title>
		<meeting>BDA<address><addrLine>Namur, Belgium</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-10" />
		</imprint>
	</monogr>
	<note>Conference without formal proceedings</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On the expressiveness of probabilistic XML models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Senellart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1041" to="1064" />
			<date type="published" when="2009-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Querying and updating probabilistic information in XML</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Senellart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EDBT</title>
		<meeting>EDBT<address><addrLine>Munich, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Answering aggregate queries in data exchange</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">N</forename><surname>Afrati</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PODS</title>
		<meeting>PODS<address><addrLine>Vancouver, BC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Doléans-Dade. Probability &amp; Measure Theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename><surname>Ash</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<publisher>Academic Press</publisher>
			<pubPlace>San Diego, CA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Aggregate queries over ontologies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kharlamov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Nutt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Thorne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ONISW</title>
		<meeting>ONISW<address><addrLine>Napa, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Evaluating probabilistic queries over imprecise data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">V</forename><surname>Kalashnikov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Prabhakar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD</title>
		<meeting>SIGMOD<address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Incorporating constraints in probabilistic XML</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PODS, Vancouver</title>
		<meeting>PODS, Vancouver<address><addrLine>BC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Running tree automata on probabilistic XML</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PODS, Providence</title>
		<meeting>PODS, Providence<address><addrLine>RI, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Rewriting queries with arbitrary aggregation functions using views</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Nutt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TODS</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="672" to="715" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Probabilistic databases: Diamonds in the dirt</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Dalvi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ré</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">7</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Model-driven data acquisition in sensor networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Deshpande</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Guestrin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB</title>
		<meeting>VLDB<address><addrLine>Toronto, ON, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The complexity of query reliability</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Grädel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Gurevich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hirsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PODS</title>
		<meeting>PODS<address><addrLine>Seattle, WA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Probability inequalities for sums of bounded random variables</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hoeffding</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the American Statistical Association</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">301</biblScope>
			<biblScope unit="page" from="16" to="30" />
			<date type="published" when="1963" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">PXML: A probabilistic semistructured data model and algebra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Hung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Getoor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">S</forename><surname>Subrahmanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICDE</title>
		<meeting>ICDE<address><addrLine>Bangalore, India</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Hung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Getoor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">S</forename><surname>Subrahmanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Probabilistic interval XML. TOCL</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Incomplete information in relational databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Imieliński</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lipski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="761" to="791" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Efficient aggregation algorithms for probabilistic data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S</forename><surname>Jayram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Vee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SODA</title>
		<meeting>SODA<address><addrLine>New Orleans, LA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Query efficiency in probabilistic XML models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kosharovsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD</title>
		<meeting>SIGMOD<address><addrLine>Vancouver, BC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Query evaluation over probabilistic XML</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kosharovsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1117" to="1140" />
			<date type="published" when="2009-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Matching twigs in probabilistic XML</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB</title>
		<meeting>VLDB<address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Aggregate queries over conditional tables</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lechtenbörger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Shu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Vossen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Intelligent Information Systems</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="343" to="362" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">ProTDB: Probabilistic data in XML</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Nierman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB</title>
		<meeting>VLDB<address><addrLine>Hong Kong, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Addison Wesley</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computational Complexity</title>
		<meeting><address><addrLine>Reading, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">The complexity of counting cuts and of computing the probability that a graph is connected</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Provan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">O</forename><surname>Ball</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal of Computing</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="777" to="788" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Efficient evaluation of HAVING queries on a probabilistic database</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ré</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DBPL</title>
		<meeting>DBPL<address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">On the complexity of managing probabilistic XML data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Senellart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PODS</title>
		<meeting>PODS<address><addrLine>Beĳing, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A probabilistic XML approach to data integration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Van Keulen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>De Keĳzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Alink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICDE</title>
		<meeting>ICDE<address><addrLine>Tokyo, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-04" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
