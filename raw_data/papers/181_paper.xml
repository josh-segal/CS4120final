<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:32+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Expediting GA-Based Evolution Using Group Testing Techniques for Reconfigurable Hardware 1</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rashad</forename><forename type="middle">S</forename><surname>Oreifej</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">College of Electrical Engineering and Computer Science</orgName>
								<orgName type="institution">University of Central Florida Orlando</orgName>
								<address>
									<postCode>32816-2450</postCode>
									<region>FL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carthik</forename><forename type="middle">A</forename><surname>Sharma</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">College of Electrical Engineering and Computer Science</orgName>
								<orgName type="institution">University of Central Florida Orlando</orgName>
								<address>
									<postCode>32816-2450</postCode>
									<region>FL</region>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ronald</forename><forename type="middle">F</forename><surname>Demara</surname></persName>
							<email>demara@mail.ucf.edu</email>
							<affiliation key="aff0">
								<orgName type="department">College of Electrical Engineering and Computer Science</orgName>
								<orgName type="institution">University of Central Florida Orlando</orgName>
								<address>
									<postCode>32816-2450</postCode>
									<region>FL</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Expediting GA-Based Evolution Using Group Testing Techniques for Reconfigurable Hardware 1</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Autonomous repair and refurbishment of reprogrammable logic devices using Genetic Algorithms can improve the fault tolerance of remote mission-critical systems. The goal of increasing availability by minimizing the repair time is addressed in this paper using a CGT-pruned Genetic Algorithm. The proposed method utilizes resource performance information obtained using Combinatorial Group Testing (CGT) techniques to evolve refurbished configurations in fewer generations than conventional genetic algorithms. A 3-bit x 2-bit Multiplier circuit was evolved using both conventional and CGT-pruned genetic algorithms. Results show that the new approach yields completely refurbished configurations 37.6% faster than conventional genetic algorithms. In addition it is demonstrated that for the same circuit, refurbishment of partially-functional configurations is a more tractable problem than designing the configurations when using genetic algorithms as results show the former to take 80% fewer generations.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Fault tolerance, high reliability, and availability are major desired characteristics of a mission critical system. Harsh operating environments, manufacturing defects, and component aging are contributing causes of hardware faults that make realizing these characteristics difficult. Many hardware reliability approaches have been proposed in the literature such as fault avoidance, design margin, modular redundancy, and fault refurbishment <ref type="bibr" target="#b0">[1]</ref>. Fault avoidancebased design approaches aim to avoid possible faults that could occur at run time. Such approaches impose minimal size, weight, and power overheads. Meanwhile, design margin approaches rely on an increased number of redundant system components and capabilities to enhance reliability by designing with a margin for fault tolerance.</p><p>Despite the advantages of both the above approaches, anticipating all the possible faults before the system is operational is difficult. Modular redundancy approaches utilize multiple identical modules each of which is capable of delivering the desired functionality. These increase size, weight, and power consumption.</p><p>Additionally, the recovery capacity of these approaches is limited to the number and granularity of the available redundant modules. Fault refurbishment approaches, such as the proposed approach offer a very competitive option because of the high recovery capacity and adaptability to unforeseen faults. However, fault refurbishment is challenging due to the complexity involved in generating configurations for implementing fault-free digital circuits on reconfigurable devices.</p><p>Genetic Algorithms (GAs) <ref type="bibr" target="#b1">[2]</ref> are guided trial-and-error search techniques that use the principles of Darwinian evolution which target the survival of the fittest by casting a net over the entire solution space to find high fitness regions. The reprogrammability of Field Programmable Gate Arrays (FPGAs) provides an efficient platform highly suitable for evolutionary fault refurbishment experiments <ref type="bibr" target="#b2">[3]</ref>. In the event of faults in FPGAs, a GA can be used to search and implement alternate configurations that circumvent the faulty resource, thus providing device refurbishment.</p><p>This paper introduces the concept of improving the performance of GAs by generating and utilizing information regarding the location of faulty resources on FPGAs.</p><p>The main hypotheses presented in this paper are as follows:</p><p>Hypothesis 1: Knowledge regarding the location of hardware resource faults guides the GA search process to converge to complete repair in fewer generations than when the knowledge is unavailable.</p><p>In particular, information regarding the location of the fault effectively reduces the search space. The GA can also avoid creating and analyzing solutions that use the suspected faulty resource. Information regarding the location of the fault can be obtained using a Combinatorial Group Testing (CGT) <ref type="bibr" target="#b3">[4]</ref> based fault location algorithm.</p><p>Hypothesis 2: Realizing device refurbishment given a population of operational configurations is more tractable than designing a specified circuit without a population of partially or fully fit individuals.</p><p>In particular, in the case of repair, given a population of configurations which were fully operational before the occurrence of a fault, search beginning from locations in the fitness-space that are closer to the solution is assisted by the presence of good alleles in the individuals.</p><p>Formally, the Combinatorial Group Testing problem is defined as that of identifying a subset of d defectives from a set of n items. Items can be sampled, and subset of items, known as groups can be tested to identify the presence of defectives. Group testing techniques have been used in medical, chemical, and electrical testing, coding, drug screening, pollution control, multi-access channel management, and recently in data verification, clone library screening and blood testing. The fault location problem in FPGA logic elements closely approximates the generic group testing problem. A set of functionally-identical but physically-distinct configurations provide the groups, and evaluation of the outputs provides the tests for the identification of defectives in the groups-under-test. The accumulated correctness behavior of resources can be used to locate the physical resource fault. Once sufficient information is obtained regarding the location of the physical fault, it is passed on to the GA which can use the information to identify a refurbished solution.</p><p>The rest of the paper is organized as follows: Section 2 provides a quick overview of the related fault tolerance techniques. Section 3 introduces the CGT-pruned genetic algorithm. Section 4 discusses the experimental setup. Results and analysis are presented in Section 5 and Section 6 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related Work</head><p>Previous work on fault tolerance in FPGA-based systems varies from pre-defined design-time approaches, to completely adaptive GA-based repair approaches. In the pre-compiled column-based dual FPGA architecture approach <ref type="bibr" target="#b4">[5]</ref> pre-compiled FPGA configurations are utilized for error detection and fault-circumvention. These precompiled configurations have the same functional design but different placement and routing. Loading these configurations successively emulates shifting configurations' columns. The process continues until the column with the faulty resource is not used by the loaded configuration anymore. In this approach fault isolation is achieved by using distributed Concurrent Error Detection (CED) checkers while performing the blind reconfiguration. However, the repair process is not evolutionary and is limited by the number of available precompiled configurations. Also the solutions obtained might lead to a high subset of resources being excluded from the operational resources as the granularity of the solutions is high.</p><p>In <ref type="bibr" target="#b5">[6]</ref>, fault tolerance is accomplished by utilizing a voting system that votes among three functionally-identical modules.</p><p>Upon fault detection, the faulty module undergoes offline evolutionary repair without the need to perform fault isolation. Consequently, the faulty resources do not get identified and are not excluded from the repair process. This is in contrast to the proposed approach where the benefits of utilizing fault location information are demonstrated.</p><p>Other evolutionary approaches to fault tolerance include <ref type="bibr" target="#b6">[7]</ref> and <ref type="bibr" target="#b7">[8]</ref>, however, it is only in <ref type="bibr" target="#b8">[9]</ref> and <ref type="bibr" target="#b9">[10]</ref> that resource performance information is obtained, maintained and then used as feedback in the repair process. However, in <ref type="bibr" target="#b8">[9]</ref> it is the configuration performance information that is maintained rather than the performance of the resources themselves. In <ref type="bibr" target="#b9">[10]</ref> performance information at the resource level is maintained, however, this approach has issues such as a high fault detection latency, performance degradation in the absence of fault, and increased operational complexity.</p><p>In <ref type="bibr" target="#b10">[11]</ref>, the authors present results from the adaptation of various CGT algorithms for fault isolation in FPGAs. Runtime fault detection without using special test vectors is achieved by repeatedly comparing the outputs of configurations for discrepancies as described in <ref type="bibr" target="#b11">[12]</ref>. The presence of a faulty output ascertained using bit-wise output comparison with an ideal output provides information regarding the fitness of individual resources used by the configuration.</p><p>In the proposed CGT-pruned GA approach, resource performance information is obtained and resources suspected of being faulty are excluded from the evolutionary repair process leading to a repair within fewer generations. The resource performance information is provided by means of the CGT techniques described in <ref type="bibr" target="#b11">[12]</ref> where fault location is achieved by observing the discrepancy characteristics of the outputs of competing configurations using CED methods <ref type="bibr" target="#b4">[5]</ref>. The proposed approach does not require additional test vectors or data coding schemes. This is achieved by extending CGT techniques <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Enhancing</head><p>GA Performance using Information from CGT-based Testing</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Conventional GAs Applied to FPGAs</head><p>Genetic Algorithms perform guided search over the entire search space based on Darwinian evolution principles <ref type="bibr" target="#b1">[2]</ref>. The search for solutions is conducted by modifying and evaluating candidate individual solutions that together comprise a generation of solutions. Genetic operators such as mutation and crossover are applied to the bitstrings representing candidate solutions to modify the individuals. All individuals in a generation are evaluated using an exhaustive fitness function. This helps to identify the most competitive individuals, which then serve as the population from which the next generation of solutions are evolved. Over a number of generations of solutions, evolution perfects a fully-fit individual that exhibits the desired behavior.</p><p>Genetic Algorithms have been successfully used as an alternative design methodology to evolve digital circuits for implementation on FPGAs <ref type="bibr" target="#b12">[13]</ref>. More importantly, GAs provide an efficient paradigm to perform repair <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b13">[14]</ref> when failures occur in logic and/or interconnection resources without a-priori knowledge about the possible real-time fault scenarios. For the purposes of this paper, a conventional GA applied to these concepts is one which does not utilize information regarding the location of the faulty resource.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Group Testing based Fault Location</head><p>CGT algorithms are a class of solutions to the problem of identifying individual defective members from a large population by conducting a minimal number of tests on sub-groups or blocks of elements. The fault-location algorithm used in this paper is obtained from the Dueling with Modified Halving algorithm described in <ref type="bibr" target="#b11">[12]</ref>.</p><p>In this algorithm individual configurations are evaluated based on their output to identify discrepancies between the expected output and the observed output. The presence of an output discrepancy implies that the resources used by the configuration are suspect of being fault-affected. The set of all competing configurations is represented by S. Each competing configuration k, 1 &lt; k &lt; |S| has a unique binary Usage Matrix U k , 1 &lt; k &lt; p, with elements U k <ref type="bibr">[i,j]</ref>, 1 &lt; i &lt; m, 1 &lt; j &lt; n, where m and n represent the rows and columns in the device layout respectively. Elements complete when a single element in H has the maximum value in H. The output of the fault location procedure is the coordinates of the suspected-faulty resources. The CGT-pruned GA presented in this paper utilizes the output from the fault location procedure to avoid the suspected faulty resource during the process of searching for alternate solutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">CGT-pruned Genetic Algorithm</head><p>The CGT-pruned GA presented in this paper utilizes resource performance information obtained by using combinatorial group testing techniques. This information is incorporated within the GA to evolve faster refurbishment and consequently yield higher availability. In order to assess the advantages of the CGT-pruned genetic algorithms over previous methods, a simulator was created. The architecture of this simulator is shown in <ref type="figure">Figure 1</ref>. <ref type="table">Table   Seed</ref> Config. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Settings</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Truth</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fitness</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 1. Genetic Algorithm Simulator</head><p>The simulator is a C++ based console application that consists of two main components: the CGT procedure and the GA. The CGT algorithm uses the Gnu Scientific Library (GSL) and simulates the fault location method. The GA is implemented using an object oriented architecture that contains classes which model the FPGA resources with flexible geometries such as the Configurable Logic Block (CLB) and Look-Up <ref type="table">Table (</ref>LUT) classes, and others that model the GA such as Individual and Generation classes. When this simulator is run in the CGT-pruned GA mode, the CGT component simulates the desired FPGA chip and obtains resource performance information which is an input to the GA. The GA then performs evolutionary design or reads the Seed Configuration file and performs evolutionary repair according to the active mode of operation. In the Conventional GA mode, the CGT component is not invoked and no resource performance information is available to the GA.</p><p>The simulator has three input files as follows:</p><p>• Settings: This file contains all the parameterized settings that control the way the simulator works such as the geometry of the simulated FPGA chip, GA settings such as the population size and crossover rate, and the mode of operation.</p><p>• <ref type="table">Truth Table: This file contains the input/output truth  table for</ref> the circuit under evolution. This describes the desired behavior of a fully-fit configuration and is used to evaluate the correctness of the simulated circuit's outputs.</p><p>• Seed Configuration: This file contains the bitstream representation of the initial configuration that the GA should start with in case of repair, i.e. the faulty design that is sought to be repaired. This file is not required in the design mode of operation.</p><p>The following two output files are produced by the simulator:</p><p>• Fitness Report: This file contains the history of each generation of the GA process, detailing the maximum fitness of its best individual and its average fitness.</p><p>• Best Configuration: This file contains the bitstream representation of the configuration with the highest fitness the GA could evolve at the end of the run.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Experiments</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Design of Experiments</head><p>Three experiments, each targeting a different problem, were conducted to analyze differences between the CGTpruned GA and conventional GAs. The first involved comparing the performance of the two for repair. In the second, the CGT-pruned GA was enhanced using the cellswapping operator. The third experiment quantifies the differences in performance of the two for the problem of designing configurations from scratch. Also, by comparing results from the refurbishment and the design problem, the hypothesis that the repair problem is more tractable than the design problem can be verified. <ref type="figure">Figure 2</ref> shows two configurations on an FPGA, where the darker squares represent resources currently used by the configuration and the lighter squares represent the unused resources. The configuration shown on the left utilizes a resource that has been affected by a fault. This suspected faulty resource that has been identified using the CGT algorithm is indicated by a cross. In the CGT-pruned genetic algorithm, the faulty resource is isolated and is no longer regarded in the genetic operations that evolve a repair. Thus, all the faulty configurations which involve the faulty resource will be avoided. The crossover and mutation operators are used by the GA to modify the bitstring representation of the FPGA configurations. Crossover points can only occur on the CLB boundaries to prevent destructive intra-CLB crossover. The mutation operator is defined as probabilistic inversions of bits in the bitstring. A mutation might change either the functional logic implemented in the LUT, or the inter-LUT connections. <ref type="figure" target="#fig_2">Figure 3</ref>, shows on the left an FPGA configuration that utilizes a faulty resource. Using CGT, the faulty resource is identified as being suspect. As shown on the right, after the logic configuration of this suspected faulty resource is copied to another unused resource using the Cell Swapping GA operator. This additional operator replaces one LUT with another by copying its function, taking into account the inter-CLB interconnections.  <ref type="figure">Figure 4</ref> depicts FPGA circuit design using the CGTpruned GA in the presence of a faulty LUT. The faulty resource is no longer considered by the GA in creating the circuit. However, as opposed to using the GA for repair, a new configuration is evolved from scratch using a fitness function to direct the search towards a fully-fit realization. Since information by way of working designs is unavailable to the GA, this is shown to be a more difficult problem than the repair problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2. CGT-pruned Genetic Algorithm Repair</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 4. CGT-pruned Genetic Algorithm Design</head><p>A total of 120 experiments were conducted to explore the advantage of the CGT-pruned genetic algorithms in both repair and design problems in the presence of a randomly inject single stuck at one fault on the input of an LUT. Results have shown that CGT-pruned GA yields faster evolved solution for both cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Experimental Setup</head><p>In all the experiments, the circuit evolved was a 3-bit x 2-bit multiplier. Several attempts were made to evolve a 3-bit x 3-bit multiplier and 4-bit x 4-bit multiplier but neither a fully working design nor a fully working repair could be attained even after 300,000 generations due to the intractable problem size. Previously, successful evolution of a 3-bit x 3-bit Multiplier has been reported in <ref type="bibr" target="#b12">[13]</ref>. The parameters shown in <ref type="table" target="#tab_0">Table 1</ref> were used in all the experiments. The GA parameters were obtained by varying the parameters to optimize performance. Elitism, wherein two best-fit individuals are carried forward to the next generation without any genetic modification, is used to increase continuation of enhancements realized by the GA. A low crossover rate of 0.4 was chosen since it was observed that higher values were too disruptive to the exploration of alternate configurations.</p><p>Four types of experiments were conducted, and for each type, 30 identical experiments were carried out to ensure statistical significance.</p><p>In the first experiment, the multiplier was evolved from scratch in the presence of fault using conventional GA. The same experiment was then repeated using the CGT-pruned GA in the place of the conventional GA. In the repair experiments, the multiplier was repaired using the conventional GA, and then again using the CGT-pruned GA.</p><p>The simulated FPGA geometry through all the 120 different experiments has 15 Configurable Logic Blocks (CLBs) with each CLB containing four Look Up <ref type="table">Tables  (LUTs)</ref>. Each LUT has two inputs and one output which in turn can be configured to realize one of the OR, AND, NOR, NAND, NOT, and XOR basic logic functions. The interconnect follows a strict Feed-Forward topology architecture. The LUTs are numbered sequentially with the lowest numbers being connected to the inputs. The output of LUTs with higher index numbers cannot be the inputs of LUTs with numbers lower than them as described in <ref type="bibr" target="#b12">[13]</ref>. The fault simulated in the experiments was a single functional logic fault in one of the LUTs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Results and Analysis</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Fault Location using the CGT algorithm</head><p>In experiments involving the CGT-pruned GAs, fault location information was gained by using the CGT algorithm. The CGT algorithm used a simulated array of 15 CLBs, with 4 LUTs in each CLB. Thus each Usage Matrix, U k has 60 elements. A single functional fault was simulated in one of the 60 LUTs on the simulated FPGA. On average, over a set of 30 fault-isolation simulations, the procedure required only 12 evaluations to correctly identify the location of the fault, as denoted by a single element with the maximum value in the H matrix. The number of evaluations required by the fault-location algorithm is as low as 0.02% of the average number of generations required by the GA to design the circuit, and 0.11% of the average number of generations CGT-pruned GA takes to realize a complete refurbishment. Thus, the isolation procedure imposes a very low temporal overhead in exchange for the speedup obtained in the refurbishment process.</p><p>In order to evaluate the advantages of the CGT Pruning GA over the conventional GA, three statistical metrics are used: Arithmetic Mean, Standard Deviation, and  <ref type="table" target="#tab_1">Table 2</ref>. The experimental results listed in <ref type="table" target="#tab_1">Table 2</ref> show that the CGT-pruned GA yields a complete design after an average of 53,900 generations as opposed to the 64,500 generations required by the conventional GA.</p><p>However, this enhancement is not consistently substantial as shown by the relatively standard deviations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Repair</head><p>This experiment analyzes the effect of incorporating resource performance information in the GA for evolutionary repair. The results are listed in <ref type="table" target="#tab_2">Table 3</ref>. From <ref type="table" target="#tab_2">Table 3</ref>, and as shown in <ref type="figure" target="#fig_4">Figure 5</ref>, it is seen that the CGT-pruned GA yields substantially faster repair than the conventional GA. Again the range of the actual mean for a high confidence level is still wide, yet not as wide as in the design case. Since GAs in general have a probabilistic nature, the standard deviation is large which in turn widens the range of possible values the actual mean could fall within. The standard error of the mean can be reduced by increasing the number of experiments conducted. The 68% confidence interval ranges for the conventional and the CGT-pruned GAs do not intersect in the repair experiment which makes the results more statistically significant.  <ref type="figure">Figure 6</ref> compares the performance of the CGT-Pruned GA with that of a conventional GA for the 3-bit x 2-bit multiplier repair experiments. In experiment 15, the CGTpruned GA requires only 526 generations to realize a complete refurbishment, as opposed to the 66,735 required by the conventional GA, which corresponds to a 99.2% reduction. However, in about one third of the experiments, the CGT-pruned GA does not always outperform the conventional GA. For example, in experiment 25, the conventional GA performs the CGT-pruned GA by refurbishing the faulty configuration in 76.76% fewer generations. As listed in <ref type="table" target="#tab_2">Table 3</ref>, on average, the CGTpruned GA requires 10,700 generations as opposed to the 17,150 generations required by the conventional GA to realize complete configuration refurbishment. This confirms Hypothesis 1 at a 68% confidence level.  <ref type="figure" target="#fig_5">Figure 7</ref> shows repair progress of three runs which achieved repair within 1,200 generations, where a maximum fitness of 160 is attained at the end of 512 generations in the best case. It can be seen in general that the GA evolves to a relatively very high fitness within the first few hundreds generations, but it takes it significantly more generations to reach the maximum fitness.</p><p>In addition to the 3-bit x 2-bit multiplier, a 2-to-4 decoder was also designed and repaired using the CGTpruned GA. The experimental results show that the CGTpruned GA yields a complete design after an average of 152 generations as opposed to the 220 generations required by the conventional GA. In the refurbishment experiments, the CGT-pruned GA converges to a complete repair in 70 generations on an average, as compared to the 102 generations required by the conventional GA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusion</head><p>A new CGT-pruned genetic algorithm is presented that utilizes information of the LUT performance on the FPGA chip generated using combinatorial group testing. With regards to Hypothesis 1, experiments have quantified the benefit of the CGT-pruned genetic algorithm which yields a completely refurbished FPGA configuration in 37.6% fewer generations on average than a conventional GA. The CGT-pruned genetic algorithm is approximately 16% faster in the case of designing in the presence of a fault. Benefits of the CGT-pruned GA are more pronounced in repair than in design. This is related to the fact that the search space is reduced by eliminating faulty FPGA logic resources from the pool of unused resources in the case of repair.</p><p>Finally, with respect to Hypothesis 2, by comparing the results of the design and repair experiments, it is clear that refurbishment of reconfigurable devices is a more tractable problem for GAs than design. The CGT-pruned GA generates a refurbished FPGA configuration for a 3-bit x 2-bit multiplier 80% faster than it creates a new design. In the case of repair, the GA starts with partially-fit configurations, and thus a more tractable problem as opposed to design, where the GA has to build the configurations with no initial information or designs. The cell swapping operator plays a vital role by providing an effective way to re-route around the faulty resources.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>U k [i,j] = 1 denote the usage of resource (i, j) by configuration k. Discrepant outputs lead to a unit increment in the value of all H[i,j] where U k [i,j] = 1. The History Matrix H, with elements H[i,j] 1 &lt; i &lt; m, 1 &lt; j &lt; n, is an integer matrix used to represent the relative fitness of individual resources. In case of a single fault, fault location is</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>No. Of CLBs = ... No. LUTs = ... Pop. Size = … . . . I1 I2 ... O1 O2 ... 0 0 ... 0</head><label>0</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. CGT-pruned Genetic Algorithm Repair with cell-swapping</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Confidence Level.</head><label></label><figDesc>The Arithmetic Mean, µ x , quantifies the average for a set of n samples {x k }, and is calculated as:The Standard Deviation, x σ , provides a measure of statistical dispersion to analyze the range of variation in the results. Given a set of samples {x k }, it is calculated using:The Confidence Level, CL , is the probability measure of the incidence when the actual mean falls within a certain interval as follows:where x SEM is the Standard Error of the Mean for a set of samples {x k }, and is calculated as follows: n SEM x x σ = 5.2. Design in the presence of fault A 3-bit x 2-bit multiplier was designed in the presence of a faulty LUT by a conventional GA and the CGT-pruned GA. The results are listed in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Repair Progress: CGT-pruned vs. Conventional GA</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 .</head><label>7</label><figDesc>Figure 6. CGT-pruned vs. Conventional GA Repair</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><head>Table 1 . GA Parameters</head><label>1</label><figDesc></figDesc><table>CLBs 
15 

LUTs/CLB 
4 

Population Size 
25 

Mutation Rate 
0.05 

Crossover Rate 
0.4 

Tournament Size 
6 

Elitism 
2 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 2 .</head><label>2</label><figDesc></figDesc><table>Design of a 3-bit x 2-bit Multiplier in the 
Presence of a Fault 

Experiment Type 
Conventional 
design 

CGT-pruned 
design 

Circuit 
3-bit x 2-bit 
Multiplier 

3-bit x 2-bit 
Multiplier 

Number of Experiments 
30 
30 

Arithmetic Mean 
(Generations) 
64500 
53900 

Standard Deviation 
36000 
37300 

Standard Error of the 
Mean 
7200 
7450 

68% Confidence Interval 
[57300 → 71700] 
[46450 → 61350] 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><head>Table 3 . Repair of a 3-bit x 2-bit Multiplier</head><label>3</label><figDesc></figDesc><table>Experiment Type 
Conventional 
Repair 

CGT-pruned 
Repair 

Circuit 
3-bit x 2-bit 
Multiplier 

3-bit x 2-bit 
Multiplier 

Number of Experiments 
30 
30 

Arithmetic Mean 
(Generations) 
17150 
10700 

Standard Deviation 
15650 
12550 

Standard Error of the 
Mean 
2850 
2300 

68% Confidence Interval 
[14300 → 20000] 
[8400 → 13000] 

</table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Detecting, diagnosing, and tolerating faults in SRAM-based field programmable gate arrays: a survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Doumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Ito</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="386" to="405" />
			<date type="published" when="2003-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Holland</surname></persName>
		</author>
		<title level="m">Adaptation in Natural and Artificial Systems</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Exploring FPGA structures for evolving fault tolerant hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">P</forename><surname>Shanthi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Parthasarathi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NASA/DoD Conference on Evolvable Hardware</title>
		<meeting><address><addrLine>Chicago, Illinois, 9</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-07-11" />
			<biblScope unit="page" from="174" to="181" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Combinatorial Group Testing and its Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">K</forename><surname>Hwang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">of Series on Applied Mathematics</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="volume">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Column-Based Precompiled Configuration Techniques for FPGA</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename><surname>Mccluskey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">proc. The 9th Annual IEEE Symposium on FieldProgrammable Custom Computing Machines (FCCM&apos;01)</title>
		<meeting>The 9th Annual IEEE Symposium on FieldProgrammable Custom Computing Machines (FCCM&apos;01)</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="137" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Evolutionary Fault Repair in Space Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Vigander</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dep. of Computer &amp; Information Science</title>
		<imprint>
			<date type="published" when="2001" />
			<publisher>NTNU</publisher>
		</imprint>
		<respStmt>
			<orgName>Norwegian University of Science and Technology</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Masters Thesis</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Evolutionary fault recovery in a Virtex FPGA using a representation that incorporates routing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Larchev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">F</forename><surname>Demara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">proc. Parallel and Distributed Processing Symposium</title>
		<meeting>Parallel and Distributed Processing Symposium</meeting>
		<imprint>
			<date type="published" when="2003-04" />
			<biblScope unit="page" from="22" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Low overhead fault-tolerant FPGA systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">H</forename><surname>Mangione-Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Potkonjak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Very Large Scale Integration (VLSI) Systems, IEEE Transactions</title>
		<imprint>
			<date type="published" when="1998-06" />
			<biblScope unit="volume">6</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Autonomous FPGA Fault Handling through Competitive Runtime Reconfiguration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">F</forename><surname>Demara</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">proc. NASA/DoD Conference on</title>
		<meeting>NASA/DoD Conference on</meeting>
		<imprint>
			<date type="published" when="2005-06" />
			<biblScope unit="page" from="29" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Roving Stars: An Integrated Approach To On-Line Testing, Diagnosis, And Fault Tolerance For FPGAs In Adaptive Computing Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Abramovici</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Emmert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename><surname>Stroud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">proc. The Third NASA/DoD Workshop on Evolvable Hardware</title>
		<meeting>The Third NASA/DoD Workshop on Evolvable Hardware<address><addrLine>Long Beach, Cailfornia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Combinatorial Group Testing Methods for the BIST Diagnosis Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Reda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">proc. Asia and South Pacific Design Automation Conference</title>
		<meeting>Asia and South Pacific Design Automation Conference</meeting>
		<imprint>
			<date type="published" when="2004-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Combinatorial Group Testing Method for FPGA Fault Location</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">F</forename><surname>Demara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">proc. International Conference on Advances in Computer Science and Technology (ACST 2006)</title>
		<meeting>International Conference on Advances in Computer Science and Technology (ACST 2006)<address><addrLine>Puerto Vallarta, Mexico</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-01" />
			<biblScope unit="page" from="23" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Designing Electronic Circuits Using Evolutionary Algorithms. Arithmetic Circuits: A Case Study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">F</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Thomson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Fogarty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms and Evolution Strategy in Engineering and Computer Science</title>
		<editor>D. Quagliarella, J. Periaux, C. Poloni, and G. Winter</editor>
		<imprint>
			<biblScope unit="page" from="105" to="131" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Consensus-based Evaluation for Fault Isolation and On-line Evolutionary Regeneration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">F</forename><surname>Demara</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A</forename><surname>Sharma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">proc. International Conference in Evolvable Systems (ICES&apos;05)</title>
		<meeting>International Conference in Evolvable Systems (ICES&apos;05)<address><addrLine>Barcelona, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="12" to="24" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
