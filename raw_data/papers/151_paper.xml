<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:31+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Tight Bounds for Asynchronous Randomized Consensus * (Preliminary Version) General Terms</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>June 11-13, 2007,</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hagit</forename><surname>Attiya</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="institution">Technion Haifa</orgName>
								<address>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keren</forename><surname>Censor</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Technion Haifa</orgName>
								<address>
									<region>California</region>
									<country>Israel, USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Tight Bounds for Asynchronous Randomized Consensus * (Preliminary Version) General Terms</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published">June 11-13, 2007,</date>
						</imprint>
					</monogr>
					<note>* This research is supported by the Israel Science Foundation (grant number 953/06). Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. STOC&apos;07, 978-1-59593-631-8/07/0006 ...$5.00.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D13 [Software]: Programming Techniques-Concurrent programming</term>
					<term>F2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity</term>
					<term>G3 [Mathematics of Computing]: Probability and Statistics-Stochastic processes Algorithms, Theory Keywords distributed computing, shared-memory, lower bound, ran- domized algorithms, isoperimetric inequality</term>
				</keywords>
			</textClass>
			<abstract>
				<p>A distributed consensus algorithm allows n processes to reach a common decision value starting from individual inputs. Wait-free consensus, in which a process always terminates within a finite number of its own steps, is impossible in an asynchronous shared-memory system. However, consensus becomes solvable using randomization when a process only has to terminate with probability 1. Randomized consensus algorithms are typically evaluated by their total step complexity, which is the expected total number of steps taken by all processes. This work proves that the total step complexity of ran-domized consensus is Θ(n 2) in an asynchronous shared memory system using multi-writer multi-reader registers. The bound is achieved by improving both the lower and the upper bounds for this problem. In addition to improving upon the best previously known result by a factor of log 2 n, the lower bound features a greatly streamlined proof. Both goals are achieved through restricting attention to a set of layered executions and using an isoperimetric inequality for analyzing their behavior. The matching algorithm decreases the expected total step complexity by a log n factor, by leveraging the multi-writing capability of the shared registers. Its correctness proof is facilitated by viewing each execution of the algorithm as a stochastic process and applying Kolmogorov&apos;s inequality.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Coordinating the actions of processes is crucial for virtually all distributed applications, especially in asynchronous systems. At the core of many coordination problems is the need to reach consensus among processes, despite the possibility of process failures. A (binary) consensus algorithm allows processes starting with input values in {0, 1} to agree on the same output value (agreement); to rule out trivial solutions, this common output must be one of the inputs (validity). Consensus is a fundamental task in asynchronous systems, and can be employed to implement arbitrary concurrent objects <ref type="bibr" target="#b20">[21]</ref>; consensus is also a key component of the state-machine approach for replicating services <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b27">28]</ref>.</p><p>Perhaps the most celebrated result in distributed computing shows that no deterministic algorithm can achieve consensus in an asynchronous system, if one process may fail <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b22">23]</ref>. Due to the importance of the consensus problem, much research was invested in trying to circumvent this impossibility result. One successful approach is to allow randomized algorithms in which a nonfaulty process terminates only with probability 1. (The agreement and validity properties remain the same.) Randomized consensus algorithms are typically evaluated by their total step complexity, which is the expected total number of steps taken by all processes.</p><p>Many randomized consensus algorithms have been suggested, in different communication models and under various assumptions about the adversary (see <ref type="bibr" target="#b3">[4]</ref>). In particular, algorithms were designed to solve randomized consensus in asynchronous shared-memory systems, against a strong adversary that can observe the results of local coin flips before scheduling the processes <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b25">26]</ref>. The total step complexity of the best previously known algorithm is O(n 2 log n) <ref type="bibr" target="#b12">[13]</ref>. A lower bound of Ω( n 2 log 2 n ) on the expected total number of coin flips was proved by Aspnes <ref type="bibr" target="#b2">[3]</ref>; this implies the same lower bound on the total step complexity.</p><p>Closing the gap of Θ(log 3 n) between the lower and the upper bounds and determining the total step complexity of randomized consensus remained an intriguing open question.</p><p>In this paper, we prove that Θ(n 2 ) is a tight bound on the total step complexity of solving randomized consensus under the strong adversary in asynchronous shared memory systems, where processes communicate by reading and writing to multi-writer multi-reader registers.</p><p>The Ω(n 2 ) lower bound is obtained by considering a restricted set of schedules with a round-based structure, called layers <ref type="bibr" target="#b24">[25]</ref>. We focus on configurations at the end of each layer and classify them according to their valence <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b24">25]</ref>, namely, the decisions that can be reached in layered extensions. As opposed to deterministic algorithms, where the valence of a configuration binds the extension to reach a certain decision value v, in a randomized algorithm the valence only implies that some execution will decide v with high probability <ref type="bibr" target="#b2">[3]</ref>. This introduces a category of null-valent configurations, from which no decision value is reached with high probability. When a decision is reached, the configuration must be univalent, so the proof aims to avoid univalent configurations. An important case in the proof is when the configuration is null-valent, where we derive an isoperimetric inequality in order to control a one-round coin-flipping game for reaching another null-valent configuration.</p><p>To show that the lower bound is tight, we present a randomized algorithm for consensus, which has an O(n 2 ) total step complexity. We give a shared coin algorithm with a constant agreement parameter, which leverages a single binary multi-writer register (in addition to n single-writer multireader registers); this can be used to obtain a randomized consensus algorithm with the same total step complexity <ref type="bibr" target="#b4">[5]</ref>. We prove that all processes output the same value with high probability by viewing any schedule of the algorithm as a stochastic process, and applying Kolmogorov's inequality.</p><p>Related Work. The previous Ω( n 2 log 2 n ) lower bound <ref type="bibr" target="#b2">[3]</ref> relies on a lower bound for coin flipping games. In this proof, the adversary schedules processes step-by-step, and the results of the games are analyzed through hyperbolic functions, resulting in a long and unwieldy proof. In contrast, our approach considers only the configurations at the end of layers, allowing powerful results about product probability spaces to be applied, and streamlining the analysis of the behavior of executions.</p><p>Our general proof structure follows a proof by Bar-Joseph and Ben-Or <ref type="bibr" target="#b11">[12]</ref> of an Ω( p n/ log n) lower bound on the expected number of rounds in a randomized consensus algorithm for the synchronous message passing model. In particular, like them, we treat null-valent configurations by considering one-round coin-flipping games and applying an isoperimetric inequality. Unlike their proof, our proof handles the more complicated shared-memory model and exploits the fact that in an asynchronous system, processes can be hidden in a one-round coin flipping game without having to fail for the rest of the execution.</p><p>The layered approach was introduced by Moses and Rajsbaum <ref type="bibr" target="#b24">[25]</ref>, who used it to study deterministic consensus. They showed that the layered approach can unify the impossibility proof for asynchronous consensus <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b22">23]</ref> with the lower bound on the number of rounds needed for solving synchronous consensus <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b18">19]</ref>. Their work considered the message-passing model as well as the shared-memory model with single-writer registers. We take the layered approach one step further and extend it to randomized algorithms, deriving the lower bound on their total step complexity within the same framework as the results for deterministic algorithms. Besides incorporating randomization into the layered model, our proof also deals with the technical challenge of allowing processes to access multi-writer registers.</p><p>Abrahamson <ref type="bibr" target="#b0">[1]</ref> presented a randomized algorithm for solving consensus in asynchronous systems using shared memory, which had an exponential running time. The first polynomial algorithm for solving randomized consensus was presented by Aspnes and Herlihy <ref type="bibr" target="#b4">[5]</ref>. They described an algorithm that uses a shared coin in order to reach agreement and has a total step complexity of O(n 4 ). The amount of shared memory required by this algorithm was later bounded by Attiya, Dolev and Shavit <ref type="bibr" target="#b6">[7]</ref>. Aspnes <ref type="bibr" target="#b1">[2]</ref> presented an algorithm for randomized consensus with O(n 4 ) total step complexity, which also uses bounded space. These algorithms were followed by an algorithm of Saks, Shavit and Woll <ref type="bibr" target="#b25">[26]</ref> with O(n 3 ) total step complexity and later, an algorithm of Bracha and Rachman <ref type="bibr" target="#b12">[13]</ref> with O(n 2 log n) total step complexity.</p><p>Organization. In Section 2, we adapt the layered model to incorporate randomization and a strong adversary. Section 3 defines the key notions used in our lower bound proofpotence and valence-and proves that layered executions in the multi-writer shared-memory model are potence connected. The lower bound proof appears in Section 4, while Section 5 presents the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">LAYERED MODEL FOR RANDOM-IZED DISTRIBUTED ALGORITHMS</head><p>We consider a standard model of an asynchronous sharedmemory system, where n processes, p1, . . . , pn, communicate by reading and writing to shared multi-writer multi-reader registers (cf. <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b23">24]</ref>).</p><p>Each step consists of some local computation, including an arbitrary number of local coin flips (possibly biased) and one shared memory event, which is a read or a write to some register.</p><p>A configuration C consists of the local states of all the processes, and the values of all the registers. Like many impossibility results, our proof relies on having configurations that are indistinguishable to all processes, except some set P . We denote C ¬P ∼ C if the state of all processes that are not in P is equal in both C and C , and the values of all the registers are equal. We write C ¬p ∼ C when P = {p}. For the purpose of the lower bound, we restrict our attention to a constrained set of executions, which proceed in layers. An f -layer is a sequence of at least n − f distinct process id's. When executing a layer L, each process p ∈ L takes a step, in the order specified by the layer.</p><p>An f -execution τ = L 1 , L 2 , · · · is a (finite or infinite) sequence of f -layers. We will consider only configurations that are reachable by finite f -executions, namely, after some finite sequence of f -layers.</p><p>Since we consider randomized algorithms, for each configuration C there is a fixed probability for every step a process will perform when next scheduled. Denote by X C i the probability space of the steps that process pi will preform, if scheduled by the adversary. The probability space X C i depends only on the local state of p i in configuration C, and therefore, delaying p i does not change this probability space. Let X C = X C 1 × X C 2 × · · · × X C n be the product probability space. An element y ∈ X C represents a possible result of the local coin flips from a configuration C.</p><p>We assume a strong adversary that observes the processes' local coin flips, and chooses the next f -layer knowing what is the next step each process will take. The adversary applies a function σ to choose the next f -layer to execute for each configuration C and y ∈ X C , i.e.,</p><formula xml:id="formula_0">σ : {(C, y) | C is a configuration and y ∈ X C } → {L | L is a layer}.</formula><p>When the configuration C is clear from the context we will use the abbreviation σ( y) = L y . Denote by (C, y, L y ) the configuration that is reached by applying steps of the processes in L y , after a specific y ∈ X C is chosen. Then C • σ is a random variable whose values are the configurations (C, y, L y ), when y is drawn from the probability space X C .</p><p>An f -adversary α = σ 1 , σ 2 , · · · is a (finite or infinite) sequence of functions.</p><p>Given a configuration C and a finite prefix α = σ 1 , σ 2 , · · · , σ of the adversary α, C • α is a random variable whose values are the configurations that can be reached by the algorithm. For every y 1 ∈ X C let P ( y 1 ) = Pr[ y1 is chosen] denote the probability of y1 in the probability space X C . The probability that a configuration C is reached is defined inductively 1 :</p><formula xml:id="formula_1">Pr[C • α is C ] = X y 1 ∈X C P ( y 1 ) · Pr[(C, y 1 , L y 1 ) • α is C ],</formula><p>where α is the remainder of the prefix after σ1, i.e., α = σ 2 , · · · σ , and the basis of the induction for α 1 = σ 1 is:</p><formula xml:id="formula_2">Pr[C • α1 is C ] = X y 1 ∈X C P ( y1) · χ C ( y1),</formula><p>where χ C ( y1) = χ C (C, α1, y1) characterizes whether the configuration C is reached if y1 is chosen, i.e.,</p><formula xml:id="formula_3">χ C ( y 1 ) =  1 (C, y1, L y 1 ) is C 0 otherwise</formula><p>The probability of deciding v when executing the algorithm under α from the configuration C is defined as follows: if C is a configuration in which there is a de-</p><formula xml:id="formula_4">cision v, then Pr[decision from C under α is v] = 1, if C is a configuration in which there is a decision ¯ v, then Pr[decision from C under α is v] = 0, otherwise, Pr[decision from C under α is v] = X y 1 ∈X C P ( y1) · Pr[decision from (C, y1, L y 1 ) under α is v],</formula><p>where α is the remainder of the adversary after σ 1 , i.e.,</p><formula xml:id="formula_5">α = σ 2 , σ 3 , · · · .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">POTENCE AND VALENCE OF CONFIGURATIONS</head><p>In order to derive our lower bound, we are interested in the probability of reaching each of the possible decision values, from a given configuration. As the algorithm proceeds towards a decision, we expect the probability of reaching a decision to grow, where for a configuration in which a decision is reached, this probability is 1. Let k ≥ 0 be an integer, and define</p><formula xml:id="formula_6">k = 1 n √ n − k (n − f ) 3 .</formula><p>Our proof makes use of adversaries that have a probability of 1 − k for reaching a certain decision value. As the layer number k increases, the value of k decreases, and the probability 1 − k required for a decision grows.</p><p>An adversary with a high probability of deciding is defined as follows.</p><formula xml:id="formula_7">Definition 1. An f -adversary α from a configura- tion C that is reachable from an initial configuration by an f -execution with k ≥ 0 layers, is v-deciding if Pr[decision from C under α is v] &gt; 1 − k .</formula><p>Next, we classify configurations according to the probabilities of reaching each of the possible decisions from them. We adapt the notion of potence <ref type="bibr" target="#b24">[25]</ref> to fit randomized algorithms.</p><p>Instead of considering all possible adversaries, we further restrict our attention to a certain subset of them, which will be specified later.</p><formula xml:id="formula_8">Definition 2. A configuration C is (v, k, S)-potent, for v ∈ {0, 1} and a set S of f -adversaries, if there is a v- deciding adversary α ∈ S from C. Definition 3. A configuration is (v, k, S)-valent if it is (v, k, S)-potent but not (¯ v, k, S)-potent. Such a configuration is (k, S)-univalent. A configuration is (k, S)-bivalent if it is both (0, k, S)- potent and (1, k, S)-potent. A configuration is (k, S)-null-valent if it is neither (0, k, S)-potent nor (1, k, S)-potent.</formula><p>We often say that C is v-potent (v-valent, bivalent, nullvalent) with respect to S. <ref type="figure" target="#fig_0">Figure 1</ref> illustrates the valence of configurations.</p><p>Note that a configuration can have certain valency with respect to one set of adversaries S and another valency with respect to another set S . For example, it can be univalent with respect to S and null-valent with respect to S ; however, this cannot happen when S ⊆ S . (Another example appears in Lemma 1 below.) We will sometimes use the notation v-potent or v-valent, when the set S and the layer number k are clear from the context.</p><p>The set of f -adversaries we consider, denoted SP , is induced by a subset of processes P ⊆ {p1, . . . , pn}. A layer is P -free, for some set of processes P , if it does not include any process p ∈ P . An adversary α is in S P , if all of the layers it may choose are P -free. A layer is full with respect to SP if it contains the n − |P | distinct process identifiers {p1, . . . , pn} \ P ; otherwise, the layer is partial.</p><p>Restricting a set of adversaries can only eliminate possible adversaries, and therefore cannot introduce potence that does not exist in the original set of adversaries, as formalized in the following simple lemma.</p><p>Lemma 1. If a configuration C is v-valent with respect to S P , then it is not ¯ v-potent with respect to S P ∪{p} for any process p. Proof. Assume towards a contradiction, that there is a process p such that C is ¯ v-potent with respect to S P ∪{p} . Then there exists a ¯ v-deciding adversary α in S P ∪{p} , i.e.,</p><formula xml:id="formula_9">6 - 1 − k 1 − k 1 1 max α Pr[decision from C under α is 0]</formula><formula xml:id="formula_10">Pr[decision in C • α is ¯ v] &gt; 1 − k .</formula><p>But α is also an adversary in SP because S P ∪{p} ⊆ SP , which implies that C is ¯ v-potent also with respect to SP , contradicting the fact that C is v-valent with respect to SP .</p><p>Let C be a configuration, and fix y1 ∈ X C . We consider the configurations that can be reached by applying different layers. We define a relation between these configurations, based on their potence, which generalizes notions suggested by Moses and Rajsbaum <ref type="bibr" target="#b24">[25]</ref>.</p><p>Definition 4. For a given y1, configurations (C, y1, L) and (C, y1, L ) have shared potence with respect to SP , if they are both v-potent with respect to SP for some v ∈ {0, 1}.</p><p>Definition 5. For a given y1, configurations (C, y1, L) and (C, y1, L ) are potence connected with respect to SP , if there is a sequence of layers L = L0, L1, . . . , L h = L such that for every i, 0 ≤ i &lt; h, there exists a process p such that the configurations (C, y1, Li) and (C, y1, Li+1) have shared potence with respect to S P ∪{p} .</p><p>Note that potence connectivity is a transitive relation. Also, if (C, y1, L) and (C, y1, L ) have shared potence with respect to S P ∪{p} for some process p, then, in particular, they are potence connected.</p><p>The following claims show specific configurations that are potence connected, under the assumption that for every process p and layer L, the configuration (C, y1, L) is univalent with respect to SP and S P ∪{p} . This implies that</p><formula xml:id="formula_11">if (C, y1, L) ¬P ∪{p} ∼ (C, y1, L ), then (C, y1, L) and (C, y1, L )</formula><p>have shared potence with respect to S P ∪{p} , since they must have the same valence with respect to S P ∪{p} , but are not null-valent.</p><formula xml:id="formula_12">Claim 2. If L = [pi 1 , pi 2 , . . . , pi ]</formula><p>is a layer where for some j, 1 ≤ j &lt; , pi j and pi j+1 both write to the same register R, and</p><formula xml:id="formula_13">L = [pi 1 , . . . , pi j−1 , pi j+1 , . . . , pi ] is the layer L after removing pi j , then (C, y1, L) and (C, y1, L ) have shared potence with respect to S P ∪{p i j } . Proof. It is clear that (C, y1, L) ¬P ∪{p i j } ∼ (C, y1, L )</formula><p>, which implies that (C, y1, L) and (C, y1, L ) have shared potence with respect to S P ∪{p i j } .</p><formula xml:id="formula_14">Claim 3. If L = [pi 1 , pi 2 , . . . , pi ] is a layer, p is a pro- cess not in L, and L = [pi 1 , pi 2 , . . . , pi , p]</formula><p>is the layer L after adding p at the end, then (C, y1, L) and (C, y1, L ) have shared potence with respect to S P ∪{p} .</p><p>Proof. If p performs a read operation, then <ref type="bibr">(C, y1, L)</ref> ¬P ∪{p} ∼ (C, y1, L ), which implies that these two configurations have shared potence with respect to S P ∪{p} , and the claim follows.</p><p>If p performs a write operation to register R, then the states of all processes not in P ∪{p} are the same in (C, y1, L) and in (C, y1, L ), but the value of R may be different.</p><p>If (C, y1, L) and (C, y1, L ) do not have shared potence with respect to S P ∪{p} , then since we assume they are univalent with respect to S P ∪{p} , we have that for some v ∈ {0, 1}, (C, y1, L) is v-valent with respect to S P ∪{p} and (C, y1, L ) is ¯ v-valent with respect to S P ∪{p} . In particular, there is a ¯ v-deciding adversary α ∈ S P ∪{p} from (C, y1, L ). Adding p at the beginning of α yields a ¯ vdeciding adversary from (C, y1, L), which is in SP . However, by Lemma 1, (C, y1, L) is v-valent with respect to SP , which is a contradiction.</p><formula xml:id="formula_15">Claim 4. If L = [pi 1 , pi 2 , . . . , pi ] is a layer and L = [pi 1 , . . . , pi j−1 , pi j+1 , pi j , pi j+2 , . . . , pi ]</formula><p>is the layer L after swapping pi j and pi j+1 , then (C, y1, L) and (C, y1, L ) are potence connected with respect to SP .</p><p>Proof. If pi j and pi j+1 access different registers or if they</p><formula xml:id="formula_16">both read, then (C, y1, L) ¬P ∼ (C, y1, L ). If pi j reads register R and pi j+1 writes to R, then (C, y1, L) ¬P ∪{p i j } ∼ (C, y1, L )</formula><p>. Both cases imply that (C, y1, L) and (C, y1, L ) are potence connected with respect to SP . The remaining case is when pi j and pi j+1 both write to the same register R, which is proved by reverse induction on j.</p><p>Basis:</p><formula xml:id="formula_17">If j = −1, let L0 = L, L1 = [pi 1 , . . . , pi −2 , pi</formula><p>] be the layer L after removing pi −1 , and L2 = L . By Claim 2, (C, y1, L0) and (C, y1, L1) are potence connected with respect to SP , and by Claim 3, (C, y1, L1) and (C, y1, L2) are potence connected with respect to SP . By the transitivity of potence connectivity, this implies that (C, y1, L0) and (C, y1, L2) are potence connected with respect to SP .</p><p>Induction step: Let</p><formula xml:id="formula_18">L0 = L = [pi 1 , pi 2 , . . . , pi ]</formula><p>and</p><formula xml:id="formula_19">L1 = [pi 1 , . . . , pi j−1 , pi j+1 , pi j+2 , . . . , pi ]</formula><p>be the layer L0 after removing pi j . By Claim 2, (C, y1, L0) and (C, y1, L1) are potence connected with respect to SP . Let</p><formula xml:id="formula_20">L2 = [pi 1 , . . . , pi j−1 , pi j+1 , pi j+2 , . . . , pi , pi j ]</formula><p>be the layer L1 after adding pi j at the end. By Claim 3, (C, y1, L1) and (C, y1, L2) are potence connected with respect to SP . For every m, 3 ≤ m ≤ − j + 1, let</p><formula xml:id="formula_21">Lm = [pi 1 , . . . , pi j−1 , pi j+1 , pi j+2 , . . . , pi j , pi −m+3 , . . . , pi ]</formula><p>be the previous layer L m−1 after swapping p i j with the process before it, until it reaches p i j+1 . Specifically,</p><formula xml:id="formula_22">L −j+1 = L = [p i 1 , . . . , p i j−1 , p i j+1 , p i j , p i j+2 , . . . , p i ].</formula><p>By the induction hypothesis, (C, y 1 , L m ) and (C, y 1 , L m+1 ) are potence connected with respect to SP , for every m, 2 ≤ m &lt; − j + 1. This implies that (C, y1, L0) and (C, y 1 , L −j+1 ) are potence connected with respect to S P .</p><p>The following lemma shows that given a configuration C and a y ∈ X C , if there is a layer that extends C into a v-valent configuration and a layer that extends C into a ¯ vvalent configuration, then there is a layer that extends C into a non-univalent configuration, possibly by failing one additional process.</p><p>Lemma 5. Let C be a configuration and</p><formula xml:id="formula_23">y 1 ∈ X C . If there are layers L v and L ¯ v , such that (C, y 1 , L v ) is (v, k + 1, S P )-valent and (C, y 1 , L ¯ v ) is (¯ v, k + 1, S P )-valent, then there is a layer L such that (C, y1, L) is either not (k+1, SP )- univalent or not (k + 1, S P ∪{p} )-univalent, for some process p.</formula><p>Proof. Assume towards a contradiction that for every layer L and every process p, the configuration (C, y 1 , L) is univalent with respect to both S P and S P ∪{p} . Let L F be the full layer with respect to SP consisting of all processes not in P , according to the order of their id's. Then, L F is univalent with respect to S P , say it is (¯ v, k + 1, S P )-valent. (Otherwise, we follow the same proof with We start with the layer L F and repeatedly swap processes until we reach the layer L , in a chain of configurations which, by Claim 4, are potence connected with respect to SP . From L , we repeatedly remove the last process until reaching the layer L v , in a chain of configurations which, by Claim 3, are potence connected with respect to S P . This implies that (C, y 1 , L F ) and (C, y 1 , L v ) are potence connected with respect to SP .</p><formula xml:id="formula_24">L ¯ v .) Assume L v = [p i 1 , .</formula><p>Since (C, y1, Lv) is (v, k + 1, SP )-valent, and (C, y1, L F ) is (¯ v, k + 1, S P )-valent, it follows that there are layers L 1 and</p><formula xml:id="formula_25">L 2 such that (C, y 1 , L 1 ) is (v, k + 1, S P )-valent, (C, y 1 , L 2 )</formula><p>is (¯ v, k + 1, S P )-valent, and (C, y 1 , L 1 ) and (C, y 1 , L 2 ) have shared potence with respect to S P ∪{p} for some process p.</p><p>By Lemma 1 and our assumption, (C, y1, L1) is (v, k + 1, S P ∪{p} )-valent, and (C, y 1 , L 2 ) is (¯ v, k +1, S P ∪{p} )-valent, and hence, they cannot have shared potence with respect to S P ∪{p} . This yields a contradiction and proves the lemma.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">THE LOWER BOUND</head><p>A deciding configuration has to be univalent, so our proof aims to avoid univalent configurations. We first show that some initial configuration is not univalent (Lemma 6); namely, it is either bivalent or null-valent.</p><p>Ideally, we would like to prove that a non-univalent configuration can be extended by a single layer to a non-univalent configuration, by (permanently) failing at most one more process. Doing so would allow us to construct a layered execution with f layers, each containing at least n − f process steps, which implies the desired lower bound.</p><p>However, while this can be done (with high probability) in the case of a null-valent configuration (see Lemma 11), this is not true in the case of a bivalent configuration. From a bivalent configuration, we have both a v-deciding adversary and a ¯ v-deciding adversary. However, we cannot use them in Lemma 5 to obtain a non-univalent configuration, since the first layer of a v-deciding adversary may lead to a ¯ vvalent configuration. Such a ¯ v-valent configuration, which is reached while following a v-deciding adversary, will be called ¯ v-switching. We prove that a bivalent configuration can be extended by a single layer to a non-univalent or switching configuration, by failing at most one more process (Lemma 7). We also prove that there is a small probability of deciding in a switching configuration and thus, the execution can be extended (with high probability) from a switching configuration by at least one layer (Lemma 8).</p><p>We extend the execution in this manner, with high probability, for f layers. Since n − f processes take a step in each layer, we obtain the bound of an expected Ω(f (n − f )) steps (Theorem 12).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Initial Configurations</head><p>We start by applying Lemma 1 to prove that some initial configuration is not univalent.</p><p>Lemma 6. There exists an initial configuration C that is not univalent with respect to either S ∅ or S {p} , for some process p.</p><p>Proof. Assume that all initial configurations are univalent with respect to S ∅ . Consider the initial configurations ∼ Ci, and hence, C i−1 and C i have the same valence with respect to S {p i } . By Lemma 1, C i−1 is not 1-potent with respect to S {p i } , and C i is not 0-potent with respect to S {p i } . Hence, they are null-valent with respect to S {p i } .</p><formula xml:id="formula_26">C 0 , C 1 , · · · , C n such that in C i , 0 ≤ i ≤ n,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Bivalent and Switching Configurations</head><p>We formally define switching configurations as follows.</p><p>Definition 6. Let C be a (v, k, S P )-potent configuration, α = σ1, σ2, . . . be a v-deciding adversary from C in SP , and y1 ∈ X C such that the configuration (C, y1, σ1( y1)) is (¯ v, k + 1, S P )-valent. Then (C, y 1 , σ 1 ( y 1 )) is a ¯ v-switching configuration with respect to S P from C by y 1 and α.</p><p>Lemma 5 implies that a bivalent configuration can be extended with one layer to a configuration which is either vswitching or not univalent.</p><p>Lemma 7. If a configuration C reachable by an fexecution is (k, SP )-bivalent, then there is an adversary σ such that for every y 1 ∈ X C , (C, y 1 , σ( y 1 )) is either vswitching, or not (k+1, S P )-univalent or not (k+1, S P ∪{p} )-univalent, for some process p.</p><p>Proof. Assume that for every layer L and every process p, the configuration (C, y 1 , L) is univalent with respect to S P and S P ∪{p} .</p><p>Consider the extension of C with L F . Fix y 1 ∈ X C and assume that D = (C, y 1 , L F ) is (¯ v, k + 1, S P )-valent. Since C is bivalent, there is a v-deciding adversary α = σ1, σ2, · · · in SP . Consider the configuration C = (C, y1, σ1( y1)). By the assumption, C is univalent. If it is (¯ v, k + 1, S P )-valent then it is ¯ v-switching with respect to S P from C by y 1 and α. Otherwise, it is (v, k+1, S P )-valent. Since D is (¯ v, k+1, S P )-valent, by Lemma 5, there exists a layer L and a process p such that (C, y1, L) is either not (k + 1, SP )-univalent or not (k + 1, S P ∪{p} )-univalent.</p><p>Handling switching configurations is more delicate, and it is done in the next lemma.</p><p>Lemma 8. Let C be a ¯ v-switching configuration with respect to S P from C by y 1 and α. Then with probability at least 1 − 1 n √ n , C can be extended with at least one layer to a configuration which is either v-switching, or not univalent with respect to S P , or not univalent with respect to S P ∪{p} , for some process p.</p><p>Proof. Let α = σ1σ2 . . .; note that C = (C, y1, σ1( y1)).</p><formula xml:id="formula_27">Denote C 0 = C, C 1 = C and for every k ≥ 2 fix y k ∈ X C k−1 and let C k = (C k−1 , y k , σ k ( y k )).</formula><p>Assume that for every k ≥ 1, C k is univalent, and let C be the first configuration which is v-valent with respect to SP . If such a configuration does not exist then the execution either reaches a configuration that decides ¯ v, or does not reach any decision. Since α is v-deciding from C, the probability that C does not exist is at most k ≤ 1</p><formula xml:id="formula_28">n √ n . Since C is the first configuration which is v-valent, C −1 is ¯ v-valent. Therefore, there is a ¯ v-deciding adversary β = ρ1, ρ2, . . . from C −1 in SP . Consider the configura- tion D = (C −1 , y , ρ 1 ( y )). If D is not (k + , S P )-univalent then we are done. If D is ¯ v-valent, then since C is v-valent, by Lemma 5, there exists a layer L such that (C −1 , y , L)</formula><p>is either not (k + , SP )-univalent or not (k + , S P ∪{p} )-univalent, for some process p, in which case we are also done. Otherwise D is v-valent, which implies that it is v-switching with respect to S P from C −1 by y and β.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">One-Round Coin-Flipping Games</head><p>The remaining part of the lower bound proof deals with null-valent configurations, and it relies on results about oneround coin-flipping games. Formally, a U -valued one-round coin flipping game of m players is a function</p><formula xml:id="formula_29">g : {X 1 ∪ ⊥} × {X 2 ∪ ⊥} × · · · × {X m ∪ ⊥} −→ {1, 2, . . . , U },</formula><p>where X i , 1 ≤ i ≤ m, is the i-th probability space.</p><p>A t-hiding adversary may hide at most t of the random choices in X 1 , · · · , X m , by replacing them with a ⊥. Formally, let X = X1 × · · · × Xm be the product probability space. For every y ∈ X, and I ⊆ {1, · · · , m}, the vector reached when the adversary hides the coordinates of I is defined as follows:</p><formula xml:id="formula_30">y I (i) = 8 &lt; : y(i), i / ∈ I ⊥, i ∈ I.</formula><p>For every possible outcome of the game u ∈ {1, . . . , U }, define the set of all vectors in X for which no t-hiding adversary can force the outcome of the game to be u, as</p><formula xml:id="formula_31">W u = { y ∈ X|g( yI ) = u for every I ⊆ {1, · · · , m} such that |I| ≤ t } .</formula><p>We prove that there is high probability for hiding values in a way that forces one of the outcomes when U = 3, i.e., for some u ∈ {1, 2, 3}, Pr[ y ∈ W u ] is very small. The proof relies on an isoperimetric inequality, following a result of Schechtman <ref type="bibr" target="#b26">[27]</ref>.</p><p>The space (X, d) is a finite metric space where for every x and y in X, d <ref type="bibr">( x, y)</ref> is the Hamming distance between x and y (the number of coordinates in which x and y differ). For A ⊆ X, B(A, t) is the ball of radius t around the set A, i.e., B(A, t) = { y ∈ X| there is z ∈ A such that d( y, z) ≤ t}.</p><p>Lemma 9. Let X = X 1 ×· · ·×X m be a product probability space and A ⊆ X such that Pr[ x ∈ A] = c. Let λ0 = q 2m log 2 c , then for ≥ λ0,</p><formula xml:id="formula_32">Pr[ x ∈ B(A, )] ≥ 1 − 2e − (−λ 0 ) 2 2m .</formula><p>Proof. Consider an element x as a random function</p><formula xml:id="formula_33">x : D = {1, . . . , m} → X1 ∪ · · · ∪ Xm such that x(i) ∈ Xi. Define a sequence of partial domains ∅ = D 0 ⊂ D 1 ⊂ · · · ⊂ D m = D such that D i = {1, . . . , i}.</formula><p>Let f : X → R be a function that measures the distance of elements from the given subset A ⊆ X, i.e.,</p><formula xml:id="formula_34">f ( x) = d(A, x).</formula><p>Choose a random element of w ∈ X according to the given distribution. Define the sequence Y 0 , . . . , Y m by</p><formula xml:id="formula_35">Y i = E[f ( x) | x| D i = w]. Specifically, Y 0 = E[f ( x)</formula><p>] with probability 1, and Ym = f ( w) with the probability of choosing w. It is well known that Y0, . . . , Ym is a Doob martingale (see <ref type="bibr">[18, Chapter VI]</ref>).</p><p>Notice that X 1 , ..., X m are independent and therefore for every i ∈ D, the random variable x(i) is independent of other values of x.</p><p>The function f satisfies the Lipschitz condition, i.e., for every x, y that differ only in By Azuma's inequality we have that</p><formula xml:id="formula_36">Pr[|f ( x) − E[f ( x)]| &gt; λ] &lt; 2e − λ 2 2m .</formula><p>We now claim that E[f ( x)] ≤ λ 0 . Assume the contrary,</p><formula xml:id="formula_37">that E[f ( x)] &gt; λ 0 . Since λ 0 = q 2m log 2 c</formula><p>, we have that</p><formula xml:id="formula_38">2e − λ 2 0 2m = c. For every x ∈ A we have f ( x) = 0, therefore Pr[|f ( x) − E[f ( x)]| &gt; λ 0 ] ≥ Pr[f ( x) = 0] = c,</formula><p>which contradicts Azuma's inequality. Hence, for every ≥ λ 0 we have</p><formula xml:id="formula_39">Pr[ x / ∈ B(A, )] = Pr[f ( x) &gt; ] ≤ Pr[|f ( x) − E[f ( x)]| &gt; − λ0] &lt; 2e − (−λ 0 ) 2 2m</formula><p>, which completes the proof.</p><p>Lemma 10. In a 3-valued one-round coin-flipping game of m players, for t = 6 p 2m log(m 3 ) there exists a t-hiding adversary and u ∈ {1, 2, 3}, such that the adversary can force the outcome of the game to u with probability greater than 1 − 1 m 3 . Proof. Recall that for every u ∈ {1, 2, 3}, the set W u is the set of all vectors in X for which no t-hiding adversary can force the outcome of the game to be u. So our goal is to prove that Pr[ y ∈ W u ] &lt; 1 m 3 for some u ∈ {1, 2, 3}. </p><formula xml:id="formula_40">Denote B u = B(W u , t 3</formula><formula xml:id="formula_41">Pr[ y ∈ B u ] ≥ 1 − 2e − (t−λ 0 ) 2 2m = 1 − 2e − 2m log (2m 3 ) 2m = 1 − 2e − log (2m 3 ) = 1 − 1 m 3 . Since T u∈{1,2,3} B u = ∅ we have that Pr[ y ∈ B 1 ∩ B 2 ] + Pr[ y ∈ B 1 ∩ B 3 ] + Pr[ y ∈ B 2 ∩ B 2 ] ≤ 1 2 · P u∈{1,2,3} Pr[ y ∈ B u ], which implies that Pr[ y ∈ ∪ u∈{1,2,3} B u ] = X u∈{1,2,3} Pr[ y ∈ B u ] − X u =u ∈{1,2,3} Pr[ y ∈ B u ∩ B u ] +Pr[ y ∈ ∩ u∈{1,2,3} B u ] ≥ 1 2 · X u∈{1,2,3} Pr[ y ∈ B u ] ≥ 3 2 · (1 − 1 m 3 ) &gt; 1</formula><p>This contradiction implies that for some u ∈ {1, 2, 3} we have Pr[ y ∈ W u ] &lt; 1 m 3 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Null-Valent Configurations</head><p>We use one-round coin-flipping games to show that, with high probability, a null-valent configuration C can be extended with one f -layer to a null-valent configuration. In order to achieve the above, we may need to hide up to 6 p 2n log (2n 3 ) processes in the layer other than the processes in P , although they are not permanently failed. Therefore, we assume that f ≥ 12 p 2n log (2n 3 ), and will always make sure that |P | ≤ f 2 . This will allow us to hide f 2 ≥ 6 p 2n log (2n 3 ) additional processes (not in P ), in executions in S P .</p><p>Lemma 11. If a configuration C reachable by an fexecution is (k, S P )-null-valent, then with probability at least 1 −</p><formula xml:id="formula_42">1 (n−|P |) 3 , there is an f -adversary σ1 such that C • σ1 is (k + 1, SP )-null-valent.</formula><p>Proof. Let C be a (k, S P )-null-valent configuration, and let L F be an f -layer that is full with respect to S P . For every y 1 ∈ X C , we classify the configurations (C, y 1 , L F ) into three categories:</p><formula xml:id="formula_43">1. The configuration (C, y 1 , L F ) is (0, k + 1, S P )-potent. 2. The configuration (C, y 1 , L F ) is (1, k + 1, S P )-valent. 3. The configuration (C, y1, L F ) is (k +1, SP )-null-valent.</formula><p>This can be considered as a 3-valued one-round coinflipping game of m players, where m = n − |P |. This implies that n − f ≤ m ≤ n. By Lemma 10, we can hide 6 p 2m log(2m 3 ) processes and force the resulting configuration into one of the above categories with probability at least 1 − 1 m 3 . Hiding processes is done by choosing a partial layer L y 1 in S P that does not contain any step by the hidden processes, but only a step of each process that is not hidden. We define an adversary σ 1 that for each y 1 ∈ X, chooses the corresponding partial layer, i.e., σ1( y1) = L y 1 . Our claim is that the category that can be forced is the third one. Assume, towards a contradiction, that the category that can be forced is the first one.</p><p>This implies that the probability over</p><formula xml:id="formula_44">y 1 ∈ X that (C, y1, L y 1 ) is (0, k + 1, SP )-potent is at least 1 − 1 m 3 .</formula><p>Therefore with probability at least 1− 1 m 3 , a y1 ∈ X is chosen such that there exists a 0-deciding adversary α from (C, y1, L y 1 ) for which:</p><formula xml:id="formula_45">Pr[decision from (C, y1, L y 1 ) under α is 0] &gt; 1 − k+1</formula><p>Therefore with probability at least 1 − 1 m 3 , there exists an adversary α = σ 1 , α from C such that:</p><formula xml:id="formula_46">Pr[decision from C under α is 0] = X y 1 ∈X P ( y 1 ) · Pr[decision from (C, y 1 , L y 1 ) under α is 0] &gt; " 1 − 1 m 3 « · (1 − k+1 ) ≥ " 1 − 1 (n − f ) 3 « · " 1 − 1 n √ n + k + 1 (n − f ) 3 « = 1 − 1 n √ n + k (n − f ) 3 + 1 (n − f ) 3 n √ n − k + 1 (n − f ) 6 &gt; 1 − 1 n √ n + k (n − f ) 3 = 1 − k ,</formula><p>where the last inequality holds for sufficiently large n, since (n − f ) 6 ≥ (n − f ) 3 n √ n and k = O(n).</p><p>This contradicts the assumption that C is (k, S P )-nullvalent. A similar argument holds for the second category.</p><p>Hence, with probability at least 1− 1 m 3 , the third category can be forced, namely, we can reach a configuration that is (k + 1, S P )-null-valent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Putting the Pieces Together</head><p>We can now put the pieces together and prove the lower bound on the total step complexity of any randomized consensus algorithm.</p><p>Theorem 12. The total step complexity of any f -tolerant randomized consensus algorithm in an asynchronous system, where n−f ∈ Ω(n) and f ≥ 12 p 2n log (2n 3 ), is Ω(f (n−f )).</p><p>Proof. We show that the probability of forcing the algorithm to continue f 2 layers is at least 1 − 1 √ n . Therefore the expected number of layers is at least (1</p><formula xml:id="formula_47">− 1 √ n ) · f 2</formula><p>. Each of these layers is an f -layer containing at least n − f steps, implying that the expected total number of steps is at least</p><formula xml:id="formula_48">Ω((1 − 1 √ n ) · f 2 · (n − f )), which is in Ω(f (n − f )) since n − f ∈ Ω(n).</formula><p>We argue that for every</p><formula xml:id="formula_49">k, 0 ≤ k ≤ f 2</formula><p>, with probability at least 1−k 1 n √ n , there is a configuration C reachable by an fexecution with at least k layers, which is either v-switching or non-univalent with respect to S P where |P | ≤ k +1. Once the claim is proved, the theorem follows by taking k = f 2 , since the probability of having an f -execution with more than f 2 layers is at least 1 − f</p><formula xml:id="formula_50">2 1 n √ n &gt; 1 − 1 √ n</formula><p>. We prove the claim by induction on k. Basis: k = 0. By Lemma 6, there exists an initial configuration C that is not univalent with respect to S ∅ or S {p} , for some process p.</p><p>Induction step: Assume C is a configuration reachable by an f -execution with at least k layers, that is either vswitching or non-univalent with respect to S P where |P | ≤ k + 1. We prove that with probability at least 1 − 1 n √ n , C can be extended with at least one layer to a configuration C that is either v-switching or non-univalent with respect to S P where |P | ≤ k + 2. This implies that C exists with</p><formula xml:id="formula_51">probability (1 − k 1 n √ n )(1 − 1 n √ n ) ≥ 1 − (k + 1) 1 n √ n</formula><p>. If C is bivalent, then by Lemma 7, there exists an adversary σ and a process p such that C • σ is either v-switching or not (k + 1, SP )-univalent or not (k + 1, S P ∪{p} )-univalent.</p><p>If C is v-switching, then by Lemma 8, there exists a finite adversary α and a process p such that with probability at least 1 − 1 n √ n , C • α is either ¯ v-switching, or not univalent with respect to S P , or not univalent with respect to S P ∪{p} .</p><p>If C is null-valent, then by Lemma 11, there exists an adversary σ1 such that the configuration C • σ1 is not (k + 1, SP )-univalent with probability at least 1 − 1 m 3 . Since m ≥ n − f ∈ Ω(n), we have that 1 − 1</p><formula xml:id="formula_52">m 3 ≥ 1 − 1 (n−f ) 3 &gt; 1 − 1 n √ n .</formula><p>Finally, taking f ∈ Ω(n) and n − f ∈ Ω(n), we get a lower bound of Ω(n 2 ) on the total step complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">A MATCHING UPPER BOUND</head><p>This section presents a randomized consensus algorithm with O(n 2 ) total step complexity, by introducing a shared coin algorithm with a constant agreement parameter and O(n 2 ) total step complexity. In a shared coin algorithm with agreement parameter δ, each process outputs a decision value −1 or +1, such that for every v ∈ {−1, +1}, there is a probability of at least δ for all processes to output the same value v <ref type="bibr" target="#b4">[5]</ref>. Using a shared coin algorithm with O(n 2 ) total step complexity and a constant agreement parameter, in the framework of Aspnes and Herlihy <ref type="bibr" target="#b4">[5]</ref>, implies a randomized consensus algorithm with O(n 2 ) total step complexity.</p><p>As in previous shared coin algorithms <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b25">26]</ref>, in our algorithm the processes flip coins until the amount of coins that were flipped reaches a certain threshold. An array of n single-writer multi-reader registers records the number of coins each process has flipped, and their sum. A process reads the whole array in order to track the total number of coins that were flipped.</p><p>Each process decides on the value of the majority of the coin flips it reads. Our goal is for the processes to read similar sets of coins, in order to agree on the same majority value. For this to happen, we bound the total number of coins that are flipped (by any process) after some process observes that the threshold was exceeded. A very simple way to guarantee this property is to have processes frequently read the array in order to detect quickly that the threshold was reached. This, however, increases the total step complexity.</p><p>The novel idea of our algorithm in order to overcome this conflict, is to utilize a multi-writer register called done that serves as a binary termination flag; it is initialized to false. A process that detects that enough coins were flipped, sets done to true. This allows a process to read the array only once in every n of its local coin flips, but check the register done before each local coin flip.</p><p>The pseudocode appears in Algorithm 1. In addition to the binary register done, it uses an array A of n single-writer multi-reader registers, each with the following components (all initially 0): count: how many flips the process performed so far.</p><p>sum: the sum of coin flips values so far.</p><p>For the proof, fix an execution α of the algorithm. We will show that all processes that terminate agree on the value 1 for the shared coin with constant probability; by symmetry, the same probability holds for agreeing on −1, which implies the algorithm has a constant agreement parameter.</p><p>The total count of a specific collect is the sum of A <ref type="bibr" target="#b0">[1]</ref>.count, . . . , A <ref type="bibr">[n]</ref>.count, as read in this collect. Note that the total count in Line 8 is ignored, but it can still be used for the purpose of the proof.</p><p>Although we only maintain the counts and sums of coin flips, we can (externally) associate them with the set of coin flips they reflect; we denote by FC the collection of coin flips that are written in the shared memory by the first time that true is written to done. The size of F C can easily be bounded, since each process flips at most n coins before checking A.</p><p>Lemma 13. FC contains at least n 2 coins and at most 2n 2 coins.</p><p>For a set of coins F we let Sum(F ) be the sum of the coins in F . We denote by F i the set of coin flips read by the collect of process p i in Line 8. This is the set according to which the process p i decides on its output, i.e., p i returns Sum(F i ). Since each process may flip at most one more coin after true is written to done, we can show:</p><formula xml:id="formula_53">Lemma 14. For every i, F C ⊆ F i , and F i \ F C contains at most n − 1 coins.</formula><p>We now show that there is at least a constant probability that Sum(FC ) ≥ n. In this case, by Lemma 14 all processes that terminate agree on the value 1, since Fi contains at most n − 1 additional coins.</p><p>We partition the execution into three phases. The first phase ends when n 2 coins are written. We assume a stronger adversary that can choose these n 2 coins out of n 2 + n − 1 coins that were flipped. The second phase ends when true is written to done. In the third phase, each process reads the whole array A and returns a value for the shared coin.</p><p>Since F C is the set of coins written when done is set to true, then it is exactly the set of coins written in the first and second phases. Let F f irst be the first n 2 coins that are written, and <ref type="figure" target="#fig_4">Figure 2.</ref>) This implies that Sum(F C ) = Sum(F f irst ) + Sum(F second ). Therefore, we can bound (from below) the probability that Sum(FC ) ≥ n by bounding the probabilities that Sum(F f irst ) ≥ 3n and</p><formula xml:id="formula_54">F second = F C \ F f irst . (See</formula><formula xml:id="formula_55">Sum(F second ) ≥ −2n.</formula><p>Consider the sum of the first n 2 + n − 1 coin flips. After these coins are flipped, the adversary has to write at least n 2 of them, which will be the coins in F f irst . If the sum of the first n 2 + n − 1 coin flips is at least 4n then Sum(F f irst ) ≥ 3n. We bound the probability that this happens using the Central Limit Theorem.</p><formula xml:id="formula_56">Lemma 15. The probability that Sum(F f irst ) ≥ 3n is at least 1 8 √ 2π e −8 .</formula><p>Proof. There are N = n 2 + n − 1 coins flipped when n 2 coins are written to F f irst . By the Central Limit Theorem, the probability for the sum of these coins to be at least x √ N , e −8 the sum of these N coins is at least 4 √ N , which is more than 4n, and hence Sum(F f irst ) ≥ 3n.</p><formula xml:id="formula_57">converges to 1 − Φ(x),</formula><p>We now need to bound Sum(F second ). Unlike F f irst , whose size is determined, the adversary may have control over the number of coins in F second , and not only over which coins are in it. However, by Lemma 13 we have |FC | ≤ 2n 2 , therefore |F second | ≤ n 2 , which implies that F second must be some prefix of n 2 additional coin flips. We consider the partial sums of these n 2 additional coin flips, and show that with high probability, all these partial sums are greater than −2n, and therefore in particular Sum(F second ) &gt; −2n. Formally, for every i, 1 ≤ i ≤ n 2 , let Xi be the ith additional coin flip, and denote Sj = P j i=1 Xi. Since |F second | ≤ n 2 , there exist k, 1 ≤ k ≤ n 2 , such that S k = Sum(F second ). If Sj &gt; −2n for every j, 1 ≤ j ≤ n 2 , then specifically Sum(F second ) = S k &gt; −2n.</p><p>The bound on the partial sums is derived using Kolmogorov's inequality. This bounds the probability of agreeing on the same value for the shared coin as follows. . Since Sum(FC ) = Sum(F f irst ) + Sum(F second ), this implies that the probability that Sum(FC ) ≥ n is at least <ref type="bibr" target="#b2">3</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>32</head><p>√ 2π</p><p>e −8 . By Lemma 14, for every i, Fi \ FC contains at most n − 1 coins, which implies that if Sum(FC ) ≥ n then Sum(Fi) ≥ 1, and therefore if pi terminates, then it will decide 1. Hence with probability at least <ref type="bibr" target="#b2">3</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>32</head><p>√ 2π</p><p>e −8 , Sum(FC ) ≥ n and all processes which terminate agree on the value 1.</p><p>By symmetry, all processes which terminate agree on the value −1 with at least the same probability.</p><p>Clearly, Algorithm 1 flips O(n 2 ) coins. Moreover, all work performed by processes in reading the array A can be attributed to coin flips. This can be used to show that Algorithm 1 has O(n 2 ) total step complexity.</p><p>Using Algorithm 1 in the framework of Aspnes and Herlihy <ref type="bibr" target="#b4">[5]</ref> implies: Theorem 18. There is a randomized consensus algorithm with O(n 2 ) total step complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">DISCUSSION</head><p>We have proved that Θ(n 2 ) is a tight bound on the total step complexity of solving randomized consensus, under a strong adversary, in an asynchronous shared-memory system using multi-writer registers.</p><p>Aspnes <ref type="bibr" target="#b2">[3]</ref> shows an Ω( n 2 log 2 n ) lower bound on the expected total number of coin flips. Our layering approach as presented here, does not distinguish between a deterministic step and a step involving a coin flip, leaving open the question of the optimal number of coin flips.</p><p>Our algorithm exploits the multi-writing capabilities of the register. The best known randomized consensus algorithm using single-writer registers <ref type="bibr" target="#b12">[13]</ref> has O(n 2 log n) total step complexity, and it is intriguing to close the gap from our lower bound.</p><p>In addition to settling the open question of the asymptotic total step complexity, we consider an important contribution of this paper to be in introducing new techniques for investigating randomized consensus algorithms. These techniques provide a new context and opportunities for exploring several research directions, two of which are discussed next.</p><p>One direction is to study the individual step complexity of randomized consensus; namely, the expected number of steps performed by a single process. Aspnes and Waarts <ref type="bibr" target="#b5">[6]</ref> present a shared coin algorithm in which each process performs O(n log 2 n) expected number of steps; their algorithm has O(n 2 log 2 n) total step complexity. Their shared coin algorithm is similar to <ref type="bibr" target="#b12">[13]</ref>, but the local flips of a process are assigned increasing weights, which allows fast processes to terminate earlier. We believe that the individual step complexity can be reduced using multi-writer registers.</p><p>Our results may also provide new insight into the expected step complexity of randomized consensus under weak adversaries that cannot observe the local flips or the contents of the shared memory. Several papers presented randomized consensus algorithms for this type of adversaries, e.g., <ref type="bibr">[9-11, 14, 15]</ref>, with the best algorithms having O(n polylog(n)) total step complexity and O(polylog(n)) individual step complexity. It will be intriguing to find tight bounds for this model as well.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Classifying configurations according to their valence.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>the input of process p j is 1 if j ≤ i and 0, otherwise. By the valid- ity condition, C 0 is (0, 0, ∅)-valent and C n is (1, 0, ∅)-valent. Therefore, there is an i, 1 ≤ i ≤ n, such that Ci−1 is (0, 0, ∅)- valent and Ci is (1, 0, ∅)-valent. Clearly, Ci−1 ¬p i</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>D i \ D i−1 for some i, we have |f ( x) − f ( y)| ≤ 1, by the triangle inequality of the Hamming metric d. This implies that the martingale Y0, . . . , Ym satis- fies the martingale Lipschitz condition, i.e., |Yi − Yi−1| ≤ 1 for every i, 0 &lt; i ≤ m.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>count, sum = count + +, sum + f lip // atomically 5: if num = 0 mod n then // check if time to terminate 6: collect A // n read operations 7: if A[1].count + ... + A[n].count &gt; n 2 then done = true // raise termination flag end while 8: collect A // n read operations 9: return sign( P n j=1 A[j].sum) // return +1 or −1, // depending on the majority value of the coin flips</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Phases of the shared coin algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Lemma 16 .</head><label>16</label><figDesc>The probability that Sj &gt; −2n for all j, 1 ≤ j ≤ n 2 , is at least 3 4 . Proof. The results of the n 2 coin flips are indepen- dent random variables X1, . . . X n 2 , with E[Xi] = 0 and V ar[Xi] = 1, for every i, 1 ≤ i ≤ n 2 . Since Sj is the sum of j independent random variables, its expectation is E[Sj] = P j i=1 E[Xi] = 0, and its variance is V ar[Sj] = P j i=1 V ar[Xi] = j. Kolmogorov's inequality [17, Chap- ter IX] implies that |Sj| &lt; 2n, for all j, 1 ≤ j ≤ n 2 , with probability at least 3 4 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>. . , p i ] and consider the layer L = [pi 1 , . . . , pi , . . . ] that is full with respect to SP , and has Lv as a prefix.</head><label>.</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>). Assume that Pr[ y ∈ W u ] ≥ 1 m 3 for all u ∈ {1, 2, 3}. Clearly, T u∈{1,2,3} W u = ∅, otherwise the value of the game is undefined for that point. Moreover, we claim that T u∈{1,2,3} B u is empty. Assume there exists z ∈ T u∈{1,2,3} B u . For every u ∈ {1, 2, 3}, let x u ∈ W u and Iu ⊆ {1, . . . , m} a set of indices, such that |Iu| ≤ t 3 and z I u = x u I u . Let I =) = u, and so g( zI ) = u. This implies that g( zI )= ∅. We now apply Lemma 9, with A = W u . Notice that the results of the local flips of each player are independent random variables. We have that Pr[ y ∈ W u ] ≥ c where c = 1 m 3 , and therefore λ 0 =</head><label></label><figDesc></figDesc><table>S 
u∈{1,2,3} I u . Since x u ∈ W u , we have 
that g( x u 
I is 
undefined, and therefore 
T 
u∈{1,2,3} B u p 
2m log (2m 3 ). Hence, for 
= t 

3 

= 2 
p 
2m log (2m 3 ) = 2λ 0 , we have 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>1 2 y 2 dy is the normal distribution function. By Feller [17, Chap- ter VII], we have 1 − Φ(x) &gt; ( 1 x − 1 x 3 ) 1 √ 2π e − 1 2 x 2 . Substitut- ing x = 4 we have that with probability at least 1 8 √ 2π</head><label></label><figDesc></figDesc><table>where Φ(x) = 
1 
√ 2π 

Z x 

−∞ 

e − </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>) ≥ 3n is at least 1 8 √ 2π e −8 , and by Lemma 16, the probability that Sum(F second ) ≥ −2n is at least</head><label></label><figDesc></figDesc><table>Lemma 17. Algorithm 1 is a shared coin algorithm with 
agreement parameter δ = 3 

32 
√ 
2π 

e −8 . 

Proof. By Lemma 15, 
the probability that 
Sum(F f irst 3 
4 

</table></figure>

			<note place="foot" n="1"> For simplicity, we assume that all the probability spaces are discrete, but a similar treatment holds for arbitrary probability spaces.</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">On achieving consensus using a shared memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Abrahamson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="page" from="291" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Time-and space-efficient randomized consensus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Aspnes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="325" to="332" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Lower bounds for distributed coin-flipping and randomized consensus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Aspnes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="415" to="450" />
			<date type="published" when="1998-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Randomized protocols for aynchronous consensus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Aspnes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dist. Comp</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="165" to="176" />
			<date type="published" when="2003-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Fast randomized consensus using shared memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Aspnes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Alg</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="441" to="461" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Randomized consensus in expected O(n log 2 n) operations per processor</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Aspnes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Waarts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1024" to="1044" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Bounded polynomial randomized consensus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Attiya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dolev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shavit</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
			<biblScope unit="page" from="281" to="293" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Attiya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Welch</surname></persName>
		</author>
		<title level="m">Distributed Computing: Fundamentals, Simulations and Advanced Topics</title>
		<imprint>
			<publisher>John Wiley &amp; Sons</publisher>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
	<note>2nd edition</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Efficient asynchronous consensus with the weak adversary scheduler</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Aumann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="209" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Efficient low-contention asynchronous consensus with the value-oblivious adversary scheduler</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Aumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Bender</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dist. Comp</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="191" to="207" />
			<date type="published" when="2005-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Cooperative sharing and asynchronous consensus using single-reader single-writer registers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Aumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kapah-Levy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="61" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">A tight lower bound for randomized synchronous consensus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Bar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">-Joseph</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ben-Or</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="193" to="199" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Randomized consensus in expected</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Bracha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Rachman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="143" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Polylog randomized wait-free consensus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">D</forename><surname>Chandra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="166" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">On processor coordination using asynchronous hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Israeli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Li</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="page" from="86" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Authenticated algorithms for byzantine agreement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dolev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">R</forename><surname>Strong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="656" to="666" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">An Introduction to Probability Theory and Its Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Feller</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1968" />
			<publisher>John Wiley &amp; Sons</publisher>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
	<note>3rd edition</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">An Introduction to Probability Theory and Its Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Feller</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1971" />
			<publisher>John Wiley &amp; Sons</publisher>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
	<note>2nd edition</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A lower bound for the time to assure interactive consistency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">A</forename><surname>Lynch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="183" to="186" />
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Impossibility of distributed consensus with one faulty process</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">A</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Paterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="374" to="382" />
			<date type="published" when="1985-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Wait-free synchronization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Prog. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="124" to="149" />
			<date type="published" when="1991-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The part-time parliament</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="133" to="169" />
			<date type="published" when="1998-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Memory requirements for agreement among unreliable asynchronous processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">C</forename><surname>Loui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">H</forename><surname>Abu-Amara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Computing Research</title>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="page" from="163" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Distributed Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">A</forename><surname>Lynch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Morgan Kaufmann Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">The unified structure of consensus: A layered analysis approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Moses</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rajsbaum</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="123" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Optimal time randomized consensus-making resilient algorithms fast in practice</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Saks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shavit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Woll</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="351" to="362" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Levy type inequality for a class of finitie metric spaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Schechtman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Lecture Notes in Mathematics: Martingle Theory in Harmonic Analysis and Banach Spaces</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1981" />
			<biblScope unit="volume">939</biblScope>
			<biblScope unit="page" from="211" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Implementing fault-tolerant services using the state machine approach: A tutorial</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="299" to="319" />
			<date type="published" when="1990-12" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
