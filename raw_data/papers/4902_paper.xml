<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T17:05+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">To SAT or Not to SAT: Ashenhurst Decomposition in a Large Scale</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hsuan-Po</forename><surname>Lin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering/Graduate Institute of Electronics Engineering</orgName>
								<orgName type="institution">National Taiwan University</orgName>
								<address>
									<postCode>10617</postCode>
									<settlement>Taipei</settlement>
									<country key="TW">Taiwan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jie-Hong</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering/Graduate Institute of Electronics Engineering</orgName>
								<orgName type="institution">National Taiwan University</orgName>
								<address>
									<postCode>10617</postCode>
									<settlement>Taipei</settlement>
									<country key="TW">Taiwan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruei-Rung</forename><surname>Lee</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering/Graduate Institute of Electronics Engineering</orgName>
								<orgName type="institution">National Taiwan University</orgName>
								<address>
									<postCode>10617</postCode>
									<settlement>Taipei</settlement>
									<country key="TW">Taiwan</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">To SAT or Not to SAT: Ashenhurst Decomposition in a Large Scale</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Functional decomposition is a fundamental operation in logic synthesis. Prior BDD-based approaches to functional decomposition suffer from the memory explosion problem and do not scale well to large Boolean functions. Variable partitioning has to be specified a priori and often restricted to a few bound-set variables. Moreover, non-disjoint decomposition requires substantial sophistication. This paper shows that, when Ashenhurst decomposition (the simplest and preferable functional decomposition) is considered, both single-and multiple-output decomposition can be formulated with satisfiability solving, Craig interpolation, and functional dependency. Variable partitioning can be automated and integrated into the decomposition process without the bound-set size restriction. The computation naturally extends to non-disjoint decomposition. Experimental results show that the proposed method can effectively decompose functions with up to 300 input variables.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Functional decomposition <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b8">9]</ref> aims at decomposing a Boolean function into a network of smaller sub-functions. It is a fundamental operation in logic synthesis and has various applications to FPGA synthesis and to the minimization of circuit communication complexity. There has been intensive work on this subject since FPGAs became a viable design style and BDD packages were available. See, e.g., <ref type="bibr" target="#b13">[14]</ref> for a survey.</p><p>Most prior work on functional decomposition used BDD as the underlying data structure. With proper variable ordering, BDD can be exploited for the computation of functional decomposition. Despite having been a powerful tool, BDD poses several limitations: Firstly, BDD suffers from the memory explosion problem. In representing a Boolean function, a BDD can be of large size (in the worst case, exponential in the number of variables). It is even more so when special variable ordering rules need to be imposed on BDDs for functional decomposition. Therefore it is typical that a function under decomposition can have just a few variables. Secondly, variable partitioning needs to be specified a priori, and cannot be automated as an integrated part of the decomposition process. In order to effectively enumerate different variable partitions and keep BDD sizes reasonably small, the set of bound set variables cannot be large. Thirdly, for BDD-based approaches, non-disjoint decomposition cannot be handled easily. In essence, decomposability needs to be analyzed by cases exponential in the number of joint (or common) variables. Finally, even though multiple-output decomposition <ref type="bibr" target="#b15">[16]</ref> can be converted to single-output decomposition <ref type="bibr" target="#b7">[8]</ref>, BDD sizes may grow largely in this conversion.</p><p>The above limitations motivate the need for new data structures and computation methods for functional decom- position. This paper shows that, when Ashenhurst decomposition <ref type="bibr" target="#b0">[1]</ref> is considered, these limitations can be overcome through satisfiability (SAT) based formulation. Ashenhurst decomposition is a special case of functional decomposition, where, as illustrated in <ref type="figure" target="#fig_0">Figure 1</ref>, a function f (X) is decomposed into two sub-functions h(X H , X C , x g ) and g(X G , X C ) with f (X) = h(X H , X C , g(X G , X C )). For general functional decomposition, the function g can be a functional vector (g1, . . . , g k ) instead. It is this simplicity that makes Ashenhurst decomposition particularly attractive in practical applications.</p><p>The enabling techniques of our method, in addition to SAT solving, include Craig interpolation <ref type="bibr" target="#b3">[4]</ref> and functional dependency <ref type="bibr" target="#b9">[10]</ref>. Specifically, the decomposability of function f is formulated as SAT solving, the derivation of function g is by Craig interpolation, and the derivation of function h is by functional dependency.</p><p>Compared with BDD-based methods, the proposed algorithm is advantageous in the following aspects. Firstly, it does not suffer from the memory explosion problem and is scalable to large functions. Experimental results show that Boolean functions with more than 300 input variables can be decomposed effectively. Secondly, variable partitioning needs not be specified a priori, and can be automated and derived on the fly during decomposition. Hence the size of the bound set variables X G need not be small. Thirdly, it works for non-disjoint decomposition naturally. Finally, it is easily extendable to multiple-output decomposition. Nonetheless, a limitation of the method is its expensive generalization to functional decomposition beyond Ashenhurst's special case.</p><p>As interconnects become a dominating concern in modern nanometer IC designs, scalable decomposition methods play a pivotal role in circuit communication minimization. With the advantages of the proposed method, hierarchical logic decomposition could be made feasible in practice. In addition, our results may shed light on scalable Boolean matching for heterogeneous FPGAs as well as topologically constrained logic synthesis. This paper is organized as follows. Section 2 introduces essential preliminaries. Our main algorithms are presented in Section 3, and evaluated with experimental results in Section 4. Section 5 compares some related prior work. Finally, Section 6 concludes the paper and outlines future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARIES</head><p>As conventional notation, sets are denoted by upper-case letters, e.g., S; set elements are in lower-case letters, e.g., e ∈ S. The cardinality of S is denoted by |S|. A partition of a set S into S i ⊆ S for i = 1, . . . , k (with S i ∩ S j = ∅, i = j, and</p><formula xml:id="formula_0">i S i = S) is denoted by {S 1 |S 2 | . . . |S k }.</formula><p>For a set X of Boolean variables, its set of valuations (or truth assignments) is denoted by <ref type="bibr">[[X]</ref>], e.g., <ref type="bibr">[</ref>[X]] = {(0, 0), (0, 1), (1, 0), (1, 1)} for X = {x 1 , x 2 }.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Functional Decomposition</head><p>Definition 1. Given a completely specified Boolean function f , variable x is a support variable of f if fx = f¬x, where fx and f¬x are the positive and negative cofactors of f on x, respectively. Definition 2. A set {f1(X), . . . , fm(X)} of completely specified Boolean functions is (jointly) decomposable with respect to some variable partition X = {X H |X G |X C } if every function f i , i = 1, . . . , m, can be written as</p><formula xml:id="formula_1">f i (X) = h i (X H , X C , g 1 (X G , X C ), . . . , g k (X G , X C )) for some functions h i , g 1 , . . . , g k with k &lt; |X G |. The de- composition is called disjoint if X C = ∅, and non-disjoint otherwise.</formula><p>It is known as single-output decomposition for m = 1, and multiple-output decomposition for m &gt; 1. Note that, in multiple-output decomposition, functions h1, . . . , hm share the same functions g1, . . . , g k . For k = 1, the decomposition is known as the so-called Ashenhurst decomposition <ref type="bibr" target="#b0">[1]</ref>.</p><p>Note that, for |X G | = 1, there is no successful decomposition because of the violation of the criterion k &lt; |X G |. On the other hand, the decomposition trivially holds if XC ∪ XG or X C ∪ X H equals X. The corresponding variable partition is called trivial. This paper is concerned about decomposition under non-trivial variable partition. Moreover, we focus on Ashenhurst decomposition.</p><p>The decomposability of a set {f1, . . . , fm} of functions under the variable partition X = {X H |X G |X C } can be analyzed through the so-called decomposition chart, consisting of a set of matrices, one for each member of <ref type="bibr">[</ref> </p><formula xml:id="formula_2">(X H = a, X G = b, X C = c). Proposition 1. [1, 5, 9] A set {f 1 , . . . , f m } of Boolean functions is decomposable as f i (X) = h i (X H , X C , g 1 (X G , X C ), . . . , g k (X G , X C )) for i = 1, . . . , m under variable partition X = {X H |X G |X C } if and only if, for every c ∈ [[X C ]]</formula><p>, the corresponding matrix of c has at most 2 k column patterns (i.e., at most 2 k different kinds of column vectors).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Functional Dependency</head><p>Definition 3. Given a Boolean function f : B m → B and a vector of Boolean functions G = (g 1 (X), . . . , g n (X)) with gi : B m → B for i = 1, . . . , n, over the same set of variable vector X = (x1, . . . , xm), we say that f functionally depends on G if there exists a Boolean function h : B n → B, called the dependency function, such that f (X) = h(g 1 (X), . . . , g n (X)). We call functions f , G, and h the target function, base functions, and dependency function, respectively.</p><p>Note that functions f and G are over the same domain in the definition; h needs not depend on all of the functions in G.</p><p>The necessary and sufficient condition of the existence of the dependency function h was given in <ref type="bibr" target="#b6">[7]</ref>. Moreover a SATbased computation of functional dependency was presented in <ref type="bibr" target="#b9">[10]</ref>. It forms an important ingredient in part of our formulation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Satisfiability and Interpolation</head><p>A brief introduction to SAT solving and circuit-to-CNF conversion, essential to our development, can be found in <ref type="bibr" target="#b9">[10]</ref>. To introduce terminology and notation for later use, we mention the following theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1 (Craig Interpolation Theorem). [4]</head><p>Given two Boolean formulas ϕA and ϕB, with ϕA ∧ϕB unsatisfiable, then there exists a Boolean formula ψA referring only to the common variables of ϕ A and ϕ B such that ϕ A ⇒ ψ A and ψ A ∧ ϕ B is unsatisfiable.</p><p>The Boolean formula ψA is referred to as the interpolant of ϕ A with respect to ϕ B . Some modern SAT solvers, e.g., MiniSat <ref type="bibr" target="#b5">[6]</ref>, are capable of constructing an interpolant from an unsatisfiable SAT instance <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">MAIN ALGORITHMS</head><p>We show that Ashenhurst decomposition of a set of Boolean functions {f 1 , . . . , f m } can be achieved by SAT solving, Craig interpolation, and functional dependency. Whenever a nontrivial decomposition exists, we derive functions hi and g automatically for</p><formula xml:id="formula_3">f i (X) = h i (X H , X C , g(X G , X C )) along with the corresponding variable partition X = {X H |X G |X C }.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Single-Output Ashenhurst Decomposition</head><p>We first consider Ashenhurst decomposition for a single function f (X) = h(XH , XC , g(XG, XC )).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Decomposition with known variable partition</head><p>Proposition 1 in the context of Ashenhurst decomposition of a single function can be formulated as satisfiability solving as follows.</p><p>Proposition 2. A completely specified Boolean function f (X) can be expressed as h(XH , XC , g(XG, XC )) for some functions g and h if and only if the Boolean formula</p><formula xml:id="formula_4">(f (X 1 H , X 1 G , X C ) ≡ f (X 1 H , X 2 G , X C )) ∧ (f (X 2 H , X 2 G , XC ) ≡ f (X 2 H , X 3 G , XC )) ∧ (f (X 3 H , X 3 G , X C ) ≡ f (X 3 H , X 1 G , X C ))<label>(1)</label></formula><p>is unsatisfiable, where a superscript i in Y i denotes the i th copy of the instantiation of variables Y .</p><p>Observe that Formula (1) is satisfiable if and only if there exists more than two distinct column patterns in some matrix of the decomposition chart. Hence its unsatisfiability is exactly the condition of Ashenhurst decomposition. Note that, unlike BDD-based counterparts, the above SATbased formulation of Ashenhurst decomposition naturally extends to non-disjoint decomposition. It is because the unsatisfiability checking of Formula (1) essentially tries to assert that under every valuation of variables X C the corresponding matrix of the decomposition chart has at most two column patterns. In contrast, BDD-based methods have to check the decomposability under every valuation of X C separately.</p><p>Whereas the decomposability of function f can be checked through SAT solving of Formula (1), the derivations of functions g and h can be realized through Craig interpolation and functional dependency, respectively, as shown below.  <ref type="formula">(2)</ref> and (3) </p><formula xml:id="formula_5">X 1 G X 2 G … … X 1 G X 2 G … … (a)<label>(b)</label></formula><formula xml:id="formula_6">(X 1 G , X 2 G , c) for some c ∈ [[XC ]]; (b) relation after cofactoring ψ A (X 1 G = p, X 2 G , c) with respect to some p ∈ [[X 1 G ]]</formula><p>To derive function g, we partition Formula (1) into two sub-formulas <ref type="figure" target="#fig_2">Figure 2</ref> shows the corresponding circuit representation of Formulas (2) and (3). The circuit representation can be converted into a CNF formula in linear time <ref type="bibr" target="#b14">[15]</ref>, and thus can be checked for satisfiability.</p><formula xml:id="formula_7">ϕ A = f (X 1 H , X 1 G , X C ) ≡ f (X 1 H , X 2 G , X C ), and (2) ϕB = (f (X 2 H , X 2 G , XC ) ≡ f (X 2 H , X 3 G , XC )) ∧ (f (X 3 H , X 3 G , X C ) ≡ f (X 3 H , X 1 G , X C )).<label>(3)</label></formula><p>Lemma 1. For function f (X) decomposable under Ashenhurst decomposition with variable partition X = {X H |X G |X C }, the interpolant ψ A with respect to ϕ A of Formula (2) and ϕ B of Formula (3) corresponds to a characteristic function such that,  </p><formula xml:id="formula_8">(i) for ϕ A satisfiable under some c ∈ [[X C ]], ψ A (b 1 , b 2 , c) = 1 with b 1 ∈ [[X 1 G ]] and b 2 ∈ [[X 2 G ]] if</formula><formula xml:id="formula_9">X i G ]]. An edge (b 1 , b 2 ) between b 1 ∈ [[X 1 G ]] and b 2 ∈ [[X 2 G ]</formula><p>] denotes that b1 is not in the same equivalence class as b2, i.e., ψA(b1, b2, c) = 1. For example, p and r in the figure are in different equivalence classes and ψ A (p, r, c) = 1, whereas p and q are in the same equivalence class and ψ A (p, q, c) = 0. Essentially the set of such edges are characterized by the equivalence relation ψA(X 1 G , X 2 G , c). So every element in one equivalence class of [ <ref type="bibr">[X 1 G ]</ref>] is connected to every element in the other equivalence class of [ <ref type="bibr">[X 2 G ]</ref>], and vice versa, in <ref type="figure" target="#fig_3">Fig- ure 3(a)</ref>.</p><p>We next show how to extract function g from the interpolant ψA.</p><formula xml:id="formula_10">Lemma 2. For an arbitrary a ∈ [[X 1 G ]], the cofactored in- terpolant ψA(X 1 G = a, X 2 G , XC ) is a legal implementation of function g(X 2</formula><p>G , X C ). After renaming X 2 G to XG, we get the desired g(XG, XC ). Consider <ref type="figure" target="#fig_3">Figure 3</ref>. After cofactoring So far we have successfully obtained function g by interpolation. Next we need to compute function h. The problem can be formulated as computing functional dependency as follows. Let f (X) be our target function; let function g(X G , X C ) and identity functions ı x (x) = x, one for every variable x ∈ X H ∪ X C , be our base functions. So the computed dependency function corresponds to our desired h. Since functional dependency can be formulated using SAT solving and interpolation <ref type="bibr" target="#b9">[10]</ref>, it well fits in our computation framework.</p><formula xml:id="formula_11">ψ A (X 1 G , X 2 G , c) with respect to p ∈ [[X 1 G ]],</formula><p>Remark 1. For disjoint decomposition, i.e., X C = ∅, we can simplify the derivation of function h, without using functional dependency.</p><p>Given two functions f (X) and g(XG) with variable partition X = {XH |XG}, we aim to find a function h(XH , xg) such that f (X) = h(X H , g(X G )), where x g is the output variable of function g(X G ).  The correctness of the so-derived Ashenhurst decomposition follows from Lemma 2 and Proposition 1, as the following theorem states.</p><formula xml:id="formula_12">h(X H , x g ) = (¬x g ∧ h ¬xg (X H )) ∨ (x g ∧ h xg (X H )), where h ¬x g (X H ) = f (X H , X G = a) and h x g (X H ) = f (X H , X G = b).</formula><p>Theorem 2. Given a function f decomposable under Ashenhurst decomposition with variable partition X = {XH |XG|XC }, then f (X) = h(X H , X C , g(X G , X C )) for functions g and h obtained by the above derivation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Decomposition with unknown variable partition</head><p>The previous construction assumes that a variable partition X = {X H |X G |X C } is given. We show how to automate the variable partition within the decomposition process of function f . A similar approach was used in <ref type="bibr" target="#b10">[11]</ref> for bi-decomposition of Boolean functions.</p><p>For each variable x i ∈ X we introduce two control variables αx i and βx i . In addition we instantiate variable X into six copies X 1 , X 2 , X 3 , X 4 , X 5 , and X 6 . Let</p><formula xml:id="formula_13">ϕ A = (f (X 1 ) ≡ f (X 2 )) ∧ i ((x 1 i ≡ x 2 i ) ∨ β x i ) and (4) ϕ B = (f (X 3 ) ≡ f (X 4 )) ∧ (f (X 5 ) ≡ f (X 6 )) ∧ i (((x 2 i ≡ x 3 i ) ∧ (x 4 i ≡ x 5 i ) ∧ (x 6 i ≡ x 1 i )) ∨ α x i ) ∧ i (((x 3 i ≡ x 4 i ) ∧ (x 5 i ≡ x 6 i )) ∨ β x i ),<label>(5)</label></formula><p>where x j i ∈ X j for j = 1, . . . , 6 are the instantiated versions of x i ∈ X. Observe that (α x i , β x i ) = (0, 0), (0, 1), (1, 0), and <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b0">1)</ref> indicate that x i ∈ X C , x i ∈ X G , x i ∈ X H , and x i can be in either of XG and XH , respectively.</p><p>In SAT solving the conjunction of Formulas <ref type="formula">(4)</ref> and <ref type="formula" target="#formula_13">(5)</ref>, we make unit assumptions <ref type="bibr" target="#b5">[6]</ref> on the control variables. Similar to <ref type="bibr" target="#b10">[11]</ref> but with a subtle difference, we introduce the following seed variable partition to avoid trivial variable partition and to avoid |XG| = 1. For the unit assumption, initially we specify three distinct variables with one, say, x j , in X H and two, say, x k , x l , in X G , and specify all other variables in</p><formula xml:id="formula_14">X C . That is, we have (α x j , β x j ) = (1, 0), (α x k , β x k ) = (0, 1), (αx l , βx l ) = (0, 1), and (αx i , βx i ) = (0, 0) for i = j, k, l.</formula><p>Lemma 3. For an unsatisfiable conjunction of Formulas (4) and (5) under a seed variable partition, the final conflict clause consists of only the control variables, which indicates a valid non-trivial variable partition.</p><p>If the conjunction of Formulas <ref type="formula">(4)</ref> and <ref type="formula" target="#formula_13">(5)</ref> is unsatisfiable under a seed variable partition, then the corresponding decomposition (indicated by the final conflict clause) is successful. Otherwise, we should try another seed variable partition. For a given function f (X) with |X| = n, the existence of non-trivial Ashenhurst decomposition can be checked with at most 3 · C n 3 different seed partitions. Rather than just looking for a valid variable partition, we may further target one that is more balanced (i.e., |X H | and |X G | are of similar sizes) and closer to disjoint (i.e., |X C | is small) by enumerating different seed variable partitions. As SAT solvers usually refer to a small unsatisfiable core, the returned variable partition is desirable because |X C | tends to be small. Even if a returned unsatisfiable core is unnecessarily large, the corresponding variable partition can be further refined by modifying the unit assumption to reduce the unsatisfiable core and reduce |X C | as well. The process can be iterated until the unsatisfiable core is minimal.</p><p>After automatic variable partition, functions g and h can be derived through a construction similar to the foregoing one. The correctness of the overall construction can be asserted.</p><p>Theorem 3. For a function f decomposable under Ashenhurst decomposition, we have f (X) = h(X H , X C , g(X G , X C )) for functions g and h, and a non-trivial variable partition X = {XH |XG|XC } derived from the above construction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Multiple-Output Ashenhurst Decomposition</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Beyond Ashenhurst Decomposition</head><p>Is the above algorithm extendable to general functional decomposition, namely,</p><formula xml:id="formula_15">f (X) = h(X H , X C , g 1 (X G , X C ), . . . , g k (X G , X C ))</formula><p>for k &gt; 1? The answer is yes, but with prohibitive cost. Taking k = 2 for example, we need 20 copies of f to assert the non-existence of five different column patterns for every matrix of a decomposition chart, in contrast to the six for Ashenhurst decomposition shown in <ref type="figure" target="#fig_2">Figure 2</ref>. This number grows in 2 k (2 k + 1). Aside from this duplication issue, the derivation of functions g1, . . . , g k , and h may involve several iterations of finding satisfying assignments and performing cofactoring. The number of iterations varies depending on how the interpolation is computed and can be exponential in k. Therefore we focus mostly on Ashenhurst decomposition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">EXPERIMENTAL RESULTS</head><p>The proposed approach to Ashenhurst decomposition was implemented in C++ within the ABC package <ref type="bibr" target="#b1">[2]</ref> and used MiniSAT <ref type="bibr" target="#b5">[6]</ref> as the underlying solver. All the experiments were conducted on a Linux machine with Xeon 3.4GHz CPU and 6Gb RAM.</p><p>Large ISCAS, MCNC and ITC benchmark circuits were chosen to evaluate the proposed method. Only large transition and output functions (with no less than 50 inputs in the transitive fanin cone) were considered. We evaluated both single-output and two-output Ashenhurst decompositions. For the latter, we decomposed simultaneously a pair of functions with similar input variables. For a circuit, we heuristically performed pairwise matching among its transition and output functions for decomposition. Only function pairs with joint input variables no less than 50 were decomposed. Note that the experiments target the study of scalability, rather than comprehensiveness as a synthesis methodology. <ref type="table" target="#tab_2">Tables 1 and 2</ref> show the decomposition statistics of singleoutput and two-output decompositions, respectively. In these  tables, circuits to be decomposed are listed in Column 1. Columns 2 and 3 list the numbers of instances (i.e., functions for single-output decomposition and function pairs for twooutput decomposition) with no less than 50 inputs and the ranges of the input sizes of these instances, respectively. Column 4 lists the numbers of instances that we cannot find any successful variable partition within 60 seconds or within 1500 seed variable partitions. Column 5 lists the numbers of instances that are decomposable but spending over 30 seconds in SAT solving for the derivation of function g or h. Columns 6 and 7 list the numbers of successfully decomposed instances and the ranges of the input sizes of these instances, respectively. Columns 8 and 9 list the average numbers of tried seed partitions in 60 seconds and the average rates hitting valid seed partitions. Column 10 shows the average CPU times spending on decomposing an instance. Finally, Column 11 shows the memory consumption. As can be seen, our method can effectively decompose functions or function pairs with up to 300 input variables.</p><p>We measure the quality of a variable partition in terms of disjointness, indicated by |XC |/|X|, and balancedness, indicated by ||XG| − |XH ||/|X|. The smaller the values are, the better a variable partition is. <ref type="figure" target="#fig_7">Figures 4 and 5</ref> depict, for each decomposition instance, the quality of best variable partition found within 60 seconds 1 in terms of the above two metrics, with emphasis on disjointness. A spot on these two figures corresponds to a variable partition for some decomposition instance. <ref type="figure" target="#fig_7">Figure 4</ref> and <ref type="figure">Figure 5</ref> show the variable partition data without and with further minimal unsatisfiable (UNSAT) core refinement 2 , respectively. Since a final conflict clause returned by a SAT solver may not reflect a minimal UNSAT core, very likely we can further refine the corresponding variable partition. Suppose the variable par- <ref type="bibr" target="#b0">1</ref> The search for a best variable partition may quit before 60 seconds if both disjointness and balancedness cannot be improved in consecutive 1500 trials. <ref type="bibr" target="#b1">2</ref> For every decomposition instance, the UNSAT core refinement is applied only once to the best found variable partition. The CPU times listed in <ref type="table" target="#tab_2">Tables 1 and 2</ref>  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Ashenhurst decomposition</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>[X C ]]. The rows and columns of a matrix are indexed by {1, . . . , m} × [[XH ]] and [[XG]], respectively. For i ∈ {1, . . . , m}, a ∈ [[XH ]], b ∈ [[XG]], and c ∈ [[X C ]], the entry with row index (i, a) and column in- dex b of the matrix of c is of value f i</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Circuit representing the conjunction condition of Formulas (2) and (3)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: (a) Relation characterized by ψA(X 1 G , X 2 G , c) for some c ∈ [[XC ]]; (b) relation after cofactoring ψ A (X 1 G = p, X 2 G , c) with respect to some p ∈ [[X 1 G ]]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 (</head><label>3</label><figDesc>Figure 3(a) illustrates the relation characterized by interpolant ψA(X 1 G , X 2 G , c) for some c ∈ [[XC ]]. The left and right</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>all the edges in Figure 3 (</head><label>3</label><figDesc>a) will disap- pear except for the ones connecting p with the elements in the other equivalence class of [[X 2 G ]] as shown in Figure 3(b). Hence ψA(p, X 2 G , c) can be used as an implementation of g function.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Let a, b ∈ [[X G ]] with g(a) = 0 and g(b) = 1. Then by Shannon expansion</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Best variable partition found in 60 seconds -without minimal UNSAT core refinement</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>and only if the column vectors indexed by b 1 and b 2 in the matrix of c of the decomposition chart of f are different; (ii) for ϕ A unsatisfiable under some c ∈ [[X C ]]</head><label></label><figDesc></figDesc><table>, there is only 
one column pattern in the matrix of c of the decompo-
sition chart of f ; 

(iii) for unsatisfiable ϕ A , variables X G are not the support 
variables of f and thus {X H |X G |X C } is a trivial vari-
able partition for f . 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>in [[X G ]] and see if g(c) equals 0 or 1. We then perform SAT solving on ei- ther g(X G ) or ¬g(X G ) dependingXH , XC = c, xg), one for every valuation c ∈ [[X C ]]. There are 2 |X C | cases to analyze.</head><label></label><figDesc>The derivation of the offset and onset minterms is easy because we can pick an arbitrary minterm c</figDesc><table>on the value g(c) to derive 
another necessary minterm. 
The above derivation of function h, however, does not 
scale well for decomposition with large |XC | because we may 
need to compute h(Consequently 
when common variables exist, functional dependency may be 
a better approach to computing h. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><head>Table 1 : Single-output Ashenhurst decomposition</head><label>1</label><figDesc></figDesc><table>circuit 
#func 
#var 
#fail 
#SAT TO 
#succ 
#var succ 
#VP avg 
rate valid-VP 
time avg (sec) 
mem (Mb) 
b14 
153 
50-218 
0 
108 
45 
50-101 
1701 
0.615 
144.22 
90.01 
b15 
370 
143-306 
0 
51 
319 
143-306 
1519 
0.917 
96.62 
107.20 
b17 
1009 
76-308 
0 
148 
861 
76-308 
1645 
0.904 
87.12 
125.84 
C2670 
6 
78-122 
0 
1 
5 
78-122 
1066 
0.835 
83.80 
58.91 
C5315 
20 
54-67 
0 
4 
16 
54-67 
3041 
0.914 
50.90 
51.34 
C7552 
36 
50-194 
0 
2 
34 
50-194 
1350 
0.455 
64.38 
36.65 
s938 
1 
66-66 
0 
0 
1 
66-66 
3051 
0.726 
19.03 
24.90 
s1423 
17 
51-59 
0 
0 
17 
51-59 
3092 
0.723 
13.66 
25.34 
s3330 
1 
87-87 
0 
0 
1 
87-87 
3336 
0.599 
58.30 
27.75 
s9234 
13 
54-83 
0 
0 
13 
54-83 
3482 
0.857 
37.86 
35.33 
s13207 
3 
212-212 
0 
0 
3 
212-212 
569 
0.908 
70.26 
50.62 
s38417 
256 
53-99 
6 
72 
178 
53-99 
1090 
0.523 
103.33 
136.04 
s38584 
7 
50-147 
0 
0 
7 
50-147 
1120 
0.924 
47.13 
51.56 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Two-output Ashenhurst decomposition 

circuit 
#pair 
#var 
#fail 
#SAT TO 
#succ 
#var succ 
#VP avg 
rate valid-VP 
time avg (sec) 
mem (Mb) 
b14 
123 
50-223 
18 
65 
40 
50-125 
1832 
0.568 
96.86 
226.70 
b15 
201 
145-306 
0 
31 
170 
145-269 
1176 
0.845 
113.86 
224.07 
b17 
583 
79-310 
0 
88 
495 
79-308 
676 
0.824 
103.12 
419.35 
C2670 
5 
78-123 
0 
1 
4 
78-123 
254 
0.724 
66.95 
55.71 
C5315 
11 
56-69 
0 
2 
9 
56-69 
370 
0.594 
59.20 
60.05 
C7552 
21 
56-195 
0 
2 
19 
56-141 
188 
0.465 
89.57 
78.67 
s938 
1 
66-66 
0 
0 
1 
66-66 
3345 
0.720 
61.24 
34.77 
s1423 
14 
50-67 
0 
0 
14 
50-67 
3539 
0.591 
55.34 
45.66 
s3330 
1 
87-87 
0 
0 
1 
87-87 
1278 
0.423 
66.83 
47.43 
s9234 
12 
54-83 
0 
0 
12 
54-83 
2193 
0.708 
48.11 
55.15 
s13207 
3 
212-228 
0 
0 
3 
212-228 
585 
0.700 
93.36 
118.03 
s38417 
218 
53-116 
13 
30 
175 
53-116 
689 
0.498 
109.06 
319.48 
s38584 
9 
50-151 
0 
0 
9 
50-151 
1656 
0.713 
46.17 
207.78 

</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>This work was supported in part by NSC grants 95-2218-E-002-064-MY3 and 96-2221-E-002-278-MY3.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">PRIOR WORK</head><p>Aside from BDD-based functional decomposition, we compare some related work using SAT. In bi-decomposition <ref type="bibr" target="#b10">[11]</ref>, a function f is written as f (X) = h(g 1 (X A , X C ), g 2 (X B , X C )) under variable partition X = {XA|XB|XC }, where function h is known a priori and is of special function types (namely, two-input or, and, and xor gates) while functions g 1 and g 2 are the unknown to be computed. In contrast, the complication of Ashenhurst decomposition f (X) = h(XH , XC , g(XG, XC )) comes from the fact that both functions h and g are unknown. The problem needs be formulated and solved differently while the basic technique used is similar to that in <ref type="bibr" target="#b10">[11]</ref>.</p><p>FPGA Boolean matching, see, e.g., <ref type="bibr" target="#b2">[3]</ref>, is a subject closely related to functional decomposition. In <ref type="bibr" target="#b11">[12]</ref>, Boolean matching was achieved with SAT solving, where quantified Boolean formulas were converted into CNF formulas. The intrinsic exponential explosion in formula sizes limits the scalability of the approach. Our method may provide a partial solution to this problem, at least for some special PLB configurations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSIONS AND FUTURE WORK</head><p>A new formulation of Ashenhurst decomposition was proposed based on SAT solving, Craig interpolation, and functional dependency. Traditionally difficult non-disjoint and multiple-output decompositions can be handled naturally. Moreover variable partition needs not be specified a priori and can be embedded into the decomposition process. It allows effective enumeration over a wide range of partition choices, which is not possible before. Although Ashenhurst decomposition is a special case of functional decomposition, its simplicity is particularly attractive and preferable.</p><p>Because of its scalability to large designs as justified by experimental results, our approach can be applied at a top level of hierarchical decomposition in logic synthesis, which may provide a global view on optimization. It can be a step forward towards topologically constrained logic synthesis.</p><p>For future work, how to perform general functional decomposition and how to minimize interpolants await future investigation. Also the application of our approach to FPGA Boolean matching can be an interesting subject to explore.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The decomposition of switching functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Ashenhurst</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1959" />
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="74" to="116" />
		</imprint>
		<respStmt>
			<orgName>Computation Lab, Harvard University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">ABC: A system for sequential synthesis and verification</title>
		<ptr target="http://www.eecs.berkeley.edu/∼alanmi/abc/" />
		<imprint/>
		<respStmt>
			<orgName>Berkeley Logic Synthesis and Verification Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Boolean matching for LUT-based logic blocks with applications to architecture evaluation and technology mapping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-Y</forename><surname>Hwang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computer-Aided Design of Integrated Circuits</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1077" to="1090" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Linear reasoning: A new form of the Herbrand-Gentzen theorem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Craig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="250" to="268" />
			<date type="published" when="1957" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">New Approach to the Design of Switching Circuits</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Curtis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1962" />
			<publisher>Van Nostrand</publisher>
			<pubPlace>Princeton, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An extensible SAT-solver</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Eén</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Söensson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SAT</title>
		<meeting>SAT</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="502" to="518" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Functional dependency for verification reduction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-H</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CAV</title>
		<meeting>CAV</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="268" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Compatible class encoding in hyper-function decomposition for FPGA synthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-H</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-Y</forename><surname>Jou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-D</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="712" to="717" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Functional decomposition and switching circuit design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Karp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Soc. Ind. Appl. Math</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="291" to="335" />
			<date type="published" when="1963" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Scalable exploration of functional dependency by interpolation and incremental SAT solving</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-H</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mishchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCAD</title>
		<meeting>ICCAD</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="227" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Bi-decomposing large Boolean functions via interpolation and satisfiability solving</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R.-R</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-H</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-L</forename><surname>Hung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">FPGA technology mapping: A study of optimality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Brown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="427" to="432" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Interpolation and SAT-based model checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CAV</title>
		<meeting>CAV</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Functional Decomposition with Applications to FPGA Synthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Scholl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
			<publisher>Kluwer Academic Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">On the complexity of derivation in propositional calculus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Tseitin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Studies in Constructive Mathematics and Mathematical Logic</title>
		<imprint>
			<date type="published" when="1970" />
			<biblScope unit="page" from="466" to="483" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Functional multiple-output decomposition with application to technology mapping for lookup table-based FPGAs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Wurth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Schlichtmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Eckl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Antreich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Design Automation of Electronic Systems</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="313" to="350" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
