<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:51+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Towards Formal Verification of Memory Properties using Separation Logic *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicolas</forename><surname>Marti</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">†Department of Computer Science</orgName>
								<orgName type="department" key="dep2">‡Research Center for Information Security (RCIS)</orgName>
								<orgName type="institution">University of Tokyo National Institute of Advanced Industrial Science and Technology (AIST)</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reynald</forename><surname>Affeldt</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">†Department of Computer Science</orgName>
								<orgName type="department" key="dep2">‡Research Center for Information Security (RCIS)</orgName>
								<orgName type="institution">University of Tokyo National Institute of Advanced Industrial Science and Technology (AIST)</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Akinori</forename><surname>Yonezawa</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">†Department of Computer Science</orgName>
								<orgName type="department" key="dep2">‡Research Center for Information Security (RCIS)</orgName>
								<orgName type="institution">University of Tokyo National Institute of Advanced Industrial Science and Technology (AIST)</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Towards Formal Verification of Memory Properties using Separation Logic *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>With the recent dissemination of embedded systems, it has become important to verifiy low-level software such as specialized operating systems. However, such verifica-tions are notoriously made difficult by complex memory management operations such as pointer arithmetic. As a first step towards the implementation of a verification tool, we show how one can formally verify an important property of memory management for the Topsy operating system, an existing operating system for active-network cards. Our approach consists in verifying individually each function involved in memory management using a formal encoding of separation logic in the Coq proof assistant. At the time of this writing, we are still in the process of verifying memory management for Topsy, but we already found issues in the implementation.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>With the recent dissemination of embedded systems, it has become important to verify low-level software such as specialized operating systems. However, such verifications are notoriously made difficult by complex memory management operations such as pointer arithmetic. The fact is that software developers lack tools for such verifications, as opposed to, say, successful applications of model-checking in the hardware industry.</p><p>Our goal is to provide a verification tool for low-level software. We have already laid down the foundations of such a tool by implementing in the Coq proof assistant the separation logic <ref type="bibr" target="#b0">[1]</ref> (a Hoare logic-like language for verification of C-like programming languages). Despite the tediousness of proof assistant-based verification, we believe that the Coq proof assistant provides an effective way to verify low-level software, as exemplified, among other experiments, by the recent verification of the Java Card System at the Common Criteria EAL7 level (Trusted Logic, press release of <ref type="bibr">November 18, 2003)</ref>.</p><p>In this paper, we use separation logic to specify an important property of memory management for the Topsy operating system <ref type="bibr" target="#b1">[2]</ref>, an existing operating system for active-network cards. The property in question is memory isolation, which holds when user-level tasks cannot access kernel-level memory. Arguably, memory isolation is important because it sustained many security properties of operating systems. As usual in verification, we found it difficult to formalize this property, and this is certainly the main contribution of this paper to show a possible formalization approach, starting from the original source-code to encoding into a proof assistant.</p><p>The rest of this paper is organized as follows. In Sect. 2, we recall the basics of x86 memory models and define memory isolation for these processors. In Sect. 3, we give an overview of the source code of Topsy and explain our approach to verify memory isolation. In Sect. 4, we formally specify the functions involved in the memory or thread management, focusing on the management of privilege levels. In Sect. 5, we illustrate how we can mechanically verify above specifications using the Coq proof assistant. In Sect. 6, we conclude, and review related and future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Memory Isolation for x86 Processors</head><p>Intuitively, memory isolation is the property that userlevel threads cannot access kernel-level memory. Although the distinction between user-level and kernel-level threads is common in operating systems, the way they access memory always relies on the underlying hardware mechanisms provided by the processor.</p><p>Programs for x86 processors access memory in terms of segments, i.e., fixed-size arrays of memory. This segmentbased access to memory is enforced by the use of segment registers (so-called cs, ss, ds, es, fs, gs registers) that are used to access physical memory through the use of logical addresses. Logical addresses consist of a segment and an offset, and are translated to physical addresses by the <ref type="table">hardware based on a conversion table loaded in physical  memory and called the global descriptor table (GDT)</ref> and pointed to by a special-purpose register called gdtr 1 . x86 processors also distinguish between privilege levels, i.e., a flag that indicates whether or not the processor may accomplish some operations. The current privilege level of the code is stored in the cs register and is 0 for kernel-level threads and 3 for user-level threads. Also, each segment descriptor stored in the GDT contains a flag called descriptor level privilege that indicates the privilege of the segment.</p><p>The memory isolation property for x86 processors can be defined precisely as follows: An operating system based on a x86 segmentation memory model ensures the memory isolation property if all the kernel related memory areas are only covered by kernel privilege segments, and if all user tasks always run in user level privilege.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Memory Isolation for Topsy</head><p>In this section, we first give an overview of the implementation of Topsy (version 2) and then we explain our approach to verify memory isolation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Topsy Implementation Overview</head><p>The implementation of Topsy is standard enough to be readable by a programmer with little experience. In the following, we comment on the contents of files related to memory and thread management (around 2,000 lines, one half being assembly code). The whole source code of Topsy (around 18,000 lines, available online <ref type="bibr" target="#b2">[3]</ref>) is depicted in <ref type="figure" target="#fig_0">Fig. 1</ref>. More exactly, the GDT is partially mapped to special-purpose registers (a.k.a. segment selectors) to speed-up the translation process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Memory Model</head><p>Topsy implements two multi-threaded tasks for the kernel and the user. Accordingly, Topsy splits the memory into kernel-privilege and user-privilege segments by dividing the whole memory into four parts (each part being further divided into two segments). There are three kernelprivilege parts, that respectively contain (1) the GDT and other kernel data structures, (2) the kernel code, data and stack, and (3) a map to input/output ports; there is one user-privilege part that contains the user code, data and stack.</p><p>The memory model described above is set by the boot loader.</p><p>The latter builds the GDT before switching the processor into segmented mode (files creatgdt.inc and pm swtch.inc in directory Boot/ia32/LowCore/CoreLoad). The user-privilege segment is set during kernel initialization (files MMHal.c and mmHalAsm.S in directory Memory/ia32).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Thread Manager</head><p>Thread management amounts to thread creation/destruction and context switching.</p><p>In Topsy, these operations are implemented by the thread manager module (directory Threads).</p><p>Upon thread creation, the kernel allocates a thread descriptor, a data structure containing in particular the privilege of the thread. This data structure is built in the function threadBuild that initializes among others the privilege of the thread context (files TMThread.c and ia32/TMHal.c). Context switching is implemented by two functions to restore and save the thread context. The allocation of the processor to a thread is done by restoring the image of the processor state (function restoreContext in file ia32/TMHalAsm.S). When the thread has to release the processor, the kernel saves the thread context into the thread descriptor (function INTHandler in file ia32/TMHal.c).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">Memory Manager</head><p>The kernel initialization and the thread manager both rely on an internal memory allocation/deallocation mechanism called the heap manager (file Memory/MMHeapMemory.c).</p><p>The heap manager exploits a portion of memory called the heap that is reserved by the kernel. The function hmInit initializes the heap. The function hmAlloc is implemented by creating blocks of memory in the heap. The function hmFree implements deallocation by replacing "allocated" blocks in the heap with "free" blocks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Memory Isolation for Topsy</head><p>In this section, we explain and discuss how we verify memory isolation for Topsy.</p><p>Our approach is to specify for each function involved in the memory or thread management of Topsy its intended behavior regarding privilege handling. The extraction from source code of involved functions and the specification of their intended behaviors is based on a careful reading of the implementation we saw above. For the sake of explanation, let us represent graphically the control flow in the kernel <ref type="figure" target="#fig_1">(Fig. 2)</ref>. Following this control flow, we informally specify the intended behavior of each phase relevant to memory isolation:</p><p>• Boot loader and kernel initialization After kernel initialization, the GDT implements the memory model of Topsy and the processor is in segmented mode.</p><p>• Heap manager Under the hypothesis of a correct initialization of the heap, newly allocated blocks do not override previously allocated blocks, and only free blocks are marked as such.</p><p>• Thread manager Thread descriptors for user threads are initialized with user privilege, and context switching preserves this privilege.</p><p>In the next section, we refine these informal specifications to formal ones. Arguably, our approach of specifying a selected part of the source code is questionable because it is always possible that some rogue function breaks memory isolation in an apparently unrelated part of the operating system. However, we think that our approach is still relevant for several reasons. The first reason is that, as knowledgeable programmers, we certainly did specify the most important functions. The second reason is that code sharing limits the possibility for errors. For example, one can imagine that the message passing facilities for communication between threads may break memory isolation by mistakenly overriding thread privileges in the heap. However, since both the message passing facilities and the thread manager rely on the same heap manager, this is unlikely to happen as long as the allocation function allocates only fresh blocks, as we did specify above. Last but not least, the alternative approach of modeling, specifying, and verifying the whole source code is too complex for today's verification tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Formal Specification with Separation Logic</head><p>In this section, we formally specify memory isolation for Topsy by refining the informal requirements of the previous section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Specification Language</head><p>As stated in the introduction, we use separation logic for specification purposes. Separation logic is a language of Hoare triples {P }prg{Q} where prg is an imperative program and P, Q are logical formulas. The intended semantics is that, in any state that satisfies formula P , the execution of program prg leads to a state satisfying formula Q. In order to build sound triples, there is a collection of syntax-directed inference rules.</p><p>The novelty of separation logic is to enable specification of memory operations allowed in imperative programs with advanced pointer usage. Let us briefly skim through some typical formulas of separation logic. The most basic formulas are the empty formula (noted Emp) that holds only for the empty heap (noted emp) and the mapsto formula (noted l 񮽙 → e, where l is an address and e a value) that holds for the singleton heap that associated the address l with the value e. The most important formula is the separating conjunction (noted * ). Its purpose is to enable local reasoning by isolating parts of the heap between each other. More precisely, P * Q holds for a heap h iff there is a partition h1, h2 of h such that P holds for h1 and Q holds for h2. For example, l1 񮽙 → e1 * l2 񮽙 → e2 never holds when l1 = l2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Specification of the Heap Manager</head><p>The heap manager of Topsy implements allocation/deallocation primitives using a list-like data structure, hereafter called the heap-list to avoid confusion with the heap of separation logic 2 . Each element of a heap-list is a block that consists of a two-fields header and an array of memory. The header consists of the type of the block (free or allocated) and a pointer to the next block; the array of memory lies in between. The trailing header points to null and is not followed by any array of memory. Observe that the size of arrays of memory can be computed using the values of pointers.</p><p>Before specifying the heap manager, let us define a predicate to characterize the heap-list data structure. First, we define a simpler predicate to characterize arrays of memory rooted at some address l and of length sz:</p><formula xml:id="formula_0">Array l sz def = (sz = 0 ∧ emp) ∨ (sz &gt; 0 ∧ (∃e.(l 񮽙 → e)) * (Array (l + 1) (sz − 1)))</formula><p>Using the Array predicate, we can now define the Heap-list predicate:</p><formula xml:id="formula_1">Heap-list x def = ∃st.(x 񮽙 → st, nil) ∨ ∃next.(next 񮽙 = nil) ∧ (x 񮽙 → f ree, next) * (Array (x + 2) (next − x − 2)) * (Heap-list next) ∨ ∃next.(next 񮽙 = nil) ∧ (x 񮽙 → allocated, next) * (Array (x + 2) (next − x − 2)) * (Heap-list next)</formula><p>The first clause captures "empty" lists (that contain only the trailing header). The second (resp. third) clause captures lists starting with a free (resp. allocated) block.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Initialization</head><p>In this section, we specify the function that initializes the heap-list (see Sect. 3.1.3).</p><p>Let us assume that the heap of the heap manager starts at address hm base and has size hm size. The initialization function hmInit turns this area into a heap-list consisting of only one big free block. Let Heap-free be the predicate that holds for heap-lists consisting only of free blocks. Using this predicate, the specification of hmInit becomes:</p><p>{Array hm base hm size} hmInit (hm base, hm size); {Heap-free hm base}</p><p>The formal definition of the Heap-free is similar to the definition of the predicate Heap-list:</p><formula xml:id="formula_2">Heap-free x def = ∃st.(x 񮽙 → st, nil) ∨ ∃next.(next 񮽙 = nil) ∧ (x 񮽙 → f ree, next) * (Array(x + 2)(next − x − 2)) * (Heap-free next)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Allocation/Deallocation</head><p>In this section, we specify the allocation/deallocation functions of the heap manager (see Sect. 3.1.3).</p><p>The allocation function hmAlloc is implemented by searching for a large-enough free block in the heap-list. If such a block can be found, it is split into an allocated block (whose address is returned) and a free block (available for further allocations).</p><p>The specification of the allocation function consists in checking that newly allocated blocks do not use already allocated addresses. Our idea is to define a predicate that characterizes heap-lists and isolate any previously allocated block: <ref type="figure">(Heap-alloc {l,k,.</ref> . .} hm base) is the same as (Heap-list hm base) without the arrays of memory starting at addresses l,k,. . . Using this predicate, we can specify that any allocated block (starting at address x and of size sizex) do not overlap with newly allocated block (starting at address y -provided the function does not fail-and of size sizey): </p><formula xml:id="formula_3">Heap-alloc L l def = ∃st.(l 񮽙 → st, nil) ∨ ∃next.(next 񮽙 = nil) ∧ (l 񮽙 → f ree, next) * Array(l+2)(next− l−2) * Heap-alloc L next ∨ ∃next.(next 񮽙 = nil) ∧ (l 񮽙 → allocated, next) * (l / ∈ L → Array(l+2)(next− l−2)) * Heap-alloc L next ∨ ∃next.(next 񮽙 = nil) ∧ (l 񮽙 → allocated, next) * (l ∈ L → Emp) * Heap-alloc L next</formula><p>The specification of the deallocation function hmFree (omitted here by lack of space) makes use of the same predicates for the pre/post-conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Specification of the Thread Manager</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Initialization</head><p>In this section, we specify the function that initializes the thread descriptors (see Sect. 3.1.2). Recall that we want to ensure that thread descriptors initialized on behalf of the user space are properly set.</p><p>The initialization of thread descriptors is performed by the function threadBuild which takes two parameters: the privilege of the thread (parameter space, that can be either KERNEL or USER) and the location of the thread descriptor to be initialized (parameter x, of type threadPtr ). The following specification states that the creation of user-space thread initializes the fields corresponding to the registers in the thread descriptor to userprivilege (&amp; represents the binary-and operator):</p><formula xml:id="formula_4">{(space = U SER) ∧ (Array x (sizeof threadPtr))} threadBuild (space, x); {(∃ cs. x.contextPtr.tf cs 񮽙 → cs ∧ cs&amp;3 = 3) * · · · ¡ £ ¢ ¤</formula><p>for the fields cs,ds,ss,es,f s,gs * True}</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Context Switch</head><p>In this section, we specify the functions that save and restore the processor context during context switch (see Sect. 3.1.2).</p><p>The processor context consists of the value of its registers-set. There is a data structure to store these values in thread descriptors. The context-switch functions make the translation between these data structures and the processor context. In order to ensure memory isolation, we need to verify that (1) after restoring a user-privilege thread descriptor, the processor runs in user privilege, and (2) after saving a user-privilege processor context, the corresponding thread descriptor has user-privilege.</p><p>Before specifying context switch, we introduce notations to accommodate assembly code. The idea is to translate assembly code to the imperative language of separation logic. More precisely, we identify a set of variables to match registers (for example, the variable CR0 represents the CR0 register), and we model memory-based operations using pointer-based operations (for example, load operations become dereferences). The only difficulty are stack-based operations. In contrast, branching operations are easily translated because the assembly code in question does not exhibit complicated control flow.</p><p>We now formally specify the restore function (the save function is similar). The restore function consists of assembly code starting after the label restoreContext; it receives the data structure containing the processor context through the esp register. The specification below ensures that restoring a user-privilege processor context data structure does lead to a user-privilege processor context:</p><formula xml:id="formula_5">¥ (esp 񮽙 → . . . , cs, . . .) ∧ ( cs&amp;3 = 3 ∧ ...) ¡ £ ¢ ¤</formula><p>for the fields cs, ds, ss, es, f s, gs</p><formula xml:id="formula_6">¦ restoreContext: . . . { cs&amp;3 = 3 ∧ ... ¡ £ ¢ ¤</formula><p>for the registers cs,ds,ss,es,f s,gs }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Specification of the Boot Loader</head><p>In this section, we formally specify that the boot loader sets a GDT implementing the intended memory model (see Sect. 3.1.1).</p><p>The specification of the GDT amounts to an arithmetic characterization of Topsy memory model. Initially, there is an image of the GDT in the boot loader data beginning at GDT00. First, the boot loader copies the image of the GDT to its final location. Then, it fills the gdtr register with the address of the GDT (called gdtr base) and its size (equal to 5). Finally, it switches the processor into segmented mode by setting the first bit of the control register CR0. Let Valid-Segment-Descriptor be a predicate that characterizes valid segment descriptors. The specification of the boot loader becomes:</p><formula xml:id="formula_7">¢ ¤ ¥ Array GDT00 (5 * 8) * Array 1000 (5 * 8) ∧ (∀x. 0 ≤ x &lt; 5 → Valid-Segment-Descriptor(GDT00+x * 8)) ¦ § ¨ Create GDT: . . . PM Switch: . . . § CR0&amp;1 = 1 ∧ (∀x. 0 ≤ x &lt; 5 → Valid-Segment-Descriptor(gdt base+x * 8)) ¨</formula><p>The definition of the Valid-Segment-Descriptor follows. Intuitively, (Valid-Segment-Descriptor x) holds when x is the starting address of a segment descriptor that is either in kernel mode or the corresponding segment is inside the user working area:</p><formula xml:id="formula_8">Valid-Segment-Descriptor x def = ∃y0, . . . , y7. x 񮽙 → y0, . . . , y7 * True ∧ ((y5 ÷ 32)&amp;3 = 0 ∨ (y2 +2 8 * y3 +2 16 * y4 +2 24 * y7) ≥ 2 14 )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Formal Verification with Coq</head><p>In this section, we illustrate how above specifications can be verified formally using the Coq proof assistant. For this purpose, we have implemented a version of separation logic in Coq that we use to translate as faithfully as possible the original source code of Topsy. At the time of this writing, we have already translated and verified some parts of the specifications presented in the previous section and already found some issues. The corresponding Coq scripts (around 7,000 lines of scripts) are available online <ref type="bibr" target="#b3">[4]</ref>.</p><p>By way of example, let us show how we verify the initialization of the heap manager described in Sect. 4.2.1. First, we translate the source code of the hmInit function into Coq, see <ref type="figure" target="#fig_5">Fig. 3</ref>. Second, we formalize the pre/postconditions. This requires the encoding in Coq of the predicates Array and Heap-free: Using above predicates and the Coq translation of the hmInit function, we can input the corresponding Hoare triple in Coq and check whether it holds:</p><p>Lemma hmInit_verif: ∀adr size, adr&gt;0 -&gt; size&gt;4 -&gt; { Array adr size } (hmInit adr size) { Heap_free (nat_e adr) }.</p><p>Actually, it happens that the above lemma does not hold because the original hmInit builds the trailing header outside of the heap. Indeed, the addition in line 8 of source code in <ref type="figure" target="#fig_5">Fig. 3</ref> generates an out of range address. This problem is not an error in the sense that it does not lead to any abnormal behavior, but it certainly undermines reusability of functions. Modulo this correction, the proof is straightforward because the code amounts to structure assignments. In practice, we appeal to a weakest-precondition generator whose output can be solved using basic properties of separating connectives (namely, monotony and adjunction: the logical view of destructive update).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>In this paper, we presented an approach to formal verification of memory properties of low-level software using separation logic. More precisely, we specified and partly verified the property of memory isolation for the Topsy operating system. Our approach was to extract from the source code the functions involved in thread and memory management (around 300 lines of code mixing C and assembly) in order to specify them individually. In addition, we illustrated mechanical verification in the Coq proof assistant, exhibiting an issue we found in the implementation.</p><p>Related Work The delta-core project <ref type="bibr" target="#b4">[5]</ref> aims at verifying a micro-kernel written in a C-like language. Verification of properties of system calls have been specified and verified in the PowerEpsilon proof assistant after source code translation. The main difference with our work is that we focus on properties of memory management.</p><p>The VFiasco project <ref type="bibr" target="#b5">[6]</ref> aims at verifying memory properties of a micro-kernel. The approach is to automatically translate a subset of the C++ language into the PVS proof assistant where a model of x86 processors has been implemented. The translation process seems to be the current challenge this project is facing.</p><p>The implementation of separation logic we did in the Coq proof assistant is similar to work by Weber in Isabelle <ref type="bibr">[7]</ref>. The main difference is technical: we use an abstract data type implemented by means of modules for the heap whereas Weber uses partial functions.</p><p>Future Work Specifications written with lists are difficult to work with. In order to facilitate verification, we are currently implementing lemmas to prove properties of linked lists. In contrast, portions of code that only deal with assignments and branching instructions should be handled automatically. For that purpose, we plan to interface our Coq implementation of separation logic with existing work an automation of verification of separation logic <ref type="bibr">[8]</ref>. Definition null := (int_e 0%Z).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Axiom size : nat.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Topsy Source Code</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Topsy Control Flow</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Heap-alloc {x−2,y−2} hm base * Array x sizex * Array y size ∧ y 񮽙 = 0) ∨ (Heap-alloc {x−2} hm base * Array x sizex ∧ y = 0) ¦ £ £ § £ £ ¨ The formal definition of the Heap-alloc predicate follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fixpoint</head><label></label><figDesc>Array (x:loc) (sz:nat) : assert := match sz with O =&gt; Emp | S n =&gt; (fun s =&gt; fun h =&gt; ∃y, ((int_e (loc2val x)) |-&gt; (int_e y)) s h) ** (Array (S x) n) end. Inductive Heap_free: expr-&gt;store.s-&gt;heap.h-&gt;Prop := heap_nil: ∀e s h status next, eval next s = 0 -&gt; (e|--&gt;status::next::nil) s h -&gt; Heap_free e s h | heap_cons: ∀e s h next h1 h2 x y, y 񮽙 = 0 -&gt; disjoint h1 h2 ∧ equal h (union h1 h2) -&gt; eval e s = loc2val x -&gt; eval next s = loc2val y -&gt; (e|--&gt;Free::next::nil ** Array(x+2)(y-x-2) s h1 -&gt; Heap_free next s h2 -&gt; Heap_free e s h.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Error hmInit(Address addr) 5 { 6 start = (HmEntry)addr; 7 start-&gt;next = (HmEntry) ((unsigned long)addr + 8 KERNELHEAPSIZE + sizeof(HmEntryDesc)); 9 start-&gt;status = HM_FREED; 10 11 end = start-&gt;next; 12 end-&gt;next = NULL; 13 end-&gt;status = HM_ALLOCATED; 14 15 hmLock = &amp;hmLockDesc; 16 lockInit( hmLock); 17 18 return HM_INITOK; 19 } 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>3 4</head><label>3</label><figDesc>Definition hmInit (adr:loc) := 5 ( 6 hmStart &lt;-(nat_e adr); 7 hmStart -.&gt; next *&lt;-(nat_e adr) +e 8 (nat_e size) +e (int_e 2); 9 hmStart -.&gt; status *&lt;-Free; 10 11 hmEnd &lt;-* hmStart -.&gt; next; 12 hmEnd -.&gt; next *&lt;-null; 13 hmEnd -.&gt; status *&lt;-Allocated 14 15 (* locking operations elapsed *) 16 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: hmInit source code (original C code on the left, Coq translation on the right)</figDesc></figure>

			<note place="foot" n="2"> Readers familiar with separation logic will observe that we do not use the standard allocation/deallocation primitives.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Separation Logic: A Logic for Shared Mutable Data Structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th IEEE Symposium on Logic in Computer Science (LICS 2002</title>
		<imprint>
			<biblScope unit="page" from="55" to="74" />
		</imprint>
	</monogr>
	<note>Invited lecture</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Topsy v3: A NodeOS For Network Processors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lukas</forename><surname>Ruf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claudio</forename><surname>Jeker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Boris</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernhard</forename><surname>Plattner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd International Workshop on Active Network Technologies and Applications</title>
		<imprint>
			<publisher>ANTA</publisher>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title/>
		<ptr target="http://www.tik.ee.ethz.ch/~topsy/Source" />
	</analytic>
	<monogr>
		<title level="j">Browsable Topsy Source Tree</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Formal Verification of Memory Isolation for Topsy</title>
		<ptr target="http://web.yl.is.s.u-tokyo.ac.jp/~affeldt/seplog.Coqscripts" />
		<imprint/>
	</monogr>
	<note>Work in progress</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ming-Yuan</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lei</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guang-Zhe</forename><surname>Xiong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">A Provably Correct Operating System: delta-Core. Operating Systems Review</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="17" to="33" />
			<date type="published" when="2001-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The VFiasco Approach for a Verified Operating System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Hohmuth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hendrik</forename><surname>Tews</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd ECOOP Workshop on Program Languages and Operating Systems</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
