<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:39+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Provably Good Global Buffering Using an Available Buffer Block Plan</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Feodor</forename><forename type="middle">F</forename><surname>Dragan</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Ion M˘ andoiu †</roleName><forename type="first">Andrew</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">College of Computing</orgName>
								<orgName type="institution">Georgia Institute of Technology</orgName>
								<address>
									<postCode>30332-0280</postCode>
									<settlement>Atlanta</settlement>
									<region>GA</region>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sudhakar</forename><surname>Muddu</surname></persName>
							<email>muddu@mti.sgi.com</email>
							<affiliation key="aff2">
								<orgName type="institution">Silicon Graphics, Inc</orgName>
								<address>
									<postCode>94039</postCode>
									<settlement>Mountain View</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Zelikovsky</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Georgia State University</orgName>
								<address>
									<postCode>30303</postCode>
									<settlement>Atlanta</settlement>
									<region>GA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">UCLA</orgName>
								<address>
									<postCode>90095-1596</postCode>
									<settlement>Los Angeles</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Provably Good Global Buffering Using an Available Buffer Block Plan</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>To implement high-performance global interconnect without impact-ing the performance of existing blocks, the use of buffer blocks is increasingly popular in structured-custom and block-based ASIC/SOC methodologies. Recent works by Cong et al. [6] and Tang and Wong [25] give algorithms to solve the buffer block planning problem. In this paper we address the problem of how to perform buffering of global nets given an existing buffer block plan. Assuming as in [6, 25] that global nets have been already decomposed into two-pin connections, we give a provably good algorithm based on a recent approach of Garg and Könemann [8] and Fleischer [7]. Our method routes connections using available buffer blocks, such that required upper and lower bounds on buffer intervals-as well as wirelength upper bounds per connection-are satisfied. Unlike [6, 25], our model allows more than one buffer to be inserted into any given connection. In addition, our algorithm observes buffer parity constraints, i.e., it will choose to use an inverter or a buffer (= co-located pair of inverters) according to source and destination signal parity. The algorithm outperforms previous approaches [6] and has been validated on top-level layouts extracted from a recent high-end microprocessor design.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A key consequence of the semiconductor technology roadmap <ref type="bibr" target="#b23">[23]</ref> is the dominant effect of interconnect in deep-submicron design. As clock frequencies reach and exceed the gigahertz level, each toplevel global net must undergo repeater insertion (among other optimizations; see <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b20">20]</ref>) to maintain signal integrity and reasonable signal delay. <ref type="bibr" target="#b1">1</ref> Estimates of the need for repeater insertion range up to O10 6 repeaters for top-level on-chip interconnect when we reach the 50nm technology node. These repeaters are large (anywhere from 40 to 200 minimum inverter size), affect global routing congestion, can entail non-standard cell height and special power routing requirements, and can act as noise sources. In a blockor reuse-based methodology, designers seek to isolate repeater for global interconnect from individual block implementations.</p><p>For these reasons, a buffer block methodology has become increasingly popular in structured-custom and block-based ASIC/SOC methodologies. Two recent works by Cong et al. <ref type="bibr" target="#b6">[6]</ref> and Tang and Wong <ref type="bibr" target="#b25">[25]</ref> give algorithms to solve the buffer block planning problem. Their buffer block planning formulation is roughly stated as: Given a placement of circuit blocks, and a set of two-pin connections with a feasible region for a single buffer per connection, plan the shape and location of buffer blocks so as to maximally use available free space and minimally impact the existing floorplan.</p><p>This work was partially supported by Cadence Design Systems, Inc. and the MARCO Gigascale Silicon Research Center. Andrew B. Kahng is now Professor of Computer Science and Engineering, and of Electrical and Computer Engineering, at the University of California, San Diego. Feodor Dragan is now Associate Professor of Mathematics and Computer Science at Kent State University. Sudhakar Muddu is now with Sanera Systems, Inc.</p><p>1 Following the literature, we will use the terms buffer and repeater fairly interchangeably. When we need to be more precise: a repeater can be implemented as either an inverter or as a buffer (= two co-located inverters).</p><p>The formulation of <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b25">25]</ref> requires a single buffer per connection. This allows use of computational geometry and network flows with respect to feasible regions, and the buffer block plan implicitly contains the global buffering solution for the netlist of connections. However, in reality, multiple buffers are often needed per connection. For example, global repeater rules for a high-end microprocessor design in 0.25µm CMOS <ref type="bibr" target="#b14">[14]</ref> require repeater intervals of at most 4500µm. <ref type="bibr" target="#b2">2</ref> The number of buffers needed for a given connection depends strongly on the length of the connection; as noted in <ref type="bibr" target="#b14">[14]</ref>, the repeater interval is not only required for delay reduction, but also for crosstalk noise immunity and edge slewtime control. We also note that buffer block resources may not always be completely plannable -buffer sites are often embedded in IP blocks or in block "collars" within a hierarchical ASIC/SOC methodology.</p><p>In this paper, we address the problem of how to perform buffering of global nets given an existing buffer block plan. (Hence, our work is compatible with and complements the methods in <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b25">25]</ref>.) Assuming as in <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b25">25]</ref> that global nets have been already decomposed into two-pin connections, we give a provably good algorithm based on a recent approach of <ref type="bibr">Garg and Könemann [8]</ref> and Fleischer <ref type="bibr" target="#b7">[7]</ref>. Our method routes connections using available buffer blocks, such that required upper and lower bounds on repeater interval -as well as length upper bounds per connection -are satisfied. Notably, unlike <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b25">25]</ref> our model allows more than one buffer to be inserted into any given connection. In addition, our algorithm observes repeater parity constraints, i.e., it will choose to use an inverter or a buffer (= co-located pair of inverters) according to source and destination signal parity. Informally, our problem is defined as follows. Given:</p><p>񮽙 a planar region with rectangular obstacles; 񮽙 a set of source-destination pairs (point pairs) in the region; 񮽙 each pair has a parity requirement; 񮽙 each (timing-driven) source-destination pair has a limit on the length of its path, i.e., there is a prescribed bound that limits the number of used repeaters; 񮽙 a set of buffer blocks, each with given capacity; and 񮽙 an interval 񮽙L;U 񮽙 that defines lower and upper bounds on the distance between repeaters.</p><p>Global Buffering Problem: Construct a route for each sourcedestination pair, such that each route passes through zero or more repeaters, subject to: 񮽙 the distance between the source of a route and its first repeater is between L and U; 񮽙 the distance between any two consecutive repeaters on any given route is between L and U; 3 񮽙 the distance between the last repeater on a route and the route's destination is again between L and U; 񮽙 the number of routes passing through any given buffer block does not exceed that block's capacity;</p><p>񮽙 the number of repeaters on each source-destination route should be of the given parity (if necessary, to achieve the parity condition, the route can use two sites in a single buffer block, i.e., a buffer instead of an inverter; in this case we use two units of the block's capacity); 񮽙 the number of repeater sites on each source-destination route should not exceed the given limit (upper bound). 4</p><p>Note that coupling awareness is built into the user-prescribed repeater interval, via the switch-factor methodology <ref type="bibr" target="#b13">[13]</ref> which accounts for best-and worst-case Miller coupling between adjacent nets. Typically, switch factors between 0 and 2, or between -1 and 3, are used to multiply the nominal victim-aggressor coupling capacitance when doing timing analysis. Then, repeater intervals are calculated to maximize interconnect performance, subject to bounds on noise and delay uncertainty <ref type="bibr" target="#b12">[12]</ref>.</p><p>The most simple-minded implementation of our approach will treat all source-sink paths as "equally critical": buffers are inserted at the same regular interval along each source-sink path, independent of the path's length. However, we note that if a particular source-sink path is not timing-critical, our method allows net ordering that would process it last, or net weighting that would decrease the priority of its claim on buffer resources. Post-processing of the solution could remove inserted buffers (starting at most-used blocks) until further removal violates some actual timing budget. On the other hand, in early chip planning stages it is typical for aggressive or "optimal" buffering to be performed, so that all global paths are as fast as possible <ref type="bibr" target="#b9">[9]</ref>. This breaks the chicken-egg problem of budgeting betweenblock and within-block paths in pre-synthesis RTL planning; it also allows maximum timing budgets for within-block timing paths. <ref type="bibr" target="#b5">5</ref> Our paper is organized as follows. In Section 2, we reduce the Global Buffering Problem to a generalized version of integer multicommodity flow (MCF), and in Section 3 we give algorithms for approximating the optimal fractional relaxation of this MCF -for both maximum-routing and minimum-routing-cost formulations -within any desired accuracy. Our algorithm is based on recent results of <ref type="bibr" target="#b8">[8]</ref> and <ref type="bibr" target="#b7">[7]</ref>, which we extend to a vertex-capacitated context. Section 4 describes a randomized rounding procedure that converts nearoptimal fractional MCF solutions to near-optimal integral solutions. MCF based heuristics (with or without randomized rounding) have been applied to VLSI global routing <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b3">3,</ref><ref type="bibr" target="#b11">11]</ref>. However, global routing appears less naturally suited for MCF than our Global buffering problem; it does not seem to yield as strong theoretical bounds nor as effective implementations. Section 5 describes the four Global Buffering heuristics that we have implemented: (i) Greedy, (ii) ε-approximate MCF (ε-MCF), (iii) Greedy enhancement of ε-MCF (ε-MCFG), and (iv) "1-Shot". Finally, Section 6 gives the results of these heuristics on test cases extracted from top-level layout of a recent high-end microprocessor, and Section 7 concludes with a list of open research directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Integer Multicommodity Flow Formulation</head><p>Assume that we have K pairs of terminals s k ; t k , and n buffer blocks fr 1 ; : : : ; r n g . Denote S = fs 1 ; : : : ; s K g , T = f t 1 ; : : : ; t K g , R = f r 1 ; : : : ; r n g . Let also cr 2 N denote the capacity of the buffer block r 2 R, a k 2 f even, oddg be the parity requirement for pair s k ; t k , and l k be the prescribed upper bound on the number of buffers on path between source s k and destination t k .</p><p>We construct a graph G = V ; E as follows. Let p xy be a rectilinear path connecting points x and y of a planar region that avoids all rectangular obstacles given in the region. Denote by dx; y the length of a shortest such path. The vertex set V of G is S 񮽙 T 񮽙 R. <ref type="bibr" target="#b4">4</ref> Our approach also handles the variant where each source-destination pair has a weight (importance or criticality of each pair) and a measure of cost is to be minimized. <ref type="bibr" target="#b5">5</ref> Thus, blocks can go through synthesis, place and route with more aggressive area targets. A strategy of uniform buffering of as many global nets as possible also helps control signal integrity and delay uncertainty issues.</p><p>The edge set E contains all edges of type vv, v 2 R, (such an edge is called a loop), as well as all edges xy for which L dx; y U.</p><p>(This graph can be constructed using, e.g., shortest paths in visibility graphs <ref type="bibr" target="#b22">[22]</ref>.)</p><p>We will use the following definition of an s k ; t k -path. A path p = s k ; v 1 ; v 2 ; : : : ; v l ; t k in G between the k th source s k and sink t k is an s k ; t k -path if 񮽙 v i 2 R for each i = 1; : : : ; l , 񮽙 there exists at most one pair of different indices i; j 2 f 1 ; : : : ; l g such that v i = v j (i.e., v i and v j represent the same buffer block), and in this case we must have ji, jj = 1, 񮽙 the parity of l is a k , 񮽙 l l k .</p><p>Having this graph and the definition of s k ; t k -path, our problem is as follows. For every pair of terminals s k ; t k , k = 1; : : : ; K , find an s k ; t k -path, subject to the constraint that the number of times any vertex r 2 R is used in these paths should not exceed the capacity cr of r. If the problem has no solution, we want to maximize the number of pairs s k ; t k that can be connected without violating capacity, parity and timing-driven constraints. Let us call this problem the Maximum Routing-Via-Buffer-Blocks (MRVBB) problem.</p><p>The MRVBB problem can be formulated as a maximum integral multicommodity flow problem on a graph with vertex capacities. An instance consists of a graph G = V ; E with vertex capacities c : V ! N and K pairs of terminals s k ; t k , with one commodity associated with each pair. We seek a multicommodity flow such that the sum of the flows of all commodities is maximized.</p><p>Define capacities on all vertices of G as follows:</p><formula xml:id="formula_0">cv := 񮽙 1 i fv 2 S 񮽙 T ; capacity of buffer block if v 2 R:</formula><p>Let P k be the set of all possible s k ; t k -paths. We define P to be the union of all P k , i.e., P = 1 if v2 p;but vv is not a loop on p; 2 if v2 p; and vv is a loop on p:</p><p>Rather than solve the integer program directly, we consider the LP relaxation, substituting the last constraint by</p><formula xml:id="formula_1">f p 0 8p 2 P .</formula><p>We call the problem of finding an optimal solution to this LP the Maximum Fractional Routing-Via-Buffer-Blocks (MFRVBB) problem. After solving the fractional routing problem, we will apply randomized rounding to get an approximate solution for the initial MRVBB problem. (Note that, in fact, this MCF formulation can also handle routing congestion, e.g., by putting on each edge of the graph G a new vertex (pseudo buffer block) with suitable capacity.) The dual of this LP is minimize ∑ v2V wvcv subject to</p><formula xml:id="formula_2">∑ v2p wv 1 8p 2 P wv 0 8v 2 V .</formula><p>The dual can be viewed as an assignment of non-negative weights, w, to the vertices of G such that the weight of any path p 2 P is at least 1; the objective is to minimize the sum ∑ v2V wvcv. Here, the weight of the path is the sum of the weights of vertices forming this path (since p is by definition a sequence of vertices, not a set of vertices, if the path uses a loop vv then vertex v contributes twice to the weight of the path). The approximation algorithm given in the next section simultaneously solves both primal and dual problems -the dual solution is then used in proving the approximation guarantee of the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Approximation of Node-Capacitated Fractional MCF</head><p>The fractional routing problem, MFRVBB, can be solved exactly in polynomial time by any polynomial-time LP algorithm. However, such algorithms are very inefficient in practice. Two recent results in approximation algorithms allow us to obtain high-quality solutions efficiently. Our algorithm for solving the MFRVBB problem is based on the fast approximate algorithm for the maximum multicommodity flow problem on graphs with edge capacities due to <ref type="bibr">Garg and Könemann [8]</ref>. Small modifications allow us to adapt their method to our context of vertex-capacitated graphs, source-sink path parity constraints and timing-driven constraints. Moreover, we apply an idea of Fleischer <ref type="bibr" target="#b7">[7]</ref> to reduce the number of minimum weight path computations made by the algorithm.</p><p>Denote Dw = ∑ v 2 V w v c v and let αw be the weight of a minimum weight path from P (with respect to w). The dual problem is equivalent to finding a weight function w : V ! R + such that β = Dw αw is minimized (see <ref type="bibr" target="#b8">[8]</ref>). Algorithm 1 solves the MFRVBB problem for any given approximation ratio. In the algorithm, f k v denotes the flow of commodity k passing through a vertex v, and f denotes the total flow routed. The algorithm associates a weight with each vertex, and every time it routes an unit flow along some s k ; t k -path p from P k (k = 1; : : : ; K ) it multiplies the weight of every vertex on this path by 1 + ε=cv for a fixed ε (if the path uses a loop vv, then the weight of v is multiplied by 1 + 2ε=cv). Initially, every vertex v has weight δ for some constant δ. Thus, the heavier the vertex the greater the flow through it.</p><p>According to <ref type="bibr">Garg and Könemann's approximate algorithm [8]</ref>, we must route a unit flow along a lightest (with respect to current weight function w) path from P , if the weight of this path is less than 1. We also must stop after t iterations where t is the smallest number such that αw, computed with respect to vertex weights w of this iteration, is at least 1. Fleischer <ref type="bibr" target="#b7">[7]</ref> noted that instead of finding the lightest path in P , one can settle for some path within a factor of (1 + 2ε) of the lightest while obtaining a similar approximation guarantee.</p><p>Let is blog 1+2ε 1+2ε δ c).</p><p>Between updates to ¯ α, the algorithm proceeds by considering each commodity one by one. As long as the lightest path for commodity k has weight less than the minimum of 1 + 2ε times the current value of ¯ α and 1, flow is augmented along such a lightest path.</p><p>When min p2P k weightp 1 + 2ε ¯ α, commodity k + 1 is considered. After all K commodities are considered, ¯ α is updated. A total of at most K log 1+2ε 1+2ε δ minimum weight path computations are used to update α over the course of the algorithm.</p><p>Note also that the number of possible augmentations is at most K log 1+2ε 1+2ε δ . Indeed, at the start wv = δ for each vertex v. The last time the weight of a vertex is updated, it is on a path of weight less than one, and it is increased by at most a factor of 1 + 2ε. Hence, the final weight of any vertex is at most 1 + 2ε. Since every augmentation increases the weight of some sink t k (k = 1; : : : ; K ) by a factor of at least 1 + 2ε, the number of possible augmentations is at most K log 1+2ε 1+2ε δ . This, together with our observation on the number of times ¯ α is recomputed, implies a runtime of OKmlog 1+2ε 1+2ε δ for our algorithm, where m is the number of edges between buffer blocks in our graph G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1 Algorithm 1 yields a 1 + 8ε-approximation for the</head><p>MFRVBB problem by choosing δ = 1 + 2 ε 1 + 2εL , 1 2ε and ε 񮽙 : 07, where L is the number of vertices in the longest simple path of G between any source-sink pair.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof.</head><p>Our proof is an extension of the proof of Fleischer <ref type="bibr" target="#b7">[7]</ref> (see also <ref type="bibr" target="#b8">[8]</ref>) to vertex-capacitated case, and is omitted due to space constraints.</p><p>In Algorithm 1 we need to solve the following problem. Let G k (k = 1; : : : ; K ) be a subgraph of the graph G induced by vertices fs k ; t k g g R (recall that each vertex v 2 R has a loop vv 2 E). Let also each vertex v of G k have a non-negative weight wv. Find a minimum weight path p k in G k connecting s k with t k which passes through an even (odd, depending on a k ) number of vertices, with the number of vertices not exceeding l k . This path may contain at most one loop. So, the vertex weight will contribute either once or twice (in case of loop) to the weight of the path.</p><p>We will reduce this problem to the usual shortest path problem on a edge-weighted directed acyclic graph (dag) D k with 2+nl k vertices and at most n + n <ref type="bibr" target="#b2">2</ref>  Proof. Suppose it contains two such edges. Then, by "sliding-up" the path along the two edges we obtain a shorter path that visits two fewer buffers and hence still has the right parity.</p><p>Notice also that, since D k is acyclic, the shortest path connecting s k to t k can be computed in OjED k j time. <ref type="bibr" target="#b6">6</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Rounding of Fractional MCF</head><p>In the previous section we presented an algorithm for approximating the optimum fractional multicommodity flow within any desired accuracy. Since the total flow f t provides an upper bound on the optimum integral multi-commodity flow, we will be able to connect no more than f t source-sink pairs under the given capacity, parity, and path-length constraints. In this section we show how to use the fractional flow to obtain a valid routing that contains almost f t paths. The construction is based on the randomized rounding technique of Raghavan and Thomson <ref type="bibr" target="#b21">[21]</ref> (see also <ref type="bibr" target="#b19">[19]</ref>). For k = 1; : : : ; K , let f k e denote the flow of commodity k routed along arc e 2 ED k , f k u denote the flow of commodity k routed through vertex u 2 V D k , and f k = f k s k denote the total flow of commodity k. Since the underlying graph is in our case directed and acyclic, randomized rounding can be efficiently implemented as a random walk; see Algorithm 2. Note that the set P of paths of the given graph G produced by the randomized MCF rounding algorithm contains a path connecting the <ref type="bibr" target="#b6">6</ref> We have also considered the variant formulation where an overall cost bound B is given, along with a weight b k for each source-destination pair s k ; t k . Define the cost of a route to be "the number of used buffer sites, times the weight of the source-destination pair". Then, we would like to solve the problem of maximizing ∑p2P f p , subject to the additional constraint that the total cost of all (fractional) routes is not more than B. A variant of Algorithm 1 provably achieves a 1 + 8ε-approximation for this CostConstrained MFRVBB problem; we omit the details of this algorithm due to space constraints. k th source-sink pair with probability f k . Hence, P contains on average ∑ K i=1 f k = f t source-sink pairs. It is easy to see that the probability that node v is visited during the random walk for commodity k is equal to f k v. As suggested in <ref type="bibr" target="#b19">[19]</ref> for the edge-capacitated case, ensuring that no node capacities are exceeded can be accomplished by solving a multicommodity flow problem with capacities scaled down by a factor of 1 , ε for a sufficiently small ε. Using Chernoff bounds on the sum of independent Bernoulli trials <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b19">19]</ref> we can prove that, with high probability, this method routes an almost optimum number of nets without violating any node capacity: Theorem 3 If cv 5:2ln4n for every vertex v in the given graph G, then, for any positive ε 񮽙 p 5 , 1=2, jPj 1 , ε 2 OPT with probability of at least 1 , 1 n ,2e ,0:38ε 2 OPT , where OPT is the optimum number of routable nets.</p><p>In our experiments we have found that instead of scaling down node capacities, it is preferable to use a simpler approach: repeatedly drop the path in P that visits the most over-used nodes, until feasibility is achieved. We will call this the greedy-deletion algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Implemented Algorithms</head><p>In this section we will describe all implemented algorithms for the Global Buffering Problem. We first give a naive greedy algorithm and then describe a full implemented version of the solution based on the rounded approximate solution of the corresponding multicommodity flow. Finally, we describe a so-called 1-Shot heuristic which tries to find an integer solution avoiding fractional relaxation. Greedy Algorithm. If we just connect all source-sink pairs with shortest paths, then we may greatly overuse the buffer resource and obtain a non-feasible solution. If we make it feasible by using the "negative" greedy algorithm from the previous section, some pairs may still be routable afterward. We suggest a simpler algorithm which obtains a maximal feasible solution, i.e., such that no disconnected pairs can be routed. The running time is OKE where K is the number of source-sink pairs and E is the number of edges in the graph G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 3: Greedy Routing Algorithm</head><p>Input: Graph G with the source-sink pairs s i ; t i Output: Set of paths connecting pairs s k ; t k 1. For each sink-source pair s i ; t i do if there exists an s i ,t i -path satisfying parity and length constraints then nd the shortest such path P and for each buuer block r on P decrease the capacity o f r b y 1 unit if resulting capacity o f r is 0, then delete r from the graph G ε-MCFG Algorithm. The rounded ε-approximate solution for the multi-commodity flow formulation will give us a feasible solution for the Global Buffering Problem. Since the fractional relaxation is solved only approximately, the rounded solution may be not maximal, i.e., some extra pairs can be routed. Experimental results below show that the Greedy Algorithm applied on top of the rounded solution can significantly increase the number of routed nets.</p><p>The 1-Shot Heuristic. The approximation algorithm for fractional multi-commodity flow uses a very simple increment of buffer block weights used in the shortest s i ; t i -path. Intuitively, the weight increment forces subsequently routed nets to avoid usage of these buffer blocks. The idea of the 1-Shot heuristic is to apply that approach directly to the integer flow formulation. The resulting flow Fleischer's algorithm Algorithm 1 2. Round the approximate fractional solution using random walk algorithm Algorithm 2 3. Using the greedy-deletion algorithm nd feasible integer solution of Global Buuering Problem 4. Using Algorithm 3, augment the solution from step 3 to obtain a maximal feasible solution.</p><p>may be infeasible due to overuse of some buffer blocks, therefore we use the greedy-deletion algorithm to make it feasible. Finally we apply the same greedy enhancement that we use in ε-MCFG (Algorithm 4). 6 Implementation Experience</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Experimental setup</head><p>All experiments were conducted on an SGI Origin 2000 with 16 195MHz MIPS R10000 processors (only one of which is actually used by the sequential implementations included in our comparison) and 4GB of internal memory, running under IRIX 6.4 IP27. Timing (reported in CPU seconds) was performed using low-level Unix interval timers, under similar load conditions for all experiments. All algorithms were coded in C and compiled using gcc version egcs-2.90.27 with -O4 optimization.</p><p>The test instances used in our experiments were extracted from the next-generation microprocessor chip at SGI. We used an optimized floorplan of the circuit blocks and also optimized the location of the source/sink pin locations based on coarse timing budgets. We used U = 4000µm, and varied L between 500µm and 2000µm (for L = 500µm the design is typically gate dominated, for L = 2000µm the design tends to be totally wire dominated). Path-length upper bounds were computed with the formula l i = dist(s k ; t k )/1000. In our experiments, we used two different block capacities: 400, respectively 50, buffers per block. The latter value heavily constrains the routing -only a little over half of the nets can be routed -while the former usually allows routing of all nets.</p><p>At very early stages of chip planning, where our work applies, it is reasonable to consider a single repeater size (typically between 60x and 80x times minimum inverter, to give good energy-delay product as well as global line delay <ref type="bibr" target="#b2">[2]</ref>). This is reasonable since delay is actually not very sensitive to either repeater size or repeater location (within reasonable bounds), and since we are considering very long global wires. Of course, source resistance and sink input capacitance can be significantly different from those of the standard repeater: to address this, shorter distances between source and the first repeater, or longer distances between the sink and the last repeater, can be enforced by constructing a restricted set of graph G edges incident to sources and sinks.</p><p>In all instances considered the number of nets was large (around 4000), and the number of buffer blocks small (50); such values are typical for this application. Our implementation attempted to exploit this particular structure of the problem for achieving practical MCF running times. To our knowledge, MCF instances of this size have never been solved before, neither exactly, using linear programming methods <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b15">15]</ref>, nor approximately <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b10">10]</ref>. A key speed-up idea was to keep individual directed acyclic graphs for each sourcesink pair. This allows shortest path computations to be performed on graphs with no useless arcs (i.e., arcs leading into different sinks). Although this representation introduces some redundancy -buffer blocks and the arcs between them are now represented K timesthis representation still fits comfortably in the internal memory of a workstation. <ref type="table" target="#tab_1">Table 1</ref> shows the number of routed nets and the running time required by each of the algorithms included in our comparison. Note that the running time of ε-MCFR grows quadratically in 1=ε. As proved in Section 3 and illustrated in <ref type="figure">Figure 1</ref>, the quality of the fractional MCF depends linearly on ε, and this clearly affects the quality of the integral solution obtained by rounding. Quite surprisingly, however, this does not necessarily mean that we always need to solve the fractional flow with very good precision. As shown in <ref type="figure">Figure 1</ref>, running the Greedy routing algorithm starting from the solution obtained by randomized rounding leads to almost the same quality solutions for all values of ε.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Results</head><p>It can be noted that the 1-Shot heuristic, which is only slightly slower than the Greedy routing, gives significantly improved solutions. On lightly constrained instances (block capacity of 400) the 1-Shot heuristic almost matches the performance of ε ,MCFG. However, on highly constrained instances ε,MCFG retains an advantage over the 1-Shot heuristic, especially for small values of ε.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions and Future Directions</head><p>In this paper, we addressed the problem of how to perform buffering of global nets given an existing buffer block plan. Assuming as in <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b25">25]</ref> that global nets have been already decomposed into two-pin connections, we gave a provably good algorithm based on a recent approach of <ref type="bibr">Garg and Könemann [8]</ref> (see also <ref type="bibr" target="#b7">[7]</ref>). Our method routes connections using available buffer blocks, such that required upper and lower bounds on buffer intervals -as well as wirelength upper bounds per connection -are satisfied. Unlike <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b25">25]</ref>, our model allows more than one buffer to be inserted into any given connection. In addition, our algorithm observes buffer parity constraints, i.e., it will choose to use an inverter or a buffer (= co-located pair of inverters) according to source and destination signal parity. The algorithm outperforms an implementation of "greedy ripup and reroute", and has been validated on top-level layouts extracted from a recent high-end microprocessor design. It gives very good results on real-world test cases.</p><p>Our current research pursues several extensions of the MCF based approach. Examples include the following. <ref type="formula">(1)</ref>   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MCF/Round MCF/Round+Greed</head><p>Fractional MCF (b) <ref type="figure">Figure 1</ref>: The benefit of running Greedy on top of rounded MCF on instances i3 (a) and i6 (b) more precise cost models for usage of buffer blocks. For example, in a regime where power routing to buffer blocks is expensive, the first time a given buffer block is used should incur fixed cost, while second and subsequent uses (up to capacity of the station) each incur marginal cost. (2) We would like to group source-sink pairs that have a common source, so as to achieve Steiner routing solutions for multi-pin nets. On each source-sink path, the repeater interval constraint <ref type="bibr">[L,U]</ref> would still hold. (3) With N-layer metal processes, different wiring "tiers" (layer-pairs) have different performance attributes. Thus, for example, the repeater interval would be between 2500-3000µm on M3-M4, and between 4000-5000µm on M7-M8.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>k . For p 2 P, let f p be a variable2 P .</head><label></label><figDesc></figDesc><table>S K 
k=1 P denoting the flow along this path. The commodity to which this 
flow corresponds is clear from looking at indices of the end vertices 
of p. Thus, we have the following integer linear program: 
maximize ∑ p2P f p 
subject to 

∑ p2P q p v f p cv 8v 2 V 
f p 2 f 0 ; 1 g 
8 p where 

q p v := 

8 
񮽙 
: 

0 if v = 

2 p; 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Algorithm 1 : MFRVBB Algorithm Input: Graph G with source-sink pairs s k ; t k , node capacities cv Output: Flows f k v 2 񮽙0; 1񮽙, k = 1; : : : ; K , v 2 V G satisfying capacity constraints 1. Set f = 0. 2. Set wv = δ for all v 2 V . 3. Set f k v = 0 for all v 2 V and k = 1; : : : ; K . 4. For i = 1 to log 1+2ε 1+2ε δ do For k = 1 to K do Find a path p in P k with minimum weight w.r.t. w. While weightp 񮽙 minf1; δ1 + 2ε i g do f = f + 1; For all v 2 p, i f p uses a loop vv then set f k v = f k v + 2 and wv = w v 1 + 2ε cv ; else set f k v = f k v + 1 and wv = w v 1 + ε cv . Find a path p in P k with2 V and k = 1; : : : ; K .</head><label>1</label><figDesc></figDesc><table>minimum weight w.r.t. w. 
End while 
End for 
End for 
5. Output 

f 
2 log 1+2ε 

1+2ε 
δ 

, and f k v 

2 log 1+2ε 

1+2ε 
δ 

for each v </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>w i,1 be the weight function at the beginning of the i th iteration. We have w 0 v = δ for each v 2 V . For brevity denote αw i , Dw i by αi, Di respectively.2 P with weightp minf1; 1 + 2ε ¯</head><label></label><figDesc></figDesc><table>Following Fleischer, we 
cycle through the commodities, sticking with a commodity until the 
lightest source-sink path for that commodity is above an 1 + 2ε fac-
tor times a lower bound estimate of the overall lightest path. Let 
¯ 
αi be a lower bound on αi. To start, we set ¯ 
α0 = δ . As long 

as there is some p αig, we 
augment flow along p. When this no longer holds, we know that 
the weight of the lightest path is at least 1 + 2ε ¯ 
αi, and so we set 
¯ 
αi + 1 = 1 + 2 ε ¯ 
α i . Thus, throughout the course of the algo-

rithm, ¯ 

α takes on values in the set fδ1+2ε i g i2N . Since α0 δ 
and αt , 1 񮽙 1, αt 񮽙 1 + 2ε. Thus, when we stop, ¯ 

αt is be-
tween 1 and 1 + 2ε. Each increase of ¯ 
α is by an 1 + 2ε factor, hence 

the number of increases of ¯ 
α is log 1+2ε 

1+2ε 

δ (and the final value of i 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>l k ,1 + n d l i = 2 e arcs, constructed as follows: 񮽙 V D k = s k 񮽙 f r i ; j j 1 i n , 1 j l k g g f t k g 񮽙 ED k = E 1 񮽙 E 2 񮽙 E 3 , where E 1 = fs k ; r i;1 j 1 i n, s k ; r i 2 EGg E 2 = fr i; j ; r i 0 ; j+1 j 1 i;i 0 n, 1 j 񮽙 l k , r i ; r i 0 2 EGg E 3 = fr i; j ;t k j 1 i n, 1 j l k , j a k (mod 2), r i ; t k 2 EGg Here, we assume that a k = 0 if it is even, and a k = 1 if it is odd. The weight of each arc x; y in D k equals wx. Clearly, any path from s k to t k in D k visits at most l k buffers, and the number of visited buffers has the parity prescribed by a k . Moreover,r i; j ; r i; j+1 .</head><label></label><figDesc></figDesc><table>Lemma 2 The shortest path from s k to t k in D k contains at most one 
edge of the form </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Algorithm 2 : Randomized MCF rounding Input: Flows f k e 2 񮽙0; 1񮽙, k = 1; : : : ; K , e 2 E G satisfying capacity constraints Output: Set P of paths connecting pairs s k ; t k 1. For each k = 1; : : : ; K , with probability f k , d o // Find path from s k to t k using a random walk based on f k e's u s k While u 6 = t k do Pick arc u; v with probability f k u; v= f k u u v</head><label>2</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>Algorithm 4 : ε-MCF Algorithm with Greedy Enhancement (ε-MCFG) Input: Graph G with the source-sink pairs s i ; t i Output: Set of paths connecting pairs s k ; t k 1. Solve the Fractional MCF Problem with ε-approximation</head><label>4</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>Graph G with the source-sink pairs s i ; t i Output: Set of paths connecting pairs s k ; t k 1.nd a shortest s i ; t i -path P i in G For each buuer block r, set wr = w r 1 + c u r = c r 3.</head><label></label><figDesc></figDesc><table>Algorithm 5: 1-Shot Heuristic 

Input: Assign weight 1 to each buuer block in the graph G. 
2. While total overused capacity does not go down for 1 0 
iteration do 
For each i, Using greedy-deletion algorithm nd feasible solution of Global 
Buuering Problem 
4. Using Algorithm 3, augment the solution from step 3 to 
obtain a maximal feasible solution. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table>Number of routed nets / running time for the implemented algorithms 

</table></figure>

			<note place="foot" n="2"> Chip side length is now routinely at 20000µm. Multiple repeaters per connection are also implicit in the cycle time modeling of the technology roadmap [23]. 3 Our approach can also handle the case where L and U bounds differ for different source-destination pairs, and depend on the position (from source) of two consecutive repeaters on the routing path.</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">24 4191 / 4912.63 4191 / 18835</title>
		<idno>i3 500 4000 400 4212 4101 / 28.79 4207 / 39.62 4212 / 107.09 4212 / 334.17 4212 / 1211.52 4212 / 4639.23 4212 / 17929.95 i4 2000 4000 50 3962 2148 / 19.77 2179 / 23.21 2325 / 074.55 2334 / 233.80 2339 / 850.85 2347 / 3293.29 2340 / 13106.98 i5 1000 4000 50 4191 2216 / 27.32 2236 / 34.23 2378 / 109.75 2369 / 295.99 2393 / 916.63 2394 / 3659.62 2392 / 14523.98 i6 500 4000 50 4212 2223 / 28.81 2232 / 36.14 2378 / 093.26 2382 / 274.63 2389 / 916.61 2392 / 3627.42 2394 / 15872.07</idno>
		<imprint>
			<biblScope unit="volume">71</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename><surname>Ahuja</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">L</forename><surname>Magnanti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Orlin</surname></persName>
		</author>
		<title level="m">Network Flows: Theory, Algorithms, and Applications</title>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">GTX: The MARCO GSRC Technology Extrapolation System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Caldwell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Koushanfar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">L</forename><surname>Markov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Oliver</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Stroobandt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Sylvester</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="693" to="698" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A Global Router Using an Efficient Approximate Multicommodity Multiterminal Flow Algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">C</forename><surname>Carden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-K</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="316" to="321" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An Implementation of Linear and Non-Linear Multicommodity Network Flows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Nabona</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eur. J. Oper. Res</title>
		<imprint>
			<biblScope unit="volume">92</biblScope>
			<biblScope unit="page" from="37" to="53" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Performance Optimization of VLSI Interconnect Layout</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-K</forename><surname>Koh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">H</forename><surname>Madden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Integration</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1" to="94" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Buffer Block Planning for Interconnect-Driven Floorplanning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">Z</forename><surname>Pan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCAD</title>
		<meeting>ICCAD</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="358" to="363" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Approximating Fractional Multicommodity Flow Independent of the Number of Commodities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">K</forename><surname>Fleischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 40th Annual Symposium on Foundations of Computer Science</title>
		<meeting>40th Annual Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="24" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Faster and Simpler Algorithms for Multicommodity Flow and Other Fractional Packing Problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Könemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 39th Annual Symposium on Foundations of Computer Science</title>
		<meeting>39th Annual Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="300" to="309" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Cadence looks to overhaul chip design flow</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Goering</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EE Times</title>
		<imprint>
			<date type="published" when="1999-05-15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An Implementation of a Combinatorial Approximation Algorithm for Minimum-Cost Multicommodity Flow</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">V</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Oldham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Plotkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Integer Programming and Combinatorial Optimization</title>
		<meeting>Integer Programming and Combinatorial Optimization<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998" />
			<biblScope unit="volume">1412</biblScope>
			<biblScope unit="page" from="338" to="352" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An Efficient Timing-Driven Global Routing Algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X.-L</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-K</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">S</forename><surname>Kuh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="596" to="600" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Tuning Strategies for Global Interconnects in High-Performance Deep-Submicron ICs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muddu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Sarto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLSI Design</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="21" to="34" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On Switch Factor Based Analysis of Coupled RC Interconnects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muddu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Sarto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="79" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Interconnect Tuning Strategies for High-Performance ICs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muddu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Sarto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sharma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Improved Interior Point Algorithms for Exact and Approximate Solution of Multicommodity Flow Problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kamath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Palmon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th Annual ACM-SIAM Symp. on Discrete Algorithms</title>
		<meeting>6th Annual ACM-SIAM Symp. on Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="502" to="511" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Delay Bounded Buffered Tree Construction for Timing Driven Floorplanning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Dillinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lapotin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCAD</title>
		<meeting>ICCAD</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="707" to="712" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Implementation of a Combinatorial Multicommodity Flow Algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Leong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">of Series in Discrete Mathematics and Theoretical Computer Science</title>
		<editor>D.S. Johnson and C.C. McGeoch</editor>
		<imprint>
			<publisher>American Mathematical Society</publisher>
			<date type="published" when="1993" />
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="387" to="405" />
		</imprint>
	</monogr>
	<note>Network Flows and Matching</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Optimal Wire Sizing and Buffer Insertion for Low Power and a Generalized Delay Model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lillis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">K</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">T Y</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCAD</title>
		<meeting>ICCAD</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="138" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Randomized Approximation Algorithms in Combinatorial Optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Raghavan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Approximation Algorithms for NP-hard Problems</title>
		<editor>D. Hochbaum</editor>
		<meeting><address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<publisher>PWS Publishing</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="144" to="191" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Buffered Steiner Tree Construction With Wire Sizing for Interconnect Layout Optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCAD</title>
		<meeting>ICCAD</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="44" to="49" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Randomized Rounding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Thompson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Combinatorica</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="365" to="374" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>O&amp;apos;rourke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Geometry in C</title>
		<imprint>
			<date type="published" when="1993" />
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Semiconductor Industry Association, International Technology Roadmap for Semiconductors</title>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A Global Router Based on a Multicommodity Flow Model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shragowitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Keel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Integration</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="16" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Planning Buffer Locations by Network Flows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">F</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ISPD</title>
		<meeting>ISPD</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="180" to="185" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
