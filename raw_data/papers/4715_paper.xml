<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:58+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Matrix-Vector Multiplication in Sub-Quadratic Time (Some Preprocessing Required)</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Williams</surname></persName>
						</author>
						<title level="a" type="main">Matrix-Vector Multiplication in Sub-Quadratic Time (Some Preprocessing Required)</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We show that any n × n matrix A over any finite semiring can be preprocessed in O(n 2+ε) time, such that all subsequent vector multiplications with A can be performed in O(n 2 /(ε log n) 2) time, for all ε &gt; 0. The approach is combinatorial and can be implemented on a pointer machine or a (log n)-word RAM. Some applications are described.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Matrix-vector multiplication is an absolutely fundamental operation, with countless applications in computer science and scientific computing. Efficient algorithms for matrix-vector multiplication are of paramount importance. However, the sheer size of the matrix can be an issue: if the matrix is dense, then Ω(n 2 ) time is certainly required for an n × n matrix.</p><p>Suppose one allows for a slightly superquadratic (n 2+ε , for arbitrarily small ε &gt; 0) preprocessing of the matrix. How quickly can matrix-vector multiplication be done then? This question has been studied since the beginning of scientific computing, but with an almost exclusive focus on special, structured matrices (such work is briefly surveyed in the next section). To our knowledge, the general case of matrix-vector multiplication has not received attention.</p><p>We first show how to matrix-vector multiply over the Boolean semiring in sub-quadratic time with preprocessing, for arbitrary matrices. More precisely, the following theorem is proved. Theorem 1.1 For all ε ∈ (0, 1/2), every n × n Boolean matrix A can be preprocessed in O(n 2+ε ) time such that every subsequent multiplication of A with an arbitrary Boolean n-vector x can be performed in O(n 2 /(ε log n) 2 ) time, on a pointer machine or a (log n)-word RAM.</p><p>Both the preprocessing and matrix-vector multiplication algorithm are of the combinatorial/"nonalgebraic" variety. At a high level, the preprocessing algorithm encodes O(n 2 /(ε log n) 2 ) lookup tables for the matrix in a directed graph that "correlates" the tables; the multiplication algorithm looks at one entry from each of the tables, using the graph to merge results.</p><p>An immediate corollary of the theorem is a new combinatorial O(n 3 /(log n) 2 ) Boolean matrix multiplication algorithm, obtained by performing a matrix-vector multiplication for n times. In fact, the theorem implies that Boolean matrix multiplication can be computed on-line in O(n 3 /(log n) 2 ) time, in the following sense: given an n × n matrix A, and supposing that the columns of an n × n matrix B are revealed one at a time, one can maintain the product of A with the currently known B in O(n 2 /(log n) 2 ) time per column. Another application of our algorithm is that graphs can be preprocessed so that certain queries can be answered faster. For example, one can determine if a given vertex subset is a dominating set in O(n 2 /(log n) 2 ) time.</p><p>Building on our results in the Boolean setting, we generalize our algorithms to show that matrix-vector multiplication over any finite semiring can be sped up with preprocessing. Theorem 1.2 Let (R, +, ×) be a semiring on K elements. For all ε ∈ (0, 1), every n × n matrix A over R can be preprocessed in O(n 2+ε log 2 K ) time such that every subsequent matrix-vector multiplication can be performed in O(n 2 /(ε log n) 2 ) steps on a pointer machine or a (log n)-word RAM, assuming operations in R take constant time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries and Related Work</head><p>It would be infeasible to properly summarize all of the prior work on matrix preprocessing here; we shall settle for mentioning a few relevant (theory-based) references. For more information on this topic, the reader is referred to Pan <ref type="bibr">[P01]</ref>.</p><p>As mentioned earlier, the major theoretical work in matrix preprocessing has focused on structured matrices. For example, consider the case of Vandermonde matrices. In 1955, Motzkin <ref type="bibr">[M55]</ref> introduced the idea of preprocessing a polynomial such that subsequent evaluations of the polynomial can be done more efficiently. Note that, after verifying a given matrix is Vandermode, computing a matrix-vector product with that matrix is equivalent to evaluating a univariate degree-n polynomial at n points. Hence Motzkin's ideas applied to preprocessing for Vandermonde matrix-vector multiplication. Later work on polynomial evaluation used ideas similar to the Fast Fourier Transform, obtaining algorithms for Vandermonde matrix-vector multiplication that run in O(n · poly(log n)) time after preprocessing (cf. <ref type="bibr">[MB72, F72, BM75]</ref>).</p><p>In more recent work, Gohberg and Olshevsky <ref type="bibr">[GO94]</ref> have generalized previous results, showing that several classes of structured matrices (including Vandermonde) admit matrix-vector multiplication in O(n log 2 n) time, after preprocessing. Substantial works continuing in this direction have discovered fast matrix-vector multiplication algorithms for a large variety of structured matrices (e.g. Olshevsky and Shokrollai <ref type="bibr">[OS00]</ref> and Pan [P00, P01]).</p><p>Besides the work on structured matrices, another related result is that of Savage [S74] who showed thirty years ago that n × n matrix-vector multiplication over semirings with s elements can be performed in O(n 2 / log s n) arithmetic operations, without preprocessing(!). The key phrase here is "arithmetic operations": while only o(n 2 ) additions and multiplications are indeed performed, all n 2 entries of the matrix must obviously be read 1 . Thus Savage's algorithm is not sub-quadratic when one counts its steps on a typical machine model. (In interesting contrast, Winograd <ref type="bibr">[W70]</ref> showed that in general, the number of arithmetic operations necessary to multiply an n×n matrix A with an n-vector x is the optimal Ω(n 2 ) bound. The catch is that his proof requires the underlying algebra to have an unbounded number of elements.)</p><p>Let us briefly review some past combinatorial (non-algebraic) approaches to matrix multiplication. The "Four Russians" algorithm of <ref type="bibr">Arlazarov et al.</ref> [ADKF70] performs Boolean n × n matrix multiplication in O(n 3 / log n) time. (For a reference in English, cf. Aho, Hopcroft, and Ullman's book <ref type="bibr">[AHU74]</ref>.) Savage <ref type="bibr">[S74]</ref> and <ref type="bibr">Santoro [S80]</ref> observed that this time bound extends to a wide range of algebraic structures, assuming constant time arithmetic. This was eventually improved slightly to O(n 3 / log 3/2 n) time by Atkinson and Santoro <ref type="bibr">[AS88]</ref>. Rytter <ref type="bibr">[R85]</ref> (and independently <ref type="bibr">Basch, Khanna, and Motwani [BKM95]</ref>) gave an O(n 3 / log 2 n) algorithm for Boolean matrix multiplication on the (log n)-word RAM. Chan <ref type="bibr">[C06]</ref> has recently suggested (see the Discussion in the citation) that the original Arlazarov et al. algorithm may be modified to run in O(n 3 / log 2 n) on a pointer machine, although the (allegedly messy) details are not provided.</p><p>Why Our Approach is Different. To our knowledge, none of the above algorithms can be modified to solve the matrix-vector multiplication problem in O(n 2 / log 2 n) time. We shall attempt to give some brief intuition as to why this is the case. All above algorithms partition both input matrices into small blocks, where multiplications for the blocks are preprocessed and solved in advance. For example, the log 2 n speedup in matrix multiplication comes from a product of two log n speedups, one from each input matrix. In our problem, as only one matrix is being preprocessed, a log 2 n speedup of matrix-vector multiplication is not possible in the same manner 2 . Therefore we believe our approach to be a truly different method, in this regard.</p><p>A Note on Word Tricks. It is sometimes the case that logarithmic speedups come from "word tricks" that exploit the word parallelism of a RAM. We do not explicitly use word tricks in our algorithms; however, we do need a form of table lookup. The only "suspicious" operation required is that a list of pointers to the neighbors of a node v in a graph can be obtained in O(deg(v)) time, where deg(v) is the degree of v. In the literature, this is known as a neighborhood query and can be implemented on a pointer machine or (log n)-word RAM using a simple adjacency list representation. Our algorithm uses this operation to encode multiple lookup tables in a common graph. If one assumes that a neighborhood query requires Θ(deg(v) · α(n)) time for some function α, our algorithm still takes only O(n 2 α(n)/ log 2 n) to perform a matrix-vector multiplication.</p><p>Semirings. We recall the definition of a semiring. A semiring is a triple (R, +, ×) such that R is a set with distinguished elements 0 and 1, and + and × are binary operations over R, satisfying the axioms:</p><p>• (R, +) is a commutative monoid with identity 0,</p><formula xml:id="formula_0">• x × 0 = 0 × x = 0</formula><p>• (R, ×) is a monoid with identity 1,</p><formula xml:id="formula_1">• × distributes over +.</formula><p>More succinctly, a semiring is essentially a ring that is not required to have additive inverses. (Thus every ring is also a semiring.) For brevity we often refer to the semiring (R, +, ×) as just "R" when there is no chance of confusion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Fast Boolean matrix-vector multiplication</head><p>We begin by considering matrix-vector multiplication in the Boolean semiring (where R = {0, 1}, + is OR, and × is AND). The main ideas introduced here carry over to the general case. In the following, let n be a positive integer, A be an n × n Boolean matrix, x be a Boolean n-vector, and V = {1, . . . , n}.</p><p>Definition 3.1 For S ⊆ V , the neighborhood of S in directed graph (V, E) is the set</p><formula xml:id="formula_2">N (S) := {j ∈ V | (∃k ∈ S)[(k, j) ∈ E]}.</formula><p>Recall there is a simple correspondence between Boolean matrix-vector multiplication and neighborhood computations in a directed graph.</p><p>Lemma 3.1 Let G A = (V, E) be the directed graph corresponding to A, and let x be an indicator vector for a subset S ⊆ V . Then A T x is the indicator vector for N (S).</p><formula xml:id="formula_3">Proof. Let j ∈ V . Then (A T x)[j] = 1 ⇐⇒ n k=1 (A T [j, k] ∧ x[k]) = 1 ⇐⇒ n k=1 (A[k, j] ∧ x[k]) = 1 ⇐⇒ (∃k ∈ S)[(k, j) ∈ E and k ∈ S] ⇐⇒ j ∈ N (S).</formula><p>񮽙 Therefore a Boolean matrix-vector multiplication is equivalent to computing the neighborhood of a given node subset. From here on, we focus on the problem of preprocessing a graph such that neighborhood queries for a given node subset can be done in O(n 2 /(log n) 2 ) time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Neighborhood Queries for Node Subsets</head><p>In this section, we establish Theorem 1.1 from the Introduction. Given a graph G, the preprocessing phase constructs a new graph H on O(n 1+ε /(ε log n)) nodes and O(n 2+ε /(ε log n) 2 ) edges. Neighborhood subset queries shall be handled by performing local operations on portions of H. Intuitively, the graph H encodes O(n 2 /(ε log n) 2 ) different lookup tables, one for each (ε log n)×(ε log n) block of the adjacency matrix of G.</p><p>Without loss of generality, assume that ε log n divides n. For i = 1, . . . , n/ε log n, define</p><formula xml:id="formula_4">P i = {(i − 1) · ε log n + 1, . . . , i · ε log n},</formula><p>and define Π to be the partition {P 1 , . . . , P n/ε log n } of <ref type="bibr">[n]</ref>.</p><p>The graph H has two layers of nodes, both having O(n 1+ε /(ε log n)) nodes. In particular both layers have n/ε log n "groups", of O(n ε ) nodes each 3 . Each group corresponds to a part P i of Π, and each of the O(n ε ) nodes in a group of H represents one of the possible subsets of P i . Therefore the number of nodes is O(n 1+ε /(ε log n)).</p><p>Our query algorithm uses the simple fact that a subset of nodes of G can be represented as a set of n/(ε log n) nodes in a layer of H. Definition 3.2 Let x be a Boolean n-vector, and let 񮽙 ∈ {1, 2}. The 񮽙th layer node representation of x is the unique list of vertices v 1 , . . . , v n/(ε log n) in H such that</p><p>• for all i, v i is in the ith group of layer 񮽙, and</p><p>• the indicator vector for the subset corresponding to v i is equal to x[(i−1)ε log n+1, . . . , iε log n], i.e. bits (i − 1)ε log n + 1 through iε log n of x.</p><p>That is, each v i corresponds to a distinct set of ε log n bits of x.</p><p>Definition 3.3 Let S be a set of n/(ε log n) nodes, from either the first or second layer of H, such that each node is from a different group. The vector representation of S is the indicator vector for the set obtained by taking the union of all node sets corresponding to the nodes in S.</p><p>We remark that on a computational model with Θ(poly(log n)) cost per random access, the two representations above can be computed in O(n · poly(log n)) time. In one matrix-vector multiplication, both of these representations are computed only once.</p><p>We now specify where the edges of H are placed.</p><p>First Layer Edges of H. Let v be a node in the first layer. Recall v corresponds to a subset S v of V , of size at most ε log n. Note that N (S v ) can easily be determined in O(n · ε log n) time <ref type="bibr">4</ref> . Let x 1 , . . . , x n/(ε log n) be the second-layer node representation of N (S v ). Then the edges out of v are defined to be (v, x 1 ), . . ., (v, x n/(ε log n) ). The number of outgoing edges from nodes in the first layer is O(n 1+ε /(ε log n) · n/(ε log n)) = O(n 2+ε /(ε log n) 2 ). As there are O(n 1+ε /(ε log n)) nodes in the first layer, the above edges can be determined in O(n 1+ε /(ε log n) · n · ε log n) = O(n 2+ε ) time.</p><p>Second Layer Edges of H. In the second layer, there is an edge (u, v) between u and v in the same group if and only if, when construed as subsets of V , u is a subset of v. Therefore, the second layer consists of n/(ε log n) disjoint copies of the same n ε -node DAG. (In particular, this DAG is the transitive closure of the directed hypercube on 2 ε log n nodes.) Thus the number of edges between nodes in the second layer is O(n/(ε log n) · n 2ε ) = O(n 1+2ε /(ε log n)).</p><p>The figure below gives a bird's eye view of H.</p><p>Processing Neighborhood Subset Queries. Neighborhood queries for a node subset are performed on H as follows.</p><p>1. Given a node subset S as a Boolean n-vector, determine the first-layer node representation of S. Let T be the set of n/(ε log n) nodes in this representation.</p><p>2. Put a mark on every node of the set N (T ) in H. Recall that the degree of each node in the first layer is n/(ε log n). Assuming the neighbors of a node v can be marked in O(deg(v)) time, the nodes of N (T ) can be marked in O(|T | · n (ε log n) ) = O(n 2 /(ε log n) 2 ) time. (Note this stage is the bottleneck in the algorithm's runtime.) n ε n ε log n n ε n ε . . . . . . ε log n ε log n ε log n <ref type="figure">Figure 1</ref>: The graph H. Both layers have n 1+ε /(ε log n) nodes, divided into n/(ε log n) groups. Each node in H corresponds to a subset of nodes in G, with cardinality at most ε log n. In the example above, the vertices labelled 00 · · · 00 represent empty sets, and the vertices labelled 11 · · · 11 represent the set of all ε log n nodes in that respective part. Since the empty set node in the first layer has no neighbors, its edges point to the empty sets of the nodes in the second layer.</p><p>3. Fix a topological order on nodes to be used for all groups (recall that each group in the second layer is a copy of a certain DAG). Each group of n ε nodes in the second layer is processed separately as follows. Specially mark the first node u in the topological order such that all marked nodes in the group have an edge to u. To do this, obtain a count t of the total number of marked nodes in the group, then for each node in order, count its marked predecessors and compare that count with t. This needs at most O(n 2ε log n) time per group, as each edge is accessed at most once. The total runtime for this stage is O 񮽙 n ε log n · n 2ε log n 񮽙 = O(n 1+2ε ).</p><p>For ε &lt; 1/2, this is less than O(n 2 /(ε log n) 2 ).</p><p>4. Observe that each group has exactly one specially marked node. Compute the vector representation of the set of specially marked nodes, and finally, erase all node markings.</p><p>This concludes the description of the neighborhood query algorithm. Observe that the runtime of the query algorithm is dominated by the second step. The next lemma proves correctness.</p><p>Lemma 3.2 The vector representation of the set of specially marked nodes is N (S).</p><p>Proof. For j = 1, . . . , n/(ε log n), let S j denote the subset of S restricted to part P j . For each i = 1, . . . , n/(ε log n), consider the ith group of nodes in the second layer of H, representing a subset of nodes of G in part P i . When a node v in the ith group is marked, then there is a j such that the node representing S j in the first layer has an edge to v. By construction of H, the nodes of G in the subset corresponding to v are exactly the neighbors of S j that lie in P i .</p><p>It follows that the collection of all marked nodes in the ith group corresponds to all neighbors of S that lie in the part P i . More precisely, the union of the node sets in G corresponding to the marked nodes in group i of H gives bits (i − 1) · ε log n + 1 through i · ε log n of the indicator vector for N (S). Over all n/(ε log n) groups, these unions give all the bits in the indicator vector for N (S).</p><p>We claim that the third step in the algorithm accomplishes exactly this, in that for each group, the algorithm specially marks the node corresponding to the union of the sets represented by marked nodes in that group. By finding a node u in a group such that all marked nodes in that group have edges to it, this implies that the node subset in G corresponding to u is a superset of all node sets in G corresponding to the marked nodes. By finding the first node in the topological ordering with this property, the node u is the smallest cardinality node subset in G that is a superset of all sets in G corresponding to the marked nodes. That is, u corresponds to the union of the sets represented by marked nodes in the current group. 񮽙</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Application: Faster Graph Subset Queries</head><p>Beyond on-line matrix multiplication, another application of faster Boolean matrix-vector multiplication is that certain types of graph queries can be answered more rapidly than one might initially believe is possible. Here we give a few examples of such queries.</p><p>Recall that a subset S of vertices is dominating if and only if every node in the graph is either in S or has a neighbor in S, S is independent if and only if there is no edge between any two nodes in S, and S is a vertex cover if every edge has an endpoint in S. Note S is independent if and only if V − S is a vertex cover. The following proposition is straightforward.</p><p>Proposition 1 S ⊆ V is a dominating set if and only if N (S) ∪ S = V . S ⊆ V is independent if and only if N (S) ∩ S = ∅.</p><p>Hence the Boolean matrix-vector multiplication algorithm can be used to more efficiently determine if a given query subset S is dominating, independent, or a vertex cover.</p><p>Corollary 3.1 A graph G can be preprocessed in O(n 2+ε ) time such that one can determine in O(n 2 /(ε log n) 2 ) time if a given subset of nodes is dominating, independent, or a vertex cover.</p><p>The problem of finding an independent set or dominating set is quite general. As a result, certain other graph queries can also be performed in subquadratic time as well. For example, one can determine if a given query node participates in a triangle.</p><p>Corollary 3.2 A graph G can be preprocessed in O(n 2+ε ) time such that one can determine in O(n 2 /(ε log n) 2 ) time if a given query node is in a 3-cycle.</p><p>Proof. Let v u be the neighborhood vector for the query node u, obtainable in O(n) time. Determine if the set of vertices denoted by v u is independent, in O(n 2 / log 2 n) time. But this set is independent if and only if every pair of neighbors of u do not have an edge between them, i.e. if and only if u does not participate in a 3-cycle. 񮽙</p><p>Note that in the absence of preprocessing, these tasks require Ω(n 2 ) time on dense graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Matrix-vector multiplication over finite semirings</head><p>The matrix-vector multiplication scheme can be extended to all finite semirings, with a few modifications. We recall the statement of Theorem 1.2 from the Introduction for convenience: Theorem 1.2: Let (R, +, ×) be a semiring on K elements. For all ε ∈ (0, 1), every n × n matrix A over R can be preprocessed in O(n 2+ε log 2 K ) time such that every subsequent matrixvector multiplication can be performed in O(n 2 /(ε log n) 2 ) steps, assuming operations in R take constant time.</p><p>Proof. As in the Boolean case, we build a graph H with two layers, and each layer has n/(ε log n) groups of nodes, where each group represents a part P i . However, four changes are made to the preprocessing phase:</p><p>1. The number of nodes in a group is now K ε log 2 n = n ε log 2 K , for all of the possible values of a vector over R with ε log n components.</p><p>2. There are no edges between nodes in the second layer.</p><p>3. The edges from the first layer to the second layer are redefined as follows. Each ε log n part of an input vector, when multiplied with the corresponding n × ε log n submatrix of A, contributes an n-vector to the overall matrix-vector product. For a node u in the first layer, let x u be its corresponding ε log n vector over R, and let y u be the corresponding nvector obtained from left-multiplying x u by the proper n × ε log n submatrix of A. Finally, let v 1 , . . . , v n/(ε log n) be the second layer node representation of the vector y u . Then u has outgoing edges to v 1 , . . . , v n/(ε log n) . For each node u, its neighbors can be computed in O(n · ε log n) steps. Therefore O(n 1+ε log 2 K /(ε log n) · n · ε log n) = O(n 2+ε log 2 K ) semiring operations and computation steps suffice for determining the edges.</p><p>4. For every node u in the second layer, maintain a variable c u that is set to 0 ∈ R at the start of a query.</p><p>Multiplication of A with an n-vector x is performed as follows:</p><p>1. For all n/(ε log n) nodes in the first layer node representation of x, starting with the node in group 1, compute the node's list of neighbors u 1 , . . . , u n/(ε log n) in the second layer, and set c u i := c u i + 1 for all i, where + is over the semiring. These counts and neighbor queries can be computed in O(n 2 /(ε log 2 n)) additions and computation steps, using fast neighborhood queries and the assumption that operations in R take constant time.</p><p>2. For each node u in the second layer, let y u be its corresponding ε log n vector over R. Set y u := c u × y u . That is, y u is obtained by semiring-multiplying the scalar c u with each component of y u . This takes O(ε log n) arithmetic operations for each node in the second layer.</p><p>3. For each group i = 1, . . . , n/(ε log n), compute the sum of all y u . That is, determine</p><formula xml:id="formula_5">z i = u in group i c u y u ,</formula><p>and output the block vector [z 1 z 2 · · · z n/(ε log n) ] T .</p><p>The multiplications take O(n ε ·poly(log n)) time per group, and the sum takes O(n ε ·poly(log n)) time as well. (Note that no table lookup is required to achieve these runtimes.) Hence the number of steps taken by stages 2 and 3 is O(n 1+ε · poly(log n)).</p><p>The runtime analysis is already embedded in the description of the algorithm. We now prove that the output vector is indeed Ax. We need to show that for the ith group of ε log n components of Ax, the corresponding sum z i is equal to it. Without loss of generality, let us only consider group 1. Then formally our objective is to show (Ax)[1, . . . , ε log n] = z 1 .</p><p>Observe that by construction, the number of times that an increment occurs to some c u in group 1 is n/(ε log n). Let u 1 , . . . , u n/(ε log n) be the temporal sequence of second layer nodes in group 1 whose c u i 's were incremented, i.e. u 1 is a neighbor of a first layer node in group 1, u 2 is a neighbor of a first layer node in group 2, etc. (Notice that the sequence has repetitions, for n ε &lt; n/(ε log n).) Then, letting y u i be the vector corresponding to u i , y u i = A i x i , where A i is the matrix A restricted to rows 1, . . . , ε log n and columns (i − 1)ε log n + 1, . . . , iε log n, and</p><formula xml:id="formula_6">x i = x[(i − 1)ε log n + 1, . . . , iε log n].</formula><p>By distributivity of R, and commutativity of +, </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>We have demonstrated how preprocessing makes it possible to achieve sub-quadratic matrix-vector multiplication for all constant-sized semirings. Our method implies an on-line combinatorial matrix multiplication algorithm, in the sense that a Θ(log 2 n) speedup is achieved even if the columns of one input matrix are only revealed one at a time.</p><p>We conclude with three interesting open problems. First, it might be of more practical importance if one could obtain a speedup of matrix-vector multiplication for sparse matrices. A time bound of the form O(m/poly(log n) + n) is desirable, but it is not clear how to extend our ideas to this case. Another interesting question is whether or not the algebraic methods for matrix multiplication (such as Strassen's <ref type="bibr">[S69]</ref>, Coppersmith-Winograd's <ref type="bibr">[CW90]</ref>, etc.) can be applied to our problem of matrix-vector multiplication with preprocessing. This possibility seems unlikely to us, but we have not rigorously ruled it out. The power of algebraic matrix multiplication algorithms stems from the redundancy in multiplying different pairs of the same collections of vectors. Such redundancy is not present in matrix-vector multiplication.</p><p>Finally, is it possible to combine our preprocessing techniques with others to achieve a nonalgebraic o(n 3 / log 2 n) Boolean matrix multiplication algorithm? Achieving such an algorithm is an important open problem at the intersection of theory and practice that has resisted many efforts. The answer would be yes if, for example, it were possible to preprocess an n × n matrix so that it can be multiplied with an arbitrary n × log n matrix in o(n 2 / log n) time.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>u</head><label></label><figDesc>in group 1:∃i.u=u i c u y u = u in group 1 c u y u , the second equality following since all other c u are 0. Finally, by definition of A i and x i , (Ax)[1, . . . , ε log n] = n/(ε log n) i=1 (A i x i ) = n/(ε log n) i=1 y u i , therefore the output of group 1 is indeed the first ε log n components of Ax, i.e. (Ax)[1, . . . , ε log n] = z 1 . 񮽙</figDesc></figure>

			<note place="foot" n="1"> Very briefly, Savage&apos;s approach is to generate a table of all O(log n)-vectors over the semiring in a Gray-code ordering, and compute the dot product of each vector on the list with various components of the input vector. The Gray code ensures that each dot product takes O(1) additions and multiplications, amortized.</note>

			<note place="foot" n="2"> Avrim Blum has pointed out to us that a Θ(log n)-speedup of matrix-vector multiplication is indeed possible using a &quot;Four Russians&quot; approach. We invite the reader to verify this.</note>

			<note place="foot" n="3"> In the following, we omit the ceilings for notational convenience.</note>

			<note place="foot" n="4"> With possibly a log n factor extra in computational models with limited random access.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Acknowledgements</head><p>I thank Avrim Blum for introducing me to the problem of preprocessing a graph such that vertex cover queries can be efficiently computed. This investigation led to the present work. Thanks to the SODA referees for helpful comments and references to the literature.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The Design and Analysis of Computer Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974" />
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On economical construction of the transitive closure of a directed graph</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">Z</forename><surname>Arlazarov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">A</forename><surname>Dinic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Kronrod</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">A</forename><surname>Faradzev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Doklady Adamedii Nauk SSSR</title>
		<imprint>
			<biblScope unit="volume">194</biblScope>
			<biblScope unit="page" from="487" to="488" />
			<date type="published" when="1970" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A practical algorithm for Boolean matrix multiplication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Atkinson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Santoro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Proc. Letters</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="37" to="38" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">On Diameter Verification and Boolean Matrix Multiplication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Basch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<idno>No. STAN-CS-95-1544</idno>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Stanford University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">The Computational Complexity of Algebraic and Numerical Problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Borodin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Munro</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975" />
			<publisher>Elsevier</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">All-Pairs Shortest Paths with Real Weights in O(n 3 / log n) Time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">M</forename><surname>Chan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop on Algorithms and Data Structures (WADS)</title>
		<meeting>Workshop on Algorithms and Data Structures (WADS)</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="318" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">All-Pairs Shortest Paths for Unweighted Undirected Graphs in o(mn) Time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">M</forename><surname>Chan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIAM Symposium on Discrete Algorithms (SODA)</title>
		<meeting>ACM-SIAM Symposium on Discrete Algorithms (SODA)</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="514" to="523" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Matrix Multiplication via Arithmetic Progressions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Coppersmith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Winograd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symb. Comput</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="251" to="280" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Polynomial evaluation via the division algorithm-the Fast Fourier Transform revisited</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">M</forename><surname>Fiduccia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symposium on Theory of Computing (STOC)</title>
		<meeting>ACM Symposium on Theory of Computing (STOC)</meeting>
		<imprint>
			<date type="published" when="1972" />
			<biblScope unit="page" from="88" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Fast algorithms with preprocessing for matrix-vector multipication problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Gohberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Olshevsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Complexity</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="411" to="427" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Evaluation of polynomials and evaluation of rational functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S</forename><surname>Motzkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bulletin of American Mathematical Society</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<date type="published" when="1955" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Fast modular transforms via division</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Moenck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Borodin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 13th Annual Symposium on Switching and Automata Theory</title>
		<meeting>IEEE 13th Annual Symposium on Switching and Automata Theory</meeting>
		<imprint>
			<date type="published" when="1972" />
			<biblScope unit="page" from="90" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Matrix-vector product for confluent Cauchy-like matrices with application to confluent rational interpolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Olshevsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shokrollahi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symposium on Theory of Computing (STOC)</title>
		<meeting>ACM Symposium on Theory of Computing (STOC)</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="573" to="581" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Nearly optimal computations with structured matrices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">Y</forename><surname>Pan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIAM Symposium on Discrete Algorithms (SODA)</title>
		<meeting>ACM-SIAM Symposium on Discrete Algorithms (SODA)</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="953" to="962" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Structured Matrices and Polynomials: Unified Superfast Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">Y</forename><surname>Pan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
			<publisher>Birkhäuser-Springer</publisher>
			<pubPlace>Boston and New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Fast Recognition of Pushdown Automaton and Context-free Languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Rytter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Control</title>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="12" to="22" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An algorithm for the computation of linear forms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">E</forename><surname>Savage</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="150" to="158" />
			<date type="published" when="1974" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Extending the Four Russians&apos; Bound to General Matrix Multiplication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Santoro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Proc. Letters</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="87" to="88" />
			<date type="published" when="1980" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Gaussian elimination is not optimal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Strassen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Numer. Math</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="354" to="356" />
			<date type="published" when="1969" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On the number of multiplications necessary to compute certain functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Winograd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. Pure and Applied Math</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="165" to="179" />
			<date type="published" when="1970" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
