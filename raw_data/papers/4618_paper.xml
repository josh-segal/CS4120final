<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:55+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Effective Hybrid Transactional Memory System with Strong Isolation Guarantees</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chi</forename><surname>Cao</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Systems Laboratory</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Minh</forename></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Systems Laboratory</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Trautmann</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Systems Laboratory</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jaewoong</forename><surname>Chung</surname></persName>
							<email>jwchung@stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Systems Laboratory</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Austen</forename><surname>Mcdonald</surname></persName>
							<email>austenmc@stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Systems Laboratory</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Bronson</surname></persName>
							<email>nbronson@stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Systems Laboratory</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jared</forename><surname>Casper</surname></persName>
							<email>jaredc@stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Systems Laboratory</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christos</forename><surname>Kozyrakis</surname></persName>
							<email>kozyraki@stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Systems Laboratory</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kunle</forename><surname>Olukotun</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Systems Laboratory</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">An Effective Hybrid Transactional Memory System with Strong Isolation Guarantees</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C12 [Processor Architec- tures]: Multiple Data Stream Architectures -MIMD processors; D13 [Programming Techniques]: Concurrent Programming -par- allel programming General Terms: Performance</term>
					<term>Design</term>
					<term>Languages Keywords: Transactional Memory</term>
					<term>Strong Isolation</term>
					<term>Multi-core Architectures</term>
					<term>Parallel Programming</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We propose signature-accelerated transactional memory (SigTM), a hybrid TM system that reduces the overhead of software transactions. SigTM uses hardware signatures to track the read-set and write-set for pending transactions and perform conflict detection between concurrent threads. All other transactional functionality, including data versioning, is implemented in software. Unlike previously proposed hybrid TM systems, SigTM requires no modifications to the hardware caches, which reduces hardware cost and simplifies support for nested transactions and multithreaded processor cores. SigTM is also the first hybrid TM system to provide strong isolation guarantees between transactional blocks and non-transactional accesses without additional read and write barriers in non-transactional code. Using a set of parallel programs that make frequent use of coarse-grain transactions, we show that SigTM accelerates software transactions by 30% to 280%. For certain workloads, SigTM can match the performance of a full-featured hardware TM system, while for workloads with large read-sets it can be up to two times slower. Overall, we show that SigTM combines the performance characteristics and strong isolation guarantees of hardware TM implementations with the low cost and flexibility of software TM systems.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Transactional Memory (TM) <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b0">1]</ref> is emerging as a promising technology to address the difficulty of parallel programming Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. ISCA'07, June 9-13, 2007, San Diego, California, USA. Copyright 2007 ACM 978-1-59593-706-3/07/0006 ...$5.00.</p><p>for multi-core chips. With TM, programmers simply declare that code blocks operating on shared data should execute as atomic and isolated transactions with respect to all other code. Concurrency control as multiple transactions execute in parallel is the responsibility of the system.</p><p>Transactional memory can be implemented in hardware (HTM) or software (STM). HTM systems use hardware caches to track the data read or written by each transaction and leverage the cache coherence protocol to detect conflicts between concurrent transactions <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b21">21]</ref>. The advantage of hardware support is low overhead. Transactional bookkeeping takes place transparently as the processor executes load and store instructions. The disadvantage of HTM is complexity and cost, as the caches and the coherence protocol must be redesigned. It is also difficult to justify new hardware features without significant experience with a large body of transactional software. STM systems implement all bookkeeping in software using instrumentation code (read and write barriers) and software data structures <ref type="bibr" target="#b14">[14,</ref><ref type="bibr" target="#b23">23,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b15">15]</ref>. STM frameworks run on existing hardware and can be flexibly modified to introduce new features, provide language support, or adapt to specific application characteristics. The disadvantage of the software-only approach is the runtime overhead due to transactional bookkeeping. Even though the instrumentation code can be optimized by compilers <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b15">15]</ref>, STM can still slow down each thread by 40% or more.</p><p>Apart from the cost/performance tradeoff, there are important semantic differences between HTM and STM. HTM systems support strong isolation, which implies that transactional blocks are isolated from non-transactional accesses <ref type="bibr" target="#b18">[18]</ref>. There is also a consistent ordering between committed transactions and non-transactional accesses. In contrast, high-performance STM systems do not support strong isolation because it requires read and write barriers in non-transactional code and leads to additional runtime overhead. As as result, STM systems may produce incorrect or unpredictable results even for simple parallel programs that would work correctly with lock-based synchronization <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b25">25]</ref>. This paper introduces signature-accelerated TM (SigTM), a hybrid transactional memory implementation that reduces the overhead of software transactions and guarantees strong isolation between transactional and non-transactional code. SigTM uses hardware signatures to conservatively represent the transaction read-set and write-set. Conflict detection and strong isolation are supported by looking up coherence requests in the hardware signatures <ref type="bibr" target="#b4">[5]</ref>. All other functionality, including transactional versioning, commit, and rollback, is implemented in software. Unlike previously proposed hybrid schemes <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b24">24]</ref>, SigTM requires no modifications to hardware caches, which reduces SigTM's hardware cost, simplifies crucial features (support for OS events, nested transactions, and multithreading), and eliminates negative interference with other cache operations (prefetching and speculative accesses). Moreover, SigTM is a stand-alone hybrid TM that does not require two operation modes or two code paths. SigTM is also the first hybrid TM system to implement strong isolation without additional barriers in non-transactional code.</p><p>The specific contributions of this work are:</p><p>• We describe the hardware and software components of SigTM, a hybrid transactional memory system that uses hardware signatures for read-set and write-set tracking. SigTM improves the performance of software transactions while providing strong isolation guarantees.</p><p>• We compare SigTM to STM and HTM systems using a set of parallel applications that make frequent use of coarse-grain transactions. We show that SigTM outperforms softwareonly TM by 30% to 280%. While for some workloads it performs within 10% of HTM systems, for workloads with large read-sets, SigTM trails HTM by up to 200%.</p><p>• We quantify that relatively small hardware signatures, <ref type="bibr">128</ref> bits for the write-set and 1024 bits for the read-set, are sufficient to eliminate false conflicts due to the inexact nature of signature-based conflict detection.</p><p>The rest of the paper is organized as follows. Sections 2 and 3 review STM and HTM systems and their differences in terms of performance and isolation guarantees. Section 4 presents the SigTM system. Sections 5 and 6 present the experiment methodology and results respectively. Section 7 discusses related work, and Section 8 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">SOFTWARE AND HARDWARE TM</head><p>A TM system provides version management for the data written by transactions and performs conflict detection as transactions execute concurrently. This section summarizes hardware and software implementation techniques, focusing on the specific STM and HTM systems we used in this study. There are several alternative implementations for both approaches <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b18">18]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Software Transactional Memory</head><p>STM systems implement version management and conflict detection using software-only techniques. In this work, we use Sun's TL2 as our base STM <ref type="bibr" target="#b11">[11]</ref>. TL2 is a lock-based STM that implements optimistic concurrency control for both read and write accesses and scales well across a range of contention scenarios <ref type="bibr" target="#b12">[12]</ref>.</p><p>Algorithm 1 provides a simplified overview of the STM for a Cstyle programming language. Refer to <ref type="bibr" target="#b11">[11]</ref> for a discussion of TL2 for object-oriented languages. The STM maintains a global version clock used to generate timestamps for all data. To implement conflict detection at word granularity, it also associates a lock to every word in memory using a hash function. The first bit in the lock word indicates if the corresponding word is currently locked. The remaining bits are used to store the timestamp generated by the last transaction to write the corresponding data.</p><p>A transaction starts (STMtxStart) by taking a checkpoint of the current execution environment using setjmp and by reading the current value of the global clock into variable RV . A transaction updates a word using a write barrier (STMwriteBarrier). The barrier first checks for a conflict with other committing or committed transactions using the corresponding lock. A conflict is signaled if the word is locked or its timestamp is higher than the value Algorithm 1 Pseudocode for the basic functions in the TL2 STM.</p><formula xml:id="formula_0">procedure STMTXSTART checkpoint() RV ← GlobalClock procedure STMWRITEBARRIER(addr, data) bloomF ilter.insert(addr) writeSet.insert(addr, data)</formula><p>procedure STMREADBARRIER(addr) if bloomF ilter.member(addr) and writeSet.member(addr) then return writeSet.lookup(addr) if locked(addr) or (timeStamp(addr) &gt; RV then conflict() readSet.insert(addr) return Memory <ref type="bibr">[addr]</ref> procedure STMTXCOMMIT for every addr in writeSet do if locked(addr) then conflict()</p><formula xml:id="formula_1">else lock(addr) W V ← Fetch&amp;Increment(GlobalClock) for every addr in readSet do if locked(addr) or (timeStamp(addr) &gt; RV ) then conflict() for every addr in writeSet do Memory[addr] ← writeSetLookup(addr) for every addr in writeSet do timeStamp(addr) ← W V unlock(addr)</formula><p>in RV . Assuming no conflict, the store address and data are added to the write-set, a hash table that buffers the transaction output until it commits. The STM also maintains in software a 32-bit Bloom filter for the addresses in the write-set. A transaction loads a word using a read barrier (STMreadBarrier). The barrier first checks if the latest value of the word is available in the write-set, using the Bloom filter to reduce the number of hash table lookups. If the address is not in the write-set, it checks for a conflict with other committing or committed transactions. Assuming no conflict, it inserts the address to the read-set, a simple FIFO that tracks read addresses. Finally, it loads the word from memory and returns its value to the user code.</p><p>In order to commit its work (STMtxCommit), a transaction first attempts to acquire the lock for all words in its write-set. If it fails on any lock then a conflict is signaled. Next, it atomically increments the global version clock using the atomic instructions in the underlying ISA (e.g., cmpxchg in x86). It also validates all addresses in the read-set by verifying that they are unlocked and that their timestamp is not greater than RV . At this point, the transaction is validated and guaranteed to complete successfully. The final step is to scan the write-set twice in order to copy the new values to memory, update their timestamp to W V , and release the corresponding lock.</p><p>The STM handles conflicts in the following manner. If a transaction fails to acquire a lock while committing, it first spins for a limited time and then aborts using longjmp. A transaction aborts in all other conflict cases. To provide liveness, the STM retries the transaction after a random backoff delay that is biased by the number of aborts thus far.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Hardware Transactional Memory</head><p>HTM systems implement version management and conflict detection by enhancing both caches and the cache coherence protocol in a multi-core system <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b21">21]</ref>. The HTM used in this study is the hardware equivalent of the TL2 STM. It uses the cache to buffer the write-set until the transaction commits. Conflict detection is implemented using coherence messages when one transaction attempts to commit (optimistic concurrency). In general, our HTM is similar to the TCC system <ref type="bibr" target="#b13">[13]</ref> with two key deviations. First, TCC executes all user code in transactional mode, while our HTM uses transactional mechanisms only for user-defined transactions. The rest of the code executes as a conventional multithreaded program with MESI cache coherence and sequential consistency. Second, TCC uses a write-through coherence protocol that provides conflict resolution at word granularity. Our HTM uses write-back caches which requires conflict detection at the cache line granularity.</p><p>The HTM extends each cache line with one read bit (R) and one write bit (W) that indicate membership in a transaction's read-set and write-set respectively. A transaction starts by taking a register checkpoint using a hardware mechanism. A store writes to the cache and sets the W bit. If there is a cache miss, the cache line is requested in the shared state. If there is a hit but the line contains modified data produced prior to the current transaction (modified and W bit not set), it first writes back the data to lower levels of the memory hierarchy. A load reads the corresponding word and sets the R bit if the W bit is not already set. If there is a cache miss for the load, we retrieve the line in the shared state as well.</p><p>When a transaction completes, it arbitrates for permission to commit by acquiring a unique hardware lock. This implies that only a single transaction may be committing at any point in time. Parallel commit can be supported using a two-phase protocol <ref type="bibr" target="#b5">[6]</ref>, but it was not necessary for the system sizes we studied in this paper. Next, the HTM generates snooping messages to request exclusive access for any lines in its write-set (W bit set) that are in shared state. At this point, the transaction is validated. Finally, it commits the write-set atomically by flash resetting all W and R bits and then releasing the commit lock. All data in the write-set are now modified in the processor's cache but are non-transactional and can be read by other processors.</p><p>An ongoing transaction detects a conflict when it receives a coherence message with an exclusive request for data in its read-set or write-set. Such a message can be generated by a committing transaction or by a non-transactional store. A software abort handler is invoked that rolls back the violated transaction by flash invalidating all lines in the write-set, flash resetting all R and W bits, and restoring the register checkpoint <ref type="bibr" target="#b20">[20]</ref>. Transaction starvation is avoided by allowing a transaction that has been retried multiple times to acquire the commit lock at its very beginning. Forward progress is guaranteed because a validated transaction cannot abort. To guarantee this, a validated transaction sends negative acknowledgments (nacks) to all types of coherence requests for data in its write-set and exclusive requests for data in its read-set. Once validated, an HTM transaction must execute just a few instructions to flash reset its W and R bits, hence the window of nacks is extremely short. If a transaction receives a shared request for a line in its read-set or write-set prior to reaching the commit stage, it responds that it has a shared copy of the line and downgrades its cache line to the shared state if needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">STM -HTM DIFFERENCES</head><p>This section compares qualitatively the STM and HTM systems in terms of their performance and strong isolation guarantees. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Performance</head><p>STM transactions run slower than HTM transactions due to the overhead of software-based versioning and conflict detection. Even though the two systems may enable the same degree of concurrency and exhibit similar scaling, the latency of individual transactions is a key parameter for the overall performance. <ref type="figure" target="#fig_0">Figure 1</ref> shows the execution time breakdown for STM running on a single processor (no conflicts or aborts). Execution time is normalized to that of the sequential code. STM is slower than sequential code by factors of 1.5× to 7.2×. In contrast, the overhead of HTM execution on one processor is less than 10%.</p><p>The biggest bottleneck for STM is the maintenance and validation of the read-set. For every word read, the STM must execute at least one read barrier and revalidate its timestamp during the commit phase. Even after optimizations, the overhead is significant for transactions that read non-trivial amounts of data. The next important bottleneck is the three traversals of the write-set needed to validate and commit a transaction: first to acquire the locks, then to copy the data values to memory, and finally to release the locks. Lock handling is expensive as it involves atomic instructions and causes additional cache misses and coherence traffic. The third important factor (not shown in <ref type="figure" target="#fig_0">Figure 1)</ref> is that an STM transaction may not detect a conflict until it validates its read-set at the very end of its execution. This is due to that fact that a read by an ongoing transaction is not visible to any other transaction committing a new value for the same word. Invisible reads increase the amount of work wasted on aborted transactions.</p><p>There are also secondary sources of STM overhead. For example, loads must first search the write-set for the latest value. Our experience is that the software Bloom filter eliminates most redundant searches. Aborting a transaction on a conflict is also sufficiently fast for our STM since no data are written to memory before the transaction is validated. Finally, there can be false conflicts due to the hash function used to map variable addresses to locks. We use a million locks which makes this case rare.</p><p>STM overheads can be reduced through manual or compiler-  <ref type="figure">Figure 2</ref>. Isolation and ordering violation cases for the STM system.</p><p>based optimizations <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b15">15]</ref>. The primary goal is to eliminate redundant or repeated barriers using techniques such as common subexpression elimination and loop hoisting or by identifying threadlocal and immutable data. Nevertheless, even optimized STM code requires one barrier per unique address as well as the validation and commit steps at the end of the transaction. A special case is readonly transactions for which there is no need to build or validate the read-set or the write-set <ref type="bibr" target="#b11">[11]</ref>. Unfortunately, statically-identified, read-only transactions are not common in most applications. For the HTM, hardware support eliminates most overheads for transactional bookkeeping. No additional instructions are needed to maintain the read-set or write-set. Loads check the write-set automatically for the latest values. Read-set validation occurs transparently and continuously as coherence requests are processed; hence, conflicts are discovered as soon as a writing transaction commits. The write-set is traversed a single time on commit. On the other hand, the HTM may experience performance challenges on transactions whose read-set and write-set overflow the available cache space or associativity. There are several proposed techniques that virtualize HTM systems using structures in virtual memory <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b6">7]</ref>. In most cases, the HTM performs similarly to an STM system for the overflowed transactions due to the overhead of virtualization. An additional source of overhead for HTM can be false conflicts due to conflict detection at cache line granularity. The STM uses word granularity conflict detection. If STM-style compiler optimizations are not used with the HTM system, false conflicts can be more frequent. For example, if an HTM transaction reads an immutable field in the same cache line with a field written by another transaction, there will be a false conflict. Ideally, the compiler should instruct the HTM system to use a non-transactional load for the immutable field that will not add its address to the read-set <ref type="bibr" target="#b20">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Strong Isolation and Ordering</head><p>The differences between HTM and STM extend beyond performance. An important feature for TM systems is strong isolation, which facilitates predictable code behavior <ref type="bibr" target="#b18">[18]</ref>. Strong isolation requires that transactional blocks are isolated from nontransactional memory accesses. Moreover, there should be a consistent ordering between transactional code and non-transactional accesses throughout the system. High-performance STM systems do not implement strong isolation because it requires additional read and write barriers in non-transactional code that exacerbate the overhead issues. We refer readers to <ref type="bibr" target="#b25">[25]</ref> for a thorough discussion of isolation and ordering issues in all types of STM systems. <ref type="figure">Figure 2</ref> presents the three isolation and ordering cases that lead to unpredictable results with our STM. For the case in <ref type="figure">Figure 2</ref>.(a), the non-transactional code in Thread 2 updates x while Thread 1 runs a transaction. Since Thread 2 does not use a write barrier, Thread 1 has no means of detecting the conflict on x. The two reads to x from Thread 1 may return different values (0 and 100 respectively). The expected behavior is that either both reads return 0 (Thread 1 before Thread 2) or both return 100 (Thread 2 before Thread 1). For the case in <ref type="figure">Figure 2</ref>.(b), the lack of conflict detection between the two threads may lead to a lost update. If the write by Thread 2 occurs after Thread 1 reads x and before it commits its transaction, the final value of x will be 1. The expected behavior is that either x has a final value of 100 (Thread 1 before Thread 2) or 101 (Thread 2 before Thread 1). For the case in <ref type="figure">Figure 2</ref>.(c), the problem arises because Thread 2 does not use a read barrier for x and y. Hence, it is possible that, as Thread 1 is in the middle of its transaction commit, Thread 2 reads the old value of x and the new value of y or vice versa. In other words, t may have value 100, while the expected behavior is that t is either 200 (Thread 1 before Thread 2) or 0 (Thread 2 before Thread 1).</p><p>One can dismiss the cases in <ref type="figure">Figure 2</ref> as examples of data races that would lead to unpredictable behavior even with lock-based synchronization. Instead of arguing whether or not TM should eliminate the data races in lock-based synchronization, we examine the privatization code in <ref type="figure" target="#fig_1">Figure 3</ref>  <ref type="bibr" target="#b18">[18]</ref>. Thread 1 atomically removes an element from a linked-list and uses it multiple times. Thread 2 atomically increments all elements in the list. There are two acceptable outcomes for this code: either Thread 1 commits its transaction first and subsequently uses only the non-incremented value of the first element or Thread 2 commits first and Thread 1 subsequently uses only the incremented value of the first element. If we implement the atomic blocks with a single coarse-grain lock, this code will produce one of the expected results as it is race-free.</p><p>The lack of strong isolation causes this code to behave unpredictably with all STM approaches <ref type="bibr" target="#b18">[18]</ref>. As the two threads execute concurrently, lhead is included in the write-set for Thread 1 and the the read-set for Thread 2. Now assume Thread 2 initiates its transaction commit, where it locks lhead.val and it verifies all variables in its read-set have not changed in memory, including lhead. While Thread 2 is copying its large write-set, Thread 1 starts its commit stage. It locks its write-set (lhead), validates its read-set (lhead and lhead.next), and commits the new value of lhead. Subsequently, Thread 1 uses res outside of a transactional block as it believes that the element has been privatized by atomically extracting from the list. Depending on the progress rate of Thread 2 with copying its write-set, Thread 1 may get to use the non-incremented value for res.val a few times before finally observing the incremented value committed by Thread 2.</p><p>The privatization example in <ref type="figure" target="#fig_1">Figure 3</ref> is not a unique case of race-free code that performs unpredictably. Another source of correctness issues is that STM systems do not validate their read-set</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Instruction</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Description</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>rsSigReset</head><p>Reset all bits in read-set or write-set signature wsSigReset rsSigInsert r1</p><p>Insert the address in register r1 in the read-set wsSigInsert r1</p><p>or write-set signature rsSigMember r1, r2</p><p>Set register r2 to 1 if the address in register wsSigMember r1, r2 r1 hits in the read-set or write-set signature rsSigSave r1, r2</p><p>Save a portion of the read-set or write-set wsSigSave r1, r2 signature into register r1 rsSigRestore r1, r2 Restore a portion of the read-set or write-set wsSigRestore r1, r2 signature from register r1 fetchEx r1</p><p>Prefetch address in register r1 in exclusive state; if address in cache, upgrade to exclusive state if needed <ref type="table">Table 1</ref>. The user-level instructions for management of read-set and write-set signatures in SigTM.</p><p>until they reach the commit stage. Hence, it is possible to have a transaction use a pointer that has been modified in the meantime by another transaction, ending up with an infinite loop or a memory exception <ref type="bibr" target="#b12">[12]</ref>. Strong isolation can be implemented in an STM using additional read and write barriers in non-transactional accesses. Shpeisman et al. <ref type="bibr" target="#b25">[25]</ref> developed a set of compiler techniques that minimize their performance impact by differentiating between private and shared data, identifying data never accessed within a transaction, and aggregating multiple barriers to the same address. For a set of Java programs that make infrequent use of transactions, their optimizations reduce the overhead of strong isolation from 180% to 40%. This overhead is significant as it is in addition to the regular overhead of STM instrumentation code. Moreover, the overhead may actually be higher for applications that make frequent use of transactional synchronization or are written in languages like C/C++. If strong isolation forces programmers to pick between performance and correctness, we have failed to deliver on the basic promise of TM: simple-to-write parallel code that performs well.</p><p>HTM systems naturally implement strong isolation as all thread interactions, whether they execute transactions or not, are visible through the coherence protocol and can be properly handled. For the cases in <ref type="figure">Figure 2</ref>.(a) and 2.(b), the write to x by Thread 2 on our HTM will generate a coherence request for exclusive access. If Thread 1 has already read x, the coherence request will facilitate conflict detection and will cause Thread 1 to abort and re-execute its transaction. For the case in <ref type="figure">Figure 2</ref>.(c), once the transaction in Thread 1 is validated, it will generate nacks to any incoming coherence request (shared or exclusive) for an address in its writeset. Since there is one transaction committing at the time, there can be no deadlock or livelock. Hence, Thread 2 will either read the new or old values for both x and y. The HTM executes correctly the privatization code in <ref type="figure" target="#fig_1">Figure 3</ref> as Thread 1 cannot read partially committed state from Thread 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SIGNATURE-ACCELERATED TM</head><p>This section describes signature-accelerated transactional memory (SigTM), a hybrid TM system that reduces the runtime overhead of software transactions and transparently provides strong isolation and ordering guarantees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Hardware Signatures</head><p>SigTM enhances the architecture of a TM system with hardware signatures for read-set and write-set tracking. Our work was inspired by the use of signatures for transactional bookkeeping in the Bulk HTM <ref type="bibr" target="#b4">[5]</ref>.</p><p>A hardware signature is a Bloom filter <ref type="bibr" target="#b2">[3]</ref> that conservatively encodes a set of addresses using a fixed-size register. SigTM uses two signatures per hardware thread: one for the read-set and the other for the write-set. <ref type="table">Table 1</ref> summarizes the instructions used by software to manage the signatures. Software can reset each signature, insert an address, check if an address hits in the signature, and save/restore its content. To insert address A in a signature, hardware first truncates the cache line offset field from the address. Next, it applies one or more deterministic hash functions on the remaining bits. Each function identifies one bit in the signature to be set to one. To check address A for a hit, the hardware truncates the address and applies the same set of hash functions. If all identified bits in the signature register are set, A is considered a signature hit. Given the fixed-size of the signature register and the nature of hash functions, multiple addresses will map to the same signature bits. Hence, hits are conservative: they will correctly identify addresses that were previously added to the set but may also identify some addresses the were never inserted in the signature. We discuss the signature length and the choice of hash functions in Section 6. The last instruction in <ref type="table">Table 1</ref> allows software to prefetch or upgrade a cache line to one of the exclusive states of the coherence protocol (E for MESI). If the address is already in the M or E state, the instruction has no effect.</p><p>The hardware can also lookup the signatures for hits using addresses from incoming coherence requests. A user-level configuration register per hardware thread is used to select if addresses from shared and/or exclusive requests should be looked up in the read-set and/or write-set signatures. If an enabled lookup produces a signature hit, a user-level exception is signaled that jumps to a pre-registered software handler <ref type="bibr" target="#b20">[20]</ref>. Coherence lookups are temporarily disabled when the handler is invoked to avoid repeated invocations of the handler that prohibit forward progress. The configuration register also indicates if coherence requests that hit in the write-set signature should be properly acknowledged by the local cache or should receive a nack reply.</p><p>Apart from hardware signatures and the nack mechanism in the coherence protocol, SigTM requires no further hardware support. Caches are not modified in any way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">SigTM Operation</head><p>Algorithm 2 summarizes the operation of software transactions under SigTM. Even though we present a hybrid scheme based on the TL2 STM, the approach is generally applicable to other STMs (see Section 4.5). SigTM is a standalone implementation. Unlike other hybrid proposals <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b24">24]</ref>, there is no backup STM, no switch between HTM and STM modes, and no fast vs. slow code paths.</p><p>SigTM eliminates the global version clock and the locks in the base STM. While it also eliminates the software read-set, a software write-set is still necessary in order to buffer transactional updates until the transaction commits. The transaction initialization code (SigTMtxStart) takes a checkpoint and enables read-set signature lookups for exclusive coherence requests. The write barrier code (SigTMwriteBarrier) inserts the address in the writeset signature and updates the software write-set. The read barrier (SigTMreadBarrier) first checks if the address is in the software write-set, using the hardware write-set signature as a filtering mechanism to avoid most unnecessary write-set lookups. If not, it simply adds it to the read-set signature and reads the word from memory. During the transaction execution, if the address from an exclusive coherence request produces a hit in the read-set signature, a conflict is signaled and the transaction aborts. The abort process includes resetting both signatures and discarding the softAlgorithm 2 Pseudocode for the basic functions in SigTM.</p><formula xml:id="formula_2">procedure SIGTMTXSTART checkpoint() enableRSlookup(exclusive)</formula><p>procedure SIGTMWRITEBARRIER(addr, data) wsSigInsert(addr) writeSet.insert(addr, data)</p><p>procedure <ref type="bibr">)</ref> ware write-set. During the transaction execution, addresses from coherence requests are not looked up in the write-set filter until the commit stage.</p><note type="other">SIGTMREADBARRIER(addr) if wsSigMember(addr) and writeSet.member(addr) then return writeSet.lookup(addr) rsSigInsert(addr) return Memory[addr] procedure SIGTMTXCOMMIT enableWSlookup(exclusive, shared) for every addr in writeSet do fetchEx(addr) enableWSnack(exclusive, shared) rsSigReset() disableRSlookup() for every addr in writeSet do Memory[addr] ← writeSet.lookup(addr) wsSigReset() disableWSnack(</note><p>To commit a transaction (SigTMtxCommit), SigTM first enables coherence lookups in the write-set signatures for all types of requests. Next, it scans the write-set and acquires exclusive access for every address in the set using the fetchEx instruction. This step validates the transaction by removing the corresponding cache lines from the caches of other processors in the system. Note that a fetchEx access may replace the line brought by another fetchEx access without any correctness issues. Correctness is provided by the signature lookups for incoming coherence requests, not by cache hits or misses. If a fetchEx instruction time-outs due to nacks, a software handler is invoked that repeats the validation from scratch. The same handler is invoked if the write-set signature identifies a conflict with any incoming coherence message (exclusive or shared request). If the read-set signature produces a hit with an exclusive request, it is a conflict that leads to an abort.</p><p>To complete the commit process, SigTM enables nacking of any coherence request that hits in the write-set signature. This is necessary for store isolation. The read-set signature is reset as a validated transaction can no longer roll back. Next, SigTM scans the writeset and updates the actual memory locations. Finally, software resets the write-set signature and disables any nacks or lookup hits it can produce.</p><p>Contention management in SigTM is similar to that in the base STM. Aborted transactions are retried after a backoff delay. If the transaction validation is repeated multiple times due to conflicts identified by the write-set signature, we eventually abort the transaction and use the same contention management approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Performance</head><p>SigTM transactions execute exactly the same number of software barriers as STM transactions. Nevertheless, the overhead of SigTM barriers is significantly lower.  <ref type="table" target="#tab_1">Table 2</ref>. The common-case dynamic instruction counts for the STM and SigTM barriers. R and W represent the number of words in the transaction read-set and write-set, respectively.</p><p>SigTM reduces the overhead of read and commit barriers, the two biggest sources of overhead for STM code (see <ref type="figure" target="#fig_0">Figure 1</ref>). SigTM accelerates read-barriers by replacing the software read-set with the hardware read-set signature. It also eliminates the need for lock or timestamp checks. The commit overhead is reduced as the writeset is traversed twice and there is no need for read-set validation. Moreover, the SigTM commit process uses fetchEx instructions, which are faster than lock acquisitions. SigTM does not provide a large performance advantage for write barriers. It eliminates the lock and timestamp checks but it still has to insert the data in the software hash table. Nevertheless, write barrier overhead is a secondary issue as most transactions read more than they write. An additional advantage for SigTM is that coherence lookups in the read-set signature make transactional reads visible. Hence, a transaction detects read-set conflicts as soon as other transactions commit and not when it attempts to commit itself. The early conflict detection reduces the cost of aborts. Finally, the elimination of lock words reduces the pressure on cache capacity and coherence bandwidth.</p><p>The performance challenge for SigTM is the inexact nature of the read-set and write-set signatures. If the signatures produce significant false hits, the system will spend more time in unnecessary rollbacks. False hits can occur due to negative interaction between the application's access pattern and the hash functions used for the signatures. It is also possible that a specific implementation uses signatures that are too short to accurately represent the large readsets and write-sets in some applications. However, the signature length is not directly visible to user code and can be changed in subsequent systems. The read-set signature is a more likely source of false hits as read-sets are typically larger than write-sets. Moreover, coherence lookups in the read-set signature are enabled throughout the entire execution of a SigTM transaction.</p><p>Another source of false conflicts is that SigTM performs conflict detection at cache line granularity. The HTM uses cache line granularity as well, but the STM uses word granularity. SigTM cannot track word addresses in the hardware signatures because coherence requests are at the granularity of full cache lines. Finally, it is difficult for SigTM to be faster than the HTM system. While SigTM barriers are significantly faster than STM barriers, they are still slower than the transparent transactional bookkeeping in the HTM. The performance gap between the two depends on the number of barriers per transaction and the amount of useful work by which they are amortized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Strong Isolation and Ordering</head><p>SigTM provides software transactions with strong isolation and ordering guarantees without additional barriers in non-transactional code. The continuous read-set validation through the read-set signature eliminates non-repeatable reads and lost updates <ref type="figure">(Figure 2.(a)</ref> and (b) respectively). In both cases, the non-transactional write in Thread 2 will generate an exclusive coherence request that hits in the read-set signature of Thread 1. Hence, Thread 1 will abort and re-execute its transaction, which will lead to one of the expected final results. Moreover, the continuous read-set validation ensures that a transaction will not operate on inconsistent state that leads to infinite loops or memory faults.</p><p>Overlapped writes <ref type="figure">(Figure 2</ref>.(c)) and the privatization problem ( <ref type="figure" target="#fig_1">Figure 3</ref>) are addressed by nacking all coherence requests that hit in the write-set signature while a validated transaction copies its write-set to memory. Note that nacking requests for an address is equivalent to holding a lock on it and can cause serialization and performance issues. SigTM uses nacks only during write-set copying which is typically a short event.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Alternative SigTM Implementations</head><p>This section discusses the implementation of SigTM based on alternative STMs or targeting alternative multi-core systems.</p><p>Object-based conflict detection: To support programming languages like C, SigTM performs conflict detection at cache line granularity. For object-oriented environments like Java, it is preferable to perform conflict detection at the granularity of objects. Objectbased detection is closer to the programmer's understanding of the application behavior. Moreover, it typically leads to fewer barriers than cache-based detection as it is sufficient to track object headers instead of all the fields in the object.</p><p>To implement an object-based SigTM, we would insert in the hardware signatures only the addresses of headers for the objects in the transaction read-set and write-set. All other fields would be accessed using regular operations. We would also change the software write-set to support versioning at object granularity. Note that the hardware signatures could still produce false conflicts due to their inexact nature or if multiple objects are stored in the same cache line. Nevertheless, since fewer addresses will be tracked by the signatures, false conflicts should be less frequent.</p><p>The SigTM hardware presented in Section 4.1 can also support a mixed environment where cache line conflict detection is used for large objects like multi-dimensional arrays, while other data types are tracked at the object level.</p><p>Eager data versioning: Because of its TL2 heritage, SigTM implements lazy data versioning. Transactional updates are buffered in the write-set until the transaction commits. Alternatively, we could start with an STM that uses eager versioning <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b15">15]</ref>. Writes within a transaction update memory locations in place, logging the original value in an undo log in case of an abort. Since SigTM implements data versioning in software, no hardware changes are necessary to support the eager-based scheme. Nevertheless, the hardware features would be used differently. Transactional write accesses that miss in the cache would retrieve the cache line in exclusive mode. Apart from looking up exclusive coherence requests in the read-set signature, we would also lookup both shared and exclusive requests in the write-set signature throughout the transaction. If the commit barrier is reached without a conflict, the transaction can complete by simply resetting its signatures. On the other hand, while a transaction aborts it must nack any coherence requests to addresses in its write-set to ensure that restoring the memory values appears atomic.</p><p>Eager-based STMs have two additional cases that can lead to unpredictable behavior without strong isolation: speculative lost updates and speculative dirty reads <ref type="bibr" target="#b25">[25]</ref>. The hardware signatures in SigTM can address both cases. Speculative lost updates are eliminated because nacks are used to guarantee that rolling back a transaction is atomic. Speculative dirty reads are eliminated because shared coherence requests are looked up in the write-set signature throughout the transaction runtime.</p><p>Multi-core systems without broadcast coherence: Thus far, we assumed a broadcast protocol that makes coherence updates visible to all processors in the system. The snooping coherence used in current multi-core systems meets this requirement. Broadcast coherence allows the hardware signatures to view all coherence requests even for cache lines that have been accessed by this transaction but have been replaced from the local cache. Larger-scale multi-core systems may use directories to filter coherence traffic. To implement SigTM correctly in such systems, we can use the LogTM sticky directory states <ref type="bibr" target="#b21">[21]</ref>. In the LogTM, cache replacement does not immediately modify the directory state. Hence, the directory will continue to forward coherence requests to a processor even after it evicts a cache line from its caches.</p><p>For systems with two levels of private caches, addresses from coherence requests must be looked up in the hardware signatures even if the L2 cache filters them from the L1 cache.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">System Issues</head><p>Nesting: SigTM supports an unbounded number of nested transactions <ref type="bibr" target="#b20">[20]</ref>. Since data versioning is in software, SigTM can manage separately, and merge when necessary, the write buffer or undo log for the parent and children transactions.</p><p>Conflict detection for nested transactions is supported by saving and restoring signatures at nested transaction boundaries. At the beginning of a nested transaction (closed or open), we save a copy of the current contents of the two signatures in thread-private storage. The signatures are not reset at this point. As the nested transaction executes, its read and write barriers will insert additional addresses to the signatures, which will represent the combined read-set and write-set for the parent and the child transaction. If the nested transaction detects a conflict before it commits, after ensuring that the conflict was not for the parent, we restore the signatures of the parent transaction as part of the abort process. If a closed-nested transaction commits, we discard the saved parent's signatures and continue with the current signature contents. If an open-nested transaction commits, we restore the parent's signature to indicate that the child transaction committed independently.</p><p>Multithreading: For processor cores that support multiple hardware threads, SigTM requires a separate set of signature and configuration registers per thread. Since the signatures are maintained outside the cache, it is straightforward to introduce support for additional threads. The hardware must also facilitate conflict detection between threads executing in the same processor. Since one thread may fetch a line that is later accessed by another thread, signature lookups on misses and coherence upgrades are no longer sufficient. Stores to lines in exclusive states (M or E) must be looked up in the signatures of other threads. Moreover, if any thread is currently copying the write-set for its validated transaction, load hits to lines in exclusive states (M or E) must be also looked up in the write-set signatures of other threads.</p><p>Thread Suspension &amp; Migration: Due to interrupts or scheduling decisions, the OS may decide to suspend a thread while it is executing a SigTM transaction. An efficient way to handle interrupts within transactions is the three-pronged approach of the XTM system <ref type="bibr" target="#b7">[8]</ref>. First, the transaction is allowed to complete before the thread is suspended. Second, if the interrupt is critical or becomes critical after some waiting period, the transaction is aborted before the thread is suspended. No transactional state needs to be saved or restored in these two cases. These two cases work well if transactions are short relative to the inherent overhead of context switching. Transactional state must be saved and restored only when suspending very long transactions. Currently, this case is uncommon (see Section 6.1 and <ref type="bibr" target="#b8">[9]</ref>).</p><p>To suspend an on-going SigTM transaction, the OS must save the current contents of the two signatures as it does with all other hardware registers for this thread. The SigTM write-set does not re-  <ref type="table">Table 3</ref>. The simulation parameters for the multi-core system.</p><p>quire special handling as it is a software structure stored in virtual memory. To facilitate conflict detection for suspended threads the OS can use an additional set of hardware signatures. The OS uses them to store a combined version of the signatures for all suspended threads (bitwise logical or) and detect conflicts with on-going transactions. Alternatively, the OS can overload the hardware signatures of a running thread to also store the combined signatures of suspended threads. In both cases, software processing is necessary to determine which of combined transactions should be be aborted due to the signature hit. When a thread is resumed, the OS restores its saved signatures. It must also recompute the combined signature for suspended threads. Thread migration occurs by suspending and resuming a thread or by directly copying its signatures from one set of hardware registers to another.</p><p>Paging: Disk paging and remapping is a challenge for SigTM because the signatures are built using physical addresses. To handle conflict detection correctly in the presence of paging, the system should track when a page accessed by active transactions is being remapped. In this case, the OS must conservatively insert all cache line addresses from the new mapping in the signatures of all threads that have accessed data in this page. This approach may lead to extra false hits but will not miss any true conflicts.</p><p>Nevertheless, since paging is typically rare, it is best handled using the XTM three-pronged approach. Moreover, if an application experiences heavy paging, its performance is already so low that thread serialization is probably an acceptable method to handle paging within transactions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">METHODOLOGY</head><p>We compared SigTM to STM and HTM systems using executiondriven simulation and a novel set of parallel benchmarks. <ref type="table">Table 3</ref> presents the main parameters of the simulated multi-core system. Insertions and lookups in the SigTM signatures use the four hash functions listed. Each function identifies a bit in the register to set or check respectively. The processor model assumes an IPC of 1 for all instructions that do not access memory. However, the simulator captures all the memory hierarchy timings including contention and queuing events.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Simulation and Code Generation</head><p>All applications were coded in C or C++ using a low-level API to identify parallel threads and manually insert transaction markers and barriers. All TM versions share the same annotation of transaction boundaries. The STM and SigTM systems run the same application code that has been linked with a different barrier library in each case. Read and write barriers for accesses to shared data were optimized as much as possible following the guidelines in <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b15">15]</ref>. The speedups reported in Section 6 are relative to sequential execution with code that includes no annotations for threads, transactions, or barriers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Applications</head><p>Most studies of TM systems thus far have used microbenchmarks or parallel applications from the SPLASH-2 suite. Microbenchmarks are useful to stress specific system features but do not represent the behavior of any real application. The SPLASH-2 benchmarks have been carefully optimized over the years to avoid synchronization <ref type="bibr" target="#b26">[26]</ref>. Turning their lock-protected regions into transactional blocks leads to programs that spend a small portion of their runtime in fine-grain transactions. This behavior may not be representative of new parallel programs developed with TM techniques. After all, the main promise of transactional memory is to provide good performance with simple parallel code that frequently uses coarse-grain synchronization (transactions).</p><p>For this study, we parallelized four applications from scratch using transactions. The parallel code for each application uses coarsegrain transactions to execute concurrent tasks that operate on one or more irregular data structures such as a graph or a tree. Parallel coding at this level is easy because the programmer does not have to understand or manually manage the inter-thread dependencies within the data structure code. The parallel code is very close to the sequential algorithm. The resulting runtime behavior is frequent, coarse-grain transactions. The following are brief descriptions of the four applications:</p><p>Delaunay implements Delaunay mesh generation, an algorithm for producing guaranteed quality meshes for applications such as graphics rendering and PDE solvers. The basic data structure is a graph that stores the mesh data. Each parallel task involves three transactions. The first one removes a "bad" triangle from a work queue, the second processes the cavity around the triangle, and the third inserts newly created triangles to the work queue.</p><p>Genome is a bioinformatics application and performs gene sequencing: from a very large pool of gene segments, it finds the most likely original gene sequence. The basic data structure is a hash table for unmatched segments. In the parallel version of the segment matching phase, each thread tries to add to its partition of currently matched segments by searching the shared pool of unmatched segments. Since multiple threads may try to grab the same segment, transactions are used to ensure atomicity.</p><p>Kmeans is an algorithm that clusters objects into k partitions based on some attributes. It is commonly used in data mining workloads. Input objects are partitioned across threads and synchronization is necessary when two threads attempt to insert objects in the same partition. Thus, the amount of contention varies with the value of k. For our experiments, we use two such values to observe kmeans with high (kmeans-high) and low (kmeans-low) contention in its runtime behavior.</p><p>Vacation implements a travel reservation system powered by an in-memory database using trees to track items, orders, and customer data. Vacation is similar in design to the SPECjbb2000 benchmark. The workload consists of several client threads interacting with the database via the system's task manager. The workload generator can be configured to produce a certain percentage of read-only (e.g., ticket lookups) and read-write (e.g., reservations) tasks. For our experiments, we use two workload scenarios, one with a balanced set of read-only and read-write tasks (vacationhigh) and one dominated by read-only tasks (vacation-low). Tasks operate on multiple trees and execute fully within transactions to maintain the database's atomicity, consistency, and isolation. <ref type="table" target="#tab_4">Table 4</ref> presents averages for the basic application statistics on the STM and HTM systems. Transactions include a significant number of instructions, ranging from 3K to 30K instructions for the HTM. Instruction counts for STM transactions are higher by 2× to 8×, depending on the distribution of read and write barriers per transaction. The instruction counts for SigTM are typically closer to the HTM counts due to reduced overhead of SigTM barriers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EVALUATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Application Characterization</head><p>For HTM, the read-sets vary between 20 and 120 cache lines. While such read-set sizes do not put significant pressure on the capacity of L1 caches, they can cause associativity conflicts. Writesets are smaller, 4 to 30 cache lines. This is not surprising as most transactions first search a data structure performing O(logN ) or O( √ N ) reads and then update a single new element. Transactions that write a lot, for example by rebalancing a tree, are rare. It is interesting to notice that the read-set to write-set size ratio in HTM does not necessarily match the read to write barrier ratio in STM. The STM does not include barriers for immutable or thread-local fields, while the HTM automatically inserts them in the read-set. On the other hand, the STM can have redundant barriers for fields accessed multiple times per transaction in a statically unpredictable manner. Finally, the STM will use multiple barriers for fields allocated in the same cache line, while the HTM will include the line in the read-set just once.</p><p>A final interesting point is that transactions account for 96% to 99% of the runtime for these applications. Hence, they place significant stress on the TM support in all three systems. This behavior is because the application code encloses, in a coarse-grain transaction, any task that operates on shared data. It is possible to reduce the percentage of time in transactions by using finer-grain synchronization or by manually partitioning and merging the shared data structures across threads. Nevertheless, such optimizations complicate parallel programming significantly and increase the likelihood of both correctness and performance bugs. <ref type="figure">Figure 4</ref> presents the speedups of the three TM systems as we scale the number of processors from 1 to 16. Higher speedups are better. For these experiments, SigTM uses 2Kbits per read-set and write-set signature. To provide further insights into performance issues, <ref type="figure">Figure 5</ref> shows the execution time breakdown for the runs with 16 processors. For HTM, execution time is broken into "busy" (useful instructions and cache misses), "rollback" (time spent on aborted transactions), "commit" (commit overhead), and "other" (work imbalance, etc.). For STM and SigTM, we separate time spent on read and write barriers from busy time. Miscellaneous barriers, like those starting a software transaction, are accounted for in the "other" segment. Lower execution times are better. <ref type="figure">Figure 4</ref> shows that three systems scale similarly for all applications. Nevertheless, the actual speedups differ significantly. Compared to STM, the SigTM design provides a performance advantage that ranges from 30% (genome) to 280% (vacation), with an average advantage of 130%. SigTM comes within 10% of the HTM performance for delaunay and genome, but is approximately two times slower than HTM for vacation. The average advantage of HTM over SigTM is 70%. The differences between the three systems do not change significantly as we scale the number of processors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Performance Analysis</head><p>For delaunay, STM suffers from the late discovery of frequent conflicts and from read barrier overhead. SigTM discovers conflicts early and drastically reduces the read barrier time. At 16 processors, the SigTM speedup is 8.6, only 7% lower than the HTM speedup and 78% higher than the STM speedup. Genome behaves similarly to delaunay. SigTM reaches a speedup of 6.9, which is 9% lower than the HTM speedup and 27% higher than the STM speedup. At large processor counts, genome exhibits some work imbalance on STM and SigTM and experiences some commit serialization on the HTM.</p><p>For kmeans, the STM performance is primarily limited by writeset management. <ref type="figure">Figure 5</ref> shows that a significant portion of time is spent in write and commit barriers. SigTM accelerates the commit process but does not significantly reduce the write barrier overhead. Hence, SigTM reaches maximum speedups of 8.7 and 11 for the two kmeans workloads, which is 27% and 13% lower than the HTM speedups respectively, but 81% and 41% higher than the STM speedups. Obviously, the differences between the three systems are higher in low contention scenarios.</p><p>The two vacation workloads exhibit the biggest differences among the three TM implementations. Most transactions involve large read-sets as they search one or more trees in the database. Since tree traversals have no temporal locality, it is difficult to reduce the number of read barriers. Hence, the STM performance suffers heavily from read barrier overhead and read-set validation time during the commit stage. SigTM reduces both overheads and leads to a 280% improvement over STM for both workloads. Nevertheless, SigTM is still 200% (vacation-high) and 160% (vacation-low) slower than the HTM system which handles all transactional bookkeeping transparently. The overall speedups for SigTM are 4.6 and 11 for the two workloads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Sensitivity to Signature Length</head><p>The SigTM results in Section 6.2 assume long read-set and writeset signatures that eliminate virtually all false conflicts due to signature inaccuracies (2 Kbits per signatures). <ref type="figure">Figure 6</ref> presents the normalized performance of SigTM with 16 processors as we scale the read-set and write-set signature lengths from 2 Kbits down to 32 bits. Higher performance is better. We use the same set of hash functions in all experiments (see <ref type="table">Table 3</ref>).</p><p>The top graph in <ref type="figure">Figure 6</ref> shows that SigTM's performance is highly sensitive to the read-set signature length. Delaunay and genome are particularly problematic as they have a significant number of conflicts to begin with. Their performance drops dramatically with signature lengths less than 1 Kbits. The two vacation workloads are also sensitive to the read-set signature length. Due to their large read-sets, they start experiencing an increasing number of false conflicts for signature lengths less than 512 bits. At 64 bits, vacation achieves 40% of its original performance with 2 Kbits per signature. Kmeans is less sensitive due to its small readsets and does not experience significant performance improvement with more than 64 bits per signature.</p><p>In contrast, the bottom graph in <ref type="figure">Figure 6</ref> shows that none of the applications exhibit particular sensitivity to the write-set signature length. With 128 bit signatures, all workloads are virtually unaffected excluding delaunay, which performs 10% slower. This is due to two reasons. First, most applications have small write-sets that can be accurately represented even with small signatures. Second, our SigTM uses lazy versioning: write-set signatures detect conflicts only during the commit stage to guarantee write isolation as the write-set is copied to memory. Since the commit stage is short, the write-set signature accuracy is less critical. SigTM with eager versioning will likely be more sensitive to write-set signature length as it enables coherence lookups in the write-set throughout the transaction execution.</p><p>Given the applications and system sizes we studied, our recom-   <ref type="figure">Figure 4</ref>. Speedups over sequential code for the three TM implementations.</p><p>mendation is 1-Kbit read-set signatures and 128-bit write-set signatures. Hence, the per hardware thread cost of SigTM is 1152 bits of storage plus the logic for the hash functions. Further experiments are necessary to determine if such signatures are sufficient for other applications and larger-scale systems. The choice of hash function can also play a significant role in the signature accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>In the past few years, there has been significant research activity on transactional memory, covering topics such as implementation techniques, programming constructs, runtime systems, and contention management. We refer readers to Larus and Rajwar for a thorough coverage of transactional memory research <ref type="bibr" target="#b18">[18]</ref>.</p><p>Hybrid TM: The first hybrid TM systems were proposed to address the virtualization challenges of HTM <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b10">10]</ref>. These systems combine an HTM with an STM implementation, switching from the former to the latter if the hardware resources are exhausted. These hybrid TMs introduce modifications to caches (for the HTM) and require two versions of the code for every transaction.</p><p>Subsequent hybrid schemes introduced modifications to caches and coherence protocols in order to address performance bottlenecks of software transactions <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b24">24]</ref>. SigTM is closest to the HASTM system that adds software-controlled mark bits to each cache line <ref type="bibr" target="#b24">[24]</ref>. Transactions use these extra bits to create filters for conflict detection. However, there are significant differences between HASTM and SigTM. HASTM cannot rely exclusively on mark bits for conflict detection as cache lines from the read-set or write-set may be replaced at any time. Hence, the HASTM barriers must be able to fall back to the slower STM bookkeeping. SigTM is a stand-alone system without a backup STM mode. An additional issue for HASTM is that cache updates due to prefetching or speculative execution can evict transactional data causing unnecessary rollbacks or switches to the STM mode. The SigTM signatures are maintained in registers outside of the cache, hence their contents are not affected by speculative cache activity in the local processor.</p><p>To avoid false conflicts due to speculative activity in remote processors, signature hits should signal a conflict only when this activity is committed. Finally, introducing support for multithreaded cores and nested transactions in HASTM can be expensive as it requires multiple sets of mark bits per cache line. SigTM is the first hybrid scheme with strong isolation guarantees without barriers in non-transactional code.   <ref type="figure">Figure 5</ref>. Execution time breakdowns with 16 processors on the three TM systems.</p><p>Signature-based HTMs: SigTM was inspired by the Bulk HTM that first proposed the use of signatures for conflict detection <ref type="bibr" target="#b4">[5]</ref>. As an HTM, the Bulk design requires additional hardware to implement lazy data versioning in caches and must deal with cache capacity limitations. In contrast, SigTM implements data versioning in software and requires no hardware support beyond the read-set and write-set signatures. LogTM-SE is similar to Bulk but implements eager data versioning <ref type="bibr" target="#b27">[27]</ref>. It requires additional hardware to implement the undo log, including an array of recently logged cache lines. Using the SPLASH-2 suite, LogTM-SE suggests the use of short signature registers (32 to 64 bits). Our results indicate that longer registers are needed, in particular for the read-set.</p><p>Strong Isolation: Several researchers observed that strong isolation is necessary for predictable behavior in TM system <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b18">18]</ref>. Shpeisman et al. <ref type="bibr" target="#b25">[25]</ref> have categorized the problematic cases for both eager and lazy TM systems that do not provide strong isolation. They also presented a compiler methodology, including optimizations, that use additional barriers in non-transactional code in order to provide strong isolation guarantees. Blundell et al. also claim that there are cases for which strong isolation leads to unexpected results <ref type="bibr" target="#b3">[4]</ref>. We argue that strong isolation is not the issue in these cases. They are simply observing that transactions can replace lock-based synchronization in some cases (atomicity) but not in others (coordination).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSIONS</head><p>This paper presented signature-accelerated transactional memory, a hybrid TM implementation that reduces the overhead of software transactions. SigTM uses hardware signatures to track the read-set and write-set for pending transactions, but implements data versioning and all other transactional functionality in software. Unlike previous hybrid designs, SigTM requires no modifications to the hardware caches in a multi-core system, which reduces hardware cost and simplifies support for features such as nested transactions and multithreaded cores. SigTM is also the first hybrid TM system that transparently provides strong isolation guarantees that lead to predictable interactions between transactional blocks and non-transactional accesses.</p><p>Using a set of applications that make frequent use of coarse-grain transactions, we compared SigTM to STM and HTM systems. We show that SigTM outperforms software-only transactions by 30% to 280%. While for some workloads it performs within 10% of HTM systems, for workloads with large read-sets SigTM trails HTM by up to 200%. We also demonstrated that 1-Kbit signatures for the read-set and 128-bit signatures for the write-set are sufficient to eliminate most false conflicts due to the inexact nature of signature-based conflict detection.</p><p>Overall, SigTM combines the performance characteristics and strong isolation guarantees of hardware TM techniques with the low cost and flexibility of software TM systems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. The STM execution time breakdown for a single processor run. Execution time is normalized to that of the sequential code without transaction markers or read/write barriers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. The code for the privatization scenario.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 2 presents the com- mon case dynamic instruction count for STM and SigTM barriers.</head><label>2</label><figDesc></figDesc><table>Read 
Write 
Commit 
Barrier Barrier 
Barrier 
STM 
19 
43 44 + 16R + 31W 
SigTM 
8 
35 
41 + 12W 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 4 .</head><label>4</label><figDesc></figDesc><table>The basic application statistics for the STM, SigTM, and HTM systems. STM and SigTM have the same number of read and write 
barriers per transaction. For the HTM, we present the number of cache lines in the transaction's read-set and write-set. All numbers are 
averages across the whole program execution. All kmeans statistics follow a bipolar distribution. For vacation, the number of instructions 
per transaction and read-set related statistics follow an even distribution. The remaining statistics follow roughly a normal distribution. 

delaunay 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

1 
2 
4 
8 
16 

Processor Cores 

Speedup 

genome 

0 

1 

2 

3 

4 

5 

6 

7 

8 

1 
2 
4 
8 
16 

Processor Cores 

Speedup 

HTM 
STM 
SigTM 

vacation-low 

0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 

1 
2 
4 
8 
16 

Processor Cores 

Speedup 

kmeans-high 

0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 

1 
2 
4 
8 
16 

Processor Cores 

Speedup 

vacation-high 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

1 
2 
4 
8 
16 

Processor Cores 

Speedup 

kmeans-low 

0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 

1 
2 
4 
8 
16 

Processor Cores 

Speedup 

</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">ACKNOWLEDGMENTS</head><p>We would like to thank Nir Shavit, David Dice, Ali-Reza AdlTabatabai, and the anonymous reviewers for their feedback at various stages of this work. We also want to thank Sun Microsystems for making the TL2 code available. This work was supported by NSF Career Award number 0546060, NSF grant number 0444470, and FCRP contract 2003-CT-888.</p></div>
			</div>

			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Unlocking Concurrency: Multi-core programming with Transactional Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Adl-Tabatabai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kozyrakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Saha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Queue</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">10</biblScope>
			<date type="published" when="2006-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Compiler and Runtime Support for Efficient Software Transactional Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A.-R</forename><surname>Adl-Tabatabai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Menon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">R</forename><surname>Murphy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Shpeisman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 2006 Conference on Programming Language Design and Implementation (PLDI)</title>
		<meeting><address><addrLine>Ottawa, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Space/Time Trade-Offs in Hash Coding with Allowable Errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Bloom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of ACM</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">7</biblScope>
			<date type="published" when="1970-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Subtleties of Transactional Memory Atomicity Semantics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Blundell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">C</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Architecture Letters</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2006-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Bulk Disambiguation of Speculative Threads in Multiprocessors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tuck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Torrellas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cascaval</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 33rd Intl. Symposium on Computer Architecture (ISCA)</title>
		<imprint>
			<date type="published" when="2006-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Non-blocking Approach to Transactional Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chafi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Casper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">D</forename><surname>Carlstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Minh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Baek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kozyrakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Olukotun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Scalable</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 13th Intl. Symposium on High Performance Computer Architecture (HPCA)</title>
		<meeting><address><addrLine>Phoenix, AZ</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Unbounded Page-Based Transactional Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Chuang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Venkatesh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sampson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">V</forename><surname>Biesbrouck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Colavin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 12th Intl. Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting><address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Tradeoffs in Transactional Memory Virtualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Minh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chafi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">D</forename><surname>Carlstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Skare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kozyrakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Olukotun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 12th Intl. Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting><address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The Common Case Transactional Behavior of Multithreaded Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chafi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Minh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">D</forename><surname>Carlstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kozyrakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Olukotun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 12th</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Intl</surname></persName>
		</author>
		<title level="m">Conference on High-Performance Computer Architecture (HPCA)</title>
		<meeting><address><addrLine>Austin, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Hybrid transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Damron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fedorova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Luchangco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Moir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Nussbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 12th Intl. Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting><address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Transactional Locking II</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dice</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Shalev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shavit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 20th Intl. Symposium on Distributed Computing (DISC)</title>
		<meeting><address><addrLine>Stockholm, Sweden</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Understanding Tradeoffs in Software Transactional Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dice</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shavit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the Intl. Symposium on Code Generation and Optimization (CGO)</title>
		<meeting><address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Transactional Memory Coherence and Consistency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hammond</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">D</forename><surname>Carlstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hertzberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Prabhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Wijaya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kozyrakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Olukotun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 31st Intl. Symposium on Computer Architecture (ISCA)</title>
		<meeting><address><addrLine>Munich, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Language Support for Lightweight Transactions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fraser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 18th Conference on Object-oriented Programing, Systems, Languages, and Applications (OOPSLA)</title>
		<meeting><address><addrLine>Anaheim, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Optimizing Memory Transactions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Plesko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shinnar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Tarditi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the Conference on Programming Language Design and Implementation (PLDI)</title>
		<meeting><address><addrLine>Ottawa, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Transactional Memory: Architectural Support for Lock-Free Data Structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">E B</forename><surname>Moss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 20th Intl. Symposium on Computer Architecture (ISCA)</title>
		<meeting><address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Hybrid Transactional Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">J</forename><surname>Hughes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kundu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Nguyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 11th Symposium on Principles and Practice of Parallel Programming (PPoPP)</title>
		<meeting><address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">J. Larus and R. Rajwar. Transactional Memory. Morgan Claypool Synthesis Series</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Lowering the Overhead of Nonblocking Software Transactional Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">J</forename><surname>Marathe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename><surname>Spear</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Heriot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Acharya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Eisenstat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">N</forename><surname>Scherer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">L</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 1st Workshop on Languages, Compilers, and Hardware Support for Transactional Computing</title>
		<meeting><address><addrLine>Ottawa, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Architectural Semantics for Practical Transactional Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">D</forename><surname>Carlstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Minh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chafi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kozyrakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Olukotun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 33rd Intl. Symposium on Computer Architecture (ISCA)</title>
		<meeting><address><addrLine>Bostom, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">LogTM: Log-Based Transactional Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">E</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bobba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Moravan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 12th Intl. Conference on High-Performance Computer Architecture (HPCA)</title>
		<meeting><address><addrLine>Austin, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Virtualizing Transactional Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rajwar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Lai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 32nd Intel. Symposium on Computer Architecture (ISCA)</title>
		<meeting><address><addrLine>Madison, WI</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A High Performance Software Transactional Memory System For A Multi-Core Runtime</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A.-R</forename><surname>Adl-Tabatabai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Hudson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">Cao</forename><surname>Minh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hertzberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 11th Symposium on Principles and practice of Parallel Programming (PPoPP)</title>
		<meeting><address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Architectural Support for Software Transactional Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A.-R</forename><surname>Adl-Tabatabai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Jacobson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 39th Intl. Symposium on Microarchitecture (MICRO)</title>
		<meeting><address><addrLine>Orlando, FL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Enforcing Isolation and Ordering in STM</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Shpeisman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Menon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A.-R</forename><surname>Adl-Tabatabai1</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Balensiefer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Grossman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Hudson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Saha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 2007 Conference on Programming Language Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2007-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The SPLASH2 Programs: Characterization and Methodological Considerations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">C</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ohara</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Torrie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Symposium on Computer Architecture</title>
		<meeting>the 22nd International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1995-06" />
			<biblScope unit="page" from="24" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">LogTM-SE: Decoupling Hardware Transactional Memory from Caches</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Yen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bobba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Marty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">E</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Volos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 13th Intl. Symposium on High Performance Computer Architecture (HPCA)</title>
		<imprint>
			<date type="published" when="2007-02" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
