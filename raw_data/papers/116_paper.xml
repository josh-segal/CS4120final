<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:30+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Ordinal-Recursive Complexity of Timed-Arc Petri Nets, Data Nets, and Other Enriched Nets</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Serge</forename><surname>Haddad</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Laboratoire Spécification et Vérification (LSV)</orgName>
								<orgName type="institution">ENS Cachan &amp; CNRS Cachan</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sylvain</forename><surname>Schmitz</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Laboratoire Spécification et Vérification (LSV)</orgName>
								<orgName type="institution">ENS Cachan &amp; CNRS Cachan</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philippe</forename><surname>Schnoebelen</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Laboratoire Spécification et Vérification (LSV)</orgName>
								<orgName type="institution">ENS Cachan &amp; CNRS Cachan</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The Ordinal-Recursive Complexity of Timed-Arc Petri Nets, Data Nets, and Other Enriched Nets</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Index Terms-Complexity theory</term>
					<term>fast-growing hierarchy</term>
					<term>for- mal verification</term>
					<term>Petri nets</term>
					<term>well-structured systems</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We show how to reliably compute fast-growing functions with timed-arc Petri nets and data nets. This construction provides ordinal-recursive lower bounds on the complexity of the main decidable properties (safety, termination, regular simulation, etc.) of these models. Since these new lower bounds match the upper bounds that one can derive from wqo theory, they precisely characterise the computational power of these so-called &quot;enriched&quot; nets.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>We call enriched nets a handful of Petri net extensions where tokens are coloured with data values, that still enjoy decidable verification problems: timed-arc Petri nets (TPN) where tokens carry real-valued clocks <ref type="bibr" target="#b5">[6]</ref>, data nets (DN) and Petri data nets (PDN) where they carry a datum from some dense domain <ref type="bibr" target="#b19">[19]</ref>, and constrained multiset rewriting systems (CMRS) where they carry positive integers <ref type="bibr" target="#b2">[3]</ref>. Their richer structure makes enriched nets a natural choice when modelling for instance parameterised systems, protocols, workflows, or real-time systems-in fact, timed extensions of Petri nets have been in use since the 1970's for such modelling tasks. In spite of the presence of two "sources" of infiniteness, the number of tokens and their colours, enriched nets can be handled by the now standard toolkit of well quasi-orders (wqo) and well-structured transition systems (WSTS) <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b14">14]</ref> so that e.g. safety-which in this context corresponds to the coverability problem-and other properties are decidable <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b9">9]</ref>.</p><p>Recent investigations <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7]</ref> have shown that all these formalisms are expressively equivalent, i.e. they define the same class of so-called coverability languages, and thus in particular their coverability problems are inter-reducible. Their computational complexity, however, has rarely been analysed. The employed wqo and WSTS techniques are generally seen as non-constructive, hence the aforementioned works do not provide any complexity analysis of the algorithms they propose ( <ref type="bibr">[19, Prop. 3.2]</ref> gives a lower bound: PDNs can simulate lossy channel systems and hence inherit at least their F ω ω complexity <ref type="bibr" target="#b10">[10]</ref>, but this is far from optimal).</p><p>We prove in this paper that the complexity of enriched nets is exactly at level F ω ω ω in the fast-growing hierarchy.</p><p>1) The upper bound is a consequence of a generic technique described in <ref type="bibr" target="#b22">[22]</ref>: the length-function theorem for elementary wqos, here instantiated with (N k ) * as the underlying wqo. It applies uniformly to DN, PDNs, TPNs, CMRSs (and to some further extensions); see Sec. IV.</p><p>2) The matching lower bound is our main contribution: it relies on the construction of PDNs with O(k) unbounded places that can compute in a weak sense the fast-growing functions F ω ω k and their inverses and therefore simulate F ω ω kbounded computations (see Sec. V for an overview). This construction relies on several intermediate steps: we first define in Sec. VI-A a cumulative encoding of ordinals below ω ω ω k in sequences of vectors of integers (or "codes") along with rewriting rules over codes implementing fast-growing computations and their inverses (see Sec. VI-B). Because this encoding is robust, i.e. safe wrt. Higman's ordering on codes, any weak implementation of the rewriting rules will yield the desired behaviour (Sec. VI-C); in particular, a weak PDN implementation is possible, as shown in Sec. VII. Once established for PDNs, the new lower bound automatically applies to <ref type="bibr">TPNs and DNs.</ref> 3) Beyond the complexity of verification problems, our techniques are easily applied to the study of the coverability languages of WSTS models <ref type="bibr" target="#b17">[17]</ref>. Here our construction directly yields separation results; see Sec. VIII.</p><p>The details of the proofs and of the construction of PDNs can be found in the long version of the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. PETRI DATA NETS</head><p>Although the complexity of decision problems in timedarc Petri nets provided our prime motivation-an important body of literature is dedicated to their analysis <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b9">9]</ref> and they are actually employed in tools [e.g. 18]-, we will work exclusively with Petri data nets, which proved easier to manipulate, and rely on known interreducibility results <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b0">1]</ref> to capture the other classes of enriched nets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Definitions</head><p>We denote by 0 the null vector in N k for any k, and for a word w = x 1 · · · x n we write |w| = n and w(i) = x i .</p><p>A Petri Data Net (PDN) is a Petri net where each token carries an identity from a linearly ordered and dense domain D. A marking s of a PDN with P as set of places could be seen, e.g., as a multiset of pairs in D × P , or as a map s ∈ (N P ) D . However, two key features of PDNs will guide our choice of (N |P | \ 0) * for representing markings:</p><p>1) a marking s only has finitely many tokens, thus denoting d 1 &lt; · · · &lt; d m the identities that occur in s and gathering all the tokens that carry the same identity d i , one obtains a (non-null) place vector v i in N |P | \ 0: s can be written as a sequence</p><formula xml:id="formula_0">(d 1 , v 1 ) · · · (d m , v m ),</formula><p>implicitly associating the null vector 0 with any d ∈ D \ {d 1 , . . . , d m }; 2) the concrete identities d i are irrelevant, and only their relative order is useful wrt. the dynamics of the net, thus s can safely be abstracted as the sequence</p><formula xml:id="formula_1">v 1 · · · v m in (N |P | \ 0) * .</formula><p>(Also the choice of the concrete set D is irrelevant.) Every transition t of a PDN specifies a sequence of n ordered potential identities and for any such identity specifies the tokens cons to be consumed and prod to be produced. Thus cons(t) and prod (t) are two sequences of n (possibly null) place vectors.</p><formula xml:id="formula_2">Definition 1 (Petri Data Nets). A k-dimensional Petri Data Net (k-PDN) is a tuple N = (P, T, cons, prod , s 0 ) where</formula><p>• P is a finite set of k = |P | places, • T is a finite set of transitions with P ∩ T = ∅, • for every t in T , cons(t) and prod (t) are finite sequences in (N k ) * with |cons(t)| = |prod (t)|, and</p><formula xml:id="formula_3">• s 0 is an initial marking in (N k \ 0) * .</formula><p>Consider now a marking s ∈ (N k \ 0) * . In order to fire a transition t with |cons(t)| = n, nondeterministically select n identities, consume some of their tokens as indicated by cons(t), and produce new tokens with the identities specified by prod (t). However, some of these n identities might not be present in s, and we should introduce null vectors wherever necessary:</p><formula xml:id="formula_4">s ∈ (N k ) * is a 0-extension of s ∈ (N k \ 0) * (or s is the 0-contraction of s ) def</formula><p>⇔ s is obtained by removing all 0's from s . Once an extension s is built, select in it a subword of n vectors x 1 , . . . , x n s.t. every vector contains enough tokens, i.e. with x i ≥ cons(t)(i). If the condition is fulfilled, the corresponding tokens are consumed and prod (t)(i) is added to the resulting vector, yielding a new sequence s . This s may contain null vectors, e.g. when all tokens with some identity have been consumed, hence the reached marking really is the 0-contraction of s . Note that any way of firing t requires at most n insertions. Examples of PDNs will be found in Section VII.</p><p>Definition 2 (Semantics of PDNs). The transition system associated with a k-PDN N = (P, T, cons, prod , s 0 ) is (S, s 0 , →) with state set S • there exists u 0 x 1 u 1 · · · u n−1 x n u n a 0-extension of s with for all i, u i ∈ (N k ) * and x i ∈ N k ; • for i in {1, . . . , n}, x i ≥ cons(t)(i);</p><p>• and defining y i = x i − cons(t)(i) + prod (t)(i), s is the 0-contraction of u 0 y 1 u 1 · · · u n−1 y n u n .</p><p>Below we consider three decision problems for PDNs: (Strong) Coverability: Given N and p ∈ P , can we reach a configuration where p holds at least one token? Boundedness: Given N , is the set of reachable configurations in S finite? Termination: Given N , is every run finite?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. PDNs as Well-Structured Transition Systems</head><p>A wqo (A, ≤) is a set A endowed with a transitive and reflexive relation ≤ s.t. every infinite sequence σ = a 0 , a 1 , · · · of elements of A contains a pair a i ≤ a j for some i &lt; j. Some classical examples of wqos are</p><p>Dickson's Lemma: (N k , ≤) with the product ordering defined by</p><formula xml:id="formula_5">x ≤ y def ⇔ ∀0 ≤ j &lt; k, x[j] ≤ y[j], Higman's Lemma: if (A, ≤) is a wqo, then (A * , ≤ * ) the set</formula><p>of finite sequences of elements of A along with the subword embedding ordering is also a wqo, where</p><formula xml:id="formula_6">≤ * is defined by s ≤ * s def ⇔ s = a 1 · · · a n , s = x 0 b 1 x 1 · · · b n x n with x 0 , . . . , x n in A * and a i ≤ b i for all 1 ≤ i ≤ n.</formula><p>The transition system associated with a PDN (see Definition 2) is well-structured <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b14">14]</ref>   <ref type="bibr" target="#b3">4</ref> . This (strict) compatibility of the transition relation with the ordering allows to employ generic algorithms for deciding coverability, boundedness, and termination. In fact, the same generic WSTS algorithms show that coverability, boundedness and termination are decidable • for TPNs <ref type="bibr" target="#b1">[2]</ref>, even when extended with read arcs <ref type="bibr" target="#b9">[9]</ref> or transport arcs <ref type="bibr" target="#b18">[18]</ref>, • for CMRSs <ref type="bibr" target="#b2">[3]</ref>, and • as far as coverability and termination are concerned, for DNs <ref type="bibr" target="#b19">[19]</ref>. Compared to PDNs, these allow so-called whole-place operations that can e.g. duplicate or erase the whole contents of some places, and/or transfer them to other places, which makes their compatibility non-strictand indeed their boundedness problem is undecidable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. ORDINAL RECURSIVE COMPLEXITY</head><p>The enormous complexity of some decidable problems on WSTSs requires the introduction of complexity classes spanning way beyond the usual polynomial or exponential hierarchies. The complexity classes we consider are generated by ordinal-indexed subrecursive hierarchies, like the Hardy hierarchy and the fast-growing hierarchy. See <ref type="bibr" target="#b12">[12]</ref> for a selfcontained presentation; we only recall below the notions and notations that are required for our construction in Section VI.</p><p>It is well-known that any ordinal α &lt; ε 0 can be written uniquely in Cantor Normal Form (CNF). In this paper we use a dotted addition symbol " ˙ +" when we want to stress that an ordinal term is in CNF. Thus, when we write</p><formula xml:id="formula_7">α = ω α1 ˙ + · · · ˙ + ω αp ,<label>(1)</label></formula><p>we mean that not only the equality (1) holds, but also that α p ≤ . . . ≤ α 1 &lt; α, as required by CNF. (NB: we allow writing α ˙ + α when α or α is 0.) Subrecursive hierarchies are defined through assignments of fundamental sequences (λ n ) n&lt;ω for limit ordinals λ &lt; ε 0 , verifying λ n &lt; λ for all x and λ = sup n λ n . A standard assignment is defined by:</p><formula xml:id="formula_8">γ ˙ + ω α+1 n def = γ ˙ + ω α · ω n , γ ˙ + ω λ n def = γ ˙ + ω λn ,<label>(2)</label></formula><p>together with ω n def = n. Writing Ω for the ordinal ω ω ω ω , this yields for instance Ω k = ω ω ω k and</p><formula xml:id="formula_9">(Ω k ) k = ω ω ω k−1 ·k . The Hardy hierarchy (H α : N → N) α&lt;ε0 is defined by H 0 (n) def = n and H α+1 (n) def = H α (n + 1), H λ (n) def = H λn (n). (3)</formula><p>Observe that H 1 is the successor function, and more generally H α is the αth iterate of the successor function, using diagonalisation to treat limit ordinals. The fast growing hierarchy</p><formula xml:id="formula_10">(F α : N → N) α&lt;ε0 can be defined by F α def = H ω α , resulting in F 0 (n) = H 1 (n) = n + 1, F 1 (n) = H ω (n) = H n (n) = 2n</formula><p>, F 2 (n) = H ω 2 (n) = 2 n n being exponential, F 3 nonelementary, and F ω an Ackermannian function.</p><p>By applying elementary closure operations to the collection of functions (F β ) β≤α along with the addition, projection and zero functions, one obtains a hierarchy (F α ) α known as the extended Grzegorczyck hierarchy <ref type="bibr" target="#b20">[20]</ref>, which characterises several natural classes of functions; for instance F 0 = F 1 is the class of linear functions, F 2 that of elementary ones, k∈N F k of primitive-recursive ones, and k∈N F ω k of multiply-recursive ones. The hierarchy is strict for all 0 &lt; α &lt; α :</p><formula xml:id="formula_11">F α F α , in particular because F α ∈ F α .</formula><p>The (F α ) α hierarchy provides a more abstract packaging of the main stops in the extended Grzegorczyk hierarchy and requires lighter notation than the Hardy hierarchy (H α ) α . However, with its tail-recursive definition, the Hardy hierarchy is easier to implement as a while-program or as a counter machine. Below we weakly implement Hardy computations with PDNs. Formally, a (forward) Hardy computation is a sequence</p><formula xml:id="formula_12">α 0 , n 0 − → α 1 , n 1 − → α 2 , n 2 − → · · · − → α , n of evaluation steps implementing Eq. (3) seen as left-to-right rewrite rules. It guarantees α 0 &gt; α 1 &gt; α 2 &gt; · · · and n 0 ≤ n 1 ≤ n 2 ≤ · · · and keeps H αi (n i ) invariant.</formula><p>We say it is complete when α = 0 and then n = H α0 (n 0 ) (we also consider incomplete computations). A backward Hardy computation is obtained by using Eq. (3) as right-to-left rules. For instance, Ω, k → Ω k , k → (Ω k ) k , k constitute the first three steps of the forward Hardy computation starting from Ω, k if k &gt; 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. COMPLEXITY UPPER BOUNDS</head><p>A key insight for the complexity analysis of WSTS algorithms is that the use of wqos yields not only algorithm termination, but also upper complexity bounds:</p><p>Theorem 3 (Upper Bound). Coverability and termination for PDNs, DNs, TPNs, and CMRSs, are in F ω ω ω n + O(1) .</p><p>For this result, as explained in <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b22">22]</ref>, we merely need to find out <ref type="formula" target="#formula_7">(1)</ref> what is the complexity of a step of the WSTS (in the case of PDNs, transitions perform simple affine operations in F 1 ), and (2) the maximal order type of the wqo, which is a measure of its complexity (this is Ω k for a k-PDN). By the length function theorem for elementary wqos (see full version of <ref type="bibr" target="#b22">[22]</ref>), we then obtain a parameterised upper bound in F ω ω k for the decision problems of k-PDNs mentioned in Section II-B, and a uniform F ω ω ω upper bound (which asymptotically majorises every function in k F ω ω k ) when the dimension is not fixed.</p><p>These upper bounds hold more generally for k-DNs, as they have the same order type and their extra whole-place operations are still in F 1 . Regarding TPNs and CMRSs, the F ω ω ω upper bound also holds; however here the main parameter in the parameterised complexity-which appears as the exponent on top of the tower of ω's-is not simply the dimension k but km where m is the maximal constant that appears in the constraints put on transitions or in the initial marking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. COMPLEXITY LOWER BOUNDS</head><p>We now describe the proof plan for our main result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4 (Lower Bound). Coverability and termination for</head><p>PDNs are F ω ω ω -hard.</p><p>This follows from a reduction from the halting problem for Minsky machines (MM) M with counters bounded by F ω ω ω (|M |). The proof is done by assembling two constructions (described in the following sections). The schematics (see <ref type="figure" target="#fig_1">Fig. 1</ref>) are similar to earlier constructions for lossy channel systems or counter machines and the reader can refer to <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b10">10]</ref> where more lower-level details are given. We outline it as a motivation for the following sections. 1) Direct Computation: For a provided size k, we first construct (see Section VII) a PDN N H [k] initialised with a pair α 0 , n 0 def = (Ω k ) k , k and that tries to rewrite it α 0 , n 0 − → α 1 , n 1 − → · · · − → α , n in a way that reflects precisely the complete Hardy derivation issuing from α 0 , n 0 , thus computing n = H α0 (n 0 ) = H Ω (k). There are two difficulties here. First, one has to encode ordinals in sequences of vectors (i.e. in PDN configurations) and this is the topic of Section VI. Secondly, our PDN only performs Hardy computations in a weak sense. What is guaranteed is the following:</p><formula xml:id="formula_13">N H [k] =(Ω k ) k ,k α 0 , n 0 r − → · · · r − → α i , n i r − → · · · r − → α , ≤H α 0 (n0) n p start p rewr p halt t rewr N H −1 [k] 0, m 0 r − → −1 · · · r − → −1 α, n p start p rewr p halt t rewr N M p start p halt simulate M using cpt as a budget cpt c M 1 c M r</formula><formula xml:id="formula_14">Lemma 5 (See Section VII). N H [k] is "complete": Starting with α 0 = (Ω k ) k , N H [k]</formula><p>can perform the exact Hardy computation and halt with α = 0 and n = H Ω (k).</p><formula xml:id="formula_15">N H [k] is "safe": Any halting computation in N H [k], correct or incorrect, has n ≤ H Ω (k).</formula><p>2) Simulation: Now consider some MM M of size k. An easy (see <ref type="bibr">[11, §7]</ref> or <ref type="bibr">[21, §4]</ref> for emptiness: at this point, the value n f of cpt is necessarily ≤ n , and only equals n if c M 1 , . . . , c M r are empty (NB: if M halts, n f = n is indeed feasible).</p><p>3) Inverse Computation: </p><formula xml:id="formula_16">We now connect N H [k], N M and N H −1 [k] so that they run sequentially. Here N H −1 [k] is a</formula><formula xml:id="formula_17">(Ω k ) k , k if m 0 = H Ω (k).</formula><p>Here too, the PDN only computes H −1 in a weak sense but it is guaranteed that it can do exact backward computations (completeness) and that incorrect backward computations halting on <ref type="bibr">(Ω k</ref> </p><formula xml:id="formula_18">) k , n have H (Ω k ) k (n) ≤ m 0 (safety).</formula><p>As a consequence, the resulting full PDN started with (Ω k ) k , k can reach a configuration with p halt and a pair α, n that covers (Ω k ) k , k (in terms of the places that store the current Hardy pair) if, and only if, the Minsky machine M with space bounded by H Ω (k) = F ω ω ω (k) halts.</p><p>Indeed, if M halts within the space bound, the PDN may reach the required p halt , α, n by chaining exact Hardy computations and the simulation of M by N M . More interestingly, if the required α, n is reached, we know, letting h</p><formula xml:id="formula_19">def = H Ω (k), that n ≤ h (safety of N H ), that n ≥ n f = m 0 (budget of N M ), that H α (n) ≤ m 0 (safety of N H −1 ), and that H α (n) ≥ h (α, n covers (Ω k ) k , k). Thus h ≤ H α (n) ≤ m 0 = n f ≤ n ≤ h.</formula><p>Necessarily n = n f , witnessing that M halts, and n = h, witnessing that M runs in space bounded by h = F ω ω ω (k).</p><p>In conclusion, the construction provides a (logspace) manyone reduction from the halting problem for Minsky machines running in space bounded by F ω ω ω (k) where k = |M | is the size of the MM description. Using standard complexitytheoretical arguments, Theorem 4 (for Coverability) follows. 4) Termination: Regarding termination, a similar reduction works. One makes sure that N H [k] always halts or deadlocks (it does) and stores two copies of n : one is a time budget that ensures the eventual halting-or-deadlock of N M , and the other witnesses n f = n as earlier. In the end, the whole system has to eventually stop, unless it can cover (Ω k ) k , k with α, n, finally enabling an infinite loop. This reduces the same MM problem to termination for PDNs. More details can be found in <ref type="bibr">[23, §7]</ref> where the same adaptation is done.</p><p>Using the simulations of PDNs by TPNs of <ref type="bibr" target="#b6">[7]</ref> and of DNs by CMRSs of <ref type="bibr">[1, §5]</ref>, we conclude:</p><p>Corollary 6. Coverability and Termination for TPNs, DNs, and CMRSs are F ω ω ω -hard.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. ENCODING HARDY COMPUTATIONS</head><p>We define in this section a so-called "cumulative" encoding of ordinals as codes (Section VI-A) and a rewriting system r − → operating on codes that performs Hardy computations (Section VI-B). Its crucial property is its robustness, which entails that weak implementations, like the PDN implementation we present in Section VII, are correct (see Section VI-C).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Encoding Ordinals as Cumulative Vector Sequences</head><p>Fix k ∈ N. An ordinal &lt; ω k is "small" and we use β, β , . . . to denote small ordinals; an ordinal &lt; ω ω k is "medium" and we use α, α , . . . for such ordinals; finally, an ordinal &lt; Ω k is "large" and we use π, π , . . . for such ordinals. A medium ordinal can be written in CNF as α = ω β1 ˙ + · · · ˙ + ω βp where β 1 , . . . , β p are small ordinals, and a large ordinal can be written as π = ω α1 ˙ + · · · ˙ + ω αm where α 1 , . . . , α m are medium ordinals.</p><p>We now introduce an encoding of large ordinals that will allow the computation of the Hardy functions with PDNs. These data structures are 1) k-dimensional vectors in N k for small ordinals, 2) vector sequences in (N k ) * for medium ordinals, and 3) cumulative encodings in (N k {#}) * for large ordinals, where # is a fresh tally symbol.</p><p>1) Small Ordinals as Vectors: For v ∈ N k and an index 0 ≤ i &lt; k, let v[i] ∈ N denote the i-th component of v. We use two different orderings over N k : the product ordering, denoted v ≤ v and the lexicographic ordering, denoted v ≤ lex v , with most significant component at index k − 1. Recall that ≤ is a wqo, and that ≤ lex is a linearization of ≤.</p><p>With a vector v ∈ N k , we associate the small ordinal</p><formula xml:id="formula_20">β(v) def = ω k−1 · v[k − 1] ˙ + · · · ˙ + ω 0 · v[0] .<label>(4)</label></formula><p>This establishes a bijective correspondence between N k and small ordinals, and we write v(β) for β −1 (β). </p><formula xml:id="formula_21">v ≤ lex v iff β(v) ≤ β(v ) .<label>(5)</label></formula><p>2) Medium Ordinals as Vector Sequences: With a finite sequence V = v 1 v 2 · · · v p ∈ N k * , we associate the ordinal <ref type="bibr">vp)</ref> . <ref type="formula" target="#formula_48">(6)</ref> This surjective 1 embedding of N k * into ω ω k satisfies α(VV ) = α(V) + α(V ). Write ε for the empty sequence in N k * . Then α(V) = 0 iff V = ε, and α(V) = 1 iff V = 0.</p><formula xml:id="formula_22">α(V) = α(v 1 v 2 · · · v p ) def = ω β(v1) + · · · + ω β(</formula><formula xml:id="formula_23">Example 7. Consider k = 2: α(1 0 ) = α(| 0 1 ) = ω β(10) = ω ω 0 ·1 = ω 1 = ω, thus α(| 0 1 | 0 1 ) = ω · 2, while α(2 × 1 0 ) = α(| 0 2 ) = ω ω 0 ·2 = ω 2 .</formula><p>We order vector sequences with ≤ * , the sequence extension of ≤: it is a wqo since ≤ is.</p><p>We</p><formula xml:id="formula_24">say that V = v 1 · · · v p is pure if v 1 ≥ lex v 2 ≥ lex · · · ≥ lex v p :</formula><p>restricted to pure vector sequences, the embedding in (6) is bijective since the expression giving α(V) in Eq. <ref type="formula" target="#formula_48">(6)</ref> is in CNF. We write pure(V) for the only pure V such that α(V) = α(V ): one obtains pure(V) by removing in</p><formula xml:id="formula_25">V = v 1 · · · v p any v i such that v i &lt; lex v j for some j &gt; i. Hence pure(V) ≤ * V.</formula><p>3) Cumulative Encodings for Large Ordinals: Fix a special tally symbol # and let N k</p><formula xml:id="formula_26"># def = N k ∪{#}. A cumulative ordinal description, or simple a "code", is a sequence x in N k # * . Below we see them as sequences in [N k * #] * N k * , i.</formula><p>e. we single out the tally symbols and factor codes under the form</p><formula xml:id="formula_27">x = V 1 #V 2 # · · · #V m #V rest ,<label>(7)</label></formula><p>where the V i 's are vector sequences. We extend ≤ * from vector sequences to codes in the natural way, by requiring that a # embeds into a #: this is still a wqo. With x we associate a large ordinal π(x) via the following</p><formula xml:id="formula_28">π(V 1 #V 2 # · · · #V m #V rest ) def = ω α(V1V2···Vm) ˙ + · · · ˙ + ω α(V1V2) ˙ + ω α(V1) .<label>(8)</label></formula><p>The above definition explains why codes are called cumulative. One can also define π inductively by</p><formula xml:id="formula_29">π(V) = 0 , π(V#x) = ω α(V) · π(x) ˙ + ω α(V) .<label>(9)</label></formula><p>We say that x is pure if each V i , i = 1, . . . , m, is pure, and if in addition V rest = ε. (NB: purity of, e.g., V 1 #V 2 #, does not guarantee purity of V 1 V 2 .) For a code x, the unique pure x such that π(x) = π(x ), denoted x = pure(x), is given by</p><formula xml:id="formula_30">pure(V 1 #V 2 # · · · #V m #V rest ) = pure(V 1 )#pure(V 2 )# · · · #pure(V m )#ε .<label>(10)</label></formula><p>Lemma 8. x ≤ * x implies pure(x) ≤ * pure(x ).</p><p>Lemma 9 (Bijection). Pure codes in N k # * and large ordinals in Ω k are in bijection by π.</p><p>If we write V (x) for the vector sequence obtained by removing all tally symbols from x, i.e. the result of the projection # → ε applied to x, then</p><formula xml:id="formula_31">π(x 1 #x 2 ) = π(pure(V (x 1 )x 2 )) ˙ + π(x 1 #) .<label>(11)</label></formula><p>Example 10. Let k &gt; 1; the initial Hardy computation step x 0 , k → x 1 , k with pure codes x 0 , x 1 is defined by</p><formula xml:id="formula_32">x 0 def = (1 k−1 ) k # ; π(x 0 ) = (Ω k ) k ; x 1 def = (1 k−1 ) k−1 (1 k−2 ) k # ; π(x 1 ) = ω ω ω k−1 ·(k−1)+ω k−2 ·k .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Rewriting of Ordinal Codes</head><p>Let us turn to the encoding of Hardy computations (below Ω k ) as rewriting rules on codes. Such a system should e.g. map x 0 to x 1 in Example 10. It turns out that the bulk of the task when computing Hardy functions lies in computing the elements in the fundamental sequences of limit ordinals.</p><p>1) Limit Ordinals: Observe that a code denotes a successor ordinal if it is of the form #x, as indeed π(#x) = ω 0 · π(x) + ω 0 = π(x) + 1. Conversely, a pure code of form Vv#x denotes a limit ordinal <ref type="bibr">Vv)</ref> ) n . We want to define a similar mapping (.) n from codes to codes s.t. π (x) n = π(x) n ; this mapping essentially needs to treat the head Vv, which contributes the smallest term ω α(Vv) to the encoded ordinal. Several cases arise depending on v:</p><formula xml:id="formula_33">π(Vvx) ˙ + ω α(Vv) s.t. π(Vv#x) n = π(Vvx) ˙ + (ω α(</formula><formula xml:id="formula_34">• if v = 0, i.e. ω β(v) = 1, then ω α(V0) = ω α(V)+1 verifies (ω α(V0) ) n = ω α(V) · n, encoded through (V0) n def = V# n .<label>(12)</label></formula><p>Thus we verify</p><formula xml:id="formula_35">π (V0#x) n def = π(V# n 0x)<label>(13)</label></formula><formula xml:id="formula_36">= π(V0x) ˙ + ω α(V) · n = π(V0#x) n . • if v = 0 then (ω α(Vv) ) n = ω α(V) ˙ +(ω β(v) )n (recall that Vv is pure) is encoded by (Vv) n def = V(v) n # ,<label>(14)</label></formula><p>and we need to further distinguish two cases: let i ∈ {0, . . . , k − 1} be the smallest index with v[i] &gt; 0. Then β(v) is a successor ordinal if i = 0 and a limit ordinal otherwise, hence the definition</p><formula xml:id="formula_37">(v) n def = (v − 1 0 ) n if i = 0, v − 1 i + n · 1 i−1 otherwise.<label>(15)</label></formula><p>Since every vector in the sequence (v) n is &lt; lex v, this verifies</p><formula xml:id="formula_38">π (Vv#x) n def = π(V(v) n #vx)<label>(16)</label></formula><formula xml:id="formula_39">= π(V(v) n vx) ˙ + ω α(Vv) n = π(Vvx) ˙ + ω α(Vv) n .</formula><p>The definitions (12-16) thus result for a pure Vv in</p><formula xml:id="formula_40">π (Vv#x) n = π (Vv) n vx = π(Vv#x) n .<label>(17)</label></formula><p>2) Rewriting System: We define a set of rewriting rules r − → working on pairs (x, n) of a code x and a number n ∈ N, that together encode an intermediate stage H π(x) (n) in the course of a Hardy computation. Remark 13 (Purity is required). A step x, n r − → y, m is not always correct when x is not pure: e.g. if k = 1, π(01#) = ω + ω ω = ω ω but 01#, n r − → 0 n+1 #, n, which encodes ω n+1 , and</p><formula xml:id="formula_41">H ω ω (n) = H ω n (n) &lt; H ω n+1 (n).</formula><p>It is convenient to work with pure codes in proofs: the oneto-one correspondence between pure codes and ordinals in Ω k yields a one-to-one correspondence between a pair (x, n) and a snapshot of a Hardy computation H π(x) (n), allowing to transfer results from Hardy computations to r − →. More importantly, note that Proposition 12 entails the correctness of r − → even when applied backwards: we capture both forward and backward Hardy computations with the same rewriting system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Robustness of</head><p>r − → So far, our encoding of ordinals in Ω k and the rewriting system r − → can be seen as a (rather convoluted) way of performing forward and backward Hardy computations using sequences of vectors. Their critical interest compared to more basic ordinal encodings is that r − → is robust: if instead of computing with x, n we first decrease the configuration in an uncontrolled way to some y, m with y ≤ * x and m ≤ n, we obtain a configuration that codes a smaller value H π(y) (m) ≤ H π(x) (n). This result is subject to hygienic conditions on x, n and y, m; see Proposition 16 for the exact statement.</p><p>Remark 14 (Non-Robustness of CNF). Let us pause for a moment and consider a natural encoding χ of large ordinals. In this encoding, we use the CNF of the ordinal and separate pure vector sequences with " ˙ +" symbols s.t. <ref type="bibr">Vm)</ref> ; e.g. p = 1 ˙ +0 codes χ(p) = ω ω ˙ +ω for k = 1. However, q = 10 verifies q ≤ * p and codes the much larger ordinal χ(q) = ω ω+1 , with H χ(p) (n) = H ω ω ˙ +ω (n) &lt; H ω ω ·(n−1) ˙ +ω n (n) = H χ(q) (n) when n &gt; 0. By contrast, with cumulative codes, "losing" a tally symbol results in the loss of Proposition 16 (Robustness). Let x, x be pure codes and n &gt; 0. If x is n -trim and x, n ≤ * x , n , then</p><formula xml:id="formula_42">χ(V 1 ˙ + · · · ˙ + V m ) def = ω α(V1) ˙ +· · · ˙ +ω α(</formula><formula xml:id="formula_43">H π(x) (n) ≤ H π(x ) (n ).</formula><p>b) Weak Implementations: The efforts put into defining a robust computation for the Hardy functions pay when one tries to implement them in a "weak" model like PDNs, as we do in Section VII-but this could also be used in other models. By a weak implementation, we mean-as usual in the Petri net literature-an implementation that guarantees 1) completeness: it includes the desired behaviour, and 2) safety: it might also yield "smaller" results. In the case at hand, we provide sufficient conditions (see Definition 18) for two relations </p><formula xml:id="formula_44">1) For any n 0 -trim x 0 , x 0 , n 0 d − → * ε, H π(x0) (n 0 ) and ε, H π(x0) (n 0 ) b − → * x 0 , n 0 . 2) If x 0 is n 0 -trim and x 0 , n 0 d − → * ε, n then n ≤ H π(x0) (n 0 ),</formula><formula xml:id="formula_45">and if ε, m b − → * x, n, then H π(x) (n) ≤ m.</formula><p>Note that these are exactly the two properties required in the main proof of Section V from the PDNs N H <ref type="bibr">[k]</ref> and N H −1 <ref type="bibr">[k]</ref>.</p><p>Here are our sufficient conditions:</p><formula xml:id="formula_46">Definition 18 (Weakenings). A relation d − → on codes is a weakening of r − → if rt − → ⊆ d − → ⊆ ≥ * ; trim − − →; rt − →; ≥ * ; trim − − →. Similarly, a relation b − → is a weakening of r − → −1 if rt − → −1 ⊆ b − → ⊆ ≥ * ; trim − − →; rt − → −1 ; ≥ * ; trim − − →.</formula><p>Proof of Theorem 17: For (1), by Lemma 15, for an n 0 -trim</p><formula xml:id="formula_47">x 0 , x 0 , n 0 r − → * ε, H π(x0) (n) implies x 0 , n 0 rt − → * ε, H π(x0) (n) and ε, H π(x0) (n) ( rt − → −1 ) * x 0 , n 0 since ε is H π(x0) (n)</formula><p>-trim. For (2), we reconstruct step by step pieces of a computation of </p><formula xml:id="formula_48">rt − → or rt − → −1 . For d − →, if x, n is trim and x, n ≥ * x , n trim − − → x , n rt − → y , m ≥ * y , m trim − − → y, m, then H π(x) (n) ≥ H π(x ) (n ) (by Prop. 16) = H π(y ) (m ) (by Prop. 12) ≥ H π(y) (m) ,<label>(</label></formula><formula xml:id="formula_49">H π(y) (m) ≥ H π(y ) (m ) (by Prop. 16) = H π(x ) (n ) (by Prop. 12) ≥ H π(x) (n) , (by Prop. 16)</formula><p>and we proceed again by induction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. PETRI DATA NET IMPLEMENTATION</head><p>We explain in this section how to construct N H and N H −1 , the PDNs that we announced and used in Section V. They transform pairs x, n via a relation What makes PDNs relatively powerful is that they can make weak copies of a counter and even of a sequence, and they can use these weak copies for bounding the number of times a loop is executed ("weak control"). We designed codes and robustness precisely to fit this weak computational power.</p><p>In the rest of this section we explain how codes are represented in a PDN (Section VII-A) and how to perform trimming. Due to lack of space, the definitions and the implementation of The weak implementation of Hardy computations has to maintain a PDN representation of a code/counter pair x, n.</p><p>1) Counter: The counter n is represented via two places cpt and cpt.id. Place cpt.id is an identity place for relevant tokens: the current value of the counter will be the number of tokens in cpt whose identity match cpt.id.</p><p>2) Code: For a code x of length l, distinct identities I 1 &lt; . . . &lt; I l identify each item in x. Every item of the code is identified by a unique identity, and the ordering of identities lets one recover the code. All the identities that have been used for items of the current and past codes are stored in two places, vect and tally, letting one distinguish between vector and # occurrences in x; note that each # occurrence has a different identity. The representation of a vector v identified by some I in a code is done via places c 0 , . . . , c k−1 : v[i] is the number of tokens in c i with identity I.</p><p>Identities evolve during a computation. In order to prevent tokens with now irrelevant identities from disturbing the computation, N H uses two identity places, low and high. We make sure that at any time each of these two places contains a single token, and we just write low or high to denote the identity carried by that single token. Initially, one has cpt.id &lt; low &lt; high and the identities I 1 , . . . , I l for the (current) code are exactly those with low &lt; I &lt; high; other identities are irrelevant for x.</p><p>When simulating an r − → step (and except in simple cases), cpt.id is decreased, high is increased and low is set to the previous value of high. Thus tokens with (now) irrelevant identities will never match the current value of cpt.id nor belong to the open interval (low, high).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Counter Duplication</head><p>In most cases, r − → requires that we iterate some operation at most n times (or n−1, or ...) where n is the current value of the counter. In N H this is systematically done in a modular way by first duplicating the counter and then consuming the tokens of the duplicate, thus controlling the number of iterations.</p><p>For this, N H uses two places, dpt and dpt.id, where it stores duplicates of the tokens in cpt and cpt.id. The net of <ref type="figure" target="#fig_10">Fig. 2</ref> depicts the duplication. <ref type="bibr" target="#b1">2</ref> Transition dp 1 performs the identity updating: cpt.id acquires a smaller identity C &lt; C while dpt.id is updated with the previous identity of cpt.id, namely C. Then transition dp 2 transfers the tokens of cpt (corresponding to the previous identity of the counter D) both to the original counter and to the duplicated counter. Transition <ref type="bibr" target="#b1">2</ref> We rely on the standard graphical depiction of enriched nets and use (pictures of) Petri nets where arcs connected to a transition t are labelled with bags of variables that must be instantiated by ordered identities. The number of these variables is exactly |cons(t)| and the ordering of the corresponding identities is carried by the transition. For concision and readability, it is convenient to allow orderings of the variables that are not total: this stands for all possible linearizations. We also use graphical conventions for better readability: control places containing black tokens are greyed or filled somehow, identity places containing at most one token per identity are represented by simple circles, and the other places, used for counters or general storage, are represented by double circles.  ... <ref type="figure">Fig. 3</ref>. Copying the first vector (case i). dp 3 stops the process, and is slightly modified if we need to put n−1 rather than n in dpt. (In order to avoid a special case for the first duplication, the initial marking has dpt empty and dpt.id with the same identity as cpt.id.) This simple mechanism must be refined for the loops in the trimming process (see below) where the value of n is used to control that every component of a vector in the code is ≤ (some value related to) n. Here one cannot just iterate the previous mechanism: since every duplication possibly decreases n and could violate the property already established for previous components. A more elaborate implementation is required: N H uses a second auxiliary counter ept and ept.id (initialised using dpt and dpt.id) for such multiple controls (as in <ref type="figure">Fig. 3</ref>). In order to avoid a clash of identities for counters, at every initialisation of ept, the new identity of dpt.id, namely D is selected by the guard C &lt; D &lt; D where D and C are the current identities of dpt.id and cpt.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Weak Trimming</head><p>During most weak rule applications, a trimming is performed on-the-fly while the exact rule is simulated, i.e. we actually weakly implement rt − → and its inverse. This trimming consists in implementing ≥ * ; trim − − → during the selection and copy of the rule left-hand side and is simultaneously ensured from the rule right-hand side: it turns a configuration t, n into another one t , n ≤ * t, n which is trim and pure.</p><p>• N H first duplicates the counter cpt, yielding a new value n ≤ n (see <ref type="figure" target="#fig_10">Fig. 2</ref>). Below we assume that this stage is already passed.</p><p>• N H scans (in increasing order) relevant identities (the ones in vect or sharp, between low and high), purifies the code and copies it beyond high as we explain.</p><p>• It purifies, one at a time, sequences separated by #s.</p><p>• When copying a vector sequence, the first vector is copied but also duplicated in auxiliary places d 0 , . . . , </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) Controlling Trimming:</head><p>Let us detail how this is controlled. N H uses three additional identity places: from, to and with. The current item's identity is from, its copy after trimming has the new identity to, and the purification of a vector requires comparisons with the previous vector in the sequence, whose identity is recorded in with, letting one select the appropriate tokens in d 0 , . . . , d k−1 . <ref type="figure" target="#fig_12">Fig. 4</ref> describes the overall control of this process, started by beg.pur, looping, and concluded by end.pur. The body of the loop copies one vector sequence followed by a #. If non empty, the sequence has just one vector, or more, requiring two different treatments. For readability, the labeling of the crucial transitions is specified in the lower part of the picture:</p><p>• At start, beg.pur produces identity tokens in from and to within the appropriate intervals (wrt. low and high), guessing the identity of an item to be copied.</p><p>• When the treatment ends, end.pur updates low and high to their new value.</p><p>• After copying the first vector, efirst guesses a new identity (to be copied) in from and a new (target) identity in to, while recording the current identity in with.</p><p>• After copying a remaining vector, erem guesses fresh identities from and to, and updates the recorded identity in with.</p><p>• csharp copies a # symbol, consuming a token in sharp with identity from and producing a token with identity to (while updating from and to as usual). Observe that a bad guess in from can lead to deadlock but no infinite looping is possible (as required by the proof of Theorem 4).</p><p>2) Copy of a Vector Sequence: a) First Vector: First, in order to guarantee a trim representation, the copy of the first vector non deterministically selects a component i, which is allowed to be less than or equal to n. The rest of the process is depicted in <ref type="figure">Fig. 3</ref>  consists for j &gt; i in:</p><p>• setting the auxiliary counter ept to dpt;</p><p>• "updating" tokens in place c j from identity F to identity n, and at the same time in memorising the transferred tokens in place d j for j &gt; i. With the help of the counter ept, at most n − 1 tokens are transferred. This is performed by transition ts j . We then perform the same transfer for component i, but allow one more token thanks to the firing of transition ts i . No token is transferred for any component j &lt; i. b) Remaining Vectors: For the sake of readability, we do not represent the management of trimming, which is performed as with the first vector, but rather focus on the purity of the vector sequence.</p><p>Let us call v the vector to be copied (identified by variable F), v the last vector that has been copied (identified by W) and v ≤ v the vector to be copied (identified by T). In order for v to be lexicographically smaller than v it must satisfy:</p><p>• either for all i, v (i) ≤ v (i) • or there exists some i s.t. for all j &gt; i, v (i) ≤ v (i) and v (i) ≤ v (i) − 1. Then the simulation non deterministically selects one of these cases. The purity check is thus largely similar to the trimming one: copying is limited by some values, depending on W and cpt.</p><p>Observe that one of the possible results of weak trimming is (exact) trimming of the code, and that the other ones are trimmings of a weaker code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. ON WELL-STRUCTURED LANGUAGES</head><p>Well-structured transition systems can be seen as language acceptors (or generators). For M a class of WSTS models, e.g. M = the Data Nets, let L(M) be the class {L(M ) | M ∈ M} of languages (nondeterministically) accepted by systems in M when their transitions carry labels, possibly ε, over some alphabet, and when the set of "final", or "accepting", states is upward-closed. Geeraerts et al. <ref type="bibr" target="#b17">[17]</ref> shows convincingly that this notion of well-structured languages (WSL), also called coverability languages, is most relevant.</p><p>A series of recent papers (see <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b8">8]</ref> and the references therein) successfully use WSLs as a tool for comparing the descriptive power of varied WSTS models, showing equivalence, e.g. of PDNs and TPNs, or, separating them from the less expressive LCSs (lossy channel systems) or APNs (affine Petri nets <ref type="bibr" target="#b15">[15]</ref>).</p><p>It turns out that the simulation we develop in this paper (and the matching complexity upper bounds) leads to a (relative but) precise characterisation: Let L 0 = {w# n | n = |w|} collect all words (over a two-letter alphabet) equipped with a length witness: L 0 ⊆ (a + b) * # * is deterministic context-free.</p><formula xml:id="formula_50">Theorem 19. 1) L ∈ L(PDN)(= L(TPN) = L(DN)) implies L ∈ k∈N TIME(F ω ω k (n)). 2) L ∈ k∈N TIME(F ω ω k (n)) implies L ∩ L 0 ∈ L(PDN).</formula><p>The proof relies on the possibility of simulating a spacebounded MM. Using the simulations in <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b23">23]</ref> and the upper bounds in <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b22">22]</ref> we derive in a similar way: to nets with at most k places (resp., to channel systems with a k-letter internal message alphabet). These first separation results are not stronger than those of <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b8">8]</ref>, but they provide a standard measure (using Turing, or equivalently Minsky, machines) rather than a myriad of relative ones.</p><formula xml:id="formula_51">Theorem 20. For any L ⊆ L 0 : 1) L ∈ k∈N TIME(F ω k (n)) iff L ∈ L(LCS). 2) L ∈ k∈N TIME(F k (n)) iff L ∈ L(APN).</formula><p>IX. CONCLUDING REMARKS Theorems 3 and 4 close the open question of the complexity of decision problems over the family of "enriched" nets (our terminology), and have immediate consequences, e.g. for separating various WSTS models according to their computational power. Interestingly, we are not aware of any other natural decision problem sitting exactly at level F ω ω ω <ref type="bibr" target="#b16">[16]</ref>, which makes of enriched net problems the canonical examples for this complexity class.</p><p>Our main technical contribution is the robust encoding in (N k * , ≤ * ) of ordinals in Ω k , together with rewrite rules that describe Hardy computations. Enriched nets are not the only computational model in which these rules can be weakly implemented, and one may use them for proving complexity lower bounds in other settings.</p><p>Finally, let us mention two questions raised by this work: 1) Can one improve on Theorem 20? We would prefer an exact characterisation of L(PDN), not relatively to L 0 . 2) What about ν-Petri nets <ref type="bibr" target="#b21">[21]</ref> and unordered PDNs? The underlying wqo is simpler than N k * , hence we expect lower complexities.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>def = (N k \ 0) * and transition relation → def = t∈T t − →, where s t − → s for t ∈ T iff, letting n = |cons(t)|:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Schematics for Theorem 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>PDN for backward Hardy computations. It starts with α 0 = 0 and m 0 = n f (passed on by N M ). Its backward computation may reach</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>We write 1 i for the vector with v[i] = 1 and v[j] = 0 for all j = i. Hence β(0) = 0 and β(1 i ) = ω i . The bijection relates the two linear orderings of small ordinals and of vectors in N k since</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>(</head><label></label><figDesc>Vv) n x, n if x = ε or x = v x with v &lt; lex v (Vv) n vx, n if x = #x or x = v x with v ≤ lex v (R2) Rule (R2) implements the case of limit ordinals and is correct by (17)-the first subcase includes a purification step when π((Vv) n vx) = π((Vv) n x)-while rule (R1) handles successor ordinals: Proposition 12 (Correctness of r − →). x, n r − → y, m and x pure imply H π(x) (n) = H π(y) (m).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>a</head><label></label><figDesc>summand in the corresponding ordinal, which immediately leads to smaller Hardy values. a) Trim Codes: We introduce a restriction on codes that allows to ensure that r − → behaves as expected, especially when performing backward computations: a pure code x is n-trim if, for any vector v occurring in x, there exists 0 ≤ i &lt; k s.t. v[i] ≤ n and for all 0 ≤ j &lt; i, v[j] = 0 and all i &lt; j &lt; k, v[j] ≤ n − 1 (this restricts the ordinal β(v)). A configuration x, n of r − → is trim if x is n-trim, and a computation x 0 , n 0 r − → x 1 , n 1 r − → · · · r − → x m , n m is trim if every configuration x i , n i is trim. Write x , n trim − − → x, n if x ≤ * x and x is n-trim (and thus pure) and call trimming the transformation from x , n to x, n (nondeterministic but always possible, e.g. by decreasing vector values in excess, or removing vectors). In particular, trim − − →⊆≥ * where we let x, n ≤ * x , n def ⇔ x ≤ * x and n ≤ n . Trimness allows us to focus on particular computations of r − →: Lemma 15. If x is n-trim, then there exists a trim computation x, n r − → * ε, H π(x) (n). As our initial code x 0 defined in Example 10 is k-trim, it suffices in the following to consider trim computations, i.e. forward computations in rt − → or backward computations in rt − → −1 , where x, n rt − → y, m def ⇔ x, n r − → y, m and x, n and y, m are trim. (In other words, rt − →= r − → ∩ {x, n | x, n is trim} 2 ). The next proposition states the key monotonicity property of trim computations:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>.</head><label></label><figDesc>The conditions will be easy to check on the actual implementation by PDNs of Section VII, and they entail: Theorem 17 (Weak Implementations). If d</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>by Prop. 16) from which a simple induction yields the result. Similarly for b − →, if y, m is trim and y, m ≥ * y , m trim − − → y , m rt − → −1 x , n ≥ * x , n trim − − → x, n, then</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>−1 ) so that Theorem 17 is a proof of Lemma 5. We have to explain how to represent pairs x, n in a PDN, how to transform them correctly, and to engineer definitions for d − → and b − → that are both simple enough for PDN implementability, but rigorous and complete enough to fulfil the requirements of Definition 18. One can loosely describe d − → and b − → as "trying to perform r − → or r − → −1 on codes, tolerating decreases (wrt ≤ * ) on x and n, all the while trimming x regularly because Definition 18 requires it." The PDNs are highly nondeterministic (unlike r − →) and may deadlock, but this is not a concern.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>can be found in the full version of the paper, but all the main implementation ideas are already present with the trimming process. A. Encoding Configurations of r − → in a PDN</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Duplication of the counter value.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>d k−1 inter- preted as the c i 's. The remaining vectors are also copied and duplicated. Purity is enforced by checking that any (copy of a) vector is lexicographically below the previous vector, as stored in d 0 , . . . , d k−1 . • Finally, both vectors should fulfil the trimming constraint: for some i &lt; k, v[i] ≤ n, and v[j] &lt; n when j &gt; i, and v[j] = 0 when j &lt; i.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Control part of the trimming phase.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>This immediately entails separation results like L(APN) L(LCS) L(PDN)(= L(TPN) = L(DN)) and the non- collapse of hierarchies like {L(k-PDN)} k∈N , {L(k-LCS)} k and {L(k-APN)} k where k-DN, k-APN and k-LCS restrict</figDesc></figure>

			<note place="foot" n="1"> This is not bijective, e.g. for v &lt; lex v , α(v v ) = ω β(v) + ω β(v ) = ω β(v ) = α(v ) = ω β(v ) ˙ + ω β(v) .</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>Work supported by ANR grant 11-BS02-001-01 and by the Leverhulme Trust. The third author is currently visiting the Computer Science Department at Oxford University.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A classification of the expressive power of well-structured transition systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">A</forename><surname>Abdulla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Delzanno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Van Begin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">209</biblScope>
			<biblScope unit="page" from="248" to="279" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Dense-timed Petri nets: Checking Zenoness, token liveness and boundedness</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Abdulla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mahata</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Mayr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Logic. Meth. in Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">On the coverability problem for constrained multiset rewriting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">A</forename><surname>Abdulla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Delzanno</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<pubPlace>AVIS</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Timed Petri nets and BQOs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">A</forename><surname>Abdulla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Nylén</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Petri Nets 2001, ser. LNCS</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001" />
			<biblScope unit="volume">2075</biblScope>
			<biblScope unit="page" from="53" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Algorithmic analysis of programs with well quasiordered domains</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">A</forename><surname>Abdulla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Jonsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-K</forename><surname>Tsay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">160</biblScope>
			<biblScope unit="page" from="109" to="127" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">From timed Petri nets to timed LOTOS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Bolognesi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Lucidi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Trigila</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PSTV&apos;90</title>
		<imprint>
			<publisher>North-Holland</publisher>
			<date type="published" when="1990" />
			<biblScope unit="page" from="395" to="408" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Comparing Petri Data Nets and Timed Petri Nets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bonnet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Finkel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Haddad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Rosa-Velardo</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Research Report LSV-10-23</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lsv</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ens</forename><surname>Cachan</surname></persName>
		</author>
		<ptr target="http://tinyurl.com/82vwcxf" />
		<imprint>
			<date type="published" when="2010-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Ordinal theory for expressiveness of well structured transition systems</title>
	</analytic>
	<monogr>
		<title level="m">FoSSaCS 2011, ser. LNCS</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011" />
			<biblScope unit="volume">6604</biblScope>
			<biblScope unit="page" from="153" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Timed Petri nets and timed automata: On the discriminating power of Zeno sequences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bouyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Haddad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-A</forename><surname>Reynier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">206</biblScope>
			<biblScope unit="page" from="73" to="107" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The ordinal recursive complexity of lossy channel systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Chambart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ph</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schnoebelen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS 2008. IEEE</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="205" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Reset nets between decidability and undecidability</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Dufourd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Finkel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ph</forename><surname>Schnoebelen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP &apos;98, ser</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998" />
			<biblScope unit="volume">1443</biblScope>
			<biblScope unit="page" from="103" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Ordinal complexity of recursive definitions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">V H</forename><surname>Fairtlough</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>Wainer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">99</biblScope>
			<biblScope unit="page" from="123" to="153" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Ackermannian and primitive-recursive bounds with Dickson&apos;s Lemma</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Figueira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Figueira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Schmitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ph</forename><surname>Schnoebelen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS 2011. IEEE</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="269" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Well-structured transition systems everywhere</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Finkel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ph</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schnoebelen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">!&quot; Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">256</biblScope>
			<biblScope unit="page" from="63" to="92" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A wellstructured framework for analysing Petri nets extensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Finkel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mckenzie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Picaronny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">195</biblScope>
			<biblScope unit="page" from="1" to="29" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Some decision problems of enormous complexity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">M</forename><surname>Friedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS 1999. IEEE</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="2" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Wellstructured languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Geeraerts</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-F</forename><surname>Raskin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">V</forename><surname>Begin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="249" to="288" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Verification of timed-arc Petri nets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Jacobsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jacobsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Møller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Srba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOFSEM 2011, ser. LNCS</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011" />
			<biblScope unit="volume">6543</biblScope>
			<biblScope unit="page" from="46" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Nets with tokens which carry data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Lazi´clazi´c</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Newcomb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ouaknine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Roscoe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Worrell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fund. Inform</title>
		<imprint>
			<biblScope unit="volume">88</biblScope>
			<biblScope unit="page" from="251" to="274" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Hierarchies of number theoretic functions, I</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Löb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wainer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Arch. Math. Logic</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="39" to="51" />
			<date type="published" when="1970" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Decidability and complexity of Petri nets with unordered data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Rosa-Velardo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>De Frutos-Escrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">412</biblScope>
			<biblScope unit="page" from="4439" to="4451" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Multiply-recursive bounds with Higman&apos;s Lemma</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Schmitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ph</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schnoebelen</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1103.4399</idno>
	</analytic>
	<monogr>
		<title level="m">ICALP 2011, ser. LNCS</title>
		<meeting><address><addrLine>Available</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011" />
			<biblScope unit="volume">6756</biblScope>
			<biblScope unit="page" from="441" to="452" />
		</imprint>
	</monogr>
	<note>cs.LO</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Revisiting Ackermann-hardness for lossy counter machines and reset Petri nets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ph</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schnoebelen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MFCS 2010, ser. LNCS</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010" />
			<biblScope unit="volume">6281</biblScope>
			<biblScope unit="page" from="616" to="628" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
