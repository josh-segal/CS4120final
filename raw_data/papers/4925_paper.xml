<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="fr">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T17:06+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Construction Locale de Sous-Graphes Couvrants Peu Denses †</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bilel</forename><surname>Derbel</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cyril</forename><surname>Gavoille</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Peleg</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laurent</forename><surname>Viennot</surname></persName>
						</author>
						<title level="a" type="main">Construction Locale de Sous-Graphes Couvrants Peu Denses †</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Algorithmes distribués</term>
					<term>sous-graphe couvrant peu dense</term>
					<term>complexité en temps</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Nous présentons un algorithme distribué déterministe qui calcule pour tout graphe connexe simple non pondéré, un sous-graphe couvrant (spanner) avec O(kn 1+1/k) arêtes et un facteur d&apos;étirement (2k − 1, 0), n étant le nombre de sommets du graphe et k un paramètre entier strictement positif. Si n est inconnu l&apos;algorithme termine en temps 3k − 2, sinon il termine en temps k. En se basant sur cet algorithme pour k = 2, nous construisons de façon déterministe un sous-graphe couvrant avec O(ε −2 n 3/2) arêtes et un facteur d&apos;étirement (1 + ε, 2) en O(ε −1) temps, ε &gt; 0 est un paramètre arbitrairement petit. Nous complétons nos algorithmes par des bornes inférieures. D&apos;abord, nous montrons que k unités de temps sont nécessaires pour calculer un sous-graphe couvrant avec o(n 1+1/(k−1)) arêtes et un facteur d&apos;étirement (2k − 1, 0) pour k ∈ {2, 3, 5}. Ensuite, nous montrons que pour tout k &gt; 1, si un algorithme distribué construit un sous-graphe couvrant H ayant moins de n 1+1/k+ε arêtes en temps t n ε , alors H a un facteur d&apos;étirement au moins (1 + Ω(k/t), Ω(kn ε)). Nos bornes sont valables aussi bien pour des algorithmes déterministes que probabilistes, avec ou sans la connaissance de n.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="fr">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Dans ce papier nous nous intéressons à la construction distribuée de structures efficaces de graphes, appelées spanners. Les spanners permettent de couvrir les sommets d'un graphe en utilisant peu d'arêtes tout en préservant les distances. Plus formellement, étant donné un graphe G = (V (G), E(G)) qui modélise un réseau d'interconnexion, un sous-graphe H de G tel que V (H) = V (G) est un (α, β)-spanner si pour tout couple de sommets u et v, d H (u, v) α · d G (u, v) + β, (avec d X (u, v) désignant la distance dans X entre u et v). Le facteur d'étirement du spanner H est définit par le couple (α, β) et sa taille par |E(H)| (le nombre d'arêtes utilisées par le spanner). En pratique, les spanners sont utilisés de façon explicite ou implicite comme structure de base dans plusieurs applications distribuées tels que, les synchroniseurs <ref type="bibr" target="#b1">[2]</ref>, le routage compact <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b10">11]</ref>, les forêts couvrantes <ref type="bibr" target="#b2">[3]</ref>, etc.</p><p>Étant donné un graphe G avec n sommets et un paramètre entier positif k 1, il est bien connu que G admet un (2k − 1, 0)-spanner de taille O(n 1+1/k ). Ce compromis entre la taille et le facteur d'étirement est considéré comme étant optimal d'après une conjecture d'Erdös <ref type="bibr" target="#b8">[9]</ref> prouvée pour k ∈ {1, 2, 3, 5}.</p><p>Dans ce papier, nous considérons la complexité en temps de la construction de spanners optimaux avec des algorithmes distribués, c'est à dire dans un modèle de calcul où les sommets sont des entités autonomes de calcul pouvant communiquer en envoyant et en recevant des messages. Le meilleur algorithme distribué déterministe existant <ref type="bibr" target="#b5">[6]</ref> permet de construire des (4k − 3, 0)-spanner avec O(k · n 1+1/k ) arêtes en temps 2 O(k) log k−1 n. Le meilleur algorithme probabiliste <ref type="bibr" target="#b4">[5]</ref> permet de construire un (2k − 1, 0)-spanner avec O(k · n 1+1/k ) arêtes en temps k. Cependant, ce dernier algorithme est de type Monte-Carlo, c'est à dire que les propriétés du spanner ne sont garanties qu'avec une certaine probabilité. Ceci peut être problématique dans le cadre d'applications qui exigent des bornes sûres concernant les propriétés d'un spanner. D'un point de vue plus fondamental, là où les algorithmes probabilistes permettent de calculer plusieurs structures de façon rapide, les algorithmes déterministes se voient ralentis considérablement notamment à cause des difficultés inhérentes aux problèmes de symétrie. Casser la symétrie par des algorithmes déterministes est l'un des défis majeurs des calculs distribués. Notre premier résultat est un algorithme distribué extrême-ment simple permettant de calculer de façon déterministe un (2k − 1, 0)-spanner de taille O(k · n 1+1/k ) en temps exactement k (n étant connu). Notre algorithme possède en plus une propriété particulièrement intéressante : il ne nécessite pas la connaissance de n. Ceci n'est pas le cas des algorithmes (probabilistes ou déterministes) existants qui eux doivent connaître au moins une bonne approximation de n. Ceci rend notre algorithme particulièrement adéquat dans le cadre d'applications pratiques par exemple, dans des applications où le graphe est dynamique c'est à dire où des sommets peuvent apparaître et/ou disparaître.</p><p>Par ailleurs, nous nous intéressons à un autre type de spanners dits additifs, c'est à dire des spanners où le facteur d'étirement est de la forme (1, β). Seulement quelques spanners de ce type sont connus. Plus précisément, il existe un</p><formula xml:id="formula_0">(1, 2)-spanner avec O(n 3/2 ) arêtes [8] et un (1, 6)-spanner avec O(n 4/3 ) arêtes [4].</formula><p>Cependant des constructions qui essayent de donner une approximation de spanners additifs existent. Les algorithmes distribués les plus rapides <ref type="bibr" target="#b5">[6]</ref> permettent de construire un spanner de taille O(n 3/2 ) avec un facteur d'étirement (1 + ε, 4) en temps n o(1) + O(ε −1 ) (ou O(log n + ε −1 ) temps en moyenne) ou avec un facteur d'étirement (1 + ε, 8 log n) en temps O(log n · ε −1 ). Notre deuxième résultat est un algorithme distribué déterministe qui construit un (1 + ε, 2)-spanner de taille O(ε −2 n 3/2 ) en temps O(ε −1 ). Là aussi, la connaissance de n n'est pas requise.</p><p>Les algorithmes distribués que nous présentons sont complètement nouveaux dans le sens où ils ne sont pas une adaptation des techniques séquentielles ou distribués existantes (y compris celles probabilistes).</p><p>Finalement, nous complétons nos deux résultats par deux bornes inférieures. Notre première borne montre que tout algorithme distribué (potentiellement probabiliste) nécessite au moins k temps pour calculer un (2k − 1, 0)-spanner de taille o(n 1+1/(k−1) ) pour k ∈ {2, 3, 5}. En se basant sur la conjecture evoquée plus haut, le résultat reste vrai pour tout k &gt; 1. Notre deuxième borne inférieure montre que pour tout k &gt; 1, il existe un ε &gt; 0 tel que pour tout algorithme distribué construisant un spanner H pour G de taille inférieure à n 1+1/k+ε en temps n ε , il existe au moins deux sommets du graphe tel que d H (u, v) d G (u, v) + n Ω(ε) . Ce résultat est en fait un corollaire d'un résultat plus technique qu'on donnera plus loin.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Les bornes supérieures</head><p>Nous considérons des graphes simples non pondérés. Nous considérons le modèle de calcul classique de Linial <ref type="bibr" target="#b9">[10]</ref>. Les sommets possèdent des identifiants uniques et ils effectuent des calculs de façon synchrone. Chaque unité de temps, un sommet peut envoyer ou recevoir des messages de taille non limitée, et effectuer n'importe quel calcul local. La complexité en temps est ainsi définie comme étant le nombre total d'unités de temps depuis le début de l'algorithme jusqu'à sa terminaison. On note cependant que puisque on ne s'intéresse qu'au temps de calcul et non au nombre de messages échangés, un algorithme synchrone peut être adapté à un modèle asynchrone tout en gardant la même complexité en temps.</p><p>Pour tout sommet u d'un graphe G, et pour tout entier positif r, nous définissons B G (u, r) le sous-graphe de G induit par les sommets à distance au plus r de u dans G. Nous omettrons de préciser G dans notre notation quand il n'y a pas d'ambiguïté.  L'idée générale de l'algorithme SPAN 2,t exécuté par un sommet u est de rajouter des plus courts chemins entre u et certains sommets du voisinage à distance O(t) de u. Ainsi, lorsqu'une longue distance est à approximer, on n'est pas obligé de payer un étirement 3 pour chaque arête. Au contraire, on essaye de faire des sauts en utilisant les plus courts chemins que l'on a calculé. En remarquant que les régions des sommets enlevés par la boucle sont disjointes et de taille supérieure à σ, on peut alors montrer le théorème suivant :</p><p>Théorème 2 Pour tout ε ∈ (0, 4], il existe un algorithme distribué et déterministe tel que pour tout graphe connexe à n sommets (n n'est pas connu des sommets) calcule un (1 + ε, 2)-spanner avec O(ε −2 n 3/2 ) arêtes en temps O(ε −1 ).</p><p>Les preuves de nos bornes inférieures sont techniques et trop longues pour être exposées en détail. Nous allons donc nous contenter de les énoncer et de donner la technique générale que nous avons utilisée.</p><p>Un algorithme distribué éventuellement probabiliste opère toujours en cycles se composant d'une étape de communication suivie d'un calcul local. La technique que nous utilisons se base sur l'observation suivante. À un temps τ , un sommet u ne peut connaître que les identifiants des sommets à distance τ et les τ − d G (u, v) + 1 premiers choix aléatoires effectués par un sommet v. On peut ainsi définir la vue d'un sommet u, c'est à dire toute l'information que u peut avoir à sa disposition au bout d'un certain temps τ. Ceci nous permet de définir l'état d'un sommet comme étant une fonction de sa vue. Ainsi, deux sommets ayant la même vue auront forcément le même état indépendamment du graphe auquel ils appartiennent.</p><p>La preuve de la première borne consiste à trouver deux familles de graphe pour lesquelles on peut trouver deux sommets ayant la même vue au bout d'un temps τ donné. Mais, où un algorithme correct doit attribuer deux états différents à ces deux sommets. Typiquement, pour le problème des spanners, un sommet doit décider de n'enlever aucune arête, alors que l'autre doit en enlever au moins une. Ceci permet donc de prouver qu'un temps τ ne suffit pas pour résoudre le problème correctement.</p><p>La preuve de la deuxième borne est techniquement différente. Elle consiste à construire un graphe pour lequel on peut dire précisément, en s'appuyant sur les vues de certains sommets, quelles sont les arêtes qui doivent être enlevées du graphe pour garantir la taille désirée. Ensuite, il s'agit de donner un chemin qui passe par ces arêtes et pour lequel la distance dans le spanner est forcément plus grande qu'une valeur qu'on sait calculer très précisément. Ceci nous permet d'obtenir une borne sur le facteur d'étirement.</p><p>Les deux preuves s'appuient sur l'existence de graphes biparties dont la longueur du plus petit cycle est 2k + 2 et ayant c · n 1+Ψ(1/k) arêtes, avec c une constante, Ψ(k) = k si k ∈ {1, 2, 3, 5}, et Ψ(k) = 3k/2 sinon. De plus, si la conjecture d'Erdos <ref type="bibr" target="#b8">[9]</ref> est vraie alors Ψ(k) = k pour tout k. Théorème 3 Soit n, k des entiers vérifiant 1 &lt; k log n. Soit un algorithme distribué A qui calcule pour tout graphe à n sommets un spanner de taille plus petite que c · n 1+1/Ψ(k−1) et un facteur d'étirement Ψ(k). Alors, l'algorithme A a une complexité en temps au moins k.</p><p>Théorème 4 Soit k, ε tel que 1 &lt; k log n, et 1/ε &gt; 3k 2 − k. Soit un algorithme distribué A qui calcule pour tout graphe à n sommets un spanner de taille plus petite que λ·n 1+1/Ψ(k) en temps t, pour k −3 t n ε et λ n ε . Alors, il existe un graphe G et deux sommets u, v à distance d G (u, v) = Ω(tn ε ) tel que dans le spanner H calculé par l'algorithme A, on a :</p><formula xml:id="formula_1">d H (u, v) &gt; 1 + k − 1 t + 1 · d G (u, v) + 2k − 3 .</formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>2. 1</head><label>1</label><figDesc>Algorithme SPAN k : facteur d'étirement (2k − 1, 0) L'algorithme SPAN k est décrit de façon formelle dans la figure 1. L'idée générale de l'algorithme est la suivante. Tout sommet u maintient une région R(u) qui grossit à chaque itération. La valeur courante de la région de u est C et l'ensemble des voisins non encore couverts est W . À chaque itération certains voisins dans W migrent vers l'ensemble L qui désigne l'ensemble des voisins de u dans le spanner. En effet, en analysant les régions R(w) de ses voisins, le sommet u peut déterminer s'il existe un chemin dans le spanner (en cours de construction) qui mène vers un sommet de W . Si c'est le cas, ce sommet est enlevé de Construction Locale de Sous-Graphes Couvrants Peu Denses L := C := R(u) := {u}, W := B(u, 1), σ := |B(u, 2k − 1)| 1/k pour i := 1 à k faire Le sommet u envoie R(u) à ses voisins, et il reçoit R(w) de ses voisins w tant que ∃w ∈ W tel que R(u) ∩ R(w) = ∅ faire W := W \ {w} tant que ∃w ∈ W et |L| &lt; iσ faire W := W \ {v ∈ W | R(v) ∩ R(w) = ∅} L := L ∪ {w} C := C ∪ R(w) R(u) := C Algorithme 1: Algorithme SPAN k (u) pour un sommet u. L'ensemble L calculé par u contient les voisins de u dans le spanner. W . Sinon, il migre dans L. Bien entendu, l'algorithme fait attention à ne pas rajouter beaucoup de sommets dans l'ensemble L ce qui permet de garantir un spanner avec la taille requise. En montrant par récurrence qu'à la fin d'une itération donnée i de l'algorithme SPAN k , l'une des deux propriétés suivantes est vraie : |R(u)| |B(u, 2k −i)| i/k ou R(v)∩R(u) = ∅ pour tout v ∈ B(u, 1), on obtient : Théorème 1 L'algorithme SPAN k est un algorithme distribué et déterministe qui calcule pour tout graphe connexe à n sommets un (2k − 1, 0)-spanner avec au plus kn 1+1/k arêtes en temps k. Si n n'est pas connu, alors le temps de calcul est 3k − 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>2. 2</head><label>2</label><figDesc>Algorithme SPAN 2,t : facteur d'étirement (1 + ε, 2) L'algorithme SPAN 2,t ci-dessous est une extension de l'algorithme précédent dans le cas k = 2. R(u) := {u}, r := t/2, σ := |B(u, 2r + 1)| 1/2 Le sommet u envoie R(u) à ses voisins, et reçoit R(w) de ses voisins w Le sommet u choisit min {deg(u), σ − 1} voisins et les rajoute à l'ensemble R(u) H u := (R(u), S w∈R(u)\{u} {u, w}) si R(u) = B(u, 1) alors F u := vrai sinon F u := faux Le sommet u envoie (R(u), F u ) aux sommets de B(u, r) et reçoit (R(w), F w ) des sommets w ∈ B(u, r) pour := 1 à r faire W := {w ∈ B(u, ) | F w is false} tant que ∃w ∈ W faire W := W \ {v | R(v) ∩ R(w) = ∅} Ajouter à H u un plus court chemin dans G reliant u et w Algorithme 2: Algorithme SPAN 2,t (u) pour un sommet u et pour t = 1 + 4/ε où ε ∈ (0, 4] est un paramètre. Le spanner global est l'union des sous-graphes H u calculés par chaque sommet u.</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On space-stretch trade-offs: Upper bounds</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Abraham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gavoille</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Malkhi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">18 th Annual ACM Symposium on Parallel Algorithms and Architectures (SPAA)</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006-07" />
			<biblScope unit="page" from="207" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Complexity of network synchronization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Awerbuch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="804" to="823" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Fast distributed network decompositions and covers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Awerbuch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">J</forename><surname>Cowen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Peleg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Parallel and Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="105" to="114" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">New constructions of (α, β)-spanners and purely additive spanners</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Baswana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kavitha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mehlhorn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pettie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16 th Symp. on Dis. Algorithms (SODA)</title>
		<imprint>
			<publisher>ACM-SIAM</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="672" to="681" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">A simple and linear time randomized algorithm for computing sparse spanners in weighted graphs. Random Structures and Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Baswana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007-07" />
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="532" to="563" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Deterministic distributed construction of linear stretch spanners in polylogarithmic time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Derbel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gavoille</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Peleg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">21 st Symp. on Dist. Comp. (DISC)</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="179" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">On the locality of distributed sparse spanner construction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Derbel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gavoille</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Peleg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Viennot</surname></persName>
		</author>
		<idno>RR-1441-08</idno>
		<imprint>
			<date type="published" when="2008-02" />
			<pubPlace>LaBRI</pubPlace>
		</imprint>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">+ ε, β)-spanner constructions for general graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Elkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Peleg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. on Comp</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="608" to="631" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Compactness results in extremal graph theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Erdös</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Simonovits</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Combi</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="275" to="288" />
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Locality in distributed graphs algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="193" to="201" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A trade-off between space and efficiency for routing tables</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Peleg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Upfal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="510" to="530" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
