<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T17:01+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Consistency Maintenance Based on the Mark &amp; Retrace Technique in Groupware Systems *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ning</forename><surname>Gu</surname></persName>
							<email>ninggu@fudan.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing and Information Technology</orgName>
								<orgName type="institution">Fudan University No</orgName>
								<address>
									<addrLine>220 Handan Road</addrLine>
									<postCode>200433</postCode>
									<settlement>Shanghai</settlement>
									<country key="CN">P.R.China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiangming</forename><surname>Yang</surname></persName>
							<email>yangjiangming@fudan.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing and Information Technology</orgName>
								<orgName type="institution">Fudan University No</orgName>
								<address>
									<addrLine>220 Handan Road</addrLine>
									<postCode>200433</postCode>
									<settlement>Shanghai</settlement>
									<country key="CN">P.R.China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qiwei</forename><surname>Zhang</surname></persName>
							<email>qiweizhang@fudan.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing and Information Technology</orgName>
								<orgName type="institution">Fudan University No</orgName>
								<address>
									<addrLine>220 Handan Road</addrLine>
									<postCode>200433</postCode>
									<settlement>Shanghai</settlement>
									<country key="CN">P.R.China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Consistency Maintenance Based on the Mark &amp; Retrace Technique in Groupware Systems *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. GROUP&apos;05, November 6-9, 2005, Sanibel Island, Florida, USA.-2/05/0011 ...$5.00.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C24 [Computer-Communication Networks]: Distribu- ted Systems-Distributed applications; H53 [Information Interfaces and Presentation]: Group and Organization Interfaces-Collaborative computing</term>
					<term>Synchronous interac- tion General Terms Algorithms</term>
					<term>Design</term>
					<term>Human Factors Keywords CSCW</term>
					<term>Concurrency Control</term>
					<term>Consistency</term>
					<term>Group editors</term>
					<term>Undo</term>
					<term>Address Space Transformation</term>
					<term>Mark &amp; Retrace</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Replicated architecture is widely used for concealing network delay. However, consistency maintenance in fully repli-cated architecture is a major technical challenge. In this paper , we report a Mark &amp; Retrace based method in replicated groupware systems. Compared with the Operation Transformation technique, it does not adjust the operation&apos;s position but retraces the document&apos;s address space to the state at the time of the operation&apos;s generation. Then the operation can be executed directly in this address space. Mark &amp; Retrace method can not only achieve the same goal of consistency maintenance but also provide a better support for Undo. This paper provides the proof of the algorithm&apos;s correctness of consistency maintenance, in which both the orders of character nodes and marks of each node at all sites are kept consistent. Furthermore, the amortized efficiency can reach O(logn).</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Group editors are one of the most commonly used groupware applications <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b15">15]</ref>. It allows multiple users to participate in the editing and modification of shared data objects, such as word, graphics, and media documents, using a computer network. Techniques for building group editors have been widely applied and practiced <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b12">12]</ref>. Group editors have also been acknowledged as powerful research vehicles in exploring solution to consistency problems <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b6">6,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b19">19]</ref>.</p><p>To hide the effects of network delay and give better local response to users, a replicated architecture has been widely adopted <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b6">6,</ref><ref type="bibr" target="#b15">15]</ref>. In a replicated architecture, a local user's operations are executed immediately to achieve good responsiveness and are then multicast to remote replicas to keep the document states consistent. Compared with conventional techniques such as locking and serialization, it has no adverse effects on the user interface while the replicated document states are maintained in consistent states which observe the CCI model <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b15">15]</ref>.</p><p>OT is a consistency maintenance technique. In the OT method, due to the existence of concurrent operations, a remote operation should include or exclude some operations' effects <ref type="bibr" target="#b14">[14,</ref><ref type="bibr" target="#b15">15]</ref> and find the correct operation position or area at the local site. To maintain the CCI model, in the past decade, OT method has been gradually improved (include extensions of control algorithms <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b17">17]</ref> and OT functions <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b9">9]</ref> ). In this process, we have realized that an OT algorithm which completely maintains the CCI model will be very intricate.</p><p>Mark &amp; Retrace is a new method, which is different and independent of the OT technique. It retraces the document's address space to the state at the time of the operation's generation. In this state, we can directly find the execution position for the operation. This process does not affect the order of characters in current document. It only needs to determine the position of a new operation. It can maintain the CCI model in replicated architecture and is easier to support group Undo <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b20">20]</ref>. This paper is organized as follows. First, the concept of the address space transformation is introduced in Section 1. Then, the Mark &amp; Retrace method is described. The correctness and efficiency of the technique and how it supports Undo operation are discussed in Sections 3, 4 and 5, respectively. In Section 6, the Mark &amp; Retrace method is compared with related works. Finally, we conclude this paper and point out future directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">ADDRESS SPACE TRANSFORMATION</head><p>State vector based timestamping <ref type="bibr" target="#b1">[2]</ref> has been widely used to detect causal relationships among operations. In the timestamping scheme, every site maintains its own state vector. After an operation is generated, it is attached with the generating site's current state vector, and is then multicast to all other sites.</p><p>Then, we discuss the operation's expression. Without loss of generality, each character is indivisible and each operation targets only one character. In fact, any complex Insert or Delete can be divided into a group of indivisible operations. So this assumption does not affect operation's capability. Since an operation targets only one character, a Delete can only be represented by a position P . A Delete is timestamped by SVO del , which indicates that the site's state vector is SVO del when the operation was generated and its intension is to delete the P th effective character counting from the left. And an Insert can be represented by an Inserted content C and an Inserting position P . An Insert timestamped by SVO ins denotes that the site's state vector is SVO ins when the operation was generated and its intention is to Insert the content C between the P th and P +1th effective characters counting from the left. (There also exist two special Inserting positions: the left of the most left effective character and the right of the most right character). A remote operation cannot be directly executed at the local site due to the effect of concurrent operations on the local document state, which may result in an offset in the execution position of the remote operation. Consider a system consisting of three users and a shared empty document state. The order of operations' generation and execution is shown in <ref type="figure" target="#fig_0">Fig.1</ref>. Here we only need to focus on operation O4 and O5, but this example is also relevant to later <ref type="figure">Fig.3</ref> and 4. Operation O5 is to insert "c" at position 3 between "b" and "d". Consider what happens when user U1 attempts to execute the operation O5 -inserting the character "c" at position 3. Since the character "b" was deleted by O4, position 3 now refers to the position on the right of "d" rather than the intended position of the left of "d". To resolve this problem, the OT technique transforms the operation's target position. It adjusts the target position of an operation by taking into account of all the effects of concurrent operations. In <ref type="figure" target="#fig_0">Fig.1</ref>, due to the existence of concurrent operation O4, O5 shall be transformed to Insert ["c", 2] before execution.</p><p>The AST (Address Space Transformation) is a different technique to OT -the operation's intention is achieved by transforming the address space, rather than the operation itself. The basic idea of AST is as follows. If it is known that user U1 cannot execute O5 directly because the address space of the document has been changed, address "3" represents the right of character "d" which is different from the one at the time of O5's generation. To execute operation O5, we shall retrace the document's address space to the state at the time of O5's generation, which is shown in <ref type="figure" target="#fig_1">Fig.2</ref>. In this way, O5 can be executed directly in this new address space, that is address "3" represents the position between "a" and "d". To support the transformation of the document's address space, a marking technique is used. A mark indicates if a character node effective or ineffective at a given time. We shall describe the Mark &amp; Retrace method and how it may be used to achieve consistency in the next section. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">ACHIEVING CONSISTENCY</head><p>To achieve causality preservation in the timestamping scheme, we only need to ensure that every remote operation is causallyready before its execution, which we call execution condition <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b15">15]</ref>. It should be noted that even if causality is preserved, the execution order of the operations would still be different because of their different orders of arrival at different sites. In the following, we shall focus on the issues of how we can execute an operation correctly to achieve convergence and intention preservation, under the assumption that causality is preserved. In follow discussion we use the same definition of casual ordering relation "→" and independent relation "񮽙" in <ref type="bibr" target="#b15">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Structure of Mark &amp; Retrace</head><p>The difficulty in achieving convergence and intention preservation is that the relationships that exist among independent operations can result in changes to the operations' positions and area. The OT technique searches the operations that may cause these changes and derives their effects first. Then it adjusts the operation current position accordingly <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b6">6,</ref><ref type="bibr" target="#b15">15]</ref>. Mark &amp; Retrace method tries to conceal such effects in the document. It marks and conceals the execution effects of some operations, which allows the document to be converted to the document to the address space at the time of an operation's generation. In this way we can directly find an accurate position and then achieve the execution effects of the operation. The advantage of this method is that we do not have to think of the complex relations among operations. We only need to pay attention to each operation's effect on user's view.</p><p>Assume a document is a liner structure composed of characters. Each character may have several operations targeting itself while each operation targets only one character. Then we save the operation together with its timestamp to the character's liner node. So apart from the information of characters and corresponding operations, we also add the effective/ineffective mark information to every node in the liner structure. The mark indicates whether the current node is observable on the user interface or not. So a document structure might be expressed as <ref type="figure">Fig.3</ref>. In Mark &amp; Retrace method, the address space can be expressed as the effective character nodes from left to right.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Effective Ineffective</head><p>Insert(񮽙a񮽙, 1) &lt;1, 0, 0&gt;</p><formula xml:id="formula_0">Insert(񮽙b񮽙, 1) &lt;0, 1, 0&gt; Insert(񮽙c񮽙, 3) &lt;1, 1, 2&gt; Insert(񮽙d񮽙, 1) &lt;0, 0, 1&gt; Delete(񮽙b񮽙, 2) &lt;2, 1, 1&gt;</formula><p>Effective Effective </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Retracing Procedure</head><p>Given the liner structure of document at site S, DocS , and the state vector at site S, SVS. Suppose SV is a timestamp which meets the execution condition. Then the Retracing procedure can be expressed as Proc.1:</p><p>The goal of the Retracing procedure is to retrace the address space to the state at a given timestamp SV . It reviews every character node and determines their "effective/ineffective" marks in the timestamp SV . Its execution is only to preserve the effects of operations which are causally before generation. For every character node, suppose that the Insert and Delete attached are timestamped by SVO ins and SVO del . We should consider the following four situations. <ref type="formula">(1)</ref>  set CNi ineffective 10:</p><p>end if 11: end for there will not exist the situation where SVO ins ≥ SV while SVO del ≤ SV . On the other hand, when several concurrent Delete operations target one character, there may be several Delete operations attached on one node. When one of them satisfies SVO del ≤ SV , this node must be marked ineffective. We can see that inside a node, the effects of operations independent or causally after timestamp SV have not been considered. As to the result of Retracing, an "effective/ineffective" mark of one character node is determinate as long as timestamp SV is fixed.</p><p>There are two examples. Given an operation O which is timestamped by SV and is causally-ready for execution. For any operation O 񮽙 and O 񮽙 → O, O 񮽙 is sure to have been executed. The result of Retracing (DocS, SV ) is that it can conceal all the effects of operations which are independent of operation O and retrace the address space to the time SV at the time of its generation. In other words, it can achieve an address space of liner structure, whose effective character nodes are completely consistent with the site' liner structure at the time of operation O's generation. This consistency has two meanings. One is that they both have the same set of effective character nodes. The other is that all the ineffective character nodes at the current site are either ineffective or nonexistent at the operation's generation site and at the time of the operation's generation. Another example. When current state vector of the site S is SV , the result of Retracing(DocS , SV )is that it can restore the address space to the state that is used by the local user. If SV represents the state vector when a new operation has just been executed at the site S, the effect of the new operation has already been involved. All the timestamps of operations which have been executed before the new one are all before SV . And the adjustment of SV after new operation's execution also makes new operation's timestamp before SV . So all the effects of executed operations have been retained and the new operation's effect also has been applied.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The Control Algorithm</head><p>When a remote operation O generates at site R and timestamped by SVO is causally-ready for execution, we can express the execution process of O at site S whose state vector is SVS in Proc.2.</p><p>The definition of operation position is obtained by counting the number of effective character nodes on the left side of linear structure at the time of its generation. When the </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>: SVS[R] ⇐ SVS[R] + 1 5: Retracing(DocS , SVS)</head><p>order of any two character nodes is certain, Retracing(DocS , SVO) ensures that the address space (effective character nodes) of the current document's liner structure is the same as the one at the time of the operation's generation. So control algorithms ensure that we can count to the correct effective character node when executing an operation. And by adjusting SVS, Retracing(DocS , SVS) can restore the address space to the state which has included the new operation's execution effect. See also <ref type="figure" target="#fig_12">Fig.4</ref>. When user U1 intends to execute operation Insert["c", 3] with timestamp &lt;1,1,2&gt;, the document state is shown in top-left. First, the control algorithm retraces the document to the view "abd"(top-right) at the time of timestamp &lt;1,1,2&gt; by concealing the effect of operation Delete["b", 2], then inserts "c" between "b" and "d". The State Vector of the local site has been adjusted to &lt;2,1,2&gt; after the execution is finished. And then it retraces to the view "acd"(bottom-left) of new State Vector by restoring the effect of operation Delete["b", 2] and adding the execution effect of the new operation Insert["c", 3].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Operation Execution</head><p>The focus of this section is on how an operation O is executed:</p><p>If O denotes a Delete operation, just find the characters in the address space (count the effective character nodes in the liner structure of DocS) to find the position.</p><p>If O denotes an Insert operation, find the position in the address space (count the effective character nodes in the liner structure of DocS to find the range between two adjoining effective character nodes), build a new character node, initialize the mark and Insert it to an accurate position within the range. Since Retrace(DocS , SVO) transforms the address space to the state at the time of the operation's generation, the Delete operation's execution is simple. The process is to find the corresponding character node, attach the operation on the character node and then perform the Retracing procedure to give this node a correct effective/ineffective mark. But the Insert is to search for an Inserting position in the address space, which is corresponding to a range in document between two effective character nodes. There may exist some other ineffective character nodes in this range. We need a Range-Scan process to determine the right-and-left relation between the new Insert and these ineffective character nodes and then find an accurate position. A T Order function, which realizes a total order relation among Insert operations, has been involved in the follow to realize this Range-Scan process. Since the Delete only revises the mark information and has no effect on the order of character nodes, the focus of following discussion is on Insert operations.</p><p>To realize the comparability between two Insert operations, we refer to the technique of maintaining operation transformation order <ref type="bibr" target="#b15">[15]</ref>. Given the T Order relation to represent the right-and-left relation between two inserted characters. Given two character nodes CNa and CN b . The attached operations are generated at site a and site b, and are timestamped by <ref type="bibr">SVa and SV</ref> </p><formula xml:id="formula_1">b . We have T Order(CNa) &lt; T Order(CN b ), iff: (1) sum(SVa) &lt; sum(SV b ), or (2) a &lt; b when sum(SVa) = sum(SV b ), where sum(SV ) = È N−1 i=0 SV [i].</formula><p>The T Order relation is a total order which is transitive and any two T Order are comparable.</p><p>The process to determine an accurate position of a new operation O is to scan every Insert in this range from left to right. There are two kinds of Insert operations in this range. Some of these operations are casually before operation O. We force the new Insert O to insert on the left side of these Insert operations, so when Range-Scan scans to these operations, it will directly end itself (Range-Scan Function, line 12-17). The other Insert operations are concurrent with operation O. We compare them by comparing the T Order relation (Range-Scan Function, line 4-11). The inserting position is saved in the P . The new operation will be inserted on the left side of P . We can sketch the scanning process as Func.3. Retracing process locates the Insert into a one-and-only range. Range-Scan process determines a one-and-only position for this Insert in the range and keeps it from being affected by concurrent operations. Then we explain how algorithm maintains the convergence and intention preservation in detail in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Achieve Convergence and Intention Preservation</head><p>Suppose that originally, every site has the same initial document state and that all the character node orders at every site are the same. Given n operations to be executed, we shall discuss how to ensure that all the sites still have the same character nodes orders after the operations' execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.1">Two operations</head><p>Consider the situation where there are two operations O1 and O2. If they are casually ordered, since the execution order is certain, the result will be certain too. If they are concurrent, we prove the following theorem.</p><p>Theorem 1. If O1 and O2 are concurrent and inserted to a same scan-range (i.e. the range between two effective characters CNa and CN b in the Range-Scan process), the execution effects of two operations have no relation with their execution order.</p><p>Proof. When O1 and O2 are executed respectively in this range, there are only three possible cases:</p><p>1. O1, O2 ends with the same return position.</p><p>2. O1 ends with the return position on the left of O2's.</p><p>3. O1 ends with the return position on the right of O2's.</p><p>We would like to prove that in the three cases above, if we execute one operation after another (i.e. O1 before O2 or O2 before O1), the results are the same no matter in what sequence they are executed. With out loss of generality, assume T Order(O1) &gt; T Order(O2).</p><p>To simplify description, given the following notations in <ref type="figure">Fig.5,6</ref>.  Then in the situation in <ref type="figure">Fig.7</ref>, if O1 is executed before O2, the result is <ref type="figure">Fig.8</ref>.</p><p>If O2 is executed before O1, the same result can be obtained due to the certain T Order relationship between O1 and O2. In this case, the possible situations before the execution can only be <ref type="figure">Fig.9</ref>. Then in the situation in <ref type="figure">Fig.9</ref>, if O1 is executed before O2, the result is shown in <ref type="figure" target="#fig_0">Fig.10</ref>-a. O1 ends with the return position OT L2 . During the Range-Scan process of O2, when it scans to O1, it will record O1 into P and go on scanning to OT L2 . Since OT L2 's T Order is less than O2's and OT L2 is causally before O1 which is saved in P , so P will be reset to Nill. And then the process ends with the return position OT any or OT G2 or OT any . If O2 is executed before O1, the result is shown in <ref type="figure" target="#fig_0">Fig.10-b</ref>. O2 passes through OT L2 and ends with the return position OT any or OT G2 or OT any , and O1 ends with the return position OT L2 as before. We can see that the two results in <ref type="figure" target="#fig_0">Fig.10-a and Fig.10-b</ref> are the same.</p><p>Case 3: O1 ends with the return position on the right of O2's when they are executed respectively.</p><p>In this case, the possible situations before the execution can only be <ref type="figure" target="#fig_0">Fig.11</ref>.</p><p>Then in the situation in <ref type="figure" target="#fig_0">Fig.11</ref>, if O1 is executed before O2, the result is shown in <ref type="figure" target="#fig_0">Fig.12</ref>. Because O1 is concurrent with OT L1 and OT L1G2 , and the T Order of O1 is more than that of OT L1 and OT L1G2 , O1 will pass through OT L1 or OT L1G2 and end with the return position OT G1 or OT any or OT any . When O2 is being executed, it will end with the return position OT L1 or OT L1G2 . If O2 is executed before O1, O2 ends with the return position OT L1 or OT L1G2 as before. When O1 is executed, since it is concurrent with O2 and its T Order is more than that of O2, it will pass through O2 as well as OT <ref type="bibr">L1</ref> or OT L1G2 and end with return position OT G1 or OT any or OT any . Thus the same result is obtained.</p><p>All the three cases show that no matter in what sequence O1 and O2 are executed the results are always the same, i.e. the execution effects of the two operations have no relation with their execution order.</p><p>Theorem 2. If O1 and O2 are concurrent, the execution effects of two operations have no relation with their execution order.</p><p>Proof. Consider the scan-range of the two operations.</p><p>1. If the scan-ranges of the two operations have no shared part, it is obvious that the two operations do not affect each other due to the retracing process.</p><p>2. If the scan-ranges of the two operations have one shared part. As shown in <ref type="figure" target="#fig_0">Fig.13</ref>, −→ AC denotes O1's scan-range, − − → BD denotes O2's scan-range. The relative position (left or right) of C and D (two right bounds of the scan-ranges) is ignored in our following proof since it has no impact on the proof of Theorem 1. Then consider two cases: (b) A = B. Suppose the two operations are done respectively (i.e. do O1, undo O1 and then do O2), we have already proved that the execution effects of two operations have no relation with their execution order in a same range and the relative position of the right bounds has no impact on this result.</p><p>Therefore, the execution effects of two operations have no relation with their execution order no matter what scanranges they have.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.2">N operations</head><p>Theorem 3. Orders of character nodes at every site are still consistent when n operations have been executed.</p><p>Proof. First, when all the document orders at every site are consistent, executing two operations under the execution condition, a consistent order is certain to be obtained. Then suppose the orders of character nodes at every site are consistent after we have executed n − 1 operations in the order which meets the execution condition. What we want to prove is that the orders of character nodes at every site are still consistent when n operations have been executed.</p><p>Suppose executing n operations under the execution condition at two sites, whose order can be expressed as which still meet the execution condition. According to the assumption, the orders of character nodes at every site are consistent after we have executed n − 1 operations in the order which meets the execution condition, so the orders of document's character nodes are still consistent after these two sequences have been executed. So all the orders of character node at the sites' are consistent after n operations have been executed in the order which meets the execution condition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.3">Summary</head><p>We have proved that after executing several operations in any order which meets the execution condition, the orders of character nodes at every site will keep consistent. It is to say that the order in which two operations are executed at one site for the first time has been kept at any other sites. In addition, the key to the correctness of a Delete operation is that it can find the correct effective character node and the consistency of orders of character node ensures it to count to the correct effective character node. Both of the orders of character nodes and effective/ineffective marks of every character node at all sites are kept consistent, so the documents are convergent. Since a Insert operation can find the correct scan-range and a Delete operation can find its corresponding character node at any sites and they do not interfere with other operations, those satisfy operations' definition in Section 2. However, there are still some arguments for intention preservation, we plan to present more about intention's formal definition and the complete proof in the next future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Some Existing Puzzles</head><p>The dOPT puzzle described in C.A.Ellis et al. <ref type="bibr" target="#b1">[2]</ref> supposes that several Insert operations targeting the same position satisfy certain causal or concurrent relationships. Judging their order by simple priority cannot ensure convergence. In the dOPT puzzle, different operations execution orders can be reduced to the two typical cases shown in <ref type="figure" target="#fig_0">Fig.10</ref>. <ref type="figure" target="#fig_0">In Fig.10</ref>, O1 is causally after OT L2 and O2 are concurrent with O1 and OT L2 . It is shown that we can always obtain the same result no matter in what sequence the operations are executed. It is proved in Section 3.5.2 that the convergence can also be ensured in some more complex situations.</p><p>The false-tie puzzle in C.Sun et al. <ref type="bibr" target="#b15">[15]</ref>, which is also called ERV puzzle in D. <ref type="bibr">Li et al.[6]</ref>, supposed that two concurrent Insert operations may lose their relative position (left or right) due to the Delete between them and obtain the opposite result. In the Mark &amp; Retrace method, the scan-ranges of two Insert operations with the relative position (left or right) have no shared part. Since a concurrent Delete has no impact on the result of the retracing process, the range-scan processes of these two Insert operations are performed in two independent scan-ranges and do not affect each other. So the results of every site are convergent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">EFFICIENCY ANALYSIS</head><p>In Control-algorithm, we can see that the cost of algorithm is mainly spent on two aspects. One is the execution of Retracing and the other is the execution of Insert or Delete. Attaching operations on corresponding nodes and modifying the state of the local site can be finished in time O(1). Discuss these two aspects respectively. Since the execution efficiency of Retracing is relevant to the operations' organize structure, we first introduce the optimization of operation execution efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Optimization of Operation Execution Efficiency</head><p>The first step of operation's execution is to count to the appointed nodes. Then the Insert chooses an inserting position between two nodes during the Rang-Scan proc while the Delete only revises that node's effective/ineffective mark. The efficiency of mark revision is obviously O(1) and the time complexity of Rang-Scan is O(m) in which m represents the number of the ineffective character nodes between the two effective character nodes. When the document is of great scope, comparing with the great number of ineffective character nodes produced by Delete, the concurrent operations which are marked ineffective can be neglected. So m is approximately equal to the using rate of Delete and Insert.</p><p>When a document is organized by liner structure, the process of counting is sequential access to linear structure. Its time complexity is linear which is expressed as O(n) in which n is the number of character nodes in the document. But when the document is of great scope, the great number of ineffective nodes makes the execution time of algorithm dissatisfactory. We hope to further optimize the operation execution efficiency.</p><p>We reorganize the character nodes to a Red-Black Tree <ref type="bibr" target="#b0">[1]</ref> and ensure the result of pre-order traversal of the BlackRed tree is the original linear order. It means that every node's left sub-tree is the set of the nodes which are on the left of itself in the original linear structure. As the figure below, the Insert and Delete operations in the Red-Black Tree can keep this property easily. Since the internal rotation rules of Red-Black Tree do not affect the result of pre-order traversal, as long as the counting process can find the correct position, the correctness of algorithm will not be affected if we change the sequential access from left to right to the pre-order traversal of the tree. Then we extend the data structure of original Red-Black Tree. Every node of the tree saves two additional data -the two numbers of the effective character nodes of left sub-tree and right sub-tree. When the effective/ineffective mark of every node has been changed or there is a effective character node being Inserted or deleted, only the data of ancestor of this node has to be changed. Suppose a Red-Black Tree has n nodes (n is the number of the document's character nodes). The time complexity is O(logn) when changing the mark of one node because of the tree is approximately balanced. In one Red-Black Tree, one Insert or Delete operation can result in at most two or three rotations and every rotation only involves two nodes. We can adjust the data of this node (the number of effective character nodes of this node's left and right sub-tree) when executing rotation operations. The time complexity of changing the two nodes' mark is O(1) and the time complexity of ancestor's adjustment is O(logn), so the time complexity of Insert or Delete in one Red-Black Tree is still kept O(logn). The reader can derive the analysis and the proof of the correctness of expanded Red-Black Tree in <ref type="bibr" target="#b0">[1]</ref>.</p><p>Then when we need to count the P th effective character node in pre-order traversal, we can search it recursively as Func.4.</p><p>This recursively searching process is the extension of the general traversal process of binary search tree, whose time complexity is still O(logn).</p><p>So in the new document structure, the optimization of an Insert operation's time complexity is O(logn + m) and the Delete operation's is O(logn). Since m is the using rate of Delete and Insert, we can use ordinary potential method to make the further analysis: since the Delete is executed m times while the Insert is executed once, we can amortize the cost O(m) of Range-Scan within an Insert to m corresponding Delete operations. And then the amortized costs of Insert and Delete are both O(logn). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Efficiency Optimization of Retracing</head><p>The Retracing procedure is to retrace to the state according to the given timestamp SV . The effective/ineffective mark is only determined by the relations between SV and timestamp of every operation attached on the node. When the timestamp of every operation attached on the node are kept causal before SV , the node's effective/ineffective mark is certain. In other words, for every operation to be executed, only when the operation attached on a certain node is concurrent with it, this node's effective/ineffective mark will be changed.</p><p>On the one hand, suppose an operation O has been executed at every site, and another operation O 񮽙 generates after O. There must be O → O 񮽙 and there is no need to consider operation O when we executing Retracing by the timestamp of operation O 񮽙 . On the other hand, every operation is sent to other sites together with SV of current site. This SV represents the documents state at the time of operation's generation and through it other sites will know what operations have been executed at the sending site. We only keep the OList containing the operations which haven't been executed at some sites. During Retracing process, we only take into account of the character nodes relevant to these operations into consideration and as long as we have ensured that one operation has been executed at every site, we can delete it from the OList.</p><p>Then we can use the same method as State Vector Table(SVT) in Garbage Collection Scheme in <ref type="bibr" target="#b15">[15]</ref>  , it is obvious that OList-i has been executed at all sites. So we can delete it from the list.</p><p>Suppose the length of OList is h which means we need to check and change at most h character nodes' effective/ineffective mark during Retracting process. Under the new document structure, suppose the number of operations attached on a character node is d and then the cost of checking the node's effective/ineffective mark is O(d) and the cost of adjusting its ancestor's data(the number of effective character nodes of node's left and right sub-tree) is O(logn). So the time complexity of Retracing can be expressed as</p><formula xml:id="formula_2">O(d · h + h · logn).</formula><p>Generally, the number of the operations attached on a node is smaller than ten, so we can consider d as a constant. During the operation execution process, when the operation is executed and fed back in good time, the length of OList will not be increased. Obviously, we can also consider h as a constant.</p><p>Before the execution of Control-Algorithm process, the state vector of site S is SV . Control-Algorithm adjusts this state vector to SV 񮽙 by SVS[R] ⇐ SVS[R] + 1 and only the Rth element has been changed. So after the second Retracing process in Control-Algorithm is finished, only the targeting character node of the new operation has changed. We record all the changed nodes in the Retracing(DocS , SVO) first. When it is the time to execute Retracing(DocS , SVO), we restore the changed nodes instead of the Retracing process. After then, we only need to deal with the targeting character node of the new operation. The time complexity of the restore process can be expressed as O(h + d).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">General Efficiency Analysis</head><p>Colligate the execution efficiency of operation and process of Retracing, we have the actual execution cost. The cost of</p><formula xml:id="formula_3">Insert is O(h · logn + logn + d · h + h + d + m) and of Delete is O(h·logn+logn+d·h+h+d).</formula><p>In the situation where there are great number of operations, consider h (the OList's length) and d (the number of operations attached on every node) as two constants, we have the amortized cost of an operation O(logn), in which n is the number of character nodes in the document. And we plan to give a further comprehensive comparison with OT technique in the future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">UNDO SUPPORTED</head><p>In Mark &amp; Retrace method, the expression of Undo is like that of Insert and Delete. It includes the state vector of its generation site and the operation that is being undone. We can identify the corresponding operation of the Undo by the number of generation sites and the timestamp attached <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b20">20]</ref>. When the Undo operation is causally-ready, it will be executed in the control algorithms. Given an Undo operation O2, Undo[O1], in which O1's target position is P1 and timestamped by SVO 1 . O1 and O2 should be attached on the same character node. The execution process can be performed as follow. Rretrace the address space to the state at the time SVO 1 , count to the P1th effective character node and attach O2 on it. Then the second Retracing process takes this new Undo into consideration and gives this node the correct effective/ineffective mark.</p><p>During the Retracing process, the only adjustment produced by the introduction of Undo operation is that it takes the effect of Undo into consideration when deciding the effective/ineffective mark of a character node. Since there may attached several concurrent Delete operations or Undo operations on one character node, it may cause the intention violation <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b20">20]</ref>. We have discussed the cause of intention violation and how to judge and deal with it in <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b20">20]</ref>, but we have not discussed the display strategy in detail. Actually, the method will be very simply if we want to realize Multi-version/Single-display <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b16">16]</ref>. The advantage of Multi-version/Single-display has been also emphasized in CoWord/CoPowerPoint <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b16">16]</ref>.</p><p>In order to realize the Multi-version/Single-display strategy of intention violation by Undo, we append a Delete counter to every character node, whose initial value is zero. Every Delete and every Undo toward Insert will plus 1 to this counter while every Undo toward Delete will minus 1 to this counter. The Retracing process only considers the effects of other valid operations (the timestamp is causally before the given one) on the counter. Consider a character node, when the Insert is valid and the counter's value is 0, this character is marked effective, otherwise it will be marked ineffective. When there are several Delete operations in the algorithm, the character node is effective only when all the Delete operations are undone, otherwise it will keep ineffective. When there exists intention violation, the algorithm maintains the intention of users who want character node to be ineffective, namely Multi-version/Singledisplay strategy <ref type="bibr" target="#b16">[16]</ref>.</p><p>During the revised Retracing process, the set of valid operations in a given SV is certain so the result of the counter is also certain and the effective/ineffective mark as well. Since the Undo does not affect the order of character nodes, the CCI model is also maintained. Compared with OT, Mark &amp; Retrace with Undo operation can deal with current undo puzzles well and it does not need any other adjustments <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b11">11]</ref>. For space reason, please refer to <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b20">20]</ref> for the analysis of how to deal with undo puzzles and the cause and judgments of intention violation. The execution efficiency of undo operation approximates that of Delete. The time complexity and its amortized cost are both kept as O(logn).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORKS</head><p>The initial concept of Address Space Transformation was reported early in <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b18">18]</ref> but was not able to resolve the dOPT puzzle. The algorithms in <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b18">18]</ref> are localized in the relation between the new operation and the executed ones at current site but has not fully considered the confusion of concurrent operations. When all the operations in dOPT puzzle are executed between two existing character nodes (for example, executing dOPT puzzle in an initially vacant document), the operation order will not be affected by the retracing process. So it needs additional solutions when there are several concurrent operations targeting one position, but <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b18">18]</ref> lack such support to this situation.</p><p>Algorithm dOPT, adOPTed and GOTO are based on TP2, <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b15">15]</ref>, but cannot fully satisfy TP2. NICE reported notification server <ref type="bibr" target="#b8">[8]</ref> and SOCT3/4 used the sequence method <ref type="bibr" target="#b17">[17]</ref>, but neither of them is able to resolve the false-tie (ERV) puzzle. GOT maintains the convergence by the method of a global total order of execution. But Li et al. <ref type="bibr" target="#b6">[6]</ref> pointed out that the original GOT will fail in the case of complicated false-tie (ERV) scenarios but the details have not been published. Li et al. <ref type="bibr" target="#b6">[6]</ref> also pointed out that although the solution of false-tie (ERV) has been realized in <ref type="bibr" target="#b12">[12]</ref>, it is still not published. Imine et al. <ref type="bibr" target="#b4">[5]</ref> tried to support TP2 by expanding IT function but fails in solving dOPT puzzle. Li et al. <ref type="bibr" target="#b6">[6]</ref> reported a solution and also gave the proof. We have explained that our Mark &amp; Retrace method can satisfy the CCI model and deal with dOPT puzzle and false-tie(ERV) puzzle.</p><p>We discuss the support to Undo based on the current work, finally. Among the algorithms above, adOPTed supports the sequential Undo by maintaining a multiple dimensions data structure <ref type="bibr" target="#b7">[7]</ref>. REDUCE supports undo any operation at any time by inversing the Undo operation <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b11">11]</ref>. But when facing Undo puzzles, it needs to maintain the operations' relationship additionally, which adds to the time complexity of algorithm (nonlinear time complexity). Mark &amp; Retrace method also can support any Undo and can resolve the Undo puzzles in <ref type="bibr" target="#b10">[10]</ref> more easily. None of the current methods has considered the intention violation in Undo <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b20">20]</ref>. Although REDUCE can maintain convergence in the intention violation and obtain the effect of Multi-version /Single-display strategy, it lacks related examining method and enough hints to users. In this paper, we report a new solution to Multi-version/Single-display strategy and plan to discuss the Multi-version/ Multi-display strategy and its related examining and hinting method in the further work. More information can be derived in <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b20">20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>In this paper we present a strategy which can maintain the CCI model and is different from OT. It does not ensure the operation's execution correctness by modifying the operation's address but by transforming the address space of the document. Since the Mark &amp; Retrace processes do not affect the relative position (left or right) between characters, it is easier to maintain operations' order. It can not only achieve all the consistency criteria in <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b15">15]</ref>, but can support any Undo as well.</p><p>For space reason, we have not given more examples to describe the process to resolve the Undo puzzles using Mark &amp; Retrace. More information can be derived in <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b20">20]</ref>. We plan to discuss more about the Multi-version/Multi-display strategy in Undo intention violation and the support to update operation and tree based structures of Mark &amp; Retrace Algorithm.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The order of operations' producing and executing</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The address space transformation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 : The final state of document's liner struc- ture and user's view in the case of Fig. 1</head><label>31</label><figDesc>Figure 3: The final state of document's liner structure and user's view in the case of Fig.1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 : The process of executing operation Insert["c", 3 ] in the case of Fig. 1 Procedure 2</head><label>4312</label><figDesc>Figure 4: The process of executing operation Insert["c", 3] in the case of Fig.1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 : Definition of some special character nodes Figure 6 :</head><label>56</label><figDesc>Figure 5: Definition of some special character nodes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 : Possible situations before executing O1 and O2 respectively in case 1 :</head><label>71</label><figDesc>Figure 7: Possible situations before executing O1 and O2 respectively in case 1: O1 and O2 end with the return position OT G12 or OT any or OT G2 or OT G1 or OT any</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 : The result of case 1 Case 2 :</head><label>812</label><figDesc>Figure 8: The result of case 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 : Possible situations before executing O1 and O2 respectively in case 2 :</head><label>92</label><figDesc>Figure 9: Possible situations before executing O1 and O2 respectively in case 2: O1 ends with the return poison OT L2 ; O2 passes through OT L2 and ends with the return position OT any or OT G2 or OT any</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 : The result of case 2</head><label>102</label><figDesc>Figure 10: The result of case 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 : Possible situations before executing O1 and O2 respectively in case 3 :Figure 12 : The result of case 3</head><label>113123</label><figDesc>Figure 11: Possible situations before executing O1 and O2 respectively in case 3: O2 ends with the return position OT L1 or OT L1G2 ; O1 passes through OT L1 or OT L1G2 and ends with the return position OT G1 or OT any or OT any</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Scan-Range of two operations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 14 : Adjusting the liner structure to a</head><label>14</label><figDesc>Figure 14: Adjusting the liner structure to a RedBlack tree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Function 4</head><label>4</label><figDesc>Count(P , node), return the P th effective char- acter node 1: if node.N umof Lef t = P −1 and node.effective = true then 2: return node 3: end if 4: if node.N umof Lef t &gt; P − 1 then 5: return Count(P , node.lef t) 6: else 7: if node.effective = true then 8: return Count(P − node.N umof Lef t − 1, node.right) 9: else 10: return Count(P − node.N umof Lef t, node.right) 11: end if 12: end if</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>to deter- mine the members of OList. Maintain a SV T at every site and suppose the state vector table of the kth site is SV T k . Initially, SV T k [i][j] = 0 for all i, j ∈ 0, . . . , N − 1. After ex- ecuting an operation O from a remote site r, timestamped by SVO, updated the SV T k : SV T k [r][i] = SVO[i], for all i ∈ 0, . . . , N − 1. Let MSV k be the minimum state vector at site k: MSV k [i] = min(SV T k [0][i], . . . , SV T k [N − 1][i]), for all i ∈ 0, . . . , N − 1. MSV k is updated after the new operation's execution at site k. Then check every operation OList-i in OList. Suppose OList-i is generated at site r and timestamped by SVOList−i. When SVOList−i[r] ≤ MSV k [r]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>if SVO ins ≥ SV , then this node is marked ineffective; (2) if SVO ins ≤ SV and there is no Delete targeting this character node, then this node is marked effec- tive; (3) if SVO ins ≤ SV and SVO del ≥ SV , then this node is marked effective; (4) if SVO ins ≤ SV but SVO del ≤ SV , then this node is marked ineffective. On one hand, consider an Insert and a Delete attached on a node, then it must be SVO ins ≤ SVO del . In other words Procedure 1 Retracing (DocS, SV ), retrace the address space of DocS with timestamp SV 1: for all character node CNi of liner structure of DocS do 2: Set CNi ineffective 3: Consider the Insert Oins of CNi 4: if Oins is timestamped by SVO ins and SVO ins ≤ SV thenof CNi 8: if O del is timestamped by SVO del and SVO del ≤ SV then 9:</head><label></label><figDesc></figDesc><table>5: 
set CNi effective 
6: 
end if 
7: 
for each Delete O del </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Function 3 Range-Scan(CNa, CN b , CNnew ), scan charac- ter nodes between CNa and CN b , then return the position of CNnew 1: P ⇐ Nill and19: until CNscan = CN b 20: if P 񮽙 = Nill then</head><label>3</label><figDesc></figDesc><table>CNscan ⇐ CNa.right 
2: repeat 
3: 
Compare CNnew with CNscan 
4: 
if CNscan 񮽙 CNnew then 
5: 
if T Order(CNnew) &lt; T Order(CNscan) 
and P = Nill then 
6: 
P ⇐ CNscan 
7: 
end if 
8: 
if T Order(CNnew) &gt; T Order(CNscan) 
and CNscan → P then 
9: 
P ⇐ Nill 
10: 
end if 
11: 
end if 
12: 
if CNscan → CNnew then 
13: 
if P = Nill then 
14: 
P ⇐ CNscan 
15: 
end if 
16: 
exit the loop 
17: 
end if 
18: 
CNscan ⇐ CNscan.right 
21: 
return P 
22: else 
23: 
return CN b 
24: end if 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>. . On and O k 1 O k 2 O k 3 . . . O kn . Without loss of gener- ality, suppose O k i = O1. Since O1O2O3 . . . On meets the execution condition, O k i and O k 1 O k 2 O k 3 . . . O k i−1 arewith O k i−1 , O k i−2 , O k i−3 , . . . , O k 2 and O k 1 in turn and obtain O k i O k 1 O k 2 . . . O k i−1 O k i+1 . . . O kn . Since O k i = O1 andOn and O k 2 O k 3 . . . O k i−1 O k i+1 . . . O kn</head><label></label><figDesc>O1O2 O3 .con- current. The change of any two concurrent operations' exe- cution order does not affect the result of the document, so we can switch O k iafter the adjustment the first operation of every sequence is O1, we can execute the first operation of every sequence first. Here, all the sites' orders are still consistent and the operation sequences to be executed are changed to O2O3 . . .</figDesc><table></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>The authors wish to thank Yan Yu and David Sun for their help in improving the final presentation of this article and Qin Zhang for his assistance in the proofs. The authors are also very grateful to anonymous referees for their detailed and insightful comments and suggestions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Introduction to Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">H</forename><surname>Cormen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-09" />
			<publisher>MIT Press</publisher>
			<pubPlace>Boston</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Concurrency control in groupware systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A</forename><surname>Ellis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">J</forename><surname>Gibbs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Conference on the Management of Data</title>
		<meeting>the ACM Conference on the Management of Data<address><addrLine>Portland Oregon</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1989-05" />
			<biblScope unit="page" from="399" to="407" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Ontology based semantic conflicts resolution in collaborative editing of design documents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Ye</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Advanced Engineering Informatics (IJAEI)</title>
		<imprint>
			<date type="published" when="2005-01" />
		</imprint>
	</monogr>
	<note>Accepted</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Document marking scheme for preserving intention of operation in cooperative editing system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Luo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Software</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="160" to="164" />
			<date type="published" when="1999-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Proving correctness of transformation functions in real-time groupware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Imine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Molli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Oster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rusinowitch</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Proceedings</title>
		<imprint>
			<date type="published" when="2003-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Preserving operation effects relation in group editors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on CSCW 2004</title>
		<meeting>ACM Conference on CSCW 2004<address><addrLine>Chicago, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004-11" />
			<biblScope unit="page" from="437" to="446" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An integrating, transformation-oriented approach to concurrency control and undo in group editors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ressel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Nitsche-Ruhland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gunzenbauser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on CSCW 1996</title>
		<meeting>ACM Conference on CSCW 1996</meeting>
		<imprint>
			<date type="published" when="1996-11" />
			<biblScope unit="page" from="288" to="297" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Flexible notification for collaborative systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on CSCW 2002</title>
		<meeting>ACM Conference on CSCW 2002<address><addrLine>Chicago, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-11" />
			<biblScope unit="page" from="77" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Concurrent operations in a distributed and mobile collaborative environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Suleiman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ferrie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Fourteenth International Conference on Data Engineering</title>
		<meeting>the IEEE Fourteenth International Conference on Data Engineering<address><addrLine>Orlando, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-02" />
			<biblScope unit="page" from="36" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Undo any operation at any time in group editors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on CSCW 2000</title>
		<meeting>ACM Conference on CSCW 2000<address><addrLine>Philadelphia, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-12" />
			<biblScope unit="page" from="191" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Undo as concurrent inverse in group editors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer-Human Interaction</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="309" to="361" />
			<date type="published" when="2002-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
		<ptr target="http://reduce.qpsf.edu.au/coword/" />
		<title level="m">The coword and copowerpoint project</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Consistency maintenance in real-time collaborative graphics editing systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer-Human Interaction</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="41" />
			<date type="published" when="2002-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Operation transformation in real-time group editor: issuer, algorithm, and achievement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A</forename><surname>Ellis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on CSCW 1998</title>
		<meeting>ACM Conference on CSCW 1998<address><addrLine>Seattle, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-11" />
			<biblScope unit="page" from="59" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Achieving convergence, causality-preservation, and intention-preservation in real-time cooperative editing systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer-Human Interaction</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="63" to="108" />
			<date type="published" when="1998-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Operational transformation for collaborative word processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on CSCW 2004</title>
		<meeting>ACM Conference on CSCW 2004<address><addrLine>Chicago, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-11" />
			<biblScope unit="page" from="437" to="446" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Copies convergence in a distributed realtime collaborative environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Vidot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ferrie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Suleiman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on CSCW 2000</title>
		<meeting>ACM Conference on CSCW 2000<address><addrLine>Philadelphia, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-12" />
			<biblScope unit="page" from="171" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A concurrency control method based on document marking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Gu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Research and Development</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1662" to="1667" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A document mark based on method supporting group undo</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CSCW&apos;2004 Workshop on Collaborative Editing Systems</title>
		<meeting><address><addrLine>Chicago, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The multi-version and single-display strategy in undo scheme</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 5th International Conference on Computer and Information Technology</title>
		<meeting><address><addrLine>Shanghai, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-09" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
