<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:43+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Taming the Computational Complexity of Combinatorial Auctions: Optimal and Approximate Approaches</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuzo</forename><surname>Fujishima</surname></persName>
							<email>fujisima@ccs.mt.nec.co.jpvisitingfromneccorporationkevinlb@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Stanford University</orgName>
								<address>
									<postCode>94305</postCode>
									<settlement>Stanford</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Leyton-Brown</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Stanford University</orgName>
								<address>
									<postCode>94305</postCode>
									<settlement>Stanford</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Shoham</surname></persName>
							<email>shoham@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Stanford University</orgName>
								<address>
									<postCode>94305</postCode>
									<settlement>Stanford</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Taming the Computational Complexity of Combinatorial Auctions: Optimal and Approximate Approaches</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>In combinatorial auctions, multiple goods are sold simultaneously and bidders may bid for arbitrary combinations of goods. Determining the outcome of such an auction is an optimization problem that is NP-complete in the general case. We propose two methods of overcoming this apparent intrac-tability. The first method, which is guaranteed to be optimal, reduces running time by structuring the search space so that a modified depth-first search usually avoids even considering allocations that contain conflicting bids. Caching and pruning are also used to speed searching. Our second method is a heuristic, market-based approach. It sets up a virtual multi-round auction in which a virtual agent represents each original bid bundle and places bids, according to a fixed strategy, for each good in that bundle. We show through experiments on synthetic data that (a) our first method finds optimal allocations quickly and offers good anytime performance, and (b) in many cases our second method, despite lacking guarantees regarding optimality or running time, quickly reaches solutions that are nearly optimal.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Combinatorial Auctions</head><p>Auction theory has received increasing attention from computer scientists in recent years. <ref type="bibr">1</ref> One reason is the explosion of internet-based auctions. The use of auctions in business-to-business trades is also increasing rapidly <ref type="bibr">[Cortese and Stepanek, 1998</ref>]. Within AI there is growing interest in using auction mechanisms to solve distributed resource allocation problems. For example, auctions and other market mechanisms are used in network bandwidth allocation, distributed configuration design, factory scheduling, and operating system memory allocation <ref type="bibr">[Clearwater, 1996]</ref>. Market-oriented programming has been particularly influential <ref type="bibr" target="#b3">[Wellman, 1993;</ref><ref type="bibr">Mullen and Wellman, 1996]</ref>.</p><p>The value of a good to a potential buyer can depend on what other goods s/he wins. We say that there exists complementarity between goods g and h to bidder b if u b ({g,h})&gt; u b ({g})+u b ({h}), where u b (G) is the utility to b of acquiring the set of goods G. If goods g and h were auctioned separately, it is likely that neither of the typically desired properties for auctions-efficiency and revenue maximization-would hold. One way to accommodate complementarity in auctions is to allow bids for combinations of goods as well as individual goods. Generally, auctions in which multiple goods are auctioned simultaneously and bidders place as many bids as they want for different bundles of goods are called combinatorial auctions <ref type="bibr">2</ref> .</p><p>It is also common for bidders to desire a second good less if they have already won a first. We say that there exists substitutability between goods g and h to bidder b when u b ({g,h}) &lt; u b ({g})+u b ({h}). A common example of substitutability is for a bidder to be indifferent between several goods but not to want more than one. In order to be useful, a combinatorial auction mechanism should provide some way for bidders to indicate that goods are substitutable.</p><p>Combinatorial auctions are applicable to many real-world situations. In an auction for the right to use railroad segments a bidder desires a bundle of segments that connect two particular points; at the same time, there may be alternate paths between these points and the bidder needs only one <ref type="bibr" target="#b0">[Brewer and Plott, 1996]</ref>. Similarly, in the FCC spectrum auction bidders may desire licenses for multiple geographical regions at the same frequency band while being indifferent to which particular band they receive <ref type="bibr" target="#b2">[Milgrom, 1998]</ref>. The same situation also occurs in military operations when multiple units each have several alternate plans and each plan may require a different bundle of resources.</p><p>While economics and game theory provide many insights into the potential use of such auctions, they have little to say about computational considerations. In this paper we address the computational complexity of combinatorial auctions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Complexity Problem</head><p>There has been much work in economics and game theory on designing combinatorial auctions. The Clarke-Groves-Vickrey mechanism (also known as the Generalized Vickrey Auction, or GVA) has been particularly influential <ref type="bibr" target="#b1">[Mas-Colell et al., 1995;</ref><ref type="bibr">Varian, 1995]</ref>. It is beyond the scope of this paper to review such mechanisms, but they share a central problem: given a collection of bids on bundles, finding a set of non-conflicting bids that maximizes revenue. (A more precise definition is given in Section 3.) This problem is easily shown to be NP-complete 3 <ref type="bibr" target="#b3">[Rothkopf et al., 1995]</ref>.</p><p>Several methods have been conceived to cope with the computational complexity of combinatorial auctions, most aiming to ease the difficulty of finding optimal allocations. They can be classified into three categories based on the strategies they use.</p><p>One strategy is to restrict the degree of freedom of bidding to simplify the task of finding optimal allocations. <ref type="bibr">Rothkopf et al.</ref> show that an optimal allocation can be found in polynomial time if (1) each bid contains no more than two goods; (2) for any two bids, either they are disjoint or one is a subset of the other; or (3) each bid contains only consecutive goods given a one-dimensional ordering of goods <ref type="bibr" target="#b3">[Rothkopf et al., 1995]</ref>.</p><p>Another strategy is to shift the burden of finding an optimal allocation to bidders. [ <ref type="bibr" target="#b0">Banks et al., 1989]</ref> and <ref type="bibr" target="#b0">[Bykowsky et al., 1995]</ref> have reported a mechanism called AUSM in which non-winning bids are pooled in a stand-by queue. Bidders can combine their bids with other bids currently in the queue to form new allocations. A new allocation is adopted if it generates more revenue than the previously best allocation.</p><p>A third strategy is to attempt to find an optimal allocation but to be satisfied with a sub-optimal allocation when the expenditure of further resources becomes unacceptable. In other words, the optimality of the allocation is traded-off with the resources required, especially time.</p><p>In this paper we present two algorithms. The first is an anytime algorithm that attempts to exploit a problem's particular bid structure to reduce the size of the search. It also reduces search time by caching partial results and by pruning the search tree. The second algorithm uses a market-based approach to determine an acceptable allocation, although it is not guaranteed to find an optimal one. We then show results of experiments with synthetic data suggesting that these methods, though not provided with formal guarantees, appear to have surprisingly good per-formance. Additionally, the market-based approach appears to produce allocations that are always optimal or nearly optimal. <ref type="bibr">4</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Precise Problem Statement</head><p>In this paper we propose two methods for finding desirable allocations based on bids submitted. We start by formally defining the optimization problem. Denote the set of goods by G and the set of non-negative real numbers by R + . A bid b=(p b ,G b ) is an element of S= R + ×(2 G -{∅}). Let B be a subset of S. A set F⊆B is said to be feasible if ∀b,c≠b∈F G b ∩G c =∅. Denote the set of all feasible allocations for B by Φ(B). Further, let G(B)=∪ b∈B G b be the set of goods contained in the bids of B.</p><p>[Problem] Find an allocation W∈Φ(B) such that ∀F∈Φ(B) ∑ b∈F p b ≤∑ b∈W p b . Such an allocation is said to be optimal or revenue maximizing.</p><p>What kind of value interrelation between goods can be represented by the bids defined above? Clearly, complementary values are easily accommodated. Suppose a bidder bids $20 for each of {g} and {h}, and $50 for {g,h}. In this case any revenue-maximizing algorithm will correctly select the {g,h} bid instead of {g} and {h}.</p><p>This bid format is also sufficient for representing substitutability through an encoding trick. Suppose a bidder is willing to pay $20 for {g} and $30 for {h} but only $40 for {g,h}. In this case, bids cannot be submitted as before since the revenue-maximizing algorithm would select the pair {g} and {h} over {g,h}, charging the bidder $50 instead of $40 for g and h. However, this problem can be solved by the introduction of 'dummy goods'-virtual goods that enforce an exclusive-or relationship. (Each dummy good must appear only in a single bidder's bids.) In our example, the bidder could submit the following bids: ($20, {g,d}), ($30, {h,d}), and ($40, {g,h}) where d is a new, unique dummy good. The first two bids are now mutually exclusive and so will never be allocated together. This technique can lead to a combinatorial explosion in the number of bids if many goods are substitutable, but in many interesting cases this does not arise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CASS Algorithm</head><p>When the number of goods and bids is small enough, an exhaustive search can be used to determine the optimal allocation. We propose an algorithm, Combinatorial Auction Structured Search (CASS), presented as a naïve brute-force approach followed by four improvements. CASS considers fewer partial allocations than the brute-force method because it structures the search space to avoid considering allocations containing conflicting bids. It also caches the results of partial searches and prunes the search tree. Finally, it may be used as an any-time algorithm, as it tends to find good allocations quickly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Brute-Force Algorithm</head><p>Suppose there are |G| goods 1, 2, ..., |G|, and |B| bids 1, 2, …, |B|. First, bids that will never be part of an optimal allocation are removed. That is, if for bid b k =(p k ,G k ) there exists a bid b l =(p l ,G l ) such that p l &gt;p k and G l ⊆G k , then b k is removed because it can always be replaced by b l , increasing revenue. Then for each good g, if there is no bid b=(x,{g}) a dummy bid b=(0,{g}) is added.</p><p>Our brute-force algorithm examines all feasible allocations through a depth-first search. Let x be the first bid and y be the last bid. Our implementation follows:</p><p>1. If x does not conflict with the current allocation, add x to the current allocation 2. Increment x 3. If more bids can be added to the allocation, go to 2. 4. Update best revenue and allocation observed so far. 5. If y is contained in the current allocation, remove it, set x=y+1 and repeat from 2. 6. Decrement y. 7. If y is not the first bid, go to 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Improvement #1: Bins</head><p>A great deal of unnecessary computation is avoided in the brute-force algorithm by checking whether bids conflict with the current allocation before they are added. However, work is still required to determine that a combination is infeasible and to move on to the next bid. It would be desirable to structure the search space to reduce the number of infeasible allocations that are considered in the first place.</p><p>We can reduce the number of infeasible allocations considered by sorting bids into bins, D i , containing all bids b where good i ∈ G b and for all j such that j∈ <ref type="bibr">[1, i-1]</ref>, j ∉ G b . Rather than always trying to add each bid to our allocation, we add at most one bid from every bin since all bids in a given bin are mutually exclusive.</p><p>In fact, we can often skip bins entirely. While considering bin D i , if we observe that good j&gt;i is already part of the allocation then we do not need to consider any of the bids in D j . In general, instead of considering each bin in turn, skip to D k where k∉G(F) and ∀i&lt;k, i∈G(F).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Improvement #2: Caching</head><p>Let F i be the partial allocation under consideration when D i is reached during a search. Define C i ⊆ G(F i ) where ∀j ∈ G(F i ), j&gt;i ↔ j ∈ C i . Note that there are many different partial allocations F i1 , F i2 , etc., that share the same C i , and that if C i1 =C i2 then the search trees for F i1 and F i2 are identical beyond D i . It is therefore possible to cache partial searches based on C i . However, caching all possible values of C i would require a cache of size 2 |G|-(i-1) , which would quickly become infeasible. Therefore, we only cache when C i includes no more than k goods, where k is a threshold defined at runtime for each bin. D i requires a cache of size</p><formula xml:id="formula_0">∑ =         − k j j i G 0 | | .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Improvement #3: Pruning #1</head><p>Performance can be improved by backtracking whenever a given search path is provably unable to lead to a new best allocation. We can prune whenever C (F i1 ) ⊂ C (F i2 ) and p(F i2 ) + p(cache (F i1 )) ≤ bestAllocation. In this case, the sum of the revenue from the cached path beyond F i1 and the revenue leading up to F i2 is less than the revenue from the best allocation seen so far. Since F i1 allocates a superset of the goods allocated in F i2 (thus overestimating revenue), a better allocation would not be found by expanding F i2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Improvement #4: Pruning #2</head><p>We can also backtrack when it is provably impossible to add any bids to the current allocation to generate more revenue than the current best allocation. Before starting the search we calculate an overestimate of the revenue that can be achieved with each good, ( ≤ p(best_allocation). This technique is most effective when good allocations are found quickly. Finding good allocations quickly is also useful if a solution is required before the algorithm has completed (i.e., if CASS is used as an anytime algorithm). We have found that good allocations are found early in the search when the bids in each bin are ordered in descending order of average price per good. Similarly, the pruning technique is most effective when the unallocated goods are those with the lowest o(g) values. To achieve this, we reorder bins so that for any two bins i and j, o(g i ) &gt; o(g j ) ↔ i &lt; j.</p><formula xml:id="formula_1">o(g) = | | / ) ( max | b b g b G b p ∈ . o(g) is</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">VSA Algorithm</head><p>Our second algorithm is called Virtual Simultaneous Auction (VSA). This market-based method was inspired by market-oriented programming <ref type="bibr" target="#b3">[Wellman, 1993;</ref><ref type="bibr">Mullen and Wellman, 1996]</ref> and the simultaneous ascending auction <ref type="bibr" target="#b2">[Milgrom, 1998</ref>]. VSA generates a virtual simultaneous auction from the bids submitted in a real combinatorial auction, then simulates the virtual auction to find a good allocation of goods in the real auction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Algorithm</head><p>First, a virtual simultaneous auction is generated based on the bids submitted in a real combinatorial auction. For each bid b=(p b ,G b ) a virtual bidder v b is created. The virtual bidders compete in a virtual simultaneous auction that has multiple rounds. Each virtual bidder v b tries to win all the goods in G b for the price p b on an all-or-nothing basis. The virtual auction starts with no goods allocated and the prices of all goods set to zero. The simultaneous auction is repeated round by round until either an optimal allocation is found or a pre-set time deadline is reached. In the latter case the current best allocation is adopted as the final result.</p><p>Each round of VSA has three phases: the virtual auction phase, the refinement phase and the update phase. In the virtual auction phase each virtual bidder bids for the goods they want. Each individual good is allocated to the highest bidder. If a bidder succeeds in winning all desired goods, that bidder becomes a temporary winner. Otherwise the bidder becomes a temporary loser and returns all allocated goods to the auctioneer. In the refinement phase each of the losers is examined in a random order to see whether making that agent a temporary winner (and consequently making a different winner into a loser) would increase global revenue. If so, the list of winners is updated. Finally in the update phase the current highest price of each good is changed to reflect the price that its current winner bid. The current highest price for unallocated goods is reset to zero.</p><p>Virtual bidders in VSA follow a simple strategy. If a bidder was the temporary winner in the previous round, the bidder does not bid in the current round. Otherwise, agents calculate the sum of the current highest prices of the goods required. If the sum exceeds an agent's budget, the agent does not bid because the agent will not be able to acquire all the goods simultaneously. If the sum is less than the budget, the agent bids such that the surplus (budget -sum) is equally divided among the goods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Properties</head><p>In certain circumstances, VSA will find an optimal allocation. Additionally, it is sometimes possible to detect if an optimal allocation has been found, allowing the virtual auction to end before the deadline.</p><p>[Theorem] If no virtual bidder bids in a round in the virtual auction, the current set of winners is optimal.</p><p>[Proof] Assume that no agents bid in a given round. Define the function that calculates the revenue of an allocation F by r <ref type="figure">(F</ref> </p><formula xml:id="formula_2">(O) = r(O 1 )+r(O 2 ) ≤ r(O 1 )+r(W 2 ) = r(W).</formula><p>However, there is no guarantee that auctions will always finish, even if an optimal allocation is found.</p><p>[Theorem] There exists a set of bids B such that at least one virtual bidder always bids in every round of the virtual auction no matter what bidding strategy is used.</p><p>[ It is this property that makes the refinement phase of VSA important. Consider the case B=B 1 ∪B 2 ∪... where ∀i,j G(B i )∩G(B j )=∅, |B i |=3 and each B i satisfies the condition from the proof above. If we omit the refinement phase then the winner in each subset changes every round except the case where there is no winner. Therefore, an optimal global allocation is examined only when in every subset the optimal winner is temporarily winning. Such synchronization is unlikely to occur unless the number of subsets is very small. The refinement phase causes the optimal winners to become the temporary winners in every round, leading to an optimal allocation even though it is not detected as optimal. (In some cases where ∃i,j G(B i )∩G(B j )≠∅ or |B i | &gt; 3 an optimal allocation may be impossible to achieve regardless of the time limit.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Experimental Evaluation</head><p>As we have not yet determined each algorithm's formal complexity characteristics we conducted empirical tests. We evaluated (1) how running time varies with the number of bids, and (2) how percentage optimality of the best allocation varies with time, given a particular bid distribution and a fixed number of bids and goods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Assumptions and Parameters</head><p>The space of this problem is large. Roughly speaking it has three degrees of freedom: the number of goods, the number of bids and the distribution of bids. Most problematic among these is the distribution. Precisely because of the computational complexity of combinatorial auctions there is little or no real data available. In the absence of such data we tested our algorithms against bids drawn randomly from specific distributions.</p><p>Throughout the experiments we used the following two distribution functions to determine how often a bid for n goods appears. The first is binomial, f b (n)=p n (1-p) N-n N!/(n!(N-n)!), p=0.2, in which the probability of each good being included in a given bid is independent of which other goods are included. The second distribution is of exponential form, f e (n)=Ce -x/p , p=5, representing the case where a bid for n+1 goods appears e -1/p times less often than a bid for n goods. The prices of bids for n goods is uniformly distributed between [n(1-d), n(1+d)], d=0.5.</p><p>We do not present any experiments varying the number of goods in this paper because of space constraints. We found that for both CASS and VSA running time increased exponentially with the number of goods.</p><p>We ran our experiments on a 450MHz Pentium II with 256MB of RAM, running Windows NT 4.0. 30 MB of RAM was used for the CASS cache. All algorithms were implemented in C++.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Results</head><p>To answer question (1) we measured the running time of CASS, VSA and the brute-force algorithm. Since VSA is not guaranteed to reach the optimal revenue, it was passed this value-calculated by CASS-and stopped when it found an allocation with revenue of at least 95% of optimal. All the results reported here are averages over 10 different runs. <ref type="figure">Figure 1</ref> shows running time as a function of the number of bids with a binomial distribution, with the number of goods fixed at 30. <ref type="figure">Figure 2</ref> shows the same thing for an exponential distribution, without the brute-force algorithm. To answer question <ref type="formula">(2)</ref>, we measured the optimality of the output of both VSA and CASS as a function of time. <ref type="figure">Figure 3</ref> shows both algorithms' performance with 15000 bids for 150 goods with a binomial distribution and <ref type="figure">Figure 4</ref> shows 4500 bids for 45 goods with an exponential distribution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Discussion</head><p>CASS demonstrates excellent performance both in finding optimal allocations and as an anytime algorithm. In Figures 1 and 2 CASS remains roughly an order of magnitude faster than VSA as the number of bids increases. Both curves appear to grow sub-linearly on the logarithmic graph, suggesting polynomial-time performance. As the size of the problem is increased <ref type="figure">(Figures 3 and 4)</ref> CASS still performs better than VSA for the binomial distribution, but initially offers worse anytime performance for the exponential distribution. These results-and other experiments we have conducted-suggest that VSA is most likely to outperform CASS when the number of goods is relatively large compared to average bid length. (Note that VSA runs to a time limit, so the point at which VSA's curve ends is not meaningful.) CASS's effectiveness is strongly influenced by the distribution of bids, particularly as the number of goods increases. If bids contain a large number of goods on average, improvement #1 will have a substantial effect because more bins will be skipped between every pair of bins that are considered, eliminating the need to individually examine all the bids in those bins. However, our caching scheme favors distributions with small bids because they increase the likelihood that partial allocations will be cacheable. The pruning technique described in 4.4 reduces the number of nodes that are cached, lowering memory consumption and making CASS feasible for larger problems. Our second pruning technique often improves performance by two orders of magnitude, though it is most effective when the variance of average price per bid is relatively small. This technique also reduces the optimal cache size, further reducing memory consumption. As a result of pruning, with pruning the amount of memory available for caching does not seem to be a limiting factor in CASS's performance. VSA is interesting for two reasons. Firstly, it appears to offer good anytime performance in cases with small bids and many goods. Secondly, it provides a case study in the power of market-based optimization. Further work is needed to reach firm conclusions, but it appears that as a centralized optimization method VSA is overshadowed by other techniques. However, other attractions of market-based optimization-in particular its inherent distributed nature and robustness to change in problem specification-may make VSA attractive for some domains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related and Ongoing Work</head><p>As far as we are aware, the work most directly relevant to the ideas presented here is a paper by <ref type="bibr">Sandholm [1999]</ref> that appears in these proceedings. Sandholm's Bidtree algorithm appears to be closely related to CASS, but important differences hold. In particular, Bidtree performs a secondary depth-first search to identify non-conflicting bids, whereas CASS's structured approach allows it to avoid considering most conflicting bids. Bidtree also performs no pruning analogous to our Improvement #3 and no caching. On the other hand, Bidtree uses an IDA* search strategy rather than CASS's branch-and-bound approach, and does more preprocessing. We intend to continue studying the differences between these algorithms, including differences in experimental settings.</p><p>Our problem can of course be abstracted away from the auction motivation and viewed as a straightforward combinatorial optimization. This suggests a wealth of literature that could be applied. We are currently implementing some of these techniques and comparing them to our present results. We are especially interested in comparisons with mixed-integer programming and greedy methods. In particular, we have been investigating a new algorithm <ref type="bibr">5</ref> that orders bids in descending order according to average price per good, and does a depth-first search with extensive pruning. This algorithm appears to offer performance similar to CASS, and we intend to report on it in a follow-up paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>We have proposed two novel algorithms to mitigate the computational complexity of combinatorial auctions.</p><p>CASS determines optimal allocations very quickly, and also provides good anytime performance. In the future we intend to pursue a formal analysis of CASS's computational complexity, and to test both CASS and VSA with data collected from real bidders.</p><p>VSA can determine near-optimal allocations even in cases with hundreds of goods and tens of thousands of bids. Since it has been infeasible to run CASS on much larger problems we do not yet know how close VSA comes to optimality in these cases. An investigation of VSA's limits remains an area for future work.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>the largest average price per bid of bids containing good g. We backtrack at any point during the search with allocation F if p(F) + ∑ ∉F g g o )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 : Running Time Comparison (Binom. Dist.Figure 2 : Running Time Comparison (Exp. Dist.TT im e (s ec ) - 4 5 g o o d s, 45 00 b id s , e xp o n e n tia l d is trib .Figure 4 :</head><label>124454</label><figDesc>Figure 1: Running Time Comparison (Binom. Dist.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>)=∑ b∈F p b and let O denote the optimal set of winners. Split the current set of winners W into two parts O 1 and W 2 such that O 1 =O∩W and W 2 =W∩¬O 1 . Also split O into O 1 and O 2 such that O 1 is defined as before and O 2 = O ∩ ¬O 1 . Further, split G into G 1 and G 2 such that G 1 =∪ b∈O1 G b and G 2 =G∩¬G 1 . By the assumption, for each currently losing bidder, the sum of the current highest prices of the goods needed exceeds the bidder's budget. This is especially true for bidders in O 2 , i.e., ∀b∈O 2 p b &lt;∑ g∈Gb h g where h g is the current highest price of good g. It follows that r(O 2 ) = ∑ b∈O2 p b ≤ ∑ b∈O2 ∑ g∈Gb h g ≤ ∑ g∈G2 h g = ∑ b∈W2 ∑ g∈Gb h g = ∑ b∈W2 p b = r(W 2 ). (Remember that the minimum price of a good that is not allocated to any agent is zero and agents always bid their entire budgets.) The inequality means that W is optimal because r</head><label></label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Proof] Suppose B={a,b,c} where a={p a , {1,2}}, b={p b , {2,3}}, and c={p c , {3, 1}}. Suppose further that p a &lt; p b + p c , p b &lt; p c + p a , and p c &lt; p a + p b .is currently winning. Then h 1 +h 2 =p a and h 3 =0. Assume that neither b nor c bids in the current round. Then for each of b and c, the sum of the prices of goods needed must be larger than or equal to the budget, i.e., h 2 +h 3 =h 2 ≥p b and h 3 +h 1 =h 1 ≥p c . This means that p a = h 1 +h 2 ≥p b +p c and contradicts p a &lt;p b +p c . This argument</head><label></label><figDesc>doesn't depend on the bidding strategy as long as an agent bids if and only if their budget exceeds the sum of the minimum prices of the goods needed.</figDesc><table>Because the real bids are 
mutually exclusive, at most one virtual bidder becomes the 
temporary winner. If none is winning, h 1 =h 2 =h 3 =0 and all 
the bidders bid in the current round. Assume here that 
bidder a </table></figure>

			<note place="foot" n="1"> This material is based upon work supported by DARPA under the CoABS program, contract #F30602-98-C-0214, and by a Stanford Graduate Fellowship.</note>

			<note place="foot" n="2"> Auctions in which combinatorial bidding is allowed are alternately called combinatorial and combinational.</note>

			<note place="foot" n="3"> The GVA has the additional shortcoming of requiring bidders to submit an unreasonably large number of bids, but we do not address this issue here.</note>

			<note place="foot" n="4"> We do not analyze the impact of the approximation on the equilibrium strategies in auction mechanisms such as GVA; we will address this issue in a future paper.</note>

			<note place="foot" n="5"> This ongoing work is joined by Liadan O&apos;Callaghan and Daniel Lehmann.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A binary conflict ascending price (BICAP) mechanism for the decentralized allocation of the right to use railroad tracks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Banks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Industrial Organization</title>
		<editor>Amy E. Cortese and Marcia Stepanek</editor>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="71" to="84" />
			<date type="published" when="1989" />
			<publisher>World Scientific</publisher>
		</imprint>
		<respStmt>
			<orgName>California Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note>Market-Based Control: A Paradigm for Distributed Resource Allocation. Cortese and Stepanek. Good-bye to fixed pricing? Business Week</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Andreu Mas-Colell</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mas-Colell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<publisher>Michael D</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Putting auction theory to work: the simultaneous ascending auction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jerry</forename><forename type="middle">R</forename><surname>Whinston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Green</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Microeconomic Theory ; Paul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tracey</forename><surname>Milgrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mullen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Michael</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<publisher>Mullen and Wellman</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Dept. Economics, Stanford University</orgName>
		</respStmt>
	</monogr>
	<note>Working paper 98-002</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A market-oriented programming environment and its application to distributed multicommodity flow problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wellman ; Rothkopf</surname></persName>
		</author>
		<idno>95-09</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI-99)</title>
		<editor>M.J. Wooldridge, J.P. Muller, and M. Tambe</editor>
		<meeting>the International Joint Conference on Artificial Intelligence (IJCAI-99)<address><addrLine>Stockholm; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Wellman</publisher>
			<date type="published" when="1993" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1" to="23" />
		</imprint>
	</monogr>
<note type="report_type">DIMACS Technical Report</note>
	<note>Tuomas Sandholm. An algorithm for optimal winner determination in combinatorial auctions</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
