<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:32+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Highly Scalable Algorithms for Rectilinear and Octilinear Steiner Trees £</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><forename type="middle">Z</forename><surname>Zelikovsky</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Georgia State University</orgName>
								<address>
									<addrLine>University Plaza</addrLine>
									<postCode>30303</postCode>
									<settlement>Atlanta</settlement>
									<region>Georgia</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Ion I. M˘ andoiu</orgName>
								<orgName type="department" key="dep2">Departments of CSE and ECE</orgName>
								<orgName type="institution">University of California at San Diego</orgName>
								<address>
									<addrLine>La Jolla</addrLine>
									<postCode>92093-0114</postCode>
									<region>California</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Highly Scalable Algorithms for Rectilinear and Octilinear Steiner Trees £</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>The rectilinear Steiner minimum tree (RSMT) problem, which asks for a minimum-length interconnection of a given set of terminals in the rectilinear plane, is one of the fundamental problems in electronic design automation. Recently there has been renewed interest in this problem due to the need for highly scalable algorithms able to handle nets with tens of thousands of terminals. In this paper we give a practical Ç´ÒÐÓÓ ¾ Òµ heuristic for computing near-optimal rectilinear Steiner trees based on a batched version of the greedy triple contraction algorithm of Zelikovsky [21]. Experiments conducted on both random and industry testcases show that our heuristic matches or exceeds the quality of best known RSMT heuristics, e.g., on random instances with more than 100 terminals our heuristic improves over the rectilinear minimum spanning tree by an average of 11%. Moreover, our heuristic has very well scaling runtime, e.g., it can route a 34k-terminals net extracted from a real design in less than 25 seconds compared to over 86 minutes needed by the Ç´Ò ¾ µ edge-based heuristic of Borah, Owens, and Irwin [3]. Since our heuristic is graph-based, it can be easily modified to handle practical considerations such as routing obstacles, preferred directions, via costs, and octilinear routing-indeed, experimental results show only a small factor increase in runtime when switching from rectilinear to octilinear routing.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>The rectilinear Steiner minimum tree (RSMT) problem, which asks for a minimum-length interconnection of a given net (i.e., set of terminals) in the rectilinear plane, is one of the fundamental problems in electronic design automation. Although deep-submicron technology has introduced additional routing objectives, minimum length continues to be the primary objective when routing non-critical nets, since the minimum-length interconnection has minimum total capacitance and occupies minimum amount of area.</p><p>Of growing interest are practical methods for minimumlength rectilinear routing of nets with up to tens of thousands of terminals. Nets of this size, e.g., scan enable, are becoming more common in modern designs due to the increased emphasis on design for test <ref type="bibr" target="#b0">[1]</ref>. Such nets are non-critical and tend to consume significant routing resources, so minimizing length is the appropriate optimization objective. Furthermore, very large RSMT instances are created by reductions that model non-zero terminal dimensions, e.g., nets with pre-routes. Highquality routing of such instances requires representing each terminal by a set of electrically equivalent points <ref type="bibr" target="#b14">[15]</ref> and this results in RSMT instances with as much as 100,000 points <ref type="bibr" target="#b21">[22]</ref>.</p><p>The main contribution of this paper is a highly scalable heuristic for computing rectilinear Steiner trees. Existing implementations of exact methods <ref type="bibr" target="#b17">[17]</ref> and of best-performing heuristics such as Iterated 1-Steiner <ref type="bibr" target="#b9">[10]</ref> and RajagopalanVazirani <ref type="bibr" target="#b11">[12]</ref> cannot be used on instances with tens of thousands of terminals due to combinatorial explosion and quadratic memory requirements, respectively. Our heuristic requires Ç´Òµ memory and Ç´Ò ÐÓÓ ¾ Òµ time for Ò terminals, and routes, e.g., a 34k-terminals net extracted from a real design in less than 25 seconds compared to over 86 minutes needed by the Ç´Ò ¾ µ edge-based heuristic of <ref type="bibr" target="#b2">[3]</ref>. More importantly, this dramatic reduction in runtime is achieved with no loss in solution quality. On random instances with more than 100 terminals our algorithm improves over the rectilinear minimum spanning tree (MST) by an average of 11%, matching in solution quality the edge-based heuristic of <ref type="bibr" target="#b2">[3]</ref>. To the best of our knowledge, this is the first practical sub-quadratic RSMT heuristic with such performance. ½ Due to considerable potential for further wirelength reductions, recently there has been much interest <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr">18]</ref> in octilinear routing, which allows 񮽙񮽙 AE diagonal interconnect in addition to the traditional horizontal and vertical orientations. ¾ Since our heuristic is graph-based, it can be easily modified to handle octilinear routing -indeed, the results reported in Section V show only a small factor increase in runtime compared ½ The Ç´Ò ÐÓÓ Òµ implementation given in <ref type="bibr" target="#b2">[3]</ref> for the edge-based heuristic requires advanced data structures, potentially involving large hidden constants. We are not aware of any implementation demonstrating the practical applicability of this implementation. to the rectilinear implementation. The heuristic can be similarly extended to handle other practical considerations such as routing obstacles, preferred directions <ref type="bibr" target="#b18">[19]</ref>, and via costs.</p><p>Our highly scalable Steiner tree heuristic, referred to as the batched greedy algorithm (BGA) in the following, derives its efficiency from three key ideas: ¯ Combining the implementation proposed in <ref type="bibr" target="#b4">[5]</ref> for the greedy triple contraction algorithm (GTCA) of Zelikovsky <ref type="bibr" target="#b20">[21]</ref> with the batched method introduced by the Iterated 1-Steiner heuristic of Kahng and Robins <ref type="bibr" target="#b9">[10]</ref>.</p><p>¯ A new divide-and-conquer method for computing a superset of size Ç´Ò ÐÓÓ Òµ of the set of Ç´Òµ triples required by GTCA. ¯ A new linear size data structure that enables finding a bottleneck (i.e., maximum cost) edge on the tree path between two given nodes in Ç´ÐÓÓ Òµ time after Ç´Ò ÐÓÓ Òµ preprocessing, with very low constants hidden under the big Ç. This data structure allows computing the gain of a triple (see Section II for the definition) in Ç´ÐÓÓ Òµ time, leading to an Ç´Ò ÐÓÓ ¾ Òµ implementation of BGA. ¿ The rest of the paper is organized as follows. In Section II we briefly review the greedy triple contraction algorithm of <ref type="bibr" target="#b20">[21]</ref> and describe our new batched greedy algorithm. In the following two sections we describe in detail two of the key BGA subroutines: in Section III we give the new divide-andconquer method for computing the set of Ç´Ò ÐÓÓ Òµ triples used by BGA, while in Section IV we describe the new data structure for computing bottleneck edges. Finally, in Section V we give experimental results comparing BGA with previous implementations of rectilinear and octilinear Steiner tree heuristics and exact algorithms on test cases both randomly generated and extracted from recent VLSI designs.</p><p>¿ Our data structure may be of interest in other applications that require computing bottleneck edges. For example, Zachariasen incorporated it in the beta version of the GeoSteiner 4.0 code for computing optimum geometric Steiner trees. On large instances, computing bottleneck edges with the new data structure was found to be faster, most likely due to improved memory access locality, than look-up in a precomputed matrix <ref type="bibr" target="#b19">[20]</ref>.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. THE GREEDY TRIPLE CONTRACTION AND BATCHED GREEDY ALGORITHMS</head><p>We begin this section by introducing the Steiner tree terminology used in the rest of the paper. A Steiner tree for a set of terminals is a tree spanning the terminals and possibly additional points, called Steiner points. A Steiner tree is called a full Steiner tree if all terminals are leaves (i.e., have degree 1). Any Steiner tree Ì can be split into edge-disjoint full Steiner trees called the full Steiner components of Ì <ref type="bibr" target="#b5">[6]</ref>. A Steiner tree Ì is called 񮽙-restricted if every full component of Ì has at most 񮽙 terminals (an example of a 3-restricted rectilinear Steiner tree is shown in <ref type="figure">Figure 1</ref>). The minimum-cost 3-restricted Steiner tree is in general cheaper than the minimum spanning tree (MST) of the terminals (note that the MST is the minimum-cost 2-restricted Steiner tree of the terminals).</p><p>The greedy triple contraction algorithm (GTCA) in <ref type="bibr" target="#b20">[21]</ref> finds an approximate minimum-cost 3-restricted Steiner tree by greedily choosing 3-restricted full components which reduce the cost of the MST. In order to describe GTCA we need to introduce a few more notations. Let 񮽙 Ë be the complete graph on a given set Ë of terminals, and let Å Ë Ì ´Ëµ be the MST of 񮽙 Ë . A triple 񮽙 is an optimal Steiner tree for a set of three terminals. 񮽙 We denote by 񮽙񮽙ÒØØÖ´񮽙 µ the single Steiner point of 񮽙 and by 񮽙Ó×Ø´񮽙 µ the cost of 񮽙 . In the graph Å Ë Ì ´Ëµ 񮽙񮽙, there are two cycles (see <ref type="figure" target="#fig_1">Figure 2(</ref> GTCA (see <ref type="figure">Figure 3</ref>) repeatedly adds a triple 񮽙 with the largest gain and contracts it, i.e., collapses the three terminals of 񮽙 into a single new terminal. Contraction of a triple is conveniently implemented by adding two new zero-cost edges 񮽙´񮽙 µ µ 񮽙񮽙 ¼ ½ 񮽙 񮽙 ¼ ¾ 񮽙 between the three terminals of 񮽙 (see <ref type="figure" target="#fig_1">Figure   2</ref>(b)). It is easy to see that addition of 񮽙´񮽙 µ changes the MST of 񮽙 Ë -in the updated MST the two edges in 񮽙´񮽙 µ replace the two edges in Ê´񮽙 µ. Finally, GTCA adds all chosen triples to the original MST of 񮽙 Ë and outputs the MST of this union.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1 [2]</head><p>The cost of the rectilinear Steiner tree constructed by GTCA is at most 1.3125 times more than the opti-񮽙 The optimum Steiner tree of 3 given terminals can be computed in constant time under the common geometric metrics, including rectilinear <ref type="bibr" target="#b7">[8]</ref> and octilinear <ref type="bibr" target="#b10">[11]</ref> metrics. mal Steiner tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Input: Set Ë of terminals</head><p>Fößmeier, Kaufmann and Zelikovsky <ref type="bibr" target="#b4">[5]</ref> prove that in order to achieve an approximation ratio of 1.3125 in Theorem 1 it is sufficient to consider only empty tree triples of terminals. A triple 񮽙 is empty if the minimum rectangle bounding the triple does not contain any other terminals and is a tree triple if the center 񮽙 of 񮽙 is adjacent to all terminals of the triple in Å Ë Ì ´Ë · 񮽙µ (or, equivalently, if Ò ´񮽙 µ 񮽙 ¼). As shown in <ref type="bibr" target="#b4">[5]</ref>, there are at most ¿¿Ò empty tree triples. Even so, finding the best triple in Step 3 of GTCA is very time consuming. An efficient Ç´Ò ¾ ÐÓÓ Òµ time implementation of GTCA should maintain dynamic minimum spanning trees for which, to date, there is no data structure able to handle instances with tens of thousands of nodes in practical running time. Existing data structures are difficult to implement and involve big asymptotic constants, see Cattaneo et al. <ref type="bibr" target="#b3">[4]</ref> for a recent empirical study.</p><p>Our new heuristic, the batched greedy algorithm (BGA) (see <ref type="figure">Figure 4</ref>) adopts the batched method from <ref type="bibr" target="#b9">[10]</ref>, substantially reducing running time by relaxing the greedy rule used to select triples in GTCA. After contracting a triple we continue by picking the best triple among those with unchanged gain; in general this may not be the best triple overall. Note that a triple 񮽙 can change its gain only if one of the edges in Ê´񮽙 µ is removed when contracting other triple -if none of the contracted triples removes edges from Ê´񮽙 µ then the gain of 񮽙 is unchanged. When done with one such batched phase (the body of the while loop in Step 4) it is still possible to have positive gain triples. Therefore, we recompute triple gains and repeat the batched phase selection until no positive gain triples are left. To enable further improvements, we add the centers of triples selected in Step 4 to the terminal set then iterate Steps 2-5 (which constitute a round of the algorithm) until no more centers are added to the tree.</p><p>In next section we show how to compute in Ç´Ò ÐÓÓ Òµ time a set of Ç´Ò ÐÓÓ Òµ triples containing all empty tree triples (see Theorem 3). Then, in Section IV we describe a data structure which enables computing a bottleneck edge on the tree path between any two given nodes in <ref type="bibr">Ç´ÐÓÓ</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. GENERATION OF TRIPLES</head><p>In this section we show how to compute in Ç´Ò ÐÓÓ Òµ time a set of Ç´Ò ÐÓÓ Òµ triples containing all empty tree triples. For simplicity we assume that terminals are in general position, i.e., no two of them share the same Ü-or Ý-coordinate. This assumption is not restrictive since we can always break ties, e.g., according to terminal IDs.</p><p>In a triple, the terminal which does not share Ü-and Ý-coordinates with the center is called diagonal. There are 4 types of triples depending on where the diagonal terminal lies with respect to the center: a triple is called north-west if the diagonal terminal is in the north-west quadrant of the center (see <ref type="figure">Figure 1)</ref>; north-east, south-west, and south-east triples are defined similarly. We will use the divide and conquer method to find Ç´Ò ÐÓÓ Òµ north-west triples containing all north-west empty tree triples. Triples of the other types are obtained by reflection and application of the same algorithm.</p><p>For finding north-west triples we recursively partition the terminals into (almost) equal halves with a bisector line paral- the half-planes defined by the bisector line, and let 񮽙, Ê, and 񮽙 be the diagonal, right, and bottom terminals of a north-west triple that is intersected by the bisector line (see <ref type="figure" target="#fig_2">Figure 5</ref>). We distinguish the following 4 cases:</p><p>Case 1: Ê ¾ Ì Ê and 񮽙 ¾ ÄÄ. <ref type="figure" target="#fig_3">Figure 6</ref> (a) illustrates how to compute for each diagonal terminal 񮽙 the unique terminal Ê that can serve as a right terminal in an empty north-west triple with 񮽙 as the diagonal terminal. All terminals in Ì Ê are processed in Ü-ascending order as follows: (1) if the next terminal has Ý larger then the current terminal, then a dashed pointer is set from the next to the current terminal, and then the current terminal is advanced to the next terminal; (2) otherwise, a solid pointer is set from the current terminal to the next one, and the current terminal is moved back along the dashed pointer (if it exists, otherwise the current terminal is advanced to the next). Clearly this procedure is linear since the runtime is proportional to the number of pointers established and each terminal has at most two pointers (one solid and one dashed). When processing of the points in Ì Ê is finished, each solid arc connects a terminal 񮽙 with the leftmost terminal in TR lower than and to the right of 񮽙, i.e., with the unique terminal Ê that can serve as a right terminal in an empty north-west triple with 񮽙 as the diagonal terminal.</p><p>In order to find all Case 1 north-west triples, we must find for each solid arc´Êµarc´Êµ in Ì Ê the node 񮽙 in ÄÄ which can complete the triple, i.e., the node 񮽙 with maximum Ý-coordinate in the vertical strip defined by 񮽙 and Ê. This is done in linear time by one traversal of the terminals in LB in Ü-ascending order (i.e., strip by strip) while computing the highest point in each strip.</p><p>Case 2: Ê¾ Ì Ê and 񮽙 ¾ ÄÄ. For each terminal Ê, the unique terminal in Ì Ê that can serve as the bottom terminal in an empty north-west triple with Ê as the right terminal (i.e., the highest terminal in Ì Ê lower and to the left of Ê) can be found by a procedure similar to the one in Step 1. Cf. <ref type="bibr" target="#b4">[5]</ref>, an arc   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. COMPUTING MAXIMUM COST EDGE ON A TREE PATH</head><p>It is easy to see that computing the gain of a triple 񮽙 and the edges in Ê´񮽙 µ reduces to finding bottleneck (i.e., most expensive) edges on the tree paths between pairs of terminals in 񮽙 . The hierarchical greedy preprocessing (HGP) algorithm given in <ref type="figure" target="#fig_4">Figure 7</ref> computes for a given tree on Ò terminals two auxiliary arrays, ÔÔÖÒØ and , with at most ¾Ò ½ elements each. Using these arrays, the bottleneck tree edge between any two terminals Ù and Ú can be found in Ç´ÐÓÓ Òµ using the algorithm in <ref type="figure">Figure 8</ref>.</p><p>Assuming that edges are sorted in ascending order of cost, HGP is equivalent to the following recursive procedure. First, for each node Ù, direct the cheapest edge incident to Ù, away from Ù, and save its index in´Ùµin´Ùµ. As a result some edges remain undirected, some become unidirected, and some become bidirected. In the subgraph induced by the (uni-and bi-) directed edges, each connected component consists of a bidirected edge with two (possibly empty) arborescences attached to its ends. HGP collapses each such connected component Ã into a single node Õ, then sets ÔÔÖÒØ´Ùµ to Õ for every Ù ¾ Ã.</p><p>Since each connected component contains at least one bidirected edge, no more than ÒÒ¾ collapsed component nodes are created. The procedure is repeated on the tree induced by collapsed components until there is a single node left. The total runtime of HGP is Ç´Ò ÐÓÓ Òµ because of the edge sorting in Step 1, remaining HGP steps require Ç´Òµ time.</p><p>Clearly, edge costs decrease along any directed path of a connected component Ã. Therefore, if Ù and Ú are two ver-  <ref type="figure">Figure 8</ref> is an iterative implementation of this recursive definition. Since the hierarchy of collapsed connected components has a depth of at most ÐÓÓ Ò, we get:</p><formula xml:id="formula_0">Theorem 4</formula><p>The algorithm in <ref type="figure">Figure 8</ref> finds the maximum cost edge on the tree path connecting two given nodes in Ç´ÐÓÓ Òµ time after Ç´Ò ÐÓÓ Òµ time for hierarchical greedy preprocessing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. EXPERIMENTAL RESULTS</head><p>Comprehensive experimental evaluation indicates that the Iterated 1-Steiner heuristic of Kahng and Robins <ref type="bibr" target="#b9">[10]</ref> significantly outperforms in solution quality the RSMT heuristics proposed prior to 1992 <ref type="bibr" target="#b8">[9]</ref>. Since then, the edge-based heuristic of Borah, Owens, and Irwin <ref type="bibr" target="#b2">[3]</ref>, and the IRV heuristic <ref type="bibr" target="#b11">[12]</ref> have been reported to match or slightly exceed Iterated 1-Steiner in solution quality. However, among these best-performing heuristics only the edge-based heuristic can be applied to instances with tens of thousands of terminals, since current implementations of Iterated 1-Steiner and IRV require quadratic memory. Besides Borah's Ç´Ò ¾ µ implementation of the edge-based heuristic, we compared our Ç´Ò ÐÓÓ ¾ Òµ batched greedy algorithm to the recent Ç´Ò ÐÓÓ ¾ Òµ Prim-based heuristic of Rohe <ref type="bibr" target="#b13">[14]</ref>. For comparison purposes, we also include results from our implementation of the Guibas-Stolfi Ç´Ò ÐÓÓ Òµ rectilinear MST algorithm <ref type="bibr" target="#b6">[7]</ref>, and, whenever possible, the optimum RSMTs computed using the beta version of the GeoSteiner 4.0 algorithm recently announced in <ref type="bibr" target="#b12">[13]</ref>.</p><p>All heuristics and MST algorithms were run on a dual 1.4 GHz Pentium III Xeon server with 2GB of memory running Red Hat Linux 7.1. The GeoSteiner code using the CPLEX 6.6 linear programming solver was run on a 360 MHz SUN Ultra 60 workstation with 2 GB of memory under SunOS 5.7. The test bed for our experiments consisted of two categories of instances: instances drawn uniformly at random from a ½񮽙 ¼¼¼񮽙 ¼¼¼ ¢½񮽙 ¼¼¼񮽙 ¼¼¼ grid, ranging in size between 100 and 500,000 terminals, and a set of 8 testcases extracted from recent industrial designs, ranging in size between 330 and 34,000 terminals. <ref type="table" target="#tab_7">Table I</ref> gives the percent improvement over the rectilinear MST and running time (in CPU seconds) for experiments on rectilinear instances. On random instances, the batched greedy heuristic matches or slightly exceeds in average solution quality the edge-based heuristic of <ref type="bibr" target="#b2">[3]</ref>. Both batched greedy and the edge-based heuristic improve the rectilinear MST by an average of 11% in our experiments. This is roughly 1% more than the average improvement achieved by the Prim-based heuristic of <ref type="bibr" target="#b13">[14]</ref>, and is within 0.7% of the optimum average improvement for the sizes for which the optimum could be computed using GeoSteiner. Results on VLSI instances show that the relative performance of the heuristics is the same to that observed on random instances. However, the improvement over the rectilinear MST and the gaps between heuristics are smaller in this case.</p><p>The results in <ref type="table" target="#tab_7">Table I</ref> show that the batched greedy algorithm is highly scalable. Even though batched greedy is not as fast as the MST or the Prim-based heuristic of <ref type="bibr" target="#b13">[14]</ref>, it can easily handle up to hundreds of thousands of terminals in minutes of CPU time. Compared to Borah's Ç´Ò ¾ µ implementation of the edge-based heuristic, batched greedy is two or more orders of magnitude faster as soon as the number of terminals gets into the tens of thousands.</p><p>The batched greedy algorithm can be easily adapted to other cost metrics, such as octilinear routing. The only required modifications are in the distance formula (see Footnote 2) and in the procedure for finding the optimum Steiner point of a triple. <ref type="table" target="#tab_7">Table II</ref> gives results obtained by the octilinear versions of the Guibas-Stolfi MST, Ç´Ò ¾ µ edge-based, 񮽙 batched greedy, and GeoSteiner 4.0 algorithms. Octilinear batched greedy is almost always better than the octilinear edge-based heuristic, and very close to optimum for the instances for which the latter is available. Furthermore, octilinear batched greedy remains highly scalable, with just a small factor increase in runtime compared to the rectilinear version.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CONCLUSIONS</head><p>Non-critical nets with tens of thousands of terminals are becoming more common in modern designs due to the increased emphasis on design for test. Even a single net of this size can render quadratic Steiner tree algorithms impractical, given the stringent constraints on routing runtime (e.g., designers expect full chip global and detailed routing to be completed overnight). In this paper we have given a highquality Ç´Ò ÐÓÓ ¾ Òµ heuristic that can practically handle these nets without compromising solution quality.</p><p>Since our heuristic is graph-based, it can be easily modified to handle other cost metrics, e.g., octilinear routing. We are 񮽙 We use our own octilinear modification of Borah's code since the implementation in <ref type="bibr" target="#b10">[11]</ref> appears to have cubic rather than quadratic runtime. currently extending the heuristic to handle other practical considerations, such as routing obstacles, preferred directions, and via costs. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>£</head><label></label><figDesc>Work partially supported by Cadence Design Systems, Inc., the MARCO Gigascale Silicon Research Center, NSF Grant CCR-9988331, Award No. MM2-3018 of the Moldovan Research and Development Association (MRDA) and the U.S. Civilian Research &amp; Development Foundation for the Indepen- dent States of the Former Soviet Union (CRDF), and by the State of Georgia's Yamacraw Initiative.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. The MST of 񮽙 Ë (a) before and (b) after contraction of the triple 񮽙.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Four cases of partitioning of a north-west triple.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Case 1: (a) Finding the right terminal for each diagonal terminal, e.g.,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. The hierarchical greedy preprocessing algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>¾ The octilinear distance between points´ÜÜpoints´ÜÜ Ýµ and´Üand´Ü ¼ 񮽙 Ý ¼ µ is equal to</head><label>¾</label><figDesc></figDesc><table>ÑÑÜ񮽙񮽙Ü Ü ¼ 񮽙񮽙 񮽙Ý Ý ¼ 񮽙񮽙 · ´ Ô 
¾ ½µ ÑÑÒ񮽙񮽙Ü Ü ¼ 񮽙񮽙񮽙Ý Ý ¼ 񮽙񮽙 and is al-
ways smaller than the rectilinear distance, 񮽙Ü Ü ¼ 񮽙 · 񮽙Ý Ý ¼ 񮽙, unless the 

two points are on the same horizontal or vertical line, in which case the two 
distances are equal. 

North-west triple of terminals 

Diagonal terminal 

Full Components 

center 

Fig. 1. A 3-restricted rectilinear Steiner tree partitioned into full components. 
The dark full component is a north-west triple. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>a)). To obtain an MST of this graph we should remove the most expensive edge from each cycle. Let 񮽙 ½ and 񮽙 ¾ be the two edges that must be removed and let Ê´񮽙 µ 񮽙 񮽙񮽙 ½ 񮽙 񮽙 ¾ 񮽙. The gain of 񮽙 is Ò ´񮽙 µ µ 񮽙Ó×Ø´Ê´񮽙 µµ 񮽙Ó×Ø´񮽙 µ.</head><label></label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Ç´È Ò ÐÓÓ ¾ Òµ, where È is the total number of batched phases and Ò is the number of terminals. In practice the total number of phases È is small and can be bounded by a constant. Thus, the runtime of BGA is</head><label></label><figDesc></figDesc><table>Òµ time after 
Ç´Ò ÐÓÓ Òµ time preprocessing. Since computing the gain of 
a triple amounts to 3 bottleneck edge computations, this leads 

Input: Set Ë of terminals 
Output: Steiner tree Ì spanning Ë 

1. Compute the minimum spanning tree of Ë, Å Ë Ì ´Ëµ 
2. Compute a set Ì Ö Ô Ð × , of size Ç´Ò ÐÓÓ Òµ, containing all 
empty tree triples 

3. Ë È񮽙 񮽙 
4. While Ì ÖÔÐ× 񮽙 񮽙 񮽙 do 
For each 񮽙 ¾ Ì Ö Ô Ð × compute Ê´񮽙 µ, 񮽙´񮽙 µ, and 

Ò ´񮽙 µ, discarding triples with non-positive gain 
Sort Ì ÖÔÐ× in descending order of gain 
Unmark all edges of Å Ë Ì ´Ëµ 

For each 񮽙 ¾ Ì Ö Ô Ð × do 

If both edges in Ê´񮽙 µ are unmarked, then mark 
them and replace them in the MST with the 
two edges in 񮽙´񮽙 µ, i.e., 

Å Ë Ì ´Ëµ 񮽙 Å Ë Ì ´Ëµ Ê´񮽙 µ · 񮽙´񮽙 µ 

Ë È񮽙 Ë È· 񮽙񮽙ÒØØÖ´񮽙 µ 

5. If Ë È񮽙 񮽙 then return the minimum spanning tree of Ë, else 
Ë 񮽙 Ë · Ë È 

Compute the minimum spanning tree of Ë and discard all 
Steiner points with degree 1 or 2 
Go to Step 2 

Fig. 4. The batched greedy algorithm. 

to an Ç´Ò ÐÓÓ ¾ Òµ time implementation of the batched phase 
algorithm. This gives the following: 

Theorem 2 The running time of the batched greedy algorithm 
is Ç´Ò ÐÓÓ 
¾ Òµ. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>set of size Ç´Ò ÐÓÓ Òµ containing all empty tree triples can be computed in Ç´Ò ÐÓÓ Òµ time.Weighted tree Ì 񮽙´Î񮽙´񮽙´Î Î Ó × Ø µ with Î 񮽙 񮽙½񮽙 ¾ Ò 񮽙 Output: Arrays ÔÔÖÒØ´񮽙µ and´񮽙µand´񮽙µ, 񮽙 񮽙 ½ ¾Ò ½ 1. Sort tree edges 񮽙½񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 Ò ½ in ascending order of cost 2. Initialization: ÒÒÜØ 񮽙 Ò For each 񮽙 񮽙 ½ 񮽙 ¾ ¾Ò ½ do</head><label></label><figDesc></figDesc><table>g., 

if 񮽙 񮽙 ½ , then Ê 񮽙 񮽙 , if 񮽙 񮽙 ¿ , then Ê 񮽙 񮽙 , etc. (b) Finding highest 

terminals in the strips corresponding to consecutive terminals. 

´ÊÊµ in Ì Ê is completed into a tree north-west triple only 
when the diagonal node 񮽙 is the closest to Ê (and therefore 
to 񮽙) in the octant of ÄÄ containing points higher than Ê. 
To find the diagonal points 񮽙 for each arc´ÊÊµarc´ÊÊµ in Ì Ê , we 
simultaneously traverse terminals in Ì Ê in Ý-ascending order 

and terminals in ÄÄ in´Üin´Ü Ýµ-ascending order as follows: 

While there are unprocessed terminals in both Ì Ê and ÄÄ, do 

¯ Advance in Ì Ê until we reach a terminal Ê which has an 

arc to the associated 񮽙 

¯ Advance in ÄÄ until we reach a terminal 񮽙 higher than 

Ê 

¯ Assign 񮽙 to Ê 

Note that triples found bye the above procedure are not neces-
sarily empty. With a more careful implementation it is possi-
ble to avoid generating non-empty triples, however this would 
not change the asymptotic number of triples generated or the 
worst-case running time of the algorithm. 

Case 3: Ê ¾ Ì Ê and ¾ ÄÄ. It is equivalent to the case 

1 after reflection over bisector. 

Case 4: 񮽙 ¾ Ì Ê and Ê¾ ÄÄ. It is equivalent to the case 

2 after reflection over bisector. 

Theorem 3 A Proof. Each north-west empty tree triple crossing the divid-
ing diagonal must fall in one of the 4 cases considered and 
finding all crossing triples takes linear time. Thus, the running 
time is given by the recurrence Ì ´Òµ µ ¾ Ì ´ÒÒ¾µ · Ç´Òµ, i.e., 
Ì ´Òµ 񮽙 Ç´Ò ÐÓÓ Òµ. The number of triples generated by the 
divide-and-conquer algorithm is also Ç´Ò ÐÓÓ Òµ by the same 
recurrence; notice that each recursive step generates a linear 
number of triples. The same argument applies to the other 3 
triple types. 

Ù Ø 

Input: ÔÔÖÒØ´񮽙µ 񮽙 AE Á Ä 
´񮽙µ 񮽙 AE Á Ä 
3. For each edge 񮽙񮽙 񮽙´ÙÙ񮽙´񮽙´ÙÙ Úµ, 񮽙 񮽙 ½ Ò ½, do 
While Ù 񮽙 񮽙 Ú and ÔÔÖÒØ´Ùµ 񮽙 񮽙 AE Á Ä and 
ÔÔÖÒØ´Úµ 񮽙 񮽙 AE Á Ä do 
Ù 񮽙 ÔÔÖÒØ´Ùµ 
Ú 񮽙 ÔÔÖÒØ´Úµ 

If ÔÔÖÒØ´Ùµ µ ÔÔÖÒØ´Úµ µ AE Á Ä , then 

ÒÒÜØ 񮽙 ÒÒÜØ · ½ 
ÔÔÖÒØ´Ùµ 񮽙 ÔÔÖÒØ´Úµ 񮽙 ÒÒÜØ´Ùµ ÒÒÜØ´Ùµ 񮽙´Úµ񮽙´Úµ 񮽙 񮽙 
If ÔÔÖÒØ´Ùµ µ AE Á Ä and ÔÔÖÒØ´Úµ 񮽙 񮽙 AE Á Ä , then 
ÔÔÖÒØ´Ùµ 񮽙 ÔÔÖÒØ´Úµ´Ùµ ÔÔÖÒØ´Úµ´Ùµ 񮽙 񮽙 
If ÔÔÖÒØ´Ùµ 񮽙 񮽙 AE Á Ä and ÔÔÖÒØ´Úµ µ AE Á Ä , then 
ÔÔÖÒØ´Úµ 񮽙 ÔÔÖÒØ´Ùµ´Úµ ÔÔÖÒØ´Ùµ´Úµ 񮽙 񮽙 

4. Output the arrays ÔÔÖÒØ´񮽙µ and´񮽙µand´񮽙µ 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>Input : Tree edges 񮽙½ Ò ½ in ascending order of cost, arrays ÔÔÖÒØ´񮽙µ and´񮽙µand´񮽙µ, 񮽙 񮽙 ½ ¾Ò ½, and nodes ÙÙ Ú ¾ Î Output: Maximum cost edge on the tree path between Ù and Ú</head><label>:</label><figDesc></figDesc><table>1. 񮽙ÒÒÒÜ ½, 
2. While Ù 񮽙 񮽙 Ú do 
񮽙ÒÒÒÜ 񮽙 ÑÑÜ񮽙ÒÒÒÜÜ´Ùµ´Úµ񮽙ÑÑÜ񮽙ÒÒÒÜÜ´ÙµÑÑÜ񮽙ÒÒÒÜÜ´Ùµ´Úµ񮽙 
Ù 񮽙 ÔÔÖÒØ´Ùµ 
Ú 񮽙 ÔÔÖÒØ´Úµ 

3. Return 񮽙 񮽙ÒÒÒÜ 

Fig. 8. Subroutine for computing the maximum cost edge on the tree path 

between nodes Ù and Ú. 

tices of Ã, then the index of the maximum cost edge on the 
tree path between Ù and Ú is ÑÑÜ񮽙´Ùµ´Úµ񮽙ÑÑÜ񮽙´Ùµ´Úµ񮽙. If Ù and 
Ú are in different components Ã and Ã ¼ , we need to compute 
the maximum between´Ùµbetween´Ùµ, ´Úµ, and the maximum 
index of the most expensive edge on the path between Ã and 
Ã ¼ in the tree Ì with collapsed connected components. The 
algorithm in </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>TABLE I PERCENT IMPROVEMENT OVER MST AND CPU TIME OF THE COMPARED RECTILINEAR STEINER TREE</head><label>I</label><figDesc></figDesc><table>ALGORITHMS 
#Term. 
MST 
Prim-Based 
Edge-Based 
Batched Greedy 
GeoSteiner 4.0 
Len.(񮽙m) 
CPU 
%Imp. 
CPU %Imp. 
CPU 
%Imp. 
CPU 
%Imp. 
CPU 
Random instances (average results over 10 instances) 
100 
85169.9 
0.0005 
9.78 
0.001 
10.97 
0.006 
10.99 
0.003 
11.66 
0.555 
500 
184209.7 
0.0036 
10.08 
0.007 
11.12 
0.216 
11.17 
0.081 
11.76 
15.205 
1000 
258926.8 
0.0079 
10.04 
0.014 
10.96 
0.939 
10.99 
0.230 
11.61 
117.916 
5000 
573178.8 
0.0501 
10.02 
0.082 
11.02 
56.348 
11.05 
1.903 
-
-
10000 
809343.5 
0.1268 
10.04 
0.191 
11.01 
415.483 
11.05 
5.192 
-
-
50000 
1808302.7 
1.2330 
10.05 
1.320 
11.01 
16943.777 
11.06 
69.043 
-
-
100000 
2555821.9 
3.1150 
10.08 
3.143 
11.04 
61771.928 
11.08 
195.589 
-
-
500000 
5710906.8 
22.9130 
10.07 
20.570 
-
-
11.08 
1706.765 
-
-
VLSI instances 
337 
247.7 
0.0020 
5.96 
0.000 
6.50 
0.060 
6.43 
0.040 
6.75 
16.040 
830 
675.6 
0.0055 
3.10 
0.010 
3.19 
0.320 
3.20 
0.080 
3.26 
9.480 
1944 
452.2 
0.0165 
6.86 
0.040 
7.77 
3.640 
7.85 
0.400 
8.15 
1304.270 
2437 
578.8 
0.0217 
7.09 
0.040 
7.96 
5.740 
7.96 
0.680 
8.34 
13425.310 
2676 
887.2 
0.0235 
8.07 
0.040 
8.99 
5.340 
8.93 
0.770 
9.38 
430.800 
12052 
2652.7 
0.1378 
7.65 
0.180 
8.46 
540.840 
8.45 
5.230 
-
-
22373 
13962.5 
0.3419 
8.99 
0.480 
9.83 
2263.760 
9.85 
13.060 
-
-
34728 
9900.5 
0.5455 
8.16 
0.690 
9.01 
5163.060 
9.05 
24.200 
-
-

TABLE II 
PERCENT IMPROVEMENT OVER MST AND CPU TIME OF THE COMPARED OCTILINEAR STEINER TREE ALGORITHMS 
#Term. 
MST 
Edge-Based 
Batched Greedy 
GeoSteiner 4.0 
Len.(񮽙m) 
CPU 
%Imp. 
CPU 
%Imp. 
CPU 
%Imp. 
CPU 
Random instances (average results over 10 instances) 
100 
72375.1 
0.0005 
4.28 
0.530 
4.43 
0.010 
4.75 
11.608 
500 
155611.7 
0.0036 
4.12 
13.410 
4.29 
0.118 
4.60 
311.991 
1000 
219030.8 
0.0079 
4.12 
54.641 
4.25 
0.296 
4.59 
1321.382 
5000 
484650.5 
0.0506 
4.17 
1466.296 
4.31 
2.820 
-
-
10000 
684409.5 
0.1217 
4.13 
5946.815 
4.28 
8.362 
-
-
50000 
1528687.2 
1.1940 
4.16 
147210.395 
4.30 
116.419 
-
-
100000 
2160629.4 
3.1060 
-
-
4.32 
476.307 
-
-
500000 
4826839.1 
23.0610 
-
-
4.31 
6578.840 
-
-
VLSI instances 
337 
219.0 
0.0020 
2.92 
5.690 
2.99 
0.050 
3.13 
72.960 
830 
630.4 
0.0055 
0.93 
27.610 
0.90 
0.120 
1.07 
195.190 
1944 
407.2 
0.0167 
3.33 
202.030 
3.47 
0.750 
4.01 
5279.870 
2437 
523.1 
0.0218 
3.67 
345.330 
3.77 
0.820 
4.29 
7484.730 
2676 
780.2 
0.0236 
3.41 
392.340 
3.51 
1.310 
3.89 
6080.050 
12052 
2372.3 
0.1417 
3.63 
7517.680 
3.72 
10.800 
-
-
22373 
12069.8 
0.3447 
3.65 
25410.340 
3.74 
21.380 
-
-
34728 
8724.9 
0.5427 
3.64 
62971.090 
3.74 
25.160 
-
-</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We would like to thank Manjit Borah, Benny Nielsen, André Rohe, and Martin Zachariasen for giving us access to their implementations, and Charles Alpert for providing the VLSI benchmarks.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Alpert</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Personal communication</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Approaching the 5/4-approximation for rectilinear Steiner trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Berman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Fossmeier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Karpinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Zelikovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Symp. on Algorithms (ESA)</title>
		<editor>K. W. Ng et al.</editor>
		<meeting>European Symp. on Algorithms (ESA)</meeting>
		<imprint>
			<publisher>Springer Verlag Lecture Notes</publisher>
			<date type="published" when="1994" />
			<biblScope unit="volume">762</biblScope>
			<biblScope unit="page" from="533" to="542" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A fast and simple Steiner routing heuristic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Borah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Irwin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">90</biblScope>
			<biblScope unit="page" from="51" to="67" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Maintaining dynamic minimum spanning trees: an experimental study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Cattaneo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Faruolo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><forename type="middle">F</forename><surname>Petrillo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">F</forename><surname>Italiano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Int. Workshop on Algorithm Engineering and Experiments (ALENEX)</title>
		<editor>D.M. Mount, C. Stein</editor>
		<meeting>4th Int. Workshop on Algorithm Engineering and Experiments (ALENEX)</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="111" to="125" />
		</imprint>
	</monogr>
	<note>Springer Verlag Lecture Notes in Computer Science 2409</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Faster approximation algorithms for the rectilinear Steiner tree problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Fößmeier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Zelikovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete &amp; Computational Geometry</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="93" to="109" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Steiner minimal trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">N</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">O</forename><surname>Pollak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Appl. Math</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="826" to="834" />
			<date type="published" when="1977" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">On computing all north-east nearest neighbors in the Ä ½ metric</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">J</forename><surname>Guibas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Stolfi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="219" to="223" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On Steiner&apos;s problem with rectilinear distance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hanan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="255" to="265" />
			<date type="published" when="1966" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The Steiner tree problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">K</forename><surname>Hwang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Richards</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Winter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Discrete Mathematics</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<date type="published" when="1992" />
			<publisher>North-Holland</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A new class of iterative Steiner tree heuristics with good performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Robins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on CAD</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="1462" to="1465" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Manhattan or Non-Manhattan? A study of alternative VLSI routing architectures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-K</forename><surname>Koh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">H</forename><surname>Madden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Great Lakes Symposium on VLSI</title>
		<meeting>Great Lakes Symposium on VLSI</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="47" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A new heuristic for rectilinear Steiner trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">V</forename><surname>Vazirani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Ganley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1129" to="1139" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An exact algorithm for the uniformly-oriented Steiner tree problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">K</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Winter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zachariasen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Springer Verlag Lecture Notes in Computer Science 2461</title>
		<editor>R. Möhring and R. Raman</editor>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="760" to="772" />
		</imprint>
	</monogr>
	<note>Proc. European Symp. on Algorithms (ESA)</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Sequential and parallel algorithms for local routing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rohe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-12" />
			<pubPlace>Bonn, Germany</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Bonn University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Rectilinear MST code, available as part of the</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Scheffer</surname></persName>
		</author>
		<ptr target="http://www.gigascale.org/bookshelf/slots/RSMT/RMST/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">The X architecture: Not your father&apos;s diagonal wiring</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Teig</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>inn Proc</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
				<title level="m">ACM/IEEE Workshop on System Level Interconnect Prediction (SLIP)</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="33" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">M</forename><surname>Warme</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Winter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zacharisen</surname></persName>
		</author>
		<ptr target="http://www.diku.dk/geosteiner/" />
		<imprint/>
	</monogr>
	<note>GeoSteiner 3.1 package</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Preferred direction Steiner trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">C</forename><surname>Yildiz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">H</forename><surname>Madden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Great Lakes Symposium on VLSI</title>
		<meeting>Great Lakes Symposium on VLSI</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="56" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zachariasen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002-08" />
		</imprint>
	</monogr>
	<note>Personal communication</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">An 11/6-approximation for the network Steiner tree problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Zelikovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="463" to="470" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Efficient minimum spanning tree construction without Delaunay triangulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shenoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Nicholls</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Asia-Pacific Design Automation Conference (ASP-DAC)</title>
		<meeting>Asia-Pacific Design Automation Conference (ASP-DAC)</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="192" to="197" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
