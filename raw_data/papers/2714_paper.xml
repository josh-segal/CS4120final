<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:42+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giampaolo</forename><surname>Bella</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Computer Laboratory</orgName>
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Dip. di Matematica e Informatica</orgName>
								<orgName type="institution">Università di Catania</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefano</forename><surname>Bistarelli</surname></persName>
							<email>stefano.bistarelli@iit.cnr.it</email>
							<affiliation key="aff2">
								<orgName type="department">Dip. di Scienze, Università &quot;G. D&apos;annunzio&quot; di Chieti-Pescara</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="department">Istituto di Informatica e Telematica</orgName>
								<orgName type="institution">CNR</orgName>
								<address>
									<settlement>Pisa</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabio</forename><surname>Massacci</surname></persName>
							<email>massacci@ing.unitn.it</email>
							<affiliation key="aff4">
								<orgName type="department">Dip. di Informatica e TLC</orgName>
								<orgName type="institution">Università di Trento</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>A protocol&apos;s life after attacks. . .</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction and Motivations</head><p>What is a security protocol, if we set technology aside? It is just a social behavior that principals of a distributed system must follow to obtain some important collective benefits. For the good guys, we just set up clear, understandable, and acceptable rules describing this behaviour: execute the security protocol correctly, namely by the book. Because they are good guys, they will conform to the rules, and behave as we wanted. The bad guys, by definition, will not conform to the rules and execute the protocol incorrectly, namely arbitrarily.</p><p>Classical research in distributed systems and security starts from the need to counter the disruptive behavior of the nasty ones. In classical distributed algorithms, the main focus has been to design the protocol so that if the good guys outnumber the bad ones, the collective benefits will be achieved, no matter what the bad guys do (alternatively, prove that the good guys are doomed, no matter how many they are and how smart they are <ref type="bibr" target="#b3">[4]</ref>). The security standpoint is to find a design such that, no matter what the bad guys do and no matter how many they are, they can prevent the good guys from achieving the desired collective benefits.</p><p>Each time an attack is published, the implied corollary is that the security experts have failed: the protocol has flaws, the good guys cannot achieve their ultimate goal, and we should go back to the drawing board. Yet, before abandoning the protocol, it is worth looking at what is left after the attack. This can lead us to more comprehensive evaluation of security protocols even if it requires continuation of a protocol analysis after an attack is found.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our Contribution</head><p>It has never been considered whether it is at all possible to threaten the bad guys in case they execute the protocol incorrectly. In the real world, we impose a virtuous behavior on people by not letting them sin first (the classical security approach), and by making them repent of their sins ever since (sending them to jail). They would therefore weigh up the benefits of an incorrect execution with the consequent threats, and might choose to execute the protocol correctly if the threats were heavier.</p><p>Let's consider Lowe's example in his paper on Needham-Schroeder <ref type="bibr" target="#b5">[6]</ref>. After the end of the attack, the bad guy asks for a transfer of money. Would he steal 1.000 Euro if the threat that 2.000 Euro could be stolen to him on the next day were significant? Would he transfer the money if the chances of being caught were significant?</p><p>In this paper, we propose a number of notions for the analysis of protocols beyond attacks: we introduce the notions of retaliation, detection, and suspicion. For instance, in a peer-2-peer environment or in network games, direct retaliation can be an effective threat to force the bad guys to play by the rules.</p><p>In the next section we show how Lowe's attack on Needham-Schroeder can be retaliated <ref type="bibr" target="#b0">[1]</ref>. Then, we introduce the notion of retaliation, followed by those of detection and suspicion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Retaliation in Needham-Schroeder</head><p>Let's start from a classical case: the (in)famous Needham-Schroeder public key protocol represented in <ref type="figure" target="#fig_0">Figure 1</ref>. We use the classical notation for security protocols <ref type="bibr" target="#b1">[2]</ref>: -keys are denoted by K, possibly extended with subscripts expressing the principals knowing them; the −1 superscript expresses the inverse of a key; -nonces are denoted by N ; -concatenation is denoted by a comma; -encryption is denoted by a pair of curly braces with the key as a subscript; the type of the key determines the type of encryption. The goal of the protocol is authentication: at completion of a session initiated by A with B, A should get evidence to have communicated with B and, likewise, B should get evidence to have communicated with A. Assuming that encryption is perfect and that the nonces are truly random, authentication is achieved here by confidentiality of the nonces. Indeed, upon reception of Na inside message 2, A would conclude that she is interacting with B, the only principal who could retrieve Na from message 1. In the same fashion, when B receives Nb inside message 3, he would conclude that A was at the other end of the network because Nb must have been obtained from message 2, and no-one but A could perform this operation.</p><formula xml:id="formula_0">1. A → B : {|Na, A| } Kb 2. B → A : {|Na, Nb| } Ka 3. A → B : {|Nb| } Kb</formula><p>Lowe discovers <ref type="bibr" target="#b5">[6]</ref> that the protocol suffers the "attack" described in <ref type="figure" target="#fig_1">Figure 2</ref>, whereby a malicious principal C masquerades as a principal A with a principal B, after A initiated a session with C. The attack, which sees C interleave two sessions, indicates failure of the authentication of A with B which follows from failure of the confidentiality of Nb.</p><p>Let's examine this protocol after the attack took place:</p><p>-B is the subject of the attack -we call him the good agent; -C is the bad guy; -A is just playing by the rules -we call him the ugly participant; -the trace T of the protocol as in <ref type="figure" target="#fig_1">Figure 2</ref> describes an attack</p><p>The predicate Attack(T, G := {B} , B := {C} , U := {A}) can represent the previous fact with the meaning: ∈ T ); -C knows the nonce Nb, which was meant to be known to A and B only by receiving the message {|Nb| } Kc ∈ T in step 3 (so he can complete the run with B and perform the attack). -A plays according to the rules and is just a spectator in the battle between B and C.</p><formula xml:id="formula_1">1. A → C : {|Na, A| } Kc 1 . C → B : {|Na, A| } Kb 2 . B → A : {|Na, Nb| } Ka 2. C → A : {|Na, Nb| } Ka 3. A → C : {|Nb| } Kc 3 . C → B : {|Nb| } Kb</formula><p>By using the authentication attack if B is a bank for example, C can steal money from A's account as reported by Lowe <ref type="bibr" target="#b5">[6]</ref>:</p><formula xml:id="formula_2">4. C → B : {|Na, Nb, "Transfer £1000 from A's account to C's"| } Kb</formula><p>The bank B would honour the request believing it came from the account holder A.</p><p>Notice however, that the same predicate Attack also holds if instantiated in a different way <ref type="bibr" target="#b0">[1]</ref>. In fact, we have also Attack(T, G := {A} , B := {B} , U := {C}):</p><p>-A executes a run of the protocol apparently with C (in fact he receives/sends the following messages:[{|Na, A| } Kc , {|Na, Nb| } Ka , {|Nb| } Kc ] ∈ T ); -B knows the nonce Na, which was meant to be known to A and C only, by receiving the message {|Na, A| } Kb ∈ T in step 1 (so he can send in step 2 the message {|Na, Nb| } Ka also without having C sending it to A). -C is in this run just playing according to the rules.</p><p>In this case B is the bad guy. As C did previously, B can equally decide to illegally exploit his knowledge of Na. If also A is a bank, B can rob the robber as follows:</p><formula xml:id="formula_3">2 . B → A : {|Na, Nb| } Ka 4 B → A : {|Na, Nb, "Transfer £2000 from C's account to B's"| } Ka</formula><p>The bank A would honour the request believing it came from the account holder C. After we found the attack Attack(T, G := {B} , B := {C} , U := {A}) in the trace T , we could have continued the analysis and find out that the bad guy could be easily punished, as in the example given above.</p><p>3 Vendetta. . .</p><p>To introduce the notion of retaliation we must identify the role played by each principal in the protocol execution. We are not interested in notions such as responder or initiator; rather, we intend to provide a behavioural characterization.</p><p>Good principals are denoted by the set G. They currently obey the protocol, but may change their mind in the future when attacked. Bad principals are denoted by the set B. They also take part in the protocol, possibly communicating with friendly and neutral agents but, crucially, they can as well collaborate with the intruder who runs the network. Ugly principals are denoted by the set U. Usually they mind their own business and conform to the protocol. However they can also both collaborate with corrupt agents or help in future the friendly agent to retaliate.</p><p>Informally, we assume that -a trace T is a protocol run, namely a sequence of sending, receiving and memorizing actions, -a protocol P is the set of all traces of the protocol 1 (all possible executions), -a projection T /A of a trace T with respect to a set of agents A is the subsequence of the actions in T that are performed 2 by an agent in A, -an attack is a trace T that satisfies some property A(T , G, B, U, Spy).</p><p>We take the following definition of vulnerable protocol: Definition 1. A protocol P is vulnerable to an attack A for the principals in G if there exists a trace T ∈ P such that A(T , G, B, U, Spy).</p><p>The property as stated is suited for model checking, whereas people working with theorem provers will try to prove that there is no such trace.</p><p>Definition 2. A protocol P is immune to an attack A for the principals in G if there exists no trace T ∈ P such that A(T , G, B, U, Spy).</p><p>What is the essence of retaliation? Each time you try to cheat, we can hit you back. So, do you still want to cheat?</p><p>This makes sense if hitting you back is a meaningful property in the context of the protocol. If the corrupted principals B are protocol participants, then we can assume that they want to reap the benefits of the protocol (such as authentication), plus any additional benefits they may obtain by misbehaving. These latter benefits should be balanced with the threat of being hit back. So, we simply need to pay an attacker with the same coin.</p><p>Definition 3. A protocol P allows the retaliation of an attack A onto the principals in B iff for every trace T ∈ P such that A(T, G, B, U, Spy), there exists a trace T r ∈ P extending T such that A(T r , B , G , U , Spy).</p><p>In particular, -when we have B = G we speak of direct retaliation; -when B ∩ G = ∅ we have a combined retaliation; -lastly, when B ⊂ G ∪ U we have an arbitrary retaliation.</p><p>This definition follows the intuition that each time there is an attack (a trace T such that A(T , G, B, U, Spy) some additional actions (hence T r extending T ) can be done to retaliate. Who acted initially as friendly is now ready to act as corrupted (possibly against who was corrupted initially).</p><p>The property as stated is useful for theorem proving: this is a positive guarantee to make bad guys play by the rules. For model checking, and thus finding that not only are there attacks but you are even powerless against them, we need to turn the quantifiers.</p><p>Definition 4. A protocol P is vulnerable to an attack A without chance of retaliation onto B if there exists a trace T ∈ P such that A(T , G, B, U, Spy) and no trace T r ∈ P extending T is such that A(T r , B , G , U , Spy) where B ∈ G ∪ U, B ∈ G ∪ U .</p><p>The important caveat here is that we assume that the formerly friendly principals will jump side and collaborate with the Spy, owner of the network, to frame the formerly corrupted principals. The spy will act as a devil helping the current corrupt agent (whoever he/she is). This view may be subject to debate but the key observation is that we need in any case some collaboration with the network provider, otherwise after the attack she could simply start killing every message that is sent on the network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Detection</head><p>The notion of detection is more complicated and requires the comparison of alternative traces. Let's see the intuition: you look at your logs and spot some fishy actions (the projection of the full trace with respect to yourself). These actions are enough to bring the bad guys to trial if you can show that there is no other full trace which would have left the same marks on your logs and not included the attack.</p><p>In contrast, detection would fail if the bad guys could show at Court one trace, beside yours with the attack, with the same marks on your logs, but without the attack. Indeed, it would have been enough for them to show a trace with an attack from somebody else. This would have been sufficient to get acquittal.</p><p>Definition 5. A protocol P allows the detection of an attack A from B if for every trace T ∈ P such that A(T , G, B, U, Spy), for all traces T r ∈ P such that</p><formula xml:id="formula_4">T r /G = T /G, it is A(T r , G, B, U, Spy).</formula><p>The intuition is that each time there is an attack on a trace T , the friendly agents can check their own logs T /G and pinpoint who acted corruptly, namely the principals in B. The same logs could not have been created by some other set B of corrupted principals.</p><p>The model checking version of the same property requires two pieces of evidence: the logs of the good guys and the "plausible" no-attack alternative concocted by the bad guy's counsel for the defence.</p><p>Definition 6. A protocol P is vulnerable to an attack A without possibility of detection of B if there exists some trace T ∈ P such that A(T , G, B, U, Spy) and there exists a trace T r ∈ P , T r = T , such that T r /G = T /G and it is not A(T r , G, B, U, Spy).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Suspicion</head><p>Suspicion is a weaker version of detection: each time there is an attack (a trace T such that A(T , G, B, U, Spy)) we can look at the logs (the projection T /G) and conclude that something fishy happened but we cannot pin-point the villain.</p><p>Also in this case, the model checking version of the same property, requires two pieces of evidence: the logs of the good guys and the "plausible" no-attack alternative concocted by the bad guy's counsel for the defence.</p><p>Definition 7. A protocol P allows the suspicion of an attack A if for every trace T ∈ P and set B such that A(T , G, B, U, Spy) then for all traces T r ∈ P such that T r /G = T /G there are sets U and B , such that A(T r , G, B , U , Spy).</p><p>In a nutshell: each time the log matches with your logs, the traces include some attack by somebody.</p><p>The model checking version is by far more complicated:</p><p>Definition 8. A protocol P is vulnerable to an attack A without possibility of suspicion if there exists some trace T ∈ P and set B such that A(T , G, B, U, Spy) and there exists a trace T r ∈ P such that T r /G = T /G and for all sets U and B it is not A(T r , G, B , U , Spy).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Implications for Formal Protocol Verification</head><p>We have been used to hair-splitting formal analysis of authentication. Can we formally analyze properties such as retaliation? From a theoretical standpoint there is not a big difference. We have casted our properties as properties of traces because almost all research in tool-supported security verification is based on defining authentication or confidentiality as a property of traces <ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref> or fragments thereof <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b10">11]</ref>.</p><p>The key observation is that the emphasis in the traditional work on security verification was on finding attacks or showing that no attack existed. This was reflected on formal models by the nature of the checked properties, which were essentially of existential nature: is there a trace T in the protocol P such that A(T ) holds? Here, T , P , and A could be complicated at wish. Indeed, A, as a formally defined property, could be awfully complicated (for instance including arithmetical constraints on the number of actions and arbitrarily many quantifiers). However, the trace as such, was only existentially qualified. Theorem proving fellows wished to prove that no such a trace existed, model checking guys longed for a witness of its existence.</p><p>Here, the properties are more complex: we run at least two quantifiers over traces. In some cases we have alternation of quantifiers (such as retaliation). Lifting the theory is simple. Lifting the automatic tool support will be the real challenge.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. The asymmetric Needham-Schroeder protocol</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Lowe's attack to the Needham-Schroeder Protocol</figDesc></figure>

			<note place="foot" n="1"> This can be defined in the formal model of choice: CSP [10], inductive definitions [8], strand spaces [12]. 2 Note that the action in which A sends a message to B is included in the projection over the set {A}, but not in the projection over the set {B}, as B might never receive that message.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Confidentiality levels and deliberate/indeliberate protocol attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Bella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bistarelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Security Protocols 10th International Workshop</title>
		<meeting>Security Protocols 10th International Workshop<address><addrLine>Cambridge, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002-04" />
		</imprint>
	</monogr>
	<note>Revised Papers, to appear</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A logic for authentication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Needham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="18" to="36" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Verifying security protocols as planning in logic programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlucci</forename><surname>Luigia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabio</forename><surname>Aiello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Massacci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computational Logic</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="542" to="580" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Reasoning about Knowledge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ronald</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">Y</forename><surname>Halpern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoram</forename><surname>Moses</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<publisher>The MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Three system for cryptographic protocol analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kemmerer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Meadows</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Millen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="79" to="130" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An Attack on the Needham-Schroeder Public-Key Authentication Protocol</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="131" to="133" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Automated analysis of cryptographic protocols using Murphi</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Stern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th IEEE Symposium on Security and Privacy</title>
		<meeting>the 16th IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="141" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The inductive approach to verifying cryptographic protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lawrence</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Paulson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="85" to="128" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The compositional security checker: A tool for the verification of information flow security properties</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Focardi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gorrieri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="550" to="571" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Security properties and CSP</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th IEEE Symposium on Security and Privacy</title>
		<meeting>the 15th IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="174" to="187" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Athena: An automatic checker for security protocol analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawn</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th IEEE Computer Security Foundations Workshop</title>
		<meeting>the 12th IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Honest ideals on strand spaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Thayer Fabrega</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Herzog</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Guttman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th IEEE Computer Security Foundations Workshop</title>
		<meeting>the 11th IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
