<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:53+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Fault-tolerant Routing Strategy for Fibonacci-class Cubes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xinhua</forename><surname>Zhang</surname></persName>
							<email>xinhua.zhang@nus.edu.sg</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">National University of Singapore</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">K</forename><surname>Loh</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">School of Computer Engineering</orgName>
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Fault-tolerant Routing Strategy for Fibonacci-class Cubes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Fibonacci Cubes (FCs), together with the enhanced and extended forms, are a family of interconnection topologies formed by diluting links from binary hypercube. While they scale up more slowly, they provide more choices of network size. Despite sparser connectivity, they allow efficient emulation of many other topologies. However, there is no existing fault-tolerant routing strategy for FCs or other node/link diluted cubes. In this paper, we propose a unified fault-tolerant routing strategy for all Fibonacci-class Cubes, tolerating as many faulty components as network node availability. The algorithm is livelock free and generates deadlock-free routes, whose length is bounded linearly to network dimensionality. As a component, a generic approach to avoiding immediate cycles is designed which is applicable to a wide range of inter connection networks, with computational and spatial complexity at O(1) and O(n log n) respectively. Finally, the performance of the algorithm is presented and analyzed through software simulation, showing its feasibility.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Fibonacci-class Cubes originate from Fibonacci Cube (FC) proposed by Hsu <ref type="bibr" target="#b0">[1]</ref>, and its extended forms are Enhanced Fibonacci Cube (EFC) by Qian <ref type="bibr" target="#b1">[2]</ref> and Extended Fibonacci Cube (XFC) by <ref type="bibr">Wu [3]</ref>. This class of interconnection network uses fewer links than the corresponding binary hypercube, with the scale increasing at <ref type="bibr">(((13)</ref>2)) n O + , slower than O(2 n ) for binary hypercube. This allows more choices of network size. In structural aspects, the two extensions virtually maintain all desirable properties of FC and improve it by ensuring the Hamiltonian property <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>. Besides, there is an ordered relationship of containment between the series of XFC and EFC, together with binary hypercube and regular FC. Lastly, they all allow efficient emulation of other topologies such as binary tree (including its variants) and binary hypercube. In essence, Fibonacci-class Cubes are superior to binary hypercube for low growth rate and sparse connectivity, with little loss of its desirable topological and functional (algorithmic) properties.</p><p>Though Fibonacci-class Cubes provide more options of incomplete hypercubes to which a faulty hypercube can be reconfigured and thus tend to find applications in fault-tolerant computing for degraded hypercubic computer systems, there are, to the best of the authors' knowledge, no existing fault-tolerant routing algorithms for them. This is also a common problem for link-diluted hypercubic variants. In this paper, we propose a unified fault-tolerant routing strategy for Fibonacci-class Cubes, named Fault-Tolerant Fibonacci Routing (FTFR), with following strengths: · It is applicable to all Fibonacci-class Cubes in a unified fashion, with only minimal modification of structural representation. · The maximum number of faulty components tolerable is the network's node availability <ref type="bibr" target="#b3">[4]</ref> (the maximum number of faulty neighbors of a node that can be tolerated without disconnecting the node from the network). · For a n-dimensional Fibonacci-class Cube, each node of degree deg maintains and updates at most (deg + 2) n × bits' vector information, among which: 1) a n-bit availability vector indicating the local non-faulty links, 2) a n-bit input link vector indicating the input message link, 3) all neighbors' n-bit availability vector, indicating their link availability. · Provided the number of component faults in the network does not exceed the network's node availability, and the source and destination nodes are not faulty, FTFR guarantees that a message path length does not exceed nH + empirically and 2nH + theoretically, where n is the dimensionality of the network and H is the Hamming distance between source and destination. · Generates deadlock-free and livelock-free routes. · Can be implemented almost entirely with simple and practical routing hardware requiring minimal processor control. The rest of this paper is organized as follows. Section 2 reviews several versions of definitions of Fibonacci-class Cube, together with initial analysis on their properties. Section 3 presents a Generic Approach to Cycle-free Routing (GACR), which is used as a component of the whole strategy. Section 4 elaborates on the algorithm FTFR. The design of a simulator and simulation results will be presented in section 5. Finally, the paper is concluded in section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Definitions</head><p>Though Fibonacci-class Cubes are very similar and are all based on a sequence with specific initial conditions, they do have some different properties that require special attention. The well-known Fibonacci number is defined by: </p><formula xml:id="formula_0">0 0, f = 112 1, nnn ffff -- ==+ for 2 n ³ . In [1], the order-n Fibonacci code of integer [0,1](3) n ifn Î-³</formula><formula xml:id="formula_1">()|1, k XFCnk ³ 2} nk ³+ , where (){(),()} kkk XFCnVnEn = , ()0||(1)10||(2) kkk VnVnVn =--U for 4 nk ³+.</formula><p>As initial conditions for recursion, <ref type="bibr">(</ref> En if and only if their Hamming distance is 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Properties of Fibonacci-class Cubes</head><p>In this section, we introduce an important property for our algorithm. Let current node address be u and destination node address be d, then each dimension corresponding to 1 in ud Å is called preferred dimension, where Å stands for bitwise XOR operation. Other dimensions are called spare dimension. As Fibonacci-class Cubes are defined by link dilution, it is likely that links in some preferred dimensions are not available at a packet's current node. But the following proposition guarantees that in a fault-free setting, there is always at least one preferred dimension available at the present node. Unlike in binary hypercube, this is not a trivial result.</p><p>(Proposition 1) In a fault-free FC, EFC or XFC, there is always a preferred dimension available at the packet's present node before the destination is reached.</p><p>Proof : Consider an n-dimensional Fibonacci-class Cube, which means FC, XFC and EFC of order n + 2. Let the binary address of current node be 110 n aaa -××× and the destination be 110 n ddd -××× . Let the rightmost (least significant) bit correspond to dimension 0 while the leftmost bit correspond to dimension 1 n -. Case I: Fibonacci Cube FC n + 2 . Obviously, if the destination has not been reached, there is always a preferred dimension <ref type="bibr">[0,</ref><ref type="bibr" target="#b0">1]</ref> in Î-. If When 3 n £ , the proposition can be easily proven by enumeration. So now we suppose 4 n ³ . 1) If <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref> in Î-, then <ref type="bibr" target="#b0">1</ref>  3) If i = n -1, then d n -2 = 0. If a n -2 = 1, then dimension n -2 is an available preferred dimension. If 2 0 n a -= , then dimension 1 n -is an available preferred dimension.</p><p>Case II: XFC k (n+2 g The proposition implies that whenever a spare dimension is used, either a faulty component is encountered or all neighbors on preferred dimensions have been visited previously. For the latter case, all such preferred dimensions must have been used as spare dimensions sometime before. So both cases can be boiled down to the encounter of faulty components (now or before). It is also implied that certain algorithm can be applied to all the three types of network and the existence of at least one preferred dimension is guaranteed in a certain sense, given the number of faulty components does not exceed node availability. This is the underlying idea of FTFR.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Generic Approach to Cycle-Free Routing (GACR)</head><p>As a component of FTFR, we digress from the mainframe for one section and propose now a generic approach to avoiding cycles in routing by checking the traversal history. The algorithm takes only O(1) time to update the coded history record and O(n) time to check whether a neighbor has been visited before (can be virtually reduced to O(1) by utilizing parallelism). Other advantages include its wide applicability and easy hardware implementation. It applies to all networks in which links only connect node pairs whose Hamming distance is 1 (called Hamming link). All networks constructed by node or link dilution meet this criterion. An extended form of the algorithm can be applied to those networks with O(1) types of non-Hamming links at each node. Thus, such networks as Folded Hypercube, Enhanced Hypercube and Josephus Cube <ref type="bibr" target="#b4">[5]</ref> can also use this algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Basic GACR</head><p>The traversal history is effectively an ordered sequence of dimensions used when leaving each visited node. We use <ref type="figure">Figure 1</ref> for illustration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 1. Basic GACR illustration</head><p>The route that originates from 000 can be recorded as: 1210121. An obvious equivalent condition for a route to contain a cycle is: there exists a way of inserting '(' and ')' into the sequence such that each number in the parenthesis appears for an even number of times. For example, in 1(21012), 0 appears only one time. In (1210121), 1 and 2 appear for an even time but 0 still appears for an odd number of times. So neither case forms a cycle. But for a sequence of 1234243, there must be a cycle: 1(234243). Suppose at node p, the history sequence is 12 n aaa ××× , and it is guaranteed that no cycle exists hitherto, then to check whether using dimension 1 n a + will cause any cycle, we only need to check whether in</p><formula xml:id="formula_2">1 () nn aa + , 211 () nnnn aaaa --+ , 43211</formula><p>() nnnnnn aaaaaa ----+ … each number will appear for an even number of time.</p><p>We first introduce the basic form of this algorithm that applies only to networks constructed by node/link dilution from binary hypercube. This algorithm is run at each intermediate node to ensure that the next node has never been visited before.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(Algorithm 1) Basic GACR</head><p>The data structure is a simple array: port[], with each element composed of log n éù êú bits. port <ref type="bibr">[i]</ref> records the port used when exiting the node that the packet visited 1 i + hops before. So when leaving a node, we only need to append the exiting dimension to the head of the array port[]. As each node has only n ports and each dimension c at node a has the same meaning at node b, only log n éù êú bits are needed to represent these n possibilities. At the source node, port[ ] is null. Suppose at node x, the length of the array is L. After running the following code segment, each 0 in mask corresponds to a dimension, the using of which will cause an immediate cycle.</p><formula xml:id="formula_3">unsigned GACR ( unsigned port[], int L) { unsigned mask = 0, history = 1 &lt;&lt; port[0]; for (int k = 1; k &lt; L; k ++) { // invert the bit of history corresponding to dimension 'port[k]' history = history XOR (1 &lt;&lt; port[k]);</formula><p>if (k is an odd number and history has a single 1) mask = mask OR history;</p><formula xml:id="formula_4">dim 0 dim 1 dim 2 dimension direction: } return ~mask; // bitwise NOT of mask }</formula><p>For instance, given the dimension sequence 875865632434121 from source to present, the mask should be 000010011, because in 875865632434121a, a cycle is formed when a = 2, 3, 5, 6, 7, or 8. All operations in this algorithm are basic logic operations. The logic check for whether history x is the complementary of x i . The check can be implemented to cost only one clock cycle, with n AND gates and 1 OR gate. But in software simulation, it takes () On time, which requires attention during simulation. This algorithm also has the strength that the time cost can be reduced to virtually zero because it can be executed when the packet is still queuing in the buffer, making parallelism and pipelining possible. Though the time complexity is O(L max ) and message overhead is O(L max log n), where L max is the length of the longest path that the packet can traverse, in most routing algorithms,</p><formula xml:id="formula_5">L max = O(n) thus O(L max log n) (log) Onn =</formula><p>. So both time and spatial complexity are within the acceptable bound in practice. For example, the technique used by <ref type="bibr" target="#b5">[6]</ref> incurs message overhead of 2 (1)log nn + éù êú bits for n-dimensional binary hypercube.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Extended GACR</head><p>If the network has O(1) number of non-Hamming links at each node and those links can be represented in a common way, then basic GACR can be easily extended. </p><formula xml:id="formula_6">for (int k = 1; k &lt; L; k ++) { if ( port[k] &lt; n ) // once exit through Hamming links dim = 1 &lt;&lt; port[k]; else if ( port[k] == n ) // once exit through complementary link dim = (1&lt;&lt;n) -1; else dim = (unsigned) 3;</formula><p>// once exit through Josephus link history = history XOR dim; if (history has a single 1) // now when k is even, we also have to check </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Definition and notation</head><p>Now we will go back to the mainframe of the routing strategy. In a Fibonacci-class Cube of order n + 2 (n-dimensional), each node's address is a n-bit binary number. Let the source node s be ( a n -1 L a 1 a 0 ) {0, 1} n Î and the destination node d be</p><formula xml:id="formula_7">(d n-1 L d 1 d 0 ) {0, 1} n Î</formula><p>. Denote the neighbor of node u along the i-th dimension (0) in £&lt; as () i u , by inverting the i th bit of u's binary address. For convenience we define following terms. 1) input link vector I (x). An n-bit input link vector at node x is defined as I (x) = [l n-1 … l 1 l 0 ], where l i = 0 if the message goes to the current node along the dimension i link ( 0 in £&lt; ). l j = 1 for ji ¹ . Setting the corresponding bit to 0 for a used input link prevents the link from being used again immediately for message transmission, causing the message to "oscillate" back and forth. An input link vector has straight 1's for a new message.</p><p>2) availability vector AV(x). At each node x, the n-bit binary number availability vector AV(x) records a bit string, indicating by '1' what dimensions are available at x, and by '0' what dimensions are unavailable. Here a dimension i is available if there is a non-faulty link at x to () i x . For example, in <ref type="figure" target="#fig_5">Figure 2</ref>, node 1001 and link (0000, 0001) are faulty. The availability vector for all nodes is listed in <ref type="table" target="#tab_3">Table 1</ref>.  . At source node, DT is cleared to be straight 1. After that, whenever a spare dimension is used, the corresponding bit in DT is set to 0 and cannot be set back to 1. Spare dimensions whose corresponding bit in DT is 0 cannot be used, i.e., dimensions that are spare at the source node can be used for at most two times. But different from many existing algorithms (e.g. <ref type="bibr" target="#b6">[7]</ref>), each dimension which is preferred at the source can be used more than once. When it is used for the first time, DT doesn't record it. But when it is used as a spare dimension later, the corresponding bit in DT is masked, so that it can't be used as a spare dimension again. Finally, each node periodically exchanges its own availability vector with all neighbors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Description of FTFR</head><p>Empirically, the number of faults FTFR can tolerate is the network's node availability, a value constant for a network which is independent of each node. There is an intricate mechanism for choosing candidate dimension when more than one preferred dimension are available, or when no preferred but several spare dimensions are available. First of all, the GACR is applied to generate a mask M. Only those dimensions whose corresponding bit in (M AND I (x) AND AV (x)) is 1 are further investigated. These dimensions are called adoptable. For illustration, we use the following <ref type="figure">Figure 3</ref>, in which 's' and 'p' stand for spare and preferred dimension, respectively. We divide our discussion into two cases.</p><p>(Case I) If there are several adoptable preferred neighbors (like A and B), we choose the one which has the largest number of non-faulty preferred dimensions. To break tie, we compare their number of non-faulty spare dimension. If still tie, choose the lowest dimension. Equivalently, if the dimensionality of the network is n, then the score to compare is ps nNN ×+, where N p and N s stand for the number of preferred and spare dimensions respectively. Here, for A, 22 ps nNNn ×+=+ , while for B, the score is 3 n + . So A is chosen. (Case II) If at current node M, there are no adoptable preferred dimensions, spare dimensions have to be used, like D and E. Firstly, the eligibility is checked by DT. Then just like in case I, we compare n × N p + N s . After one spare dimension is finally chosen, its corresponding bit in DT is masked to 0, so that it will not be used as spare dimension again.</p><p>The m = n × N p + N s is a heuristic score. After extensive experiment, it is found that minor modifications can be made to m so as to improve the performance of FTFR. Suppose the dimension under consideration is i and inverting the i th bit of destination d produces d <ref type="bibr">(i)</ref> . If d (i) is a valid node address in that Fibonacci-class Cube, attaching some priority to dimension i will be helpful in reducing the number of hops. Hence, we add the value of network node availability to m for that candidate dimension in such a case.</p><p>The following is the pseudo-code for the two core routing functions. GetNext is run at M, which looks ahead at A, B, C, D and E. Vector adoptable = AV(M) AND I(M) AND (GACR result). The following function OneBest is run for "scoring" neighbors, A, B, C,…. and returns the selected dimension. Each 1 in cand corresponds to a candidate dimension waiting to be considered. max records the largest ps nNN ×+. If all candidates have no adoptable outlets, max is set to -1 (unchanged as before OneBest is called) and return NOT_FOUND. // no qualified dimension is found return NOT_FOUND; return best; } It is obvious that the algorithm possesses all the properties listed in Section 1. The only uncertain thing, which is why we call it a heuristic algorithm, is that no guarantee can be made that FTFR will never fail to find a route (GetNext may return ABORT) when there really exists one. We call it false abortion. We enumerated all possible locations of faulty components and (source, destination) pairs for three kinds of Fibonacci-class Cubes with dimensionality below 7 and no false abortion occurs. For higher dimensional cases, we can only randomly set faults and pick (source, destination) pairs. After one month's simulation on a 2.3 GHz CPU, still no false abortion is detected. In the next section, we will test the performance of the FTFR extensively.</p><p>For example, suppose in a 9-dimensional Regular Fibonacci Cube FC 11 , there are two faulty nodes 000001000 and 000000001 while no link is faulty. Source is 101010100 and destination is 000001001. At the beginning, there are 4 adoptable 1 ® 0 preferred dimensions, namely 2, 4, 6, 8, whose and we use the smaller one. After using dimension 6 8 0 4 0 2, the packet reaches 000000000, where neither of the two preferred dimensions (3 and 0) is adoptable because they both lead to a faulty node. So a spare dimension has to be used. The input dimension is 2 and using dimension 4 will lead to cycle. Therefore, there are only 5 adoptable dimensions, namely 1, 5, 6, 7, 8. Their scores are: 14, 25, 25, 25, and 27, respectively. So spare dimension 8 is chosen and its corresponding bit in DT is masked.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Simulation Results</head><p>A software simulator is constructed to imitate the behavior of the real network <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref>, and thus test the performance of our algorithm. The assumptions are: (1) fixed packet-sized messages, (2) source and destination nodes must be non-faulty, (3) eager readership is employed when packet service rate is faster than packet arrival rate, (4) a node is faulty when all of its incident links are faulty, (5) a node knows status of its links to its neighboring nodes, (6) all faults are fail-stop, (7) location of faults, source and destination are all randomly chosen by uniform distribution.</p><p>The performance of the routing algorithms is measured by two metrics: average latency and throughput. Average latency is defined as LP/DP, where LP is the total latency of all packets that have reached destination while DP is the number of those packets. Throughput is defined as DP/PT, where PT is the total routing process time taken by all nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Comparison of FTFR's Performance on Various Network Sizes</head><p>In this section, FTFR is applied to fault-free FC, EFC, XFC 1 and binary hypercube. Their average latency and throughput are shown in <ref type="figure">Figure 4</ref> and 5 respectively.</p><p>In <ref type="figure">Figure 4</ref>, it can be observed that the average latency of regular/Enhanced/Extended Fibonacci Cubes increases when the networks dimension n is below 19. As the network size grows, its diameter increases and a packet has to take a longer path to reach its destination, resulting in a higher average latency. The EFC has the highest latency among three because when dimension is large enough, the number After the dimension reaches 19 or 20, the latency decreases. This is because the scale of the network becomes so large that the simulation time is insufficient to saturate the network with packets, i.e., the number of packets reaching destination is lower than the total allowable packet number. So the packets in these networks spend less time waiting in output queue or injection queue, while that portion of time comprises a major part of latency for lower dimensional networks that get saturated with packets during the simulation. As n = 19~20 is already adequate for demonstrating the performance of FTFR, we do not wait for network saturation. Binary hypercube, a special type of XFC, shows a similar trend, with latency starting to decrease at n = 15. This also goes well with the fact that the number of nodes in Fibonacci-class Cube and binary hypercube are ( <ref type="formula">(13)</ref> physical memory, simulation for binary hypercube is conducted up to n = 15. In <ref type="figure">Figure 5</ref>, it is demonstrated that the throughput of all networks is increasing as the dimension increases from 12 to over 20. This is due to the parallelism of the networks and the increase in the number of nodes, which can generate and route packets in the network, is faster as compared with the FTFR time complexity O(n log n). By increasing the network size, the number of links is also increasing at a higher rate than the node number. This in turn increases the total allowable packets in the network. With parallelism, more packets will be delivered in a given duration. For the same reason mentioned in the previous discussion of latency, EFC has the largest throughput among the three types of Fibonacci-class Cube. An interesting observation is that for dimensions between 11~13, the throughput decreases and increases again afterwards. One possible explanation is: the complexity of FTFR is O(n log n). For large n, the variation in log n is small compared with small n. Thus the difference given by log n will be small and the trend of throughput is similar to an O(n) routing algorithm. For small n, however, the contribution of log n is comparable with the increase rate of networks size, which leads to the seemingly irregularity. On the other hand, when dimension is small (below 11), the network is too small to display this characteristic. For Fibonacci-class Cube, the irregular interval is 11~13, while for binary hypercube, such an interval is 8~9. This again tallies with (13)/2 + : 2 » 8.5:12.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Comparison of FTFR's Performance on Various Numbers of Faults</head><p>In this sub-section, the performance of FTFR is measured by the varying the number of faulty components in network. The result for XFC 13 (16) is shown in <ref type="figure">Figure 6</ref>.</p><p>It is clear that when the number of faults increases, the trend of average latency is to increase while the throughput is to decrease. This is because when more faults appear, the packet is more likely to use spare dimensions which make the final route longer. In consequence, the latency increases and throughput decreases. However, there are some special situations when the existence of faults reduces the number of alternative output ports available, and thus accelerates the routing process. The varying number of faults has more evident influence when the network size is small. With fixed number of faults, there are fewer paths available for routing in smaller networks than in larger ones. Thus making some of the paths unavailable in smaller networks will bring about more significant influence. While the networks grows larger and larger, the total number of nodes in n-dimension network is <ref type="bibr">((13)</ref>2) nn O + and maximum faulty component number tolerable is O(n). So the influence of faults will bring about less and less influence on the overall statistical performance on the network. That explains why the throughput and latency fluctuate in <ref type="figure">Fig. 6</ref>. However, the overall trend is still correct. On the other hand, as the number of faults tolerable in Fibonacci-class Cubes of order n is approximately /3 n êú ëû or /4 n êú ëû <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b2">3]</ref>, we have to use networks of large dimension to provide a large enough number of faults for comparison. <ref type="figure">Figure 7</ref>, 8, and 9 present the influence of varying number of faults for 20-dimensional regular Fibonacci Cube, 19-dimensional EFC, and 18-dimensional XFC respectively.</p><p>The fluctuation of the result needs to be examined carefully. For example, the latency in <ref type="figure">Figure 9</ref> varies only in the range of below 1%. For different runs of simulation, the faulty components' location is randomly distributed. Similarly, messages have different destinations according to uniform distribution. If we examine the standard  <ref type="bibr">(16)</ref> deviation of the result (not shown), it is observed that such a small variation as in <ref type="figure">Figure  9</ref> is within the 95% confidence interval for almost all situations. Thus, it is more reasonable to focus on the trend of the statistical results, rather than the exact value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>In this paper, a new effective fault-tolerant routing strategy is proposed for Fibonacci-class Cubes in a unified fashion. It is livelock free and generates deadlock-free routes with the path length strictly bounded. The space and computation complexity as well as message overhead size are all moderate. Although the Fibonacci-class Cubes may be very sparsely connected, the algorithm can tolerate as many faulty components as the network node availability. The component mechanism which ensures cycle-freeness is also generically applicable to a wide range of network topologies. Simulation results show that the algorithm scales well with network size and is empirically immune to false abortion. Future work needs to be done on further increasing the number of faulty components tolerable, possibly by careful categorization of faults based on their specific location as in <ref type="bibr" target="#b7">[8]</ref>. Physical implementation, such as Field Programmable Gate Array, can also be done to evaluate the algorithm's efficiency and feasibility more accurately.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>1 i a = and 0 i d = , then there is always a preferred link available at dimension i because changing one '1' in a valid address into 0 always produces a new valid address. So we only need to consider 0 i a = and 1 i d = .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>0 i d -= , 1 0 i d + = . If 1 1 i a -= , then i -1 is an available pre- ferred dimension. If 1 1 i a + = , then 1 i + is an available preferred dimension. If 11 0 ii aa -+ == , then dimension i is an available preferred dimension because inverting i a to 1 will not produce two consecutive 0's in the new nodes address. 2) If i = 0, then d 1 = 0. If a 1 = 1, dimension 1 is an available preferred dimension. If a 1 = 0, then dimension 0 is an available preferred dimension because setting a 0 to 1 will give a valid address.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>LL (logic sum of bit products) where i</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>For example, in Josephus Cube () JCn [5], we denote the complementary link (between 120 nn xxx --L and 120 nn xxx --L ,) as dimension n and the Josephus link (between 1210 n xxxx -L and 1210 n xxxx -L ) as dimension 1 n + . Then the basic GACR can be extended as follows. mask2 = 0 and mask3 = 0 represent that using complementary link and Josephus link will result in a cycle, respectively. (Algorithm 2) Extended GACR void ExGACR (unsigned port[], int L, unsigned &amp;mask1, unsigned &amp;mask2, unsigned &amp;mask3) { // mask1 to mask3 are called by reference, mask1 is the same as mask in Algo. 1 unsigned dim, history = 1 &lt;&lt; port[0]; mask1= 0; mask2 = mask3 = 1;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>mask1 = mask1 OR history; // for cycles caused by Hamming link else if (history is straight 1) // check if history has straight 1's for the cycle caused by complementary link mask2 = 0; else if (history = = (unsigned) 3) // check the rightmost two bits for the cycles caused by Josephus link mask3 = 0; } mask1 = ~ mask1; } 4 Fault-tolerant Fibonacci Routing (FTFR)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. availability vector example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Fig. 3. Illustration of FTFR</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>unsigned</head><label></label><figDesc>GetNext (unsigned current, unsigned destination, unsigned adoptable, unsigned *DT) { int max1, max2; If (current = = destination) return REACH_DESTINATION; If exists adoptable 1-&gt;0 preferred dimension mask = source &amp; ~destination &amp; adoptable; //choose the dimension which has the largest n*N p +N s . Record the value in max1 call OneBest(current, destination, mask, *DT, &amp;max1) If exists adoptable 0-&gt;1 preferred dimension mask = ~source &amp; destination &amp; adoptable; //choose the dimension which has the largest n*N p +N s . Record the value in max2 call OneBest(current, destination, mask, *DT, &amp;max2) If either case above gives a valid dimension return the dimension corresponding to the larger of max1 and max2. If tie, use 1-&gt;0 link. If there is an adoptable 0-&gt;0 spare dimension mask = ~current &amp; ~destination &amp; adoptable &amp; *DT; call OneBest(current, destination, mask, *DT, &amp;max1) If there is an adoptable 1-&gt;1 spare dimension mask = current &amp; destination &amp; adoptable &amp; *DT; call OneBest(current, destination, mask, *DT, &amp;max2) If either case above gives a valid dimension update DT; return the dimension corresponding to the larger of max1 and max2. If tie, use 1-&gt;1 link. Otherwise return ABORT; // should not reach here }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>unsigned</head><label></label><figDesc>OneBest(unsigned current, unsigned destina- tion, unsigned cand, unsigned DT, int *max) { int total, prefer, spare, best, d ; *max 1 ¬-; for(d = 0; d &lt; n; d + +) { If (d is a candidate dimension in cand) { unsigned neighbor = current node's neighbor along dimension d If (neighbor = = destination) { *max = INFINITY; return d; } prefer = number of adoptable preferred dimension at neighbor spare = number of adoptable spare dimension at neighbor (note DT is used here) total = n ´ prefer + spare; If destination has link on dimension d in a (imagined) fault-free setting total = total + Node_Availability; If (total &gt; *max) { *max = total; best = d; // record current winner } } } If (*max = -1)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>ps nNN ×+ scores are 491, ´+ 492,490,490´+´+´+490´+´+´+ respectively. After updating for dimensional availability at destination, their final scores are 37, 38, 39, and 39, respectively (node availability is 3). The 0 ® 1 preferred dimension 0 has score 39. Thus dimension 6 or 8 can be chosen</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 4 .Fig. 5 .</head><label>45</label><figDesc>Fig. 4. Latency of Fault-free Fibonacci-Class Cubes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>Hamming distance between I F and J F is 1, where I F , J F stand for the Fibonacci codes of i and j, respectively.and Extended Fibonacci Cube can be defined in a similar way. Let , nnn EFCVE =&lt;&gt; denote the Enhanced Fibonacci Cube of order n ( 3 n ³ ),³ . Two nodes in EFC n are connected by an edge in n E if and only if their labels differ in exactly one bit position, i.e., Hamming distance is 1. A series of Extended Fibonacci Cubes is defined as {</head><label></label><figDesc></figDesc><table>is defined as 

132 

(,,,) nF 
bbb -××× 
where b j is either 0 or 1 for 

2(1) jn 
££-and 

1 
2 
n 
j 
jj 

ibf -

= 

= å 
. Then Fibonacci Cube of order n ( 
3 
n ³ ) is a graph 

(),() 

nnn 

FCVfEf =&lt;&gt; , where (){0,1,,1} nn 
Vff =×××-and (,)() n 
ijEf Î 
if and only 
if the An equivalent definition is: let 
(,) 

nnn 

FCVE = 
, then 

3 

{1,0} 
V = 
, 4 {01,00,10} 
V = 
and 

12 

0||10|| 

nnn 

VVV --
= 
U 
for 

5 
n ³ , where || de-

notes the concatenation operation and has higher precedence than union operation U . 

Two nodes in 

n 

FC are connected by an edge in n 
E if and only if their Hamming 

distance is 1. To facilitate a unified discussion of Fibonacci-class Cubes, V n can be a 
further defined in an obviously equivalent form: a set of all possible (2) n --bit binary 
numbers, none of which has two consecutive 1's. This definition is important for the 
discussion of properties in the next sub-section. 
Enhanced Fibonacci Cube then 3 {1,0} 
V = 
, 4 {01,00,10} 
V = 
, 5 {001,101,100,000,010} 
V = 
, 6 {0001, 
V = 

0101,0100,0000,0010,1010,1000,1001} 
and 

22 

00||10|| 

nnn 

VVV --
= 
U 

44 

0100||0101|| nn 
VV --
UU 
for 
7 
n </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>2 ){0,1} k k Vk += meaning the Cartesian product of k sets of {0, 1}, and</head><label>2</label><figDesc></figDesc><table>1 

(3){0, 1} k 

k 

Vk 

+ 

+= 
. Two nodes in 
() 

k 

XFCn are connected by 

an edge in 
() 

k 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>). Suppose there is a preferred dimension i. If ik &lt; , then in- verting i a will always produce a valid address. If ik ³ , the discussion is the same as</head><label></label><figDesc></figDesc><table>case I. 
Case III: EFC n+2 . The discussion is similar to case I, but much more complicated. 
Basically, we just need to discuss over the leftmost preferred dimension. Detailed proof 
is 
omitted 
here 
due 
to 
limited 
space, 
but 
is 
available 
at 
http://www.comp.nus.edu.sg/~zhangxi2/proof.pdf. 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 1 . availability vector for Fig. 2</head><label>1</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>Dim Extended Fibonacci Cube XFC 13</head><label></label><figDesc></figDesc><table>14-Dim Extended Fibonacci Cube XFC 13 (16) 

169 

169.8 

170.6 

171.4 

172.2 

173 

0 
1 
2 
3 
4 
5 
6 
7 
8 
9 10 11 12 13 

Number of Faulty Nodes 

Latency (us/packet) 

27.515 

27.525 

27.535 

27.545 

Throughput(pkts/s) 

Latency 
Throughput(log) 

Fig. 6. Latency and Throughput (logarithm) 
of a faulty 14-dim Extended Fibonacci Cube 

20-Dim Regular Fibonacci Cube 

300 

301 

302 

303 

304 

0 
1 
2 
3 
4 
5 
6 

Number of Faulty Nodes 

Latency(us/pkt) 

26.73 

26.74 

26.75 

26.76 

26.77 

Throughput(pkts/s) 

Latency 
Throughput(log) 

Fig. 7. Latency and Throughput 
(logarithm) of a faulty 20-Dim FC 

Fig. 8. Latency and Throughput 
(logarithm) of a faulty 19-Dim EFC 

Fig. 9. Latency and Throughput 
(logarithm) of a faulty 18-Dim XFC 

19-Dim Enhanced Fibonacci Cube 

388.5 

389 

389.5 

390 

390.5 

391 

0 
1 
2 
3 
4 
5 

Number of Faulty Nodes 
Latency (us/packet) 

26.82 

26.822 

26.824 

26.826 

26.828 

26.83 

T h r o u g h p u t ( p k t s / s ) 

Latency 
Throughput 

d 

18-Dim Extended Fibonacci Cube XFC 1 (20) 

257 

258 

259 

260 

261 

1 
2 
3 
4 
5 

Number of Faulty Nodes 
Latency (us/packet) 

25.772 

25.773 

25.774 

25.775 

25.776 

25.777 

T h r o u g h p u t ( p kt s/ s) 

Latency 
Throughput 

Number of Faulty Nodes 
Number of Faulty Nodes 

Number of Faulty Nodes 
Number of Faulty Nodes 

19-Dim Enhanced Fibonacci Cube 
18-Dim Extended Fibonacci Cube XFC 1 (20) 

20-Dim Regular Fibonacci Cube 
14-</table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Hsu</surname></persName>
		</author>
		<title level="m">Fibonacci Cubes-A New Interconnection Topology. IEEE Transactions on Parallel and</title>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="3" to="12" />
		</imprint>
	</monogr>
	<note>Distributed Systems 4[1</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Enhanced Fibonacci Cubes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Hsu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Computer Journal</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="331" to="345" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Extended Fibonacci Cubes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="1203" to="1210" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Cyclic-Cubes: A New Family of Interconnection Networks of Even Fixed-Degrees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">W</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="1253" to="1268" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The Josephus Cube: A Novel Interconnection Network</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">K K</forename><surname>Loh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Hsu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Parallel Computing</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="427" to="453" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Depth-First Search Approach for Fault-Tolerant Routing in Hypercube Multicomputers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M.-S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">G</forename><surname>Shin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="152" to="159" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">An Adaptive Fault-Tolerant Routing Algorithm for Hypercube Multicomputers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1147" to="1152" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A fault-tolerant routing strategy for Gaussian cube using Gaussian tree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">K K</forename><surname>Loh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Parallel Processing Workshops</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="305" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Analysis of Fuzzy-Nero Network Communications. Undergraduate Final Year Project</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xinhua</forename><surname>Zhang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
		<respStmt>
			<orgName>Nanyang Technological University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
