<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T17:05+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">AN EFFICIENT NOMINAL UNIFICATION ALGORITHM</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jordi</forename><surname>Levy</surname></persName>
							<email>levy@iiia.csic.es</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Artificial Intelligence Research Institute (IIIA)</orgName>
								<orgName type="institution" key="instit2">Spanish Council for Scientific Research (CSIC)</orgName>
								<address>
									<settlement>Barcelona</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mateu</forename><surname>Villaret</surname></persName>
							<email>villaret@ima.udg.edu</email>
							<affiliation key="aff1">
								<orgName type="department">Departament d&apos;Informàtica i Matemàtica Aplicada (IMA)</orgName>
								<orgName type="institution">Universitat de Girona (UdG)</orgName>
								<address>
									<settlement>Girona</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">AN EFFICIENT NOMINAL UNIFICATION ALGORITHM</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>Submitted to the International Conference on Rewriting Techniques and Applications</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Nominal Unification is an extension of first-order unification where terms can contain binders and unification is performed modulo α-equivalence. Here we prove that the existence of nominal unifiers can be decided in quadratic time. First, we linearly-reduce nominal unification problems to a sequence of freshness and equalities between atoms, modulo a permutation, using ideas as Paterson and Wegman for first-order unification. Second, we prove that solvability of these reduced problems may be checked in quadratic time. Finally, we point out how using ideas of Brown and Tarjan for unbalanced merging, we could solve these reduced problems more efficiently.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Nominal techniques introduce mechanisms for renaming via name-swapping, for namebinding, and for freshness of names. They were introduced at the beginning of this decade by Gabbay and Pitts [Pit01, <ref type="bibr">Gab01, Pit03]</ref>. These first works have inspired a sequel of papers where bindings and freshness are introduced in other topics, like nominal algebra [Gab06, <ref type="bibr">Gab07, Gab09]</ref>, equational logic <ref type="bibr">[Clo07]</ref>, rewriting <ref type="bibr">[Fer05, Fer07]</ref>, unification <ref type="bibr">[Urb03, Urb04]</ref>, and Prolog <ref type="bibr">[Che04, Urb05]</ref>.</p><p>In this paper we study the complexity of Nominal Unification <ref type="bibr">[Urb03, Urb04]</ref>, an extension of first-order unification where terms can contain binders and unification is performed modulo α-equivalence. Moreover, (first-order) variables (unknowns) are allowed to "capture" bound variables (atoms) contrarily to unification in λ-calculus. In <ref type="bibr">[Urb03, Urb04]</ref> it is described a sound and complete, but inefficient (exponential), algorithm for nominal unification. Later this algorithm was extended to deal with the new-quantifier and locality in <ref type="bibr">[Fer05]</ref>. In <ref type="bibr">[Cal07]</ref> there is a description of a direct but exponential implementation in Maude, and a polynomial implementation in OCAML based on termgraphs. In <ref type="bibr">[Cal08]</ref>, it is described a polynomial algorithm for nominal unification. In <ref type="bibr">[Lev08]</ref> it is proved that the problem can be solved in quadratic time by quadratic reduction to Higher-Order Pattern Unification, that is claimed to be linear <ref type="bibr">[Qia96]</ref>. Therefore, the present algorithm does not improve the complexity bounds already known. However, it has to be noticed that in this paper we describe a practical implementation, and that it is really difficult to obtain a practical algorithm from the proof described in <ref type="bibr">[Qia96]</ref>. In <ref type="bibr">[Cal10]</ref> there is a quadratic algorithm for nominal unification, independently found by Calvès, and also based on Paterson and Wegman's first-order unification algorithm. Other extensions of nominal unification have been studied in [Che05, <ref type="bibr">Dow09, Dow10]</ref>.</p><p>This paper proceeds as follows. In Section 2 we describe nominal logic and the nominal unification algorithm of <ref type="bibr">[Urb03, Urb04]</ref>. In Section 3 we prove that freshness equations and suspensions are mere syntactic sugar. We can translate them in terms of basic nominal equations, with a linear increasing in the size of the problem. In Section 4 we describe the Paterson-Wegman linear algorithm for First-Order Unification <ref type="bibr">[Pat78]</ref> and some preliminary ideas of how we plan to adapt this algorithm to nominal unification. In Section 5, we introduce replacings as L = (a 1 ← b 1 ) · · · (a n ← b n ). We say that t and u are equivalent modulo L, written t = L u, if a n . · · · a 1 .t ≈ b n . · · · b 1 .u. In some cases we need to compute some kind of composition of replacings. This leads us to the introduction of generalized replacings in Section 6. The adaptation of Paterson-Wegman's algorithm is described in Section 7. It allows us to translate a nominal unification problem into a set of replacing equations in linear time. Section 8 is devoted to the verification of these replacing equations. There we prove that it can be done in quadratic time. Finally, in Section 9 we discuss on the possibility of improving this bound and do this verification in quasi-linear time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Preliminaries</head><p>Nominal terms contain variables and atoms. Only variables may be instantiated, and only atoms may be bound. They roughly correspond to the higher-order notions of free and bound variables, respectively, but are considered as completely different entities. Therefore, contrarily to the higher-order perspective, in nominal terms it makes no sense the distinction between free and bound variables depending on the existence of a binder above them.</p><p>Nominal terms 1 (typically t, u, . . . ) are given by the grammar:</p><formula xml:id="formula_0">t ::= t 1 , t 2 | f (t 1 , . . . , t n ) | a | a.t | π X</formula><p>where f is a function symbol, a is an atom, π is a permutation (finite list of swappings), and X is a variable. A swapping (a b) is a pair of atoms of the same sort. The effect of a swapping over an atom is defined by (a b) a = b and (a b) b = a and (a b) c = c, when c 񮽙 = a, b. For the rest of terms the extension is straightforward, in particular,</p><formula xml:id="formula_1">(a b) (c.t) = (a b) c . (a b) t .</formula><p>A permutation is a (possibly empty) sequence of swappings. Suspensions are uses of variables with a permutation of atoms waiting to be applied once the variable is instantiated.</p><p>Substitutions are sort-respecting functions and behave like in first-order logic, hence allowing atom capture, for instance [X → a]a.X = a.a.</p><p>A freshness environment (typically ∇) is a list of freshness constraints a # X stating that the instantiation of X cannot contain free occurrences of a.</p><p>The notion of nominal term α-equivalence, noted ≈, is defined by means of the following theory:</p><formula xml:id="formula_2">∇ ⊢ t 1 ≈ u 1 · · · ∇ ⊢ t n ≈ u n ∇ ⊢ f (t 1 , . . . , t n ) ≈ f (u 1 , . . . , u n ) (≈-function) ∇ ⊢ a ≈ a (≈-atom) a 񮽙 = a ′ ∇ ⊢ t ≈ (a a ′ ) t ′ ∇ ⊢ a#t ′ ∇ ⊢ a.t ≈ a ′ .t ′ (≈-abst-2) ∇ ⊢ t ≈ t ′ ∇ ⊢ a.t ≈ a.t ′ (≈-abst-1) (a#X) ∈ ∇ for all a such that π a 񮽙 = π ′ a ∇ ⊢ π X ≈ π ′ X (≈-susp.)</formula><p>where the freshness predicate # is defined by:</p><formula xml:id="formula_3">∇ ⊢ a#t 1 · · · ∇ ⊢ a#t n ∇ ⊢ a#f (t 1 , . . . , t n ) (#-function) a 񮽙 = a ′ ∇ ⊢ a#a ′ (#-atom) ∇ ⊢ a#a.t (#-abst-1) a 񮽙 = a ′ ∇ ⊢ a#t ∇ ⊢ a#a ′ .t (#-abst-2) (π −1 a #X) ∈ ∇ ∇ ⊢ a#π X (#-susp.)</formula><p>Their intended meanings are: ∇ ⊢ a # t holds if, for every substitution σ respecting the freshness environment ∇ (i.e. avoiding the atom captures forbidden by ∇), a is not free in σ(t); ∇ ⊢ t ≈ u holds if, for every substitution σ respecting the freshness environment ∇, t and u are α-convertible.</p><p>A nominal unification problem (typically P ) is a set of equations of the form t ?</p><p>≈ u or a # ? t, equational problems and freshness problems respectively. A solution of a nominal problem is given by a substitution σ and a freshness environment ∇. Formally, the pair ∇, σ solves P if, ∇ ⊢ a # σ(t), for freshness problems a # ? t ∈ P , and ∇ ⊢ σ(t) ≈ σ(u), for equational problems t ? ≈ u ∈ P . The first linear First-Order Unification algorithm was described by Paterson and Wegman <ref type="bibr">[Pat78]</ref>. Here we describe it in terms of transformation rules as it is done by Martelli and Montanari in <ref type="bibr">[Mar82]</ref>.</p><p>Definition 2.2. The Paterson-Wegman can be described by the following two transformation rules. Simplification:</p><formula xml:id="formula_4">{X 1 , X ′ 1 , . . . } = f (Y 1 , . . . , Y m ) {X 2 , X ′ 2 , . . . } = f (Z 1 , . . . , Z m ) X 1 = X 2    =⇒        {X 1 , X ′ 1 , . . . , X 2 , X ′ 2 , . . . } = f (Y 1 , . . . , Y m ) Y 1 = Z 1 . . . Y m = Z m Variable: {X 1 , X ′ 1 , . . . } = t {X 2 , X ′ 2 , . . . } = ∅ X 1 = X 2    =⇒ {X 1 , X ′ 1 , . . . , X 2 , X ′ 2 , . . . } = t</formula><p>At every transformation, the selected equation X 1 = X 2 has to be maximal in the sense that there is no other equation X m 1 = X m 2 and a set of equations of the form</p><formula xml:id="formula_5">{X m i , . . . } = f m−1 (. . . , X m−1 i , . . . ), . . . , {X 1 i , . . . } = f 1 (. . . , X i , . . . ) for i = 1 or i = 2.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Three Initial Simplifications</head><p>In this section we show how we can simplify nominal unification problems getting rid of freshness equations, of suspensions, and flattening all applications and abstractions. We will show that these simplifications only increase the size of the problem linearly. Lemma 3.1 shows us how to encode a freshness equation as an equality equation, and Lemma 3.2, how to encode a suspension also as an equality. Therefore, we can conclude that freshness equations and suspensions are mere syntactic sugar in nominal unification. Proof. We first prove that a#t, Id is a solution of {a.b.t</p><formula xml:id="formula_6">? ≈ b.b.t} when b 񮽙 = a . . . . t ≈ t a#t . . . . (lemma 2.7) b#(a b) t b.t ≈ a.(a b) t (≈-abst-2) a#t a#b.t (#-abst-2) a.b.t ≈ b.b.t (≈-abst-2)</formula><p>In this proof we prove t ≈ t from an empty set of assumptions. We can prove that this is always possible, for any term t, by structural induction on t. We also prove b#(a b) t from a#t, using Lemma 2.7 of <ref type="bibr">[Urb04]</ref>. Now, since ∇ ′ ⊢ σ(∇) and  </p><formula xml:id="formula_7">∇ ⊢ t ≈ t ′ implies ∇ ′ ⊢ σ(t) ≈ σ(t ′ ) (</formula><formula xml:id="formula_8">t ≈ (a b)u b.t ≈ b.(a b)u (≈-abst-1) a#a.u (#-abst-1) a.b.t ≈ b.a.u (≈-abst-2)</formula><p>Lemma 3.3. Let X be a fresh variable not occurring elsewhere. Then, P ∪ {a.t</p><formula xml:id="formula_9">? ≈ u} and P ∪ {a.X ? ≈ u, X ? ≈ t} are equivalent P ∪ {f (t 1 , . . . , t n ) ? ≈ u} and P ∪ {f (t 1 , . . . , t i−1 , X, t i+1 , t n ) ? ≈ u, X ? ≈ t i } are equivalent, P ∪ {(a b) t ? ≈ u} and P ∪ {(a b) X ? ≈ u, X ? ≈ t} are equivalent, P ∪ {t 1 ? ≈ t 2 } and P ∪ {X ? ≈ t 1 , X ?</formula><p>≈ t 2 } are equivalent, and</p><formula xml:id="formula_10">P ∪ {Y 1 ? ≈ Y 2 } and [Y 1 → Y 2 ]P are equivalent.</formula><p>Proof. Let us consider the first statement. If ∇, σ solves P ∪ {a.t</p><formula xml:id="formula_11">? ≈ u}, then it is enough to extend σ with X → σ(t) to get a solution of P ∪ {a.X ? ≈ u, X ? ≈ t}. In the opposite direction, any solution of P ∪ {a.X ? ≈ u, X ? ≈ t} is a solution of P ∪ {a.t ?</formula><p>≈ u}, because, for any three terms t 1 , t 2 and t 3 , if a.t 2 ≈ t 1 and t 2 ≈ t 3 , then a.t 3 ≈ t 1 .</p><p>Notice that the previous lemma does not hold for unification in λ-calculus. For instance, {λa.f (a) = ? λb.f (b)} is trivially solvable. However, {λa.X = ? λb.b, X = ? a} is unsolvable because, in λ-calculus, we have to avoid variable-capture in substitutions. This fact prevented Qian <ref type="bibr">[Qia96]</ref> to apply this simplification in his linear-time algorithm for higher-order pattern unification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3.4. There exists a linear reduction from Nominal Unification to a simplified version of Nominal Unification where all equations are of the form</head><formula xml:id="formula_12">X ? ≈ a, X ? ≈ f (Y 1 , . . . , Y n ) or X ? ≈ a.Y .</formula><p>Proof. We apply four reductions. First, applying Lemma 3.1, we can remove all freshness equations. Second, applying the transformations of Lemma 3.3 widely, replacing the first set of equations by the second whenever t is not a variable (in the first and third rules), or t i is not a variable (in the second rule), or t 1 and t 2 are not variables (in the forth rule), we can flat all equations. Now, all equations have a variable in one side and a term of the form a, a.X, f (X 1 , . . . , X n ), or (a b) X in the other side. In particular, all suspensions will occur in equations of the form X </p><formula xml:id="formula_13">3 ? ≈ a.Z 1 , Z 3 ? ≈ b.Z 2 , Z 1 ? ≈ b.X, Z 2 ?</formula><p>≈ a.Y , where Z 1 , Z 2 and Z 3 are fresh. A simple analysis shows that all these transformations are linear.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">A First (Naive) Idea</head><p>Considering the similarities between Nominal Unification and FO Unification, a natural way to address the implementation of an efficient nominal unification algorithm is to postpone as much as possible the test of freshness predicates and equality between atoms. We can adapt algorithm of Definition 4.1 as follows. Instead of equations between variables, we use equations between variables affected by a permutation: X 1 = πX 2 . Moreover, these equations are coupled with a set of freshness restrictions with the form of an implication:</p><formula xml:id="formula_14">a 񮽙 = π 1 b 1 ∧ · · · ∧ a 񮽙 = π n b n ⇒ a#π 0 X 2 .</formula><p>The application rule is quite similar to the one used in algorithm 4.1, but the abstraction rule involves the extension of the permutation, the addition of a new associated freshness restriction and of additional conditions to the rest of freshness restrictions. Definition 4.1. Consider the following (sound but incomplete) nominal unification algorithm. Given a set of simplified equations, transform them into a set of multi-equations as follows. First, transform any equation X ?</p><p>= t into a multi-equation {X} = t, and second, transform any pair of multi-equations {X} = t 1 , {X} = t 2 into {X} = t 1 , {X ′ } = t 2 , X = X ′ , and add a multi-equation {X} = ∅ for any variable not occurring in the left of any multi-equation, until all variables occur in the left of a multi-equation exactly once. Then, apply the following transformation rules wisely. Application:</p><formula xml:id="formula_15">{X 1 , S 1 } = f (Y 1 , . . . , Y m ) {X 2 , S 2 } = f (Z 1 , . . . , Z m ) X 1 = πX 2 P 1 ⇒ c 1 #π 1 X 2 · · · P n ⇒ c n #π n X 2                =⇒                {X 1 , S 1 , πX 2 , πS 2 } = f (Y 1 , . . . , Y m ) Y 1 = πZ 1 , · · · , Y m = πZ m P 1 ⇒ c 1 #π 1 Z 1 , . . . , P 1 ⇒ c 1 #π 1 Z m · · · P n ⇒ c n #π n Z 1 , . . . , P n ⇒ c n #π n Z m Abstraction: {X 1 , S 1 } = a.Y {X 2 , S 2 } = b.Z X 1 = πX 2 P 1 ⇒ c 1 #π 1 X 2 · · · P n ⇒ c n #π n X 2                    =⇒                    {X 1 , S 1 , πX 2 , πS 2 } = a.Y Y = (a πb)πZ P 1 ∧ c 1 񮽙 = π 1 b ⇒ c 1 #π 1 Z · · · P n ∧ c n 񮽙 = π 1 b ⇒ c n #π n Z a 񮽙 = πb ⇒ a#πZ Atom: {X 1 , S 1 } = a {X 2 , S 2 } = b X 1 = πX 2 P 1 ⇒ c 1 #π 1 X 2 · · · P n ⇒ c n #π n X 2                =⇒                {X 1 , S 1 , πX 2 , πS 2 } = a a = πb P 1 ⇒ c 1 񮽙 = π 1 b · · · P n ⇒ c n 񮽙 = π n b</formula><p>Notice that the algorithm previously described is incomplete. For instance, the variable</p><formula xml:id="formula_16">X 1 in {X 1 , S 1 } = f (Y 1 , .</formula><p>. . , Y m ) could be already affected by a permutation, which makes the rule inapplicable. However, these rules allow us to solve the following example:</p><formula xml:id="formula_17">Example 4.2. The Nominal unification problem a 3 .a 2 .a 1 .f (c 1 , c 2 ) ? ≈ b 3 .b 2 .b 1 .f (d 1 , d 2 )</formula><p>is transformed by the naive algorithm into the following set of conditional equalities and inequalities.</p><formula xml:id="formula_18">c 1 = (a 1 (a 2 (a 3 b 3 )b 2 )(a 3 b 3 )b 1 )(a 2 (a 3 b 3 )b 2 )(a 3 b 3 )d 1 c 2 = (a 1 (a 2 (a 3 b 3 )b 2 )(a 3 b 3 )b 1 )(a 2 (a 3 b 3 )b 2 )(a 3 b 3 )d 2 a 3 񮽙 = b 3 ∧ a 3 񮽙 = b 2 ∧ a 3 񮽙 = b 1 ⇒ a 3 񮽙 = d 1 a 3 񮽙 = b 3 ∧ a 3 񮽙 = b 2 ∧ a 3 񮽙 = b 1 ⇒ a 3 񮽙 = d 2 a 2 񮽙 = (a 3 b 3 )b 2 ∧ a 2 񮽙 = (a 3 b 3 )b 1 ⇒ a 2 񮽙 = (a 3 b 3 )d 1 a 2 񮽙 = (a 3 b 3 )b 2 ∧ a 2 񮽙 = (a 3 b 3 )b 1 ⇒ a 2 񮽙 = (a 3 b 3 )d 2 a 1 񮽙 = (a 2 (a 3 b 3 )b 2 )(a 3 b 3 )b 1 ⇒ a 1 񮽙 = (a 2 (a 3 b 3 )b 2 )(a 3 b 3 )d 1 a 1 񮽙 = (a 2 (a 3 b 3 )b 2 )(a 3 b 3 )b 1 ⇒ a 1 񮽙 = (a 2 (a 3 b 3 )b 2 )(a 3 b 3 )d 2</formula><p>It is easy to see that a generalization of this simple problem to a n . . . . .a <ref type="figure" target="#fig_1">1 .f (c 1 , .</ref> . . , c m )</p><formula xml:id="formula_19">? ≈ b n . . . . .b 1 .f (d 1 , . . . , d m )</formula><p>would result in a set of inequalities of size O(n m). The number of comparisons of atoms that have to be checked in order to compute the result of applying the permutation and check the equalities is also O(n m).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Simple Replacings</head><p>In this section we introduce a new concept, similar to the idea of substitution and of swapping, but with some differences. Thus, we have preferred to call it with the new name replacings.</p><formula xml:id="formula_20">Definition 5.1. A replacing is a (possibly empty) list of pairs of atoms L = (a 1 ← b 1 ) · · · (a n ← b n ).</formula><p>Given two terms t and u and a replacing L = (a 1 ← b 1 ) · · · (a n ← b n ), we say that t and u are equivalent modulo L, noted t = L u, if a n .</p><formula xml:id="formula_21">· · · a 1 .t ≈ b n . · · · b 1 .u.</formula><p>Any replacing may be associated with a permutation of atoms, defined as follows. This definition and the following lemma, helps us to see replacings as permutations, plus a set of associated freshness equations. The example bellow also shows that the associated permutation is not enough to characterize a replacing. </p><formula xml:id="formula_22">2) Π (a←b)L = (a Π L b)Π L Lemma 5.3</formula><p>. Given a replacing L = (a 1 ← b 1 ) · · · (a n ← b n ) and two terms t and u, t = L u holds, iff (1) t ≈ Π L u, and (2) for any i = 1, . . . , n, if</p><formula xml:id="formula_23">a i 񮽙 = Π (a i+1 ←b i+1 )...(an←bn) b j for all j = i, . . . , 1, then a i #Π (a i+1 ←b i+1 )...(an←bn) u.</formula><p>Example 5.4. Notice that the permutation Π L does not characterize the replacing L. For instance, we have</p><formula xml:id="formula_24">Π (a←b) = Π (b←a) = Π (b←a)(a←b) = Π (a←b)(b←a) = Π (a←b)(a←b) = (a b) = (b a)</formula><p>However, assuming a 񮽙 = b, we have</p><formula xml:id="formula_25">t = (a←b) u ⇔ t = (a←b)(a←b) u ⇔ t = (a b)u ∧ a#u t = (b←a) u ⇔ t = (b←a)(b←a) u ⇔ t = (a b)u ∧ b#u t = (b←a)(a←b) u ⇔ t = (a←b)(b←a) u ⇔ t = (a b)u</formula><p>If for any pair of term we have t = L u ⇔ t = L ′ u, then this will be also true for any pair of atoms, and we will have Π L = Π L ′ . This motivates the following definition.</p><p>Definition 5.5. We say that two replacings L and L ′ are equivalent if, for any pair of terms t and u, we have Next, we will describe a normalization procedure of replacings. We say that a replacing (a 1 ← b 1 ) · · · (a n ← b n ) is normalized if a 1 , . . . , a n is a list of pairwise distinct atoms, and b 1 , . . . , b n too. Lemma 5.8 states that, any normalized replacing may be characterized by a set, instead of a list), of pairs of atoms. Lemma 5.9 shows how we can remove duplicated pairs and normalized replacings, on the expenses of adding freshness equations.</p><formula xml:id="formula_26">t = L u iff t = L ′ u Lemma 5.6. t = (a 1 ←b 1 )···(an←bn) u iff u = (b 1 ←a 1 )···(bn←an) t.</formula><p>When atoms are not repeated in a replacing, then they are basically 2 a permutation, as the following lemma states.</p><p>Lemma 5.8. If L = (a 1 ← b 1 ) · · · (a n ← b n ) is a normalized replacing, i.e. a replacing where a 1 , . . . , a n is a list of pairwise distinct atoms, and b 1 , . . . , b n too, then</p><formula xml:id="formula_27">(1) Π L is a permutation satisfying Π L (b i ) = a i , for i = 1, . . . , n, (2) (a 1 ← b 1 ) · · · (a n ← b n ) and (a π(1) ← b π(1) ) · · · (a π(n) ← b π(n) ) are equivalent, for any permutation π. (3) For any a, b ∈ A, a = L b iff Π L (a) = b.</formula><p>Proof. By induction on n. For any i = 1, . . . , n, we have</p><formula xml:id="formula_28">Π (a 1 ←b 1 )···(an←bn) b i = (a 1 Π (a 2 ←b 2 )···(an←bn) b 1 ) · · · (a i Π (a i+1 ←b i+1 )···(an←bn) b i ) =Π (a i+1 ←b i+1 )···(an←bn) . . . (a n b n ) b i =a i</formula><p>Hence, the i-th swapping changes Π (a i+1 ←b i+1 )···(an←bn) b i by a i . Now we are going to prove that a i is not affected by the swappings (a j Π (a j+1 ←b j+1 )···(an←bn) b j ) where j &gt; i. On one hand, by assumption, a j 񮽙 = a i when j &gt; i. On the other hand, Π (a j+1 ←b j+1 )···(an←bn) b j 񮽙 = a i because (a j+1 ← b j+1 ) · · · (a n ← b n ) is a strictly shorter replacing, and i ∈ {j + 1, . . . , n}, therefore by induction hypothesis (Π (a j+1 ←b j+1 )···(an←bn) ) −1 (a i ) = b i 񮽙 = b j .</p><p>Lemma 5.9. The replacing L(a ← b)L ′ where a occurs on the left in L, and b occurs on the right in L, is equivalent to L L ′ . In other words,</p><formula xml:id="formula_29">L 1 (a ← c)L 2 (d ← b)L 3 (a ← b)L 4 and L 1 (a ← c)L 2 (d ← b)L 3 L 4 are equivalent.</formula><p>If a occurs on the left in L, but b does not occur in the right in L, then, for any pair of terms t and u, t = L(a←b)L ′ u iff b#u and t = LL ′ u.</p><p>Similarly, if a does not occur on the left in L, but b occurs in the right in L, then, for any pair of terms t and u, t = L(a←b)L ′ u iff a#t and t = LL ′ u.</p><p>Proof. In nominal logic, and in λ-calculus we have the following implications:</p><p>If a#t and a.t ≈ b.u, then b#u and t ≈ u (5.1) If t ≈ u, a#t and b#u, then a.t ≈ b.u (5.2) By definition of replacing, t = (a 1 ←b 1 )...(an←bn) u is equivalent to a n . · · · .a <ref type="bibr">1</ref>  Lemmas 5.8 and 5.9 describe a characterization of replacings in terms of a set of pairs of atoms (normalized replacing), and a set of freshness equations. In the following we make explicit this characterization in terms of a set of pairs, called rewriting set, and a set of forbidden atoms.</p><formula xml:id="formula_30">.t ≈ b n . · · · .b 1 .u.</formula><p>Definition 5.10. Given a replacing L, we define the sets of rewriting pairs and forbidden atoms, noted Rew(L) and F or(L), as follows</p><formula xml:id="formula_31">Rew(L) = {(a ← b) ∈ A × A | a 񮽙 = b ∧ a = L b} F or(L) = {a ∈ A | ¬(a = L a)} Lemma 5.11. Replacings L and L ′ are equivalent iff Rew(L) = Rew(L ′ ) and F or(L) = F or(L ′ ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 5.12. For any replacing L we have</head><formula xml:id="formula_32">Rew([ ]) = ∅ Rew(L(a ← b)) = Rew(L) ∪ {a ← b} if a 񮽙 = b and ∀c.a ← c ∈ Rew(L) and ∀c.c ← b ∈ Rew(L) Rew(L) otherwise F or([ ]) = ∅ F or(L(a ← b)) =    F or(L) ∪ {b} if ∃c.a ← c ∈ Rew(L) and ∀d.d ← b ∈ Rew(L) F or(L) ∪ {a} if ∃d.d ← b ∈ Rew(L) and ∀c.a ← c ∈ Rew(L) F or(L) otherwise</formula><p>Proof. Given a replacing, we can use Lemma 5.9 to remove pairs with a duplicated component wisely until we obtain a normalized replacing. By Lemma 5.8, this normalized replacing is the rewriting set, whereas the set of freshness equations define the set of forbidden atoms. Then we can check that the previous recursions hold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Generalized Replacings</head><p>Sometimes, simple replacings are not enough to represent the equations between atoms that we have to check. In some cases, we have to use a kind of composition of replacings. In this section we show how the notion of simple replacing may be generalized for this purpose, and how we can extend the definition of set of rewritings and set of forbidden atoms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 6.1. A generalized replacing is an expression generated by the grammar</head><formula xml:id="formula_33">L ::= Id | (a ← b) :: L | L 1 • L 2 | L −1</formula><p>with the following semantics</p><formula xml:id="formula_34">t = Id u, if t ≈ u, t = (a←b)::L u, if a.t = L b.u, t = L 1 •L 2 u,</formula><p>if there exists a term v such that t = L 1 v and v = L 2 u, and</p><formula xml:id="formula_35">t = L −1 u, if u = L t.</formula><p>The sets Rew(L) and F or(L) are defined for generalized replacings as for simple replacings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 6.2. Any generalized replacing is equivalent to a composition of simple replacings accordingly to the following equivalences between replacings</head><formula xml:id="formula_36">(L 1 • L 2 ) • L 3 = L 1 • (L 2 • L 3 ) (a ← b) :: L 1 • L 2 = (a ← b) :: L 1 • (a ← b) :: L 2 (a 1 ← b 1 ) :: · · · :: (a n ← b n ) :: Id = (a 1 ← b 1 ) · · · (a n ← b n )</formula><p>The following lemma shows us how we can recursively compute the set of rewritings and of forbidden atoms of a generalized replacing.</p><formula xml:id="formula_37">Lemma 6.3. Rew(Id) = F or(Id) = ∅ Rew (a ← b) :: L = Rew(L) \ {a ← c | ∀c ∈ A} \ {c ← b | ∀c ∈ A} ∪ {a ← b} if a 񮽙 = b ∅ if a = b F or (a ← b) :: L = F or(L) ∪ {c | a ← c ∈ Rew(L) ∨ c ← b ∈ Rew(L)} Rew(L 1 • L 2 ) = {a ← c | ∃b ∈ A a ← b ∈ Rew(L 1 ) ∧ b ← c ∈ Rew(L 2 )} ∪{a ← b | a ← b ∈ Rew(L 1 ) ∧ b ∈ F or(L 2 )} ∪{a ← b | a ← b ∈ Rew(L 2 ) ∧ a ∈ F or(L 1 )} F or(L 1 • L 2 ) = F or(L 1 ) ∪ F or(L 2 ) Rew(L −1 ) = {(b ← a) | (a ← b) ∈ Rew(L)} F or(L −1 ) = F or(L)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">A Paterson-Wegman Style Algorithm</head><p>In this section we describe our nominal unification algorithm in the style of Paterson and Wegman <ref type="bibr">[Pat78]</ref>, or, to be precise, in the style of the description that Martelli and Montanari <ref type="bibr">[Mar82]</ref> makes of this algorithm.</p><p>First, w.l.o.g. we consider that we have a single nominal equation (we get rid of freshness equations, by Lemma 3.1, and reduce {t 1 ≈ X 2 is written as X 1 = Id X 2 , using the replacing Id. Then, we apply the following transformation rules wisely, where the equation X 1 = L X 2 is in all cases a maximal equation, in the sense of Definition 2.2. Like in the classical PatersonWegman algorithm, there always exists an equation satisfying this condition, and we can find this equation intelligently, such that the total time consumed by this search is linearly bounded on the size of the original problem (see <ref type="bibr">[Pat78]</ref> for more details).</p><formula xml:id="formula_38">? ≈ u 1 , . . . , t n ? ≈ u n } to f (t 1 , . . . f (t n−1 , t n ) . . . ) ? ≈ f (u 1 , . . . f (u n−1 , u n ) . . . ),</formula><p>Definition 7.1. Consider the following set of transformation rules:</p><p>Application:</p><formula xml:id="formula_39">{Π L 1 X 1 , Π L ′ 1 X ′ 1 , . . . } = f (Y 1 , . . . , Y m ) {Π L 2 X 2 , Π L ′ 2 X ′ 2 , . . . } = f (Z 1 , . . . , Z m ) X 1 = L X 2    =⇒              Π L 1 X 1 , Π L ′ 1 X ′ 1 , . . . , Π L 1 •L X 2 , Π L 1 •L•L −1 2 •L ′ 2 X ′ 2 , . . . = f (Y 1 , . . . , Y m ) Y 1 = L 1 •L•L −1 2 Z 1 · · · Y m = L 1 •L•L −1 2 Z m Abstraction: {Π L 1 X 1 , Π L ′ 1 X ′ 1 , . . . } = a.Y {Π L 2 X 2 , Π L ′ 2 X ′ 2 , . . . } = b.Z X 1 = L X 2    =⇒      Π L 1 X 1 , Π L ′ 1 X ′ 1 , . . . , Π L 1 •L X 2 , Π L 1 •L•L −1 2 •L ′ 2 X ′ 2 , . . . = a.Y Y = (a←b)::(L 1 •L•L −1 2 ) Z Atom: {Π L 1 X 1 , Π L ′ 1 X ′ 1 , . . . } = a {Π L 2 X 2 , Π L ′ 2 X ′ 2 , . . . } = b X 1 = L X 2    =⇒      Π L 1 X 1 , Π L ′ 1 X ′ 1 , . . . , Π L 1 •L X 2 , Π L 1 •L•L −1 2 •L ′ 2 X ′ 2 , . . . = a a = L 1 •L•L −1 2 b Variable: {Π L 1 X 1 , Π L ′ 1 X ′ 1 , . . . } = t {Π L 2 X 2 , Π L ′ 2 X ′ 2 , . . . } = ∅ X 1 = L X 2    =⇒ Π L 1 X 1 , Π L ′ 1 X ′ 1 , . . . Π L 1 •L X 2 , Π L 1 •L•L −1 2 •L ′ 2 X ′ 2 , . . . = t {Π L 1 X 1 , Π L ′ 1 X ′ 1 , . . . } = ∅ {Π L 2 X 2 , Π L ′ 2 X ′ 2 , . . . } = t X 1 = L X 2    =⇒ Π L 2 •L −1 X 1 , Π L 2 •L −1 •L −1 1 •L ′ 1 X ′ 1 , . . . Π L 2 X 2 , Π L ′ 2 X ′ 2 , . . . = t</formula><p>Theorem 7.2. Given a simplified nominal unification problem P , P is solvable if, and only if, the rules of Definition 7.1 transform the problem into a set of equations of the form</p><formula xml:id="formula_40">               {Π L 1 1 X 1 1 , . . . , Π L r 1 1 X r 1 1 } = t 1 · · · {Π L 1 m X 1 m , . . . , Π L rm m X rm m } = t m a 1 = L 1 b 1 · · · a n = Ln b n                where {a 1 = L 1 b 1 , .</formula><p>. . , a n = Ln b n } holds, and the equations t i = L j i X j i , for i = 1, . . . , m and j = 1, . . . , r i , are solvable. When P is solvable, then set of equations t i = L j i X j i encode a solution. Moreover, the size of the DAG representing the new set of equations is O(|P |), and it can be obtained in time O(|P |).</p><p>Proof. Soundness and completeness results from the rules ≈-abst-1, ≈-abst-2, and ≈-fun and ≈-atom of <ref type="bibr">[Urb04]</ref>, conveniently written in terms of replacings. The transformations resemble Paterson-Wegman transformations (Definition 2.2), and the termination proof is based on the same ideas. Notice that some transformations duplicate some L's. Therefore, the linear bound only applies representing equations as DAGs. </p><formula xml:id="formula_41">{X} = ∅, {Y 1 } = a.Y 3 , {Y 2 } = b.Y 4 , {Y 3 } = b.X, {Y 4 } = b.X, Y 1 = Id Y 2</formula><p>Applying twice the abstraction rule we obtain: </p><formula xml:id="formula_42">{X} = ∅, {Y 1 , Y 2 } = a.Y 3 , {Y 3 , Π<label>(</label></formula><formula xml:id="formula_43">Y 4 Y 3 Y 1 ? ≈ b. b.X Y 5 Y 2 , we obtain {Y 1 , Y 2 } = a.Y 3 {Y 3 , Π (a←b)::Id Y 5 } = b.Y 4 {Y 4 , Π (b←b)::(a←b)::Id X} = a .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Efficient Checking of Replacings</head><p>Using the algorithm described in Definition 7.1, we obtain a set of replacing equations of the form a = L b, a set of equations of the form {Π L 1 X 1 , . . . , Π L r X r } = t that codify the solution, and a DAG that represents the generalized replacings L's. Now, we will describe how we can check the solvability of these equations in quadratic time.</p><p>The main idea is to compute, for every node of the DAG, the two sets Rew(L) and F or(L), where L is the replacing represented by this node. We will use the values of these sets already computed for the descendants of the node. Therefore, we proceed from the leaves of the DAG to the roots. We assume that we have a total ordering on the atoms A. For efficiency, we compute three lists for every node L: a list RL that contains the elements of Rew(L) ordered by the first component, RR with the elements of Rew(L) ordered by the second component, and an ordered list F with the elements of F or(L). Moreover, the lists RL and RR are doubly linked, such that knowing the position of an element (a ← b) in RL, we can know its position in RR and vice versa. Lemma 6.3 describes how to compute these list. Just as an example, <ref type="figure" target="#fig_1">Figure 1</ref> shows how to compute RL, RR and F for L = L 1 • L 2 , being RL i , RR i and F i , for i = 1, 2, the respective lists for L i .</p><p>To check if a set of equations P of the form {Π L 1 X 1 , . . . , Π Lr X r } = t has solution, and what is this solution, we compute the set of atoms that cannot occur free in the instance of X, written F or(X). This computation aborts (using rule 5) if P is unsolvable. Definition 8.1. Given a set of equations P , for every variable X, we compute F or(X) as the minimal set of atoms that satisfy all the following rules, or we abort.</p><p>(</p><formula xml:id="formula_44">1) If P contains {Π L 1 X 1 , . . . , Π Lr X r } = t, then Π L −1 j Π L i F or(X i ) ∪ F or(L i ) ⊆ F or(X j ), for i 񮽙 = j = 1, . . . , r. (2) If P contains {Π L 1 X 1 , . . . , Π Lr X r } = f (Y 1 , . . . , Y m ), then Π L i (F or(X i )) ∪ F or(L i ) ⊆ F or(Y j ), for i = 1, .</formula><p>. . , r, and j = 1, . . . , m.</p><formula xml:id="formula_45">(3) If P contains {Π L 1 X 1 , . . . , Π Lr X r } = a.Y , then Π L i (F or(X i )) ∪ F or(L i ) \ {a} ⊆ F or(Y ), for i = 1, . . . , r. (4) If P contains {Π L X, Π L ′ X, . . . } = t and Π L (a) 񮽙 = Π L ′ (a), for some a ∈ A, then a ∈ F or(X). (5) If P contains {Π L 1 X 1 , . . . , Π Lr X r } = a and a ∈ Π L i (F or(X i )) ∪ F or(L i )</formula><p>, for some i = 1, . . . , r, then P is unsolvable and abort.</p><p>Input: RL 1 , RR 1 , F 1 , RL 2 , RR 2 , F 2 Output: RL, RR, F i 1 := 1 ; i 2 := 1 ; j 1 := 1 ; j 2 := 1 while i 1 ≤ RR 1 .size() and</p><formula xml:id="formula_46">i 2 ≤ RL 2 .size() do let (a ← b) = RR 1 [i 1 ] and (b ′ ← c) = RL 1 [i 2 ] if b = b ′ then following the double links, change (a ← b) in RL 1 by (a ← c) following the double links, change (b ← c) in RR 2 by (a ← c) remove (a ← b) from RR 1 and (b ← c) from RL 2 i 1 := i 1 + 1 i 2 := i 2 + 1 else if b &lt; b ′ then while j 2 ≤ F 2 .size() and F 2 [j 2 ] &lt; b do j 2 := j 2 + 1 if j 2 ≤ F 2 .size() and F 2 [j 2 ] = b then remove (a ← b) from RR 1 and RL 1 i 1 := i 1 + 1 else while j 1 ≤ F 1 .size() and F 1 [j 1 ] &lt; b do j 1 := j 1 + 1 if j 1 ≤ F 1 .size() and F 1 [j 1 ] = b ′ then remove (b ′ ← c) from RR 2 and RL 2 i 2 := i 2 + 1 if i 1 = RR 1 .size() then while i 2 ≤ RL 2 .size() do while j 1 ≤ F 1 .size() and F 1 [j 1 ] &lt; b ′ do j 1 := j 1 + 1 if j 1 ≤ F 1 .size() and F 1 [j 1 ] = b ′ then remove (b ′ ← c) from RR 2 and RL 2 i 2 := i 2 + 1 else while i 1 ≤ RR 1 .size() do while j 2 ≤ F 2 .size() and F 2 [j 2 ] &lt; b do j 2 := j 2 + 1 if j 2 ≤ F 2 .size() and F 2 [j 2 ] = b then remove (a ← b) from RR 1 and RL 1 i 1 := i 1 + 1 RL := merge(RL 1 , RL 2 ) RR := merge(RR 1 , RR 2 ) F := merge(F 1 , F 2 ) return RR, RL, F Figure 1: Computation of Rew(L 1 •L 2 ) and F or(L 1 •L 2 ) in time O(|Rew(L 1 )|+|Rew(L 2 )|+ |F or(L 1 )| + |F or(L 2 )|).</formula><p>Lemma 8.2. Given a set of equations of the form {Π L 1 X 1 , . . . , Π Lr X r } = t, we can compute F or(X), for every variable X, or abort, in quadratic time on the size of the DAGrepresentation of the equations. Moreover, the solution encoded by the equations is {a#X | a ∈ F or(X)}.</p><p>Proof. At every node of the DAG representing a generalized replacing L, we compute Rew(L) and F or(L), using the values Rew(L i ) and F or(L i ) previously computed for the descendants L i of the node. This computation takes at worst linear time for every node, being the worst case the composition of replacings <ref type="figure" target="#fig_1">Figure 1</ref>. Therefore, the overall computation takes quadratic time. Then, using the rules of Definition 8.1, in quadratic time we can check if all equations are solvable.   In example 7.4, the equation {Y 4 , Π (b←b)::(a←b)::Id X} = a, using rule 5 of Definition 8.1, allows us to deduce that the problem is unsolvable.</p><formula xml:id="formula_47">L = L 1 • L 2 with time O(|Rew(L 1 )| + |Rew(L 2 )| + |F or(L 1 )| + |F or(L 2 )|), described in</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Conclusions, can we do it better?</head><p>We have presented an efficient algorithm that computes nominal unifiers in quadratic time. This result does not improve the bound found by ourself by reduction to the problem of Higher-Order Pattern Unification <ref type="bibr">[Lev08]</ref>. The natural question now is: can we still improve this bound?</p><p>A careful analysis of the algorithm of <ref type="figure" target="#fig_1">Figure 1</ref> shows us that it is basically a merge function, and that the complete check of the whole DAG of replacings is not very distinct from a merge-sort algorithm. In fact, if we could ensure that, when L = L 1 • L 2 , we have |Rew(L)| + |F or(L)| ≥ |Rew(L 1 )| + |F or(L 1 )| + |Rew(L 2 )| + |F or(L 2 )| and |Rew(L 1 )| + |F or(L 1 )| ≈ |Rew(L 2 )| + |F or(L 2 )|, then the cost of the algorithm would be dominated by T (n) = 2 T (n/2) + O(n) that has solution O(n log n). If we could ensure |Rew(L)| + |F or(L)| ≥ |Rew(L 1 )|+|F or(L 1 )|+|Rew(L 2 )|+|F or(L 2 )|, but not the balance between the data structures of L 1 and L 2 , then we could implement the sorted lists using AVL, and apply the ideas of Brown and Tarjan <ref type="bibr">[Bro79]</ref> for merging of unbalanced sorted lists. This unbalance merge of two lists of sizes n 1 and n 2 can be done in time O(n 1 log n 2 n 1 ). Therefore, the time of the complete checking would be dominated by T (n) = T (n 1 ) + T (n 2 ) + O(n 1 log n 2 n 1 ), where n = n 1 + n 2 . In this case, the solution is also O(n log n). Therefore, we can conclude that we can check a set of replacings in time O(n log n) on the size of the tree (not the DAG) representing the replacing. This means that, when the DAG is a tree, for instance in example 4.2, we can check the replacings in quasi-linear time.</p><p>To conclude, consider the following example, that shows that the quadratic bound seems difficult to improve in the general case. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 2 . 1 .</head><label>21</label><figDesc>The solutions of the equation a.X ? ≈ b.X can not instantiate X with terms containing free occurrences of the atoms a and b, for instance if we apply the substitution [X → a] to both sides of the equation we get [X → a]a.X = a.a for the left hand side and [X → a]b.X = b.a for the right hand side, and obviously a.a ≈ b.a. The most general solution of this equation is {a#X, b#X}, [ ].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Lemma 3. 1 .</head><label>1</label><figDesc>Let b 񮽙 = a. Then, P ∪ {a#t} and P ∪ {a.b.t ? ≈ b.b.t} have the same solutions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Lemma 3 . 2 .</head><label>32</label><figDesc>P ∪ {t ? ≈ (a b)u} and P ∪ {a.b.t ? ≈ b.a.u} have the same solutions. Proof. If a = b the proof is obvious. If a 񮽙 = b, then the proof is similar to proof of Lemma 3.1. In this case, the proof of a.b.t ? ≈ b.a.u from t ? ≈ (a b)u is as follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>?</head><label></label><figDesc>≈ (a b)Y . Applying Lemma 3.2, we can remove all them, translating them into a.b.X ? ≈ b.a.Y . Forth, all these equations can be translated into Z</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Definition 5. 2 .</head><label>2</label><figDesc>Given a replacing L, we define its associated permutation Π L inductively as follows (1) Π [ ] = [ ], being [ ] the empty list, and empty sequence of swappings. (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>The following lemma describes a method to check if c = L d in time O(|L|). Lemma 5.7. Given two atoms c and d and a replacing (a ← b)L: c = (a←b)L d iff c = a and b = d, or c 񮽙 = a, b 񮽙 = d and c = L d.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>For the first statement: For a given i, if a i ∈ {a i−1 , . . . , a 1 }, then a i #a i−1 . · · · .a 1 .t and t = (a 1 ←b 1 )...(an←bn) u (using 5.1) imply a i−1 . · · · .a 1 .t ≈ b i−1 . · · · .b 1 .u, hence t = (a 1 ←b 1 )...(a i−1 ←b i−1 )(a i+1 ←b i+1 )...(an←bn) u.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>provided that there exists a binary constant f ). Then, we flatten this equation, obtaining a set of equations of the form X ? ≈ f (Y 1 , . . . , Y n ), X ? ≈ a.Y , X ? ≈ a or X ? ≈ (a b)Y , and a single equation X 1 ? ≈ X 2 , where X 1 and X 2 do not occur elsewhere bellow any other symbol. Finally, by Lemma 3.2, we can get rid of equations of the form X ? ≈ (a b)Y . By Theorem 3.4, the resulting nominal unification problem has size O(|P |) on the size of the original problem. Following the notation of [Mar82], equations of the form X ? ≈ f (Y 1 , . . . , Y n ), X ? ≈ a.Y , and X ? ≈ a are written in the form {X} = f (Y 1 , . . . , Y n ), {X} = a.Y , and {X} = a, respectively. The equation X 1 ?</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Example 7 . 3 .</head><label>73</label><figDesc>The equation a.b.X ? ≈ b.b.X can be simplified as:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>a←b)::Id Y 4 } = b.X, X = (b←b)::(a←b)::Id X One application of the variable rule gives us the simplified equations {Y 1 , Y 2 } = a.Y 3 , {Y 3 , Π (a←b)::Id Y 4 } = b.X, {X, Π (b←b)::(a←b)::Id X} = ∅ Example 7.4. From a. b. a</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Example 8 . 4 .</head><label>84</label><figDesc>Consider example 7.3, where we obtain {Y 1 , Y 2 } = a.Y 3 , {Y 3 , Π (a←b)::Id Y 4 } = b.X, {X, Π (b←b)::(a←b)::Id X} = ∅ . The DAG representation with Rew(L) and F or(L) of every node representing a gener- alized replacing is as follows.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>{Y 1 , Y 2 } = a.Y 3 {Y 3 , Π • Y 4 } = b.X {X, Π • X} = ∅ (b ← b) :: • (a ← b) :: • Id Rew = {} F or = {a} Rew = {a ← b} F or = {} Rew = {} F or = {} Definition 8.1 computes F or(Y 3 ) = F or(X) = {a}, F or(Y 4 ) = {b}, F or(Y 1 ) = F or(Y 2 ) = ∅. Now, considering only original variables, i.e. X, we obtain the solution a#X.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Example 9 . 1 .</head><label>91</label><figDesc>Given a permutation π of m = |π| elements, an a value n, we can construct the following two equation of size O(n + m) a π 1 . · · · .a πm .f (f (. . . f (Y, X n ) . . . , X 2 ), X 1 ) ≈ a 1 . · · · .a m .f (X 1 , f (X 2 , . . . f (X n , Y ) . . . )) Y ≈ f (a 1 , f (a 2 , . . . f (a m−1 , a m ) . . . )) From these equations we get the following DAG. This problem is solvable, if we have π 2 n = Id. It seems difficult to answer this question in time faster than O(n m). a 1 = • a 1 a 2 = • a 2 a m = • a m • • • • • • • • • (a πm ← a m ) :: • (a π 1 ← a 1 ) :: • Id</figDesc></figure>

			<note place="foot" n="1"> For simplicity, we do not consider the unit value nor the pairing. Instead of them we consider n-ary function symbols.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A fast merging algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of the ACM</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="211" to="226" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Implementing nominal unification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Calvès</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fernández</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ENTCS</title>
		<imprint>
			<biblScope unit="volume">176</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="25" to="37" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A polynomial nominal unification algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Calvès</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fernández</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">403</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="285" to="306" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Complexity and Implementation of Nominal Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Calvès</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
		<respStmt>
			<orgName>King&apos;s College London</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">α-prolog: A logic programming language with names, binding and α-equivalence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cheney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Urban</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 20 th Int. Conf. on Logic Programming, ICLP&apos;04</title>
		<meeting>of the 20 th Int. Conf. on Logic Programming, ICLP&apos;04</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="volume">3132</biblScope>
			<biblScope unit="page" from="269" to="283" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Equivariant unification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cheney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 16 th Int. Conf. on Term Rewriting and Applications, RTA&apos;05</title>
		<meeting>of the 16 th Int. Conf. on Term Rewriting and Applications, RTA&apos;05</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="volume">3467</biblScope>
			<biblScope unit="page" from="74" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Clouston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pitts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nominal equational logic. ENTCS</title>
		<imprint>
			<biblScope unit="volume">1496</biblScope>
			<biblScope unit="page" from="223" to="257" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Permissive nominal terms and their unification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Dowek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gabbay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Mulligan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 24 th Convegno Italiano di Logica Computazionale, CILC&apos;09</title>
		<meeting>of the 24 th Convegno Italiano di Logica Computazionale, CILC&apos;09</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Permissive nominal terms and their unification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Dowek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gabbay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Mulligan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Logic Journal of the IGPL</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Nominal rewriting with name generation: abstraction vs. locality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fernández</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gabbay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 7 th Int. Conf. on Principles and Practice of Declarative Programming, PPDP&apos;05</title>
		<meeting>of the 7 th Int. Conf. on Principles and Practice of Declarative Programming, PPDP&apos;05</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="47" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fernández</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gabbay</surname></persName>
		</author>
		<title level="m">Nominal rewriting. Information and Computation</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="volume">205</biblScope>
			<biblScope unit="page" from="917" to="965" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A new approach to abstract syntax with variable binding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gabbay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pitts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects of Computing</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3-5</biblScope>
			<biblScope unit="page" from="341" to="363" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Nominal algebra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gabbay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mathijssen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 18 t h Nordic Workshop on Programming Theory, NWPT&apos;06</title>
		<meeting>of the 18 t h Nordic Workshop on Programming Theory, NWPT&apos;06</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A formal calculus for informal equality with binding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gabbay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mathijssen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic, Language, Information and Computation</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007" />
			<biblScope unit="volume">4576</biblScope>
			<biblScope unit="page" from="162" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Nominal (universal) algebra: equational logic with names and binding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gabbay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mathijssen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Computation</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1455" to="1508" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Nominal unification from a higher-order perspective</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Villaret</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 19 th Int. Conf on Rewriting Techniques and Applications, RTA&apos;08</title>
		<meeting>of the 19 th Int. Conf on Rewriting Techniques and Applications, RTA&apos;08</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="volume">5117</biblScope>
			<biblScope unit="page" from="246" to="260" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An efficient unification algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Martelli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Montanari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="258" to="282" />
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Linear unification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Paterson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">N</forename><surname>Wegman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="158" to="167" />
			<date type="published" when="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Nominal logic: A first order theory of names and binding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pitts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 4 th Int. Symp. on Theoretical Aspects of Computer Software, TACS&apos;01</title>
		<meeting>of the 4 th Int. Symp. on Theoretical Aspects of Computer Software, TACS&apos;01</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="volume">2215</biblScope>
			<biblScope unit="page" from="219" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Nominal logic, a first order theory of names and binding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pitts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">186</biblScope>
			<biblScope unit="page" from="165" to="193" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Unification of higher-order patterns in linear time and space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Qian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Logic and Computation</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="315" to="341" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Nominal unification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Urban</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pitts</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gabbay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 17 th Int. Work. on Computer Science Logic, CSL&apos;03</title>
		<meeting>of the 17 th Int. Work. on Computer Science Logic, CSL&apos;03</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="volume">2803</biblScope>
			<biblScope unit="page" from="513" to="527" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Nominal unification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Urban</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pitts</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gabbay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">323</biblScope>
			<biblScope unit="page" from="473" to="497" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">If accepted for publication by RTA, this work will be licensed under the Creative Commons Attribution-NoDerivs License</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Urban</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cheney</surname></persName>
		</author>
		<ptr target="http://creativecommons.org/licenses/by-nd/3.0/" />
	</analytic>
	<monogr>
		<title level="m">Proc. of the Int. Conf. on Typed Lambda Calculus and Applications, TLCA&apos;05</title>
		<meeting>of the Int. Conf. on Typed Lambda Calculus and Applications, TLCA&apos;05</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="volume">3461</biblScope>
			<biblScope unit="page" from="401" to="416" />
		</imprint>
	</monogr>
	<note>Avoiding equivariance in alpha-prolog. To view a copy of this license</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
