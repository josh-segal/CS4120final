<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:56+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Interpolating Functions from Large Boolean Relations</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jie-Hong</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering/Graduate Institute of Electronics Engineering</orgName>
								<orgName type="institution">National Taiwan University</orgName>
								<address>
									<postCode>10617</postCode>
									<settlement>Taipei</settlement>
									<country key="TW">Taiwan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hsuan-Po</forename><surname>Lin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering/Graduate Institute of Electronics Engineering</orgName>
								<orgName type="institution">National Taiwan University</orgName>
								<address>
									<postCode>10617</postCode>
									<settlement>Taipei</settlement>
									<country key="TW">Taiwan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei-Lun</forename><surname>Hung</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering/Graduate Institute of Electronics Engineering</orgName>
								<orgName type="institution">National Taiwan University</orgName>
								<address>
									<postCode>10617</postCode>
									<settlement>Taipei</settlement>
									<country key="TW">Taiwan</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Interpolating Functions from Large Boolean Relations</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Boolean relations are an important tool in system synthesis and verification to characterize solutions to a set of Boolean constraints. For physical realization as hardware, a deter-ministic function often has to be extracted from a relation. Prior methods however are unlikely to handle large problem instances. From the scalability standpoint this paper demonstrates how interpolation can be exploited to extend deter-minization capacity. A comparative study is performed on several proposed computation techniques. Experimental results show that Boolean relations with thousands of variables can be effectively determinized and the extracted functional implementations are of reasonable quality.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Relations are a powerful tool to represent mappings. Admitting one-to-many mappings, they are strictly more generic than functions. Taking the Boolean mappings {(x1, x2) ∈ B 2 } → {(y1, y2) ∈ B 2 } of <ref type="figure" target="#fig_0">Figure 1</ref> as an example, we can express the (one-to-one) mapping of (a) using Boolean functions f1 = x1x2 and f2 = ¬x1¬x2 for outputs y1 and y2, respectively. On the other hand, there is no similar functional representation for the mapping of (b) due to the oneto-many mapping under (x1, x2) = (0, 1). However, this mapping can be specified by the relation (with characteristic function) R = ¬x1¬x2¬y1y2 ∨ ¬x1x2¬y1¬y2 ∨ ¬x1x2y1y2 ∨ x1¬x2¬y1¬y2 ∨ x1x2y1¬y2.</p><p>Owing to their generality, relations can be exploited to specify the permissible behavior of a design. For instance, the behavior of a system can be specified using relations as constraints over its input stimuli, state transitions, and output responses. Moreover, the flexibility of a circuit can be naturally characterized by a relation. In fact, relations subsume the conventional notion of don't-cares. To see it, assume Figure 1 (b) to be a relaxed permissible mapping of (a). That is, under input (x1, x2) = (0, 1) the output (y1, y2) can be (1, 1) in addition to <ref type="bibr">(0,</ref><ref type="bibr">0)</ref>. This flexibility is not expressible using the conventional don't-care representation, and it can be useful in circuit optimization. By trimming off the output choice (0, 0) under input (0, 1), the resulting mapping in (c) has new output functions f1 = x2 and f2 = ¬x1, simpler than those of (a).</p><p>Compared with relations, functions, though more restrictive, are often closer to physical realization due to their deterministic nature. Therefore conversions between relations and functions are usually indispensable. To name two examples, in reachability analysis, the transition functions of a state transition system are often converted to a transition relation to abstract away input variables; in circuit synthesis, optimal functions can be extracted from a relation representing some specification or permissible behavior.</p><p>Whereas converting functions to relations is straightforward, converting relations to functions involves much compli- cation. Among many possibilities, relation-to-function conversion in its two extremes can be range-preserving, where all possible output responses under every input stimulus 1 are produced (with the help of parametric variables), and can be deterministically reducing, where only one output response under every input stimulus is produced (without the need of parametric variables). Both extremes have important applications in system synthesis and verification. The former is particularly useful in verification. As the constraints specified by a relation are preserved, the conversion helps create a testbench to generate simulation stimuli <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b20">21]</ref> mimicking the constrained system environment. The later on the other hand is particularly useful in synthesis <ref type="bibr" target="#b3">[4]</ref>. As the synthesized components are typically much compact than those with range preserved <ref type="bibr" target="#b1">[2]</ref>, it is attractive for generating the final implementation. This paper is concerned with the latter, in particular, determinizing a relation and extracting functional implementation in the Boolean domain.</p><p>Brayton and Somenzi <ref type="bibr" target="#b3">[4]</ref> were among the first to observe the utility of Boolean relations in logic minimization. Boolean relations are useful not only in characterizing circuit flexibilities <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b14">15]</ref>, but also in characterizing solutions to design specifications/constraints <ref type="bibr" target="#b1">[2]</ref>. There were intensive efforts focusing on the exact or heuristic optimization of functions implementing a given relation. Such optimization objectives, for instance, can be in terms of two-level logic minimization under the SOP representation <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b18">19]</ref>, or in term of some polynomial functions over BDD sizes <ref type="bibr" target="#b0">[1]</ref>. State-ofthe-art methods, such as <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b0">1]</ref>, are based on decision diagrams. As BDDs are not memory efficient in representing large Boolean functions, these methods have intrinsic limitations and are not scalable to large problem instances. There has been growing need for scalable determinization of large Boolean relations. Synthesis from specifications shows one such example <ref type="bibr" target="#b1">[2]</ref>. The quest for scalable determinization methods remains.</p><p>From the scalability standpoint, we seek reasonable representation of large Boolean functions and, in particular, use and-inverter graphs (AIGs) (see, e.g., <ref type="bibr" target="#b16">[17]</ref>) as the underlying data structure. Due to their simple and multi-level nature, AIGs are often much compact and are closer to final logic implementation than the two-level SOP form. Moreover they provide a convenient interface with SAT solvers in terms of conversion to CNFs and representation of interpolants <ref type="bibr" target="#b17">[18]</ref>. Therefore, unlike previous efforts on relation solving, our objective is to convert a large relation to a set of functions with reasonable quality. Similar attempts were pursued recently in other efforts of scalable logic synthesis, e.g., <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b15">16]</ref>.</p><p>Our main exploration includes 1) exploiting interpolation <ref type="bibr" target="#b5">[6]</ref> for Boolean relation determinization and function extraction, 2) studying expansion-and substitution-based quantifications with reuse, and 3) showing support minimization in the interpolation framework. A comparative empirical study is performed on various computation schemes. Experimental results suggest that interpolation is essential to scalable relation determinization and function extraction. Boolean relations with thousands of variables can be determinized effectively and the extracted functions are typically of reasonable quality compared with their respective reference models.</p><p>This paper is organized as follows. Essential backgrounds are given in Section 2. Section 3 presents the main results on relation determinization and function extraction; Section 4 discusses function simplification. Experimental results and discussions are given in Section 5. Finally, Section 6 concludes the paper and outlines some future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARIES</head><p>As a notational convention, substituting function g for variable v in function f is denoted as f [v/g].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Boolean Relation</head><p>A relation R ⊆ X × Y can be equivalently represented as a characteristic function R : X × Y → B such that (a, b) ∈ R for a ∈ X, b ∈ Y if and only if R(a, b) = 1.</p><formula xml:id="formula_0">Definition 1. A relation R : X × Y → B is total (in X) if ∀a ∈ X, ∃b ∈ Y.R(a, b) = 1. Otherwise, R is partial.</formula><p>Unless otherwise said we shall assume that a relation R ⊆ X × Y is total in X.</p><formula xml:id="formula_1">Definition 2. Given a partial relation R : X × Y → B, an (input) assignment a ∈ X is undefined if no (output) assignment b ∈ Y makes R(a, b) = 1.</formula><p>This paper assumes that X is the input space B n spanned by input variables x = (x1, . . . , xn) and Y is the output space B m spanned by output variables y = (y1, . . . , ym).</p><p>Given a Boolean relation R : B n ×B m → B with input variables x = (x1, . . . , xn) and output variables y = (y1, . . . , ym), we seek a functional implementation f = (f1, . . . , fm) with</p><formula xml:id="formula_2">fi : B n → B such that D = m i=1 (yi ≡ fi( x))</formula><p>is contained by R, i.e., the implication D ⇒ R holds. Equivalently, the relation after substituting fi for yi R[y1/f1, . . . , ym/fm] equals constant 1.</p><p>Note that the above relation D is a deterministic relation, i.e.,</p><formula xml:id="formula_3">∀a ∈ X, ∀b, b ∈ Y.((D(a, b) ∧ D(a, b )) ⇒ (b = b )).</formula><p>Therefore seeking a functional implementation of a total relation can be considered as determinizing the relation. On the other hand, any deterministic total relation has a unique functional implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Satisfiability and Interpolation</head><p>The reader is referred to prior work <ref type="bibr" target="#b10">[11]</ref> for a brief introduction to SAT solving and circuit-to-CNF conversion, which are essential to our development. To introduce terminology and convention for later use, we restate the following theorem.</p><p>Theorem 1 (Craig Interpolation Theorem).</p><p>[6] Given two Boolean formulas φA and φB, with φA ∧ φB unsatisfiable, then there exists a Boolean formula ψA referring only to the common variables of φA and φB such that φA ⇒ ψA and ψA ∧ φB is unsatisfiable.</p><p>The Boolean formula ψA is referred to as the interpolant of φA with respect to φB. Modern SAT solvers can be extended to construct interpolants from resolution refutations <ref type="bibr" target="#b17">[18]</ref>.</p><p>In the sequel, we shall assume that Boolean relations, functions, and interpolants are represented using AIGs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">RELATIONS TO FUNCTIONS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Single-Output Relation</head><p>We consider first the functional implementation of a singleoutput relation R( x, y) with y the only output variable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Total Relation</head><p>Proposition 1. A relation R( x, y) is total if and only if the conjunction of ¬R( x, 0) and ¬R( x, 1) is unsatisfiable.</p><p>Theorem 2. Given a single-output total relation R( x, y), the interpolant ψA of the refutation of</p><formula xml:id="formula_4">¬R( x, 0) ∧ ¬R( x, 1) (1)</formula><p>with φA = ¬R( x, 0) and φB = ¬R( x, 1) corresponds to a functional implementation of R.</p><p>Proof. Since R is total, Formula (1) is unsatisfiable by Proposition 1. That is, the set {a ∈ X | R(a, 0) = 0 and R(a, 1) = 0} is empty. Hence φA (respectively φB) characterizes the set SA = {a ∈ X | R(a, 1) = 1 and R(a, 0) = 0} (respectively SB = {a ∈ X | R(a, 0) = 1 and R(a, 1) = 0}). As φA ⇒ ψA and ψA ⇒ ¬φB, the interpolant ψA maps every element of SA to 1, every element of SB to 0, and every other element to either 0 or 1.</p><formula xml:id="formula_5">Let D be (y ≡ ψA). Then D ⇒ R.</formula><p>Therefore interpolation can be seen as a way to exploit flexibility for function derivation without explicitly computing don't cares.</p><p>Corollary 1. Given a single-output total relation R, both R( x, 1) and ¬R( x, 0) are legitimate functional implementation of R.</p><p>Proof. Let φA = ¬R( x, 0) and φB = ¬R( x, 1). Because φA ⇒ R( x, 1) and R( x, 1) ⇒ ¬φB, R( x, 1) is a legitimate interpolant. Similarly, ¬R( x, 0) is a legitimate interpolant, too.</p><p>In fact, the cofactored relations R( x, 1) and ¬R( x, 0) are the largest (weakest) and smallest (strongest) interpolants, respectively, in terms of solution spaces. Therefore to derive a functional implementation of a single-output total relation, interpolation is unnecessary. However practical experience suggests that functional implementations obtained through interpolation are often much simpler in AIG representation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Partial Relation</head><p>Note that Theorem 2 works only for total relations because partial relations make Formula (1) satisfiable. To handle partial relations, we treat undefined input assignments as don't-care conditions (this treatment is legitimate provided that the undefined input assignments can never be activated) and define complete totalization as follows.</p><p>Definition 3. Given a single-output partial relation R, its complete totalization is the new relation</p><formula xml:id="formula_6">T ( x, y) = R( x, y) ∨ ∀y.¬R( x, y).<label>(2)</label></formula><p>Note that T = R if and only if R is total. Accordingly Theorem 2 is applicable to a totalized relation T with φA = ¬T ( x, 0) and</p><formula xml:id="formula_7">(3) φB = ¬T ( x, 1),<label>(4)</label></formula><p>which can be further simplified to</p><formula xml:id="formula_8">φA = ¬R( x, 0) ∧ R( x, 1) and (5) φB = ¬R( x, 1) ∧ R( x, 0).<label>(6)</label></formula><p>Observe that the conjunction of Formulas <ref type="formula">(5)</ref> and <ref type="formula" target="#formula_8">(6)</ref> is trivially unsatisfiable. Further, either of ¬R( x, 0) and R( x, 1) is a legitimate interpolant. Therefore, as long as the undefined input assignments of R are never activated, the interpolant is a legitimate functional implementation of R. (This fact will play a role in the development of Section 3.2.2.) Given a (partial or total) relation R with y being the only output variable, in the sequel we let F I(y, R) denote a functional implementation of y with respect to R. Among many possibilities, F I(y, R) can be derived through the interpolation of Formulas (5) and (6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Multiple-Output Relation</head><p>We now turn attention to the functional implementation of a multiple-output relation R( x, y1, . . . , ym) with m &gt; 1. In essence, we intend to reduce the problem so as to apply the previous determinization of single-output relations.</p><p>A determinization procedure contains two phases: The first phase reduces the number of output variables; the second phase extracts functional implementation. We study two determinization procedures with different ways of reducing the number of output variables. One is through existential quantification; the other is through substitution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Determinization via Expansion Reduction</head><p>As a notational convention, we let R (i) denote ∃ym, . . . , yi.R for 1 ≤ i ≤ m. Through standard existential quantification by formula expansion, i.e., ∃x.ϕ = ϕ[x/0] ∨ ϕ[x/1] for some formula ϕ and variable x, one can reduce a multiple-output relation R to a single-output relation R <ref type="bibr" target="#b1">(2)</ref> .</p><p>In the first phase, R (i) can be computed iteratively as follows.</p><formula xml:id="formula_9">R (m) = ∃ym.R . .</formula><p>.</p><formula xml:id="formula_10">R (i) = ∃yi.R (i+1)</formula><p>. . .</p><formula xml:id="formula_11">R (2) = ∃y2.R (3) for i = m − 1, . . . , 2.</formula><p>In the second phase, functional implementations of all output variables can be obtained through the following iterative calculation.</p><formula xml:id="formula_12">f1 = F I(y1, R (2) )</formula><p>. . .</p><formula xml:id="formula_13">fi = F I(yi, R (i+1) [y1/f1, . . . , yi−1/fi−1])</formula><p>. . . for i = 2, . . . , m − 1. The above procedure is similar to prior work (see, e.g., <ref type="bibr" target="#b18">[19]</ref>) with some subtle differences: First, the quantification results of the first phase are reused in the second-phase computation. It reduces the number of quantifications from O(m 2 ) to O(m). Second, interpolation is the key element in the computation and AIGs are the underlying data structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Determinization via Substitution Reduction</head><p>Alternatively the solution to the determinization of a singleoutput relation can be generalized as follows. Each time we treat all except one of the output variables as the input variables. Thereby we see a single-output relation rather than a multiple-output relation. For example, let ym be the only output variable and treat y1, . . . , ym−1 be additional input variables. In the enlarged input space (spanned by y1, . . . , ym−1 as well as x), however, R may not be total even though it is total in the original input space X. Let f m = F I(ym, R), obtained through interpolation mentioned in Section 3.1.2. Note that since f m depends not only on x, but also on y1, . . . , ym−1, it is not readily a functional implementation of ym.</p><p>In the first phase, the number of output variables can be iteratively reduced through the following procedure.  </p><formula xml:id="formula_14">R i = R i+1 [yi/f i ] . . . f 2 = F I(y2, R 3 ) R 2 = R 3 [y2/f 2 ] for i = m − 1, . . . , 2.</formula><p>In the second phase, the functional implementations can be obtained through the following iterative calculation.</p><formula xml:id="formula_15">f1 = F I(y1, R 2 )</formula><p>. . .  . This fact is true however and a detailed exposition can be found in the work <ref type="bibr" target="#b7">[8]</ref>. By induction on i = m, . . . , 2 using Lemma 1, one can further claim that R i = R (i) . Note that the above computation implicitly relies on the don't-care assumption of partial relations. This assumption is indeed legitimate because the don't cares for deriving f i can never be activated when substituting f i for yi in R i+1 . Comparing R (i) of Section 3.2.1 and R i of Section 3.2.2, one may notice that the AIG of R (i) is in general wider in width but shallower in depth, and, in contrast, that of R i narrower but deeper.</p><p>As an implementation technicality, relations R (i) (similarly R i ) can be stored in the same AIG manger. So structurally equivalent nodes are hashed together, and logic sharing is possible among relations R (i) (similarly R i ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Deterministic Relation</head><p>We consider the special case of extracting functions from a deterministic relation.</p><p>Lemma 2. Given a deterministic relation D( x, y) total in the input space X with</p><formula xml:id="formula_16">D = m i=1 (yi ≡ fi),<label>(7)</label></formula><p>let φA = D( x, y1, . . . , yi−1, 1, yi+1, . . . , ym) and</p><formula xml:id="formula_17">(8) φB = D( x, y 1 , . . . , y i−1 , 0, y i+1 , . . . , y m ),<label>(9)</label></formula><p>where y and y are independent variables. Then the interpolant of φA with respect to φB is functionally equivalent to fi.</p><p>Proof. Since D is deterministic and total in X, for every a ∈ X there exists a unique b ∈ Y such that D(a, b) = 1. It follows that the formulas </p><p>must induce a partition on the input space X, and thus the interpolant of φA with respect to φB must logically equivalent to Formula (11), which is unique.</p><p>Back to the computation of Section 3.2.2, let</p><formula xml:id="formula_19">D = R ∧ i (yi ≡ f i ).<label>(12)</label></formula><p>Since the relation D is deterministic, the computation of Lemma 2 can be applied to compute fi. The strengths of this new second-phase computation are twofold: First, no substitution is needed, in contrast to the second-phase computation of Section 3.2.2. Hence the formula sizes of φA and φB in interpolant computation do not grow, unlike the previous second-phase computation. As interpolant sizes are more or less proportional to the formula sizes of φA and φB, this approach is particularly desirable. Second, only functions f i , but not relations R i , are needed in the computation. Since the formula sizes of R i are typically much larger than those of f i , this approach saves memory by discharging R i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">FUNCTION SIMPLIFICATION</head><p>The following lemma can be exploited in reducing the support variables of a functional implementation. Lemma 3. For two Boolean formulas φA and φB with an unsatisfiable conjunction, there exists an interpolant without referring to variable xi if and only if the conjunction of ∃xi.φA and φB (equivalently the conjunction of φA and ∃xi.φB) is unsatisfiable.</p><p>Proof. (⇐=) Assume the conjunction of ∃xi.φA and φB (similarly φA and ∃xi.φB) is unsatisfiable. Since φA ⇒ ∃xi.φA (similarly φB ⇒ ∃xi.φB), the conjunction of φA and φB is unsatisfiable as well. Also by the common-variable property of Theorem 1, the existence condition holds.</p><p>(=⇒) Observe that ∃xi.φA (respectively ∃xi.φB) is the tightest xi-independent formula that is implied by φA (respectively φB). The existence of an interpolant of φA with respect to φB without referring to xi infers the unsatisfiability of the conjunction of ∃xi.φA and φB as well as that of φA and ∃xi.φB.</p><p>By the lemma, we can possibly knock out some variables from an interpolant.</p><p>Note that, in Lemma 3, it suffices to quantify xi over φA or φB even though it is okay to quantify on both. In practice, quantification on just one formula results in smaller interpolants because the unsatisfiability is easier to be shown in SAT solving.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EXPERIMENTAL RESULTS</head><p>The proposed methods were implemented in the ABC package <ref type="bibr" target="#b2">[3]</ref>; the experiments were conducted on a Linux machine with Xeon 3.4GHz CPU and 6Gb RAM.</p><p>To prepare Boolean relations, we constructed the transition relations of circuits taken from ISCAS and ITC benchmark suites. Different amounts of don't cares were inserted to the transition relations to introduce nondeterminism. We intended to retrieve a circuit's transition functions in the following experiments.</p><p>The original circuits 2 were minimized with the ABC command dc2, and so were the AIGs produced during determinization and function extraction. The profile of the original circuits (after the removal of primary-output functions and after dc2 synthesis) is shown in <ref type="table" target="#tab_0">Table 1</ref>, where "(n, m)" denotes the pair of input-and output-variable sizes of the transition relation, "#n" denotes the number of AIG nodes, "#l" AIG logic levels, and "#v" the summation of support variables of all transition functions.</p><p>We first study the usefulness of interpolation in contrast to cofactoring, which can be considered as a way of deriving special interpolants as mentioned in Section 3.1.1. In the experiment, a circuit was determinized via expansion reduction, where the functional implementations extracted in the second phase were derived differently using interpolation   and cofactoring to compare. Taking circuit b11 as a typical example, <ref type="figure" target="#fig_7">Figure 2</ref> contrasts the difference between the two techniques. As can be seen, by cofactoring, the function sizes grow almost exponentially during the iterative computation; by interpolation, the function sizes remain under control. In fact, derived by cofactoring, say, R (i+1) with yi = 1, function fi has almost the same size as R (i+1) unless command dc2 can effectively minimize fi. However, dc2 is unlikely to be helpful for large fi as justified by experiments. Below we compare different determinization methods, including BDD-based computation, that via expansion reduction (Section 3.2.1), denoted Xp, that via substitution reduction (Section 3.2.2), denoted St, and that via constructing deterministic relation (Section 3.3), denoted SD. Dynamic variable reordering and BDD minimization are applied in BDD-based computation. <ref type="table">Table 2</ref> shows the results of function extraction from relations without don't care insertion. BDD-based computation is not scalable as expected. There are five circuits whose transition relations cannot be built compactly using BDDs under 500K nodes and the computation cannot finish either within 30 hours CPU time or within the memory limitation. Ratio 1 and Ratio 2 are normalized with respect to the data of the original circuits of <ref type="table" target="#tab_0">Table 1</ref>, whereas Ratio 3 is normalized with respect to the BDD-based derivation. Ratio 1 covers all the ten circuits, whereas Ratio 2 and Ratio 3 cover only the five circuits that BDD-based derivation can finish.</p><p>By Ratio 1, we observe that the derived functions (without further postprocessing to minimize) are about 3-times larger in nodes, 4-times larger in logic levels, and 9% smaller in support sizes. To be shown in <ref type="table">Table 4</ref>, with postprocessing, the derived functions can be substantially simplified and are comparable to the original sizes. By Ratio 2, we see that even BDD-based derivation may increase circuit sizes by 70% while logic levels are reduced by 11%. By Ratio 3, we see that the results of the SAT-based methods are about 40% larger in nodes and 2-times larger in logic levels. <ref type="table" target="#tab_2">Table 3</ref> shows the results of function extraction from relations with don't cares inserted. For a circuit with r registers, r · 10% random cubes (conjunction of literals of input and state variables) are created. Each cube represents some don't cares for a randomly selected set of functions. Presumably the more the don't cares are inserted, the simpler the transition functions are extracted. In practice, however, such simplification 3 is not guaranteed (even in BDD-based computation). The reasons can be twofold: Firstly, the simplifi- cation achieves only local optimums. Secondly, relations with don't cares inserted become more sophisticated and affect interpolant derivation. Nevertheless the results of <ref type="table">Table 2</ref> and <ref type="table" target="#tab_2">Table 3</ref> are comparable.</p><p>The above experiments of Xp, St, and SD used only light synthesis operations in minimizing the extracted functions. Nonetheless, it is possible to greatly simplify these functions with heavier synthesis operations. To justify such possibilities, we applied ABC command collapse once followed by dc2 twice as postprocessing. <ref type="table">Table 4</ref> shows the statistics of extracted functions by Xp for relations without don't care insertion. (Similar results were observed for St and SD, and for cases with don't care insertion.) The postprocessing results of the original functions and extracted functions are shown. This postprocessing time is listed in the last column. Operation collapse failed on circuit s15850, and the two ratios shown excludes the data of s15850. As can be seen, the postprocessing makes the extracted functions comparable to the original ones. Since the postprocessing time is short, our method combined with some powerful synthesis operations can effectively extract simple functions from large relations, where pure BDD-based computation fails. Our method can be used as a way of bypassing the BDD memory explosion problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSIONS AND FUTURE WORK</head><p>We have shown that Boolean relations with thousands of variables can be determinized inexpensively using interpolation. The extracted functions from a relation are of reasonable sizes. With such extended capacity, we would anticipate real-world applications, which might in turn enable constraint-based synthesis and verification, synthesis from specifications, and other areas that require solving large Boolean relations.</p><p>As we just presented a first step, there remain some obstacles to overcome. In particular, the unpredictability of interpolation prevents relation determinization from being robustly scalable. Moreover, we may need good determinization scheduling and powerful interpolant/AIG minimization techniques, especially under the presence of flexibility.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Boolean mappings.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>fm</head><label></label><figDesc>= F I(ym, R[y1/f1, . . . , ym−1/fm−1])</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>=</head><label></label><figDesc>F I(yi, R i+1 )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>The following fact can be shown. Lemma 1. [8] Given a relation R and f m = F I(ym, R), the equality R[ym/f m ] = ∃ym.R holds. It may be surprising, at first glance, that any f m = F I(ym, R) results in the same R[ym/f m ]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>. . . , yi−1, yi+1, . . . , ym.D[yi/1]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Circuit b11 determinized by expansion reduction with function extraction by interpolation vs. cofactoring in the second phase.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><head>Table 1 : Profile of original benchmark circuits.</head><label>1</label><figDesc></figDesc><table>circuit 
(n, m) 
orig 
#n 
#l 
#v 
s5378 
(214, 179) 
624 
12 
1570 
s9234.1 
(247, 211) 
1337 
25 
3065 
s13207 
(700, 669) 
1979 
23 
3836 
s15850 
(611, 597) 
2648 
36 
15788 
s35932 
(1763, 1728) 
8820 
12 
7099 
s38584 
(1464, 1452) 
9664 
26 
19239 
b10 
(28, 17) 
167 
11 
159 
b11 
(38, 31) 
482 
21 
416 
b12 
(126, 121) 
953 
16 
1639 
b13 
(63, 53) 
231 
10 
383 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Function extraction from relations -with don't care insertion. 

circuit 
BDD 
Xp 
St 
SD 
#n 
#l 
#v 
time 
#n 
#l 
#v 
time 
#n 
#l 
#v 
time 
#n 
#l 
#v 
time 
s5378 
769 
11 
1561 
200.2 
1332 
25 
1561 
49.05 
1196 
27 
1561 
60.99 
1919 
42 
1561 
32.74 
s9234.1 
-
-
-
-
7696 
55 
2765 
166.74 
8739 
64 
2764 
325.98 
11613 
99 
2927 
120.37 
s13207 
-
-
-
-
5818 
202 
3554 
897.86 
6882 
228 
3554 
1062.15 
6218 
204 
3554 
287.47 
s15850 
-
-
-
-
40078 
136 
13309 
2596.94 
42097 
164 
13318 
3012.36 
41240 
212 
14276 
467.95 
s35932 
-
-
-
-
7360 
25 
6843 
4811.1 
7300 
10 
6843 
7168.53 
8823 
19 
8756 
2775.32 
s38584 
-
-
-
-
23726 
331 
17676 
5476.67 
21595 
285 
17676 
8160.28 
17708 
281 
18556 
2591.71 
b10 
199 
9 
152 
0.1 
193 
8 
152 
0.99 
217 
9 
152 
1.62 
239 
8 
168 
1.13 
b11 
1221 
20 
394 
0.9 
1562 
52 
394 
5.5 
1638 
46 
394 
15.19 
1896 
54 
394 
8.54 
b12 
1619 
15 
1574 
452.5 
2261 
23 
1574 
26.98 
2081 
24 
1574 
86.96 
2458 
25 
1575 
44.19 
b13 
243 
11 
349 
1.6 
229 
12 
349 
2.45 
236 
10 
349 
4.2 
232 
10 
349 
2.9 
ratio 1 
3.35 
4.53 
0.91 
3.42 
4.52 
0.91 
3.43 
4.97 
0.98 
ratio 2 
1.65 
0.94 
0.97 
2.27 
1.71 
0.97 
2.18 
1.66 
0.97 
2.74 
1.99 
0.97 
ratio 3 
1.00 
1.00 
1.00 
1.38 
1.82 
1.00 
1.33 
1.76 
1.00 
1.66 
2.11 
1.00 

</table></figure>

			<note place="foot" n="1"> In some occasions input stimuli are unimportant and their correspondences with output responses need not be preserved.</note>

			<note place="foot" n="2"> Since a circuit&apos;s primary-output functions are immaterial to our evaluation, we are concerned only about the sub-circuit responsible for transition functions.</note>

			<note place="foot" n="3"> Notice that, unlike BDD-based computation, our methods do not explicitly perform don&apos;t-care based minimization on the extracted transition functions. The don&apos;t-care choices are made implicitly by SAT solving for interpolation.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The authors are grateful to Robert Brayton and Alan Mishchenko for valuable discussions. This work was supported in part by NSC grants 95-2218-E-002-064-MY3 and 96-2221-E-002-278-MY3.</p></div>
			</div>

			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A recursive paradigm to solve Boolean relations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Baneres</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cortadella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kishinevsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automation Conf</title>
		<meeting>Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="416" to="421" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Automatic hardware synthesis from specifications: A case study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Galler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Jobstmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Piterman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Weiglhofer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automation and Test in Europe</title>
		<meeting>Design Automation and Test in Europe</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">ABC: A System for Sequential Synthesis and Verification</title>
		<ptr target="http://www.eecs.berkeley.edu/∼alanmi/abc/" />
		<imprint>
			<date type="published" when="2005" />
		</imprint>
		<respStmt>
			<orgName>Berkeley Logic Synthesis and Verification Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Boolean relations and the incomplete specification of logic networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Very Large Scale Integration</title>
		<meeting>Int&apos;l Conf. on Very Large Scale Integration</meeting>
		<imprint>
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An exact minimizer for Boolean relations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Computer-Aided Design</title>
		<meeting>Int&apos;l Conf. on Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1989" />
			<biblScope unit="page" from="316" to="319" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Linear reasoning: A new form of the Herbrand-Gentzen theorem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Craig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="250" to="268" />
			<date type="published" when="1957" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Heuristic minimization of Boolean relations using testing techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ghosh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Newton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Computer Design</title>
		<meeting>Int&apos;l Conf. on Computer Design</meeting>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Quantifier elimination via functional composition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-H</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Computer Aided Verification</title>
		<meeting>Int&apos;l Conf. on Computer Aided Verification</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="383" to="397" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A new algorithm for the binate covering problem and its application to the minimization of Boolean relations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jeong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Computer-Aided Design</title>
		<meeting>Int&apos;l Conf. on Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="417" to="420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Building circuits from relations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kukula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Shiple</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Computer Aided Verification</title>
		<meeting>Int&apos;l Conf. on Computer Aided Verification</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="113" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Scalable exploration of functional dependency by interpolation and incremental SAT solving</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-H</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mishchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Computer-Aided Design</title>
		<meeting>Int&apos;l Conf. on Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Bi-decomposing large Boolean functions via interpolation and satisfiability solving</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R.-R</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-H</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-L</forename><surname>Hung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automation Conf</title>
		<meeting>Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="636" to="641" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">To SAT or not to SAT: Ashenhurst decomposition in a large scale</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-P</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-H</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R.-R</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Computer-Aided Design</title>
		<meeting>Int&apos;l Conf. on Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="32" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Minimization of symbolic relations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Computer-Aided Design</title>
		<meeting>Int&apos;l Conf. on Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="88" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Simplification of non-deterministic multi-valued networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mishchenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Computer-Aided Design</title>
		<meeting>Int&apos;l Conf. on Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="557" to="562" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Scalable don&apos;t care based logic optimization and resynthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mishchenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-H</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Symp. on Field-Programmable Gate Arrays</title>
		<meeting>Int&apos;l Symp. on Field-Programmable Gate Arrays</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="151" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">FRAIGs: A unifying representation for logic synthesis and verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mishchenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chatterjee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-H</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005-03" />
		</imprint>
		<respStmt>
			<orgName>UC Berkeley</orgName>
		</respStmt>
	</monogr>
<note type="report_type">ERL Technical Report</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Interpolation and SAT-based model checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Computer Aided Verification</title>
		<meeting>Int&apos;l Conf. on Computer Aided Verification</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Heuristic minimization of multi-valued relations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Watanabe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Brayton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In IEEE Trans. on Computer-Aided Design</title>
		<imprint>
			<biblScope unit="page" from="1458" to="1472" />
			<date type="published" when="1993-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Efficient calculation of Boolean relations for multi-level logic optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Wurth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Wehn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. European Design and Test Conference</title>
		<meeting>European Design and Test Conference</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="630" to="634" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Constraint synthesis for environment modeling in functional verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Albin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aziz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Pixley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automation Conf</title>
		<meeting>Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Modeling design constraints and biasing in simulation using BDDs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Shultz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Pixley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aziz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Computer-Aided Design</title>
		<meeting>Int&apos;l Conf. on Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="584" to="589" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
