<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T17:08+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Using First-Order Logic to Reason about Policies</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">Y</forename><surname>Halpern</surname></persName>
							<email>halpern@cs.cornell.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Cornell University Ithaca</orgName>
								<orgName type="institution" key="instit2">Cornell University Ithaca</orgName>
								<address>
									<postCode>14853, 14853</postCode>
									<region>NY, NY</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vicky</forename><surname>Weissman</surname></persName>
							<email>vickyw@cs.cornell.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Cornell University Ithaca</orgName>
								<orgName type="institution" key="instit2">Cornell University Ithaca</orgName>
								<address>
									<postCode>14853, 14853</postCode>
									<region>NY, NY</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Using First-Order Logic to Reason about Policies</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>A policy describes the conditions under which an action is permitted or forbidden. We show that a fragment of (multi-sorted) first-order logic can be used to represent and reason about policies. Because we use first-order logic, policies have a clear syntax and semantics. We show that further restricting the fragment results in a language that is still quite expressive yet is also tractable. More precisely, questions about entailment, such as &apos;May Alice access the file?&apos;, can be answered in time that is a low-order polynomial (indeed, almost linear in some cases), as can questions about the consistency of policy sets. We also give a brief overview of a prototype that we have built whose reasoning engine is based on the logic and whose interface is designed for non-logicians, allowing them to enter both policies and background information, such as &apos;Alice is a student&apos;, and to ask questions about the policies.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A policy describes the conditions under which an action, such as reading a file, is permitted or forbidden. Digital content providers have a rough idea of what their policies should be. Unfortunately, policies are typically described informally. As a result, their meaning and consequences are not always clear.</p><p>To better understand the problem, consider the statement 'only librarians may edit the on-line catalog'. We can view this statement as a policy, because it governs who may edit the catalog, based on whether or not the editor is a librarian. It is not clear if this policy permits librarians to make changes to the catalog or only forbids anyone who is not a librarian from doing so. The policy could be rewritten ¡ Authors supported in part by NSF under grant CTC-0208535, by ONR under grants N00014-00-1-03-41 and N00014-01-10-511, by the DoD Multidisciplinary University Research Initiative (MURI) program administered by the ONR under grant N00014-01-1-0795, and by AFOSR under grant F49620-02-1-0101.</p><p>to remove this particular ambiguity, but others are likely to exist if policies are written in a natural language. Policy languages such as the Extensible rights Markup Language (XrML) <ref type="bibr" target="#b9">[10]</ref> and Open Digital Rights Language (ODRL) <ref type="bibr" target="#b20">[21]</ref> have the potential to be more formal (partly because their syntax is more restricted). Currently, however, the only semantics for these languages seems to be an English description of what the syntax means; thus, they also suffer from significant ambiguity. Our goal in this paper is to provide a logic with a clear syntax and semantics that can be used to represent and reason about policies. In addition, we want the logic to be well-suited to the needs of digital content providers. To achieve our objectives, we use a fragment of first-order logic. This automatically gives us a clear syntax and semantics; thus, it remains to argue that the logic is well-suited to the needs of digital content providers.</p><p>To be of practical use, a logic must satisfy (at least) the following three desiderata.</p><p>1. It must be expressive enough to capture in an easy and natural way the policies that people want to discuss.</p><p>2. It must be tractable enough to allow interesting queries about policies to be answered efficiently.</p><p>3. It must be usable by non-logicians, because we cannot expect policy makers and administrators to be wellversed in logic.</p><p>Of course, whether a logic is sufficiently expressive to meet our first objective depends very much on the application. To evaluate our approach, we gathered a large collection of policies from various libraries, including on-line collections, local and university libraries, the Library of Congress, and Cornell's Digital Library Research Group. We have written these policies in our language. In addition, we have begun to encode government policies in our language, including those that determine a person's eligibility for Social Security. Finally, we have created a translation from most of the XrML Core and all of the XrML Content Extension to our language. Details of the translation and a more complete discussion of the collected policies are given in a companion paper <ref type="bibr" target="#b18">[19]</ref>.</p><p>For the second desideratum, we focus on two key queries: ¢ Given a set of policies and an environment that provides all relevant facts (e.g., 'Alice is a librarian', 'Anyone who is a librarian for less than a year is a novice', etc.), does it follow that a particular action, such as Alice editing the on-line catalog, is permitted or forbidden? ¢ Is a set of policies consistent? In other words, are there no actions that are both permitted and forbidden by the policies in the set? This question is particularly interesting for collaboration. For example, suppose that Alice is writing the policies for her university's new outreach program. If the union of her policies and the university policies is consistent, then she knows that her policies do not contradict those of the university.</p><p>The answers to these questions could be used by enforcement mechanisms and individuals who want to do regulated activities. More importantly, we believe that the answers provide a reasonably good understanding of the policies, increasing our confidence that the formal statements capture the informal rules and the informal rules capture the policy creator's intent.</p><p>To address our third goal, the usability requirement, we developed, and are currently refining and extending, a prototype that allows users to enter policies, as well as facts about their environment, and to ask questions about them. This software will be tested by University of Virginia librarians as part of the Mellon-Fedora project <ref type="bibr" target="#b31">[32]</ref> to verify that the language can be used by people who have not been trained in logic.</p><p>There have been a number of attempts to give formal semantics to policies, some of which involve first-order logic. Most of the first-order approaches are based on some variant of Datalog <ref type="bibr" target="#b15">[16]</ref>. By beginning with Datalog, these solutions start with a language that is tractable, but not sufficiently expressive. They then extend the language to better meet the needs of applications. In particular, they find extensions that permit a limited use of negation and functions. The restrictions that we make are quite different from those made previously. We believe (and will argue throughout this paper) that the resulting language is especially well-suited for many applications, and has a number of advantages over variants of Datalog.</p><p>The rest of this paper is organized as follows. In the next section, we formally define our notions of a policy and an environment. We also give examples that illustrate how policies can be represented in an appropriate fragment of first-order logic. In Section 3 we show that, in general, the questions we want to ask about policies are hard to answer.</p><p>In Section 4 we present some restrictions under which these questions are tractable. We give a brief overview of the prototype that we are building in Section 5. We discuss the Datalog approaches, as well as other related work, in Section 6. The paper concludes in Section 7 with plans for future research. Detailed proofs are left to the full paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">A First-Order Logic for Reasoning About Policies</head><p>For the rest of the paper, we assume knowledge of manysorted first-order logic at the level of Enderton <ref type="bibr" target="#b13">[14]</ref>. More specifically, we assume the reader is familiar with the syntax of first-order logic, including constants, variables, predicate symbols, function symbols, and quantification, with the semantics of first-order logic, including relational models and valuations, and with the notions of satisfiability and validity of first-order formulas.</p><p>We use many-sorted first-order logic with equality over some vocabulary . In practice, it may be useful to add additional arguments to Permitted, such as when the action is permitted and who is authorizing the granting or revoking of the permission. We have not included these here to simplify the exposition; including them would not change our results. The constant now denotes the current time. In practice, a global clock would determine the interpretation of now.</p><p>A policy is a closed first-order formula of the form Permitted indicates that the Permitted predicate may or may not be negated. Defining the policy in this way provides a structure that matches our intuition, namely, that a policy is a set of conditions under which an action is or is not permitted.</p><formula xml:id="formula_0">P ) Q S R U T F T 8 T G P ) Q W V © Y X a ` b © Y c Permitted© 1 D F E G DH I E</formula><p>To illustrate how policies can be expressed in first-order logic, consider the following examples. To determine the consequences of a policy, we need to know what facts are true in the context in which the policies are applied. For example, to decide if the policies in Example 2.1 permit Alice to edit the catalog, we must know if Alice is a librarian. In other words, we must know if the statement Librarian(Alice) is true. This fact, along with all the others that are needed to analyze a set of policies, are contained in the environment. The environment may include very simple statements such as 'The Cat in the Hat is a children's book' or 'Sally has a junior library card'. More complex statements may also be included, such as the conditions under which a customer is considered to be in good standing and 'at all times, there is a senior staff member who is on call'. All the examples we have considered so far confirm our belief that first-order logic is sufficiently expressive to capture most environments that are likely to arise in practice. Thus, we formally define an environment to be a closed first-order formula that does not contain the Permitted predicate. The requirement that the environment not contain Permitted encourages the intuitive separation between the environment, which is a description of reality, and the policies, which are the rules governing that reality.</p><p>The two types of queries discussed in the introduction can now be formalized. is quantifier-free <ref type="bibr" target="#b6">[7]</ref>. This means that we cannot determine if a single policy implies a permission when the conditions under which the policy applies must be written in first-order logic as a formula of the form</p><formula xml:id="formula_1"> Q    P 5  X ) H where X ) H</formula><p>has a binary predicate other than Permitted.</p><p>We can get the same result even without assuming that £ has a binary predicate other than Permitted. This is summarized in the following theorem. It follows from Theorem 3.1 that we cannot determine if a set of policies imply a permission in an environment when the environment is empty, the policy set has only one policy, and that policy has a single alternation of quantifiers and no function symbols. Not surprisingly, similar undecidability results hold if we allow formulas in the environment to involve nontrivial quantification (provided that there is a binary predicate in the language other than Permitted, since we do not allow Permitted in the environment). Given Theorem 3.1, it seems that our only hope is to forbid any alternation of quantifiers.</p><p>How much quantification do we really need? A quantifier-free environment suffices to capture simple databases. However, we want to allow at least universal formulas in the environment so that we can state general properties, such as 'all freshman are students'. Universal quantification is even more critical in policies. If we do not allow a policy to have any quantification (i.e., define a policy to have the form is quantifier-free), then each policy must govern a specific individual and action. For example, we can say 'If Alice is good, she may play outside', but we cannot say 'All good children may play outside'. Because policies typically permit an individual to do an action based on the attributes of that individual and action, we must allow policies to be universally quantified.</p><p>Policies with universal quantification (and a quantifierfree antecedent) are sufficiently expressive to capture the policies that we have collected from libraries and government databases. Although some of the collected policies appear to need existential quantification, they can be converted to formulas with universal quantification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 3.2:</head><p>Consider the policy 'anyone who is accompanied by a librarian may enter the stacks'. A natural way to state this in first-order logic is e nter(stacks) I E which uses only universal quantification.</p><p>Note that enter is a function in Example 3.2. Unfortunately, it is well known that the validity problem for existential formulas with functions is undecidable <ref type="bibr" target="#b6">[7]</ref>. The following result is almost immediate: by co-NEXPTIME (co-nondeterministic exponential time) in parts (a) and (b) <ref type="bibr" target="#b6">[7]</ref>. Theorems 3.1, 3.3, and 3.4 seem to suggest that the questions we are interested in are hopelessly intractable. Fortunately, things are not nearly as bad as they seem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Identifying Tractable Sublanguages</head><p>The work on Datalog and its variants mentioned in the introduction demonstrates that there are useful, tractable fragments of first-order logic. In this section we identify a different set of restrictions than those considered by the Datalog community, show that they lead to tractability, and argue that they are particularly well-suited to reasoning about policies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Analyzing a restricted set of policies</head><p>Define a standard policy to be a policy of the form</p><formula xml:id="formula_2">P ) Q R T F T 8 T G P ) Q  © I © w m R n p T F T 8 Tp m o ` p © Y cD </formula><p>are terms of the appropriate sort. A basic environment is an environment that is a conjunction of ground literals. Basic environments are sufficiently expressive to capture the information in databases and certificates. While this is adequate for many applications, basic environments cannot represent general properties, such as 'all freshmen are students'. To handle these, we define a standard environment to be an environment that is a conjunction of quantifier-free formulas and universal formulas of the form</p><formula xml:id="formula_3">P ) Q  R W T F T F T I P ) Q  © w m R p T F T 8 T p m o ` m o 3 q R</formula><p>, where</p><formula xml:id="formula_4">m R E T F T F T E G m o 3 q R</formula><p>are literals. As argued in Section 3, standard policies seem sufficiently expressive to capture most (if not all) policies of interest. Basic environments suffice for many applications of interest; standard environments suffice for all the applications we have considered.</p><p>As a first step towards tractability, we consider only basic environments and make what may seem to be rather arbitrary restrictions on policies. (Later in this section we justify the restrictions and discuss standard environments.) One of the restrictions relies on a notion called bipolarity, which in turn relies on a well-known technique from theorem proving called unification <ref type="bibr" target="#b29">[30]</ref>.</p><p>Two We can determine the validity of formulas in</p><formula xml:id="formula_5">¤ k x in time z © I © Y { |  w { d } ~ { | v  {   |  "  { |  w {</formula><p>, where</p><formula xml:id="formula_6">{ |   {</formula><p>denotes the length of  , when viewed as a string of symbols. <ref type="bibr" target="#b0">1</ref> We say that a first-order formula is in CNF if it has the form</p><formula xml:id="formula_7">    ' )  Y  I     Y  d      d   I  Y  I  5  W   , where each  U </formula><p>is a (quantifier-free) disjunction of literals and</p><formula xml:id="formula_8"> k  k  u  9  $  G    for  5  s   I  Y  f  Y  1  and    s   I  Y  f  Y  1 . Each  U </formula><p>is called a clause. We sometimes identify a universal formula in CNF with its set of clauses.</p><p>Note that the language ¤ ¦ x includes formulas such as</p><formula xml:id="formula_9">Student© Alice U p Good© Alice I p P d Q © S tudent© Q ` Permitted© Q E w ork f Y p P d Q © S tudent© Q U p Good© Q ` Permitted© Q E p lay f T</formula><p>('Alice is a student, Alice is good, all students may work and all good students may play'). Unlike Theorem 3.4(c), function symbols are allowed in Theorem 4.1. Moreover, there is no assumption that the arity of predicates and functions in £ is bounded. The price we pay for this added generality and for cutting the complexity to linear in the number of policies (which could well be large) and not much more than linear in the size of the database (which we expect to be relatively small, particularly in certificate-passing systems) is the four restrictions. Before describing the proof of Theorem 4.1, we argue that the restrictions are often met in practice and show how the restrictions can be relaxed so that the result is even more applicable.</p><p>As we have already said, basic environments are sufficiently expressive to capture the facts stored in databases and certificates. This is not always enough. For example, the documents that describe who may collect Social Security define an aged person to be anyone 65 years old or older, who is a resident of the U.S., and is either a citizen or an alien residing in the U.S. both legally and permanently. A basic environment cannot capture what it means to be aged, according to Social Security policies. Nevertheless, basic environments seem perfectly adequate for certificate-based permissions in the spirit of SPKI/SDSI <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13]</ref> and for licenses as described by XrML <ref type="bibr" target="#b9">[10]</ref>, which assumes a minimal environment containing facts such as the current time and the time of the most recent revocation polling.</p><p>The second restriction, that equality is not used, is a serious restriction. Without equality, we cannot express threshold policies ('if at least three different people vouch for Alice, then she can enter the club') nor can we express the identity of two individuals ('Miss Alice Smith = Mrs. Alice Jones'). Nevertheless, there are large classes of policies that do not require equality at all. (This includes the policies in the Social Security database and the library policies that we have considered.)</p><p>The third restriction, that every variable appearing in a policy  also appears as an argument to Permitted in  , is met if an individual is granted or denied permission based solely on her attributes and the attributes of the regulated action. Notice that the policies in Examples 2.1 and 2.3 have this form, but the policies in Examples 2. <ref type="bibr" target="#b1">2</ref>  ), and policies do not have Permitted in their antecedents. To see why, recall that a permitting policy says 'if the following conditions hold, then a particular action is permitted'. These conditions typically include requirements that someone possess one or more credentials, such as a library card or a driver's license. It is fairly rare that not having a credential, such as not having a driver's license, increases an individual's rights. Therefore, we do not expect credentials to correspond to bipolars. Similar arguments may be made for other types of information.</p><p>If the policy set includes a mix of permitting and denying policies, even if Permitted does not appear in the antecedent of policies, then it seems less likely that the bipolar restriction will hold. For example, consider the policy set </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Relaxing the restrictions</head><p>In this subsection, we discuss the consequences of relaxing some of the conditions in Theorem 4.1. In particular, we consider the effect of allowing standard environments, as opposed to basic ones, allowing a limited use of equality, allowing variables to appear in policies (and the standard environment) without also appearing as arguments to Permitted, and allowing each policy (and each environment fact) to have one bipolar. The bipolar restriction is further relaxed in Section 4.3.</p><p>We first consider the equality restriction. It turns out that we can allow equality in the quantifier-free portion of the environment. As a result, we can write statements such as 'Miss Alice Smith = Mrs. Alice Jones' and 'hearing £ s listening'. However, if we allow equality to be used in this way, then we need to generalize the definitions of unification and bipolarity. <ref type="bibr">We</ref>  We also can support equality in the antecedents of policies, but we cannot support inequalities. For example, we can handle the policy</p><formula xml:id="formula_10">P ) Q RP ) Q y  © f © Q R s Spouse© Q   I ` Permitted© Q R E S peakFor© Q   I f E</formula><p>but we cannot handle the policy</p><formula xml:id="formula_11">P ) Q RP ) Q y  © f © Q R £ s Spouse© Q   I ` b c Permitted© Q R E S peakFor© Q   I f T (</formula><p>The first policy says 'an individual may speak for her spouse'. The second says 'an individual may not speak for someone who is not her spouse'.) We now consider the variable restriction; first we relax it and then we remove it entirely. Suppose that every literal in every policy has at most one variable that doesn't appear in Permitted (which is the case in Examples 2.2 and 3.2) and there are § constants that appear in the environment. Then the increase in complexity is only</p><formula xml:id="formula_12">z © w § ¨ { © v  {  |  "  { |  w {</formula><p>, and the time needed to answer our queries is</p><formula xml:id="formula_13">z © f © Y { |  w {  } v § ¨ { © v  {   w    { |  w {</formula><p>. Therefore, our language will not become intractable if we allow any number of variables to violate our original restriction, provided that each literal has only one such variable.</p><p>The NP-hardness result of Theorem 3.4(b) suggests that it will not be possible to get such low complexity in general. We can show that if there are at most ª variables in any policy that do not appear as arguments to Permitted, then the queries in which we are interested can be answered in time</p><formula xml:id="formula_14">z © I © Y { |  w { ) } ¤ § o { © v  {   w    { |  w {</formula><p>. This result is not simply a generalization of the previous one. Our earlier result might apply to a policy set for which ª is greater than one. Consider the policy </p><formula xml:id="formula_15">P ) Q RP ) Q y  F P ) Q j P d Q l © G « R © Q R E Q l  p «  © Q y  E Q l  p « ¦ j n © Q j " E Q l ` Permitted© Q l E F h I .</formula><formula xml:id="formula_16">z © I © I { ©  w { ¯ } ° § o { © v  {   w    { |  w { .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Moreover, if each literal in each policy has at most one variable that does not appear in Permitted, then we can determine the validity of the formula in time</head><formula xml:id="formula_17">z © I © Y { |  w { ± } § v { | v  { ²  |  "  { ©  C { .</formula><p>Note that Theorem 4.2 allows equality in the environment  . Also, note that all of the examples in this paper, including Examples 2.2 and 3.2, meet the condition that every literal in every policy has at most one variable that does not appear in Permitted. Thus, we can answer our queries about these policies in time We can determine the validity of  is a variable that does not appear as an argument to Permitted.</p><formula xml:id="formula_18">z © f © Y { |  w { n } A § ¨ { © v  {   w    { |  w</formula><formula xml:id="formula_19">X in time z © Y { |  R p v  {  w    { |  R p v  { W } ´ ¦ F { | µ S ¶  {  } ¸ · ,</formula><formula xml:id="formula_20">© Y { |  S  { n } § B © Y { |  R p v  { } ¸ ¦ 8 { © µ S ¶ G { I   w    { ©  S  n { . Otherwise, · is © Y { |  S  n { ¯ } k § o © I { ©  R p v  { ¯ } ¦ 8 { © µ S ¶ 9 { f   w    { |  S  n { ,</formula><p>For the rest of this subsection, we discuss why Theorems 4.1, 4.2, and 4.3 are true, and the role of the restrictions on bipolarity and equality.</p><p>These theorems are best understood in the context of the resolution procedure from theorem proving <ref type="bibr" target="#b29">[30]</ref> can add bipolars to the formula and we need to restrict bipolars for tractability, our theorems must refer to the number of bipolars after the substitutions have been made. This is why the theorems refer to the number of bipolars relative to a set of equality statements (if the environment has equality).</p><p>We remark that, in general, dealing with equality in the context of resolution is nontrivial; it requires techniques such as paramodulation <ref type="bibr" target="#b7">[8]</ref>. Our restrictions guarantee that these additional procedures are unnecessary.</p><p>The problem with applying resolution is that, in general, the number of clauses in   Thus, if the hypotheses of Proposition 4.5(c)(i) hold, then, after making the all the required substitutions, each literal has at most one variable that has not yet been assigned a value. It is not hard to show that, in this case variable can be considered independently of the others. Therefore, we can try all possible assignments in time </p><formula xml:id="formula_21">«  © G X H s Ë ¡ Ì µ R E T F T F T E F µ  ¢ , then «  © G X p X H s Í «  © G X W Î © Â 9 Ï  «  © G µ Â p X f .<label>(c)</label></formula><formula xml:id="formula_22">z © f © Y { | X W { 9 }  § ¨ { © µ  {   w    { © X W { .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Beyond the bipolar restriction</head><p>As we have already observed, the bipolar restriction in Theorems 4.1, 4.2, and 4.3 might not hold in practice. In this section, we discuss two situations in which the restriction is unlikely to hold, and what can be done about it. The first is when policies use predicates that are, intuitively, defined in the environment. The second is when the policy set includes both permitting and denying policies (that is, the set has policies with Permitted in the conclusion and policies with c Permitted in the conclusion). To understand the role of definitions, consider the policy 'any minor who is intoxicated may go to jail'. Now, suppose that an individual is a minor in New York if she is under twenty-one and she is a minor in Alaska, if she is under eighteen. Also, an individual is intoxicated if she fails a breathalyzer test, can't touch her nose, or can't walk straight. Formally, is the first-order part of the environment. Is this so bad? Examples in the social security database suggest that § is typically less than 3. In most cases, a bipolar is defined by only one clause. Thus, replacement does not typically increase the number of policies, although the individual policies are longer. These examples suggest that, in practice, definitions will not significantly reduce the efficiency of these procedures.</p><p>We next provide a condition that allows us to support policy sets that have both permitting and denying policies. This task would be easy if we could consider only the permitting policies (ignoring the denying policies) when determining if an action is permitted. Unfortunately, if we do this, then we might not answer queries correctly.</p><p>To see why, consider an environment together imply that no student is a faculty member. (Intuitively, students cannot be faculty members, because no one can be both permitted and not permitted to chair committees.) Because students are not faculty members, Alice, being a student, is not a faculty member and, by  j , may take a nap. We cannot determine that Alice may nap if we consider only the permitting policies, because to derive the permission we need the environment fact that is implied by</p><formula xml:id="formula_23"> R  p  </formula><p>. If each fact implied by a permitting and denying policy together were derivable from either the environment or a single policy, then we could separate the permitting policies from the denying policies. Intuitively, this is because the interaction would not provide any information that wasn't already known. To formalize this intuition, note that each implied fact corresponds to a resolvent of a permitting and denying policy. In the previous example, the implied fact that students are not faculty members corresponds to the resolvent of . Therefore, if every resolvent of a permitting and denying policy is already implied by the environment or a single policy, then we can separate the policies. Continuing our example, we could separate the policies if the environment said that students were not faculty members. A closer analysis shows that, because we are determining permissions and prohibitions, we need to consider only those resolvents that are created by resolving on a literal that involves Permitted.</p><p>We formalize all of this in the following theorem. But to do so, we need to discuss permitting and denying policies in a bit more detail. Note that a policy such as</p><formula xml:id="formula_24">P ) Q © P ermitted© AliceE F h ` Permitted© BobE F h I</formula><p>is logically equivalent to both a permitting policy and a denying policy. (The denying policy is</p><formula xml:id="formula_25">P d Q © Y c Permitted© BobE 8 h ` c Permitted© AliceE F h f T )</formula><p>We say that a policy is pure if it is not logically equivalent to both a permitting and a denying policy. Note that policies that do not mention Permitted in the antecedent (which is the case for almost all the policies we have collected) are guaranteed to be pure.  Of course, a similar result holds for prohibitions.</p><formula xml:id="formula_26"> p  R p T 8 T F T p   p Ü R p T 8 T F T p Ü V ` Permitted© w D F E G DH is valid iff  p  R p T F T F T p   ` Permitted© 1 D F E G</formula><p>Given an environment and a set of policies, we can always add clauses to obtain an equivalent environment and policy set that meets the theorem's conditions. Therefore, the question isn't 'how likely are these conditions to be met in practice', but 'how many clauses are we going to have to add so that these conditions are met'. Example 4.4 shows that we may need to add an infinite number of policies to the set. However, for policy sets where Permitted appears only in the conclusions of policies, it is easy to see that every resolvent is an environment fact and there is, at most, one resolvent per pair of permitting and denying policies.</p><p>So, if the policy set consists of Á policies, then we can satisfy the antecedent of Theorem 4.6 by adding at most Á  clauses to the environment. Instead of adding these clauses to the environment automatically, it may be better to verify the changes with the policy maker. To see why, recall the two policies 'faculty members may chair committees' and 'students may not chair committees'. We could satisfy the antecedent of Theorem 4.6 by adding the fact 'no student is a faculty member' to the environment. But suppose that there is (or could one day be) a student who is also a faculty member. Then the policy maker may want to revise the policies to take this into account, rather than allowing the environment to (possibly) become inconsistent. In general, we expect that the additional facts needed to satisfy the antecedent of Theorem 4.6 will be ones that either the user would agree should have been there all along or are ones that should not be there and in fact suggest that the policies should be rewritten. By querying policy makers, we help them to write better policies.</p><p>Another advantage of querying the policy maker is that the implied facts may remind her of a general fact that should be added to the environment. For example, the policies 'men under 65 may apply for health plan A', 'men who do not smoke may apply for health plan A', and 'women may not apply for health plan A' imply the facts 'men under 65 are not women' and 'men who do not smoke are not women'. Rather than adding both facts to the environment, the policy maker may prefer to add the fact 'men are not women' and in this way simplify the environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Consistency</head><p>In this section, we consider the problem of checking consistency. <ref type="table">(Recall that an</ref>  </p><formula xml:id="formula_27">× á s Ó ¡  R E T F T 8 T E  )  E F Ü R E T F T 8 T E F Ü V ¢</formula><p>is a set of policies such that the antecedent of Theorem 4.6 holds. Then</p><formula xml:id="formula_28"> p  R ± p T F T 8 T p  )  p Ü R  p T F T 8 T p Ü V is satisfiable iff  is satisfiable.</formula><p>Thus, in addition to making it feasible to check the consequences of policies, our conditions essentially prevent users from writing inconsistent policies. This is a major benefit of adhering to these restrictions!</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Prototype</head><p>We have presented an expressive, tractable logic for reasoning about policies. But how can policy writers and administrators (users), who are not logicians, benefit from such a logic? We believe that an appropriate interface would allow users to state their policies and the relevant facts, as well as to make queries, without writing formulas. Their input could be translated into our fragment of first-order logic and then answers to their queries could be translated back into natural language to produce reasonable answers to the original (pre-translated) questions. We are in the process of building a prototype that allows users to enter information by filling in blanks in English sentences. Although many of the details are still being refined, we have completed a basic interface and a translation from the interface to firstorder logic. Due to space constraints, we do not give a complete description of the interface, nor do we provide a formal translation from the fields entered by users to first-order formulas. We are preparing a paper that will discuss this in detail. Here we just present the highlights of our approach.</p><p>A user creates policies and states environment facts by filling in blanks in English sentences. For example, the user could record the fact that Alice Smith paid her dues to Bob Jones at 10 AM on <ref type="bibr">May 1, 2002</ref>, by selecting the appropriate environment form and filling in the white boxes as shown in <ref type="figure" target="#fig_4">Figure 1</ref>.</p><p>When designing the prototype, we need to decide which English sentences should be supported, where the blanks should go, and what symbols may go in each blank. The first two questions can be answered by analyzing the structure of the policies that we collected and the environment facts on which they rely. Addressing the last question is more interesting. Based on the structure of the sentences, it is easy to decide which blanks should take terms and which should take predicate symbols, but it is less clear what those symbols should be. This choice depends on the application, and for any particular application the appropriate choice may change over time. For example, a library may want a constant symbol for each patron. The set of library patrons, however, is not fixed. To handle this, we allow users to create symbols on the fly, while filling in the sentences. We can, for the most part, infer what type of symbol it is (Subject, predicate, etc.) from its use. The only exception is that the user must help us distinguish constants from variables.</p><p>A drawback to having a nonfixed language is that a user may have difficulty remembering precisely which terms have been defined. For example, a policy maker may wonder if a predecessor used the term 'graduate student', 'grads', 'gradStudent', or something else to refer to the graduate population. To minimize this confusion, we provide a directory system for the various sorts (e.g., the subject 'grad' may be in the directory 'subjects/university/students'). When a new symbol is defined, the policy maker puts the symbol in the appropriate directory where appropriateness, like the directories themselves, are determined by the users. When searching for the forgotten symbol, the user can consult these directories, which are accessible from the main menu and by clicking on the buttons beside the blanks in the English sentences.</p><p>The interface to the system has been designed to support standard environments and policies. In other words, the user cannot fill in the English sentences in such a way that our translation creates either a nonstandard environment or a nonstandard policy. The user, however, can enter a permitting policy and a denying policy that together imply a fact that is not in the environment or a policy that is not implied by one already in the set. Therefore, the antecedent of Theorem 4.6 may not hold. If we are not certain that it holds, then we ask the user if a conflict could occur and, if so, how it should be handled. We then either extend the environment to include the missing fact or we modify the policies to reflect the policy maker's actual intent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>Our work has been heavily influenced by the work of Halpern, van der Meyden, and Schneider <ref type="bibr" target="#b17">[18]</ref>. Their paper discusses key issues that must be addressed when designing a policy language, evaluates various solutions that have been proposed in the literature, and recommends directions for future research. Our design incorporates three of their suggestions. First, Halpern et al. seem to favor first-order logic for handling policies. Second, they advocate defining sorts for principals, actions, and time, which is common in the literature. Third, they suggest having a Permitted predicate that takes an individual and an action argument (and perhaps others). (This usage of Permitted is much in the spirit of how it is used in modal deontic logic <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b28">29]</ref>.) In essence, we have tailored a logic that was based on their recommendations to serve the expressive and tractability needs of applications.</p><p>Many people in the trust management and access control communities have defined tractable policy languages using a fragment of first-order logic. The standard approach (see, for example, Delegation Logic <ref type="bibr" target="#b24">[25]</ref>, the RT (Role-based Trust-management) framework <ref type="bibr" target="#b26">[27]</ref>, Binder <ref type="bibr" target="#b10">[11]</ref>, SD3 <ref type="bibr" target="#b23">[24]</ref>, and FAF (Flexible Authorization Framework) <ref type="bibr" target="#b22">[23]</ref>) is to describe policies in such a way that they can be analyzed using a variant of Datalog, typically either safe stratified Datalog <ref type="bibr" target="#b15">[16]</ref> or Datalog with constraints <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b32">33]</ref>. Datalog is an efficient well-understood reasoning engine that was originally designed for function-free negation-free Horn clauses. The variants allow some use of functions and negation, while preserving tractability.</p><p>There are relatively few policy languages that support functions, but those that do (e.g. <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b25">26]</ref>) seem to favor a variant of Datalog called Datalog with constraints. By using this variant, many structured resources, such as directories and even time, can be expressed using functions. However, function symbols may not appear in intentional predicates (predicates whose relations are computed by applying Datalog rules, as opposed to being stored in a database). Also, for tractability, additional restrictions are often made. For example, Li and Mitchell <ref type="bibr" target="#b25">[26]</ref> do not allow formulas in constraints to have more than one variable.</p><p>There are a number of policy languages that support negation. This is typically done using safe, stratified Datalog (e.g. <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b10">[11]</ref>, and <ref type="bibr" target="#b23">[24]</ref>). Safe, stratified Datalog allows some use of negation in the body of rules. The relaxation is not sufficient for all permitting policies of interest. For example, the policy</p><formula xml:id="formula_29">P ) Q © Y c BadCredit© Q ` Permitted© Q E</formula><p>a pply for loan f (anyone without bad credit may apply for a loan) is not supported. More importantly, denying policies cannot be written in safe, stratified Datalog, because the language does not allow negation in the conclusion of rules. This limitation may not seem to be particularly troublesome. After all, the standard approach, used in relational databases <ref type="bibr" target="#b16">[17]</ref>, as well as by UNIX <ref type="bibr" target="#b34">[35]</ref>, SPKI/SDSI <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b11">12]</ref>, KeyNote <ref type="bibr" target="#b3">[4]</ref>, and almost all of the Datalogbased approaches, is to assume that everything that is not explicitly permitted is prohibited. However, it is difficult to believe that most policy makers really want to forbid every action that they do not explicitly permit. Thus, the assumption may be acceptable in various instances, but it does not capture the policy maker's actual intent. This becomes a problem when different policy makers want to combine their policies. For example, consider a group of libraries that want to merge their policies so that patrons are effected by the same regulations, regardless of which library they visit. When merging the policy sets, we clearly want to detect conflicts (e.g. one library lets minors check-out adult books and another does not). Unfortunately, if a language can state only what is permitted, then this will be impossible. If we put the permitting policies from each library into one large set, then that set will be consistent (it is satisfied in the model that permits everything), regardless of which policies are in the set. Alternatively, we could require that no library permits an action that another forbids (which is what we want to do) under the assumption that every unregulated action is forbidden. It is not hard to see that this approach will always detect a conflict between sets of library policies, unless the policies are essentially identical. For example, if one library allows patrons to access the coat room and another library's policies don't mention a coat room (perhaps because that library doesn't have one) then the policy sets would be flagged as inconsistent, since one allows access and the other forbids it by not explicitly permitting. The bottom line is that it seems unlikely that a policy language will be able to support mergers, unless the language supports both permitting and denying policies. We believe that the issue of merging policies has by and large been ignored, but is an increasingly significant one.</p><p>Although we do not know of a Datalog variant that allows negation in the conclusions of rules, there is an extension that allows unrestricted use of negation in the body of rules. Jajodia et al. <ref type="bibr" target="#b22">[23]</ref> show that in certain settings this extension, called Datalog with negation, can capture negated conclusions. But this approach to adding negation to Datalog, although it does support both permitting and denying policies, has its own problems. Datalog with negation is tractable because it makes the closed world assumption. According to this assumption, if we cannot prove that a positive literal is true, we assume it is false. Unfortunately, the closed world assumption can lead to unintuitive (and probably unintended) results. For example, consider the single policy 'If Alice is not a student, then she may play' and suppose that the reasoning engine can recognize a student only when she presents her ID. If Alice is a student who does not present her ID and the reasoning engine makes the closed world assumption, then the reasoning engine will incorrectly assume that Alice is not a student and, thus, permit her to play.</p><p>If a policy language can capture both permitting and denying policies, then conflicts can be detected and resolved in some prescribed way. For example, FAF <ref type="bibr" target="#b22">[23]</ref> expects the user to create an overriding policy such as 'if an action is both permitted and forbidden, then it is forbidden'. However, as we have already seen, there are problems with the FAF approach to dealing with conflicts. Similar approaches are taken in <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b21">22]</ref>. In our language, as long as all pairs of permitting and denying policies satisfy the antecedent of Theorem 4.6, policies cannot be inconsistent, so we do not need overriding policies.</p><p>One way in which it may seem that our language is restricted is that we we do not provide explicit support for groups and roles. Many policy languages talk about groups, where a group is a set of subjects such that if a group has a property, then every member of the group has the property (cf. <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b22">23]</ref>). In role-based access control models <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b19">20]</ref>, roles are an intermediary between individuals and rights. More specifically, an individual obtains a right by assuming a role that is associated with that right. For example, Alice may need to assume the role of Department Chair in order to obtain the budget.</p><p>We do not need to support groups and roles explicitly because we can easily capture both in first-order logic using appropriate predicates. For example, if we want to say that Alice is a member of the faculty and any faculty member may chair committees, then we can represent the group using the predicate Faculty. The environment fact is encoded as Faculty(Alice); the policy is then would be added to the environment when Alice assumes the role and would be removed when she relinquishes it. Alternatively, we could add a sort Roles to our logic along with the predicate As (as suggested in <ref type="bibr" target="#b0">[1]</ref>  . Continuing our example, 'Alice, acting as the Department Chair, may sign the budget' could be written in the logic as As(Alice, Dept. Chair) ` Permitted© Alice, sign the budget . The second encoding for roles may be more in keeping with the spirit of the rolebased model, but we believe that both approaches are reasonable (and our results apply to both choices).</p><p>Finally, we should note that the KeyNote system <ref type="bibr" target="#b2">[3]</ref> (formerly called PolicyMaker <ref type="bibr" target="#b3">[4]</ref>) is more flexible than our approach in that the application can write its policies in a number of different languages. More specifically, the application gives to Keynote programs (which can be written in a variety of programming languages) that determine if a policy applies to a request and a requestor. Because KeyNote essentially views these programs as black boxes, it is quite limited in its ability to reason about policies. As discussed in <ref type="bibr" target="#b4">[5]</ref>, the system needs to put restrictions on the programs to ensure correct analysis. This is in fact done in <ref type="bibr" target="#b5">[6]</ref>, but at the price of a substantial reduction in the expressive power of the language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>We have considered a fragment of first logic that, based on the policies we collected, is likely to be sufficiently expressive for many applications. We proved that, for typical policies, we could efficiently determine if actions are permitted or prohibited by the policies. Finally, we briefly discussed a prototype that allows non-logicians to benefit from our logic (see <ref type="bibr" target="#b18">[19]</ref> for details). As we said earlier, all approaches using first-order logic restrict it in some way to get tractability. The examples that we have been collecting suggest that our language is expressive enough to capture the policies that people want to write. Moreover, we believe that our approach has significant advantages over approaches that cannot express prohibitions, such as approaches based on Datalog, when it comes to merging policy sets.</p><p>In terms of future research, we are in the process of using our logic to give semantics to the popular, though ambiguous, XrML rights language <ref type="bibr" target="#b9">[10]</ref>. As we said, we are also investigating online databases of policies to check if our language is expressive enough to capture everything that policy writers want to say. This investigation has already led to improvements in our language. For example, it showed us that we need to support definitions. We expect that it will prove useful to find extensions of our logic that remain tractable. One avenue to explore is to consider a hybrid of our approach and Datalog. We plan to pursue this in future work.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>(</head><label></label><figDesc>Depending on the intended meaning of the English state- ment, the first formula by itself may characterize the pol- icy.) Example 2.2: The policy 'a customer may download any article if she has paid a fee within the past six weeks' can be rewritten as 'if an individual g has paid the fee within the past six weeks, g is a customer, and h is some article, then g may download h '. The policy can be encoded readily in the logic as d ance I T</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>by simply trying all possible substi- tutions. (This observation leads to the result in Proposi- tion 4.5(c)(ii).) Note that if a literal m in µ unifies with only one literal in X , relative to the equalities in X , then the sub- stitution r is essentially determined for the free variables in m .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. A typical action record.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Similarly, the policy 'Alice, acting as the Department Chair, may sign the budget' can be written as Dept. Chair© Alicè Alicè Permitted© Alice, sign the budget T The fact Dept. Chair© Alice</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>The first query, is an individual D permitted to perform an action DH (where D and DH are closed terms) given an environment</head><label></label><figDesc></figDesc><table>Since 

X 

does not mention Permitted, the last formula is 
valid iff 

X 

is valid. The validity problem for first-order for-
mulas is well-known to be undecidable, even if we restrict 
to formulas that contain a single binary predicate; indeed, 
undecidability holds even if we further restrict to formulas 
of the form 

 
Q 
 
 
P 
  
X 
H 

, where 

X 
H 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>D and DH are terms of the appropriate sort, and XTheorem 3.3 suggests that even if we drastically reduce quantification, we still need to disallow functions to get de- cidability. Once we restrict quantification to a bare mini- mum and remove functions entirely, then we do get a de- cidable fragment, but it's not tractable. Recall thatconstants  and H of sorts£ (that is, there exists some h such that all predicate symbols in £ have arity at most h ). Finally, let ¤ </head><label></label><figDesc></figDesc><table>Theorem 3.3: Let 

¤ 
R 

be the set of closed formulas of the 
form 

P 
) Q 
R 
T 
8 T 
F T 
 Q 
V 
© 
Y X 
d ` 

Permitted© 

w D 
F E 
Y DH 

f 
` 

Permitted© 

1 D 
F E 
G DH 


, 
where 

is a 
quantifier-free formula (possibly containing function sym-
bols). The validity problem for 

¤ 
R 

is undecidable. 

e 
g f  

is 
the second level of the polynomial hierarchy, and represents 
languages that can be decided in co-NP with an NP oracle. 

Theorem 3.4: Let 

£ 

be a vocabulary that contains 
Permitted, % 
$ &amp; 
) ( 
0 
2 
3 
8 
9 # 

and 


g 

9 

 ! 
$ # 

, respectively, and possibly other predicate and 
constant symbols. Assume there is a bound on the arity 
of the predicate symbols in 

be the set of all closed formulas in 

¤ 
¦ ¥ 
¨  § 
© 
£ 


of the form 

 
p 
 
R 
p 
T 
F T 
F T 
p 
 
 
` 

Permitted© 

Y  
x E 
F H 


such that 

 

is a conjunction of quantifier-free and uni-
versal formulas and each policy 

 
R 
E 
T 
F T 
8 T 
E 
 
 

has the form 

P 
) Q 
 R 
W T 
F T 
8 T 
G P 
) Q 
U V 
© 
Y X 
i ` D 
 

are 
terms of the appropriate sort and 

X 

is quantifier-free. 

(a) The validity problem for 

¤ 
 

is in 

e 
f  

. 

(b) If 

¤ 
k j 

is the set of formulas in 

¤ 
 

in which every policy's 
antecedent is a conjunction of literals, then the validity 
problem for 

¤ 
k j 

is 

e 
f  

hard. 

(c) If 

¤ 
¦ l 

is the set of 

¤ 
 

formulas in which 

 

is quantifier-
free, then the validity problem for 

¤ 
¦ l 

is NP-hard. 

We remark that if we do not require the arity of the pred-
icate symbols in 

£ 

to be bounded, then we must replace 

e 
f  

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>v is a conjunction of standard policies and both D and DH are closed terms of the appropriate sort, such that (a)  is a basic environment, (b) equality is not used in  or v , (c) if a variable appears in a policy  in v , then it appears as an argument to Permitted in  , and (d) there are no bipolars in v .</head><label></label><figDesc></figDesc><table>literals 

m 

and 

m 
F H 

are unifiable if there are variable 
substitutions 

r 

and 

r 
H 

such that 

m 
 r 
t s 
u m 
Hr 
H 

. For ex-
ample, 

v 
w © 
Q 
E 
F  
R 


and 

v 
w © 
Y  
 
E 
Y  


are unifiable by substitut-
ing 

 
 

for 

Q 

and 

 
 

for 

 

, while 

v 
w © 
Q 
E 
F  
R 


and 

v 
w © 
w  
W E 
F  
 


are not unifiable (assuming that 

 
R 

and 

 
 

are distinct 
constants). A literal 

m 

is bipolar in formula 

X 

, written 
in CNF 1 , if 

m 

is in 

X 

and there is another literal 

m 
H 

in 

X 

such that 

m 

and 

c 
' m 
H 

are unifiable. The pair 

m 

, 

m 
H 

is 
called a bipolar pair. For example, Permitted© 

Q 
E 

n ap 

and 
Permitted© Advisor© 

Q 

E 

n ap 

are the only bipolar literals in 
the formula 

P 
d Q 
© 

P 
ermitted© 

Q 
E 

p lay 


p 

Permitted© 

Q 
E 

n ap`Permitted© 

ap` 

ap`Permitted© Advisor© 

Q 

E 

n ap 


I 

. 

Theorem 4.1: Let 

£ 

be a vocabulary that contains 
Permitted (and possibly other predicate, constant, and func-
tion symbols). Let 

¤ 
k x 

consist of all closed formulas in 

¤ 
¦ ¥ 
¨  § 
© 
£ 


of the form 

 
p 
v 
y ` 

Permitted© 

w D 
F E 
Y DH 


, where 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>likely to be met if all the policies are permitting policies (that is, their conclusions have the form Permitted©</head><label></label><figDesc></figDesc><table>and 3.2 do 
not. In particular, whether the policy in Example 3.2 allows 

Q 
R 

to enter the stacks depends on an attribute of some other 
person 

Q 
y  

. As we shall see, we can allow variables to appear 
in policies without appearing as arguments to Permitted, as 
long as the number of such variables in any one policy is 
small. 

The last restriction, that there are no bipolar literals in 

 
R 
p 
T 
F T 
8 T 
p 
 
 

, is 1 D 
R 
E 
G D 
 


) or all are denying policies (that is, their 
conclusions have the form 

c 

Permitted© 

w D 
R 
E 
G D 
 


</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><head>X relative to  .</head><label></label><figDesc></figDesc><table>say that 

m 

and 

m 
H 

are unifiable relative 
to a set 

 

of equality statements if there are variable substi-
tutions 

r 

and 

r 
H 

such that it follows from 

 

that 

m 
 r 
¤ s 
¥ m 
Hr 
H 

. 
For example, 

v 
w © 
G h 


and 

v 
w © 
G ¦ 


are unifiable relative to 

h 
 s 
~ ¦ 

. 
Similarly, we can talk about a literal 

m 

being bipolar in for-
mula 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head>v is a conjunction of standard policies and both D and DH are closed terms of the appropriate sort, such that (a)  is a basic environment with § constants, (b) no policy in v has an inequality in its antecedent, and (c) there are no bipolars in v relative to the equality state- ments in  . If there are at most ª</head><label></label><figDesc>The condition in our first result is met by this policy, because each literal has only one variable that does not appear in Permitted.variables in a single policy that do not appear as arguments to Permitted, then we can determine the validity of the formula in time</figDesc><table>The second 
result applies with 

ª 
¬ s 
B ­ 

, because the policy has three vari-
ables that do not appear as arguments to Permitted, namely 

Q 
 R 

, 

Q 
 

, and 

Q 
j 

. 
It is unlikely that these results can be significantly im-
proved, because even with our bipolar restriction, we can 
show that the general problem is NP-complete. However, 

we expect that both 

 § 

and 

ª 

will be quite small in prac-
tice. Therefore, we can still answer queries efficiently in 
practice. 
The following theorem summarizes the discussion thus 
far: 

Theorem 4.2: Let 

£ 

be a vocabulary that contains 
Permitted (and possibly other predicate, constant, and func-
tion symbols). Let 

¤ 
k ® 

consist of all closed formulas in 

¤ 
¦ ¥ 
¨  § 
© 
£ 


of the form 

 
p 
v 
y ` 

Permitted© 

w D 
F E 
Y DH 


, where 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><head>where ¦ is the number of bipolar pairs in X relative to the equality statements in   , µ ¶ is the longest conjunct in X , and ·</head><label></label><figDesc></figDesc><table>is defined as fol-
lows. If every literal that appears in a conjunct in 

 
R 
¦ p 
v 

has at most one variable that does not appear as an argu-
ment to an instance of Permitted in that conjunct, then 

· 

is 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12" validated="false"><head></head><label></label><figDesc>where ª is the largest number of variables appearing in a single conjunct that do not also appear as arguments to an instance of Permitted in that conjunct. Because the environment, by definition, does not contain the Permitted predicate, every variable in a conjunct in  R</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13" validated="false"><head>parents of the resolvent and we say that we resolve on a literal m (or c ' m ) if that is the shared literal used in creating the resolvent. The closure of a universal formula</head><label></label><figDesc>CNF) does not refer to an inequality. The reason for the equality restriction is that the resolu- tion procedure assumes all constants are distinct, regardless of statements to the contrary. For example, consider the fol- lowing three statements about Bob and Robert. , the resolution pro- cedure recognizes that the constant Bob in the first clause refers to the same individual as the constant Bob in the sec- ond. Thus, the procedure resolves the two clauses to create the resolvent false, which indicates thatis unsatisfiable. If equality occurs only in clauses that are ground literals, then the fix is straightforward. We simply compute, for each constant, the set of constants equal to it according to the equality statements among the ground literals. This parti- tions the constants into equivalence classes. We then choose a representative element from each equivalence class, and replace each occurrence of a constant by the equivalent rep- resentative element. For example, given X x j , we would re- place every occurrence of Bob with Robert (or vice-versa), since Bob and Robert are in the same equivalence class. Note that, after the substitution, there are two bipolar literals in</figDesc><table>. Res-
olution tries to find clauses 

µ 
R 

and 

µ 
 

and a substitution 

r 

under which 

µ 
R 

and 

µ 
 

refer to the same literal with 
different polarities (one refers to the literal 

m 

, the other 
to 

c 
' m 

). If the search is successful, then a new clause, 
called the resolvent, is created by taking the disjunction of 

µ 
R 
r 

and 

µ 
 
r 

after removing the shared literal from each 
clause. For example, given the clauses c 
¹ º 
¦ © 
G X 
 © 
Q 

I 
 

Permitted© 

w » 
 © 
Q 

E 
 


. 2 Throughout the rest of 
the paper, we refer to the clauses 

µ 
R 

and 

µ 
 

as the X 

, denoted 

« 
© 
Y X 


, is the 
smallest set of clauses such that 

X 
¥ ¼ 
i « 
 © 
G X 


and if 

½ 

is a re-
solvent of two clauses that are in 

« 
© 
Y X 


, then 

½ 

is in 

« 
© 
Y X 


. 
A key property of the resolution procedure is the following 
statement. If no positive literal in 

X 

(written in CNF) in-
volves equality, then 

« 
 © 
Y X 
p 
P 
d Q 
© 
Q 
s 
Q 

I 

contains false iff 

X 

is not satisfiable. Thus, we can use resolution to check the 
validity of an existential formula provided that the formula 
(in X 
 

is not satisfiable. 
Now consider 

X 
j 

. Because of the last clause in 

X 
j 

, Bob 
cannot be a different individual than Robert, however the 
resolution procedure fails to take this into account. There-
fore, it does not resolve the first two clauses and 

« 
 © 
G X 
j 


does 
not contain false, even though 

X 
j 

¾ 
 
©  
d  

for 

¿ 

, instead of, say substituting 

¾ 
 
 À 
 

for 

¿ 

and 

À 

for 

 

. (See [30] for details.) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15" validated="false"><head>Suppose X has § constants and µ is a clause in «Ð ¹ Ñ be the set of literals in µ that unify with no more than one literal in X relative to the equality state- ments in X . Let Ò n Ñ be the set of variables in µ that do not appear in any literal in Ð ¹ Ñ . (i) If every literal in µ has no more than one vari- able that is in . The reason that Proposition 4.5(a) holds is that we re- solve only on literals that are bipolar. It follows that the only resolvents created from the clauses in</head><label></label><figDesc></figDesc><table> © 
G X 
H 


. 
Let 

X 
H 

are those created 
by the bipolar pairs, and only one resolvent is created per 
pair. Furthermore, these are the only resolvents in the clo-
sure, because none of the resolvents created by this process 
have a bipolar literal. To prove Proposition 4.5(b), we need 
one more fact (proved in the full paper): For any resolvent 

½ 
o 

with one parent in 

« 
 © 
Y µ 
Â 
p 
X 


and another in 

« 
 © 
G µ 
S Ô 
p 
X 


, 
there is a resolvent 

µ 
o 

whose parents are 

µ 
Â 

and 

µ 
S Ô 

(thus 

µ 
o 

is in 

« 
 © 
G X 
H 


) such that 

½ 
o 

is in 

« 
© 
Y µ 
o 
p 
X 


. 

« 
 © 
G µ 
p 
X 


can 
contain false iff one of the following Finally, for Proposi-
tion 4.5(c), it is easy to show that 

« 
 © 
Y µ 
p 
X 


contains false 
iff either 

(i) 

« 
 © 
G X 


contains false, or 

(ii there is a variable substitution 

r 

such that, for every 
disjunct 

m 

in 

µ 
r 

, there is a conjunct of 

X 

equivalent to 

c 
' m 

relative to the equality statement in 

X 

. 

Since 

X 

is a conjunction of ground literals, it is satisfi-
able unless there is a bipolar in 

X 

(in which case resolv-
ing on the bipolar produces false). We can check this in 
time 

z 
© 
Y { 
| X 
W { 
 
w  
  
{ 
© X 
W { 


, using an appropriate dictionary struc-
ture. Clearly, we can check if the second statement holds 
in time 

 § 
o 
{ 
© µ 
 { 
 
|  
"  
{ 
© X 
W { 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_18" validated="false"><head>some ß in × , then</head><label></label><figDesc></figDesc><table>Theorem 4.6: Suppose that 

 

is a standard environ-
ment and on a literal that 
involves Permitted, either 

 
Þ ` 
X 

is valid or 

ß 
~ ` 
X 

is 
valid for </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_19" validated="false"><head>DH is valid for any terms D and DH</head><label>is</label><figDesc></figDesc><table>of the appro-
priate sort. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_20" validated="false"><head>environment</head><label></label><figDesc></figDesc><table> 

and policy set 

v. 
Thus, we can apply our previous techniques to checking 
consistency. However, we can say even more. If the condi-
tion of Theorem 4.6 (or the corresponding condition for de-
termining prohibitions) is met, then we automatically have 
consistency, provided that 

 

is consistent. 

Theorem 4.7: Suppose that 

 

is a simple environment and 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_22" validated="false"><head>)</head><label></label><figDesc></figDesc><table></table></figure>

			<note place="foot">X j when originally there were none. Since this procedure 2 Actually, the resolution procedure looks for a particular type of substitution called a most general unifier (mgu). This is why, in our example, we substitute</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank Carl Lagoze for his advice on the policy needs of digital libraries, Riccardo Pucella for numerous discussions on the material presented here, Thomas Bruce for pointing us to the documents on Social Security, and Moshe Vardi for discussions about the complexity of fragments of first-order logic.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A calculus for access control in distributed systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lampson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Prog. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="706" to="734" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">An access control model supporting periodicity constraints and temporal reasoning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Bertino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bettini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ferrari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Samarati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="231" to="285" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">The keynote trust management system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Blaze</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Feigenbaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ioannidis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Keromytis</surname></persName>
		</author>
		<ptr target="http://www.cis.upenn.edu/âangelos/keynote.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Decentralized trust management</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Blaze</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Feigenbaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lacy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 1996 IEEE Symposium on Security and Privacy</title>
		<meeting>1996 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="164" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Compliance checking in the PolicyMaker trust management system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Blaze</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Feigenbaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Strauss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Financial Cryptography</title>
		<meeting>Financial Cryptography</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="254" to="274" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Trust management for IPsec</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Blaze</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ioannidis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Keromytis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the Network and Distributed System Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="139" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">The Classical Decision Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Borger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gradel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Gurevich</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin Heidelberg</pubPlace>
		</imprint>
	</monogr>
	<note>1nd edition</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Symbolic Logic and Mechanical Theorem Proving</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-L</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-T</forename><surname>Lee</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1973" />
			<publisher>Academic Press</publisher>
			<pubPlace>Boston</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A logic programming approach to conflict resolution in policy management</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chomicki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lobo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Naqvi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Knowledge Representation and Reasoning: Proc. Ninth International Conference (KR &apos;00)</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="121" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">The digital rights language for trusted content and services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Contentguard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Xrml</surname></persName>
		</author>
		<ptr target="http://www.xrml.org/" />
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Binder, a logic-based security language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Detreville</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 2002 IEEE Symposium on Security and Privacy</title>
		<meeting>2002 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="95" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Simple public key certificate</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ellison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Frantz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lampson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ylonen</surname></persName>
		</author>
		<ptr target="http://world.std.com/âcme/spki.txt" />
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
	<note>Internet RFC 2693</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ellison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Frantz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lampson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ylonen</surname></persName>
		</author>
		<ptr target="http://www.ietf.org/html.charters/spki-charter.html" />
		<title level="m">SPKI certificate theory</title>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
	<note>Internet RFC 2693</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">A Mathematical Introduction to Logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">B</forename><surname>Enderton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1972" />
			<publisher>Academic Press</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A role based access control model and reference implementation within a corporate intranet</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ferraiolo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Barkley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kuhn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Information and System Security</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="34" to="64" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Database Systems: The Complete Book</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<publisher>Prentice Hall</publisher>
			<pubPlace>New Jersey</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An authorization mechanism for a relational database system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Griffiths</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Wade</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="242" to="255" />
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Logical foundations for trust management</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Y</forename><surname>Halpern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Van Der Meyden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Schneider</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
	<note>manuscript</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">A practical approach to analyzing policy languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Y</forename><surname>Halpern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Weissman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
	<note>In preparation.</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Tower: A language for role based access control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hitchens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Varadharajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Workshop of Policies for Distributed Systems and Networks</title>
		<meeting>International Workshop of Policies for Distributed Systems and Networks</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="88" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Iannella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Odrl</surname></persName>
		</author>
		<ptr target="http://odrl.net/" />
		<title level="m">The open digital rights language initiative</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Supporting inconsistent rules in database systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Ioannidis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Sellis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Intelligent Information Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3/4</biblScope>
			<biblScope unit="page" from="243" to="270" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Flexible support for multiple access control policies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jajodia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Samarati</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">L</forename><surname>Sapino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Subrahmanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="214" to="260" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">SD3: A trust management system with certified evaluation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Jim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 2001 IEEE Symposium on Security and Privacy</title>
		<meeting>2001 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="106" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Delegation Logic: A logic-based approach to distributed authorization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">N</forename><surname>Grosof</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Feigenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transaction on Information and System Security (TISSEC)</title>
		<imprint>
			<date type="published" when="2003-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Datalog with constraints: A foundation for trust management languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth International Symposium on Practical Aspects of Declarative Languages</title>
		<meeting>the Fifth International Symposium on Practical Aspects of Declarative Languages</meeting>
		<imprint>
			<date type="published" when="2003-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Design of a role-based trust-management framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">H</forename><surname>Winsborough</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 2002 IEEE Symposium on Security and Privacy</title>
		<meeting>2002 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="114" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Permissions and obligations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Mccarty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Joint Conf. on Artificial Intelligence</title>
		<meeting>Int. Joint Conf. on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="1983" />
			<biblScope unit="page" from="287" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A different approach to deontic logic: Deontic logic viewed as a variant of dynamic logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-J</forename><forename type="middle">C</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Notre Dame Journal of Formal Logic</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Logic for Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Nerode</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Shore</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>SpringerVerlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
	<note>2nd edition</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Constraint query languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">R P C</forename><surname>Kanellakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">M</forename><surname>Kuper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="26" to="52" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">The Mellon Fedora project: Digital library architecture meets XML and web services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Payette</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Staples</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Research and Advanced Technology for Digital Libraries</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="406" to="421" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Constraint databases: A survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Revesz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Semantics in Databases</title>
		<meeting>the Workshop on Semantics in Databases</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="209" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">SDSI -a simple distributed security infrastructure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lampson</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">UNIX in a nutshell: System V Edition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Robbins</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>Reilly and Associates, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Role-based access control models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Sandhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename><surname>Coyne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">L</forename><surname>Feinstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename><surname>Youman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="38" to="47" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
