<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:49+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Dynamic Key-Updating: Privacy-Preserving Authentication for RFID Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Li</forename><surname>Lu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Graduate School of Chinese Academy of Sciences</orgName>
								<orgName type="laboratory">State Key Laboratory of Information Security</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jinsong</forename><surname>Han</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Dept. of Computer Science and Engineering</orgName>
								<orgName type="institution">Hong Kong University of Science and Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lei</forename><surname>Hu</surname></persName>
							<email>hu@is.ac.cn</email>
							<affiliation key="aff0">
								<orgName type="department">Graduate School of Chinese Academy of Sciences</orgName>
								<orgName type="laboratory">State Key Laboratory of Information Security</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yunhao</forename><surname>Liu</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Dept. of Computer Science and Engineering</orgName>
								<orgName type="institution">Hong Kong University of Science and Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lionel</forename><forename type="middle">M</forename><surname>Ni</surname></persName>
							<email>ni@cse.ust.hk</email>
							<affiliation key="aff1">
								<orgName type="department">Dept. of Computer Science and Engineering</orgName>
								<orgName type="institution">Hong Kong University of Science and Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Dynamic Key-Updating: Privacy-Preserving Authentication for RFID Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>The objective of private authentication for Radio Frequency Identification (RFID) systems is to allow valid readers to explicitly authenticate their dominated tags without leaking tags&apos; private information. To achieve this goal, RFID tags issue encrypted authenti-cation messages to the RFID reader, and the reader searches the key space to locate the tags. Due to the lack of efficient key updating algorithms, previous schemes are vulnerable to many active attacks, especially the compromising attack. In this paper, we propose a Strong and lightweight RFID Private Authenti-cation protocol, SPA. By designing a novel key updating method, we achieve the forward secrecy in SPA with an efficient key search algorithm. We also show that, compared with existing designs, SPA is able to effectively defend against both passive and active attacks , including compromising attacks. Through prototype implementation, we observe that SPA is practical and scalable in current RFID infrastructures.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The proliferation of RFID applications <ref type="bibr" target="#b10">[11]</ref> raises an emerging requirement -protecting user privacy <ref type="bibr" target="#b12">[13]</ref> in RFID authentications. In most RFID systems, tags automatically emit their unique serial numbers upon reader interrogation without alerting their users. Within the scanning range, a malicious reader can perform bogus authentication with detected tags to retrieve sensitive information. For example, without privacy protection, any reader can identify a consumer's ID via the emitted serial number from the tag. As a result, a buyer can be tracked and profiled by unauthorized people. In addition, many companies usually embed tags in items.</p><p>Those tags indicate the unique information of the items to which they attach. Thus, a customer carrying those tags is subject to silent track from unauthorized readers. Some sensitive personal information would thereby be exposed: the illnesses she may suffer from indicated by the pharmaceutical products; the malls where she shops; the types of items she prefers to buy, and so on. Therefore, a secure RFID system must meet two requirements. On one hand, a valid reader must successfully identify the valid tags; on the other hand, misbehaving readers should not be able to retrieve private information from these tags.</p><p>To address the above issue, researchers employ encryptions in RFID authentication. Each tag shares a unique key with the RFID reader and sends an encrypted authentication message to the reader. Instead of identifying the tag directly, the back-end database subsequently searches all keys that it holds to recover the authentication message and identify the tag. For simplicity, we will denote the reader device and backend database by the "reader" in what follows. Two challenging issues on the reader side must be addressed in the key storage infrastructure and search algorithm: the search efficiency and the security guarantee. First, searching a key should be sufficiently fast to support a large scale system. Second, the keys should be updated dynamically for security concerns.</p><p>Many efforts have been made to achieve efficient private authentication. To the best of our knowledge, the most efficient protocols are tree-based <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b9">10]</ref>. They provide an efficient key search scheme with logarithm complexity. In such approaches, each tag holds multiple keys instead of a single key. A virtual hierarchical tree structure is constructed by the reader to organize these keys. Every node in the tree, except the root, stores a unique key. Each tag is associated with a unique leaf node. Keys in the path from the root to the leaf node are then distributed to this tag. If the tree has a depth d and branching factor δ , each tag contains d keys and the entire tree can support up to δ d N = tags. A tag encrypts the authentication message by using each of its d keys. During authentication, the reader performs a depth-first search in the key tree. In each hierarchy, the reader can narrow the search set within δ keys. Thus, the reader only needs to search δ d keys for each tag's authentication. Therefore, the key search complexity of identifying a given tag from N tags is logarithmic in N.</p><p>The tree based approaches are efficient, nevertheless, not secure due to the lack of a key-updating mechanism. Most, if not all, tree-based approaches never update tags' keys dynamically. Since the key storage infrastructure of tree-based approaches is static, each tag, more or less, shares some common keys with others. Consequently, compromising one tag might reveal information of other tags. To address this problem, we need to provide a dynamic key-updating mechanism to such approaches. The major challenge of dynamic key-updating in tree-based approaches is consistency. If a single tag updates its keys, some other tags have to update their keys accordingly. To our knowledge, consistent and dynamic key-updating mechanisms have scarcely been seen in the literature.</p><p>In this paper, we propose a Strong and lightweight RFID Private Authentication protocol, SPA, which enables dynamic key-updating for tree based authentication approaches. Besides consistency, SPA also achieves forward secrecy without degrading key search efficiency. We also show that SPA outperforms existing designs in defending against both passive and active attacks, including the compromising attack.</p><p>The rest of this paper is organized as follows. We introduce related work in Section 2. We present the SPA design in Section 3. In Section 4, we analyze the security guarantee of SPA. We evaluate the performance of SPA via a prototype implementation in Section 5. We conclude this paper in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related Work</head><p>Many approaches have been proposed to achieve private authentication in RFID systems. Weis et al. <ref type="bibr" target="#b13">[14]</ref> proposed a hash function based authentication scheme, HashLock, to avoid tags being tracked. In this approach, each tag shares a secret key k with the reader. The reader sends a random number r as the authentication request. To respond to the reader, the tag generates a hash value on the inputs of r and k. The reader then computes h(k, r) of all stored keys until it finds a key to recover r, thereby identifying the tag. The search complexity of HashLock is linear to N, where N is the number of tags in the system. Most subsequent approaches in the literature are aimed at reducing the cost of key search. Juels <ref type="bibr" target="#b7">[8]</ref> classifies these approaches into three types.</p><p>Tree based approaches: tree based approaches <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b9">10]</ref> improve the key search efficiency from linear complexity to logarithmic complexity. <ref type="bibr">Molnar et al.</ref> proposed the first tree-based scheme, which employs a challenge-response scheme <ref type="bibr" target="#b9">[10]</ref>, which achieves mutual authentication between tags and readers. The protocol uses multiple rounds to identify a tag and each round needs three messages. Since it requires O(logN) rounds to identify a tag, the exchanged messages incur relatively large communication overhead. In <ref type="bibr" target="#b4">[5]</ref>, the authors provide a more efficient scheme which performs the authentication via one message from the tag to the reader and no further interactions. However, the tree based approaches are often vulnerable to the Tag Compromising Attack. Because tags share keys with others in the tree structure, compromising one tag results in compromising secrets in other tags.</p><p>Synchronization approaches: synchronization approaches <ref type="bibr" target="#b11">[12]</ref> make use of an incremental counter to enhance the authentication security. When successfully completing an authentication, the counter of a tag augments by one. The reader can compare the value of a tag's counter with the record in the database. If they match, the tag is valid and the reader will synchronize the counter record of this tag. However, incomplete authentications lead the tag's counter larger than the one held by the reader. To solve this problem, the reader keeps a window for each tag. Such a window limits the maximum value of the counter held by the tag. If a tag's counter is larger than the record held by the reader but within the window, the reader still regards this tag as valid. Such schemes are vulnerable to the Desynchronization Attack. In such an attack, an invalid reader can interrogate a tag many times so that the counter of this tag exceeds the window recorded in the valid reader. In <ref type="bibr" target="#b6">[7]</ref>, the authors proposed a protocol to mitigate the impact from desynchronization attacks by allowing tags to report the number of incomplete authentications since the last successful authentication with the reader. Dimitriou proposed a scheme in <ref type="bibr" target="#b3">[4]</ref>, in which a tag increases its counter only after successful mutual authentications. Those protocols, however, degrade the anonymity of tags. An attacker is still able to interrogate a given tag enough times so that the tag will be immediately recognized when replying with unchanged responses.</p><p>Time-space tradeoff approaches: Avoine converted the key search problem to an attempt at breaking a symmetric key <ref type="bibr" target="#b2">[3]</ref>. In <ref type="bibr" target="#b5">[6]</ref>, Hellman studied the keybreaking problem and claimed that to recover a symmetric key k from a ciphertext needs to pre-compute and to store O(N 2/3 ) possible keys. Accordingly, the key search complexity is O(N 2/3 ) in key-breaking based approaches. Obviously, those approaches are not efficient compared with tree based approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">SPA Protocol</head><p>In this section, we first introduce the challenging issues of static tree based private authentication approaches. We then present the design of SPA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Challenges of Tree Based Approaches</head><p>Existing tree based approaches <ref type="bibr" target="#b4">[5]</ref> construct a balanced tree to organize and store the keys for all tags. Each node stores a key and each tag is arranged to a unique leaf node. Thus, there exists a unique path from the root to this leaf node. Correspondingly, those keys on this path are assigned to the tag. For example, tag T 1 obtains keys k 0 , k 1,1 , k 2,1 , and k 3,1 , as illustrated in <ref type="figure" target="#fig_0">Fig.  1</ref>. When the reader R authenticates T 1 , it first sends a nonce r to tag T 1 . T 1 encrypts r with all its keys and includes the ciphertexts in a response. Upon the response from T 1 , the reader searches proper keys in the key tree to recover r. This is equal to marking a path from the root to the leaf node of T 1 in the tree. At the end of identification, if such a path exists, R regards T 1 as a valid tag. Usually, the encryption is employed by using cryptographic hash functions.</p><p>From the above procedure, we see that tags will, more or less, share some non-leaf nodes in the tree. For example, T 1 and T 2 share k 2,1 , while T 1 , T 2 , T 3 , and T 4 share k 1,1 . Of course all tags share the root k 0 . Such a static tree architecture is efficient because the complexity of key search is logarithmic. For the example in <ref type="figure" target="#fig_0">Fig. 1</ref>, any identification of a tag only needs log 2 (8) = 3 search steps. If the adversary compromises some tags, however, it obtains several paths from the root to those leaf nodes of the compromised tags, as well as the keys on those paths. Since keys are never changed in the static tree architecture, the captured keys will still be used by uncompromised tags. As a result, the adversary captures the secret of uncompromised tags.</p><formula xml:id="formula_0">0 k 1 , 1 k 2 , 1 k 1 , 2 k 2 , 2 k 3 , 2 k 4 , 2 k 1 T 1 , 3 k 2 , 3 k 4 , 3 k 3 , 3 k 5 , 3 k 6 , 3 k 8 , 3 k 7 , 3</formula><p>A practical solution is to update keys for a tag after each authentication so that the adversary cannot make use of keys obtained from compromised tags to attack uncompromised ones. However, the static tree architecture is not capable of solving the key-updating problem. Suppose we update the keys of T 1 in <ref type="figure" target="#fig_0">Fig. 1</ref>, we have to change k 0 , k 1,1 , k 2,1 , and k 3,1 partially or totally. Note that k 1,1 is used by T 2 , T 3 , and T 4 , and k 2,1 is used by T 2 . To keep the updating consistent, the keys of all influenced tags must be updated and re-distributed. A challenging issue is that if the position of a key is close to the root, the key-updating would influence more tags. For example, updating k 1,1 would influence half of all the tags in the system (T 1 , T 2 , T 3 , and T 4 ). One intuitive solution is to periodically recall all tags and update the keys simultaneously. Unfortunately, such a solution is not practical in large scale systems with millions or even hundreds of millions of tags. Another solution is collecting those influenced tags only and updating their keys. This is also difficult because we need to collect a lot of tags even though there is only one tag updating its keys.</p><p>This problem motivates us to develop a dynamic key-updating algorithm for private authentication in RFID systems. This is where our proposed SPA enters the picture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">SPA Overview</head><p>SPA comprises four components: system initialization, tag identification, key-updating, and system maintenance. The first and second components are similar to tree based approaches such as <ref type="bibr" target="#b4">[5]</ref> and perform the basic identification functions. The key-updating is employed after a tag successfully performs its identification with the reader. In this procedure, the tag and the reader update their shared keys. This key-updating procedure will not break the validation of keys used by other tags. SPA achieves this via two techniques: temporary keys and state bits. A temporary key is used to store the old key for each non-leaf node in the key tree. For each non-leaf node, a number of state bits are used in order to record the key-updating status of nodes in the sub-trees. Based on this design, each non-leaf node will automatically perform key-updating when all its children nodes have updated their keys. Thus, SPA guarantees the validation and consistency of private authentication for all tags. SPA also eases the system maintenance in high dynamic systems where tags join or leave frequently by using the fourth component. <ref type="figure">Figure 2</ref>. A key tree with four tags (N = 4).</p><formula xml:id="formula_1">r s 0 l s 0 l s 1 , 1 r s 1 , 1 l s 2 , 1 r s 2 , 1 0 0 ,tk k 1 , 1 1 , 1 ,tk k 2 , 1 2 , 1 ,tk k 1 , 2 k 2 , 2 k 3 , 2 k 4 , 2 k 1 T 2 T 3 T 4 T</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">System Initialization</head><p>For the simplicity of discussion, we use a balanced binary tree to organize and store keys, as shown by an example in <ref type="figure">Fig 2.</ref> Let δ denote the branching factor of the key tree (e.g., if the key tree is a binary tree, 2 = δ</p><p>). We assume that there are N tags T i , 1 ≤ i ≤ N, and a reader R in the RFID system. The reader R assigns the N tags to N leaf nodes in a balanced binary tree S. Each non-leaf node j in S is assigned with two keys, a working key k j and a temporary key tk j . The usage of tk j will be illustrated in subsection 3.5. Initially, each key is generated randomly and independently by the reader, and tk j = k j for all non-leaf nodes.</p><p>When a tag T i is introduced into the system, the reader distributes the ( log N     + 1) keys to T i . Those keys are corresponding to the path from the root to tag T i (for a non-leaf node j at the path, if</p><formula xml:id="formula_2">j j k tk ≠ , tag T i</formula><p>is assigned with k j ). For example, the keys stored in tag T 1 are k 0 , k 1,1 and k 2,1 , as illustrated in <ref type="figure">Fig. 2</ref>. From now on, we use d to denote the depth of the tree and (</p><formula xml:id="formula_3">i d i i k k k , , , 1 0 … ) to denote the secret keys distributed to T i .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Tag Identification</head><p>The basic authentication procedure between the reader and tags comprises three rounds, as illustrated in <ref type="figure" target="#fig_1">Fig. 3</ref>. In the first round, R starts the protocol by sending a "Request" and a random number r 1 (a nonce) to tag R executes the basic identification procedure to identify T i , as represented Step 1 in <ref type="figure" target="#fig_1">Fig. 3</ref>. From the root, the reader first encrypts r 1 by using k 0 , and compares the result with ) , ( 1 0 r k h from T i . If they match, R invokes a recursive algorithm, Algorithm 1, as illustrated in <ref type="figure">Fig. 4</ref> to identify T i . For the example in <ref type="figure">Fig. 2</ref>, the reader starts from the root and encrypts r 1 by using k 1, 1 (or tk 1, 1 ) and k 1, 2 (or tk <ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b1">2</ref>  by using the keys of node j's children, then compares them with v l . Note that v l is in the authentication message U received from T i . If there is a match, T i must belong to the sub-tree of the matched j's child node. Therefore, R extends the path to that node and continues the identification procedure until reaching a leaf node.</p><formula xml:id="formula_4">T i , 1 ≤ i ≤ N.</formula><p>In short, identifying a tag is similar to traversing from the root to a leaf in the key tree. The path is determined by using Algorithm 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Key-Updating</head><p>After successfully identifying T i , R invokes the Key-updating algorithm in Step 2, as shown in <ref type="figure" target="#fig_1">Fig. 3</ref>. Step 1, identifying T i and Computing σ ; Step 2, sending σ to T i and key-updating. T i also updates its keys after checking σ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1: Identification (U, node n)</head><formula xml:id="formula_5">Algorithm 2: Key-updating (node n) Fix N d log ← ; false SUCCEED ← ; ) ( e DepthofNod n l ← ; if )) , ( ) , ( ( 1 1 r tk h v r k h v n l n l = ∨ = if ( d l ≠ ) if ) , ( 1 r tk h v n l = Record n in Synchronization Message; for i=1 to δ ) , ( en FindChildr i n m ← ; Identification (U, m); else if l=d true SUCCEED ← ; if ( ¬ SUCCEED)</formula><p>Fail and output 0; Accept and output 1;  </p><formula xml:id="formula_6">) ( ' j j k h k = .</formula><p>The key-updating algorithm for the key tree is shown in <ref type="figure">Fig. 5</ref>. To remain consistent, the non-leaf node j uses temporary key tk j to store j's old key. In this way, the key-updating of a tag will not interrupt the authentication procedures of other tags belonging to j's sub-tree.</p><p>Two challenging issues must be addressed when updating keys. First, R should update the keys of the identified tag T i without interrupting the identification of other tags. This is because the keys stored in nonleaf nodes are shared by multiple tags. Those keys should be updated in a consistent manner. Second, each non-leaf node should automatically update its keys when all its children have updated their keys.</p><p>To address the two issues, SPA introduces a number of state bits to each non-leaf node. The basic idea behind this mechanism is that each non-leaf node uses these bits to reflect the key-updating status of its children. Once a child has updated its key, the corresponding bit is set to 1. Each node updates its own key when all its state bits become 1.</p><p>Without losing generality, we still use balanced binary key tree S to illustrate this mechanism. Each nonleaf node j in S is assigned with two state bits, denoted as . If yes, T i updates its keys according to the synchronization message. For example, in <ref type="figure">Fig. 2</ref>, suppose that R has updated keys k 1, 1 and k 1, 2 at level 1 and 2 after identifying T 2 . The synchronization message is <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b1">2)</ref>. Accordingly, T 2 updates k 1,1 as k' 1, 1 = h'(k 1,1 ) and k 2,2 as k' 2, 2 = h(k 2, 2 ), respectively. This algorithm guarantees that the key-updating is consistent and feasible under arbitrary tag access patterns.</p><p>The key-updating algorithm is suitable for an arbitrary balanced tree with δ &gt; 2. In such a tree, there are δ state bits maintained in each non-leaf node to indicate the key-updating states of δ children.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">System Maintenance</head><p>In practice, users might withdraw their tags. On the other hand, some tags of new users might be added. To deal with these maintenance issues, SPA provides the tag enrollment and withdrawal services. If a new tag T i joins the system, R starts the tag enrollment service. R first finds an empty leaf node in the key tree S and associates T i with this node. T i is accordingly assigned with the keys of nodes which are on the path from the root to the leaf node in S. If there is no an empty leaf node in S, R creates a new balanced tree S' with the branching factor δ and depth d-1. R then initializes S' by employing the system initialization component, as we described in Section 3.3. After initialization, R grafts S' onto the root of S and S' becomes a sub-tree of S. T i is then assigned to an empty leaf node in S' and T i 's keys are distributed according to the path from root of S to the leaf node. For example, in <ref type="figure" target="#fig_5">Fig. 6</ref>, R has 4 tags and all leaf nodes in S are occupied. If a new tag T 5 joins the system, R creates a new sub-tree marked with a dashed square. A leaf node in this sub-tree is associated with T 5 . T 5 's keys are k 0 , k 1,3 and k 2,5 . Indeed, increasing branching factor δ of the root of S incurs extra processes to the RFID system. For the example in <ref type="figure" target="#fig_5">Fig. 6</ref>, increasing δ of the root in a binary tree by one results in N/2 empty leaf nodes, while the added computation overhead is only one hash operation for node <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b2">3)</ref>.</p><p>For any empty leaf node i in the key tree, i's parent node j will lock the corresponding state bit s j as 1 until node i is assigned to a new tag T i . The purpose of such constraint is to protect key-updating of other tags from being interrupted. Otherwise, if s j is 0, it will never change such that node j will never update the keys.</p><p>If a tag is withdrawn, R empties the leaf node associated to this tag and sets the corresponding bit of the parent node to 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Discussion</head><p>In this section, we first discuss the security requirements for designing private authentication protocols in RFID systems. To evaluate the security of SPA, we propose an attack model to represent existing attacking scenarios. We then demonstrate the ability of SPA to meet those requirements and to defend against attacks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Security Requirements</head><p>A private authentication protocol should meet the following security requirements <ref type="bibr" target="#b4">[5]</ref>.</p><p>Privacy. The private information, such as tag's ID, user name, and other private information should not be leaked to any third party during authentication.</p><p>Untraceability. A tag should not be correlated to its output authentication messages; otherwise, it may be tracked by attackers.</p><p>Cloning resistance. Attackers should not be able to use bogus tags to impersonate a valid tag. Also, the replay attack should be resisted.</p><p>Forward secrecy. Attackers can compromise a tag to obtain the keys stored in it. In this case, those keys should not reveal the previous outputs of the captured tag.</p><p>Compromising resistance. The privacy of uncompromised tags is threatened if they share some keys with compromised tags. Thus, the number of affected tags should be minimized after a successful compromising attack.</p><p>Existing private authentication approaches are able to defend against passive attacks (i.e., eavesdropping), but are vulnerable to active attacks (i.e., cloning and compromising attacks). Therefore, our discussion will focus on how SPA protects tags from active attacks. From the attacker's perspective, two metrics are important for evaluating the capability of SPA in defending against active attacks: (a) past-exposing probability, the probability of successfully identifying the past outputs of a compromised tag -this metric reflects the forward secrecy property of an authentication scheme; and (b) correlated-exposing probability, the probability of successfully tracing a tag when some other tags in the system are compromised.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Attack Model</head><p>Avoine <ref type="bibr" target="#b1">[2]</ref> provides an attack model for RFID systems. The model reflects the impacts of different attacks on the authentication protocols. Our discussions are mainly based on this model. In the model, the attackers and the RFID system are abstracted into two participants: the Adversary A (the attackers) and the Challenger C (the RFID system). Attacking-defending between the attackers and the RFID system is like a game between A and C. A first informs C that A will start to attack. C then chooses two tags to perform SPA protocols. If A can successfully distinguish one tag from another based on their outputs, we claim that A successfully compromises the privacy of the system. For simplicity, we let P denote the SPA authentication procedure. We define four oracles, Query, Send, Executive, and Reveal, to model the attacks on each tag T and the reader R. Thus, each T or R has four such oracles in our model. Any attack on a given R or T can be represented as A's calling on one of its oracles as follows:</p><p>Query(T, m 1 , m 3 ): A sends a request m 1 to T. Subsequently, A receives a response from T. R then sends the message m 3 to T. Note that m 1 and m 3 represent the messages sent in the first and third round of SPA authentication procedure, respectively.</p><p>Send(R, m 2 ): A sends a message m 2 to R and receives R's response. Note that m 2 represents the message sent in the second round in a SPA authentication procedure.</p><p>Execution(T, R): A acts as "a man in the middle" and executes an instance of P with T and R, respectively. A then modifies the received response message from one side and relays it to the other side.</p><p>Reveal(T): After accessing this oracle of T, A compromises T, which means A obtains T's keys. Note that A can distinguish any given tag T from other tags if it can obtain T's keys.</p><p>Based on these oracles, the detailed procedure of a game between A and C is demonstrated by the following steps.</p><p>1) A tells C that the game begins. C chooses two tags T 0 and T 1 .</p><p>2) For two tags T 0 and T 1 chosen by C, A accesses the oracles of T 0 and T 1 . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Security Analysis</head><p>In this subsection, we show how SPA meets the security requirements.</p><p>Privacy: The privacy is guaranteed by the security of the hash function used in SPA. Due to the pseudorandomness and one-way properties of cryptographic hash functions, it is safe to claim that the output of the hash function can be seen as a random bit string. Therefore, the messages sent by the reader and tags will not reveal private information to any passive adversary. It is difficult, if not impossible, for passive adversaries to deduce the original messages based on the output of hash functions, unless they can break the hash function. It is well known that the probability of breaking a hash function is negligible.</p><p>Untraceability: SPA provides untraceability for tags. Since keys are dynamically updated in SPA, the encrypted messages of each tag are also changed accordingly. Thus, any passive adversary cannot track a tag by identifying the encrypted messages.</p><p>Cloning resistance: In a cloning attack, an adversary captures the messages from a tag and sends them to the reader repeatedly <ref type="bibr" target="#b4">[5]</ref>. Similar to previous protocols, SPA employs random numbers r 1 and r 2 to defend against the cloning attack. Since the random numbers r 1 and r 2 are generated uniformly at random for each authentication procedure, it is extremely difficult for attackers to pre-determine them. In addition, the length of r 1 (r 2 ) in SPA is sufficiently long (more than 64 bits) such that the probability of successfully guessing a random number is negligible. Thus, SPA is not subject to the cloning attack.</p><p>Forward secrecy: If a tag is compromised, the adversary might obtain the tag's current keys. Since the keys stored in the tag are updated after each authentication procedure, the adversary cannot recover the past outputs of the compromised tag. Therefore, we can consider that the past-exposing probability of SPA approaches 0 and the forward secrecy of tags can be guaranteed. On the contrary, tags in the static tree protocols <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b9">10]</ref> never update their keys. Adversaries can easily recover the past outputs of compromised tags by using the obtained keys. Thus, the pastexposing probability of the static tree based protocols approaches 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Compromising Attack</head><p>As we discussed in Section 3.1, a compromised tag may reveal some of the keys of other tags in static tree based protocols. The adversary is then aware of some paths from the root to the leaf nodes of the compromised tag. Based on those paths, the adversary partially compromises the tree infrastructure. Knowing the "positions" of those non-leaf nodes, the adversary can further identify a sub-tree to which T i might belong. Now we use the attack model to discuss the impact of a compromising attack on SPA. The following analysis is based on Avoine's work <ref type="bibr" target="#b2">[3]</ref>. The game procedure comprises six phases. Phase 1. Adversary A has compromised a number of tags and obtained their secret keys. Suppose the number of compromised tags is t. A will utilize the keys obtained from compromised tags in the attacks.</p><p>Phase 2. Challenger C chooses two tags T 0 and T 1 . Note that T 0 and T 1 have not been compromised. Suppose that A has compromised t tags except T 0 and T 1 . Thus, A is aware of several paths from the root to the leaf nodes of those tags as well as the relevant keys of the non-leaf nodes in those paths. Let M denote the set of the compromised non-leaf nodes in the key tree. Let M i denote the subset of M which includes the compromised nodes at the same level i in the tree.</p><p>Clearly,</p><formula xml:id="formula_7">i d i M M ∪ 1 = = .</formula><p>Correspondingly, let i M denote the set of nodes at level i which have not been compromised by A in the key tree. In Phase 5, A impersonates the reader and queries T, T 0 and T 1 with the keys obtained from compromised tags. As a result, there are three possible scenarios.</p><p>1) If neither T 0 nor T 1 has a non-leaf in M, A completely fails.</p><p>2) If either T 0 or T 1 (but not both) has a non-leaf node in M, the keys stored in this node as well as all the keys on the path from the root to this node have been compromised. The adversary can determine T in Phase 6. In this case, A succeeds.</p><p>3) If both T 0 and T 1 have an identical non-leaf node in M, A cannot directly distinguish T 0 or T 1 from the other. However, A can move down to the next lower level from the current non-leaf node in the key tree. We assume that the keys of T, T 0 and</p><formula xml:id="formula_8">T 1 are ] , , [ 0 d k k … , ] , , [ 0 0 0 d k k …</formula><p>, and</p><formula xml:id="formula_9">] , , [ 1 1 0 d k k …</formula><p>, respectively, where d is the depth of the tree. Suppose T 0 and T 1 share an identical node n i-1, 0 at lever i -1. At level i, T 0 has a node n i, 0 and T 1 has a node n i, 1 . The keys of n i, 0 and n i, 1 are 0 i k and 1 i k , respectively. Let S i-1 denote the sub-tree of the key tree S rooted at n i-1, 0 . Thus, n i, 0 and n i, 1 are both in S i-1 . Let i K denote the set of keys of the nodes in the interaction of</p><formula xml:id="formula_10">i i M S ∩ 1 − . Let i</formula><p>U denote the set of the nodes in the interaction of</p><formula xml:id="formula_11">i i M S ∩ 1 −</formula><p>. For example, suppose that R maintains a key tree with eight leaf nodes in <ref type="figure">Fig. 7</ref> δ be the branching factor of the key tree. Let a denote the number of keys belonging to a non-leaf node (in SPA, any non-leaf node stores two keys k and tk, therefore a = 2). We consider the following five cases:</p><formula xml:id="formula_12">Case 1. If )) U ( ) K (( 1 0 1 i i i i i k k C ∈ ∧ ∈ = , A succeeds. Case 2. If )) K ( ) U (( 1 0 2 i i i i i k k C ∈ ∧ ∈ = , A succeeds. Case 3. If )) ( ) K ( ) K (( 1 0 1 0 3 i i i i i i i k k k k C ≠ ∧ ∈ ∧ ∈ = , A succeeds. Case 4. If )) U ( ) U (( 1 0 4 i i i i i k k C ∈ ∧ ∈ = , A definitely fails. Case 5. If )) ( ) K ( ) K (( 1 0 1 0 5 i i i i i i i k k k k C = ∧ ∈ ∧ ∈ =</formula><p>, A fails at level i but it can move to level i + 1 to continue its attack.</p><p>For   The correlated-exposing probability of A is given by:</p><formula xml:id="formula_13">d i ≤ ≤ 1 , we have ) 1 ( ] Pr[ ] Pr[ 2 1 δ δ a t a t C C i i i i − = = , ) 1 1 ( ) ( ] Pr[</formula><formula xml:id="formula_14">− − = ∨ ∨ i i i i i t a a t C C C δ δ : 1 S : 2 M : 2 M 1 T 1 , 3 k 2 , 3 k 4 , 3 k 3 , 3 k 5 , 3 k 6 , 3 k 8 , 3 k 7 , 3 k 2 T 3 T 4 T 5 T 6 T 7 T 8 T 0 k 1 , 1 k 2 , 1 k 1 , 2 k 2 , 2 k 3 , 2 k 4 , 2 k nodes d Compromise</formula><formula xml:id="formula_15">∑ ∏ = − = × ∨ ∨ + ∨ ∨ = d i i j j i i i C C C C C C C 2 1 1 5 3 2 1 3 1 2 1 1 1 ) ] Pr[ ] (Pr[ ] Pr[ ] Succeeds Attack Pr[ ∑ ∏ = − = × − − + − − = d i i j i i i a t t a a t t a a t 2 1 1 2 2 1 2 1 ) ) ( ) 1 2 ( ) ( ( ) 1 2 ( ) ( δ δ δ δ δ (1)</formula><p>In Eq. (1), t i , the number of keys known by the adversary at level i, is given by:</p><formula xml:id="formula_16">) ) 1 1 ( 1 ( 1 t a t δ δ − − = , d i a t i t f i ≤ &lt; − − = 1 ), ) 1 1 ( 1 ( ) ( δ δ ,</formula><p>where</p><formula xml:id="formula_17">∏ − = = 1 1 1 ) ( i j j i t t t f .</formula><p>Equation <ref type="formula">(1)</ref> shows that the correlated-exposing probability is mainly determined by three key parameters: a) t, the number of compromised tags; b) δ , the branching factor of the key tree; and c) a, the number of keys belonging to each non-leaf node. Note that if a = 1, Equation (1) can also be used to evaluate the security of static tree based approaches. In <ref type="figure">Fig. 8, we</ref> show the theoretical evaluation on the security of SPA in a typical RFID system.</p><p>We assume that the system contains 2 20 tags and the depth of key tree is 20. In the worst case, the adversary A can simultaneously compromise t tags at a given time. Then, A immediately starts attacks following the game strategy with challenger C. In addition, we assume there are only T 0 and T 1 , which are chosen by C, performing authentication with the reader at this moment. Thus, we can use Eq. (1) to compute the correlated-exposing probability for A attacking SPA and static tree based approaches.</p><p>As shown in <ref type="figure">Fig 8,</ref> SPA outperforms static tree based approaches in defending against compromising attacks. In SPA, although A captures a number of keys shared by some uncompromised tags, those tags are still secure if they update their keys. In contrast, uncompromised tags in static tree based approaches would be more vulnerable because the keys obtained by A will still be in use. This would ease A's tracking attempts.</p><p>In both SPA and static tree based approaches, the correlated-exposing probability is reduced when enlarging the branching factor δ . This is because enlarging δ leads attackers to capturing fewer keys shared by uncompromised tags.</p><p>The static tree base approaches are extremely vulnerable to compromising attacks when t is sufficiently large. We find the correlated-exposing probability is close to 1 when t = 200 in static tree based approaches. In this case, enlarging δ does not help much. On the contrary, SPA can decrease the probability by increasing a. The curves of t = 200 in <ref type="figure">Fig. 8</ref> show that SPA is more secure under compromising attacks and flexible enough to meet different security concerns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Prototype Implementation</head><p>We have implemented the SPA protocol on 40 Mantis™-series 303 MHz asset tags and a Mantis™ II reader manufactured by RF Code <ref type="bibr" target="#b0">[1]</ref>. The back-end database is implemented on a desktop PC with the following configurations: Pentium M 3.2G dual core CPU, 1GBytes memory, and 40G hard disk. We use the SHA-1 algorithm as the secure hash function. In this implementation, the system is able to maintain up to N = 2 20 tags. For each test, we randomly dist r i bu t e 4 0 t a g s in t o l ea f n od es i n th e k e y tree. We perform 1000 independent runs and report the average. We employ a balanced binary tree as the key tree. Each non-leaf node is assigned with two keys, i.e., a = 2. The length of each key is 64-bit, which is sufficiently long to resist brute-force attacks.</p><p>A fundamental concern upon SPA is the latency of key-updating. We use the metric Key-updating Latency as the time required for the reader to update a tag's keys to evaluate the performance of SPA. <ref type="figure" target="#fig_10">Figure 9</ref> plots the average key-updating latency of SPA. With the increase of the tag accessing frequency, which means how many times a tag is accessed per second, the key-updating latency increases. The processing speed of SHA-1 is 1.73 MByte per second. We find that the latency of key-updating does not exceed 1.7ms even when the tag accessing frequency approaches 10. Since we construct a tree with the depth of 20 in this experiment, each tag is assigned with 20 keys. Thus, the curve of key-updating is enclosed within two lines: one represents the upper bound (20 keys in a tag are updated) and another represents the lower bound (only one key is updated). The short keyupdating latency of SPA enables a reader to support dense access patterns. Due to page limitation, results from other experiments are not reported here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions</head><p>We proposed a privacy-preserving authentication protocol, SPA, to support secure and efficient tagreader transactions in RFID systems. By using a dynamic key-updating algorithm, SPA enhances the security of existing RFID authentication protocols. SPA is lightweight with high authentication efficiency: a reader can identify a tag within O(logN) tree walking steps. Compared with previous works, SPA can effectively defend against both passive and active attacks.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 . A binary key tree with eight tags.</head><label>1</label><figDesc>Figure 1. A binary key tree with eight tags.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Authentication Procedure in SPA. After receiving U, Reader R's operations are:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 . Tree-based identification. Figure 5 . Tree-based key-updating.</head><label>45</label><figDesc>Figure 4. Tree-based identification. Figure 5. Tree-based key-updating.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>, where l j s ( r j s ) represents the state whether the left (right) child of node j has updated its keys. When initializing the key tree S, 0 = = r j l j s s for all non-leaf nodes. At any time, if the key of node j's left (right) child is updated, SPA sets l j s ( r j s ) to 1. When R finishes key-updating, it sends a mes- sage, as shown in Fig. 3, and a synchro- nization message to T i . The former one is used by T i to authenticate R. The latter one includes the information of the levels on which the nodes have updated their keys in the key tree. Having received these messages, T i first verifies whether or not</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. A new tag T 5 joins the RFID system.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>For T 0 and T 1 , let 0 T O and 1 T O denote the sets of accessed oracles, respectively.uniformly at random, and then provides the oracles of the corresponding tag T b (if b = 0, T b = T 0 ; otherwise, T b = T 1 ) to A. For sim- plicity, we denote T b as T. A then accesses T's oracles. Let T O denote the set of accessed oracles of T. 4) Based on the results from 0 T O , 1 T O , and T O , A outputs a bit b'. If b'=b, A successfully distinguishes T 0 or T 1 from each other, hereby we say A succeeds and the protocol is broken; otherwise, A loses the game, which means the protocol is secure under A's attacks. In the model, we assume that A can access the oracles of 0 T O , 1 T O and T O in polynomial times. Since T 0 and T 1 are randomly chosen from uncompromised tags, if A can distinguish T 0 from T 1 (or vice versa), it means that A can track all tags in an RFID system.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Phase 3 .</head><label>3</label><figDesc>A calls oracles in 0 T O and 1 T O (except Re- veal oracle), and then obtains the results (note that A cannot compromise T 0 and T 1 ). Phase 4. C selects a bit } 1 , 0 { ∈ b uniformly at ran- dom, and then provides oracles in T O (denote T b as T) to A for accessing (except Reveal oracle). Phase 5. A calls oracles in T O (except Reveal oracle) and receives the results. Phase 6. A outputs a bit b'. If b'=b, A has success- fully distinguished T 0 or T 1 from the other; otherwise, A loses.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 Figure 8 .</head><label>78</label><figDesc>Figure 7. The compromising attack.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Key-updating latency of SPA.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>In the second round, upon request, T i generates a random number r 2function h on two inputs: a key k and a random number r. T i replies R with a mesbegins to identify T i .</head><label></label><figDesc></figDesc><table>(a nonce) and computes 
the sequence 

)) 
, 
( 
, 
), 
, 
( 
( 

1 
1 
0 

r 
k 
h 
r 
k 
h 

i 
d 

i 

… 

, where 
) 
, 
( r 
k 
h 
de-
notes the output of a hash -
sage U = 
)) 
, 
( 
, 
), 
, 
( 
, 
( 

1 
1 
0 
2 

r 
k 
h 
r 
k 
h 
r 

i 
d 
i 

… 
. For simplicity, we 

denote the elements in U as 

d 

v 
v 
u 
, 
, 
, 0 … . Upon U, R 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>extends the path of T i originated from the root by invoking Algorithm 1. Suppose the path reaches an intermediate node j at level l (</head><label></label><figDesc></figDesc><table>). Having the results, the 
reader compares them with received 
) 
, 
( 1 
1 r 
k 
h i 
, If 

) 
, 
( 1 
1 r 
k 
h i 
is equal to the result computed from k 1, 1 (or 
tk 1, 1 ), the tag belongs to the left sub-tree; otherwise, it 
belongs to the right sub-tree. 
Level by level, R d 
l ≤ 
≤ 
1 
) 
in the tree. At this point, R computes all hash values 
) 
, 
( 

1 

1 r 
k 
h l+ 
and 
) 
, 
( 

1 

1 r 
tk 
h l+ 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>. A has compromised tags T 3 , T 5 , and T 8 .}. Let t i be the number of keys in i K , and</head><label></label><figDesc></figDesc><table>In this case, for sub-tree S 1 , 2 
K = { 

4 
, 
2 
3 
, 
2 
2 
, 
2 

, 
, 
k 
k 
k 

} and 

2 

U = { 1 

, 
2 

k </table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Rf Code</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Inc</surname></persName>
		</author>
		<ptr target="http://www.rfcode.com/products" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Adversarial Model for Radio Frequency Identification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Avoine</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Reducing Time Complexity in RFID Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Avoine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Dysli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Oechslin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SAC</title>
		<meeting>SAC</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A Lightweight RFID Protocol to Protect Against Traceability and Cloning Attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Dimitriou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SecureComm</title>
		<meeting>SecureComm</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A Secure and Efficient RFID Protocol that Could make Big Brother (partially) Obsolete</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Dimitriou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE PerCom</title>
		<meeting>IEEE PerCom</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A Cryptanalytic Time-Memory Tradeoff</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E</forename><surname>Hellman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<date type="published" when="1980" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Minimalist Cryptography for Low-Cost RFID Tags</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Juels</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SCN</title>
		<meeting>SCN</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">RFID Security and Privacy: a Research Survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Juels</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
	<note>to appear in IEEE Journal of Selected Areas in Communication</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A Scalable, Delegatable Pseudonym Protocol Enabling Owner-ship Transfer of RFID Tags</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Molnar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Soppera</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SAC</title>
		<meeting>SAC</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Privacy and Security in Library RFID: Issues, Practices, and Architectures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Molnar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM CCS</title>
		<meeting>ACM CCS</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">LANDMARC: Indoor Location Sensing Using Active RFID</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">M</forename><surname>Ni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">C</forename><surname>Lau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Patil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE PerCom</title>
		<meeting>IEEE PerCom</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Efficient Hash-Chain based RFID Privacy Protection Scheme</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ohkubo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Suzuki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kinoshita</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of UbiComp, Workshop Privacy</title>
		<meeting>UbiComp, Workshop Privacy</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Trust Context Spaces: an Infrastructure for Pervasive Security in Context-Aware Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Robinson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Beigl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SPC</title>
		<meeting>SPC</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Security and Privacy Aspects of Low-Cost Radio Frequency Identification Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Weis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sarma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Engels</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SPC</title>
		<meeting>SPC</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
