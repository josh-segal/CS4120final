<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:30+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Understanding Transactional Memory Performance</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donald</forename><forename type="middle">E</forename><surname>Porter</surname></persName>
							<email>porterde@cs.utexas.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">The University of Texas at Austin</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emmett</forename><surname>Witchel</surname></persName>
							<email>witchel@cs.utexas.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">The University of Texas at Austin</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Understanding Transactional Memory Performance</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Transactional memory promises to generalize trans-actional programming to mainstream languages and data structures. The purported benefit of transactions is that they are easier to program correctly than fine-grained locking and perform just as well. This performance claim is not always borne out because an application may violate a common-case assumption of the TM designer or because of external system effects. This paper carefully studies a range of factors that can adversely influence transactional memory performance. In order to help programmers assess the suitability of their code for transactional memory, this paper introduces a formal model of transactional memory as well as a tool, called Syncchar. Syncchar can predict the speedup of a conversion from locks to transactions within 25% for the STAMP benchmarks. We also use the Syncchar tool to diagnose and eliminate a starvation pathology in the TxLinux kernel, improving the performance of the Modified Andrew Benchmark by 55% over Linux. The paper also presents the first detailed study of how the performance of user-level transactional programs (from the STAMP benchmarks) are influenced by factors outside of the transactional memory system. The study includes data about the interaction of transactional programs with the architecture, memory allocator, and compiler. Because many factors influence the performance of transactional programs, getting good performance from transactions is more difficult than commonly appreciated.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Transactional memory <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b13">14]</ref> is a promising paradigm to simplify concurrent programming. Transactions relieve the programmer from worry about deadlock, making it easier to code correctly. However, most real-life programs need to be both correct and efficient, and the introduction of transactions to an application can have negative, counterintuitive consequences for performance. Based on several years' experience working with transactional memory, this paper analyzes a range of issues that lead to performance problems in transactional applications, with a focus on helping developers and applications transition from using locks to transactions. Designers of transactional memory systems make implementation decisions based on an implicit model of commoncase application behavior. For instance, TM designs often trade faster commits for slower aborts, and as a result applications with high-contention transactions can perform much worse than with locking. In many cases, application data structures can be reorganized to improve transactional performance, but these opportunities are not necessarily obvious upon inspection of the code. Thus, it is important for developers to have tools that help them to diagnose and to correct performance problems.</p><p>To help developers characterize and tune the performance of transactional programs, this paper develops and validates Syncchar, or synchronization characterization, a formal model of transactional memory performance and a tool based on the model. The Syncchar model starts with a lock-based or transactional parallel application and samples the sets of addresses read and written during critical sections. It then builds a model of the program's execution that can predict the performance of the application if it used transactions. The model has two key metrics, data independence and conflict density of the critical regions. Data independence measures the likelihood that threads will access disjoint data. Conflict density measures how many threads are likely to be involved in a data conflict should one occur. Because most large-scale parallel applications use locking, a key use for the Syncchar model is identifying which applications could benefit from using transactions before investing the engineering effort to make such a conversion.</p><p>The Syncchar model is approximate, but useful, both for the critical regions that it predicts will be performance problems and for those that it predicts will perform well. Programmers can focus time reorganizing code in critical regions that will serialize when using transactions. Working with a performance model helps programmers tune transactional performance, which requires different intuitions from tuning lockbased code. For instance, common lock-based programming techniques, such as walking a linked list or incrementing a shared counter inside a critical region, can reduce transactional performance.</p><p>This paper also presents a case study of performance tuning the TxLinux kernel <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b30">31]</ref>. TxLinux is a version of the Linux kernel converted to use hardware transactional memory. This study demonstrates the often counterintuitive nature of tuning transactional performance and how Syncchar analysis can help focus the tuning effort.</p><p>Performance problems for transactional applications can also arise from the interaction of the TM system with unrelated portions of the system. For instance, compiler optimizations that avoid branches on a deeply pipelined processor can dramatically increase the conflict rate for a critical region. These issues are difficult for the application developer to anticipate and to debug. Ultimately, these issues must be resolved with better integration of the TM implementation with the rest of the system stack, but the Syncchar tool can help developers assess whether their code needs tuning or a performance problem is attributable to system effects.</p><p>This paper is the first to present data on how the system influences the performance of user-level transactional programs. The paper discusses the effect of various factors on performance, including the input size, architectural features, standard libraries and the compiler. This paper contributes the following: 1) A new analytic model that predicts how application performance will scale with transactions. 2) Experimental validation of the analytic model, characterizing the performance of workloads from the STAMP benchmark suite <ref type="bibr" target="#b19">[20]</ref> with an average error rate of 25%. 3) Detailed measurements and case studies of whole-system HTM behavior, including architectural effects, the memory allocator, and the compiler. 4) A case study of performance tuning the TxLinux kernel, in which we improve the performance of the Modified Andrew Benchmark at 8 CPUs by 55% relative to unmodified Linux. This paper describes the need for a transactional memory performance prediction and tuning tool (Section II). The paper then presents novel techniques and a tool for investigating the potential of transactional memory, through measuring data independence and conflict density of critical regions protected by the same lock. (Section III). Next, the paper validates the model with a set of microbenchmarks and the STAMP benchmark suite (Section IV). The paper then presents detailed measurements and case studies of system effects on transactional memory performance (Section V). Finally, the paper applies the methodology and tools to tune the performance of the TxLinux kernel <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b30">31]</ref> (Section VI). Section VII describes implementation details of the Syncchar tool, Section VIII presents related work, and Section IX concludes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. TUNING TRANSACTIONAL PERFORMANCE IS DIFFICULT</head><p>Understanding and tuning transactional performance requires different skills and intuitions from tuning lock-based concurrent code because the factors that influence performance are different. Tuning the performance of lock-based programs generally involves identifying highly contended locks and breaking them down into smaller locks, or restructuring the data to avoid synchronization (e.g., per-thread data structures and read-copy update <ref type="bibr" target="#b18">[19]</ref>). Tuning transactions, on the other hand, requires a reduction in conflicting memory operations (concurrent transactions writing the same data). Although there are some known techniques for avoiding memory conflicts, the process can be difficult and counterintuitive.</p><p>Many transactional memory implementations also have substantial limitations that complicate a conversion from locking to transactions. For instance, HTM systems that use cache coherence either require that the address set of a transaction fit in the L1 cache or fall back on a software-based mutual exclusion mechanism. TM systems also have difficulty isolating and rolling back the effects of system calls inside of a transaction. While many transactional applications can work around the limits of a TM implementation in practice, these issues can make adoption of transactions more complicated than a rote replacement of locks with atomic blocks.</p><p>Given these challenges to adopting transactional memory, a predictive performance model such as Syncchar can help developers assess whether a migration to transactional memory is worth the investment. Syncchar is also useful as a standard profiling tool for transactional applications, giving developers insight into which code is most likely to become a scalability bottleneck.</p><p>If performance of a converted system does not meet expectations, Syncchar can help assess whether the problem lies within the application or the transactional memory implementation. As we show in Section V, many parts of the overall computer system can affect the performance of a transactional program. The transactional memory programming community can also benefit from a predictor of performance in developing standard benchmarks for transactional memory implementations and reasoning about the performance of a particular system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Transaction tuning = lock tuning</head><p>A common optimization in lock-based programming is caching attributes, such as the number of elements in a data structure. Caching attributes saves work when they are needed, and updating them introduces no synchronization overhead under locking, since the lock protecting the data structure is already held when the data structure is updated. With transactional memory, however, multiple threads updating the same memory location serialize concurrent execution. Cached attributes can be particularly prone to becoming a bottleneck because of the work wasted on a transaction restart. If updates are made late in the critical section and if values are read early in others, the work lost on a transaction restart increases further.</p><p>Splitting counters that cannot be eliminated into per-thread counters avoids conflicts on counter writes, but introduces conflicts on reads, as each CPU's value must be read to provide a correct sum. Per-thread counters thus work well if they are updated more frequently than they are read, but are pointless otherwise.</p><p>Linked lists are commonly used as a generic container because they are simple to implement, have a low memory overhead, and don't have problems with resizing. Linked lists, however, can be pathologically bad for transactional memory, because each thread traverses the exact same pointer path inside a critical region. Any pointer update will conflict with all other critical regions that have walked further down the list, despite the fact that concurrent execution of the operations is semantically safe.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. System effects</head><p>Transactional programs are influenced by the program input size, hardware architecture, operating system, and sometimes the memory allocator and the compiler. Each subsystem can affect performance, and their interplay can also be significant.</p><p>For instance, the responsiveness of the operating system scheduler can lead to load imbalance or failure to concurrently schedule transactional threads. Poor scheduling can cause traditional transaction metrics, like restart rate, to improve despite worsening execution time. Similarly, limitations of a hardware system, such as overflowing the cache or taking a TLB miss, can cause a transaction to restart and fall back on a slower software path. These effects are often difficult to predict by code inspection.</p><p>Despite a seemingly straightforward appearance, tuning the memory access patterns of a transactional program can be subtle and non-intuitive. Even simple rules, like splitting counters shared by threads into per-thread counters, can be pointless or counterproductive when applied by rote. In a large, complicated system, programmers will need tools like Syncchar to identify where their tuning efforts are best spent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. THE SYNCCHAR MODEL</head><p>The Syncchar model formalizes the intuition that transactional performance is primarily determined by the number of conflicting transactions, and provides the basis for the Syncchar performance tuning tool. This section explains the intuitions behind the Syncchar model and provides a rigorous treatment of how the model predicts transactional performance based on sampling the address sets of dynamic critical regions from a parallel execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Syncchar approach</head><p>Assessing the likelihood that dynamic instances of critical regions will conflict is at the heart of the Syncchar approach. The performance scalability of a transactional memory program hinges on the number of critical sections that can execute concurrently.</p><p>Transactional memory systems generally rely on conflict serializability as their safety condition, implemented as an abstract form of two-phase locking <ref type="bibr" target="#b29">[30]</ref>. We call the set of addresses read during an instance of a critical section the read set, the set of addresses written the write set, and the union of read and write set the address set. For critical sections A and B, A conflicts with B if: A W ∩ (B R ∪ B W ) = ∅. Informally, conflict serializability says that the write set of one critical region must be disjoint from the other's address set to guarantee safety. Conflict serializability is efficient to compute so it is used widely in transactional memory systems.</p><p>A group of critical region executions are data independent if each write set is disjoint from the others' address sets. If critical regions concurrently modify the same data, or have data conflicts 1 , the transactional memory system will serialize execution of the critical sections. In such cases, transactional memory can perform much worse than conservative locking due to the overhead required to detect and to resolve conflicts.</p><p>Conflict density is a measure of how long the serial schedule resulting from a conflict is likely to be. Assume a conflict among N threads. In the best case, a single thread might write a datum read by N − 1 other threads. This is a low density conflict that produces a short serialized execution schedule (N − 1 readers commit, and then the writer). In the worst case, each thread can write a datum written by each of the other N − 1 threads, yielding a high density conflict that necessitates a completely sequential schedule (the threads must run serially, one after the next).</p><p>Syncchar estimates the data independence and conflict density of critical regions by sampling their address sets. Syncchar samples address sets of critical regions that could potentially execute concurrently using transactional memory and determines which of them can conflict. This process, described in detail below, is effectively an implementation of the safety property of the TM system. Sampling incorporates the dynamic behavior of the application and its potential data conflicts.</p><p>A similar model was developed by von Praun et al. <ref type="bibr" target="#b35">[36]</ref>, which calculates the dependence density of an application and broadly categorizes tasks within a program as low, medium, and high concurrency. Dependence density is essentially an aggregation of data independence and conflict density; our experience shows that this decomposition provides valuable insight into performance debugging. Syncchar closes the loop by making more concrete performance predictions (Section IV), and providing insights into performance tuning applications (Section VI). Section VIII provides additional comparison between these papers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Data independence</head><p>Data independence provides a high-level profile of the likelihood that a set of critical regions will conflict. The data independence of a lock, I n , is formally defined as the mean number of threads that will not conflict when n threads are concurrently executing critical sections protected by the same lock. Data independence is a function of the number of threads that can execute concurrently, and not a simple mean. Intuitively, one expects the probability of conflict when only a single thread is scheduled to be zero (data independence of 1), and the likelihood of conflict to increase as the number of threads grows (unless all threads access completely disjoint data).</p><p>Thus, when Syncchar calculates data independence for n CPUs, it begins with a sample of critical regions from up to n different threads. Syncchar then compares each address set in the sample to all other address sets in the sample, determining which threads are involved in a conflict C n and which are not. It keeps a running mean of the number of data independent threads:</p><formula xml:id="formula_0">I n = n − |C n | C. Conflict density</formula><p>The key metric in the Syncchar model is the density of the conflicts. A set of critical regions with high conflict density will be prone to conflicts that involve many threads and form a long serial schedule, whereas low density conflicts can be resolved more quickly.</p><p>If one thinks of conflicts as forming a graph, with critical regions as nodes and conflicts as edges, the density of the conflict is the number of edges per node. Intuitively, if every transaction conflicts with every other, one expects them to execute sequentially, which means lower performance for transactional memory. On the other hand, if for example, one thread writes a memory location read by 31 other threads, all readers should complete once the writer completes, resulting in a performance gain that is commonly experienced in practice. This scenario would have a star topology if represented as a graph; removing the most connected node causes all others to become disconnected (and able to proceed concurrently). Hence, modeling this phenomenon is crucial to the accuracy of predicting performance.</p><p>Syncchar calculates the conflict density of a sample of address sets as follows. For each address set in C n , we measure the number of conflicts with other address sets in C n and divide it by (|C n | − 1). The sum of each of these terms is the density (D n ). Formally, this is expressed as</p><formula xml:id="formula_1">D n = x∈Cn y∈{Cn−x} conflicts(x, y) |C n − x|</formula><p>where conflicts(x, y) evaluates to 1 if address sets x and y can conflict and 0 otherwise. In the case where all conflicting address sets conflict with all others, the density equals the size of the conflicts (D n == |C n |). In the star topology case, D n should equal 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Predicting transactional performance</head><p>The intuition behind our approach to predicting transactional performance is that performance will be limited by the serial schedule transactions must form to ensure correctness. In the Syncchar model, this is the conflict density. In the common case, the speedup of n threads concurrently executing a set of transactions is expressed as n max <ref type="bibr">(Dn,1)</ref> . When used with a lock-based parallel program, Syncchar tracks both the acquisition time (acq) for a lock and the length of a critical region after the lock is acquired (held), as well as unrelated cycles other. According to Amdahl's law, the overall speedup obtained from concurrent execution of a critical section is constrained by the amount of time spent in that section. Thus, the speedup term above is applied only to the cycles spent acquiring or holding a lock, leaving the unrelated cycles (other) unaffected by transaction behavior. Formally, then, our calculation becomes:</p><formula xml:id="formula_2">Execution Time = (acq + held) * max(D n , 1) n + other</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Limitations</head><p>Like any model, Syncchar makes certain simplifying assumptions that balance complexity against accuracy. Bobba et al. <ref type="bibr" target="#b3">[4]</ref> provide an analysis of performance pathologies for various hardware transactional memory designs. In our experience working with an eager/eager HTM implementation, the most common deviation from the Syncchar model is that HTM can perform substantially worse than locking under high contention. This can be attributed to a number of factors, including restart costs, suboptimal back-off policy, and bus contention. Ideally, when a transaction is restarted to resolve a conflict, it will retry execution as soon as the winner of the conflict commits. In an HTM with a high restart cost or a high back-off, there may be a period of needless latency after the winner commits and before the losing transaction resumes, lowering transaction throughput. In the worst case, this can lead to a conflict with a new transaction. On the other end of the spectrum, a back-off policy that retries too quickly can increase contention for cache lines and the memory bus, degrading system performance. A goal of our model is generality, so we have avoided including implementation-specific parameters in our model, as these contention pathologies can vary widely across HTM implementations. <ref type="figure" target="#fig_0">Figure 1</ref> shows the execution time of a simple microbenchmark at 8 CPUs, where critical regions write to a shared variable with a configurable probability, with the probability ranging from 0 to 100. The Tx line crosses the Lock line between a probability of 80 and 90. This leads to deviation in the accuracy of the Syncchar model beginning at about 60% probability of dense conflicts. Syncchar correctly identifies that transactions will give little to no performance improvement as contention increases, but it cannot predict how poorly a given HTM will perform.</p><p>The Syncchar model might also underestimate performance. An application that has a freqently executed critical region that is also highly data independent will have excellent TM performance, but might experience lock contention. Threads using locks mutually exclude even if a critical region is data independent. In such a case, a more accurate prediction may be realized by dropping the acq cycles and only applying the speedup term to the held cycles. Rather than apply heuristic weights to the acq cycles, we leave the issue for future work and use a more approximate prediction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. MODEL VALIDATION</head><p>In this section we validate the Syncchar model by implementing it as a module for Virtutech Simics <ref type="bibr" target="#b16">[17]</ref> and comparing the predicted performance with transactions to the measured performance on an HTM model. We validate the Syncchar model against seven benchmarks from STAMP version 0.9.9, listed with input parameters in <ref type="table" target="#tab_0">Table I</ref>. All experiments in this and the following sections are performed modeling 8, 16, and 32 1GHz, x86 processors. As Simics supports only a fixed IPC, bayes Learns a randomly generated bayesian network. -v32 -r4096 -n5 -p30 -s1 -i2 -e4 genome Reconstructs a larger gene sequence from segments of the gene. -g16384 -s48 -n4194304 intruder Emulates a network intrusion detection system; transactionalizes the packet capture and reassembly phases. -a10 -l32 -n65216 -s1 kmeans Implements the K-means clustering technique. -m40 -n40 -t0.0009 -i random-n65536-d32-c16.txt ssca2</p><p>Scalable Synthetic Compact Applications 2, kernel 1. Constructs a graph data structure using adjacency and auxiliary arrays. -s17 -i1.0 -u1.0 -l3 -p3 vacation Implements a travel reservation system. Transactions protect updates to a local database implemented with a red-black tree. -n4 -q60 -r1048576 -u90 -t1048576 yada Ruppert's algorithm for Delaunay mesh refinement, similar to Kulkarni et al. <ref type="bibr" target="#b12">[13]</ref>. -a20 -i ttimeu10000.2 the simulations used an IPC of 1, which is a reasonable choice for a moderate superscalar implementation. Each processor has a 32 KB, 4-way set associative private L1 cache with 64 byte lines and an access time of one cycle. L2 caches are also private with 64 byte lines. Each L2 cache is 4MB, 8-way set associative. L2 cache accesses cost 16 cycles, and are kept coherent using a transaction-aware MESI snooping protocol. Our coherence model is implemented by the Simics txcache module <ref type="bibr" target="#b31">[32]</ref> . Main memory is a single, shared 1 GB, with an access time of 200 cycles. Each CPU has two 4-way set associative, 64 entry TLB's-one for instructions and one for data.</p><p>All lock-based experiments run on Linux version 2.6.16.1. We used the MetaTM hardware transactional memory model and TxLinux version 2.6.16.1 for the transactional memory experiments <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b30">31]</ref>. Main memory access latency is pseudorandomly perturbed by 0-4 ns to get accurate performance measurements for multi-threaded programs. Multi-threaded programs are sensitive to scheduling, so several randomly perturbed runs give a more accurate picture of performance, as described by Alameldeen and Wood <ref type="bibr" target="#b0">[1]</ref>. Measurements presented are a mean of 4 simulated executions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Predicting speedup for STAMP</head><p>We applied the Syncchar model to programs from the STAMP transactional memory benchmark suite <ref type="bibr" target="#b19">[20]</ref>. As we will discuss further in Section V-C, we do not use the labyrinth benchmark in any experiments due to a memory leak that we could not resolve. <ref type="table" target="#tab_0">Table II</ref> shows the predicted and actual execution times of the parallel phases of these benchmarks. The measured exeuction times are the mean of four runs, and the standard deviations are all within 5% of the mean, except for bayes, which has a variable number of transactions and standard deviations as high as 23% of execution time. The geometric mean error in our predictions across all benchmarks is 25%. Syncchar tracks the scalability trends very closely, both for high-contention workloads that have poor scalability, like intruder, and for lowcontention workloads that have good scalability, like kmeans. Syncchar's precision decreases as the benchmarks become very short, particularly for benchmarks that run for .3 seconds or less. In the worst cases, Syncchar predicts the scaling trends offset by a factor of 40-153%. Data independence and conflict density prove to be interesting metrics, with widely varying values across STAMP applications. Ssca2 is highly data independent, while the highcontention intruder is not. Bayes has very light conflict density while yada's conflicts are quite dense, with an average of nine densely conflicting threads per transactional conflict. <ref type="figure">Figure 2</ref> shows the projected speedup of a representative sample of benchmarks, broken down into the portion attributable to data independence and the portion attributable to low conflict density. The percent of the speedup attributable to data independence is the same as the fraction of critical regions that do not conflict, and the rest is attributable to low conflict density. The projection in <ref type="figure">Figure 2</ref> for ssca2, at one end of the spectrum, is entirely due to data independence. Like many transactional benchmarks, ssca2's critical regions rarely conflict, yielding good scalability and a substantial speedup over locking. On the other extreme, nearly every critical section in bayes is likely to conflict at least once, yet the measured speedup is still substantial because relatively few threads are involved in each conflict. Low conflict density is the key to bayes' scalability. Similarly, the kmeans benchmark has high The projected speedups of selected benchmarks using transactions versus locking, decomposed into the portion attributable to data independence and conflict density. data independence at moderate CPU counts, but increasingly relies on non-dense conflicts for its performance improvement at higher CPU counts. The kmeans benchmark shows a reasonable mix of both data independence and non-dense conflicts, which we expect to be the case with realistic workloads.</p><p>These experiments show that the Syncchar model strikes a good balance between accuracy and complexity. While there are outliers in the model's predictions, most are off by 26% or less, and all capture the scaling trends of the workload. These performance estimates can help the programmer understand a transactional program's performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Scheduling model and sampling</head><p>Syncchar measures data independence and conflict density by checking for conflicts between critical regions that are likely to be scheduled concurrently. This Subsection describes how Syncchar samples critical regions to detect conflicts. The Syncchar approach respects the schedule of the original execution, but generalizes it significantly to simplify the model. Syncchar records the address sets of critical regions within a sliding time window. After Syncchar has seen a certain number of critical regions from the same lock, it samples the desired number of critical regions and measures data independence and conflict density as if those critical regions were scheduled together. In our experiments, the sliding window consists of 512 critical regions, a value selected based on experimentation with different sizes. In selecting address sets to compare, Syncchar is careful to select only one address set per process. After calculating data independence and conflict density, the recorded address sets are discarded.</p><p>Limiting the number of address sets that Syncchar can consider concurrently captures many likely execution schedules with a simple concurrency model and implementation. For instance, a newly forked thread cannot execute concurrently with critical region executions that occurred before its creation. Syncchar's sliding window reduces comparisons between critical regions that cannot be scheduled concurrently due to some other synchronization mechanism, such as a join after a fork, without having an exhaustive scheduling model. Syncchar samples address sets to reduce the number of address sets recorded, improving the efficiency of the tool. In our previous experiments, we used a 100% sampling rate for the highest fidelity data. <ref type="table" target="#tab_0">Table III</ref> shows the data independence and conflict density measurements at a sampling rate of 10%, 25%, and 100%. A representative sample of benchmarks was selected; others were omitted for space. At 25%, measurements are within 8% of the exhaustive measurement. While there are some outliers at 10% sampling rate, the result is within 15% of exhaustive measurement for most benchmarks. Syncchar's insensitivity to sampling indicates that the algorithms are practical for resource-constrained systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. SYSTEM INFLUENCE ON TRANSACTION PERFORMANCE</head><p>In situations where a transactional application ought to perform well and does not, the problem may be poor interaction with the full system and the transactional memory implementation. This section analyzes situations where the system effects transactional performance of user-level programs, using 7 of the STAMP benchmark suite as a case study. distributed with simulator inputs, which are much smaller. Simulator inputs are much smaller than the kinds of inputs for which the programs were designed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Input size</head><p>As the table makes clear, the simulator inputs are too small to show accurate scaling trends. For example, performance for genome's simulator inputs does not scale at all for 32 CPUs while our larger inputs scale by 26×. Ahmdahl's law <ref type="bibr" target="#b1">[2]</ref> explains the problem. Even though the STAMP benchmarks only measure performance during the parallel parts of the code, the parallel section still includes serial setup. Some of the setup is implicit; for example, the OS must schedule all of the threads before they all execute. Because the parallel section is so short, the performance scaling of the simulator inputs does not reflect scaling on more realistic inputs. Also, the overhead of synchronizing at a barrier towards the end of the benchmark grows with higher processor counts.</p><p>While benchmark size and startup effects are a known problem for simulation <ref type="bibr" target="#b24">[25]</ref>, they continue to impede accurate measurement. We note that researchers can compensate for the brevity of the simulator inputs and still accurately calculate the gains in performance. Authors generally omit the details of how speedup curves are generated, so we could not verify that any particular methodology for measuring simulator inputs matches the scaling trends on non-simulator inputs. Unless otherwise noted, all STAMP data in this paper uses the "Big" inputs, listed in <ref type="table" target="#tab_0">Table I</ref>. <ref type="table" target="#tab_0">Table VI</ref> shows detailed breakdowns of the simulator inputs and our resized inputs. The most important result from the table is that common transactional metrics, like restart rate and average backoff, generally are a poor indicator of execution time. For instance, execution time and restart rate are correlated as CPU counts increase for intruder and bayes with the simulator inputs, but are inversely correlated for yada and vacation. This is appreciated by the transactional memory community, but the lack of good performance indicators is a serious problem for developers who must performance-tune transactional programs. Simple event counters or runtime statistics provide insufficient data on which to base performance tuning decisions.  Simply reducing restarts or backoff cycles might not affect performance. The actual dynamics are much more complicated. For instance, it might be more important to reduce the latency of the critical path of the computation than to reduce the restarts that occur off the critical path. The complexity of tuning transactional performance motivated us to develop the Syncchar model.</p><p>The table also shows that the idle time for some of the benchmarks is high, and noticeably higher for the simulator inputs. Load imbalance significantly affects the simulator inputs, causing unrealistic amounts of idle time. For instance, kmeans with big inputs has only 1% idle time at 32 processors, but it has 52% idle time for the simulated inputs. While the STAMP benchmarks are designed to minimize system time, several of them still spend up to 10% of their execution time in the operating system, mostly in memory management and page fault handling routines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. TLB Misses</head><p>We measure TLB miss rates within transactions in <ref type="table" target="#tab_5">Table V.</ref> TLB misses are very common within transactions. In fact, for almost every run of genome, ssca2 and vacation on big inputs, over 88% of transactions take at least one TLB miss. The TLB miss rates on the simulator inputs are generally lower because these inputs touch so little data that they do not establish the steady-state TLB miss rate of the application. Only for kmeans does the simulator TLB miss rate match the big inputs. It has only 3 brief critical regions.</p><p>Knowing that TLB misses will be common in transactional programs is important for hardware designers. The Sun Rock processor <ref type="bibr" target="#b5">[6]</ref> is reported to support HTM primitives, but it will not tolerate TLB misses during a transaction. Kmeans is a good fit for designs like the Sun Rock because it has a low TLB  miss rate, none of its three critical regions make function calls, and only one critical region contains any control flow at all (a loop). It is unknown if Azul Systems' HTM can tolerate a TLB miss <ref type="bibr" target="#b4">[5]</ref>. Architectures with a software reloaded TLB would likely require the TLB load sequence to run outside the context of the current transaction. Avoiding an abort of the current transaction for a TLB miss on these architectures might be challenging.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Memory allocation</head><p>Performing system calls, including memory allocation, within a transaction can violate isolation. While most memory allocators are mostly implemented at user level, they sometimes need to make system calls to get more memory from the OS (either mmap or sbrk), and they might make other system calls. This problem is well known <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b38">39]</ref>, and there are several ways to allow system calls within transactions, including open nesting <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22]</ref> and transactional pause <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b38">39]</ref>.</p><p>The STAMP benchmarks allocate memory and are not written with any special hooks to deal with allocation. A transaction can call the memory allocator, which calls the OS for more memory. Such a transaction can restart many times, leaking memory if there are no hooks for compensating actions on transaction restart. The labyrinth benchmark is missing from this paper because it pathologically leaks and cannot complete, and we have experienced pathological memory leaks in genome.</p><p>Surprisingly, memory allocation on a complete Linux environment can actually cause deadlock. Recent versions of glibc use a blocking lock to protect the memory allocator's data structures. This lock is implemented using the futex() system call <ref type="bibr" target="#b6">[7]</ref>, which can block the current thread until the lock is released. When a process releases a futex that has other threads waiting on it, it must trap into the kernel to notify the waiters. In the context of a hardware transaction, a transactional process can acquire the lock, a second can block on the lock, and then the transaction holding the lock restarts. The hardware releases the lock variable, but does not notify the kernel of the change and blocked threads can sleep indefinitely, effectively deadlocking the application. Many standard system libraries are written to be threadsafe and will still use locks, condition variables, and other synchronization mechanisms in a transactional memory application, potentially causing adverse effects.</p><p>We discovered this deadlock behavior in the vacation benchmark, which often allocates memory within transactions to insert a new node into its red-black tree. We work around the problem by conservatively preallocating all the memory a transaction might need before beginning a transaction. This ad hoc solution will not apply to general-purpose programming, especially in the presence of composing transactions with standard library routines. Calling standard libraries and system calls, such as futex, within a transaction will likely require a combination of new standard libraries <ref type="bibr" target="#b34">[35]</ref>, OS support <ref type="bibr" target="#b27">[28]</ref>, or a TM implementation-specific solution like making a single transaction non-speculative <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b11">12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Compiler effects</head><p>A final challenge for optimizing transactional code is compiler optimizations for deeply pipelined machines. <ref type="figure" target="#fig_2">Figure 3</ref> illustrates a simple conditional statement the programmer would expect to reduce conflicting accesses to a shared variable. Yet, the code generated by gcc always reads the value from memory and always writes it back. It only uses the condition to determine whether to update the register before writing it back. The compiler is trying to avoid branching around the if(a &lt; threshold) shared_variable = new_value;</p><p>;; edx holds a, 0xc03e6008 holds threshold ;; eax holds new_value, 0xc03e600c holds shared_variable cmp 0xc03e6008,%edx ;; compare a and threshold cmovge 0xc03e600c,%eax ;; conditionally load old value mov %eax,0xc03e600c ;; unconditionally store to ;; shared_variable  load and store, which makes sense on a superscalar platform. On a hardware transactional memory system, however, the performance lost to a coherence conflict is much larger than that lost to a mispredicted branch. For a critical section such as the one above, the Syncchar tool identifies it as having no data independence and flags the shared variable as a contention hot-spot. Counterintuitive results such as these hint to the programmer that the code generated by the compiler should be inspected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. SYNCCHAR AS A TUNING TOOL</head><p>In addition to predicting the performance of a transactional memory system, the Syncchar model can provide clues as to which critical sections are likely to have performance problems. This section demonstrates the utility of Syncchar for tuning transactional performance, using the (Tx)Linux 2.6.16 kernel as a case study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Tuning features</head><p>Syncchar provides a number of useful metrics for the transactional memory developer. Data independence and conflict density give the developer an indication of how much parallelism they can expect from the code. Syncchar reports the distribution of conflicting addresses in a critical region, allowing the developer to identify contention hot-spots.</p><p>Syncchar also provides statistics on the workset size as illustrated in <ref type="table" target="#tab_0">Table VIII</ref>, which can help developers identify critical regions that are likely to overflow the cache in a coherence-based HTM. Finally Syncchar provides traditional profiling metrics, such as the most frequently executed critical region and the most contended critical regions.</p><p>1) Asymmetric Conflicts: Conflicts between transactional and non-transactional threads are known as asymmetric conflicts <ref type="bibr" target="#b28">[29]</ref> and can introduce performance pathologies in transactional applications. In resolving asymmetric conflicts, the transaction must always restart because a non-transactional thread cannot be rolled back. In many TM implementations, if non-transactional accesses occur faster than transactions can commit, transactions are starved and the application can hang. Performance problems caused by asymmetric conflicts are difficult to diagnose and to resolve. Simple profiling can indicate in which transaction the program is spending too much time, but it cannot find the unrelated code that is starving the transaction with asymmetric conflicts. Even TM researchers with good intuition about transactional performance tend to scrutinize writes, yet a variable that is only read in a transaction can cause problems if it is frequently written outside of a transaction.</p><p>Syncchar helps developers by indicating critical regions and addresses that are prone to asymmetric conflicts. This is implemented by tracking reads and writes outside of critical regions and checking for conflicts with critical regions. For each critical region, Syncchar reports the percentage of address sets that conflict with the non-transactional address set, estimating the probability of an asymmetric conflict. In the next Subsection we use Syncchar to diagnose and to correct such a pathology in TxLinux.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. TxLinux case study</head><p>Rossbach et al. <ref type="bibr" target="#b30">[31]</ref> report comparable performance for locking and transactions for the TxLinux kernel. Transactions do not help performance because the locks in Linux 2.6 are already fine-grained, highly tuned, and because several benchmarks spend relatively little time in the kernel. The primary exception was the bonnie++ filesystem benchmark, which shows severely pathological behavior under transactions. We reproduced this pathology and used simple program counter profiling to indicate that most of the time was being spent in the ext3 journaling code, protected by the journal_t.j_state and journal_t.j_list locks. We then used Syncchar to provide additional insight into the problem by sampling these critical regions by running bonnie++ on unmodified Linux. <ref type="table" target="#tab_0">Table VIII</ref> shows the distribution of conflicting addresses for these journal locks. These critical regions tend to be short-13 and 33 words in the working set, respectively. They have relatively high conflict density, indicating that there is temporal locality in the data accessed within these critical regions, but no one "hotspot" address. This matched our initial experience in auditing the journal code, as we found no immediately obvious datum causing the high transaction restarts.</p><p>The red flag Syncchar raised for these critical regions was that they had a 92% probability of an asymmetric conflict. Upon further review, we found an assertion in the code that a bit in the buffer_head.b_state field is set. This bit is used as a spinlock and always set before entering the critical regions that were converted to transactions. Moreover, other bit fields in the same byte are used by non-transactional tasks such as journal writeback. Interestingly, these bits are not modified inside a transaction, so the intuitive approach of looking for conflicting writes inside a transaction is not enough. Developers need tools to help find these sorts of bugs in a large code base.</p><p>We addressed the problem by converting the bit spinlock to a cooperative transactional spinlock (cxspinlock) <ref type="bibr" target="#b30">[31]</ref>. A cxspinlock uses transactions optimistically, but can fall back on locking to mutually exclude I/O. Cxspinlock acquisition is arbitrated by the HTM contention manager, so locks and transactions can fairly contend for a critical region. By using cxspinlocks and separating this bit into its own word (or cache line, depending on the HTM conflict granularity), we were able to eliminate the asymmetric conflicts that were starving the transaction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Experimental results</head><p>To evaluate these optimizations, measurements of 8, 16, and 32 CPU systems were taken as described in Section IV. Because TxLinux simply idles when left undisturbed, we need a set of parallel applications to exercise the concurrency within the TxLinux subsystems, such as the file system and memory allocator. We used the full suite of 6 benchmarks from the TxLinux paper <ref type="bibr" target="#b30">[31]</ref> and verified that our optimizations did not introduce any performance regressions. For the sake of space, we only report the two benchmarks with improved performance, listed in  Our optimization allows bonnie to complete, and also improves the performance of MAB. For other workloads, including MAB at 32 CPUs, the journal locks did not affect execution time substantially, and the performance remains flat. At this CPU count the performance bottleneck shifts from the journal spinlocks to other critical regions in the kernel. This demonstrates that our optimizations do not introduce regressions or other performance anomalies for other workloads.</p><p>The bit spinlock optimization also improves the performance of TxLinux relative to unmodified Linux at 8 and 16 processors, as shown in <ref type="figure" target="#fig_3">Figure 4</ref>. Tuning TxLinux 2.6 with programmer intuition and simple profiling has yielded marginal (&lt; 10%) improvement over Linux, but Syncchar led us to the fix for the bonnie++ pathology and sped up MAB by over 50%.</p><p>This case study indicates that tuning the performance of transactional memory applications can be tricky and nonintuitive, as the cause for a given critical region dominating execution time can be in an entirely different part of the application. Programmers facing this challenge will benefit from tools that help them understand their system with quantitative rigor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. IMPLEMENTATION DETAILS</head><p>This section describes key implementation details and features of the Syncchar tool, which can be used to performance tune applications as complex as the TxLinux kernel <ref type="bibr" target="#b30">[31]</ref> (Section VI).</p><p>The Syncchar prototype is a module for the Simics fullsystem, execution-driven simulator <ref type="bibr" target="#b16">[17]</ref> that generates output that is post-processed. By implementing Syncchar in the machine simulator, it is able to measure user-level code and the operating system. Nearly all instrumentation is performed using simulator breakpoints, which are performance transparent and minimally affect the execution behavior of the program being tested.</p><p>The requirements of the Syncchar model are modest enough that it could be implemented for user-level applications using a binary instrumentation tool such as Pin <ref type="bibr" target="#b15">[16]</ref>, or in a virtual machine monitor for kernel instrumentation on a live machine.</p><p>When tracking the address set of a critical region in lockbased code, Syncchar ignores reads and writes to lock variables, as locks would be removed in a transactional version of the application. Similarly, because stack addresses are generally private, Syncchar filters stack addresses to avoid conflicts due to reuse of the same stack address in different activation frames.</p><p>Syncchar needs to know about dynamically allocated lock variables. If an object containing a lock is freed and reallocated, it is treated as a new lock. In our current implementation, this information is communicated to Syncchar through annotations to the lock initialization routines.</p><p>Many locking implementations, including spin locks, do not ensure fairness and are more susceptible to load imbalance in parallel programs than transactional memory, which can have sophisticated contention management policies <ref type="bibr" target="#b32">[33]</ref>. Syncchar accounts for this effect in its predictions by discarding idle cycles at the end of a benchmark when there is gross load imbalance; in practice, one might use predictions with and without these cycles to establish a range for the performance prediction.</p><p>Finally, some spinlocks in the Linux kernel protect against concurrent attempts to execute I/O operations, but do not actually conflict on non-I/O memory addresses. When run on the Linux kernel, Syncchar detects I/O operations, and marks those critical regions as performing I/O. This annotation ensures that these critical regions will not be incorrectly reported as non-conflicting.</p><p>VIII. RELATED WORK There is very little published about performance tuning transactional programs. However, there is a large body of work about tools used to debug and to performance tune lockbased concurrent programs <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b37">38]</ref>. These tools are similar to Syncchar in that they use a runtime system to track locking and data access patterns, but are different in their analysis goals. The collected information is used to identify possible data race conditions rather than data independence and conflict density.</p><p>In previous work <ref type="bibr" target="#b26">[27]</ref>, we introduce the definition of data independent critical sections and a tool for measuring data independence of critical regions. This paper substantially modifies the data independence metric to be more practical (both in measurement and utility), introduces the new metric of conflict density, and provides empirical evaluation of its application to prediction and tuning.</p><p>Von Praun et al. <ref type="bibr" target="#b35">[36]</ref> provide a definition of dependence density that is similar to the aggregation of data independence and conflict density under Syncchar. Von Praun focuses on programs that apply similar operations to large data sets and provides a coarse classification of the workloads. They do not use the results of their model to predict speedups, and do not report any experience using the result of their model to tune the measured programs. Syncchar closes the loop by generating and validating performance predictions from its model. Further, decomposing data independence and conflict density provides more insight into tuning the behavior of real-world applications with irregular parallelism, such as the Linux kernel.</p><p>Heindl and Pokam <ref type="bibr" target="#b9">[10]</ref> present a framework for analytical performance modeling of STM implementations. The focus of the work is on assessing the performance impact of certain STM design decisions, such as lazy versus eager conflict detection or version management. To this end, they make certain simplifying assumptions about the general behavior of workloads, such as all transactions are the same length and all data are equally likely to cause conflicts (i.e., no contention "hotspots"). In contrast, the Syncchar model is designed to help TM users understand if and how their particular workload deviates from the common-case assumptions of the TM designer. For instance, many workloads have data that create contention hotspots, which may be tuned to improve performance.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Performance of locks vs. transactions for a microbenchmark over a range of probabilities of conflict. The Syncchar line illustrates how the model loses prediction precision, but correctly identifies the performance trend at high contention due to implementation-specific effects in the HTM.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Fig. 2. The projected speedups of selected benchmarks using transactions versus locking, decomposed into the portion attributable to data independence and conflict density.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. A simple code sequence and the annotated x86 assembly produced by gcc. bonnie++ Simulates file system bottleneck activity on Squid and INN servers stressing create/stat/unlink. 32 instances of: bonnie++ -d /var/local -n 1 MAB File system benchmark simulating a software development workload[23]. Runs one instance per processor of the Modified Andrew Benchmark, without the compile phase.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Speedup of unmodified TxLinux and our optimized version of TxLinux (TxLinux-Opt) over unmodified Linux for the MAB benchmark at 8, 16, and 32 CPUs (larger is better).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>TABLE I DESCRIPTION OF THE BENCHMARKS USED IN SECTIONS IV AND V, FROM THE STAMP BENCHMARK SUITE [20]. WE INCLUDE OUR CUSTOM INPUT PARAMETERS FOR REFERENCE, AS WE COMPARE WITH THE DEFAULT</head><label>I</label><figDesc></figDesc><table>PARAMETERS IN SECTION V. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>TIME IN SECONDS FOR THE STAMP BENCHMARKS IN SECONDS (LABELED TX), THE PROJECTED EXECUTION TIME IN SECONDS, LABELED SYNCCHAR, AND ACCURACY (% ERROR). DI IS THE DATA INDEPENDENCE VALUE FOR THE BENCHMARK AND CD IS THE CONFLICT DENSITY. 8 CPU BAYES DATA WAS NOT AVAILABLE AT THE TIME OF SUBMISSION.</head><label></label><figDesc></figDesc><table>Workload 
Tx 
Syncchar % Err 
DI 
CD 
bayes 
8 CPU 
-
-
-
-
-
16 CPU 
.29 
.29 
0 
0.00 
3.10 
32 CPU 
.20 
.15 
25 
0.21 
3.39 
genome 
8 CPU 1.35 
1.11 
19 
5.89 
0.01 
16 CPU 
.79 
.94 
16 11.44 
0.04 
32 CPU 
.50 
.84 
40 28.40 
0.13 
intruder 
8 CPU 1.06 
1.52 
43 
2.20 
2.72 
16 CPU 
1.33 
1.63 
22 
2.60 
4.51 
32 CPU 
1.67 
1.72 
3 
2.68 
8.45 
kmeans 
8 CPU 7.72 
8.69 
13 
5.28 
1.98 
16 CPU 
4.40 
5.98 
37 
8.43 
2.92 
32 CPU 
3.05 
3.06 
1 11.93 
4.19 
ssca2 
8 CPU 
.64 
.64 
13 
7.98 
0.00 
16 CPU 
.40 
.36 
13 15.94 
0.00 
32 CPU 
.27 
.21 
11 31.94 
0.01 
vacation 
8 CPU 1.39 
1.16 
17 
5.03 
.90 
16 CPU 
.72 
.53 
26 
6.92 
1.74 
32 CPU 
.39 
.21 
46 
7.70 
3.18 
yada 
8 CPU 
.38 
.39 
26 
4.76 
2.51 
16 CPU 
.21 
.37 
19 
7.94 
4.71 
32 CPU 
.15 
.37 
153 15.44 
9.43 

TABLE II 
THE EXECUTION </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table IV comparesFOR THE PARALLEL PHASE OF A SELECTION OF STAMP BENCHMARKS RELATIVE TO 1 CPU WITH THE STANDARD SIMULATOR INPUTS AND BIG INPUTS.</head><label>IV</label><figDesc>the speedup for STAMP benchmarks for different input sizes. Because detailed HTM simulation infrastructures tend to be slow, the STAMP benchmarks are</figDesc><table>Workload 

8 CPU 16 CPU 
32 CPU 
bayes 
sim 
3.9 
3.9 
3.5 
big 
3.3 
3.0 
4.3 
genome 
sim 
1.3 
1.3 
1.1 
big 
7.3 
14.5 
26.7 
intruder 
sim 
1.4 
1.4 
1.2 
big 
2.4 
1.9 
1.5 
kmeans 
sim 
5.1 
5.0 
5.5 
big 
7.5 
13.0 
18.9 
ssca2 
sim 
0.9 
1.0 
1.2 
big 
2.3 
3.8 
5.5 
vacation sim 
1.1 
1.4 
1.4 
big 
7.0 
12.1 
18.9 
yada 
sim 
2.8 
3.5 
3.9 
big 
3.0 
4.8 
7.0 

TABLE IV 
THE SPEEDUP </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>TABLE V TOTAL TLB MISSES IN TRANSACTIONS FOR OUR BENCHMARKS AT 8, 16, AND 32 CPUS, AND THE NUMBER AND PERCENT OF TRANSACTIONS THAT INCUR AT LEAST ONE TLB MISS OVER THE COURSE OF THEIR EXECUTION.</head><label>V</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>TABLE VI THE EXECUTION TIME (TOTAL) FOR SELECT STAMP BENCHMARKS USING BIG AND SIMULATED INPUTS, BROKEN DOWN INTO USER, SYSTEM,</head><label>VI</label><figDesc></figDesc><table>AND IDLE 
TIME (U/S/I), RESTART RATE (RESTART %) , AND MEAN BACKOFF CYCLES (BACK). 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><head>TABLE VII PARALLEL APPLICATIONS USED TO EXERCISE THE CONCURRENCY IN LINUX AND TXLINUX.</head><label>VII</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head>CONFLICTING ADDRESSES FOR THE JOURNAL LOCKS, AS WELL AS OTHER KEY SYNCCHAR METRICS. THE RANGE OF PERCENTAGES SHOWS THE NUMBER OF WORKSET ADDRESSES INVOLVED IN THAT PERCENTAGE OF CONFLICTS. SAMPLES ARE TAKEN FROM BONNIE++ AT 16 CPUS. THE AVERAGE WORKSET SIZE IS IN WORDS. DI IS DATA INDEPENDENCE, CD IS CONFLICT DENSITY, AND ASYM IS THE PROBABILITY OF BEING INVOLVED IN AN ASYMMETRIC CONFLICT.</head><label></label><figDesc></figDesc><table>Lock 
j state lock 
j list lock 
0-19% 
420 
242 
20-39% 
2 
0 
40-59% 
0 
0 
60-79% 
0 
0 
80-99% 
0 
0 
100% 
0 
0 
Avg. Workset Size 
13 
33 
Total Conflicts Sampled 
111,118 
35,600 

DI 
1.03 
1.15 
CD 
14.37 
7.26 
Asym 
88% 
92% 

TABLE VIII 
DISTRIBUTION OF </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><head>Table VII .</head><label>VII</label><figDesc>All other benchmarks performed identically to unmodified TxLinux.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12" validated="false"><head>Table IX presents</head><label>IX</label><figDesc>the time spent in the kernel for each of these benchmarks on both unmodified TxLinux and our optimized version, respectively. Kernel time is presented be- cause our tuning efforts are for the kernel itself and cannot be expected to improve the non-kernel portions of the execution time. Further, this approach eliminates noise introduced by load imbalance in the workloads.</figDesc><table>We reproduced the same pathological behavior on the bonnie 
benchmarks under TxLinux. After over a month of simulating 
bonnie on TxLinux (compared with 1-3 days on average 
for bonnie on unmodified Linux), the benchmarks had not 
terminated, so we list the baseline TxLinux performance as 
hung. 

</table></figure>

			<note place="foot" n="1"> We selected the term data conflicts over data dependence to avoid confusion with other meanings.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. CONCLUSION</head><p>This paper introduces Syncchar, a novel method and tool for reasoning about the performance of transactional memory. We have validated Syncchar's performance predictions and demonstrated its usefulness in guiding performance tuning on the TxLinux kernel. This paper also presents a detailed characterization of how the whole system, including architecture, libraries, and compiler, can affect the performance of transactional applications, often in a way that befuddles performance tuning. We see Syncchar as one in an array of profiling and debugging tools that must be developed to help application developers leverage transactional memory more effectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>X. ACKNOWLEDGEMENTS</head><p>We would like to thank the anonymous reviewers and Jeff Napper for helpful comments on earlier versions of this paper. We thank Owen Hofmann for help developing the Syncchar tool. We also thank Virtutech AB for the Simics academic license program. This research is supported by NSF CISE Research Infrastructure Grant EIA-0303609, NSF Career Award 0644205, and the DARPA computer science study group.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Variability in architectural simulations of multi-threaded workloads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Alameldeen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HPCA</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Validity of the single processor approach to achieving large-scale computing capabilities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AFIPS</title>
		<imprint>
			<date type="published" when="1967" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Making the fast case common and the uncommon case simple in unbounded transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Blundell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Devietti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Performance pathologies in hardware transactional memory. ISCA</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bobba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">E</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Volos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Yen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Click</surname></persName>
		</author>
		<ptr target="http://blogs.azulsystems.com/cliff" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Early experiences with a commercial hardware transactional memory implementation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dice</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Moir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Nussbaum</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<publisher>ASPLOS</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Fuss, futexes and furwocks: Fast userlevel locking in Linux</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Franke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Russel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kirkwood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ottawa Linux Symposium</title>
		<meeting>the Ottawa Linux Symposium</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Transactional memory coherence and consistency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hammond</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">D</forename><surname>Carlstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hertzberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Prabhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Wijaya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kozyrakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Olukotun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2004-06" />
			<biblScope unit="page">102</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Runtime checking of multithreaded applications with visual threads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Harrow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIN</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="331" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An analytic framework for performance modeling of software transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Heindl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Pokam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Netw</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1202" to="1214" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Transactional memory: Architectural support for lock-free data structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">E</forename><surname>Moss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="1993-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Maximum benefit from a minimal HTM</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rossbach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Witchel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Optimistic parallelism requires abstractions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kulkarni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Pingali</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Walter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ramanarayanan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Bala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">P</forename><surname>Chew</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Transactional Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>Larus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rajwar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<pubPlace>Morgan &amp; Claypool</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Debugging with transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Moir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TRANSACT</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Pin: Building customized program analysis tools with dynamic instrumentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Klauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lowney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">J</forename><surname>Reddi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Hazelwood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Simics: A full system simulation platform</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Magnusson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Christianson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Eskilson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Forsgren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hallberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hogberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Larsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Moestedt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Werner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Computer</title>
		<imprint>
			<date type="published" when="2002-02" />
			<biblScope unit="volume">35</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Memspy: Analyzing memory system bottlenecks in programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMETRICS</title>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Exploiting Deferred Destruction: An Analysis of Read-Copy Update Techniques in Operating System Kernels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">E</forename><surname>Mckenney</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
		<respStmt>
			<orgName>Oregon Health and Science University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">STAMP: Stanford transactional applications for multiprocessing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">C</forename><surname>Minh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kozyrakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Olukotun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IISWC</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Supporting nested transactional memory in LogTM</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Moravan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bobba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">E</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Yen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Liblit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS-XII</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Nested Transactions: An Approach to Reliable Distributed Computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">E B</forename><surname>Moss</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981" />
		</imprint>
		<respStmt>
			<orgName>Massachusetts Institute of Technology</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Why aren&apos;t operating systems getting faster as fast as hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">K</forename><surname>Ousterhout</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Summer</title>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Limited early value communication to improve performance of transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">M</forename><surname>Pant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">T</forename><surname>Byrd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICS</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Using SimPoint for accurate and efficient simulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Perelman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hamerly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">V</forename><surname>Biesbrouck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Sherwood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMETRICS</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Dissecting transactional executions in Haskell</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Perfumo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Sonmez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Cristal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Unsal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Valero</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Harris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TRANSACT</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Is the optimism in optimistic concurrency warranted? In HotOS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Witchel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Operating system transactions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><forename type="middle">S</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">J</forename><surname>Rossbach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Benn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Witchel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">MetaTM/TxLinux: Transactional memory for an operating system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Ramadan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rossbach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bhandari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Witchel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Dependence-aware transactions for increased concurrency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Ramadan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">J</forename><surname>Rossbach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Witchel</surname></persName>
		</author>
		<editor>MICRO</editor>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">TxLinux: Using and managing transactional memory in an operating system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rossbach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Ramadan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bhandari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Witchel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Hardware Transactional Memory: A Systems Perspective</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">J</forename><surname>Rossbach</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
		<respStmt>
			<orgName>The University of Texas at Austin</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Advanced contention management for dynamic software transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">N</forename><surname>Scherer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">L</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODC</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Refereeing conflicts in hardware transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shriraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Dwarkadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICS</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">xCalls: Safe I/O in memory transactions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Volos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Tack</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Welc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroSys</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Modeling optimistic concurrency using quantitative dependence analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Von Praun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bordawekar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cascaval</surname></persName>
		</author>
		<editor>PPoPP</editor>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">LogTM-SE: Decoupling hardware transactional memory from caches. In HPC</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Yen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bobba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Marty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">E</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Volos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Racetrack: Efficient detection of data race conditions via adaptive tracking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Rodeheffer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Extending hardware transactional memory to support non-busy waiting and nontransactional actions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Zilles</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Baugh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TRANSACT</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Debugging programs that use atomic blocks and transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Zyulkyarov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><forename type="middle">S</forename><surname>Unsal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Cristal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Valero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PPoPP</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
