<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T17:00+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Solving (Weighted) Partial MaxSAT through Satisfiability Testing</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><surname>Ansótegui</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Universitat de Lleida (DIEI</orgName>
								<address>
									<country>UdL</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">María</forename><surname>Luisa Bonet</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Universitat Politècnica de Catalunya (LSI</orgName>
								<orgName type="institution" key="instit2">UPC)</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jordi</forename><surname>Levy</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Artificial Intelligence Research Institute (IIIA, CSIC)</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Solving (Weighted) Partial MaxSAT through Satisfiability Testing</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Recently, Fu and Malik described an unweighted Partial MaxSAT solver based on successive calls to a SAT solver. At the kth iteration the SAT solver tries to certify that there exist an assignment that satisfies all but k clauses. Later Marques-Silva and Planes implemented and extended these ideas. In this paper we present and implement two Partial MaxSAT solvers and the weighted variant of one of them. Both are based on Fu and Malik ideas. We prove the correctness of our algorithm and compare our solver with other (Weighted) MaxSAT and (Weighted) Partial MaxSAT solvers.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In real-life, some solutions to a problem are acceptable even when some constraints are violated. In fact, in many situations it is impossible to satisfy all constraints. For instance, in the context of planning, scheduling, packing, etc., a solution satisfying all the constraints may be impossible to obtain. However we are still interested on which is the maximum number of constraints that can be satisfied with a minimal penalty.</p><p>We can solve these problems through the use of MaxSAT formalisms, such as (Weighted) MaxSAT and (Weighted) Partial MaxSAT. Recently, there has been an increasing interest in the development of solvers for these formalisms. Since 2006, every year takes place the MaxSAT evaluation <ref type="bibr" target="#b1">[2]</ref>. Most of the solvers submitted to the last MaxSAT08 evaluation are implementations of branch&amp;bound algorithms <ref type="bibr">(MaxSatz [11]</ref>, IncWMaxSatz, W-MaxSatz, WMaxsatz icss <ref type="bibr" target="#b5">[6]</ref>, MiniMaxSat <ref type="bibr" target="#b9">[10]</ref>, Lb-Sat and Lb-PSat <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13]</ref>, PMS <ref type="bibr" target="#b2">[3]</ref>, ToolBar3 <ref type="bibr" target="#b8">[9]</ref>). There are other approaches like the solver Clone <ref type="bibr" target="#b16">[17]</ref>, that makes use of a tractable language known as d-DNNF, and those which are based on the use of Satisfiability testing, SAT4J <ref type="bibr" target="#b3">[4]</ref>, msu1.2 <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15]</ref> and msu4.0 <ref type="bibr" target="#b15">[16]</ref>.</p><p>None of these solvers is a clear winner, specially for industrial and crafted instances. In particular, for the industrial category the solvers based on Satisfiability testing seem to perform very well for many benchmarks. Since the ultimate goal is to solve real world (industrial) instances it makes sense to study in detail this approach. Why these solvers work better for industrial instances may be a phenomena not only related to the hardness of the unsatisfiability cores included in the formulas (that can be efficiently detected by a SAT solver) but also to how these cores are connected.</p><p>The base of the study of this paper is the work of Fu and Malik <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>, where two Partial MaxSAT algorithms based on calls to a SAT solver are proposed, and the work of Marques-Silva and Planes <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref> and Marques-Silva and Manquinho <ref type="bibr" target="#b13">[14]</ref> which extend that previous work.</p><p>The contributions of our work are (i) a more optimized implementation of the original Fu and Malik algorithm; (ii) a weighted version of the original Fu and Malik algorithm together which the proof of its correctness; and (iii) another Partial MaxSAT solver variant of the Fu and Malik algorithm, and the proof of its correctness.</p><p>For the purpose of the evaluation of these algorithms, there is only one solver, SAT4J <ref type="bibr" target="#b3">[4]</ref>, that is adapted to deal with weights. In this paper, we provide a weighted version of the Fu and Malik algorithm <ref type="bibr" target="#b7">[8]</ref>. Our experimental investigation confirms what we already knew from previous MaxSAT evaluations. There is no unique best algorithm for solving MaxSAT or the other variants. Nevertheless, our implementation has a better performance than other solvers based on Satisfiability testing. In the case of the Partial Weighted MaxSAT, our solver is the first implementation of the original Fu and Malik ideas extended to the weighted problem. Therefore, we can only compare with SAT4J.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>In the Partial MaxSAT context we work with two sets of clauses, hard and soft. The Partial MaxSAT problem for a multiset of clauses is the problem of finding an optimal assignment to the variables that satisfies all the hard clauses, and the maximum number of soft clauses. The number of soft clause falsified by an assignment is the cost of this assignment. The cost of the optimal assignment of a formula F is called the cost of the formula, and is denoted by M axSAT (F ).</p><p>In Weighted Partial MaxSAT, we use multisets of weighted clauses. A weighted clause is a pair <ref type="bibr">(C, w)</ref>, where C is a clause and w is a natural number meaning the penalty for falsifying the clause C. The pair (C, w) is clearly equivalent to having w copies of clause C in our multiset (in case C is soft). If a clause is hard, the corresponding weight is infinity.</p><p>Given a truth assignment I and a multiset of weighted clauses C, the cost of assignment I on C is the sum of the weights of the clauses falsified by I.</p><p>The Weighted Partial MaxSAT problem for a multiset of weighted clauses C is the problem of finding an optimal assignment to the variables of C that minimizes the cost of the assignment on C. If the cost is infinity, it means that we have falsified a hard clause, and we say that the multiset is unsatisfiable.</p><p>Our approach is based on successive calls to a SAT solver. The SAT solver may return a set of clauses that is unsatisfiable. We call this set unsatisfiable core.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A Weighted Partial MaxSAT Algorithm</head><p>Before giving the full version of our algorithm, we will present the original Fu and Malik <ref type="bibr" target="#b7">[8]</ref> algorithm for Partial MaxSAT, and show the correction of the algorithm. The reason for doing this is that we will need parts of the argument to show the correctness of our algorithm for solving Weighted Partial MaxSAT.</p><p>The algorithm consists in iteratively calling a SAT solver on a working formula ϕ. This corresponds to the line (st, ϕ c ) := SAT (ϕ w ). The SAT solver will say whether the formula is satisfiable or not (variable st), and in case the formula is unsatisfiable, it will give an unsatisfiable core (ϕ c ). At this point the algorithm will produce new variables, blocking variables (BV in the code), one for each clause. The new working formula ϕ will consist in adding the new variables to the formulas of the core, adding a cardinality constraint saying that exactly one of the new variables should be true (CNF ( b∈BV b = 1) in the code), and adding one to the counter of falsified clauses. This procedure is applied until the SAT solver returns satisfiable. The following lemma and definition are part of the correctness of the algorithm for both the weighted and unweighted versions. Definition 1. We say that two (Weighted) (Partial) MaxSAT formulas ϕ and ϕ are MaxSAT equivalent if the cost of the optimal assignment of ϕ is equal to the cost of the optimal assignment of ϕ . Lemma 1. Let ϕ be an unsatisfiable CNF formula, and ϕ c = {C 1 , . . . , C s } be an unsatisfiable core in ϕ. Define</p><formula xml:id="formula_0">ϕ = (ϕ \ ϕ c ) ∪ {C 1 ∨ b 1 , . . . , C s ∨ b s } ∪ CNF ( s i=1 b i = 1) ∪ { } where b 1 , . . . , b s are new variables.</formula><p>Then, the minimum number of falsified clauses of ϕ is the same as the minimum number of falsified clauses of ϕ , i.e. ϕ and ϕ are MaxSAT equivalent.</p><p>Proof: Let I be a truth assignment for the variables of ϕ that satisfies all the hard clauses of ϕ. Since ϕ c is an unsatisfiable core, I falsifies some clause in ϕ c . Let C i be one such clause. Now define I the following way: for all x ∈ ϕ, I (x) = I(x); I (b i ) = 1 and I (b j ) = 0 for all j = i, 1 ≤ j ≤ s. Now I satisfies CNF ( s i=1 b i = 1). For every clause C in ϕ \ ϕ c , I (C) = I(C), and the same is true for all the clauses C j ∨ b j for j = i. Now, I falsifies C i but I satisfies C i ∨ b i and falsifies . As a consequence the number of falsified clauses of ϕ by I is the same as the number of falsified clauses of ϕ by I. Now consider an optimal assignment I for ϕ . By the optimality of I , we know that I satisfies CNF ( s i=1 b i = 1) and if I (C i ) = 1 then I (b i ) = 0. Now we define an assignment I for ϕ the following way: I(x) = I (x) for all x ∈ ϕ. We will see that the number of falsified clauses of I is the same as the number of falsified clauses in I . The number of falsified clauses in ϕ \ ϕ c is clearly the same. Let b i be the variable assigned true by I . Then</p><formula xml:id="formula_1">I (C j ∨ b j ) = I(C j ) for j = i. On the other hand, I(C i ) = 0 and I (C i ∨ b i ) = 1 but I falsifies .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1. Fu&amp;Malik is a correct algorithm for Partial MaxSAT.</head><p>Proof: In each iteration of the while loop, if the SAT solver returns unsatisfiable and the unsatisfiable core has soft clauses, we substitute a formula ϕ by another ϕ plus the addition of one to the variable cost. Adding 1 to cost is equivalent to considering that ϕ has also the empty clause. Lemma 1 shows that both formulas are equivalent in terms of the minimum number of unsatisfiable clauses.</p><p>The following algorithm is the weighted version of the previous one. Now we iteratively call the SAT solver with the working formula without the weights. When the SAT solver returns an unsatisfiable core, we calculate the minimum weight of the clauses of the core, w min in the algorithm. Now we transform the working formula in the following way: we duplicate the core having on one of the copies, the clauses with weight the original minus the minimum weight, and on the other copy we put the blocking variables and we give it the minimum weight. Finally we add the cardinality constraint on the blocking variables, and we add w min to the cost.</p><p>Lemma 2. Let ϕ be a weighted partial formula. Let exp(ϕ) be the natural expansion of ϕ into an unweighted formula by substituting every clause (C, w) of ϕ into w copies of C.</p><p>The minimum weight of ϕ is the same as the minimum number of falsified clauses of exp(ϕ).</p><p>Proof: This is straightforward.</p><p>The next lemma shows that if we have several identical unsatisfiable cores, we don't need to add different blocking variables to each core. Instead all cores can have the same set of blocking variables.</p><formula xml:id="formula_2">input: ϕ = {(C1, w1), . . . , (Cm, wm)} cost := 0 Optimal while true do (st, ϕc) := SAT ({Ci | (Ci, wi) ∈ ϕ})</formula><p>Call to the SAT solver without weights if st = SAT then return cost BV := ∅ Blocking variables of the core wmin := min{wi | Ci ∈ ϕc and Ci is soft} for each Ci ∈ ϕc do if Ci is soft then bi := new blocking variable</p><formula xml:id="formula_3">ϕ := ϕ \ {(Ci, wi)} ∪ {(Ci, wi − wmin)} ∪ {(Ci ∨ bi, wmin)} Duplicate soft clauses of the core BV := BV ∪ {bi} if BV = ∅ then return UNSAT</formula><p>There are no soft clauses in the core</p><formula xml:id="formula_4">else ϕ := ϕ ∪ CNF ( b∈BV b = 1)</formula><p>Add cardinality constraint as hard clauses cost := cost + wmin </p><formula xml:id="formula_5">ϕ 1 = ϕ \ ϕ c ∪ {C i ∨ b i , . . . , C i ∨ b i l times | C i ∈ ϕ c } ∪ CNF ( s i=1 b i = 1) and ϕ 2 =ϕ \ ϕ c ∪ {C i ∨ b 1 i , . . . , C i ∨ b l i | C i ∈ ϕ c } ∪ CNF ( s i=1 b 1 i = 1) ∪ . . . ∪ CNF ( s i=1 b l i = 1)</formula><p>Then, the minimum number of unsatisfiable clauses of ϕ 1 and ϕ 2 are the same, i.e. ϕ 1 and ϕ 2 are MaxSAT equivalent.</p><p>Proof: Let I be an optimal interpretation for ϕ 1 . Then, if I(C i ) = 1, for some i = 1, . . . , s, then I(b i ) = 0. This is true because ϕ c is unsatisfiable and I is optimal. Now we will modify I into an assignment I the following way:</p><formula xml:id="formula_6">I (x) = I(x) for all x ∈ ϕ I (b j i ) = I(b i ) for i = 1, . . . , s and j = 1, . . . , l It is clear that for all C ∈ ϕ − ϕ c , I (C) = I(C). Also, I (C i ∨ b j i ) = I(C i ∨ b i )</formula><p>. Let now I be an optimal assignment for ϕ 2 . Then as before, if I(C i ) = 1, for some i = 1, . . . , s, then I(b j i ) = 0 for every j = 1, . . . , l. Now we will modify I into an assignment I the following way:  </p><formula xml:id="formula_7">I(x) = I (x) for all x ∈ ϕ I(b i ) = I(b 1 i ) for all i = 1, . . . , s It is clear that for all C ∈ ϕ−ϕ c , I (C) = I(C).</formula><formula xml:id="formula_8">C i ) = I(C k ) = 0. Then I (C i ∨ b j i ) = 1 and I (C k ∨ b j k ) = 0, but I(C i ∨ b i ) = 0 and I(C k ∨ b k ) = 1.</formula><formula xml:id="formula_9">ϕ =(ϕ \ ϕ w c ) ∪ {(C i , w i − w min ) | C i ∈ ϕ c } ∪ {(C i ∨ b i , w min ) | C i ∈ ϕ c } ∪ CNF ( s i=1 b i = 1) ∪ {( , w min )} where {b 1 , . . . , b s } is a set of new variables.</formula><p>Then, ϕ and ϕ are MaxSAT equivalent.</p><p>Proof: Let exp(ϕ) be the unweighted expansion of ϕ. Lemma 2 shows that the minimum weight of ϕ is the same as the number of falsified clauses of exp(ϕ). Now ϕ c = {C 1 , . . . , C s } is an unsatisfiable core of exp(ϕ), and since w min = min(w 1 , . . . , w s ), ϕ c appears w min times in exp(ϕ). Now we can apply the transformation of lemma 1 w min times to obtain a formula</p><formula xml:id="formula_10">ϕ 2 =ϕ \ ϕ c ∪ {C i ∨ b 1 i . . . C i ∨ b wmin i | C i ∈ ϕ c } ∪ CNF ( s i=1 b 1 i = 1) ∪ . . . ∪ CNF ( s i=1 b l i = 1) { C i , . . . , C i w i − w min copies | C i ∈ ϕ c } ∪ { , . . . , w min }</formula><p>MaxSAT equivalent to ϕ exp . By Lemma 3, ϕ is MaxSAT equivalent to the formula</p><formula xml:id="formula_11">ϕ 1 =ϕ \ ϕ c ∪ {C i ∨ b i , . . . , C i ∨ b i w min copies | C i ∈ ϕ c } ∪{ C i , . . . , C i w i − w min copies | C i ∈ ϕ c } ∪ CNF ( s i=1 b i = 1) ∪ { , . . . , w min }</formula><p>Now using again Lemma 2, ϕ 1 is MaxSAT equivalent to ϕ as in the statement of the lemma.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2. WPM1 is a correct algorithm for Weighted Partial MaxSAT.</head><p>Proof: The theorem is proved iterating Lemma 4 for every execution of the loop of the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Another Partial MaxSAT Algorithm</head><p>The next algorithm, that we call PM2, is also a variant of the Fu and Malik algorithm that avoids the use of more than one blocking variable in a clause. A single blocking variable is added to each soft clause, like in other solvers like SAT4J <ref type="bibr" target="#b3">[4]</ref>, msu3 <ref type="bibr" target="#b14">[15]</ref> and msu4.0 <ref type="bibr" target="#b15">[16]</ref>. PM2 works as follows: every clause gets an additional variable and the cardinality constraint says that all these additional variables have to be false. Also before the first iteration of the algorithm the counter of falsified clauses, cost, is set to zero. At every iteration of the algorithm a SAT solver is called. As before, if the solver returns unsatisfiable, it also gives an unsatisfiable core. If the core only contains hard clauses, then the algorithm returns unsatisfiable. Otherwise, we put the blocking variables of the soft clauses of the core in a set B. Since we have found a new unsatisfiable core, variable cost gets increased by one. Also we look for other cores such that the soft clauses are included in the new core. If no such core exists, we add an at least cardinality constraint saying that the sum of the blocking variables of B is larger than or equal to one. If some cores are included, we add the cardinality constraint saying that the number of variables in B that need to be one is at least the number of cores included in the last core found (counting the last). In every call to the SAT solver we also add an at most cardinality constraint saying that the sum of all blocking variables is at most cost. If the solver says that the formula is satisfiable, the algorithm returns cost as the minimal number of falsified clauses.</p><p>PM2 simplifies Fu&amp;Malik in the sense that it only adds one blocking variable per clause. Intuitively, this would have to result into a more efficient algorithm because there are less blocking variables, so the SAT solver will have to check less possible assignments. This idea is already used in other MaxSAT solvers, like SAT4J <ref type="bibr" target="#b3">[4]</ref>, msu3 <ref type="bibr" target="#b14">[15]</ref> and msu4.0 <ref type="bibr" target="#b15">[16]</ref>. In SAT4J only one at most cardinality constraint (saying that the sum of blocking variables is smaller than k) is used. This bound k is reduced until the SAT solvers says unsatisfiable. In msu3 <ref type="bibr" target="#b14">[15]</ref>, in a first phase they compute a maximal set of disjoint cores, and in a second phase they do as in SAT4J but increasing the bound k (starting with the number of disjoint cores) until the SAT solver returns sat, and only summing the blocking variables that have appeared in some core. Finally, in the msu4.0 algorithm <ref type="bibr" target="#b15">[16]</ref>, apart from the at most constraint, they also use some at least constraints saying that blocking variables occurring in a core, and not occurring in previous cores, have to sum at least one. The algorithm alternates phases where the SAT solver returns sat or unsat, refining a lower or upper bound, and only terminates when the upper and lower bound coincide, or when the new core does not contain new blocking variables. Our approach is different from previous ones in two senses. First, our at most constraint has a bound cost that is successively increased like in msu3, instead of decreased like in SAT4J. Second, our at least constraints may impose a bound strictly greater than one, in contrast with the msu4.0 algorithm. This would have to result in a more restrictive constraint, thus in fewer assignments to check by the SAT solver. </p><formula xml:id="formula_12">= Ci ∨ bi ∈ ϕc do B := B ∪ {bi} L := L ∪ {ϕc} k := |{ψ ∈ L | ψ ⊆ ϕc}|</formula><p>Num. of cores contained in ϕc including ϕc ϕw := ϕw ∪ CNF ( b∈B b ≥ k) Add at least cardinality constraint cost := cost + 1 To prove that the PM2 algorithm is correct, we will prove that the Fu&amp;Malik algorithm can simulate it. We have to be aware they are nondeterministic, since we assume that the SAT solver returns an unsatisfiable core non-deterministically. However, recall that we have proved that Fu&amp;Malik algorithm is correct for every possible run. The proof is by induction on the number of execution steps. From now on, when we say that a set of soft clauses is a core, we mean that this set, together with the hard clauses, is a core. A core B = {i 1 , . . . , i m } will be a set of indexes of soft clauses. Suppose that Fu&amp;Malik has simulated PM2 for s steps. We will prove that 1) if PM2 finds a core B, then this set B of (soft) clauses is also a core for the Fu&amp;Malik algorithm, in particular if the set B = ∅ is a core for PM2, and it returns UNSAT, then the same set B = ∅ is a core for Fu&amp;Malik, that also returns UNSAT; and 2) if PM2 does not find any cores, and stops, then Fu&amp;Malik does not find any cores either, and also stops returning the same MaxSAT value, since both have run the same number of steps.</p><p>Since Theorem 3 will be proved by induction, assume by induction hypothesis that</p><formula xml:id="formula_13">ϕ = {C 1 ∨ a 1 , . . . , C m ∨ a m } ∪ CNF ( m i=1 a i ≤ s) ∪ s r=1 CNF ( i∈Br a i ≥ k r )</formula><p>is the formula computed by PM2 after s execution steps, where B 1 , . . . , B s is the sequence of cores, and k j is the number of cores from B 1 , . . . , B j included in B j . Assume also that Fu&amp;Malik, after s steps simulating PM2, with the same sequence of cores B 1 , . . . , B s , obtains the formula</p><formula xml:id="formula_14">ˆ ϕ = {C 1 ∨ 1∈Bj b j 1 , . . . , C n ∨ n∈Bj b j n } ∪ s j=1 CNF ( i∈Bj b j i = 1)</formula><p>Lemma 5. Let ϕ andˆϕandˆ andˆϕ be the formulas obtained by PM2 and Fu&amp;Malik algorithms, respectively, after s steps of simulation. For any optimal interpretationˆI interpretationˆ interpretationˆI of the variables ofˆϕofˆ ofˆϕ, let I be the interpretation of the variables of ϕ given by</p><formula xml:id="formula_15">I(x) = ˆ I(x) for any variable x ∈ {C 1 , . . . , C n } I(a i ) = max{ˆImax{ˆ max{ˆI(b j i ) | i ∈ B j } for the blocking variables</formula><p>Then, (1) ifˆIifˆ ifˆI satisfies the hard clause C ∈ ˆ ϕ, then I satisfies the hard clause C ∈ ϕ; (2) ifˆIifˆ ifˆI satisfies the cardinality constraints ofˆϕofˆ ofˆϕ, then I satisfies the cardinality constraints of ϕ; and (3) ifˆIifˆ ifˆI satisfies the soft clause</p><formula xml:id="formula_16">C i ∨ i∈Bj b j i ∈ ˆ ϕ, then I satisfies the soft clause C i ∨ a i ∈ ϕ.</formula><p>Proof: Statement (1) is trivial, since I andˆIandˆ andˆI assign the same values to the original variables. For (2), ifˆIifˆ ifˆI satisfies the cardinality constraints ofˆϕofˆ ofˆϕ, then i∈BrˆI i∈Brˆ i∈BrˆI(b r i ) = 1, for any core B r . Hence,</p><formula xml:id="formula_17">i∈Br i∈B j j=1,...s ˆ I(b j i ) ≥ B j ⊂Br j≤r i∈BjˆI i∈Bjˆ i∈BjˆI(b j i ) = |{B j | B j ⊆ B r ∧ j ≤ r}|</formula><p>for any of the cores B r obtained in the execution. If the interpretationˆIinterpretationˆ interpretationˆI is optimal, it means that it assigns true to at most one of the blocking variables of a clause. In other words,</p><formula xml:id="formula_18">i∈B j j=1,...,s ˆ I(b j i ) ≤ 1 hence I(a i )= max{ˆImax{ˆ max{ˆI(b j i ) | i ∈ B j ∧j = 1, . . . , s} = i∈B j j=1,...,s ˆ I(b j i )</formula><p>for any i = 1, . . . , n. From all this, we conclude i∈Br I(a i ) ≥ |{B j | B j ⊆ B r ∧j ≤ r}| = k r , i.e. I satisfies the cardinality constraints CNF ( i∈Br a i ≥ k r ).</p><p>Similarly, we can prove that ifˆIifˆ ifˆI is optimal</p><formula xml:id="formula_19">n i=1 I(a i ) = n i=1 max{ˆImax{ˆ max{ˆI(b j i ) | i ∈ B j ∧ j = 1, . . . , s} = n i=1 i∈B j j=1,...,s ˆ I(b j i ) = s j=1 i∈BjˆI i∈Bjˆ i∈BjˆI(b j i ) = s j=1 1 = s</formula><p>Hence, the other cardinality constraint CNF ( m i=1 a i ≤ s) is also satisfied. For (3), ifˆIifˆ ifˆI satisfies C i ∨ i∈Bj b j i , then either it satisfies C i , and so I because the assign the same values to original variables, or it satisfies some of the variables b j i . In this second case, the way we define the value of a i ensures that I satisfies this value, hence the clause C i ∨ a i ∈ ϕ.</p><p>Lemma 6. Let ϕ andˆϕandˆ andˆϕ be the formulas obtained by PM2 and Fu&amp;Malik algorithms, respectively, after s steps of simulation. If B is a core of ϕ, then B is also a core ofˆϕofˆ ofˆϕ.</p><p>Proof: If B is not a core ofˆϕofˆ ofˆϕ, then there exists an interpretation I ofˆϕofˆ ofˆϕ that satisfies all hard clauses, all cardinality constraints ofˆϕofˆ ofˆϕ, and all soft clauses C i ∨ i∈Bj b j i where i ∈ B. By Lemma 5, ˇ I will satisfy all hard clauses, all cardinality constraints of ϕ, and all soft clauses C i ∨ a i where i ∈ B. This would contradict that B is a core of ϕ.</p><p>The previous lemma ensures that if PM2 finds a core, then Fu&amp;Malik also finds a core. Hence, if PM2 does not stop, then Fu&amp;Malik does not stop, either. Therefore, the values computed by PM2 are smaller than the values calculated by Fu&amp;Malik. However, it is still possible that PM2 computes underestimated values of MaxSAT of a formula. The following lemma shows that this is not the case. Notice that the proof of this lemma relies on the correctness of the Fu&amp;Malik algorithm.</p><p>Lemma 7. Let ϕ andˆϕandˆ andˆϕ be the formulas obtained by PM2 and Fu&amp;Malik algorithms, respectively, after s steps of simulation. If ϕ is satisfiable, thenˆϕthenˆ thenˆϕ is satisfiable.</p><p>Proof: Let I be an interpretation satisfying ϕ. In particular, I satisfies CNF ( m i=1 a i ≤ s), and all hard and soft clauses. Therefore, I satisfies all the original soft clauses C i where I(a i ) = f alse, and there are at least n − s of such clauses. We have M axSAT (C 1 , . . . , C n ) ≤ s. Since, Fu&amp;Malik is a correct algorithm for MaxSAT, it has to stop before s or less execution steps. And, since it has not finished before, it has to finish after these s steps, hencê ϕ is satisfiable.</p><p>Theorem 3. PM2 is a correct algorithm for Partial MaxSAT. Maxcut/random/ 58 MaxSatz -4.5(40) - <ref type="formula">(0)</ref> - <ref type="formula">(0)</ref> - <ref type="formula">(0)</ref> - <ref type="formula">(0)</ref> - <ref type="formula">(</ref>  <ref type="formula">(1)</ref> - <ref type="formula">(0)</ref> - <ref type="formula">(0)</ref> 106 <ref type="formula">(61)</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experimental Results</head><p>In order to conduct our experimental investigation we have selected the benchmarks submitted to the MaxSAT08 evaluation <ref type="bibr" target="#b1">[2]</ref>. We have focus on the crafted and industrial instances for all the four categories: unweighted MaxSAT, partial MaxSAT, weighted MaxSAT and weighted partial MaxSAT. The appropriate testing instances for our algorithms would be the industrial instances, where we can expect these approaches to be competitive. However, since there is a lack of industrial instances, in particular for the weighted and partial weighted categories, we decided also to incorporate the crafted instances. Our experiments have been run on the same machine specs as the MaxSAT evaluation; Operating System: Rocks Cluster 4.0.0 Linux 2.6.9, Processor: AMD Opteron 248 Processor, 2 GHz and compilers, Memory: 1 GB and Compilers GCC 3.4.3, javac JDK 1.5.0. The solvers we compare are the best solvers for each category and benchmark at the MaxSAT08 evaluation <ref type="bibr" target="#b1">[2]</ref>, the solvers based on satisfiability testing (msu1.2, msu4.0 <ref type="bibr" target="#b15">[16]</ref>, and SAT4J <ref type="bibr" target="#b3">[4]</ref>) and our implementations of the weighted version of Fu&amp;Malik (WPM1) and Partial MaxSAT 2 (PM2) presented in this paper.</p><p>Our solvers are implemented on top of the SAT solver picosat846 <ref type="bibr" target="#b4">[5]</ref>, although they can be easily adapted to work with any other solver that provides an interface to access to the unsatisfiable core when the formula is UNSAT. In order to encode the cardinality constraints, for WPM1, we use the regular encoding presented in <ref type="bibr" target="#b0">[1]</ref>, and for PM2 we use the encoding based on sequential counters presented in <ref type="bibr" target="#b17">[18]</ref>. In SAT4J <ref type="bibr" target="#b3">[4]</ref>, for each clause c i in the original problem, a new blocking variable b i is added. Then a SAT solver is called to solve the new formula, and each time a model is found, a cardinality constraint is added to the formula that states that the sum of blocking variables has to be less than the number of blocking variables satisfied in the previous iteration. Once the SAT solver gives an UNSAT answer, the latest model is an optimal solution.</p><p>Msu1.2 <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15]</ref> is another implementation of the Fu&amp;Malik algorithm. Msu4.0 <ref type="bibr" target="#b15">[16]</ref> is a more sophisticated approach, which alternates iterations to discover new cores with iterations to reduce the number of blocking variables that need to be set to true in each core. <ref type="table" target="#tab_1">Table 1 and Table 2</ref> show the results of our experimental investigation. We set as timeout 1200 seconds. We report the number of solved instances (within parenthesis), and the mean time of the solved instances for each solver. The rules at the MaxSAT08 evaluation <ref type="bibr" target="#b1">[2]</ref> establish that the winner is the solver which solves more instances and ties are broken by selecting the solver with the minimum mean time. In bold we present the results of the winners.</p><p>We are interested in answering two questions: how our solvers would have performed at the MaxSAT08 evaluation <ref type="bibr" target="#b1">[2]</ref>, and how they compare to the current solvers based on satisfiability testing.</p><p>As we can see for the unweighted category, the solvers based on satisfiability testing perform well at the industrial category being our solver WPM1 the best performing one. For the crafted instances, the solvers based on satisfiability testing are not competitive, however our solver PM2 is the best among them.</p><p>For the partial category and the crafted instances, the solvers based on satisfiability testing are again not competitive, except for SAT4J <ref type="bibr" target="#b3">[4]</ref> at one benchmark. However, for the industrial instances, they win 7 out of 9 benchmarks, in particular, WPM1 wins at 2, PM2 at 3 and msu4.0 <ref type="bibr" target="#b15">[16]</ref> at 2.</p><p>For the weighted category, WPM1 and SAT4J <ref type="bibr" target="#b3">[4]</ref> just show a good behavior on one set of instances, the Ramsey set. However, looking more closely to the set, many of the instances are actually satisfiable. Unfortunately, there are not available industrial instances for this category.</p><p>For the weighted partial category and crafted instances, WPM1 and SAT4J <ref type="bibr" target="#b3">[4]</ref> are just able to win at 2 out 9 benchmarks. Again, unfortunately, there is only one set of industrial instances, and MinimaxSAT is the only solver able to solve 8 instances while the rest of the solvers submitted to the MaxSAT08 evaluation <ref type="bibr" target="#b1">[2]</ref> and the one presented in this paper are not able to solve more than 2 instances.</p><p>As a whole, we can say that there is not a clear winner in all the categories, and so far, all the approaches can have some potential. Respect to the solvers we have presented in this paper, we have shown that our implementations show a good performance on the industrial instances for the unweighted and partial categories. That should be a promising base point for the weighted versions. Although we can not make such a claim yet, since there are not enough industrial instances at these categories in order to test our solvers, we think this research avenue is worth further investigation.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. The pseudo-code of the Fu&amp;Malik algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. The pseudo-code of the WPM1 algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>The next lemma shows the correctness of one iteration of our Weighted Partial MaxSAT algorithm WPM1. Lemma 4. Let ϕ be an unsatisfiable weighted partial formula, let ϕ c = {C 1 , . . . , C s } be an unsatisfiable core in the set of clauses from ϕ, and let ϕ w c = {(C 1 , w 1 ), . . . , (C s , w s )} the subset of weighted clauses of ϕ that corre- sponds to the core. Let w min = min(w 1 , . . . , w s ), and let</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>input: ϕ = {C1, . . . , Cm} BV := {b1, . . . , bm} Set of all blocking variables ϕw := {C1 ∨ b1, . . . , Cm ∨ bm} Protect all clauses cost := 0 Optimal L := ∅ Set of Cores while true do (st, ϕc) := SAT (ϕw ∪ CNF ( b∈BV b ≤ cost)) Call to the SAT solver with at most cardinality constraint if st = SAT then return cost remove the hard clauses from ϕc if ϕc = ∅ then return UNSAT B := ∅ Blocking variables of the core for each C</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. The pseudo-code of the PM2 algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>We will show that the number of unsatisfied clauses of {C 1 ∨b j 1 , . . . , C s ∨b j s } by I for every j = 1, . . . , l is the same as the number of unsatisfied clauses of {C i ∨ b 1 , . . . , C s ∨ b s } by I. Now suppose that the only b variable that I assigns true is b j i and the only b variable that I assigns true is b k . By assumption, I(</head><label></label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 1 . Time in seconds (solved). Timeout of 1200 seconds. # stands for number of instances of the benchmark.</head><label>1</label><figDesc></figDesc><table>set 
# 
best08 
WPM1 
PM2 
msu1.2 
msu4.0 
SAT4J 

Unweighted MaxSAT Category 

Crafted 

Maxcut/dimacs mod/ 
62 
IncMaxSatz -81.8(52) 
0.03(4) 
175(7) 
0.28(4) 
1.71(3) 
0.93(2) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="true"><head>Table 2 . Time in seconds (solved). Timeout of 1200 seconds. # stands for number of instances of the benchmark.</head><label>2</label><figDesc></figDesc><table>set 
# 
best08 
WPM1 SAT4J 
Weighted MaxSAT Category 
Crafted 
KeXu/ 
15 IncWMaxsatz -126.5(15) 
478(1) 
7.7(4) 
Ramsey/ 
48 
lb-psat -1.63(37) 0.05(34) 
16(35) 
WMaxcut/dimacs mod/ 62 
ToolBar3 -59(56) 0.12(3) 0.84(2) 
WMaxcut/Random/ 
40 MiniMaxSAT -5.43(40) 
-(0) 
-(0) 
WMaxcut/Spinglass/ 
5 
MiniMaxSAT -27.6(4) 
-(0) 
-(0) 
Weighted Partial MaxSAT Category 
Crafted 
Auctions/Auc paths/ 88 IncWMaxsatz -8.4(88) 
-(0) 497(15) 
Auctions/Auc regions/ 88 MiniMaxSAT -1.7(84) 
-(0) 166(76) 
Auctions/Auc Sched/ 84 
MiniMaxSAT -46(84) 
-(0) 317(49) 
Random-net/ 
350 
Clone -72(236) 194(91) 331(13) 
Pseudo-factor/ 
186 IncWMaxsatz -0.07(186) 16(124) 3.3(186) 
Pseudo-miplib/ 
16 
SAT4J -13(6) 0.29(3) 
13(6) 
QCP/ 
25 
SAT4J -6.14(25) 0.27(25) 6.14(25) 
WCSP/Planning/ 
71 
SAT4J -6.55(71) 0.9(46) 6.55(71) 
WCSP/Spot5/Dir/ 
21 
Clone -87.6(6) 2.31(4) 
76(3) 
WCSP/Spot5/Log/ 
21 
Clone -15(6) 0.52(5) 63.8(3) 
Industrial 
Protein ins 
12 
MiniMaxSAT -482(8) 
42(1) 6.05(1) 

</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We especially thank Armin Biere for the insightful discussions about his SAT solver picosat. We would also like to thank the organizers of the MaxSAT evaluations.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Mapping problems with finite-domain variables to problems with boolean variables</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ansótegui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Manyà</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAT 2004</title>
		<editor>Hoos, H., Mitchell, D.G.</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005" />
			<biblScope unit="volume">3542</biblScope>
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The first and second Max-SAT evaluations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Argelich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">M</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Manyà</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Planes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal on Satisfiability</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="251" to="278" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Partial Max-SAT solvers with clause learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Argelich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Manyà</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAT 2007</title>
		<editor>MarquesSilva, J., Sakallah, K.A.</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007" />
			<biblScope unit="volume">4501</biblScope>
			<biblScope unit="page" from="28" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Berre</surname></persName>
		</author>
		<ptr target="http://www.sat4j.org" />
		<imprint>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">PicoSAT essentials</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal on Satisfiability</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="75" to="97" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On inconsistent clause-subsets for Max-SAT solving</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Darras</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Dequen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Devendeville</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">M</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CP 2007</title>
		<editor>Bessì ere, C.</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007" />
			<biblScope unit="volume">4741</biblScope>
			<biblScope unit="page" from="225" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Extending the Power of Boolean Satisfiability: Techniques and Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Fu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
			<pubPlace>Princeton</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Princeton University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On solving the partial max-sat problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAT 2006</title>
		<editor>Biere, A., Gomes, C.P.</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="volume">4121</biblScope>
			<biblScope unit="page" from="252" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">New inference rules for efficient Max-SAT solving</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Heras</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Larrosa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. the 21th National Conference on Artificial Intelligence (AAAI 2006</title>
		<meeting>the 21th National Conference on Artificial Intelligence (AAAI 2006</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">MiniMaxSat: A new weighted Max-SAT solver</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Heras</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Larrosa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Oliveras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAT 2007</title>
		<editor>Marques-Silva, J., Sakallah, K.A.</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007" />
			<biblScope unit="volume">4501</biblScope>
			<biblScope unit="page" from="41" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">New inference rules for Max-SAT</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">M</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Manyà</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Planes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artif. Intell. Res. (JAIR)</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="321" to="359" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Exploiting inference rules to compute lower bounds for Max-SAT solving</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 20th Int. Joint Conf. on Artificial Intelligence (IJCAI 2007)</title>
		<meeting>of the 20th Int. Joint Conf. on Artificial Intelligence (IJCAI 2007)</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="2334" to="2339" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Within-problem learning for efficient lower bound computation in Max-SAT solving</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">M</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. the 23th National Conference on Artificial Intelligence (AAAI 2008)</title>
		<meeting>the 23th National Conference on Artificial Intelligence (AAAI 2008)</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="351" to="356" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Towards more effective unsatisfiability-based maximum satisfiability algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Marques-Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">M</forename><surname>Manquinho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAT 2008</title>
		<editor>Kleine Büning, H., Zhao, X.</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008" />
			<biblScope unit="volume">4996</biblScope>
			<biblScope unit="page" from="225" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">On using unsatisfiability for solving maximum satisfiability</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Marques-Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Planes</surname></persName>
		</author>
		<idno>abs/0712.1097</idno>
		<imprint>
			<date type="published" when="2007" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Algorithms for maximum satisfiability using unsatisfiable cores</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Marques-Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Planes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Conf. on Design, Automation and Test in Europe</title>
		<meeting>of the Conf. on Design, Automation and Test in Europe</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="408" to="413" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Clone: Solving weighted Max-SAT in a reduced search space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Pipatsrisawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Darwiche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Australian Conference on Artificial Intelligence</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="223" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Towards an optimal CNF encoding of boolean cardinality constraints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sinz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CP 2005</title>
		<editor>van Beek, P.</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005" />
			<biblScope unit="volume">3709</biblScope>
			<biblScope unit="page" from="827" to="831" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
