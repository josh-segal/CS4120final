<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T17:01+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Bounded Model Checking of Concurrent Data Types on Relaxed Memory Models: A Case Study 񮽙</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Burckhardt</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajeev</forename><surname>Alur</surname></persName>
							<email>alur@cis.upenn.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milo</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
							<email>milom@cis.upenn.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Bounded Model Checking of Concurrent Data Types on Relaxed Memory Models: A Case Study 񮽙</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Many multithreaded programs employ concurrent data types to safely share data among threads. However, highly-concurrent algorithms for even seemingly simple data types are difficult to implement correctly, especially when considering the relaxed memory ordering models commonly employed by today&apos;s multiprocessors. The formal verification of such implementations is challenging as well because the high degree of concurrency leads to a large number of possible executions. In this case study, we develop a SAT-based bounded verification method and apply it to a representative example, a well-known two-lock concurrent queue algorithm. We first formulate a correctness criterion that specifically targets failures caused by concurrency; it demands that all concurrent executions be observationally equivalent to some serial execution. Next, we define a relaxed memory model that conservatively approximates several common shared-memory multiprocessors. Using commit point specifications, a suite of finite symbolic tests, a prototype encoder, and a standard SAT solver, we successfully identify two failures of a naive implementation that can be observed only under relaxed memory models. We eliminate these failures by inserting appropriate memory ordering fences into the code. The experiments confirm that our approach provides a valuable aid for desigining and implementing concurrent data types.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Shared-memory multiprocessor architectures dominate the server and scientific computing market today and are even finding their way into desktop, laptop and gaming machines. Nevertheless, programming such systems remains a challenge <ref type="bibr" target="#b0">[1]</ref>. To cope with the subtleties of concurrent program executions, software architects often introduce abstraction layers in the form of concurrent data types.</p><p>Concurrent data types provide familiar data abstractions (such as queues, hash tables, or trees) to client programs that have concurrently executing threads. The interface of the data type specifies the operations. The implementation provides the actual code for the operations; it hides the concurrency from the client program, using lower-level synchronization primitives such as locks or semaphores as needed. To allow for more concurrency and better performance, optimized implementations use fine-grained locking or even avoid locks altogether by using lock-free synchronization techniques <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b3">4]</ref>.</p><p>Writing correct and efficient code for concurrent data types is challenging. To make matters worse, many contemporary shared-memory architectures use relaxed memory ordering models <ref type="bibr" target="#b4">[5]</ref>. For example, a processor may execute memory accesses in a different order than specified by the program, and stores may take effect locally before becoming visible to remote processors. Although regular "fully synchronized" programs are not sensitive to the memory model, implementations that contain concurrency optimizations (such as intentional data races or lock-free synchronization) become exposed to such ordering and atomicity relaxations. Because the resulting executions are counterintuitive and nondeterministic, even highly skilled engineers are likely to make programming errors when relying on informal reasoning and conventional testing only, which motivates the use of formal verification.</p><p>The operations of the concurrent data type are invoked by a multi-threaded client program and may execute concurrently on a multiprocessor. Our correctness criterion is operation-level sequential consistency. It requires that all concurrent executions be observationally equivalent to a serial execution, that is, an execution in which the operations execute atomically and in the order they are invoked by each thread. As we assume that all serial executions reflect the semantics of the abstract data type correctly (which can be verified independently using standard techniques for sequential programs), correctness in our sense implies that client programs always observe the correct semantics. In particular, the data type is guaranteed to appear sequentially consistent to the client program even if the underlying multiprocessor executions are not sequentially consistent <ref type="bibr" target="#b5">[6]</ref> on the instruction level.</p><p>To bound the number of threads, the state space, and the depth of the execution, we consider client programs that make a fixed number of operation calls only. We call these bounded instances symbolic tests. Furthermore, the user must specify commit points <ref type="bibr" target="#b6">[7]</ref>, that is, single out an instruction within each operation such that the logical order of the operations always matches the execution order of their commit points. We qualify soundness and completeness of our approach as follows: (a) it can prove correctness for all executions of the given symbolic test, and (b) it generates counterexamples that are sound with respect to the chosen memory model and commit point specification.</p><p>We encode the existence of a violating execution as a CNF instance that can be solved or refuted by a standard SAT solver (corresponding to cases (b) and (a) above). Our encoding combines several ideas that appear in prior work, such as loop unrolling and SSA transformations <ref type="bibr" target="#b7">[8]</ref> and axiomatic memory model encodings <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref>.</p><p>We successfully applied our method to an example that represents optimized implementations of concurrent data types, the two-lock concurrent queue by Michael and Scott <ref type="bibr" target="#b10">[11]</ref>. First, we verified that the implementation code is correct for all symbolic tests in our suite when executed on a sequentially consistent memory model. Next, our prototype found two failures that can occur when the same code is executed on a relaxed memory model. Guided by the counterexamples, we identified the problematic instruction reorderings and prevented them by inserting two memory ordering fences. Finally, we verified that with these fences, the code executes correctly on a relaxed memory model for all symbolic tests in the suite.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related Work</head><p>Most prior work on formal verification of concurrent data types assumes a sequentially consistent memory model <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b13">14]</ref>. In that context, linearizability <ref type="bibr" target="#b14">[15]</ref> is the correctness criterion of choice. Unfortunately, its definition assumes that an execution globally orders the operation invocations and returns, which is not well defined on relaxed memory models because instructions may be reordered across operation boundaries.</p><p>Model checking of assembly code snippets for relaxed memory models was first attempted with explicit state enumeration <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b17">17]</ref> using an operational memory model and interleaving concurrency. More recently, constraint-based encodings of axiomatic memory models have been proposed for memory-model sensitive race detection <ref type="bibr" target="#b8">[9]</ref>. Our approach differs because we specifically target concurrent data types and because we use operation-level sequential consistency as our correctness criterion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Challenge</head><p>Our verification target is the two-lock FIFO queue implementation <ref type="bibr" target="#b10">[11]</ref> by Michael and Scott <ref type="figure" target="#fig_0">(Fig. 1)</ref>. We chose this example because of its optimized use of locks: the enqueue and dequeue operations can proceed concurrently because they use independent locks. This concurrency improves performance, but it also introduces a race condition if the queue is empty. Race conditions sometimes indicate an improper locking discipline <ref type="bibr" target="#b18">[18]</ref>, but as we see here, they may also be a side effect of concurrency optimizations.</p><p>We encountered several challenges in the course of our case study:</p><p>Avoiding State Explosion. An interleaving model of concurrency can lead to large state spaces; relaxed memory models exacerbate this effect because they introduce additional concurrency at the instruction level. Therefore, we decided against unrolling the transition relation and representing executions as global state sequences. Instead, we represent the program executed by each thread as a linear symbolic instruction stream, and we encode the relative order of instructions using SAT variables.</p><p>Defining Memory Models. We compared the memory model specifications for the IBM PowerPC <ref type="bibr" target="#b19">[19]</ref>, Sun SPARC v9 TSO/PSO/RMO <ref type="bibr" target="#b20">[20]</ref>, Alpha <ref type="bibr" target="#b21">[21]</ref>, and IBM zArchitecture <ref type="bibr" target="#b22">[22]</ref>. Although there are many differences, the specifications use similar rules (axioms) to describe the valid memory orderings. By comparing the axioms, we derived a generic relaxed memory model (to be defined in section 3.4) that provides a common conservative approximation and abstracts unneeded details.</p><p>Encoding Memory Models. We can encode the memory model axioms directly because we have explicit representations of the instruction streams for each thread <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b23">23]</ref>. In contrast, classic interleaving models based on labeled transition systems require a prior conversion of the axiomatic specification into an operational style <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b17">17]</ref>.</p><p>Bounding Instances. To achieve a bounded formulation, we approximate admissible client programs using a manually constructed suite of symbolic tests. Each test specifies a fixed, finite sequence of symbolic operation invocations for each thread. Unlike deterministic tests, a symbolic test covers all possible instruction interleavings and  <ref type="bibr" target="#b10">[11]</ref>. The queue is represented by a dynamically allocated singly linked list with head and tail pointers, each protected by a separate lock. To simplify the empty queue case, the first node of the linked list is a "dummy" element: its value is not part of the queue.</p><p>reorderings and all possible call arguments and return values. The total number of instructions executed during a test is bounded because the operations do not contain loops. As a result, each test has a finite (albeit exponential) number of possible executions, which explains how we avoid the undecidability of sequential consistency <ref type="bibr" target="#b24">[24]</ref>.</p><p>Representing Parameters. The implementation is parameterized by (a) the number of threads, (b) the size of the queue, (c) the size of the instruction reordering window, and (d) the number of distinct data values. As our formulation targets individual symbolic tests with finitely many executions, we can easily find static bounds. For instance, the number of threads is explicitly specified by the test, the queue size and the number of data values never exceed the number of "enqueue" calls, and the instruction reorder window need not be larger than the total number of instructions.</p><p>Avoiding Mixed Quantifiers. Our correctness criterion contains alternating quantifiers (we ask if there exists a observationally equivalent serial execution for each concurrent execution), which can not be directly encoded in SAT. We avoid this problem (at the expense of some generality and automation) by asking the user to designate one instruction for each operation to be the commit point. If correctly specified, the order in which the commit points execute matches the logical order of the operations. With this additional information, we can construct a deterministic serial reference execution for each concurrent execution. If the two executions are observationally equivalent in all cases, we have shown that the implementation is sequentially consistent. If not, our tool provides a counterexample trace that shows both executions, which may point out an actual defect in the implementation or an incorrect commit point specification.</p><p>Making Memory Accesses Explicit. The original algorithm <ref type="figure" target="#fig_0">(Fig. 1</ref>) uses a pseudocode notation similar to C. To accurately model synchronization instructions and the effects of the memory model, we require a lower-level representation that makes the loads and stores explicit. Our back-end prototype accepts a loop-free imperative intermediate language that has (a) a small syntax, (b) a well-defined semantics even for weak memory models, and (c) supports modelling of spin loops, atomic blocks, and assertions.</p><p>Translating the Code. We envision a tool that includes a front end that accepts a subset of C and performs the translation automatically. However, for this case study, we used a straightforward manual translation of the pseudo-code into our tool's intermediate language.</p><p>Modelling Locks and Detecting Deadlocks. The code for the two-lock queue makes calls to lock() and unlock() without fully specifying their memory ordering semantics. For reference, we use a lock implementation from an architecture manual <ref type="bibr" target="#b20">[20]</ref> that contains a spin loop, an atomic load-store primitive, and (partial) memory ordering fences. We use a reduction for side-effect free spin loops that allows us to model a single iteration of the spin loop only, while still covering all executions and detecting all deadlocks caused by an improper locking discipline in the implementation.</p><p>Modelling Dynamic Memory Management. To model dynamic memory allocation, we create an array of blocks, each with its own lock. The allocation call nondeterministically selects a free block and locks it. The deallocation call unlocks it again. The array size is bounded by the number of "enqueue" calls in the symbolic test.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Solution</head><p>In this section, we formalize symbolic tests and our correctness criterion, we show how to prove correctness or provide a counterexample for a given commit point specification, and we formally define our memory model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Symbolic Tests</head><p>A symbolic test T (A, B) specifies a finite sequence of operation invocations for each thread. A is a set of symbolic variables that represents argument values passed to the</p><formula xml:id="formula_0">T (A, B) thread 1: thread 2: (b1, b2) = dequeue() enqueue(a2) enqueue(a1) (b5, b6) = dequeue() (b3, b4) = dequeue() A = {a1, a2} and B = {b1, . . . , b6}</formula><p>Meaning of the operations:</p><formula xml:id="formula_1">-enqueue(v)</formula><p>adds value v to the queue -dequeue() returns values (r, v) if queue is empty, returns r = false; otherwise, returns r = true and the dequeued value v operations, and B similarly represents values returned by the operations. For our queue example, a symbolic client program T (A, B) may look as in in <ref type="figure" target="#fig_1">Fig. 2</ref>. For a given symbolic test T (A, B), let V A be the set of valuations to the variables in A, and let V B the set of valuations to the variables in V B . Given an implementation I, a memory model Y , and a symbolic test T (A, B), we define the set R T,I,Y ⊂ V A × V B to consist of all tuples (a, b) such that it is possible to observe the output values b when executing the test T with implementation I and input values a on a machine with memory model Y .</p><p>Let Π T be the set of all total orders on the invocations in T . We say an order o ∈ Π T is consistent with T (written consistent T (o)) if and only if for all invocations made by the same thread, the order in T matches the order o. Define the function g I,T : Π T × V A → V B such that g I,T (o, a) describes the return values that result from executing the invocations appearing in T in a single thread, in the order specified by o, and with input values a. We guarantee that g I,T is a well-defined function as follows:</p><p>1. We admit only implementations I whose single-threaded executions are deterministic. Where we want nondeterminism (such as for modelling memory allocation), we express it by declaring additional symbolic input values. 2. We assume that executions never deadlock. However, because deadlocks are well possible in practice, we discharge this assumption separately by performing a prior check for deadlocks using an independent SAT instance (which we do not describe further here).</p><p>With the formalism introduced above we can now precisely define operation-level sequential consistency for a given test T . If an implementation is correct for all symbolic tests T , it is guaranteed to be free of defects that are caused by concurrency; if it contains any other errors, those are guaranteed to manifest themselves in some serial execution, and can therefore be easily covered with conventional verification methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Encoding Concurrent Executions</head><p>Our first subgoal is to encode the concurrent executions in a way that is suitable for SAT solving. We show in this section how to define auxiliary variables C, M and a formula Φ T,I,Y (A, B, C, M ) such that for all (a, b) ∈ V A × V B the following holds:</p><formula xml:id="formula_2">(a, b) ∈ R T,I,Y ⇔ ∃C : ∃M : Φ T,I,Y (a, b, C, M )<label>(1)</label></formula><p>The  </p><formula xml:id="formula_3">A k = {x}, B k = {y}, C k = {c, r1, r2} Δ(A k , B k , C k ) ≡ (c = (x &lt; 0)) ∧ (r1 = 0) ∧ ((c ∧ (y = r1)) ∨ (¬c ∧ (y = r2)))</formula><formula xml:id="formula_4">Φ T,I,Y (A, B, C, M ) ≡ Θ T,I,Y (M, C) ∧ 񮽙 k Δ T,I,k (A k , B k , C k )<label>(2)</label></formula><p>The Thread-Local Formulas. For each thread k, the formula Δ T,I,k captures the connection among input values A k , intermediate values C k , and return values B k : the solutions to Δ T,I,k (A k , B k , C k ) correspond to all possible executions of thread k in an unspecified environment (that is, for arbitrary values returned by the load instructions). We obtain the encoding as follows (see <ref type="figure" target="#fig_4">Fig. 3</ref> for an example):</p><p>-Expand the invocation sequence for thread k specified in T (A, B) by inlining the implementation code I. -Unroll loop iterations. We can skip this step for this case study (and avoid the associated loss of precision) because the implementation code is already loop-free. -Compile the code into a linear, finite instruction sequence consisting of loads, stores, fences, and instructions that capture the thread-local computations. We call the latter move instructions. -Create a variable in C k for each intermediate value produced by a load or move. -For each move instruction, create constraints on the source and destination values that express the nature of the computation. Take the conjunction of these constraints to get the formula Δ T,I,k . -If the code contains conditionals, use predicates to express conditional execution of instructions. For each instruction i, define the predicate π(i) to be a boolean formula over variables in C k that captures the condition(s) under which this instruction gets executed. <ref type="figure" target="#fig_4">Fig. 3</ref> illustrates how to use predicates; we skip the further details of the compilation algorithm here.</p><p>The Communication Formula. The formula Θ T,I,Y (M, C) encodes the valid interactions between the threads as they execute load, store, and fence instructions. It thus captures the shared memory semantics of the multiprocessor, which is defined by the memory model Y.</p><p>To encode Θ T,I,Y , we first create predicated instruction streams for each thread as described in section 3.2. Let X be the set of all loads and stores appearing in these streams. Let Π X be the set of all total orders on X. Define the memory order variable M to range over Π X . We can now encode Θ T,I,Y such that its solutions have the following properties: (a) the value loaded by a load matches the last value stored to the same address (where "last" is interpreted in terms of the memory order M ), and (b) the memory order M follows the ordering axioms of the memory model.</p><p>We give a full definition for the formula Θ T,I,Relaxed describing our relaxed memory model in section 3.4; in the remainder of this section we discuss the similar but somewhat simpler case of a sequentially consistent multiprocessor only. For each memory access x ∈ X, let π(x) be its predicate (a boolean formula over the variables in C that captures the condition under which x gets executed), and let a x , v x ∈ C be the variables that represent the address and data value of x, respectively. Let L ⊂ X be the set of loads, and S ⊂ X be the set of stores. Let &lt; p be the program order; that is, &lt; p is a partial order on X such that x &lt; p y if and only if x, y are appear in the same stream, and x comes before y. Then</p><formula xml:id="formula_5">Θ T,I,SeqCons (M, C) ≡ ∀x, y ∈ X : (π(x) ∧ π(y) ∧ x &lt; p y) ⇒ x &lt; M y ∧ ∀l ∈ L : ∀s ∈ S : sees (l, s) ⇒ [ v l = v s ∨ (∃s 񮽙 ∈ S : sees (l, s 񮽙 ) ∧ s &lt; M s 񮽙 ) ]</formula><p>where</p><formula xml:id="formula_6">sees (l, s) ≡ (π(l) ∧ π(s) ∧ (a s = a l ) ∧ (s &lt; M l))<label>(3)</label></formula><p>The second line of (3) expresses that the memory order may not contradict the program order, which is the essence of sequential consistency. The third line of (3) specifies that a load gets the last value "seen", that is, the last value stored to the same address. It uses the subformula sees (l, s), which is defined on the last line of (3) and says that a load "sees" a store if and only if it succeeds it in the memory order M , goes to the same address, and both predicates are true.</p><p>The formula (3) still contains non-boolean variables and quantifiers. To obtain a CNF representation, we (a) encode non-boolean variables in A, B, or C as bitvectors, (b) expand quantifiers into finite conjunctions or disjunctions, and (c) break M down into boolean variables {M xy | x, y ∈ X} such that M xy represents x &lt; M y and add clauses to express transitivity, antisymmetry and non-reflexivity. The number of variables and clauses is then quadratic and cubic in |X|, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Encoding Correctness</head><p>We now show how to construct a formula Ψ such that (a) Ψ can be solved by a SAT solver, (b) unsatisfiability of Ψ implies correctness, and (c) given a satisfying assignment for Ψ , we can construct a counterexample trace. Such a trace shows a concurrent execution for which the serial reference execution is not observationally equivalent.</p><p>For a given test T and implementation I, a commit point specification h is understood as a function Π X → Π T that maps a given memory order m to the invocation order h(m) that reflects how m orders the commit points. Now we can define</p><formula xml:id="formula_7">Ψ T,I,Y,h ≡ ∃A : ∃B : ∃C : ∃M : Φ T,I,Y (A, B, C, M ) ∧ ( g I,T (h(M ), A) 񮽙 = B ∨ ¬consistent T (h(M )) )<label>(4)</label></formula><p>To encode the subformula g I,T (h(M ), A) 񮽙 = B in (4), we create a copy T 񮽙 (A, B 񮽙 ) of T (A, B) in which we put each invocation in a separate thread, and we define a special "memory model" Atomic, which is similar to sequential consistency but executes each thread atomically. Then g I,T (h(m), A) 񮽙 = B if and only if</p><formula xml:id="formula_8">∃B 񮽙 : ∃C 񮽙 : ∃M 񮽙 : Φ T 񮽙 ,I,Atomic (A, B 񮽙 , C 񮽙 , M 񮽙 ) ∧ h(M 񮽙 ) = h(M ) ∧ B 񮽙 = B 񮽙 (5)</formula><p>After substituting <ref type="formula">(5)</ref> into <ref type="formula" target="#formula_7">(4)</ref>, we can move all existential quantifiers to the front as required for SAT solving.</p><p>If the SAT solver determines that Ψ T,I,Y,h is unsatisfiable, it follows directly from the definitions that the implementation I is correct for the test T and memory model Y (regardless of h). However, if the SAT solver provides a satisfying assignment for Ψ T,I,Y,h , our prototype presents the corresponding concurrent and serial executions to the user. The user can then analyze the counterexample and determine whether there is a defect in the implementation or a mistake in the commit point specification h.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Encoding Relaxed Memory Models</head><p>Relaxed memory models impose fewer ordering restrictions on the instruction streams than sequential consistency; therefore R T,I,SeqCons ⊂ R T,I,L for all relaxed models L. Finding a uniform specification framework for the puzzling variety of memory models is a challenge of its own <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b26">26]</ref>. For this case study, we restricted our attention to a selection of memory models (listed in the next paragraph) that are commonly used by hardware. Moreover, we are content with a conservative approximation, that is, a model Relaxed such that R T,I,Y ⊂ R T,I,Relaxed for all memory models Y in our selection.</p><p>We compared the memory model specifications for the IBM PowerPC <ref type="bibr" target="#b19">[19]</ref>, Sun SPARC v9 TSO/PSO/RMO <ref type="bibr" target="#b20">[20]</ref>, Alpha <ref type="bibr" target="#b21">[21]</ref>, and IBM zArchitecture <ref type="bibr" target="#b22">[22]</ref>. Although there are many differences, all of the specifications are based on a similar axiomatic style: they consist of a collection of rules that describe the valid instruction orderings and how values may flow from stores to loads. This non-operational style suits our purpose well; it allows us to compare the different models and derive a common approximation Relaxed, which we now describe in detail.</p><p>First, let us describe the relaxations with respect to sequential consistency informally. We use the symbols X, M , C, S, L, π(x), a x , v x , and &lt; p as defined in section 3.2.</p><p>-Accesses to different locations by the same thread may be executed out of order: If x, y ∈ X and x &lt; p y and a x 񮽙 = a y , we may have y &lt; M x. -Loads to the same location by the same thread may be executed out of order: If l, l 񮽙 ∈ L and l &lt; p l 񮽙 and a l = a l 񮽙 , we may have l 񮽙 &lt; M l.</p><p>-Stores may be non-atomic: the stored value may be held in a thread-local buffer before becoming visible to other threads. We use &lt; M to express the time at which a store commits globally, and we adjust the definition of sees (l, s) to allow a load to see stores in the buffer. For example, if s ∈ S and l ∈ L and s &lt; p l and a s = a l , we may have l &lt; M s and sees (l, s).</p><p>Our formalization is similar to the Sparc RMO memory model axioms <ref type="bibr" target="#b16">[16]</ref>. In fact, our generic model is equivalent to the latter if we remove the RMO-specific axiom (m1) that defines how value and control dependencies influence the memory order.</p><p>If a memory ordering fence instruction appears in between two memory accesses in the code, they must execute in order. Fences affect only instructions in the same thread, and there exist specific variations (such as load-load, load-store, store-load or store-store fences) that target a subset of instructions only. Formally, let F to be the set of memory fences appearing in all instruction streams, and for each fence f ∈ F , let X f ⊂ X be the set of accesses affected by f . For example, if f is a store-load fence, then</p><formula xml:id="formula_9">X f = {s ∈ S | s &lt; p f } ∪ {l ∈ L | f &lt; p l}.</formula><p>Now we are ready to define Relaxed formally. We do so by directly specifying</p><formula xml:id="formula_10">Θ T,I,Relaxed (M, C) ≡ ∀x ∈ X : ∀s ∈ S : (π(x) ∧ π(s) ∧ a x = a s ∧ x &lt; p s) ⇒ x &lt; M s ∧ ∀l ∈ L : ∀s ∈ S : sees (l, s) ⇒ v l = v s ∨ (∃s 񮽙 ∈ S : sees (l, s 񮽙 ) ∧ s &lt; M s 񮽙 ) ∧ ∀f ∈ F : ∀x, y ∈ X f : (π(f ) ∧ π(x) ∧ π(y) ∧ (x &lt; p f &lt; p y)) ⇒ x &lt; M y where sees (l, s) ≡ π(l) ∧ π(s) ∧ (a s = a l ) ∧ (s &lt; M l ∨ s &lt; p l) (6)</formula><p>The second line of (6) specifies the conditions under which the memory order may not contradict the program order. When compared with the formula (3) for sequential consistency, we see that this line has been weakened to reflect the ordering relaxations we described earlier. The third line specifies that a load gets the last value "seen", that is, the last value stored to the same address. It is the same as for sequential consistency (3), but the definition of sees (l, s) on the last line has been modified to allow forwarding. The fourth line of (6) defines the effect of memory fences on the valid memory orderings.</p><p>The memory model Relaxed is simpler than most memory models used for actual hardware because (a) it consistently relaxes the order, for example, even data-or control-dependent instructions may be reordered, and no special measures are taken to prevent circular value flow, (b) it uses a single, generic memory ordering fence construct, (c) it does not contain specific synchronization primitives, but allows them to be expressed as atomic blocks (we omitted atomic blocks from the formalization above, but they can introduced easily by adding suitable constraints on &lt; M ), and (d) it omits unneeded details such as the behavior of instruction caches and I/O, special flushing operations, or unaligned and non-atomic memory accesses. This (relative) simplicity makes Relaxed a good model for studying the algorithms: even though it may exhibit executions that are not possible on a specific target architecture, we are made aware of all issues by verifying our code on Relaxed. Once we understand which instructions need to stay in order, it is comparatively easy to pick the right fences for a specific target architecture.</p><p>Specialized algorithms to insert memory fences automatically during compilation have been proposed <ref type="bibr" target="#b27">[27,</ref><ref type="bibr" target="#b28">28]</ref>. However, these methods are based on a conservative program analysis, and they enforce sequential consistency on the instruction level rather than the operation level. These characteristics make them unattractive for optimized implementations, because redundant fences imply suboptimal performance <ref type="bibr" target="#b29">[29]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Results</head><p>We implemented a prototype that encodes SAT instances as described in the previous chapter, solves them using zChaff <ref type="bibr" target="#b30">[30]</ref>, and converts satisfying assignments into human-readable execution traces. We first tested our prototype on some smaller examples (including the spinlock <ref type="bibr" target="#b16">[16]</ref>). Then we hand-translated the pseudo-code <ref type="figure" target="#fig_0">(Fig. 1)</ref> into the intermediate language accepted by our back-end prototype. Next, we created a suite of symbolic tests <ref type="figure">(Fig. 4)</ref> and made an initial guess at the commit points (lines 15 and 31 in <ref type="figure" target="#fig_0">Fig. 1)</ref>.</p><p>Running our prototype, we found five problems (numbered 1-5 below). First, we ran T0 on a sequentially consistent memory model, finding problem 1. Then, we ran T0 on our relaxed memory model, finding problems 2-4. Next, we ran on T1 on the relaxed model and found problem 5. After that, no more problems were found. The tests T0 and T1 alone (neither of which took more than a few seconds) therefore uncovered all the bugs found.</p><p>1. Incorrect commit point specification. We had guessed line 31 to be the commit point. The tool produced a counterexample revealing a race between the store on line 15 and the load on line 32. The outcome of this race determines the logical order of the operations, so we changed the commit point for the dequeue to be line 32 instead of line 31. 2. Incorrect modelling of dynamic memory. Our initial model for dynamic memory allocation was incorrect for relaxed memory models: the trace showed a load from a storage location inside a dynamically allocated block that took effect only after the block was freed, re-allocated by another thread, and then overwritten. This situation caused the load to get the wrong value. We fixed this problem by inserting fences into the alloc() and free() calls.  3. Missing store-store fence. On a relaxed model, the store instruction that updates the queued value (line 12) may be ordered after the load that is supposed to read it (line 38). To force the store to take effect by the time the node is linked into the list, we insert a store-store fence before the store on line 15. 4. Missing load-load fence. Symmetrically, we need to make sure that the load of the queued value (line 38) does not take effect before the load of its address on line 32. This may seem automatic -but some weak memory models (such as Alpha <ref type="bibr" target="#b21">[21]</ref>) do not enforce in-order execution of loads, even if there is a value dependency <ref type="bibr" target="#b31">[31]</ref>. Therefore, we insert a load-load memory fence after the load on line 32. 5. Incorrect modelling of locks. During the translation, we had misplaced one of the fences within the code for unlock(). It appeared after instead of before the committing store, where it is useless. Without proper fences in lock() and unlock(), memory accesses can "escape" from the critical section.</p><p>Analysis. The results indicate that our method is efficient at finding errors in highly concurrent programs, but does not scale to long program executions. As expected, zChaff was much quicker at solving satisfiable instances than at refuting unsatisfiable ones, but the choice of the memory model seemed to have a negligible effect on the runtime. We show some statistics about the programs and the resources required (for unsatisfiable instances and the relaxed memory model) in <ref type="figure" target="#fig_5">Fig. 5</ref>. The results show that making the programs longer (Tpc series, see <ref type="figure">Fig. 4</ref> for definition) is more challenging for the solver than making them more concurrent (T5 series). This result is not surprising because we chose an encoding that specializes on highly concurrent executions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions</head><p>Verifying the sequential consistency of a concurrent data type implementation on a relaxed memory model presents a challenge because of the high degree of concurrency at the instruction level and the infinite state space. In this case study, we developed a new SAT-based method that can solve a bounded formulation of this problem (using finite symbolic tests and commit point annotations) and demonstrated its practical value by applying it successfully to Michael and Scott's two-lock queue implementation. Future work includes exploring more example data structure implementations, eliminating the need for commit point specifications, automating the creation of a symbolic test suite, improving the scalability with more efficient or incremental SAT encodings, and developing a front end for the tool that would accept a subset of C as the specification of the implementation.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Michael and Scott's two-lock queue implementation [11]. The queue is represented by a dynamically allocated singly linked list with head and tail pointers, each protected by a separate lock. To simplify the empty queue case, the first node of the linked list is a "dummy" element: its value is not part of the queue.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. An example for a symbolic test T (A, B)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Formulation.</head><label></label><figDesc>The implementation I is correct for a given symbolic test T and a mem- ory model Y if and only if for all (a, b) ∈ R T,I,Y , there exists an invocation order o ∈ Π T such that o is consistent with T and b = g I,T (o, a).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>variable M represents the memory order; different valuations to M correspond to different instruction interleavings (and possibly reorderings). C is a set of variables that represent intermediate values of the computation. Each variable that represents an input, intermediate, or return value is local to a thread k, and we partition A = 񮽙 k A k , B = 񮽙 k B k , C = 񮽙 k C k accordingly. The formula Φ T,I,Y then decomposes (a) Implementation code for the (b) Symbolic instruction stream for operation func the expanded invocation y = func(x) var arr : array[8] of int op func(int index) returns int if (index &lt; 0) then return 0 else return arr[index] endif endop move (x &lt; 0), c [+c] move 0, r1 [-c] load arr[x], r2 move (c ? r1 : r2), y (c) Corresponding formula over</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Example of the thread-local encoding</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Some experimental data. All resource requirements are reported by the zChaff solver (version 2004/11/15) and refer to unsatisfiable instances using a relaxed memory model. The tests were run on a 3 GHz Pentium 4 desktop Linux PC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>1000</head><label></label><figDesc></figDesc><table>Program name 
T0 
T1 
T5-3 
T5-4 
T5-5 
T5-6 
Tpc4 
Tpc6 
Thread 1 sequence 
e 
e 
e e e e 
e e e 
e e 
e 
e e e e 
e e e e e e 
Thread 2 sequence 
d 
e 
d 
e 
e 
e 
d d d d 
d d d d d d 
Thread 3 sequence 
d 
d 
d 
e 
e 
Thread 4 sequence 
d 
d 
d 
e 
Thread 5 sequence 
d 
d 
Thread 6 sequence 
d 

Fig. 4. A selection of the symbolic tests we used. The letters e and d represent calls to the enqueue 
and dequeue operation (with symbolic arguments). All calls operate on the same queue object. Program Characteristics 
SAT encoding 
Requirements 
threads operations instructions loads stores variables clauses memory [kB] time [s] 
T0 
2 
2 
65 
12 
18 
551 
4,081 
332 0.004 
T1 
4 
4 
119 
23 
30 
1,514 
44,479 
4,165 0.87 
T5-3 3 
6 
163 
31 
44 
3,380 160,516 
16,246 9.33 
T5-4 4 
6 
163 
31 
44 
3,400 167,456 
16,308 21.1 
T5-5 5 
6 
163 
31 
44 
3,413 173,324 
16,357 35.4 
T5-6 6 
6 
163 
31 
44 
3,419 179,109 
16,401 42.8 
Tpc2 2 
4 
119 
23 
30 
1,504 
42,829 
4,151 0.139 
Tpc3 2 
6 
173 
34 
42 
3,717 170,116 
16,320 5.23 
Tpc4 2 
8 
227 
45 
54 
5,797 430,445 
33,372 45.7 
Tpc5 2 
10 
281 
56 
66 
8,315 877,624 
100,462 300.0 
Tpc6 2 
12 
335 
67 
78 
11,271 1,549,090 
131,087 886.3 
Tpc7 2 
14 
389 
78 
90 
12,394 2,438,721 
n/a &gt; </table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Software and the concurrency revolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Sutter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Larus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Queue</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="54" to="62" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Wait-free synchronization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="124" to="149" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Concurrent reading while writing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">L</forename><surname>Peterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="46" to="55" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Concurrent reading and writing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="806" to="811" />
			<date type="published" when="1977" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Shared memory consistency models: a tutorial</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Gharachorloo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="66" to="76" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">How to make a multiprocessor computer that correctly executes multiprocess programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comp., C</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="690" to="691" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">VYRD: verifying concurrent programs by runtime refinement-violation detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Elmas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tasiran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming Language Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="27" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A tool for checking ANSI-C programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Lerda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools and Algorithms for the Construction and Analysis of Systems (TACAS)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004" />
			<biblScope unit="volume">2988</biblScope>
			<biblScope unit="page" from="168" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Memory-model-sensitive data race analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gopalakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lindstrom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Formal Engineering Methods (ICFEM)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004" />
			<biblScope unit="volume">3308</biblScope>
			<biblScope unit="page" from="30" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">QB or not QB: An efficient execution verification tool for memory orderings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gopalakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Sivaraj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer-Aided Verification (CAV)</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="volume">3114</biblScope>
			<biblScope unit="page" from="401" to="413" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Simple, fast, and practical non-blocking and blocking concurrent queue algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">L</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Distributed Computing (PODC)</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="267" to="275" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Proving correctness of highlyconcurrent linearisable objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vafeiadis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Hoare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles and Practice of Parallel Programming (PPoPP)</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="129" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Bounded model checking of concurrent programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Rabinovitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer-Aided Verification (CAV)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005" />
			<biblScope unit="volume">3576</biblScope>
			<biblScope unit="page" from="82" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Automatically verifying concurrent queue algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Yahav</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electr. Notes Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">89</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Linearizability: a correctness condition for concurrent objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">P</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="463" to="492" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Burckhardt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An executable specification, analyzer and verifier for RMO (relaxed memory order)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Parallel Algorithms and Architectures (SPAA)</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="34" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Formal specification of abstract memory models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">G</forename><surname>Nowatzyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Research on Integrated Systems</title>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="38" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Eraser: A dynamic data race detector for multithreaded programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Savage</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sobalvarro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comp. Sys</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="391" to="411" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">PowerPC Architecture Book v2.02. International Business Machines Corporation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Frey</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">The SPARC Architecture Manual Version 9</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Weaver</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Germond</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Compaq Computer Corporation. Alpha Architecture Reference Manual</title>
		<imprint>
			<date type="published" when="2002-01" />
		</imprint>
	</monogr>
	<note>4th edition</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">International Business Machines Corporation. z/Architecture Principles of Operation</title>
		<imprint>
			<date type="published" when="2000-12" />
		</imprint>
	</monogr>
	<note>first edition</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Analyzing the Intel Itanium memory ordering rules using logic programming and SAT</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gopalakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Slind</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Correct Hardware Design and Verification Methods (CHARME)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003" />
			<biblScope unit="volume">2860</biblScope>
			<biblScope unit="page" from="81" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Model-checking of correctness conditions for concurrent objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Peled</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic in Computer Science (LICS)</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="219" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A unified theory of shared memory consistency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">C</forename><surname>Steinke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">J</forename><surname>Nutt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="800" to="849" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Nemos: A framework for axiomatic and executable specifications of memory consistency models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gopalakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Slind</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Parallel and Distributed Processing Symposium (IPDPS)</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Efficient and correct execution of parallel programs that share memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Shasha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Snir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="282" to="312" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Automatic fence insertion for shared memory multiprocessing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Midkiff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Supercomputing (ICS)</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="285" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Conditional memory ordering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Von Praun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Cain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ryu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Computer Architecture (ISCA)</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Chaff: Engineering an efficient SAT solver</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Moskewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Madigan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="530" to="535" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Correctly implementing value prediction in microprocessors that support multithreading or multiprocessing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Sorin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Cain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lipasti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Microarchitecture (MICRO)</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="328" to="337" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
