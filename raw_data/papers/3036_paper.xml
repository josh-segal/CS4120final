<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:43+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Shape Segmentation and Applications in Sensor Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xianjin</forename><surname>Zhu</surname></persName>
							<email>xjzhu@cs.sunysb.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Stony Brook University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rik</forename><surname>Sarkar</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Stony Brook University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jie</forename><surname>Gao</surname></persName>
							<email>jgao@cs.sunysb.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Stony Brook University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Shape Segmentation and Applications in Sensor Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Many sensor network protocols in the literature implicitly assume that sensor nodes are deployed uniformly inside a simple geometric region. When the real deployment deviates from that, we often observe degraded performance. It is desirable to have a generic approach to handle a sensor field with complex shape. In this paper, we propose a segmentation algorithm that partitions an irregular sensor field into nicely shaped pieces such that algorithms and protocols that assume a nice sensor field can be applied inside each piece. Across the segments, problem dependent structures specify how the segments and data collected in these segments are integrated. This unified topology-adaptive spatial partitioning would benefit many settings that currently assume a nicely shaped sensor field. Our segmentation algorithm does not require sensor locations and only uses network connectivity information. Each node is given a &apos;flow direction&apos; that directs away from the network boundary. A node with no flow direction becomes a sink, and attracts other nodes in the same segment. We evaluate the performance improvements by integrating shape segmentation with applications such as distributed indices and random sampling.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Sensor networks have a unique geometric character as sensor nodes are embedded in, and designed to monitor, the physical environment. Thus the physical locations of sensor nodes have a fundamental influence on the system design in all aspects from low-level networking and organization to high-level information processing and applications. Clearly sensor placement affects connectivity and sensing coverage, which subsequently affects basic network organization and networking operations. Recently a number of research efforts have identified the importance of not only sensor locations, but also the global geometry and topological features of a sensor field. The 'topology' here means algebraic topology and refers to holes or high-order features. In the literature, uniformly random sensor deployment is arguably the most commonly adopted assumption on sensor distribution -but is rarely the case in practice. Many algorithms and protocols proposed for a dense and uniform sensor field inside a simple geometric region, may have degraded performance when they are applied to an irregular sensor field with holes, etc.</p><p>Let us use routing as an example. Geographical routing, in which a packet is greedily forwarded to the neighbor that is geographically closest to the destination <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>, has attracted a lot of interests. It is simple, elegant, and has little routing overhead. In a dense and uniform sensor field with no holes, geographical forwarding produces almost shortest paths and is robust to link or node failures and location inaccuracies.</p><p>However, when the sensor field is too sparse, has holes or a complex shape, greedy forwarding fails at local minima. This is due to a mismatch of routing/naming rules with the real network connectivity. Two nodes that are geographically close may actually be far away in the connectivity graph. Thus, when these topological features (e.g., holes) become prominent, the naming and its coupled routing protocol should represent the real network connectivity and adjust to these topological features accordingly <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>.</p><p>Beyond geographical routing, the global topology of a sensor field has fundamental influence on how information gathered in the network should be processed, stored and queried. In a sensor field with narrow bottlenecks, more aggressive in-network processing is expected to minimize the traffic flowing through bottleneck nodes. In a distributed storage scheme, the global geometry should be taken into account to achieve better load balance on storage nodes. Many existing information processing algorithms do not account for the global geometry of a sensor field yet. A typical example is the quadtree type of geometric decomposition hierarchy, which has been extensively used to exploit spatial correlation in sensor data (e.g., DIFS, DIM <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref>) for efficient multiresolution storage. In a sensor field with holes, a standard geometric quadtree (the bounding rectangle is partitioned into 4 equal-size quadrants recursively) may become unbalanced with lots of big empty leaf blocks. An imperfect partition hierarchy subsequently affects the performance, especially load balance, of all algorithms and data structures built on top of it. In another example, random sampling of a sensor node can be conducted by choosing the node closest to a random location. To achieve a uniform distribution, the sampling probability needs to be adjusted by the area of the corresponding Voronoi cell <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>. In an irregular sensor field, the Voronoi cells have vastly varying areas. Thus the sampling efficiency suffers as a lot of trials end up being rejected.</p><p>One approach to deal with irregularly shaped sensor field is to develop virtual coordinates with respect to the true network connectivity, as in the case of routing <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>. One may follow this line and re-develop algorithms for all the other problems on virtual coordinate systems. Both the development of virtual coordinates and topology-adaptive algorithms on top of that are highly non-trivial. In this paper, we propose to develop a unified approach to handle complex geometry. We propose a segmentation algorithm that partitions an irregular sensor field into nicely shaped pieces such that algorithms that assume a uniform and dense sensor distribution can be applied inside each piece. Across the segments, problem dependent structures specify how the segments and data collected in these segments are integrated. This unified topology-adaptive spatial partitioning would benefit many settings that currently assume sensor field with nice simple shape. There is not much prior work on segmenting a sensor field. The mostly related one by <ref type="bibr">Kröller et al. [10]</ref> proposed a boundary detection algorithm with which one can organize sensor nodes by 'junctions' and 'streets'. Our goal is to further explore segmentation algorithms suitable for a discrete sensor field as well as applications that can benefit from it.</p><p>In this paper, we consider a static sensor network with an irregular shape. We take the viewpoint to regard the sensor network as a discrete sampling of the underlying geometric environment and develop a 'shape segmentation' algorithm. This is motivated by the fact that sensor networks are to provide dense monitoring of the embedded space. The analysis of geometric shapes has been extensively studied in graphics and computational geometry with many shape segmentation algorithms proposed in the literature <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b14">[15]</ref>. These algorithms typically work in a centralized setting with ample computational resources. Shape segmentation problem for a discrete sensor field faces a number of new challenges, and requires non-trivial algorithm design to achieve sufficient robustness to input inaccuracies.</p><p>• Sensor nodes start with no idea of the global picture.</p><p>We consider the approach of collecting all information at a centralized node not a scalable solution. Segmentation algorithm needs to be automatic and distributed in nature.</p><p>• Sensor nodes may not know their geographical locations -automatic and scalable localization (without GPS) is still a challenging problem. Even when they do, the locations may come with large inaccuracies. • When sensor locations are not available, the distance between two nodes is often approximated by their minimum hop count value, which is always an integer. This rough approximation introduces inevitable noise to any geometric algorithms that use the hop count to replace the Euclidean distance.</p><p>We propose to adapt a shape segmentation scheme by using flow complex <ref type="bibr" target="#b10">[11]</ref> to sensor networks. The algorithm uses only the connectivity information and does not assume that sensors know their locations. We first discover all the hole boundaries and the outer boundary, say by the algorithm developed by <ref type="bibr">Wang et al. [16]</ref>. We let the boundary nodes flood inward and every node records the minimum hop count from the boundary. Each node is then given a 'flow direction', the direction to move away fastest from boundaries. A node may be singular with no flow direction and is named as a sink <ref type="bibr" target="#b0">1</ref> . The sensor field is partitioned to segments in a way that nodes in the same segment flow to the same sink. This naturally partitions the sensor field along narrow necks. In the geometric version, all the sinks stay on the medial axis of the field, which is the set of points with at least two closest points on the boundary and constitutes a 'skeleton' of the shape. In a discrete network sinks may appear far away from the medial axis due to local noises and connectivity disturbances. In addition, in degenerate cases such as a corridor with parallel boundaries, many nodes on the medial axis may be identified as sinks. We apply a local merging process such that nearby sinks along the medial axis with similar hop counts from the boundary, together with their corresponding segments, are merged. In the end, each segment is given a unique identifier by the sink(s). All the nodes in the same segment are informed of the identifier distributed along the reversed flow pointers. The algorithm is communication efficient. It involves a couple of limited flooding from the boundary nodes to the interior of the network. All the other operations only involve local computations. With given boundaries, the segmentation algorithm incurs a total transmission cost of O(n).</p><p>We tested the segmentation algorithm under various topologies and node density. We observed intuitive segmentation along narrow necks in a sensor field with reasonable node degree (around 7 ∼ 8). To show the benefit of segmentation, we evaluated the performance improvements by integrating segmentation algorithm with two existing algorithms that currently assume a uniform sensor field: a distributed index for multi-dimensional data (DIM) <ref type="bibr" target="#b6">[7]</ref> and random sampling <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>. For both algorithms, we show that in an irregular sensor field, the segmentation algorithm provides improved performance and load balance. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. NOTATIONS AND DEFINITIONS</head><p>We first introduce some notations and definitions defined in the continuous domain <ref type="bibr" target="#b10">[11]</ref>. In the next section we show how to adapt them in a discrete network. For a connected continuous region R, denote by B the boundaries, represented by a set of closed curves, each bounding either an inner hole or the outer boundary. For a point x ∈ R, the distance from x to the boundaries is define by h(x) = min{||x − p|| 2 : p ∈ B}. The medial axis is the set of points in R with at least two closest points on the boundary. The distance function h is continuous, and smooth everywhere except points on the medial axis. We call a point x a critical point, or a sink, if x is inside the convex hull of its closest points on B, denoted by H(x). For example, sink s 1 has three closest points on the boundary and stays inside the triangle spanned by them. Obviously all the sinks stay on the medial axis. All non-critical points are called regular. <ref type="bibr">The driver, d(x)</ref>, is defined as the closest point in H(x) (e.g., in <ref type="figure" target="#fig_0">Figure 2</ref>, the driver of p 1 is the smaller black dot). For a point not on the medial axis, its driver d(x) is the unique closest point on B, e.g., p 2 in <ref type="figure" target="#fig_0">Figure 2</ref>. For a sink, the driver is itself. Now the flow is defined as a unit vector</p><formula xml:id="formula_0">v(x) = x−d(x) ||x−d(x)|| (i.</formula><p>e., the direction that points away from its driver), if x = d(x) and 0 otherwise. It has been proved in <ref type="bibr" target="#b10">[11]</ref> that all the points will flow to sinks. The stable manifold of a sink x, denoted as S(x) is simply the set of points that flow to it by following the flow directions. In <ref type="figure" target="#fig_0">Figure 2</ref> there are a total of three sinks and two large stable manifolds (the stable manifold for s 2 is just a line segment, called a degenerate segment). Sinks s 1 and s 3 correspond to local maxima of the distance function h(x), sink s 2 is a saddle point. The sink can be considered, to some extent, a 'center' of the segment. Rigorously, we have the following theorem. Define a ball centered at a point to be locally maximal if the ball is entirely inside the shape and by moving the center of the ball infinitesimally one cannot enlarge the size of the ball. Theorem 2.1. All locally maximal balls are centered at sinks.</p><p>Proof: Consider a locally maximal ball B centered at node x. If x is not a sink, it must have a flow direction. Then B will become larger if the center of the ball is shifted a small distance in the direction of the flow, because the distance function increases along the follow direction. This contradicts to the fact that B is locally maximal. So x must be a sink.</p><p>This theorem gives some property of the non-degenerate segments induced. Intuitively, we want to obtain a few number of large and 'fat' pieces. One way to measure the fatness of a segment S(x) is to consider the largest ball, completely inside R, centered at a point inside S(x) (this ball can stick out of the segment) against the minimum enclosed ball of S(x). Theorem 2.1 says that we obtain k non-degenerate segments, with k equivalent to the number of locally maximal balls -the largest ball centered inside S(x) is exactly the locally maximal ball centered at the sink x. If we merge two segments, the fatness of the resulting segment will be hurt since the size of the largest ball inside the segment does not increase but the size of the minimum enclosed ball may increase. One may improve the fatness of segments by reducing the sizes of the minimum enclosed balls, at the expense of introducing more segments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. SEGMENTATION ALGORITHM</head><p>The flow and stable manifolds described in section II naturally partition a continuous domain into segments along narrow necks -each stable manifold is a segment. In this section we show how to implement the flow and the segmentation in a discrete sensor field, when we do not have node location information, nor the distance function. Unlike the continuous case, here we approximate the Euclidean distance function to the boundary by the minimum hop count to boundary nodes. As for the notion of closest points on the boundary, an interior node x has one or more closest intervals -each interval is a consecutive sequence of nodes on the boundary with minimum hop count from x. We want to find, for each sensor x, a flow pointer that points to one of its neighbors, in order to move 'fastest' away from the boundary. The challenge is to assign these flow pointers and identify the sinks in a robust way such that there is no loop and an intuitive segmentation can be derived. We describe an outline of the algorithm followed by the details of each step.</p><p>1) Boundary detection. Find the boundaries of the sensor field using the algorithm described in <ref type="bibr" target="#b15">[16]</ref>. This algorithm identifies boundary nodes and connects them into cycles that bound the outer boundary and interior hole boundaries of the sensor field. 2) Construct the distance field. The boundary nodes simultaneously flood inward the network and each node records the minimum hop count to the boundary, as well as the interval(s) of closest nodes on the boundary.</p><p>Nodes on the medial axis can identify themselves as they have two or more closest intervals. 3) Compute the flow. Each node x computes a flow pointer that points to its parent -the neighbor with a higher hop count from the boundary and the most symmetric closest intervals on the boundary among all such neighbors. Nodes on the medial axis with no neighbor of higher hop count become sinks. See <ref type="figure" target="#fig_1">Figure 1</ref>(i) and (ii). 4) Merge nearby sinks. Nearby sinks on the medial axis with similar hop count from the boundary are merged into a sink cluster and agree on a single segment ID. 5) Segmentation. The nodes that ultimately flow to the same sink cluster are grouped into the same segment. We let each sink disseminate the segment ID along the reversed parent pointers. See <ref type="figure" target="#fig_1">Figure 1</ref> (iii) for the merged segments. 6) Final clean-up. Due to irregularities in node distribution, some nodes have locally maximum hop count to boundary but do not stay on medial axis -thus didn't get recognized as sinks. These, and nodes that flow into them are left orphan. In the final clean-up phase, we merge the orphan nodes to their neighboring segments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Boundary detection</head><p>We use the boundary detection algorithm proposed by <ref type="bibr">Wang et al. [16]</ref> to identify boundaries with the connectivity information. The boundaries of inner holes and outer boundary are assigned unique identifiers, and nodes along each boundary cycle are assigned ordered sequence numbers. Every boundary node thus knows the identifier and the length of the boundary to which it belongs, and its own sequence number on that boundary. We refer to the set of nodes on boundary j as B j .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Construct the distance field</head><p>With the boundary nodes identified, we construct a distance field such that each node is given a minimum 'distance' to the sensor field boundary. Since we do not assume location information, our only measure of distance in the network is the number of hops to the boundary nodes. The problem is that a node typically has more than one nearest boundary nodes with the same hop counts away (thus may be identified to be on the medial axis). Hence we keep not the closest node but the interval of closest nodes. An interval I on the j th boundary cycle is simply a sequence of nodes along the boundary cycle. It can be represented uniquely by a 4-tuple (j, start I , end I , |B j |), where start I and end I are the two end points, |B j | is the length of the j th boundary.</p><p>We have the boundary nodes synchronize among themselves <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b17">[18]</ref> and start to flood the network at roughly the same time. The boundary nodes initiate a flood with messages of the form (I, h) where I is an interval nearest to the transmitting node, and h is the distance to nodes in I. A node p keeps track of the set S p of intervals of boundary nodes nearest to it. On receiving a message (I, h), a node p compares h to its current distance h p to the boundary:</p><p>• If h &gt; h p , discard the current message.</p><p>• If h &lt; h p , discard all existing intervals, set h p := h, S p := {I} and send (I, h + 1) to all neighbors.</p><p>• If h = h p , merge I with adjacent and overlapping intervals on the same boundary if there is any. Otherwise, simply add I into S p . Send (I, h + 1) to all neighbors. After this computation of sets of nearest intervals for all nodes in the network, nodes on the medial axis can be identified as follows: Definition 3.1. Nodes on medial axis: A node p is a medial axis node if |S p | &gt; 1.</p><p>Note that our definition of medial axis differs from that used in existing articles (e.g. <ref type="bibr" target="#b4">[5]</ref>). What is the most appropriate analog of the continuous medial axis in a discrete network is yet to be debated. We find this definition quite robust and most suitable for our purposes. <ref type="figure" target="#fig_1">Figure 1 (i)</ref> shows the medial axis of the fish network found with this protocol. The protocol described above is easy to implement and works well in simulations. As pointed out in <ref type="bibr" target="#b4">[5]</ref>, if all boundary nodes initiate the flood at about the same time, then this method keeps the total communication cost very low. The distance field can also be constructed with two rounds of boundary flooding: in the first round each node records the hop count to the boundary; in the second round each node broadcasts their closest intervals. To simplify the theoretical analysis of message complexity, we use the two-round version in Section III-G. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Compute the flow pointer</head><p>Once each node p learns its minimum distance h p from the boundaries and the intervals of closest nodes at distance h p from it, it can construct the flow pointer and find sinks locally. Observe that for any pair of neighboring nodes p and q, if h p &lt; h q , then the closest intervals of p must be included in the closest intervals of q. Rigorously, ∀ I ∈ S p , ∃ I ∈ S q such that I ⊆ I .</p><p>Each node creates a flow pointer to its parent, the neighbor who is strictly further away from the boundary than itself, and whose closest intervals are most symmetric with respect to its own closest intervals. In <ref type="figure" target="#fig_2">Figure 3</ref>, node p selects node b as its parent v(p) because the mid point of b's interval is closer to the mid point of its own interval. The intuition behind this is to select the neighbor that represents the best movement away from all parts of the boundary. We make this notion rigorous by defining the angular distance of two neighboring nodes.  Using the function δ, each node p selects a neighbor q such that h p &lt; h q , and the sum of distances from the mid points of its intervals to the corresponding intervals of q is less than that for any other neighbor of p.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.4. Flow pointer:</head><p>Let H p be p's neighbors with higher hop count from the boundary, i.e., h p &lt; h q , for q ∈ H p . Then the parent of p, v(p) is defined as the neighbor in H p with minimum angular distance, v(p) = arg min q∈Hp δ(p, q).</p><p>A typical node, for example p in <ref type="figure" target="#fig_2">Figure 3</ref> would have only one boundary interval nearest to it. Nodes on the medial axis have more than one such interval, in which case, the parent is chosen based on the sum of mid point distances instead of a single distance, as described above. Definition 3.5. Sink: A node c is a sink, if c is a medial axis node, and has locally maximum hop count from the boundary.</p><p>The sinks of the fish network, by this definition, are shown in <ref type="figure" target="#fig_1">Figure 1(i)</ref>. Sinks are those medial axis nodes without a parent. With the flow, the sequence of directed edges starting at any non-sink node p ends at a unique root c. Since a node p selects its parent only if its parent has a higher hop count from the boundary, there cannot be a cycle in the directed graph implied by the flow. Thus, the nodes in the network are organized into directed forests, with the nodes in the same tree flow to the same root by following their flow pointers. In a continuous domain, the stable manifolds of the sinks form the segments. In a discrete network, the analog of the stable manifold of a sink c would be the directed tree rooted at c, such that any directed path in this tree ends at c.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Merge nearby sinks</head><p>One can take the stable manifolds of the sinks, i.e., the trees rooted at the sinks, as the segmentation. But this may result in a heavily fragmented network (see <ref type="figure" target="#fig_1">Figure 1(ii)</ref>). This happens when there are a cluster of sinks on the medial axis, and there is a tree rooted at each. This situation becomes severe when some parts of boundaries run parallel to each other. See <ref type="figure" target="#fig_3">Figure 4</ref> (i). In this case we have a sequence of nodes on the medial axis where no node is farther from the boundary than its neighbors, and all these nodes become sink nodes.</p><p>We would like to merge nearby sinks with similar distances from boundary as well as their corresponding segments. We call the merged sinks a sink cluster. A sink cluster K is represented by the tuple (id, h max , h min ), where id is the minimum ID of all the sinks in the cluster, i.e., the ID of the leader of the cluster. h max and h min are the maximum and minimum distances from any sink to the boundary respectively. We set a user defined threshold t to guarantee that |h max −h min | ≤ t. Each sink node waits for a random interval to start the merging process to avoid contention. Initially each sink is by itself a sink cluster, and also a sink cluster leader. A sink cluster leader searches along the medial axis for nearby sinks (or sink clusters) to be merged. Specifically, a sink cluster leader c sends a search message of its current sink cluster (id, h max , h min ) to all neighboring nodes on the medial axis. Each medial axis node p of cluster (id , h max , h min ), on receiving this message, executes the following rule (let H max = max(h max , h max ) and H min = min(h min , h min )) : • if |H max − H min | &gt; t, discard the message.</p><p>• else forward the message to all neighboring nodes on the medial axis. Furthermore, if p is a sink cluster leader, p would like to merge its sink cluster with c's sink cluster. In the second case, when p wants to be merged, it sends a merging request with (id , h max , h min ) to c and waits for the response. The leader node c makes merging decision based on its latest h max and h min values at the time the request reaches c (as c may have merged with other sink clusters before it receives the request from p) and selects the smallest sink ID in the merged cluster as the new cluster leader and cluster ID. We can suppress messages by only sending out merging response after a sink receives a few merging requests, so that a set of merged sink clusters can be updated simultaneously. Note that the handshake is carried out by cluster leaders, and search messages die out when they reach nodes on the medial axis with hop count too large or too small. When a new cluster appears, its cluster leader sends out a new search message looking for sink clusters to be merged. The process terminates automatically when no merging request is received after a timing threshold. In a sparse network when the medial axis is not connected, we search 2 or 3 hop neighbors for nearby medial axis nodes.</p><p>The variable t is a threshold defined by the user. It determines the granularity of segmentation. Smaller values of t imply that merging step will stop at a small change of the distance from the boundary and hence collect fewer sinks together into sink clusters. Thus there will be more segments created by the algorithm. For larger values of t, the algorithm will create fewer and larger segments. <ref type="figure" target="#fig_4">Figure 5</ref> shows the differences caused by variation in the value of t. In many such situations, the most preferable segmentation is likely to be dependent on the nature of the application. We leave it to the user's discretion to set the value of t. Note that the user can change the value of t even after the network has been deployed by flooding a message from any one node in the network. This would require a re-computation of only the last three steps of the algorithm, starting at merging of sinks. A second approach to merge sinks and segments is to use second derivative of distance field. The idea is that nodes around a narrow neck may have significant difference on minimum hop counts to the boundary. Every node can calculate the second derivative of the distance to the boundary locally. Merging starting at any cluster leader would stop at a node with distinct different second derivative value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Segmentation</head><p>Each sink cluster defines a segment, as all the trees rooted at nodes in the sink cluster. To create the segments of the network, each sink node c propagates the ID of the sink cluster to all the nodes in the tree rooted at c. This can be simply done by reversing the flow pointers. The ID of the sink cluster is also considered as the ID of the segment. <ref type="figure" target="#fig_1">Figure 1</ref>(iii) and <ref type="figure" target="#fig_3">Figure 4</ref>(ii) show the result of this construction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F. Final clean-up</head><p>Due to noises and local disturbances, it is possible that some nodes have locally maximum hop count to the boundary, but are not medial axis nodes. This is likely to happen in sparser regions of the network or near the boundaries if the boundaries detected are not tight. In such cases, the node at the local maximum and all nodes in the tree rooted at it are left without any segment assignment. We refer to such nodes as orphan nodes (e.g., the grey nodes in <ref type="figure" target="#fig_1">Figure 1(iii)</ref>). At the final cleanup stage, we assign the orphan nodes to a nearby segment. In a connected network, there always exists an orphan node p such that some neighbor q of p is not orphan. Each such node p selects randomly a non-orphan neighbor q, and merges to that segment. This is executed by all orphan nodes until all nodes are assigned a segment. <ref type="figure" target="#fig_1">Figure 1(iv)</ref> shows the final result.</p><p>Depending on the requirements of applications, the information about the newly formed segments can be disseminated across the network. Each segment has a natural leaderthe sink node whose ID the segment takes. This sink node easily collects information about the segment such as node count, neighboring segments, bounding rectangle (if location information is available) etc. This information can be delivered to all nodes in the network, by transmitting along the medial axis and reversed flow pointers. Since the global features of the network have been abstracted into a compact presentation, each node only transmits and stores a small amount of data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G. Algorithm complexity</head><p>We analyze the complexity of the segmentation algorithm with given boundaries. The total communication cost is dominated by the second step, i.e., constructing the distance field, which incurs a couple of limited flooding. Other steps only involve local operations, so the cost is at most O(n), where n is the number of nodes in the network. For the simplicity of analysis, the second step can be implemented in two passes. In the first pass, nodes record the minimum hop count from the boundaries. If the boundary nodes flood inwards almost simultaneously, each node will receive the message from the closest boundary node earlier than any other boundary nodes, thus each node only broadcasts once and all messages received later are suppressed. In the second pass, nodes broadcast their closest intervals. Each node constructs and broadcasts its final interval after receiving messages from all neighbors with lower hop counts. In summary, the distance field can be constructed with O(n) messages. The proposed shape segmentation algorithm is efficient and incurs communication cost of O(n) in total.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H. Simulations</head><p>We simulated the algorithm for different shapes of network, and found that an intuitive partitioning into pieces with regular shape is obtained. These networks either represent practical scenarios, like an intersection of two roads <ref type="figure" target="#fig_5">(Figure 6(i)</ref>), rooms connected by a corridor <ref type="figure" target="#fig_3">(Figure 4)</ref>, or some pathetically difficult cases we come up with. Several examples are shown in <ref type="figure" target="#fig_5">Figure 6</ref>. In general, the algorithm performs consistently well when the average degree is 7 ∼ 8 or higher. Good results can be obtained for networks of low density by considering a two or three hop neighborhood in the steps of finding flow pointers, merging the sinks and constructing segments. We used a three hop neighborhood in simulations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. APPLICATIONS</head><p>In this section, we present two specific applications that benefit from shape segmentation: a distributed index for multidimensional data <ref type="bibr" target="#b6">[7]</ref> and random sampling <ref type="bibr" target="#b8">[9]</ref>. Both of these applications assume the availability of locations. Such geographical information gives a node local picture of its neighborhood, but nodes are still unaware of global features of the network. Our shape segmentation scheme actually runs without any geographical information. Simulation results show that shape segmentation improves performance in terms of communication cost and load balance. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Distributed Index</head><p>Distributed index for multi-dimensional data (DIM <ref type="bibr" target="#b6">[7]</ref>) is a quadtree type hierarchy that supports efficient multi-resolution data storage and range query. The key idea of DIM is to map an event with certain values to a specific area called as zone, and store the event with geographic routing to the node owning that zone. The zone is determined by dividing the bounding rectangle of the network alternatively with a vertical or horizontal line until there is a single node inside the zone. When a node generates an event, it estimates the destination zone based on the event value and routes it towards there.</p><p>DIM provides a scalable index structure for data storage and performs well in a network field with simple geometric topology. However, it suffers a lot from load unbalancing in a complex shaped sensor field. For a network with arbitrary shape, there will be large empty space in the bounding rectangle. Some nodes (especially those boundary nodes) must take care of a larger zone, and hence store more data than others. Overloaded nodes would be depleted faster than other nodes, which may lead to network partitioning and shorten network lifetime.</p><p>With shape segmentation, we can avoid above problems by applying DIM on each segment. Specifically, we first divide the entire event range into several sub-ranges. Let N i denote the number of nodes belonging to the i th segment, and N denote the total number of nodes. Sub-ranges are divided based on the ratio of N i /N . The first segment takes care of events within range [0, N 1 /N ), and the second segment takes care of the range [N 1 /N, (N 1 + N 2 )/N ), and so on. A new generated event is divided into several sub-events, each of which is sent towards the corresponding segments respectively. Inside each segment, the sub-event is processed in the same way as the basic DIM algorithm.</p><p>To compare the performance of DIM with and without shape segmentation, we run simulations on various network scenarios. We generated 10000 events with values uniformly distributed in a fixed range <ref type="bibr">[0,</ref><ref type="bibr">1000]</ref>, and stored them into the network. <ref type="figure" target="#fig_6">Figure 7</ref> shows the distribution of storage load for the cross network. We can see that the boundary nodes in the basic DIM structure suffer much higher loads than the rest of the network. On the other hand, with shape segmentation, since each segment has tighter bounding rectangle and each node is associated with an almost equal sized zone, data is seen to be well distributed across the network with no particular preference for occurrence of peaks. The peaks in <ref type="figure" target="#fig_6">Figure 7</ref>(i) reach 248, while the highest peak in <ref type="figure" target="#fig_6">Figure 7</ref>(ii) is only 65.</p><p>Shape segmentation also helps reduce communication cost by mapping events into more accurate locations. <ref type="table" target="#tab_2">Table I</ref> shows that the average communication cost in terms of hop counts for every event insertion is much less with shape segmentation in all three different network scenarios, viz. cross ( <ref type="figure" target="#fig_5">Fig. 6(i)</ref>), corridor <ref type="figure" target="#fig_3">(Fig. 4</ref>) and fish network <ref type="figure" target="#fig_1">(Fig. 1</ref>). In the cross and corridor network, shape segmentation saves 60% ∼ 70% cost. The gain in fish-type network is about 20%, not as significant as the previous two cases. The reason is that each piece of 'fish' does not tightly match with its bounding rectangle.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Random Sampling</head><p>We discuss the benefits of shape segmentation with another example -random sampling. Uniform random sampling of a sensor node is a fundamental operation that is used as a basic element in many scenarios such as gossip <ref type="bibr" target="#b8">[9]</ref> and information diffusion and storage <ref type="bibr" target="#b18">[19]</ref>.</p><p>The basic sampling procedure works as follows <ref type="bibr" target="#b7">[8]</ref>. A node who wants to pick a random sensor in the network first chooses a random geographical location inside the bounding rectangle, and uses geographical routing to route towards that location. The message will eventually arrive at the node closest to the picked location. A node p is picked with a probability proportional to the area of its Voronoi cell. To achieve a uniform sampling distribution, the acceptance probability of sampling at each node needs to be adjusted, as the one with a large Voronoi cell is more likely to be picked. Basically, each sampled node will be accepted with probability r i = min(τ /a i , 1), where τ is a given threshold and a i is the area of the Voronoi cell associated with node i. If a node rejects a sample, it will pick a new location and repeat the above process. In an irregular sensor field, the Voronoi cells of different nodes have vastly varying areas. Nodes with large Voronoi cells are picked more likely, yet often get rejected afterwards. Thus, the sampling efficiency suffers as a lot of trials end up in vain. Furthermore, since the fate of each sample can only be determined at the destination node, samples may be rejected after traveling a long path, which incurs expensive communication cost and wastes network resources.</p><p>Random sampling integrated with shape segmentation can dramatically reduce the number of unnecessary trials, at the same time achieving uniform sampling. The adapted algorithm runs as follows. Each time before sampling, we first randomly select a segment. Each segment is selected with probability P i = N i /N . After that, we pick a random location within the bounding rectangle of the selected segment. Within each segment we apply the same sampling algorithm and sampling rejection policy as before. Segments are divided into Voronoi cells with much smaller variation, thus no node would reject samples with abnormally high probability.</p><p>We run simulations on the same three typical networks. Results are averaged on 10 rounds, and in each round, we randomly pick 100 samples. For the basic random sampling algorithm, we set τ to the ratio of the size of the network field and the total number of nodes. Each segment has its own τ as the ratio of the segment size and number of nodes belonging to that segment. In <ref type="table" target="#tab_2">Table II</ref>, we compare the average number of trials taken to get 100 samples. The basic random sampling algorithm tried 168, 149 and 136 times for 'cross', 'corridor' and 'fish' respectively. Shape segmentation reduces the number to 112, 115 and 123.   With the same observation we got in DIM, shape segmentation shows different levels of improvements in different network scenarios. For these two applications, the performance more or less depends on whether the bounding rectangle is tight enough. We notice that this is due to an inherent assumption of the basic sampling algorithm that uses a bounding rectangle on the sensor field. Further improvement can be made by using a tighter polygon to approximate the shape of the segment in the basic sampling algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Discussion</head><p>We mainly presented the integration of shape segmentation with applications that assume simple geometric regions and rely on geographical locations. But the applications of shape segmentation can go beyond that. For example, the recent work on information dissemination and collection <ref type="bibr" target="#b19">[20]</ref> can be directly integrated with shape segmentation. Here, we further discuss a few more fundamental applications. 1) Loadbalanced routing: Segmentation gives a high level map of the underlying network field. With proper traffic information in each segment, we can choose routes with lighter load to avoid congestion and improve load balance. For example, in a sensor network monitoring two big rooms connected by a couple of corridors with different capacity, from one room to the other, we can distribute traffic based on the capacity of each corridor. 2) Data aggregation: Data aggregation is used extensively to explore the data correlation and reduce messages transmitted. However, it is not a trivial problem to place aggregation sinks without the knowledge of the global topology. With shape segmentation, critical points are naturally the candidates of aggregation sinks. The flow pointers for nodes inside each segment naturally form the aggregation tree. Furthermore, by aggregating data within each segment first, we can dramatically reduce network traffic through bottlenecks. 3) Designing virtual coordinate system: Shape segmentation even benefits the construction of virtual coordinate systems. Take a landmark-based routing scheme <ref type="bibr" target="#b3">[4]</ref> for an example in which the placement of landmarks has a critical impact on its performance. Since the segments capture useful geometric features, like holes, concavity, etc, a few landmarks inside each segment would suffice for routing in and between segments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. CONCLUSION</head><p>In this paper we introduced a simple distributed algorithm that partitions an irregular sensor field into nicely shaped segments, by using the connectivity information. We show that segmentation is a generic approach to handle complex geometric features and improve the performance of algorithms that assume a nice regular sensor field. We expect that more applications will benefit from this general approach with improved performance in an irregular sensor field.</p><p>In shape segmentation, a generally unsolved issue is that there is no well accepted definition on good segmentation so far. The choice of appropriate segmentation may also depend on the applications. For example, a spiral-like sensor field is equivalently nice as a long corridor for routing protocols, but it needs to be segmented further for applications that require a quad-tree type hierarchy. Therefore, it is always an open choice for the upper level applications to pick a definition and choose proper segmentation granularity. One interesting problem is to classify applications into several categories so that more precise segmentation definitions can be found for each category. We regard this as our future work.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Two regular points (p 1 and p 2 ) with their flow vectors. Sinks (s 1 , s 2 and s 3 ) stay inside the convex hull of their closest points on the boundary.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>The fish network. 5000 nodes, Avg. degree 8. Boundary nodes are shown in black. (i) Medial axis nodes shown in dark green. Sink nodes shown in red. (ii) The stable manifolds of the sink nodes, shown in different colors. (iii) Nearby sinks with similar hop counts to the boundary, along with their stable manifolds, are merged. Orphan nodes shown in grey. (iv) The final result after processing orphan nodes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Node p selects node b as its parent v(p), as b is the more symmetric neighbor. The closest intervals of node p, b, c are shown.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. The corridor network. (i) Opposite boundaries run parallel to each-other, producing several sinks in succession, resulting in the fragmented segmentation. (ii) Segmentation after merging nearby sinks with similar distances to the boundary.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Network with 2200 nodes, with avg 6 neighbors per node. Segmentation with threshold (i) t = 2; (ii) t = 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>Segmentation results for miscellaneous shapes and densities. (i) cross: 2200 nodes, avg 12 neighbors per node. (ii) cactus: 2100 nodes, avg 9 neighbors per node. (iii) airplane: 1900 nodes, avg 7.8 neighbors per node. (iv) gingerman: 2700 nodes, avg 8 neighbors per node. (v) hand: 2500 nodes, avg 6.5 neighbors per node. (vi) single-hole: 3700 nodes, avg 13 neighbors per node. (vii) spiral: 2900 nodes, avg 11 neighbors per node. (viii) smiley: 2900 nodes, avg 8 neighbors per node. (ix) star: 3900 nodes, avg 9 neighbors per node.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7 .</head><label>7</label><figDesc>(i) Distribution of storage load in basic DIM structure. (ii) Distribution of storage load in shape segmentation integrated DIM structure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>for an inter- val I defined on the boundary j, is the |I|+1 2 -th element in the continuous sequence modulo |B j | of I, if |I| is oddbetween neighboring nodes p and q where h p &lt; h q is defined as δ(p, q) = I∈Sp min I ∈Sq |mid(I) − mid(I )|, I and I must be on the same boundary.</head><label></label><figDesc></figDesc><table>Definition 3.2. Mid point: The mid point mid(I) , else it is 
the mean of the ( |I| 
2 )-th and the ( |I| 
2 + 1)-th elements. 

Definition 3.3. Angular distance: The angular distance 
δ(p, q) </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>TABLE I .</head><label>I</label><figDesc>Average data insertion cost for DIM with and without shape segmentation.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table III shows</head><label>III</label><figDesc>the average communication cost per sample. As expected, the cost in shape segmentation case is less than the basic case.</figDesc><table>no. of trials 
cross corridor 
fish 
without shape segmentation 
168 
149 
136 
with shape segmentation 
112 
115 
123 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>TABLE II .</head><label>II</label><figDesc></figDesc><table>Average number of trials for 100 random sampling. 

cost per sampling 
cross 
corridor 
fish 
without shape segmentation 
477.84 
511.95 
361.80 
with shape segmentation 
102.49 
182.32 
238.47 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>TABLE III .</head><label>III</label><figDesc>Average cost per sampling.</figDesc><table></table></figure>

			<note place="foot" n="1"> Notice that the sink we refer to in this paper is not a data sink or aggregation center (base station), although the sinks are good indicators of where to place base stations or aggregation centers</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>We thank Yue Wang for sharing with us the boundary detection code in <ref type="bibr" target="#b15">[16]</ref> and Alexander Kröller for a few useful discussions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Routing with guaranteed delivery in ad hoc wireless networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Morin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stojmenovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Urrutia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Wireless Networks</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">GPSR: Greedy perimeter stateless routing for wireless networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MobiCom &apos;00: Proceedings of the ACM/IEEE International Conference on Mobile Computing and Networking</title>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Geometric ad-hoc routing: Of theory and practice</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Wattenhofer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Zollinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODC &apos;03: Proceedings of 22 nd ACM Int. Symposium on the Principles of Distributed Computing</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">GLIDER: Gradient landmark-based distributed routing for sensor networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Guibas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM &apos;05: Proceedings of the 24th Conference of the IEEE Communication Society</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">MAP: Medial axis based geometric routing in sensor networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bruck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MobiCom &apos;05: Proceedings of the ACM/IEEE International Conference on Mobile Computing and Networking</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">DIFS: A distributed index for features in sensor networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Greenstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of First IEEE International Workshop on Sensor Network Protocols and Applications</title>
		<meeting>First IEEE International Workshop on Sensor Network Protocols and Applications</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Multi-dimensional range queries in sensor networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the first international conference on Embedded networked sensor systems</title>
		<meeting>the first international conference on Embedded networked sensor systems</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Approximately uniform random sampling in sensor networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Bash</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C J</forename><surname>Byers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DMSN &apos;04: Proceedings of 1th Workshop on Data Management in Sensor Networks</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Geographic gossip: efficient aggregation for sensor networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">G</forename><surname>Dimakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename><surname>Sarwate</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Wainwright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IPSN &apos;06: Proceedings of the fifth international conference on Information processing in sensor networks</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Deterministic boundary recognition and topology extraction for large sensor networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kröller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Fekete</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Pfisterer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 17th ACM-SIAM Sympos. Discrete Algorithms</title>
		<meeting>17th ACM-SIAM Sympos. Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Shape segmentation and matching with flow discretization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">K</forename><surname>Dey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Giesen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Goswami</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WADS &apos;03: Proceedings of workshop on Algorithms and Data Structures</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Recognition of shapes by editing shock graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Sebastian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kimia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICCV &apos;01: Proceedings of International Conference on Computer Vision</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Shock graphs and shape matching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Siddiqi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shokoufandeh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">J</forename><surname>Dickinson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">W</forename><surname>Zucker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICCV &apos;98: Proceedings of International Conference on Computer Vision</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The shock scaffold for representing 3d shape</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">F</forename><surname>Leymarie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">B</forename><surname>Kimia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 4th International Workshop Visual Form</title>
		<meeting>4th International Workshop Visual Form</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Topology matching for fully automatic similarity estimation of 3d shapes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hilaga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Shinagawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kohmura</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">L</forename><surname>Kunii</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIG-GRAPH &apos;01: Proceedings of the 28th annual conference on Computer graphics and interactive techniques</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Boundary recognition in sensor networks by topological methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S B</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MobiCom &apos;06: Proceedings of the ACM/IEEE International Conference on Mobile Computing and Networking</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Time synchronization in wireless sensor networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Elson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<pubPlace>Los Angeles</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of California</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Ph.D. dissertation</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Timing-sync protocol for sensor networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ganeriwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">B</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SenSys &apos;03: Proceedings of the 1st international conference on Embedded networked sensor systems</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Ubiquitous access to distributed data in large-scale sensor networks through decentralized erasure codes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">G</forename><surname>Dimakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Prabhakaran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ramchandran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IPSN &apos;05: Proceedings of the fourth international symposium on information processing in sensor networks</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Sweeps over wireless sensor networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Skraba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Guibas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IPSN &apos;06: Proceedings of the fifth international conference on Information processing in sensor networks</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
