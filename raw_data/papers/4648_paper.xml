<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:56+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Productivity of Stream Definitions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jörg</forename><surname>Endrullis</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Vrije Universiteit Amsterdam</orgName>
								<address>
									<addrLine>De Boelelaan 1081a</addrLine>
									<postCode>1081 HV</postCode>
									<settlement>Amsterdam</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clemens</forename><surname>Grabmayer</surname></persName>
							<email>clemens@phil.uu.nl</email>
							<affiliation key="aff2">
								<orgName type="department">Department of Philosophy</orgName>
								<orgName type="institution">Universiteit Utrecht</orgName>
								<address>
									<addrLine>Heidelberglaan 8</addrLine>
									<postCode>3584 CS</postCode>
									<settlement>Utrecht</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dimitri</forename><surname>Hendriks</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Vrije Universiteit Amsterdam</orgName>
								<address>
									<addrLine>De Boelelaan 1081a</addrLine>
									<postCode>1081 HV</postCode>
									<settlement>Amsterdam</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ariya</forename><surname>Isihara</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Vrije Universiteit Amsterdam</orgName>
								<address>
									<addrLine>De Boelelaan 1081a</addrLine>
									<postCode>1081 HV</postCode>
									<settlement>Amsterdam</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><forename type="middle">Willem</forename><surname>Klop</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Vrije Universiteit Amsterdam</orgName>
								<address>
									<addrLine>De Boelelaan 1081a</addrLine>
									<postCode>1081 HV</postCode>
									<settlement>Amsterdam</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Radboud Universiteit Nijmegen</orgName>
								<address>
									<addrLine>Toernooiveld 1</addrLine>
									<postCode>6525 ED</postCode>
									<settlement>Nijmegen</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Productivity of Stream Definitions</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We give an algorithm for deciding productivity of a large and natural class of recursive stream definitions. A stream definition is called &apos;productive&apos; if it can be evaluated continuously in such a way that a uniquely determined stream is obtained as the limit. Whereas productivity is undecidable for stream definitions in general, we show that it can be decided for &apos;pure&apos; stream definitions. For every pure stream definition the process of its evaluation can be modelled by the dataflow of abstract stream elements, called &apos;pebbles&apos;, in a finite &apos;pebbleflow net(work)&apos;. And the production of a pebbleflow net associated with a pure stream definition , that is, the amount of pebbles the net is able to produce at its output port, can be calculated by reducing nets to trivial nets.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In functional programming, term rewriting and λ-calculus, there is a wide arsenal of methods for proving termination such as recursive path orders, dependency pairs (for term rewriting systems, <ref type="bibr" target="#b14">[15]</ref>) and the method of computability (for λ-calculus, <ref type="bibr" target="#b12">[13]</ref>). All of these methods pertain to finite data only. In the last two decades interest has grown towards infinite data, as witnessed by the application of type theory to infinite objects <ref type="bibr" target="#b1">[2]</ref>, and the emergence of coalgebraic techniques for infinite data types like streams <ref type="bibr" target="#b10">[11]</ref>. While termination cannot be expected when infinite data are processed, infinitary notions of termination become relevant. For example, in formal frameworks for the manipulation of infinite objects such as infinitary rewriting <ref type="bibr" target="#b6">[7]</ref> and infinitary λ-calculus <ref type="bibr" target="#b7">[8]</ref>, basic notions are the properties WN ∞ of infinitary weak normalisation and SN ∞ of infinitary strong normalisation <ref type="bibr" target="#b8">[9]</ref>.</p><p>In the functional programming literature the notion of 'productivity' has arisen, initially in the pioneering work of Sijtsma <ref type="bibr" target="#b11">[12]</ref>, as a natural strengthening of production functions is too restrictive to capture the behaviour of commonly used stream operations like even, dup, zip and so forth. Therefore he develops an approach allowing arbitrary production functions β f : N r → N, having the only drawback of not being automatable in full generality. Coquand <ref type="bibr" target="#b1">[2]</ref> defines a syntactic criterion called 'guardedness' for ensuring productivity. This criterion is too restrictive for programming practice, because it disallows function applications to recursive calls. Telford and Turner <ref type="bibr" target="#b13">[14]</ref> extend the notion of guardedness with a method in the flavour of Wadge. However, their approach does not overcome Sijtsma's criticism. Hughes, Pareto and Sabry <ref type="bibr" target="#b4">[5]</ref> introduce a type system using production functions with the property that β f (a·x+b) = c·x+d for some a, b, c, d ∈ N. This class of functions is not closed under composition, leading to the need of approximations and a loss of power. Moreover their typing system rejects definitions like M = a : b : tail(M), where ':' is the infix stream constructor, because tail is applied to the recursive call. Buchholz <ref type="bibr" target="#b0">[1]</ref> presents a formal type system for proving productivity, whose basic ingredients are, closely connected to <ref type="bibr" target="#b11">[12]</ref>, unrestricted production functions β f : N r → N. In order to obtain an automatable method, Buchholz also devises a syntactic criterion to ensure productivity. This criterion easily handles all the examples of <ref type="bibr" target="#b13">[14]</ref>, but fails to deal with functions that have a negative effect 'worse than tail'.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Recursive Stream Specifications</head><p>In this section the concepts of 'stream constant specification' (SCS) and 'stream function specification' (SFS) are introduced. We use a two-layered set-up, which is illustrated by the well-known definition M = 0:1:zip(tail(M), inv(tail(M))) of the Thue-Morse sequence. This corecursive definition employs separate definitions of the stream functions zip and tail, contained in Ex. 1 below, and of the definition inv(x:σ) = (1−x):inv(σ) of the stream function inv. Stream constants are written using uppercase letters, stream and data functions are written lowercase.</p><p>In order to distinguish between data terms and streams we use the framework of many-sorted term rewriting. Let S be a finite set of sorts. An S-sorted set A is a family of sets (A s ) s∈S . An S-sorted signature Σ is a set of function symbols, each having a fixed arity ar(f ) ∈ S * ×S. Let X be an S-sorted set of variables. The Ssorted set of terms Ter (Σ, X) is inductively defined by: X s ⊆ Ter (Σ, X) s for all s ∈ S and f (t 1 , . . . , t n ) ∈ Ter (Σ, X) s whenever f ∈ Σ with arity s 1 · · · s n , s and t i ∈ Ter (Σ, X) si . An S-sorted term rewriting system (TRS) over an Ssorted signature Σ is an S-sorted set R where R s ⊆ Ter (Σ, X) s × Ter (Σ, X) s for all s ∈ S, satisfying the standard TRS requirements for rules. An S-sorted TRS is called finite if both its signature and the set of all of its rules are finite.</p><p>In the sequel let S = {d , s} where d is the sort of data terms and s is the sort of streams. We say that a {d , s}-sorted TRS Σ, R is a stream TRS if there exists a partition of the signature Σ = Σ d Σ sf Σ sc {:} such that the arity of the symbols from Σ d is in d * , d , for Σ sf in {s, d } * , s, for Σ sc in , s and ':' has arity ds, s. Accordingly, the symbols in Σ d are referred to as the data symbols, ':' as the stream constructor symbol, the symbols in Σ sf as the stream function symbols and the symbols in Σ sc as the stream constant symbols. Without loss of generality we assume that for all f ∈ Σ sf the stream arguments are in front. That is, f has arity s rs d r d , s for some r s , r d ∈ N; we say that f has arity r s , r d for short. Definition 1. Let T = Σ, R be a finite stream TRS with Σ = Σ d Σ sf {:} and a partition R = R d R sf of its set of rules. Then T (together with these partitions) is called a weakly guarded stream function specification (SFS) if:</p><p>(i) T is orthogonal (i.e. left-linear, non-overlapping redex patterns, see <ref type="bibr" target="#b14">[15]</ref>).</p><p>(ii) Σ d , R d is a strongly normalising TRS. (iii) For every stream function symbol f ∈ Σ sf there is precisely one rule in R sf , denoted by ρ f , the defining rule for f. Furthermore, for all f ∈ Σ sf with arity r s , r d , the rule ρ f ∈ R sf has the form:</p><formula xml:id="formula_0">f((x 1 : σ 1 ), . . . , (x rs : σ rs ), y 1 , . . . , y r d ) → u</formula><p>where x i :σ i stands for x i,1 :. . .:x i,ni :σ i , and u is one of the following forms:</p><formula xml:id="formula_1">u ≡ t 1 : . . . : t m f : g(σ π f (1) , . . . , σ π f (r s ) , t 1 , . . . , t r d ),<label>(1)</label></formula><formula xml:id="formula_2">u ≡ t 1 : . . . : t m f : σ i (2)</formula><p>Here, the terms t 1 , . . .</p><formula xml:id="formula_3">, t m f ∈ Ter (Σ d ) are called guards of f. Furthermore, g ∈ Σ sf with arity r s , r d , π f : {1, . . . , r s } → {1</formula><p>, . . . , r s } is an injection used to permute stream arguments, n 1 , . . . , n rs , m f ∈ N, and 1 ≤ i ≤ r s . In case (1) we write f g, and say f 'depends on' g. (iv) Every stream function symbol f ∈ Σ sf is weakly guarded in T , i.e. on every dependency cycle f g · · · f there is at least one guard.</p><p>It is easy to show that every function symbol f ∈ Σ sf in an SFS defines a unique function that maps stream arguments and data arguments to a stream, which can be computed, for given infinite stream terms u 1 , . . . , u rs in constructor normal form (that is, being of the form s 0 :s 1 :s 2 :. . .) and data terms t 1 , . . . , t r d , by infinitary rewriting as the infinite normal form of the term f(u 1 , . . . , u rs , t 1 , . . . , t r d ).</p><p>Note that the definition covers a large class of stream functions including tail, even, odd, zip, add. However, the function head defined by head(x : σ) = x, possibly creating 'look-ahead' as in the well-defined example S = 0 : head(tail 2 (S)) : S from [12], is not included. Now we are ready to define the concept of 'stream constant specification'.</p><p>Definition 2. Let T = Σ, R be a finite stream TRS with a partition Σ = Σ d Σ sf Σ sc {:} of its signature and a partition R = R d R sf R sc of its set of rules. Then T (together with these partitions) is called a pure stream constant specification (SCS) if the following conditions hold:</p><formula xml:id="formula_4">(i) Σ d Σ sf {:}, R d R sf is an SFS. (ii) Σ sc = {M 1 , .</formula><p>. . , M n } is a non-empty set of constant symbols, and</p><formula xml:id="formula_5">R sc = {M i → rhs Mi | 1 ≤ i ≤ n, rhs Mi ∈ Ter (Σ) s }. The rule ρ Mi := M i → rhs Mi is called the defining rule for M i in T .</formula><p>Note that an SCS T is orthogonal as a consequence of (i) and (ii). An SCS is called productive if every M ∈ Σ sc has a stream of data terms as infinite normal form (an infinite constructor normal form). Note that orthogonality implies that infinite normal forms are unique.</p><formula xml:id="formula_6">Example 1. Let T D = Σ d Σ sf Σ sc {:}, R d R sf R sc</formula><p>be the SCS with Σ d = {s, 0, a}, Σ sf = {tail, even, odd, zip, add}, Σ sc = {D}, and R sc consists of</p><formula xml:id="formula_7">D → 0 : 1 : 1 : zip(add(tail(D), tail(tail(D))), even(tail(D))), R sf consists of the rules tail(x : σ) → σ even(x : σ) → x : odd(σ) odd(x : σ) → even(σ) zip(x : σ, τ ) → x : zip(τ, σ) add(x : σ, y : τ ) → a(x, y) : add(σ, τ )</formula><p>and </p><formula xml:id="formula_8">R d = {a(x, s(y)) → s(a(x, y)), a(x, 0) → x}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Modelling with Nets</head><p>We introduce nets as a means to model SCSs and to visualise the flow of stream elements. As our focus is on productivity of SCSs, we are interested in the production of such a net, that is, the number of stream elements produced by a net. Therefore, stream elements are abstracted from in favour of occurrences of the symbol •, which we call pebble. The nets we study are called pebbleflow nets; they are inspired by interaction nets <ref type="bibr" target="#b9">[10]</ref>, and could be implemented in the framework of interaction nets with little effort. First we give an operational description of pebbleflow nets, explaining what the components of nets are and the way how the components process pebbles. To ease manipulation of and reasoning about nets, we employ term representations. Term constructs corresponding to net components, as well as the rules governing the flow of pebbles through a net, are given on the fly. Their formal definitions are given in Subsec. 3.2. Finally, in Subsec. 3.3, we define a production preserving translation of pure stream specifications into rational nets.</p><p>We denote the set of coinductive natural numbers by N = N ∪ {∞} and the numerals representing the elements of N by n = s n (0) for n ∈ N, and ∞ = s ω .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Nets</head><p>Wires The directed edges of a net, along which pebbles travel, are called wires. Wires are idealised in the sense that there is no upper bound on the number of pebbles they can store; arbitrarily long queues are allowed. Wires have no counterpart on the term level; in this sense they are akin to the edges of a term tree. Wires connect boxes, meets, fans, and sources, that we describe next.</p><p>Meets A meet is waiting for a pebble at each of its input ports and only then produces one pebble at its output port, see <ref type="figure">Fig. 1</ref>. Put differently, the number of pebbles a meet produces equals the minimum of the numbers of pebbles available at each of its input ports. Meets enable explicit branching; they are used to model stream functions of arity &gt; 1, as will be explained in the part "Boxes and gates" below. A meet with an arbitrary number n ≥ 1 of input ports is implemented by using a single wire in case n = 1, and if n = k + 1 with k ≥ 1, by connecting the output port of a 'k-ary meet' to one of the input ports of a (binary) meet.</p><formula xml:id="formula_9">N 2 N 1 N 2 N 1 Fig. 1. (•(N1), •(N2)) → •((N1, N2)) N N Fig. 2. µx.•(N (x)) → •(µx.N (•(x)))</formula><p>Fans The behaviour of a fan is dual to that of a meet: a pebble at its input port is duplicated along its output ports. A fan can be seen as an explicit sharing device, and thus enables the construction of cyclic nets. More specifically, we use fans only to implement feedback when drawing nets; there is no explicit term representation for the fan in our term calculus. In <ref type="figure">Fig. 2</ref> a pebble is sent over the output wire of the net and at the same time is fed back to the 'recursion wire(s)'. Turning a cyclic net into a term (tree) means to introduce a notion of binding; certain nodes need to be labelled by a name (µx) so that a wire pointing to that node is replaced by a name (x) referring to the labelled node. Sources A source has an output port only, contains a number k ∈ N of pebbles, and can fire if k &gt; 0. In Sec. 4 we show how to reduce 'closed' nets to sources. Boxes and Gates A box consumes pebbles at its input port and produces pebbles at its output port, controlled by an infinite sequence σ ∈ {+, −} ω associated with the box. This consumption/production behaviour of the box is then also be expressed by the 'production function' β σ : N → N of the box, see <ref type="figure">Fig. 5</ref>. For example, consider the unary stream function dup, defined as follows, and its corresponding 'I/O sequence':</p><formula xml:id="formula_10">dup(x : σ) = x : x : dup(σ) −++−++−++ . . .</formula><p>which is to be thought of as: for dup to produce two outputs, it first has to consume one input, and this process repeats indefinitely. Intuitively, the symbol − represents a requirement for an input pebble, and + represents a ready state for an output pebble. Pebbleflow through boxes is visualised in <ref type="figure">Figs. 3 and 4</ref>.</p><p>Definition 3. The set ± ω of I/O sequences is defined as the set of infinite sequences over the alphabet {+, −} that contain an infinite number of +'s: Further, we define the set ± ω rat ⊆ ± ω of rational I/O sequences. A sequence σ ∈ ± ω is called rational if there exist lists α, γ ∈ {+, −} * such that σ = αγ, where γ is not the empty list and γ denotes the infinite sequence γγγ . . .. The pair α, γ is called a rational representation of σ.</p><formula xml:id="formula_11">± ω := {σ ∈ {+, −} ω | ∀n. ∃m. σ(n + m) = +} N N σ +σ</formula><p>To model stream functions of arbitrary arity, we introduce gates. Gates are compounded of meets and boxes, as depicted in <ref type="figure" target="#fig_2">Fig. 6</ref>. The precise construction of a gate corresponding to a given stream function is described in Subsec. 3.3. Definition 4. The production function β σ : N → N of (a box containing) a sequence σ ∈ ± ω is corecursively defined, for all n ∈ N, by β σ (n) := β(σ, n):</p><formula xml:id="formula_12">N N n σ β σ (n) σ Fig. 5. box(σ, • n (N )) → • βσ (n) (box(σ , N )) σ rs σ 1</formula><formula xml:id="formula_13">β(+σ, n) = s(β(σ, n)) β(−σ, 0) = 0 β(−σ, s(n)) = β(σ, n)</formula><p>Intuitively, β σ (n) is the number of outputs of a box containing sequence σ when fed n inputs. Note that production functions are well-defined due to our requirement on I/O sequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">A Rewrite System for Pebbleflow</head><p>We define terms representing nets, and a rewrite system to model pebbleflow.</p><p>Definition 5. Let V be a set of variables. The set N of terms for pebbleflow nets is generated by:</p><formula xml:id="formula_14">N ::= src(k) | x | •(N ) | box(σ, N ) | µx.N | (N, N )</formula><p>where k ∈ N, x ∈ V, and σ ∈ ± ω . Furthermore, the set N rat of terms for rational pebbleflow nets is defined by the same inductive clauses, but now with the restriction σ ∈ ± ω rat .</p><p>The importance of identifying the subset of rational nets will become evident in Sec. 4, where we introduce a rewrite system for reducing nets to trivial nets (pebble sources). That system will be terminating for rational nets, and will enable us to determine the total production of a rational net.</p><p>The rules that govern pebbleflow are listed in Def. 6.</p><p>Definition 6. The pebbleflow rewrite relation → P is defined as the compatible closure of the union of the following rules:</p><formula xml:id="formula_15">(•(N 1 ), •(N 2 )) → •((N 1 , N 2 )) (P1) µx.•(N (x)) → •(µx.N (•(x))) (P2) box((+σ), N ) → •(box(σ, N )) (P3) box((−σ), •(N )) → box(σ, N ) (P4) src(s(k)) → •(src(k))<label>(P5)</label></formula><p>The first four rewrite rules in the definition above are visualised in <ref type="figure">Figures 1, 2</ref>, 3, and 4, respectively. In rule (P2) the feedback of pebbles along the recursion wire(s) of the net N is accomplished by substituting •(x) for all free occurrences x of N . Observe that → P constitutes an orthogonal CRS <ref type="bibr" target="#b14">[15]</ref>, hence:</p><formula xml:id="formula_16">Theorem 1. The relation → P is confluent.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Translating Pure Stream Specifications</head><p>First we give a translation of the stream function symbols in an SFS into rational gates (gates with boxes containing rational I/O sequences) that precisely model their quantitative consumption/production behaviour. The idea is to define, for a stream function symbol f, a rational gate by keeping track of the 'production' (sequence of guards encountered) and the 'consumption' of the rules applied, during the finite or eventually periodic dependency sequence on f.</p><formula xml:id="formula_17">Definition 7. Let T = Σ d Σ sf {:}, R d R sf be an SFS.</formula><p>Then, for each f ∈ Σ sf with arity r s , r d the translation of f is a rational gate [f] : N rs → N as defined by:</p><formula xml:id="formula_18">[f](N 1 , . . . , N rs ) = rs (box([f] 1 , N 1 ), . . . , box([f] rs , N rs ))</formula><p>where [f] i ∈ ± ω rat is defined as follows. We distinguish the two formats a rule ρ f ∈ R sf can have. Let x i : σ i stand for x i,1 : . . . : x i,ni : σ i . If ρ f has the form: f(x 1 : σ 1 , . . . , x rs : σ rs , y 1 , . . . , y r d ) → t 1 : . . . : t m f : u, where:</p><formula xml:id="formula_19">(a) u ≡ g(σ π f (1) , . . . , σ π f (r s ) , t 1 , . . . , t r d ), then (b) u ≡ σ j , then [f] i = − ni + m f [g] j if π f (j) = i − ni + if ¬∃j. π f (j) = i [f] i = − ni + m f −+ if i = j − ni + if i = j</formula><p>In the second step, we define a translation of the stream constants in an SCS into rational nets. Here the idea is that the recursive definition of a stream constant M is unfolded step by step; the terms thus arising are translated according to their structure by making use of the translation of the stream function symbols encountered; whenever a stream constant is met that has been unfolded before, the translation stops after establishing a binding to a µ-binder created earlier.</p><formula xml:id="formula_20">Definition 8. Let T = Σ d Σ sf Σ sc {:}, R d R sf R sc be an SCS. Then, for each M ∈ Σ sc with rule ρ M ≡ M → rhs M the translation [M] := [M] ∅ of M to a</formula><p>pebbleflow net is recursively defined by (α a set of stream constant symbols):</p><formula xml:id="formula_21">[M] α = µM.[rhs M ] α∪{M} if M ∈ α M if M ∈ α [t : u] α = •([u] α ) [f(u 1 , . . . , u rs , t 1 , . . . , t r d )] α = [f]([u 1 ] α , . . . , [u rs ] α )</formula><p>Example 3. Reconsider the SCS defined in Example 1. The translation of the stream function symbols tail, zip ∈ Σ sf is carried out as follows: (Note that to obtain rational representations of the translated stream functions we use loop checking on top of Def. 7.) Then, the stream constant D is translated to the following pebbleflow net, depicted in <ref type="figure" target="#fig_4">Fig. 7</ref>:</p><formula xml:id="formula_22">[tail](N ) = 1 (box([tail]1, N )) [zip](N1, N2) = 2 (box([zip]1, N1), box([zip]2, N2)) = box([tail]1, N ) [zip]1 = −+[zip]2 = −++[zip]1 = −++</formula><formula xml:id="formula_23">[D] = µD.•(•(•([zip]([add]([tail](D), [tail]([tail](D))), [even]([tail](D)))))) .</formula><p>[tail] 1 The theorem below is the basis of our decision algorithm. It states that the translation is 'production preserving', based on the following terminology: The production π(N ) of a pebbleflow net N is the supremum of the number of pebbles the net can 'produce': π(N ) := sup{n ∈ N | N P • n (N )}, where P denotes the reflexive-transitive closure of → P . Likewise for an SCS T = Σ, R the production π T (t) of a term t ∈ Ter (Σ) is the supremum of the number of data elements t can 'produce': π T (t) := sup{n ∈ N | t s 1 : . . . : s n : t }.</p><formula xml:id="formula_24">[even] 1 [zip] 1 [zip] 2 [zip] [add] 1 [add] 2 [add] [tail] 1 [tail] 1 [tail] 1</formula><formula xml:id="formula_25">Theorem 2. Let T be a pure SCS. Then, π([M]) = π T (M) for all M ∈ Σ sc .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Deciding Productivity</head><p>We define a rewriting system for pebbleflow nets that, for every net N , allows to reduce N to a single source while preserving the production of N .</p><p>Definition 9. We define the net reduction relation → R on closed pebbleflow nets by the compatible closure of the following rule schemata:</p><formula xml:id="formula_26">•(N ) → box((+−+), N ) (R1) box(σ, box(τ, N )) → box((σ · τ ), N ) (R2) box(σ, (N 1 , N 2 )) → (box(σ, N 1 ), box(σ, N 2 )) (R3) µx.(N 1 , N 2 ) → (µx.N 1 , µx.N 2 ) (R4) µx.N → N if x ∈ FV(N ) (R5) µx.box(σ, x) → src(fix(σ)) (R6) (src(k 1 ), src(k 2 )) → src(min(k 1 , k 2 )) (R7) box(σ, src(k)) → src(β σ (k)) (R8) µx.x → src(0)<label>(R9)</label></formula><p>where σ, τ ∈ ± ω , k, k 1 , k 2 ∈ N, and min(n, m), β σ (k), σ · τ (see Def. 10) and fix(σ) (see Def. 11) are term representations of operation results.</p><p>Definition 10. The operation composition · : ± ω × ± ω → ± ω , σ, τ → σ · τ of I/O sequences is defined corecursively by the following equations:</p><formula xml:id="formula_27">(+σ) · τ = +(σ · τ ) (−σ) · (+τ ) = σ · τ (−σ) · (−τ ) = −((−σ) · τ )</formula><p>Composition of sequences σ · τ ∈ ± ω exhibits analogous properties as composition of functions over natural numbers: it is associative, but not commutative. Furthermore, for all σ, τ ∈ ± ω , n ∈ N we have β σ·τ (n) = β σ (β τ (n)). Because we formalised the I/O behaviour of boxes by sequences and because we are interested in (dis)proving productivity, for the formalisation of the pebbleflow rewrite relation in Def. 6 the choice has been made to give output priority over input. This becomes apparent in the definition of composition above: the net box(+−+, box(−−+, x)) is able to consume an input pebble at its free input port x as well as to produce an output pebble, whereas the result box(+−−+, x) of the composition can only consume input after having fired. The fixed point of a box is the production of the box when fed its own output.</p><p>Definition 11. The operations fixed point fix : ± ω → N and requirement removal δ : ± ω → ± ω on I/O sequences are corecursively defined as follows:</p><formula xml:id="formula_28">fix(+σ) = s(fix(δ(σ))) δ(+σ) = +δ(σ) fix(−σ) = 0 δ(−σ) = σ</formula><p>For all σ ∈ ± ω , we have β σ (fix(σ)) = fix(σ). Moreover, fix(σ) is the least fixed point of β σ . Observe that β σ·σ·σ·..</p><formula xml:id="formula_29">. = β σ (β σ (β σ (. . .))) = fix(σ). Therefore, the infinite self-composition box(σ, box(σ, box(σ, . . .))) is 'production equivalent' to src(fix(σ)).</formula><p>Lemma 1. The net reduction relation → R is production preserving, that is, N → R N implies π(N ) = π(N ), for all nets N, N ∈ N . Furthermore, → R is terminating and every closed net normalises to a unique normal form, a source.</p><p>Observe that net reduction employs infinitary rewriting for fixed point computation and composition (Def. 10 and 11). To compute normal forms in finite time we make use of finite representations of rational sequences and exchange the numeral s ω with a constant ∞. The reader may confer <ref type="bibr" target="#b3">[4]</ref> for further details.</p><p>Lemma 2. There is an algorithm that, if N ∈ N rat and rational representations of the sequences σ ∈ ± ω rat in N are given, computes the → R -normal form of N .</p><p>Proof (Hint). Note that composition preserves rationality, that is, σ · τ ∈ ± ω rat whenever σ, τ ∈ ± ω rat . Similarly, it is straightforward to show that for sequences σ, τ ∈ ± ω rat with given rational representations the fixed point fix(σ) and a rational representation of the composition σ · τ can be computed in finite time.</p><p>Theorem 3. Productivity is decidable for pure stream constant specifications.</p><p>Proof. The following steps describe a decision algorithm for productivity of a stream constant M in an SCS T : First, the translation <ref type="bibr">[M]</ref> of M into a pebbleflow net is built according to Def. 8. It is easy to verify that <ref type="bibr">[M]</ref> is in fact a rational net. Second, by the algorithm stated by <ref type="bibr">Lem. 2, [M]</ref> is collapsed to a source src(n) with n ∈ N. By Thm. 2 it follows that <ref type="bibr">[M]</ref> has the same production as M in T , and by Lem. 1 that the production of <ref type="bibr">[M]</ref> is n. Consequently, π T (M) = n. Hence the answers "T is productive for M" and "T is not productive for M" are obtained if n = ∞ and if n ∈ N, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Examples</head><p>We give three examples to show how our algorithm decides productivity of SCSs. First we recognise our running example (Ex. 1) to be productive. Next, we give a simple example of an SCS that is not productive. Finally, we illustrate that productivity is sensitive to the precise definitions of the stream functions used.</p><p>Example 4. We revisit Ex. 3 where we calculated the pebbleflow net <ref type="bibr">[D]</ref> for D and show the last five steps of the reduction to → R -normal form. </p><formula xml:id="formula_30">→ R6 ((src(∞), src(∞)), src(∞)) → R7 (src(∞), src(∞)) → R7 src(∞) .</formula><p>Hence D is productive in the SCS of Ex. 1.</p><p>Example 5. For the definition of J from Ex. 2 we get:</p><formula xml:id="formula_31">[J] = µJ.•(•(box(−+−, J))) → 2 R1 µJ.box(+−+, box(+−+, box(−+−, J))) → R2 µJ.box(++−+, box(−+−, J)) → R2 µJ.box(++−+−, J) → R6 src(4) ,</formula><p>proving that J is not productive (only 4 elements can be evaluated).</p><formula xml:id="formula_32">Example 6. Let T = Σ d Σ sf Σ sc {:}, R d R sf R sc be an SCS where Σ d = {0}, Σ sf = {zip, tail, even, odd}, Σ sc = {C}, R d = ∅, R sc consists of: C → 0 : zip(C, even(tail(C))) ,</formula><p>and R sf consists of the rules:</p><formula xml:id="formula_33">tail(x : σ) → σ zip(x : σ, τ ) → x : zip(τ, σ) even(x : σ) → x : odd(σ) odd(x : σ) → even(σ) .</formula><p>Then, we obtain the following translations: </p><formula xml:id="formula_34">→ 2 R6 (src(∞), src(∞)) → R7 src(∞)</formula><p>witnessing productivity of C in T . Note that the 'fine' definitions of zip and even are crucial in this setting. If we replace the definition of zip in T by the 'coarser' one: zip * (x : σ, y : τ ) → x : y : zip * (σ, τ ), we obtain an SCS T * where: </p><formula xml:id="formula_35">→ 2 R6 (src(∞), src(1)) → R7 src(1) .</formula><p>Hence C is not productive in T * (here it produces only one element). Similarly, if we change the definition of even to even(x : y : σ) → x : even(σ), giving rise to the translation [even](N ) = box(−−+, N ), then only the first two elements of C can be evaluated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion and Ongoing Research</head><p>We have shown that productivity is decidable for stream definitions that belong to the format of SCSs. The class of SCSs contains definitions that cannot be recognised automatically to be productive by the methods of <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b0">1]</ref> (e.g. the stream constant definition in Ex. 1). These previous approaches established criteria for productivity that are not applicable for disproving productivity; furthermore, these methods are either applicable to general stream definitions, but cannot be mechanised fully, or can be automated, but give a 'productive'/'don't know' answer only for a very restricted subclass. Our approach combines the features of being automatable and of obtaining a definite 'productive'/'not productive' decision for a rich class of stream definitions.</p><p>Note that we obtain decidability of productivity by restricting only the stream function definition part of a stream definition (formalised as an orthogonal TRS), while imposing no conditions on how the stream constant definition part makes use of the stream functions. The restriction to weakly guarded stream function definitions in SCSs is motivated by the wish to formulate an effectively recognisable format of stream definitions for which productivity is decidable. More general recognisable formats to which our method can be applied are possible. If the requirement of a recognisable format is dropped, our approach allows to show decidability of productivity for stream definitions that are based on stream function specifications which can (quantitatively) faithfully be described by 'rational' I/O sequences. Finally, also lower and upper 'rational' bounds on the production of stream functions can be considered to obtain computable criteria for productivity and its complement. This will allow us to deal with stream functions that depend quantitatively on the value of stream elements and data parameters. All of these extensions of the result presented here are the subject of ongoing research (see also <ref type="bibr" target="#b3">[4]</ref>).</p><p>The reader may want to visit http://infinity.few.vu.nl/productivity/ for additional material. There, an implementation of the decision algorithm for productivity of SCSs as well as an animation tool for pebbleflow nets can be found. We have tested the usefulness and feasibility of the implementation of our decision algorithm on various SCSs from the literature, and so far have not encountered excessive run-times. However, a precise analysis of the run-time complexity of our algorithm remains to be carried out.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>and hence is productive in T D . Example 2. Consider the rule J → 0 : 1 : even(J) together with Σ, R d , R sf as in Ex. 1. The infinite normal form of J is 0 : 1 : 0 : 0 : even(even(. . .)), which is not a constructor normal form. Hence J is WN ∞ (in fact SN ∞ ), but not productive.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .Fig. 4 .</head><label>34</label><figDesc>Fig. 3. box(+σ, N ) → •(box(σ, N ))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. A gate for modelling rs-ary stream functions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. The pebbleflow net [D] corresponding to the stream D.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>[</head><label></label><figDesc>D] R ((µD.box(+++−−++, D), µD.box(+++−−++, box(−−+, D))), src(∞)) → R6 ((src(∞), µD.box(+++−−++, box(−−+, D))), src(∞)) → R2 ((src(∞), µD.box(+++−−−++, D)), src(∞))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>[</head><label></label><figDesc>zip](N1, N2) = 2 (box(−++, N1), box(+−+, N2)) [even](N ) = box(−+−, N ) [tail](N ) = box(−−+, N ) [C] = µC.•((box(−++, C), box(+−+, box(−+−, box(−−+, C))))) . Now by rewriting [C] with parallel outermost rewriting (except that composition of boxes is preferred to reduce the size of the terms) according to → R we get: [C] → R2 µC.•((box(−++, C), box(+−++−, box(−−+, C)))) → R2 µC.•((box(−++, C), box(+−−+, C))) → R1 µC.box(+−+, (box(−++, C), box(+−−+, C))) → R3 µC.(box(+−+, box(−++, C)), box(+−+, box(+−−+, C))) → 2 R2 µC.(box(+−+, C), box(++−−, C)) → R4 (µC.box(+−+, C), µC.box(++−−, C))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>[zip * ](N1, N2) = 2 (box(−++, N1), box(−++, N2)) [C] = µC.•((box(−++, C), box(−++, box(−+−, box(−−+, C))))) → R2 µC.•((box(−++, C), box(−++−, box(−−+, C)))) → R2 µC.•((box(−++, C), box(−−++, C))) → R1 µC.box(+−+, (box(−++, C), box(−−++, C))) → R3 µC.(box(+−+, box(−++, C)), box(+−+, box(−−++, C))) → 2 R2 µC.(box(+−+, C), box(+−−+, C)) → R4 (µC.box(+−+, C), µC.box(+−−+, C))</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A term calculus for (co-)recursive definitions on streamlike data structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Buchholz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Pure and Applied Logic</title>
		<imprint>
			<biblScope unit="volume">136</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="75" to="90" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Infinite Objects in Type Theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Th</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Coquand</surname></persName>
		</author>
		<editor>H. Barendregt and T. Nipkow</editor>
		<imprint>
			<date type="published" when="1994" />
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="volume">806</biblScope>
			<biblScope unit="page" from="62" to="78" />
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">On the productivity of recursive definitions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1980" />
			<biblScope unit="page">749</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Productivity of Stream Definitions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Endrullis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Grabmayer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Hendriks</surname></persName>
		</author>
		<ptr target="http://infinity.few.vu.nl/productivity/" />
		<imprint>
			<date type="published" when="2007" />
		</imprint>
		<respStmt>
			<orgName>Vrije Universiteit Amsterdam</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Proving the correctness of reactive systems using sized types</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hughes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Pareto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sabry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;96</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="410" to="423" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The semantics of a simple language for parallel programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Kahn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information Processing</title>
		<imprint>
			<date type="published" when="1974" />
			<biblScope unit="page" from="471" to="475" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Transfinite reductions in orthogonal term rewriting systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kennaway</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">W</forename><surname>Klop</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Sleep</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F.-J</forename><surname>De Vries</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. and Comput</title>
		<imprint>
			<biblScope unit="volume">119</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="18" to="38" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kennaway</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">W</forename><surname>Klop</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Sleep</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F.-J</forename><surname>De Vries</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="volume">175</biblScope>
			<biblScope unit="page" from="93" to="125" />
		</imprint>
	</monogr>
	<note>Infinitary lambda calculus. TCS</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Infinitary normalization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">W</forename><surname>Klop</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>De Vrijer</surname></persName>
		</author>
		<ptr target="http://web.mac.com/janwillemklop/iWeb/Site/Bibliography.html" />
	</analytic>
	<monogr>
		<title level="m">We Will Show Them: Essays in Honour of Dov Gabbay</title>
		<imprint>
			<publisher>College Publications</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="169" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Interaction nets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lafont</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;90</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1990" />
			<biblScope unit="page" from="95" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Behavioural differential equations: a coinductive calculus of streams, automata, and power series</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J M M</forename><surname>Rutten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TCS</title>
		<imprint>
			<biblScope unit="volume">308</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="1" to="53" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On the productivity of recursive list definitions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">A</forename><surname>Sijtsma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="633" to="649" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Intentional interpretations of functionals of finite type I</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">W</forename><surname>Tait</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1967" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Ensuring the Productivity of Infinite Structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Telford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Turner</surname></persName>
		</author>
		<idno>14-97</idno>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
		<respStmt>
			<orgName>The Computing Laboratory, Univ. of Kent at Canterbury</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Term Rewriting Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terese</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cambridge Tracts in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<date type="published" when="2003" />
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An extensional treatment of dataflow deadlock</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">W</forename><surname>Wadge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TCS</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="3" to="15" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
