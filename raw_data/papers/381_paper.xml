<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:34+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Extracting Semantic Networks from Text Via Relational Clustering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stanley</forename><surname>Kok</surname></persName>
							<email>koks@cs.washington.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">University of Washington</orgName>
								<address>
									<postCode>98195-2350</postCode>
									<settlement>Seattle</settlement>
									<region>WA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pedro</forename><surname>Domingos</surname></persName>
							<email>pedrod@cs.washington.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">University of Washington</orgName>
								<address>
									<postCode>98195-2350</postCode>
									<settlement>Seattle</settlement>
									<region>WA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Extracting Semantic Networks from Text Via Relational Clustering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Extracting knowledge from text has long been a goal of AI. Initial approaches were purely logical and brittle. More recently, the availability of large quantities of text on the Web has led to the development of machine learning approaches. However, to date these have mainly extracted ground facts, as opposed to general knowledge. Other learning approaches can extract logical forms, but require supervision and do not scale. In this paper we present an unsupervised approach to extracting semantic networks from large volumes of text. We use the TextRunner system [1] to extract tuples from text, and then induce general concepts and relations from them by jointly clustering the objects and relational strings in the tuples. Our approach is defined in Markov logic using four simple rules. Experiments on a dataset of two million tuples show that it outperforms three other relational clustering approaches, and extracts meaningful semantic networks.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A long-standing goal of AI is to build an autonomous agent that can read and understand text. The natural language processing (NLP) community attempted to achieve this goal in the 1970's and 1980's by building systems for understanding and answering questions about simple stories <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b5">6]</ref>. These systems parsed text into a network of predefined concepts, and created a knowledge base from which inferences can be made. However, they required a large amount of manual engineering, only worked on small text sizes, and were not robust enough to perform well on unrestricted naturally occurring text. Gradually, research in this direction petered out.</p><p>Interest in the goal has been recently rekindled <ref type="bibr" target="#b15">[16]</ref> <ref type="bibr" target="#b6">[7]</ref> by the abundance of easily accessible Web text, and by the substantial progress over the last few years in machine learning and NLP. The confluence of these three developments led to efforts to extract facts and knowledge bases from the Web <ref type="bibr" target="#b3">[4]</ref>. Two recent steps in this direction are a system by Pasca et. al <ref type="bibr" target="#b17">[18]</ref> and TextRunner <ref type="bibr" target="#b0">[1]</ref>. Both systems extract facts on a large scale from Web corpora in an unsupervised manner. Pasca et. al's system derives relation-specific extraction patterns from a starting set of seed facts, acquires candidate facts using the patterns, adds high-scoring facts to the seeds, and iterates until some convergence criterion. TextRunner uses a domain-independent approach to extract a large set of relational tuples of the form r(x, y) where x and y are strings denoting objects, and r is a string denoting a relation between the objects. It uses a lightweight noun phrase chunker to identify objects, and heuristically determines the text between objects as relations. These are good first steps, but they still fall short of the goal. While they can quickly acquire a large database of ground facts in an unsupervised manner, they are not able to learn general knowledge that is embedded in the facts.</p><p>Another line of recent research takes the opposite approach. Semantic parsing <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b28">29]</ref> is the task of mapping a natural language sentence into logical form. The logical statements constitute a knowledge base that can be used to perform some task like answering questions. Semantic parsing systems require a training corpus of sentences annotated with their associated logical forms (i.e., they are supervised). These systems are then trained to induce a parser that can convert novel sentences to their logical forms. Even though these systems can create knowledge bases directly, their need for annotated training data prevents them from scaling to large corpora like the Web.</p><p>In this paper, we present SNE, a scalable, unsupervised, and domain-independent system that simultaneously extracts high-level relations and concepts, and learns a semantic network <ref type="bibr" target="#b19">[20]</ref> from text. It first uses TextRunner to extract ground facts as triples from text, and then extract knowledge from the triples. TextRunner's triples are noisy, sparse, and contain many co-referent objects and relations. Our system has to overcome these challenges in order to extract meaningful highlevel relations and concepts from the triples in an unsupervised manner. It does so with a probabilistic model that clusters objects by the objects that they are related to, and that clusters relations by the objects they relate. This allows information to propagate between clusters of relations and clusters of objects as they are created. Each cluster represents a high-level relation or concept. A concept cluster can be viewed as a node in a graph, and a relation cluster can be viewed as links between the concept clusters that it relates. Together the concept clusters and relation clusters define a simple semantic network. <ref type="figure" target="#fig_3">Figure 1</ref> illustrates part of a semantic network that our approach learns. SNE is short for Semantic Network Extractor.</p><p>SNE is based on Markov logic <ref type="bibr" target="#b21">[22]</ref>, and is related to the Multiple Relational Clusterings (MRC) model <ref type="bibr" target="#b11">[12]</ref> we recently proposed. SNE is our first step towards creating a system that can extract an arbitrary semantic network directly from text. Ultimately, we want to tightly integrate the information extraction TextRunner component and the knowledge learning SNE component to form a self-contained knowledge extraction system. This tight integration will enable information to flow between both tasks, allowing them to be solved jointly for better performance <ref type="bibr" target="#b13">[14]</ref>.</p><p>We begin by briefly reviewing Markov logic in the next section. Then we describe our model in detail (Section 3). Next we describe related work (Section 4). After that, we report our experiments comparing our model with three alternative approaches (Section 5). We conclude with a discussion of future work (Section 6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Markov Logic</head><p>Markov logic combines first-order logic with Markov networks.</p><p>In first-order logic <ref type="bibr" target="#b8">[9]</ref>, formulas are constructed using four types of symbols: constants, variables, functions, and predicates. (In this paper we use only function-free logic.) Constants represent objects in the domain of discourse (e.g., people: Anna, Bob, etc.). Variables (e.g., x, y) range over the objects in the domain. Predicates represent relations among objects (e.g., Friends), or attributes of objects (e.g., Student). Variables and constants may be typed. An atom is a predicate symbol applied to a list of arguments, which may be variables or constants (e.g., Friends(Anna, x)). A ground atom is an atom all of whose arguments are constants (e.g., Friends(Anna, Bob)). A world is an assignment of truth values to all possible ground atoms. A database is a partial specification of a world; each atom in it is true, false or (implicitly) unknown.</p><p>A Markov network or Markov random field <ref type="bibr" target="#b18">[19]</ref> is a model for the joint distribution of a set of variables X = (X 1 , X 2 , . . . , X n ) ∈ X . It is composed of an undirected graph G and a set of potential functions φ k . The graph has a node for each variable, and the model has a potential function for each clique in the graph. A potential function is a non-negative real-valued function of the state of the corresponding clique. The joint distribution represented by a Markov network is given by P (X = x) = 1 Z k φ k (x {k} ) where x {k} is the state of the kth clique (i.e., the state of the variables that appear in that clique). Z, known as the partition function, is given by Z = x∈X k φ k (x {k} ). Markov networks are often conveniently represented as log-linear models, with each clique potential replaced by an exponentiated weighted sum of features of the state, leading to</p><formula xml:id="formula_0">P (X = x) = 1 Z exp j w j f j (x)</formula><p>. A feature may be any real-valued function of the state. This paper will focus on binary features, f j (x) ∈ {0, 1}. In the most direct translation from the potential-function form, there is one feature corresponding to each possible state x {k} of each clique, with its weight being log φ k (x {k} ). This representation is exponential in the size of the cliques. However, we are free to specify a much smaller number of features (e.g., logical functions of the state of the clique), allowing for a more compact representation than the potential-function form, particularly when large cliques are present. Markov logic takes advantage of this. A Markov logic network (MLN) is a set of weighted first-order formulas. Together with a set of constants representing objects in the domain, it defines a Markov network with one node per ground atom and one feature per ground formula. The weight of a feature is the weight of the first-order formula that originated it. The probability distribution over possible worlds x specified by the ground Markov network is given by</p><formula xml:id="formula_1">P (X = x) = 1 Z exp i∈F j∈Gi w i g j (x)</formula><p>, where Z is the partition function, F is the set of all first-order formulas in the MLN, G i is the set of groundings of the ith first-order formula, and g j (x) = 1 if the jth ground formula is true and g j (x) = 0 otherwise. Markov logic enables us to compactly represent complex models in non-i.i.d. domains. General algorithms for inference and learning in Markov logic are discussed in <ref type="bibr" target="#b21">[22]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Semantic Network Extraction</head><p>We call our model SNE, for Semantic Network Extractor. SNE simultaneously clusters objects and relations in an unsupervised manner, without requiring the number of clusters to be specified in advance. The object clusters and relation clusters respectively form the nodes and links of a semantic network. A link exists between two nodes if and only if a true ground fact can be formed from the symbols in the corresponding relation and object clusters. SNE can cluster objects of different types, and relations of any arity.</p><p>When faced with the task of extracting knowledge from noisy and sparse data like that used in our experiments, we have to glean every bit of useful information from the data to form coherent clusters. SNE does this by jointly clustering objects and relations. In its algorithm, SNE allows information from object clusters it has created at each step to be used in forming relation clusters, and vice versa. As we shall see later in our experimental results, this joint clustering approach does better than clustering objects and relations separately.</p><p>SNE is defined using a form of finite second-order Markov logic in which variables can range over relations (predicates) as well as objects (constants). Extending Markov logic to second order involves simply grounding atoms with all possible predicate symbols as well as all constant symbols, and allows us to represent some models much more compactly than first-order Markov logic.</p><p>For simplicity, we assume that relations are binary in our definition of SNE, i.e., relations are of the form r(x, y) where r is a relation symbol, and x and y are object symbols. (Extending the definition to an arbitrary number of nary relations is straightforward.) We use γ i and Γ i to respectively denote a cluster and clustering (i.e., a partitioning) of symbols of type i. If r, x, and y are respectively in cluster γ r , γ x , and γ y , we say that r(x, y) is in the cluster combination (γ r , γ x , γ y ).</p><p>The learning problem in SNE consists of finding the cluster assignment Γ = (Γ r , Γ x , Γ y ) that maximizes the posterior probability P (Γ |R) ∝ P (Γ, R) = P (Γ )P (R|Γ ), where R is a vector of truth assignments to the observable r(x, y) ground atoms.</p><p>We define one MLN for the likelihood P (R|Γ ) component, and one MLN for the prior P (Γ ) component of the posterior probability with just four simple rules.</p><p>The MLN for the likelihood component only contains one rule stating that the truth value of an atom is determined by the cluster combination it belongs to:</p><p>∀r, x, y, +γ r ,</p><formula xml:id="formula_2">+γ x , +γ y r ∈ γ r ∧ x ∈ γ x ∧ y ∈ γ y ⇒ r(x, y)</formula><p>This rule is soft. The "+" notation is syntactic sugar that signifies that there is an instance of this rule with a separate weight for each cluster combination (γ r , γ x , γ y ). This rule predicts the probability of query atoms given the cluster memberships of the symbols in them. This is known as the atom prediction rule. As shown in <ref type="bibr" target="#b11">[12]</ref>, given a cluster assignment, the MAP weight w k of an instance of the atom prediction rule is given by log(t k /f k ), where t k is the empirical number of true atoms in cluster combination k, and f k is the number of false atoms. Adding smoothing parameters α and β, we estimate the MAP weight as log(</p><formula xml:id="formula_3">(t k + α)/(f k + β)).</formula><p>Three rules are defined in the MLN for the prior component. The first rule states that each symbol belongs to exactly one cluster:</p><formula xml:id="formula_4">∀x ∃ 1 γ x ∈ γ</formula><p>This rule is hard, i.e., it has infinite weight and cannot be violated.</p><p>The second rule imposes an exponential prior on the number of cluster combinations. This rule combats the proliferation of cluster combinations and consequent overfitting, and is represented by the formula</p><formula xml:id="formula_5">∀γ r , γ x , γ y ∃r, x, y r ∈ γ r ∧ x ∈ γ x ∧ y ∈ γ y</formula><p>with negative weight −λ. The parameter λ is fixed during learning, and is the penalty in log-posterior incurred by adding a cluster combination to the model. Thus larger λs lead to fewer cluster combinations being formed. This rule represents the complexity of the model in terms of the number of instances of the atom prediction rule (which is equal to the number of cluster combinations).</p><p>The last rule encodes the belief that most symbols tend to be in different clusters. It is represented by the formula</p><formula xml:id="formula_6">∀x, x , γ x , γ x x ∈ γ x ∧ x ∈ γ x ∧ x = x ⇒ γ x = γ x</formula><p>with positive weight µ. The parameter µ is also fixed during learning. We expect there to be many concepts and high-level relations in a large heterogenous body of text. The tuple extraction process samples instances of these concepts and relations sparsely, and we expect each concept or relation to have only a few instances sampled, in many cases only one. Thus we expect most pairs of symbols to be in different concept and relation clusters.</p><p>The equation for the log-posterior, as defined by the two MLNs, can be written in closed form as 1 log P (Γ |R) = k∈K where K is the set of cluster combinations, m cc is the number of cluster combinations, d is the number of pairs of symbols that belong to different clusters, and C is a constant.</p><p>Rewriting the equation, the log-posterior can be expressed as</p><formula xml:id="formula_7">log P (Γ |R) = k∈K + t k log t k + α t k + f k + α + β + f k log f k + β t k + f k + α + β + k∈K − f k log f k + β t k + f k + α + β − λm cc + µd + C<label>(2)</label></formula><p>where K + is the set of cluster combinations that contains at least one true ground atom, and K − is the set of cluster combinations that does not contain any true ground atoms. Observe that |K + | + |K − | = |Γ r ||Γ x ||Γ y |. Even though it is tractable to compute the first summation over |K + | (which is at most the number of true ground atoms), it may not be feasible to compute the second summation over |K − | for large |Γ i |s. Hence, for tractability, we assume that all tuples in K − belong to a single 'default' cluster combination with the same probability p f alse of being false. The log-posterior is simplified as</p><formula xml:id="formula_8">log P (Γ |R) = k∈K + t k log t k + α t k + f k + α + β + f k log f k + β t k + f k + α + β + |S r ||S x ||S y | − k∈K + (t k + f k ) log(p f alse ) − λm + cc + µd + C (3)</formula><p>where S i is the set of symbols of type i, (|S r ||S x ||S y | − k∈K + (t k + f k )) is the number of (false) tuples in K − , m + cc is the number of cluster combinations containing at least one true ground atom, and C = C − λ.</p><p>SNE simplifies the learning problem by performing hard assignment of symbols to clusters (i.e., instead of computing probabilities of cluster membership, a symbol is simply assigned to its most likely cluster). Since, given a cluster assignment, the MAP weights can be computed in closed form, SNE simply searches over cluster assignments, evaluating each assignment by its posterior probability.</p><p>SNE uses a bottom-up agglomerative clustering algorithm to find the MAP clustering <ref type="table" target="#tab_0">(Table 1</ref>). The algorithm begins by assigning each symbol to its own unit cluster. Next we try to merge pairs of clusters of each type. We create candidate pairs of clusters, and for each of them, we evaluate the change in posterior probability (Equation 3) if the pair is merged. If the candidate pair improves posterior probability, we store it in a sorted list. We then iterate through the list, performing the best merges first, and ignoring those containing clusters that have already been merged. In this manner, we incrementally merge clusters until no merges can be performed to improve posterior probability.</p><p>To avoid creating all possible candidate pairs of clusters of each type (which is quadratic in the number of clusters), we make use of canopies <ref type="bibr" target="#b14">[15]</ref>. A canopy for relation symbols is a set of clusters such that there exist object clusters γ x and γ y ,  and for all clusters γ r in the canopy, the cluster combination (γ r , γ x , γ y ) contains at least one true ground atom r(x, y). We say that the clusters in the canopy share the property (γ x , γ y ). Canopies for object symbols x and y are similarly defined. We only try to merge clusters in a canopy that is no larger than a parameter CanopyM ax. This parameter limits the number of candidate cluster pairs we consider for merges, making our algorithm more tractable. Furthermore, by using canopies, we only try 'good' merges, because symbols in clusters that share a property are more likely to belong to the same cluster than those in clusters with no property in common.</p><note type="other">in Sr, Sx, and Sy output: a semantic network, {(γr, γx, γy) ∈ Γr × Γx × Γy : (γr, γx, γy) contains at least one true ground atom} for each i ∈ {r, x, y} Γi ← unitClusters(Si) mergeOccurred ← true while mergeOccurred mergeOccurred ← f alse for each i ∈ {r, x, y} CandidateM erges ← ∅ for each (γ, γ ) ∈ Γi × Γi ∆P ← change</note><p>Note that we can efficiently compute the change in posterior probability (∆P in <ref type="table" target="#tab_0">Table 1</ref>) by only considering the cluster combinations with true ground atoms that contain the merged clusters γ and γ . Below we give the equation for computing ∆P when we merge relation clusters γ r and γ r to form γ r . The equations for merging object clusters are similar. Let T F k be a shorthand for</p><formula xml:id="formula_9">t k log( t k +α t k +f k +α+β ) + f k log( f k +β t k +f k +α+β ). ∆P = (γ r ,γ1,γ2)∈K + γ r γ r γr T F (γ r ,γ1,γ2) − T F (γ r ,γ1,γ2) − T F (γr,γ1,γ2) + λ + (γ r ,γ1,γ2)∈K + γ r ·γr T F (γ r ,γ1,γ2) − f (γ r ,γ1,γ2) log(p f alse ) − T F (γr,γ1,γ2) + (γ r ,γ1,γ2)∈K + γ r γ r · T F (γ r ,γ1,γ2) − T F (γ r ,γ1,γ2) − f (γr,γ1,γ2) log(p f alse ) −µ|γ r ||γ r |<label>(4)</label></formula><p>where</p><formula xml:id="formula_10">K + γ r γ r γr</formula><p>is the set of cluster combinations with true ground atoms such that each cluster combination (γ r , γ 1 , γ 2 ) in the set has the property that (γ r</p><note type="other">, γ 1 , γ 2 ) and (γ r , γ 1 , γ 2 ) also contains true atoms. K + γ r ·γr is the set of cluster combinations with true ground atoms such that each cluster combination (γ r , γ 1 , γ 2 ) in the set has the property that (γ r , γ 1 , γ 2 ), but not (γ r , γ 1 , γ 2 ), contains true ground atoms. K + γ r γ r ·</note><p>is similarly defined. Observe that we only sum over cluster combinations with true ground atoms that contains the affected clusters γ r , γ r and γ r , rather than over all cluster combinations with true ground atoms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Related Work</head><p>Rajaraman and Tan <ref type="bibr" target="#b20">[21]</ref> propose a system that learns a semantic network by clustering objects but not relations. While it anecdotally shows a snippet of its semantic network, an empirical evaluation of the network is not reported. Hasegawa et. al <ref type="bibr" target="#b9">[10]</ref> propose an unsupervised approach to discover relations from text. They treat the short text segment between each pair of objects as a relation, and cluster pairs of objects using the similarity between their relation strings. Each cluster corresponds to a relation, and a pair of objects can appear in at most one cluster (relation). In contrast, SNE allows a pair of objects to participate in multiple relations (semantic statements). Shinyama and Sekine <ref type="bibr" target="#b24">[25]</ref> form (possibly overlapping) clusters of tuples of objects (rather than just pairs of objects). They use the words surrounding the objects in the same sentence to form a pattern. Objects in sentences with the same pattern are deemed to be related in the same way, and are clustered together. All three previous systems are not domain-independent because they rely on name entity (NE) taggers to identify objects in text. The concepts and relations that they learn are restricted by the object types that can be identified with the NE taggers. All three systems also use ad-hoc techniques that do not give a probability distribution over possible worlds, which we need in order to perform inference and answer queries. By only forming clusters of (tuples of) objects, and not relations, they do not explicitly learn high-level relations like SNE. ALICE <ref type="bibr" target="#b1">[2]</ref> is a system for lifelong knowledge extraction from a Web corpus. Like SNE, it uses TextRunner's triples as input. However, unlike SNE, it requires background knowledge in the form of an existing domain-specific concept taxonomy, and does not cluster relations into higher level ones.</p><p>RESOLVER <ref type="bibr" target="#b27">[28]</ref> is a system that takes TextRunner's triples as input, and resolves references to the same object and relations by clustering the references together (e.g., Red Planet and Mars are clustered together). In contrast, SNE learns abstract concepts and relations (e.g., Mars, Venus, Earth, etc. are clus-tered together to form the concept of 'planet'). Unlike SNE, RESOLVER's probabilistic model clusters objects and relations separately rather than jointly. To allow information to propagate between object clusters and relation clusters, RESOLVER uses an ad-hoc approach. In its experiments, RESOLVER gives similar results with or without the ad-hoc approach. In contrast, we show in our experiments that SNE gives better performance with joint rather than separate clustering (see <ref type="table" target="#tab_2">Table 3</ref>). In a preliminary experiment where we adapt SNE to only use string similarities between objects (and relations), we find that SNE performs better than RESOLVER on an entity resolution task on the dataset described in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experiments</head><p>Our goal is to create a system that is capable of extracting semantic networks from what is arguably the largest and most accessible text resource -the Web. Thus in our experiments, we use a large Web corpus to evaluate the effectiveness of SNE's relational clustering approach in extracting a simple semantic network from it. Since to date, no other system could do the same, we had to modify three other relational clustering approaches so that they could run on our large Web-scale dataset, and compared SNE to them. The three approaches are Multiple Relational Clusterings <ref type="bibr" target="#b11">[12]</ref>, Information-Theoretic Co-clustering <ref type="bibr" target="#b4">[5]</ref>, and the Infinite Relational Model <ref type="bibr" target="#b10">[11]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Multiple Relational Clusterings</head><p>Like SNE, MRC is a model that simultaneously clusters objects and relations without requiring the number of clusters to be specified in advance. However, unlike SNE, MRC is able to find multiple clusterings, rather than just one. MRC is also defined using finite second-order Markov logic. The main difference between SNE and MRC is in the search algorithm used. MRC also differs from SNE in having an exponential prior on the number of clusters rather than on the number of cluster combinations with true ground atoms. MRC calls itself recursively to find multiple clusterings. We can view MRC as growing a tree of clusterings, and it returns the finest clusterings at the leaves. In each recursive call, MRC uses a top-down generate-and-test greedy algorithm with restarts to find the MAP clustering of the subset of relation and constant symbols it received. While this 'blind' generate-and-test approach may work well for small datasets, it will not be feasible for large Web-scale datasets like the one used in our experiments. For such large datasets, the search space will be so enormous that the top-down algorithm will generate too many candidate moves to be tractable. In our experiments, we replaced MRC's search algorithm with the algorithm in <ref type="table" target="#tab_0">Table 1</ref>. We use MRC1 to denote an MRC model that is restricted to find a single clustering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Information-Theoretic Co-clustering</head><p>The ITC model <ref type="bibr" target="#b4">[5]</ref> clusters discrete data in a two-dimensional matrix along both dimensions simultaneously. It greedily searches for the hard clusterings that optimize the mutual information between the row and column clusters. The model has been shown to perform well on noisy and sparse data. ITC's top-down search algorithm has the flavor of K-means, and requires the number of row and column clusters to be specified in advance. At every step, ITC finds the best cluster for each row or column by iterating through all clusters. This will not be tractable for large datasets like our Web dataset, which can contain many clusters. Thus, we instead use the algorithm in <ref type="table" target="#tab_0">Table 1 (∆P in Table 1</ref> is set to the change in mutual information rather than the change in log-posterior probability). Notice that, even if ITC's search algorithm were tractable, we would not be able to apply it to our problem because it only works on two-dimensional data. We extend ITC to three dimensions by optimizing the mutual information among the clusters of three dimensions. Furthermore, since we do not know the exact number of clusters in our Web dataset a priori, we follow <ref type="bibr" target="#b4">[5]</ref>'s suggestion of using an information-theoretic prior (BIC <ref type="bibr" target="#b23">[24]</ref>) to select the appropriate number of clusters. We use ITC-C and ITC-CC to respectively denote the model with a BIC prior on clusters, and the model with a BIC prior on cluster combinations. Note that, unlike SNE, ITC does not give a probability distribution over possible worlds, which we need in order to do inference and answer queries (although that is not the focus of this paper).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Infinite Relational Model</head><p>Like SNE, the IRM <ref type="bibr" target="#b10">[11]</ref> is a model that simultaneously clusters objects and relations without requiring the number of clusters to be specified in advance. It defines a generative model for the predicates and cluster assignments. It assumes that the predicates are conditionally independent given the cluster assignments, and the cluster assignments for each type are independent. IRM uses a Chinese restaurant process (CRP) prior on the cluster assignments. Under the CRP, each new object is assigned to an existing cluster with probability proportional to the cluster size. IRM assumes that the probability p of an atom being true conditioned on cluster membership is generated according to a Beta distribution, and that the truth values of atoms are then generated according to a Bernoulli distribution with parameter p. IRM finds the MAP cluster assignment using a top-down search similar to MRC, except that it also searches for the optimal values of its CRP and Beta parameters. As mentioned earlier, top-down search is not feasible for large Web-scale data, so we replace IRM's search algorithm with the one in <ref type="table" target="#tab_0">Table 1</ref>. We also fixed the values of the CRP and Beta parameters. As in SNE, we assumed that the atoms in cluster combinations with only false atoms belonged to a default cluster combination, and they had the same probability p f alse of being false. We also experimented with a CRP prior on cluster combinations. We use IRM-C and IRM-CC to respectively denote the IRM with a CRP prior on clusters, and the IRM with a CRP prior on cluster combinations. Xu et al. <ref type="bibr" target="#b26">[27]</ref> proposed a model closely related to the IRM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Dataset</head><p>We compared the various models on a dataset of about 2.1 million triples 2 extracted in a Web crawl by TextRunner <ref type="bibr" target="#b0">[1]</ref>. Each triple takes the form r(x, y) where r is a relation symbol, and x and y are object symbols. Some example triples are: named after(Jupiter, Roman god) and upheld(Court, ruling). There are 15,872 distinct r symbols, 700,781 distinct x symbols, and 665,378 distinct y symbols. Two characteristics of TextRunner's extractions are that they are sparse and noisy. To reduce the noise in the dataset, our search algorithm <ref type="table" target="#tab_0">(Table 1)</ref> only considered symbols that appeared at least 25 times. This leaves 10,214 r symbols, 8942 x symbols, and 7995 y symbols. There are 2,065,045 triples that contain at least one symbol that appears at least 25 times. In all experiments, we set the CanopyM ax parameter to 50. We make the closed-world assumption for all models (i.e., all triples not in the dataset are assumed false).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">SNE vs. MRC</head><p>We compared the performances of SNE and MRC1 in learning a single clustering of symbols. We set the λ, µ and p f alse parameters in SNE to 100, 100 and 0.9999 respectively based on preliminary experiments. We set SNE's α and β parameters to 2.81 × 10 −9 and 10 − α so that α α+β is equal to the fraction of true triples in the dataset. (A priori, we should predict the probability that a ground atom is true to be this value.) We evaluated the clusterings learned by each model against a gold standard manually created by the first author. The gold standard assigns 2688 r symbols, 2568 x symbols, and 3058 y symbols to 874, 511, and 700 non-unit clusters respectively. We measured the pairwise precision, recall and F1 of each model against the gold standard. Pairwise precision is the fraction of symbol pairs in learned clusters that appear in the same gold clusters. Pairwise recall is the fraction of symbol pairs in gold clusters that appear in the same learned clusters. F1 is the harmonic mean of precision and recall. For the weight of MRC1's exponential prior on clusters, we tried the following values and pick the best: 0, 1, 10-100 (in increments of 10), and 110-1000 (in increments of 100). We report the precision, recall and F1 scores that are obtained with the best value of 80. From <ref type="table" target="#tab_1">Table 2</ref>, we see that SNE performs significantly better than MRC1.</p><p>We also ran MRC to find multiple clusterings. Since the gold standard only defines a single clustering, we cannot use it to evaluate the multiple clusterings. We provide a qualitative evaluation instead. MRC returns 23,151 leaves that contain non-unit clusters, and 99.8% of these only contain 3 or fewer clusters of size 2. In contrast, SNE finds many clusters of varying sizes (see <ref type="table" target="#tab_4">Table 6</ref>). The poor performance of MRC in finding multiple clusterings is due to data sparsity. In each recursive call to MRC, it only receives a small subset of the relation and object symbols. Thus with each call the data becomes sparser, and there is not enough signal to cluster the symbols.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Joint vs. Separate Clustering of Relations and Objects</head><p>We investigated the effect of having SNE only cluster relation symbols, firstargument object symbols, or second-argument object symbols, e.g., if SNE cluster relation symbols, then it does not cluster both kinds of object symbols. From <ref type="table" target="#tab_2">Table 3</ref>, we see that SNE obtains a significantly higher F1 when it clusters relations and objects jointly than when it clusters them separately.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7">SNE vs. IRM and ITC</head><p>We compared IRM-C and IRM-CC with respect to the gold standard. We set IRM's Beta parameters to the values of SNE's α and β, and set p f alse to the same value as SNE's. We tried the following values for the parameter of the CRP priors: 0.25, 0.5, 0.75, 1-10 (in increments of 1), 20-100 (in increments of 10). We found that the graphs showing how precision, recall, and F1 vary with the CRP value are essentially flat for both IRM-C and IRM-CC. Both system perform about the same. The slightly higher precision, recall, and F1 scores occur at the low end of the values we tried, and we use the best one of 0.25 for the slightly better-performing IRM-CC system. Henceforth, we denote this IRM as IRM-CC-0.25, and use it for other comparisons.</p><p>We also compared SNE, IRM-CC-0.25, ITC-C, and ITC-CC. From <ref type="table">Table 4</ref>, we see that ITC performs better with a BIC prior on cluster combinations than a BIC prior on clusters. We also see that SNE performs the best in terms of F1.</p><p>We then evaluated SNE, IRM-CC-0.25 and ITC-CC in terms of the semantic statements that they learned. A cluster combination that contains a true ground atom corresponds to a semantic statement. SNE, IRM-CC-0.25 and ITC-CC <ref type="table">Table 4</ref>. Comparison of SNE, IRM-CC-0.25, ITC-CC, and ITC-C performances on gold standard. Object 1 and Object 2 respectively refer to the object symbols that appear as the first and second arguments of relations. The best F1s are shown in bold.   <ref type="table" target="#tab_3">Table 5</ref> shows the results. Even though SNE's accuracy is smaller than IRM-CC-0.25's and ITC-CC's by 11% and 7% respectively, SNE more than compensates for the lower accuracy by learning 127% and 273% more correct statements respectively. <ref type="figure" target="#fig_3">Figure 1</ref> shows examples of correct semantic statements learned by SNE. SNE, IRM-CC-0.25 and ITC-CC respectively ran for about 5.5 hours, 9.5 hours, and 3 days on identically configured machines. ITC-CC spent most of its time computing the mutual information among three clusters. To compute the mutual information, given any two clusters, we have to retrieve the number of cluster combinations that contain the two clusters. Because of the large number of cluster pairs, we choose to use a data structure (red-black tree) that is spaceefficient, but pays a time penalty when looking up the required values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Relation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.8">Comparison of SNE with WordNet</head><p>We also compared the object clusters that SNE learned with WordNet <ref type="bibr" target="#b7">[8]</ref>, a hand-built semantic lexicon for the English language. WordNet organizes 117,798 distinct nouns into a taxonomy of 82,115 concepts. There are respectively 4883 first-argument, and 5076 second-argument object symbols that appear at least 25 times in our dataset, and also in WordNet. We converted each node (synset) in WordNet's taxonomy into a cluster containing its original concepts, and all its children concepts. We then matched each SNE cluster to the WordNet cluster that gave the best F1 score. We measured F1 as the harmonic mean of precision  and recall. Precision is the fraction of symbols in an SNE cluster that is also in the matched WordNet cluster. Recall is the fraction of symbols in a WordNet cluster that is also in the corresponding SNE cluster. <ref type="table" target="#tab_4">Table 6</ref> shows how precision, recall, and F1 vary with cluster sizes. (The scores are averaged over all object clusters of the same size). We see that the F1s are fairly good for object clusters of size 7 or less. The table also shows how the level of the matched cluster in WordNet's taxonomy vary with cluster size. The higher the level, the more specifc the concept represented by the matched WordNet cluster. For example, clusters at level 7 correspond to specific concepts like 'country', 'state', 'dwelling', and 'home', while the single cluster at level 0 (i.e., at the root of the taxonomy) corresponds to 'all entities'. We see that the object clusters correspond to fairly specifc concepts in WordNet. We did not compare the relation clusters to WordNet's verbs because the overlap between the relation symbols and the verbs are too small.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion and Future Work</head><p>We presented SNE, a scalable, unsupervised, domain-independent system for extracting knowledge in the form of simple semantic networks from text. SNE is based on second-order Markov logic. It uses a bottom-up agglomerative clustering algorithm to jointly cluster relation symbols and object symbols, and allows information to propagate between the clusters as they are formed. Empirical comparisons with three systems on a large real-world Web dataset show the promise of our approach. Directions for future work include: integrating tuple extraction into SNE's Markov logic framework so that information can flow between semantic network learning and tuple extraction, potentially improving the performance of both; extending the learning mechanism so as to learn richer semantic networks as well as complex logical theories from text; etc.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>in P ({Γr, Γx, Γy}|R) if γ, γ are merged if ∆P &gt; 0, CandidateM erges ← CandidateM erges ∪ {(γ, γ )} sort CandidateM erges in descending order of ∆P M ergedClusters ← ∅ for each (γ, γ ) ∈ CandidateM erges if γ ∈ M ergedClusters and γ ∈ M ergedClusters Γi ← (Γi \ {γ, γ }) ∪ {γ ∪ γ } M ergedClusters ← M ergedClusters ∪ {γ} ∪ {γ } mergedOccurred ← true return {(γr, γx, γy) ∈ Γr × Γx × Γy : (γr, γx, γy) contains at least one true ground atom}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Fragments of a semantic network learned by SNE. Nodes are concept clusters, and the labels of links are relation clusters. More fragments are available at http://alchemy.cs.washington.edu/papers/kok08.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>Table 1 . The SNE algorithm.</head><label>1</label><figDesc></figDesc><table>function SN E(Sr, Sx, Sy, R) 
inputs: Sr, set of relation symbols 
Sx, set of object symbols that appear as first arguments 
Sy, set of object symbols that appear as second arguments 
R, ground r(x, y) atoms formed from the symbols </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><head>Table 2 . Comparison of SNE and MRC1 performances on gold standard. Object 1 and Object 2 respectively refer to the object symbols that appear as the first and second arguments of relations. The best F1s are shown in bold.</head><label>2</label><figDesc></figDesc><table>Relation 
Object 1 
Object 2 
Model Prec. Recall 
F1 Prec. Recall 
F1 Prec. Recall 
F1 
SNE 0.452 0.187 0.265 0.460 0.061 0.108 0.558 0.062 0.112 
MRC1 0.054 0.044 
0.049 0.031 0.007 
0.012 0.059 0.011 
0.018 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table 3 .</head><label>3</label><figDesc></figDesc><table>Comparison of SNE performance when it clusters relation and object symbols 
jointly and separately. SNE-Sep clusters relation and object symbols separately. Object 
1 and Object 2 respectively refer to the object symbols that appear as the first and 
second arguments of relations. The best F1s are shown in bold. 

Relation 
Object 1 
Object 2 
Model 
Prec. Recall 
F1 Prec. Recall 
F1 Prec. Recall 
F1 
SNE 
0.452 0.187 0.265 0.460 0.061 0.108 0.558 0.062 0.112 
SNE-Sep 0.597 0.116 
0.194 0.519 0.045 
0.083 0.551 0.047 
0.086 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 5 .</head><label>5</label><figDesc></figDesc><table>Evaluation of semantic statements learned by SNE, IRM-CC-0.25, and ITC-
CC. 

Total 
Num. Fract. 
Model 
Statements Correct Correct 
SNE 
1241 
965 
0.778 
IRM-CC-0.25 
487 
426 
0.874 
ITC-CC 
310 
259 
0.835 

respectively learned 1,464,965, 1,254,995 and 82,609 semantic statements. We 
manually inspected semantic statements containing 5 or more true ground atoms, 
and counted the number that were correct. </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 6 . Comparison of SNE object clusters with WordNet.</head><label>6</label><figDesc></figDesc><table>Cluster Num. 
Size Clusters Level 
Prec. 
Recall 
</table></figure>

			<note place="foot">t k log t k + α t k + f k + α + β + f k log f k + β t k + f k + α + β − λm cc + µd + C (1) 1 The derivation of the log-posterior is given in an online appendix at http://alchemy.cs.washington.edu/papers/kok08.</note>

			<note place="foot" n="2"> Publicly available at http://knight.cis.temple.edu/∼yates/data/resolver data.tar.gz</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Open information extraction from the web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Banko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Cafarella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Soderland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Broadhead</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Etzioni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IJCAI-2007</title>
		<meeting>IJCAI-2007<address><addrLine>Hyderabad, India</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Strategies for lifelong knowledge extraction from the web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Banko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Etzioni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. K-CAP-2007</title>
		<meeting>K-CAP-2007<address><addrLine>British Columbia, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Toward a Model of Children&apos;s Story Comprehension</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Charniak</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1972" />
			<pubPlace>Boston, MA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Artificial Intelligence Laboratory, Massachusetts Institute of Technology</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Learning to extract symbolic knowledge from the World Wide Web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">W</forename><surname>Craven</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dipasquo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Freitag</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mccallum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Nigam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Slattery</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AAAI-98</title>
		<meeting>AAAI-98<address><addrLine>Madison, WI</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="509" to="516" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Information-theoretic co-clustering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">S</forename><surname>Dhillon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mallela</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Modha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. KDD-2003</title>
		<meeting>KDD-2003<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">In-Depth Understanding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">G</forename><surname>Dyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983" />
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Machine reading</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Etzioni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Banko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Cafarella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2007 AAAI Spring Symposium on Machine Reading</title>
		<meeting>2007 AAAI Spring Symposium on Machine Reading<address><addrLine>Palo Alto, CA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">WordNet: An Electronic Lexical Database</title>
		<editor>C. Gellbaum</editor>
		<imprint>
			<date type="published" when="1998" />
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Logical Foundations of Artificial Intelligence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Genesereth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">J</forename><surname>Nilsson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987" />
			<publisher>Morgan Kaufmann</publisher>
			<pubPlace>San Mateo, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Discovering relations among named entities from large corpora</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Hasegawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sekine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Grishman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACL-2004</title>
		<meeting>ACL-2004<address><addrLine>Barcelona, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Learning systems of concepts with an infinite relational model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kemp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Tenenbaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">L</forename><surname>Griffiths</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Yamada</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Ueda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AAAI-2006</title>
		<meeting>AAAI-2006<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Statistical predicate invention</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kok</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Domingos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICML-2007</title>
		<meeting>ICML-2007<address><addrLine>Corvallis, Oregon</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="443" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">The Process of Question Answering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">G</forename><surname>Lehnert</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1978" />
			<pubPlace>Erlbaum, Hillsdale, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A note on the unification of information extraction and data mining using conditional-probability, relational models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mccallum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Jensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IJCAI-2003 Workshop on Learning Statistical Models from Relational Data</title>
		<meeting>IJCAI-2003 Workshop on Learning Statistical Models from Relational Data<address><addrLine>Acapulco, Mexico</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="79" to="86" />
		</imprint>
	</monogr>
	<note>IJCAII</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Efficient clustering of high-dimensional data sets with application to reference matching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mccallum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Nigam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ungar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. KDD-2000</title>
		<meeting>KDD-2000</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="169" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Reading the web: A breakthrough goal for AI. AI Magazine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Mitchell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="12" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Learning for semantic parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Mooney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CICLing-2007</title>
		<meeting>CICLing-2007<address><addrLine>Mexico City, Mexico</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Names and similarities on the web: Fact extraction on the fast lane</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pasca</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bigham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lifchits</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Jain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACL/COLING-2006</title>
		<meeting>ACL/COLING-2006</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Probabilistic Reasoning in Intelligent Systems: Networks of Plausible Inference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pearl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
			<publisher>Morgan Kaufmann</publisher>
			<pubPlace>San Francisco, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Semantic memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Quillian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Semantic Information Processing</title>
		<editor>M. L. Minsky</editor>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1968" />
			<biblScope unit="page" from="216" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Mining semantic networks for knowledge discovery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Rajaraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A-H</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICMD-2003</title>
		<meeting>ICMD-2003</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Markov logic networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Domingos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="107" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">C</forename><surname>Schank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">K</forename><surname>Riesbeck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inside Computer Understanding. Erlbaum</title>
		<imprint>
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Estimating the dimension of a model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Schwarz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Statistics</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="461" to="464" />
			<date type="published" when="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Preemptive information extraction using unrestricted relation discovery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Shinyama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sekine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HLT-NAACL-2006</title>
		<meeting>HLT-NAACL-2006<address><addrLine>New York, New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Learning synchronous grammars for semantic parsing with lambda calculus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">W</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Mooney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACL-2007</title>
		<meeting>ACL-2007<address><addrLine>Prague, Czech Republic</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Infinite hidden relational models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Tresp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-P</forename><surname>Kriegel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. UAI-2006</title>
		<meeting>UAI-2006<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Unsupervised resolution of objects and relations on the web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Yates</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Etzioni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NAACL-HLT-2007</title>
		<meeting>NAACL-HLT-2007<address><addrLine>Rochester, NY</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Learning to map sentences to logical form: Structured classification with probabilistic categorial grammers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">S</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Collins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. UAI-2005</title>
		<meeting>UAI-2005<address><addrLine>Edinburgh, Scotland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
