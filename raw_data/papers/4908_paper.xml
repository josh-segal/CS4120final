<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T17:05+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Mechanism Design Over Discrete Domains</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahuva</forename><surname>Mu&amp;apos;alem</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Engineering and Computer Science</orgName>
								<orgName type="laboratory">Social and Information Sciences Laboratory</orgName>
								<orgName type="institution" key="instit1">California Institute of Technology</orgName>
								<orgName type="institution" key="instit2">Hebrew University of Jerusalem</orgName>
								<address>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schapira</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Engineering and Computer Science</orgName>
								<orgName type="laboratory">Social and Information Sciences Laboratory</orgName>
								<orgName type="institution" key="instit1">California Institute of Technology</orgName>
								<orgName type="institution" key="instit2">Hebrew University of Jerusalem</orgName>
								<address>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Mechanism Design Over Discrete Domains</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Fm [Theory of Computation]: MISCELLANEOUS General Terms Algorithms</term>
					<term>Economics</term>
					<term>Theory Keywords Game Theory</term>
					<term>Mechanism Design</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Often, we wish to design incentive-compatible algorithms for settings in which the players&apos; private information is drawn from discrete domains (e.g., integer values). Our main result is identifying discrete settings in which an algorithm can be made incentive-compatible iff the function it computes upholds a simple monotonicity constraint, known as weak-monotonicity. To the best of our knowledge, this is the first such characterization of incentive-compatibility in discrete domains (such characterizations were previously known only for inherently non-discrete domains, e.g., convex domains). We demonstrate the usefulness of this result by showing an application to the TCP-inspired congestion-control problem presented in [20].</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Motivation. The economic field of mechanism design, and its algorithmic extensions <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref>, focus on the design of algorithms that aim to achieve global objectives in settings in which the "input" is provided by self-interested strategic players. This necessitates the design of algorithms that are incentive-compatible in the sense that players are incentivized via payments to behave as instructed. The most natural approach to designing incentive-compatible algorithms is coming up with an algorithm and an explicit payment * Supported by grants from the Israel Science Foundation.</p><p>Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. EC'08, <ref type="bibr">July 8-12, 2008</ref>, Chicago, Illinois, USA. Copyright 2008 ACM 978-1-60558-169-9/08/07 ...$5.00.</p><p>scheme that guarantees its incentive-compatibility. However, finding appropriate payments is often a difficult, settingspecific, task, which is mostly achievable for very simple types of algorithms.</p><p>A more general approach is the following: Any algorithm that interacts with selfish players and then outputs an outcome, can be regarded as computing a function, called a social-choice function, from the players' "input" to some outcome space. Certain properties of social-choice functions are known to imply their implementability, that is, the existence of a payment scheme that guarantees incentivecompatibility. Hence, instead of explicitly dealing with payments, the problem of designing incentive-compatible algorithms boils down to analyzing the mathematical properties of the social-choice functions computed by algorithms. This approach makes sense if these mathematical properties are simple and easy to analyze.</p><p>A simple constraint on social choice functions called "weakmonotonicity" has been shown to characterize the implementability of social choice functions in several interesting settings. However, all these characterizations of incentivecompatibility are known to apply only to environments in which the private information of the players is drawn from inherently non-discrete domains (for instance, convex domains).</p><p>In this paper we address the problem of finding sufficient and necessary conditions for the implementability of social choice functions in discrete settings. This question is motivated by the many cases in which the private information of the players is drawn from discrete domains (e.g., integers). Implementability in discrete domains is still little understood and has received but little attention in economics literature (see <ref type="bibr" target="#b12">[13]</ref>). Characterizing implementability in discrete domains may prove to be helpful to the design of incentivecompatible algorithms.</p><p>The Setting and Related Work. We consider the standard mechanism design setting: There are n players 1 . . . n, and a set of outcomes O. Each player i has a private valuation function vi ∈ Vi that assigns a real value to every o ∈ O (the higher the value of the outcome the more desirable it is). A (deterministic) social-choice function is a function that assigns an outcome o to every v ∈ V , where V denotes V1 × . . .× Vn. Intuitively, a social-choice function f is said to be implementable iff there is a payment-function pi : V → R such that each player i never gains from "lying" about his valuation function. Formally, let V−j denote the cartesian product of all Vis but Vj , and let (vi, v−i) denote the profile of valuation functions in which player i's valuation function is vi ∈ Vi, and the other players' valuation functions are as specified by v−i ∈ V−i. Then, f is implementable iff there is a payment function pi such that for every i ∈ [n], for every v−i ∈ V−i, and for every vi,</p><formula xml:id="formula_0">v ′ i ∈ Vi, vi(f (vi, v−i)) − pi(vi, v−i) ≥ vi(f (v ′ i , v−i)) − pi(v ′ i , v−i).</formula><p>An algorithm is incentive-compatible (in dominant strategies) if the social-choice function it computes is implementable. Rochet <ref type="bibr" target="#b17">[18]</ref> has shown that any social-choice function is implementable iff a constraint called "cycle monotonicity" holds. Hence, it is possible to show that an algorithm is incentive-compatible by proving that the social-choice function it computes upholds cycle monotonicity. Indeed, recently Lavi and Swamy <ref type="bibr" target="#b10">[11]</ref> have done so in the context of a simple scheduling problem (over severely restricted discrete domains). However, in general, resorting to this technique tends to be quite complicated and cumbersome. For this reason, researchers seek characterizations of implementability that are simpler to analyze (and thus more useful in the design of incentive-compatible algorithms). Bikhchandani et al. <ref type="bibr" target="#b2">[3]</ref> proposed the simple weak-monotonicity constraint: A social-choice function f is said to be weakly-monotone if for every i ∈ [n], for every v−i ∈ V−i, and for every vi,</p><formula xml:id="formula_1">v ′ i ∈ Vi, such that f (vi, v−i) = o1 and f (v ′ i , v−i) = o2 it holds that vi(o1) + v ′ i (o2) ≥ vi(o2) + v ′ i (o1)</formula><p>. Informally, f is said to be strongly-monotone if this inequality is always strict (see <ref type="bibr" target="#b9">[10]</ref> for the formal definition). Observe that unlike the definition of implementability, the definition of weak-monotonicity does not involve a payment function. It is easy to show that weak monotonicity is always necessary for the implementability of a social-choice function (e.g., <ref type="bibr" target="#b2">[3]</ref>) but that it is not always sufficient. Weak and strong monotonicity have proven to be very useful in various mechanism design settings, see e.g., <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b3">4]</ref>.</p><p>We shall call a domain of valuation functions V = V1 × . . . × Vn a weak-monotonicity domain if weak-monotonicity is both sufficient and necessary for implementability. <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b8">9]</ref> present some canonical examples of weak-monotonicity domains. Saks and Yu <ref type="bibr" target="#b18">[19]</ref> extended these results by showing that if each Vi is convex then V is a weak-monotonicity domain. Monderer <ref type="bibr" target="#b13">[14]</ref> has taken this an additional step forward by essentially showing that this is true even if the closure of each Vi is convex 1 . All the aforementioned results apply to non-discrete domains only (convex domains etc.).</p><p>Our Contribution. We exhibit (in Section 2) the first family of discrete weak-monotonicity domains (to the best of our knowledge), which we term Monge domains. The proof that Monge domains are indeed weak-monotonicity domains takes advantage of the two dimensional version of submodularity (see <ref type="bibr" target="#b5">[6]</ref>) that holds for this kind of domains (expressed by Monge matrices, hence the name). We highlight several properties of Monge domains that are useful from a mechanism design perspective and demonstrate their applicability in the context of the TCP-inspired congestion-control setting presented in <ref type="bibr" target="#b19">[20]</ref> (in Section 3). In this congestioncontrol setting each strategic player ("flow") wants to transmit packets along a fixed path in a network in which the nodes are non-strategic routers. Routers drop packets using fair queuing <ref type="bibr" target="#b6">[7]</ref> if the network becomes congested. The flows must decide on their transmission rates, and wish to maximize their throughput. We exploit the Monge structure of this domain to prove that the social-choice function that optimizes the max-min fairness value is implementable.</p><p>Finally (in Section 4), we present some simple discrete domains that are not weak-monotonicity domains, like integer grid domains. For these domains we show that despite the fact that weak-monotonicity does not imply the implementability of social-choice functions, strong-monotonicity is sufficient for implementability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">MONGE DOMAINS AND MECHANISM DESIGN</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Monge Domains and Alignment</head><p>In order to define Monge domains we must first explain what Monge matrices are:</p><formula xml:id="formula_2">Definition 1. A matrix A = (ar,c) r∈[R],c∈[C] is a Monge matrix if for every integers 1 ≤ r &lt; r ′ ≤ R and 1 ≤ c &lt; c ′ ≤ C it holds that ar,c + a r ′ ,c ′ ≥ a r,c ′ + a r ′ ,c .</formula><p>So, Monge matrices are simply matrices for which a simple inequality holds (for every two diagonals). These inequalities can be regarded as a two-dimensional version of submodularity (e.g. <ref type="bibr" target="#b5">[6]</ref>). One of the useful properties of Monge matrices is that it is easy to verify, for any given matrix, whether it is a Monge matrix (as implied by the following proposition). <ref type="bibr">[C]</ref> is a Monge matrix iff for every integers 1 ≤ r &lt; R and 1 ≤ c &lt; C it holds that ar,c + ar+1,c+1 ≥ ar,c+1 + ar+1,c.</p><formula xml:id="formula_3">Proposition 2.1. [6] A matrix A = (ar,c) r∈[R],c∈</formula><p>That is, in order to verify whether a matrix is a Monge matrix it is sufficient to go over adjacent entries and check whether a simple inequality holds. Remark 2.2. Observe that the definition of Monge domains requires each Vi to be finite. It is easy to extend our definitions and results to Vis of infinite size.</p><formula xml:id="formula_4">Definition 2. A domain V = V1 × . . . × Vn is a Monge domain if for every i ∈ [n]</formula><p>Alignment is a property of social-choice functions that shall play a major role in our proofs.</p><p>Definition 3. A social-choice function f is said to be aligned with a Monge domain V if the following holds: For every i ∈ [n], and for every v−i ∈ V−i, there is a Monge matrix A that corresponds to Vi, such that for every vi</p><formula xml:id="formula_5">≤ A(V i ) v ′ i it holds that f (vi, v−i) ≤ A(O) f (v ′ i , v−i).</formula><p>Like Monge matrices, alignment also has a simple interpretation: A social-choice function is aligned with a Monge domain if its output is "non-decreasing" (when looking at the corresponding Monge matrix). This simple interpretation is explained in <ref type="figure">Figure 2</ref>.1. </p><formula xml:id="formula_6">񮽙 񮽙񮽙 񮽙 񮽙 o s v i j+1 񮽙o r+1 񮽙 v i j 񮽙o r+1 񮽙 . v i j+1 񮽙o r 񮽙 񮽙 v i j 񮽙o r 񮽙 񮽙 񮽙 񮽙 񮽙 o r 񮽙 . 񮽙 񮽙 񮽙 o 2 o 1 v i m ... v i j+1 v i j ... ...</formula><formula xml:id="formula_7">j i (o r ) + v j+1 i (o r+1 ) ≥ v j i (o r+1 ) + v j+1 i</formula><p>(o r ) for every r, j. f must be such that the outcomes chosen for the different valuations (denoted by stars) are downwards sloping</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Monge Domains are Weak-Monotonicity Domains</head><p>Our main result is the following theorem:</p><p>Theorem 2.3. Any Monge Domain is a weak-monotonicity domain.</p><p>We first provide an overview of the proof of Theorem 2.3: Recall that any implementable function is weakly-monotone. So, in order to prove that a Monge domain is a weak-monotonicity domain one must show that weak-monotonicity of a socialchoice function implies its implementability. Our proof that any weakly-monotone social-choice function is implementable consists of 3 main steps:</p><p>• We start by proving a lemma we call the "Shifting Lemma". This lemma is of great use to us throughout the proof of Theorem 2.3.</p><p>• Using the Shifting Lemma, we show that any aligned social-choice function is implementable. We do so by proving that for any aligned social-choice function cyclemonotonicity holds (recall that cycle-monotonicity is sufficient for implementability). This intermediate step in the proof is of independent interest -it shows that one can prove the implementability of a social choice function by proving that it is aligned (a technique we shall use in our application, described in Section 3).</p><p>• After showing that any aligned social-choice function is implementable, we go on to showing that any weaklymonotone social-choice function is implementable. This too requires the use of both the Shifting Lemma and cycle-monotonicity.</p><p>Proof. We shall now present the terminology necessary to state and prove the Shifting Lemma. </p><formula xml:id="formula_8">V alue[(v 1...k i , o 1...k ] = Σ k r=1 v r i (o r ). Let i ∈ [n], let vi ∈ Vi, let v 1...k i = v 1 i , . .</formula><p>. , v k i be a k-tuple of valuation functions in Vi, and let f be a social choice function. We denote by f (v 1...k </p><formula xml:id="formula_9">i , v−i) the k-tuple of outcomes in O f (v 1 i , v−i) . . . f (v k i , v−i). Let o 1...k = o1, ..., o k be a k- tuple of outcomes in O. We let Π[o 1...k ] denote</formula><formula xml:id="formula_10">V alue[v 1...k i , f (v 1...k i , v−i)] ≥ V alue[v 1...k i , π].</formula><p>Remark 2.4. Observe that weak-monotonicity is a version of cycle-monotonicity in which k equals 2. </p><formula xml:id="formula_11">.k = v 1 , . . . , v k ). Let o 1...k = o1, ..., o k be a k-tuple of outcomes in O such that if oj ≤ A(O) oi for some i &lt; j then v i (oi) + v j (oj ) = v i (oj) + v j (oi). Let π 0 = π 0 1 , ..., π 0 k be the permutation in Π[o 1...k ] such that π 0 1 ≤ A(O) . . . ≤ A(O) π 0 k . Then, V alue[v 1...k , o 1...k ] = V alue[v 1...k , π 0 .] Proof. [Sketch] Let 1 ≤ m ≤ k be the index of the smallest element in o1, ..., o k (according to ≤ A(O) ). Consider the k-tuple of outcomes o ′1...k = o ′ 1 , ..., o ′ k such that o ′ 1 = om, o ′ m = o1, and for every i / ∈ {1, m} o ′ i = oi. Observe that it must hold that V alue[v 1...k , o 1...k ] = V alue[v 1...k , o ′1...k ] (if m = 1</formula><note type="other">then this is obvious, if m &gt; 1 this is due to the fact that v</note><formula xml:id="formula_12">1 (o1) + v m (om) = v 1 (om) + v m (o1)). We shall now prove that o ′1...k too has the property that if o ′ j ≤ A(O) o ′ i for some i &lt; j then v i (o ′ i ) + v j (o ′ j ) = v i (o ′ j ) + v j (o ′ i ).</formula><p>Since, this property holds for o 1...k , and o ′1...k only differs from o 1...k in (at most) two coordinates, and since o ′ 1 is smaller than any other outcome, it is easy to see that it suffices to handle the two following cases:</p><p>• Case 1: Consider some 1 &lt; i &lt; m such that o1</p><formula xml:id="formula_13">= o ′ m ≤ O(A) o ′ i . Due to the fact that A is a Monge matrix it must hold that v i (o ′ i ) + v m (o ′ m ) ≤ v i (o ′ m ) + v m (o ′ i )</formula><p>. We wish to show that this inequality is an equality.</p><p>Assume, by contradiction, that</p><formula xml:id="formula_14">v i (o ′ i ) + v m (o ′ m ) &lt; v i (o ′ m ) + v m (o ′ i ).</formula><p>Since om ≤ A(o) oi and i &lt; m, we know that</p><formula xml:id="formula_15">v i (o ′ i ) + v m (o ′ 1 ) = v i (oi) + v m (om) = v i (om) + v m (oi) = v i (o ′ 1 ) + v m (o ′ i ).</formula><p>A simple calculation (subtracting the second inequality from the first) shows that</p><formula xml:id="formula_16">v i (o ′ m ) + v m (o ′ 1 ) &gt; v i (o ′ 1 ) + v m (o ′ m ). However, since o ′ 1 ≤ A(O) o ′ m (o ′ 1</formula><p>is the smallest element), and v i ≤ A(Vr ) v m this is a contradiction to the fact that A is a Monge matrix.</p><p>• Case 2:</p><formula xml:id="formula_17">Consider some i &gt; m such that o ′ i ≤ A(O) o ′ m . Due to the fact that A is a Monge matrix it must hold that v m (o ′ m ) + v i (o ′ i ) ≤ v m (o ′ i ) + v m (o ′ m )</formula><p>. We wish to show that this inequality is an equality. Assume, by contradiction, that</p><formula xml:id="formula_18">v m (o ′ m ) + v i (o ′ i ) &lt; v m (o ′ i ) + v i (o ′ m ). Since oi = o ′ i ≤ A(O) o ′ m = o1</formula><p>and 1 &lt; i, we know that</p><formula xml:id="formula_19">v 1 (o ′ m ) + v i (o ′ i ) = v 1 (o1) + v i (oi) = v 1 (oi) + v i (o1) = v 1 (o ′ i ) + v m (o ′ m ).</formula><p>A simple calculation shows that the two previous inequalities imply that We use the Shifting Lemma to prove the following lemma:</p><formula xml:id="formula_20">v 1 (o ′ m ) + v m (o ′ i ) &gt; v 1 (o ′ i ) + v m (o ′ m</formula><p>Lemma 2. Any social-choice function that is aligned with a Monge domain is implementable.</p><p>Proof. Let f be a social choice function that is aligned with a Monge domain. Assume that f is not implementable. In this case, it must be that f does not uphold cycle-monotonicity. That is, there is some r ∈ [n], some v−r ∈ V−r, some k-tuple v </p><formula xml:id="formula_21">i &lt; j such that π * j ≤ A(O) π * i it holds that v i r (π * i ) + v j r (π * j ) = v i r (π * j ) + v j r (π * i )</formula><p>. This is because A is a Monge matrix and so</p><formula xml:id="formula_22">v i r (π * i ) + v j r (π * j ) ≤ v i r (π * j ) + v j r (π * i )</formula><p>. If this inequality is strict then we get a permutation with a strictly higher value than π * by substituting π * i and π * j . This would contradict the definition of π * .</p><p>So, π * is a permutation for which the conditions specified by the Shifting Lemma hold. Therefore, π * has the same value as the permutation in Π[f (v 1...k r , v−r)] in which the elements are ordered from low to high. However, this permutation is precisely f (v 1...k r , v−r), because f is aligned with A, and so</p><formula xml:id="formula_23">V alue[v 1...k r , f (v 1...k r , v−r)] = V alue[v 1...k r , π * ].</formula><p>A contradiction. Now, consider a social-choice function f for which weakmonotonicity holds. We shall conclude the proof of the theorem by showing that cycle-monotonicity holds for this f . Assume, by contradiction, that it does not. Then, there is some r ∈ [n], some v−r ∈ V−r, some k-tuple v <ref type="bibr" target="#b0">1</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">APPLICATION: CONGESTION CONTROL GAMES</head><p>We shall now apply the concepts and tools presented in Section 2 to the (discretized version) of the TCP-inspired congestion-control setting presented in <ref type="bibr" target="#b19">[20]</ref>: We are given a graph G = (V, E), in which set of vertices V corresponds to non-strategic routers, and the set of edges E corresponds to physical communication links between these routers. For each edge e there is a maximum (integer) number of packets that can traverse that edge simultaneously (i.e., e's capacity), denoted by ce. The players are n flows 1, ..., n, each described by a fixed route ri from a source-vertex si ∈ V to a target-vertex ti ∈ V . Each player i has a private integer value di that represents the number of packets it wishes to transmit.</p><p>For every vector of declared values d ′ 1 , ..., d ′ n , the capacity of each edge e is shared between the flows in the following recursive manner (known as fair queuing <ref type="bibr" target="#b6">[7]</ref>): Let ke be the number of flows whose routes go through e. If for every such flow Flows are selfish and wish to maximize their throughput. The utility of flow i is the minimum of the lowest capacity share it gets (over edges in its route), and di. This corresponds to the number of packets it is able to transmit over its route (a flow does not care whether it is sending di packets or more than di packets). It is known (see <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b19">20]</ref>) that sharing capacity via fair queuing results in an allocation of capacity shares that maximizes the max-min fairness value.</p><p>We shall now prove that it is a dominant strategy for every flow i to truthfully report its private value di.</p><p>Claim 3.1. There is a way to define valuation functions v1, ..., vn for the different flows 1, ..., n such that the congestioncontrol setting in <ref type="bibr" target="#b19">[20]</ref> is a Monge domain.</p><p>Proof. For every flow i, we associate the value di with the valuation function vi that assigns to every (integer) number of packets 1 ≤ a ≤ M , where M is the maximal capacity that can traverse any edge, the value −|di − a|. Now, fix some i ∈ [n], and some profile of declared values of the other flows d−i. Consider the matrix A in which each row r corresponds to the outcome in which i is able to transmit r packets, each column s corresponds to the valuation function vs (associated with ds), and every entry ar,s in A equals vs(r). It is easy to show that A is a Monge matrix. Hence, this congestion-control setting can be embedded in a Monge domain.</p><p>Fair queuing can be regarded as a social-choice function f that maps every vector of valuation functions v1, ..., vn (associated with the dis) to an outcome that specifies how the capacity is shared. This function optimizes the max-min fairness value. The following corollary (from Lemma 2) follows: Corollary 3.3. The fair queuing social-choice function is implementable.</p><p>Remark 3.4. In fact, an examination of the form of alignment of the fair-queuing function reveals that its implementation does not require any payments (payments are constantly 0 -flows are neither required to pay the mechanism nor are they paid by the mechanism).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">WEAK AND STRONG MONOTONICITY</head><p>In this section we focus on two important cases of discrete domains: Integer grid domains, and 0/1 domains. We present an interesting example, given by Lan Yu <ref type="bibr" target="#b20">[21]</ref>, to show that integer grids are not weak-monotonicity domains. We then show, in contrast, that every strongly-monotone social choice function defined over an integer grid domain is implementable. We show that the same is true for 0/1 domains -while weak-monotonicity is insufficient to guarantee implementability, strong-monotonicity is.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Integer Grid Domains</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Integer Grids Are Not Weak-Monotonicity Domains</head><p>Let V = V1 × . . . × Vn be a domain of valuation functions defined over a set of outcomes O. We can think of every vi ∈ Vi as a vector in R |O| specifying a value for every outcome.</p><formula xml:id="formula_24">Definition 6. A valuation function domain is an integer grid domain if V = Z |O| × . . . × Z |O| .</formula><p>That is, an integer grid domain is a domain of valuation functions that can take any combination of integer values. The next proposition, due to Lan Yu <ref type="bibr" target="#b20">[21]</ref>, shows that an integer grid is not a weak-monotonicity domain. In fact, this example can easily be modified to show that no bounded integer grid domain is a weak-monotonicity domain. By bounded integer grid, we simply mean the discrete cube V = {0, 1, ..., L} n|O| (for some positive integer L).</p><p>Proposition 4.1. <ref type="bibr" target="#b20">[21]</ref> There is a social choice function f defined over an integer grid domain that satisfies weakmonotonicity and is not implementable. Lemma 3. The function f is weakly-monotone.</p><p>Proof. In order to show that f is weakly-monotone it is enough to consider the following cases: </p><formula xml:id="formula_25">Case 1: Let f (u) = c, f (v) = a. Assume by contradiction that v(a) − v(c) &lt; u(a) − u(c). If v(a) ≥ v(c) and v(a) ≥ v(b) + 2, then 0 ≤ v(a) − v(c) &lt; u(a) − u(c) implies that u(a) &gt; u(c). This contradicts f (u) = c. If v(c) = v(a) + 1 and v(c) = v(b) + 2, then equivalently, v(a) = v(c) − 1 = v(b) + 1. Now, v(a) − v(c) = −1 &lt; 0 ≤ u(a) − u(c) implies that u(a) ≥ u(c). Contradicting f (u) = c. Case 2: Let f (u) = b, f (v) = a. Assume by contradiction that v(a) − v(b) &lt; u(a) − u(b). If v(a) ≥ v(c) and v(a) ≥ v(b) + 2, then 2 ≤ v(a) − v(b) &lt; u(a) − u(b) implies that u(a) &gt; u(b) + 2</formula><formula xml:id="formula_26">u(c) = u(b) + 1. Now, v(c) − v(b) &lt; u(c) − u(b) = 1 implies that v(c) − v(b) ≤ 0 -a contradiction.</formula><p>To prove that f is not implementable we show that cyclemonotonicity does not hold for f (recall that cycle monotonicity is necessary for implementability).  </p><formula xml:id="formula_27">, u = (1, 0, 1), w = (1, 1, 2). By definition of f , f (v) = a, f (u) = b, f (w) = c. Now v(a) − v(c) + w(c) − w(b) + u(b) − u(a) = −1 + 1 − 1 &lt; 0.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Sufficiency of Strong-Monotonicity</head><p>Theorem 4.4. If f : V → O is strongly-monotone and V is an integer grid domain then f is implementable.</p><p>Proof. For every distinct b, c ∈ O and v−i we define:  Proof. Assume by contradiction that: δ bc + δca &lt; δ ba . The domain is an integer grid, and so there must be v, u such that f (v) = b, f (u) = c, v(b) − v(c) = δ bc and u(c) − u(a) = δca. We can assume w.l.o.g that u(c) = v(c) (if f is stronglymonotone, then adding a constant to v does not change the chosen outcome).</p><formula xml:id="formula_28">δ i bc (v−i) = min {v ′ i (b) − v ′ i (c) | v ′ i ∈ Vi and f (v ′ i , v−i) = b} That is, fixing v−i, δ i bc (v−i) is</formula><p>Define v ′ as follows: v ′ (a) = u(a), and v ′ (d) = v(d) for any outcome d 񮽙 = a. By strong monotonicity f (v ′ ) ∈ {b, a}, as the only changed value is the value of a. We shall show that f (v ′ ) = b. This is clearly the case if u(a) ≤ v(a). Consider the case that v ′ (a) = u(a) &gt; v(a). Now, if f (v ′ ) = a, and recall that f (u) = c, and u(c) = v(c), so we get that v ′ (a) + u(c) = v ′ (c) + u(a), thus contradicting strong monotonicity. Now we are ready to prove our theorem. Fix an arbitrary outcome a ∈ O such that there exists w for which f (w) = a. Consider the following payment scheme: p d is zero if d equals a, and p d = δ da , otherwise. Assume by contradiction that f (v) = b , and f (u) = c, but v(c) − pc &gt; v(b) − p b . That is, if the valuation of the player is v, he might declare u, in order to increase his utility. Clearly, b 񮽙 = c. By definition: v(b) − v(c) ≥ δ bc . Now, by rearranging we get that:</p><formula xml:id="formula_29">δ bc ≤ v(b) − v(c) &lt; p b − pc = δ ba − δca.</formula><p>Hence, we get that: δ bc +δca &lt; δ ba , contradicting the Triangle Inequality Lemma. This completes the proof of the theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">0/1-Domains</head><formula xml:id="formula_30">Definition 7. V = V1 × . . . × Vn is a 0/1 domain if V = {0, 1} |O| × . . . × {0, 1} |O| .</formula><p>We show that, as in the case of integer grids, 0/1 domains are not weak-monotonicity domains, but strong-monotonicity is sufficient for implementability. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">DISCUSSION AND OPEN QUESTIONS</head><p>In this paper we have exhibited the first example of discrete weak-monotonicity domains. We have also presented domains in which weak-monotonicity is insufficient for implementability, but strong-monotonicity does imply implementability. There are many intriguing questions that remain open:</p><p>• We have considered the notion of strategyproofness (incentivecompatibility in dominant strategies). It is would be interesting to understand the implications of the structure of Monge domains to other mechanism design notions. For instance: When can we get group strategyproofness (resilience to deviations even by coalitions of players)? When can we get strategyproofness without money (that is, when the payments are always 0, as in our TCP-related application)?</p><p>• Many examples in mechanism design fall into the category of Monge domains (other than the one presented in Section 3), e.g.,the single parameter scheduling environment discussed by Archer and Tardos <ref type="bibr" target="#b0">[1]</ref>, singlepeaked voting problems, and more. These examples (like ours) all involve single-parameter domains (informally, domains in which the private information of each player is expressed by one real variable). However, our framework does not, at first sight, seem restricted to such domains (there is no such requirement in our model). It would be interesting to apply our techniques to a multi-parameter problem.</p><p>• From a computational perspective, there is much that we do not know. In particular, how hard is it to compute the payments given a Monge domain?</p><p>The answer to this question may require, as an intermediate step, answering another interesting question: What is the form of the payments of implementable functions over Monge domains?</p><p>• We have shown that in integer-grid domains and 0/1 domains strong-monotonicity implies implementability. We do not know whether this is the case for bounded integer grid domains. (By bounded integer grid, we simply mean the discrete cube V = {0, 1, ..., L} n|O| , for some positive integer L).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>there is an order over the out- comes in O o1, o2, . . . and an order over the valuation func- tions in Vi v 1 i , v 2 i , ..., such that the matrix A = (ar,c) in which ar,c = v c i (or) is a Monge matrix. We shall refer to A as a Monge matrix corresponding to Vi. Let ≤ A(O) and ≤ A(V i ) denote the orders over O and Vi, respectively (that is, o ≤ A(O) o ′ if the row in A that corresponds to o comes before the row that corresponds to o ′ , or if it is the same row. ≤ A(V i ) is defined in an analogous way).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: This example depicts an aligned social choice function f defined over a Monge domain. For a fixed v−i there is a Monge matrix, such that the rows represent outcomes, the columns represent valuation functions in Vi, and v j i (o r ) + v j+1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Definition 4 .</head><label>4</label><figDesc>For any k-tuple v 1...k i = v 1 i , . . . , v k i of dif- ferent valuation functions in Vi and any k-tuple o 1...k = o1, ..., o k of outcomes in O, we define:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>the set of all k-tuples of outcomes in O that are obtained by permuting the elements in o 1...k . Definition 5. A social-choice function f is said to up- hold cycle-monotonicity if for every i ∈ [n], for every v−i ∈ V−i, for every positive integer k ≤ |Vi|, for every k-tuple v 1...k i = v 1 i , . . . , v k i of different valuation functions in Vi, and for every π ∈ Π[f (v 1...k i , v−i)], it holds that:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Lemma 1 .</head><label>1</label><figDesc>[Shifting Lemma] Fix r ∈ [n], and integer k ≥ 1. Let A be a Monge matrix corresponding to Vr. Let v 1...k r = v 1 r , . . . , v k r be a k-tuple of different valuation functions in Vr such that v r i ≤ A(Vr ) . . . ≤ A(Vr ) v k r (since r is fixed, for simplicity we shall refer to these valuation functions as v 1..</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Let π 0 = π 0 1 , ..., π 0 k be the permutation in Π[f (v 1...k r , v−r)] such that π 0 1 ≤ A(O) . . . ≤ A(O) π 0 k . Lemma 2 implies that π 0 has the highest value out of all the permu- tations in Π[f (v 1...k r , v−r)]. (This is the permutation that describes the output of an aligned function. For such func- tions Lemma 2 shows that cycle-monotonicity holds.) Let us denote the k-tuple of elements f (v 1...k r , v−r) by o1, ..., o k . Because of the fact that A is a Monge matrix, for every i &lt; j and oj ≤ A(O) oi it holds that v i r (oj ) + v j r (oi) ≤ v i r (oi) + v j r (oj). However, the weak-monotonicity of f im- plies that this inequality also holds in the opposite direc- tion: v i r (oj ) + v j r (oi) ≥ v i r (oi) + v j r (oj ). Therefore, for ev- ery i &lt; j and oj ≤ A(O) oi it holds that v i r (oj ) + v j r (oi) = v i r (oi) + v j r (oj ). This means that we can use the Shifting Lemma to show that the value of f (v 1...k r , v−r) is the same as the value of π 0 . Since π 0 has the highest value out of the all permutations in Π[f (v 1...k r , v−r)] this contradicts the fact that V alue[v 1...k r , f (v 1...k r , v−r)] &lt; V alue[v 1...k r , π].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>i d ′ i ≥ ce ke (rounded down) then allocate a capacity of ce ke to each flow whose route traverses e. Otherwise, perform the following steps: Let d ′ i be the lowest declared value of a flow that goes through e. Allocate a capacity of d ′ i to i. Apply fair queuing to share the remaining capacity of ce −d ′ i between the remaining ke − 1 flows.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Claim 3 . 2 .</head><label>32</label><figDesc>The max-min fairness optimizing (fair-queuing) function f is aligned with the (congestion-control) Monge domain. Proof. Fix some i ∈ [n], and some profile of declared values of the other flows d−i. Let A be a Monge matrix as defined above. Observe that f is aligned with the Monge domain (A flow i cannot get a smaller capacity share by reporting a higher di).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Proof.</head><label></label><figDesc>Consider the following social choice function f : V → O defined for a single player domain (i.e., V = V1). There are 3 distinct outcomes O = {a, b, c} and V = Z 3 . f (v) = 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 a if {v(a) ≥ v(c) and v(a) ≥ v(b) + 2} or {v(c) = v(a) + 1 and v(c) = v(b) + 2}, c if {v(c) &gt; v(a) and v(c) &gt; v(b)} and not {v(c) = v(a) + 1 and v(c) = v(b) + 2}, b otherwise.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>.</head><label></label><figDesc>By definition of f , and by the fact that f (u) = b 񮽙 = a, c, we get that u(a) &lt; u(c) and u(c) ≤ u(b). In particular, u(a) − u(b) &lt; 0 -a contradiction. If v(c) = v(a) + 1 and v(c) = v(b) + 2, then equivalently, v(a) = v(c)−1 = v(b)+1. Now, v(a)−v(b) = 1 &lt; u(a)−u(b) implies that 2 ≤ u(a) − u(b), and we can proceed as before. Case 3: Let f (u) = b, f (v) = c. Assume by contradiction that v(c)−v(b) &lt; u(c)−u(b). Now, f (v) = c, so v(a) &lt; v(c), and v(b) &lt; v(c). Clearly, 0 &lt; v(c) − v(b) &lt; u(c) − u(b), and u(b) &lt; u(c). By definition of f , and by the fact that f (u) = b 񮽙 = a, c, u(c) ≤ u(a) and u(a) &lt; u(b) + 2. In particular, u(c) &lt; u(b) + 2. Therefore, u(b) &lt; u(c) &lt; u(b) + 2, and so</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Claim 4 . 2 .</head><label>42</label><figDesc>f does not uphold cycle-monotonicity. Proof. Consider the valuations v = (2, 1, 3)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Remark 4 . 3 .</head><label>43</label><figDesc>Observe that f is not strongly-monotone: Let v = (2, 1, 3) and u = (1, 0, 1). f (v) = a, f (u) = b, and v(a) + u(b) = 2 + 0 = 1 + 1 = v(b) + u(a). As we shall see next, this is no coincidence.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>the minimum possible dif- ference between a value for b and for c assigned by the same valuation v ′ i (for which f chooses b). Specifically, if f (v) = a, then vi(a) − vi(b) ≥ δ i ab (v−i) for every b ∈ A. W.l.o.g., we shall assume a single player and thus we use the notation δ ab instead of δ i ab (v−i) (since all monotonicity arguments in- volve fixing the other players, one can simplify matters by only considering single-player settings).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Lemma 4 .</head><label>4</label><figDesc>[Triangle Inequality Lemma] Let a, b, c be three arbitrary outcomes. If there exists u, v such that f (v) = b and f (u) = c then: δ bc + δca ≥ δ ba .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Example 4 . 5 .</head><label>45</label><figDesc>We show a 0/1-domain that is not a weak- monotonicity domain. Consider a single player and 3 out- comes O = {a, b, c}, and the following social choice function:It is not hard to verify that f is weakly-monotone. However, it is not cyclic-monotone: Let v =(0,0,1), u=(1,1,0), w=(0,1,1). Now, f (v) = a, f (u) = b, f (w) = c, and v(a) + u(b) + w(c) = 0 + 1 + 1 &lt; 1 + 1 + 1 = v(c) + u(a) + w(b). Proposition 4.6. If f : V → O is strongly-monotone, and V is the 0/1-domains then f is implementable. Proof. [Sketch] W.l.o.g. we assume a single player set- ting. Suppose that there exists a negative cycle of length 3 or more (that is, a violation of cycle-monotonicity with at least 3 outcomes). Assume w.l.o.g that this cycle is: v 1 (a)+v 2 (b)+v 3 (c)+v 4 (d) &lt; v 1 (b)+v 2 (c)+v 3 (d)+v 4 (a). In a 0/1-domain, it cannot be the case that the sum in left hand side is 4. So, assume w.l.o.g that v 1 (a) = 0. Now, we shall show that it must be the case that v 2 (b) + v 3 (c) + v 4 (d) = 3. Assume by contradiction that v 2 (b) = 0. This contradicts strong monotonicity, as 0 = v 1 (a) + v 2 (b) &gt; v 1 (b) + v 2 (a) ≥ 0. Similarly, v 3 (c) = v 4 (d) = 1. But now, if the left hand side equals 3, the right hand side must be equal to 4. By strong monotonicity: 1 = v 1 (a) + v 4 (d) &gt; v 1 (d) + v 4 (a), this can be true only if v 1 (d) + v 4 (a) = 0, and in particular v 4 (a) = 0, a contradiction.</figDesc></figure>

			<note place="foot" n="1"> Monderer basically shows that the closure of each Vi is convex IFF weak monotonicity characterizes implementability for randomized mechanisms. In this paper (as in previous works) we deal with deterministic mechanisms.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>Many thanks to Lan Yu for giving us her permission to include her counter-example in this paper. We thank Shahar Dobzinski and Noam Nisan for helpful discussions. We also thank the anonymous referees for their comments</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Truthful mechanisms for one-parameter agents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aaron</forename><surname>Archer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eva</forename><surname>Tardos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="482" to="491" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Frugal path mechanisms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aaron</forename><surname>Archer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eva</forename><surname>Tardos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Weak monotonicity characterizes deterministic dominant strategy implementation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bikhchandani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chatterji</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Lavi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mu&amp;apos;alem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Nisan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Econometrica</title>
		<imprint>
			<biblScope unit="volume">74</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1109" to="1132" />
			<date type="published" when="2006-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Mechanism design for fractional scheduling on unrelated machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Christodoulou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elias</forename><surname>Koutsoupias</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Annamaria</forename><surname>Kovacs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<editor>Lars Arge, Christian Cachin, Tomasz Jurdzinski, and Andrzej Tarlecki</editor>
		<imprint>
			<biblScope unit="volume">4596</biblScope>
			<biblScope unit="page" from="40" to="52" />
			<date type="published" when="2007" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A lower bound for scheduling mechanisms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Christodoulou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elias</forename><surname>Koutsoupias</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Angelina</forename><surname>Vidali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA</title>
		<editor>Nikhil Bansal, Kirk Pruhs, and Clifford Stein</editor>
		<imprint>
			<publisher>SIAM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="1163" to="1170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Some problems around travelling salesmen, dart boards, and euro-coins</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">G</forename><surname>Deineko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Woeginger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bulletin of the European Association for Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">90</biblScope>
			<biblScope unit="page" from="43" to="52" />
			<date type="published" when="2006-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Analysis and simulation of a fair queueing algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Demers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Keshav</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM &apos;89: Symposium proceedings on Communications architectures &amp; protocols</title>
		<imprint>
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Competitive auctions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Hartline</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anna</forename><surname>Karlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Wright</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
	<note>Working paper. Preliminary versions presented at SODA&apos;01 and STOC&apos;02</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Characterizing dominant strategy mechanisms with multi-dimensional types</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hongwei</forename><surname>Gui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rudolf</forename><surname>Muller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rakesh</forename><surname>Vohra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
	<note>Working paper</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Towards a characterization of truthful combinatorial auctions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ron</forename><surname>Lavi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahuva</forename><surname>Mu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Noam</forename><surname>Nisan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Truthful mechanism design for multi-dimensional scheduling via cycle monotonicity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ron</forename><surname>Lavi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chaitanya</forename><surname>Swamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EC</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Truth revelation in approximately efficient combinatorial auctions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Lehmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Liadan O&amp;apos;callaghan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shoham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="577" to="602" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Optimal mechanisms with finite agent types</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">S</forename><surname>Lovejoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Manage. Sci</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="788" to="803" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Dov Monderer. Monotonicity and implementability</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
	<note>Working paper.</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Setting lower bounds on truthfulness</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahuve</forename><surname>Mu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">&amp;apos;</forename><surname>Alem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schapira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Algorithmic mechanism design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Noam</forename><surname>Nisan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amir</forename><surname>Ronen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Games and Economic Behavior</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="166" to="196" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
				<title level="m">Algorithmic Game Theory</title>
		<editor>Noam Nisan, Tim Roughgarden, Eva Tardos, and Vijay V. Vazirani</editor>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A necessary and sufficient condition for rationalizability in a quasi-linear context</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Rochet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Mathematical Economics</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="191" to="200" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Weak monotonicity suffices for truthfulness on convex domains</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Saks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lan</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EC</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Congestion-control games</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schapira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aviv</forename><surname>Zohar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
	<note>Working paper</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lan</forename><surname>Yu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
	<note>Private communication</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
