<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:42+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Extending Logic Programs with Description Logic Expressions for the Semantic Web</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yi-Dong</forename><surname>Shen</surname></persName>
							<email>ydshen@ios.ac.cn</email>
							<affiliation key="aff0">
								<orgName type="department">Institute of Software</orgName>
								<orgName type="laboratory">State Key Laboratory of Computer Science</orgName>
								<orgName type="institution">Chinese Academy of Sciences</orgName>
								<address>
									<postCode>100190</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kewen</forename><surname>Wang</surname></persName>
							<email>k.wang@griffith.edu.au</email>
							<affiliation key="aff1">
								<orgName type="department">School of Computing and Information Technology</orgName>
								<orgName type="institution">Griffith University Brisbane</orgName>
								<address>
									<postCode>4111</postCode>
									<region>QLD</region>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Extending Logic Programs with Description Logic Expressions for the Semantic Web</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Recently much attention has been directed to extending logic programming with description logic (DL) expressions, so that logic programs have access to DL knowledge bases and thus are able to reason with ontologies in the Semantic Web. In this paper, we propose a new extension of logic programs with DL expressions, called normal DL logic programs. In a normal DL logic program arbitrary DL expressions are allowed to appear in rule bodies and atomic DL expressions (i.e., atomic concepts and atomic roles) allowed in rule heads. We extend the key condition of well-supportedness for normal logic programs under the standard answer set semantics to normal DL logic programs and define an answer set semantics for DL logic programs which satisfies the extended well-supportedness condition. We show that the answer set semantics for normal DL logic programs is decidable if the underlying description logic is decidable (e.g. SHOIN or SROIQ).</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In the development of Semantic Web languages we are concerned with two major components: ontologies and rules. Ontologies describe terminological knowledge and rules model constraints and exceptions over the ontologies. Since the two components provide complementary descriptions of the same problem domain, they are supposed to be integrated in some ways (e.g., <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19]</ref>; see <ref type="bibr" target="#b2">[3]</ref> for a survey). The core of the Web ontology language OWL (more recently, OWL 2) <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b8">9]</ref> is description logics (DLs) <ref type="bibr" target="#b0">[1]</ref> and thus in this paper we assume an ontology is represented as a knowledge base in DLs.</p><p>Logic programming under the (standard) answer set semantics <ref type="bibr" target="#b7">[8]</ref> is currently a widely used declarative language paradigm for knowledge representation and reasoning. A normal logic program Π consists of rules of the form H ← A 1 , · · · , A m , not B 1 , · · · , not B n , where H and each A i and B i are atoms. Such a rule states that if the body A 1 , · · · , A m , not B 1 , · · · , not B n holds, then the head H holds. The semantics of Π is defined by answer sets, which are Herbrand models of Π satisfying the well-supportedness condition <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b6">7]</ref>. Informally, a Herbrand model I is well-supported if for any H ∈ I, there is a rule as above from Π such that I satisfies the rule body and for no A i the evidence of the truth of A i is circularly dependent on H in I. It is this well-supportedness condition that lets rules in a logic program differ from formulas (implications) in classical logic and guarantees that answer sets are free of circular justifications.</p><p>Recently, much attention has been directed to using logic programs to express rules in the Semantic Web by extending logic programming under the answer set semantics with DL expressions <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b18">19]</ref>. By allowing DL expressions to appear in rules, logic programs have access to DL knowledge bases and thus are able to reason with ontologies in the Semantic Web. Major current extensions of logic programs with DL expressions include description logic programs (or dlprograms) <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr">DL+log [19]</ref> and disjunctive dl-programs <ref type="bibr" target="#b15">[16]</ref>.</p><p>Given an external DL knowledge base L, a dl-program extends a normal logic program Π by adding dl-atoms to rule bodies as an interface to access to L <ref type="bibr" target="#b3">[4]</ref>. A dl-atom is of the form DL[S 1 op 1 P 1 , · · · , S m op m P m ; Q](t), where each S i op i P i semantically maps a predicate symbol P i in Π to a concept or role S i in L via a special interface operator op i ∈ { ∪ + , ∪ -, ∩ -}, and Q(t) is a DL expression which will be evaluated against L after the predicate mapping. For instance, p(a) ← DL[c ∪ + p, b ∩ -q; c 񮽙 ¬b](a) is a rule, where the dl-atom queries L if a is in the concept c but not in the concept b, given the mapping that for any x, if p(x) is true then x is in c and if q(x) is false then x is not in b. Note that predicate symbols in Π must be disjoint from predicate symbols (i.e., atomic concepts and atomic roles) in L. Moreover, DL expressions are not allowed to appear in the head of a rule, thus no conclusion about L can be inferred from Π.</p><p>It is necessary to allow DL expressions to occur in rule heads because DL knowledge bases (ontologies) define only general terminological knowledge, while additional constraints and exceptions over some DL concepts/roles must be defined by rules. To avoid predicate mappings between L and Π and allow DL expressions to appear in rule heads, another extension, called DL+log, is introduced <ref type="bibr" target="#b18">[19]</ref>. DL+log lets Π and L share some predicate symbols and allows atomic DL expressions (i.e. atomic concepts and atomic roles) to appear either in bodies or heads of rules without using any predicate mapping operators. One restriction of this extension is that DL expressions are not allowed to appear behind the negation operator not.</p><p>Disjunctive dl-programs <ref type="bibr" target="#b15">[16]</ref> are a third extension of logic programs with DL expressions. This extension allows atomic DL expressions to appear anywhere in a rule, and has a semantics substantially different from that of DL+log.</p><p>For dl-programs, three answer set semantics are introduced in <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref>, called the weak, strong, and FLP-reduct based semantics, respectively. These semantics are proper extensions of the standard answer set semantics, but their answer sets do not satisfy the well-supportedness condition and thus may incur circular justifications by self-supporting loops. For DL+log, a semantics is defined with a class of first-order models, called NM-models <ref type="bibr" target="#b18">[19]</ref>. Such NM-models are not wellsupported models. For disjunctive dl-programs, an FLP-reduct based answer set semantics is defined <ref type="bibr" target="#b15">[16]</ref>. It is a proper extension of the standard answer set semantics, but its answer sets do not satisfy the well-supportedness condition either and thus may also incur circular justifications.</p><p>Observe that the three major extensions of logic programs with DL expressions have complementary features. In syntax, dl-programs allow arbitrary DL expressions in rule bodies, while DL+log and disjunctive dl-programs allow atomic DL expressions in rule heads. In semantics, in dl-programs and DL+log, DL concepts and roles occurring in Π are all interpreted against the external DL knowledge base L under the first-order semantics, while in disjunctive dl-programs, these DL concepts and roles are all included in the Herbrand base of Π and interpreted under the answer set semantics. These observations suggest that it is desirable to have a new extension of logic programs with DL expressions, which allows arbitrary DL expressions in rule bodies and atomic DL expressions in rule heads, and interprets DL concepts and roles occurring in Π flexibly in either of the above ways. Moreover, as we mentioned earlier, well-supportedness is a key condition of logic programming under the standard answer set semantics, so it is desirable to extend this condition to logic programs with DL expressions. In fact, the well-supportedness condition has recently been extended to dl-programs and a new answer set semantics for dl-programs has been developed which satisfies the extended well-supportedness condition <ref type="bibr" target="#b19">[20]</ref>.</p><p>Therefore, in this paper we advance one step further by introducing a fourth extension of logic programs with DL expressions as follows: (1) Given an external DL knowledge base L, we extend a normal logic program Π with DL expressions relative to L by introducing rules of the form</p><formula xml:id="formula_0">H ← A 1 , · · · , A m , not B 1 , · · · , not B n ,</formula><p>where H is an atom or an atomic DL expression, and each A i and B i are either atoms or arbitrary DL expressions. We call this extension Π relative to L a normal DL logic program. (2) We allow DL concepts and roles occurring in Π to flexibly choose between first-order interpretations and Herbrand interpretations, as described above. (3) We extend the well-supportedness condition of the standard answer set semantics from normal logic programs to normal DL logic programs, and define an answer set semantics which satisfies the extended well-supportedness condition and thus whose answer sets are free of circular justifications. (4) We show that the answer set semantics for normal DL logic programs is decidable if the underlying description logic is decidable (e.g. SHOIN or SROIQ <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b11">12]</ref>).</p><p>The paper is arranged as follows. Section 2 briefly reviews logic programs and DL knowledge bases. Section 3 defines normal DL logic programs. Section 4 mentions related approaches, and Section 5 concludes with future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Logic Programs</head><p>Consider a vocabulary Φ = (P, C), where P is a finite set of predicate symbols and C a nonempty finite set of constants. A term is either a constant from C or a variable. Predicate symbols begin with a capital letter, and constants with a lower case letter. We use strings starting with X, Y or Z to denote variables.</p><p>An atom is of the form P (t 1 , ..., t m ), where P is a predicate symbol from P, and t i is a term. A rule r is of the form</p><formula xml:id="formula_1">H ← A 1 , · · · , A m , not B 1 , · · · , not B n<label>(1)</label></formula><p>where H and each A i and B i are atoms. Each A i is called a positive literal, and each not B i called a negative literal. We use head(r) and body(r) to denote the head H and the body A 1 , · · · , A m , not B 1 , · · · , not B n , respectively. We also use pos(r) to denote the positive literals A 1 , · · · , A m , and neg(r) to denote the negative literals not B 1 , · · · , not B n . Therefore, a rule r can simply be written as head(r) ← body(r) or head(r) ← pos(r), neg(r).</p><p>A normal logic program Π consists of a finite set of rules. A ground instance of a rule r is obtained by replacing every variable in r with a constant from C. We use ground(Π) to denote the set of all ground instances of rules in Π. The Herbrand base of Π, denoted HB Π , is the set of all ground atoms P (t 1 , ..., t m ), where P ∈ P occurs in Π and t i is in C. Any subset of HB Π is a Herbrand interpretation (or interpretation for short) of Π. For an interpretation I, let</p><formula xml:id="formula_2">I − = HB Π \ I and ¬I − = {¬A | A ∈ I − }.</formula><p>An interpretation I satisfies a ground atom A ∈ HB Π if A ∈ I, and I satisfies not A if A 񮽙 ∈ I. For a rule r in ground(Π), I satisfies body(r) if for each (positive or negative) literal l in body(r), I satisfies l; I satisfies r if I does not satisfy body(r) or I satisfies head(r). I is a model of Π if I satisfies all r ∈ ground(Π). A minimal model is a model that is minimal in terms of set inclusion.</p><p>Let Π I = {A ← pos(r) | A ← pos(r), neg(r) ∈ ground(Π) and I satisfies neg(r)}. Since Π I has no negative literals in rule bodies, it has a least model. The standard answer set semantics defines I to be an answer set of Π if I is the least model of Π I <ref type="bibr" target="#b7">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">DL Knowledge Bases</head><p>We assume familiarity with the basics of description logics (DLs) <ref type="bibr" target="#b0">[1]</ref>, and for simplicity consider SHOIN , a DL underlying the Web ontology language OWL DL <ref type="bibr" target="#b12">[13]</ref>. The approach presented in this paper can easily be extended to other more expressive DLs such as SROIQ (a logical underpinning for OWL 2) <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b8">9]</ref>, and to DLs with datatypes such as SHOIN (D) and SROIQ(D).</p><p>Consider a vocabulary Ψ = (A ∪ R, I), where A, R and I are pairwise disjoint (denumerable) sets of atomic concepts, atomic roles and individuals, respectively. A role is either an atomic role R from R or its inverse, denoted R − . General concepts C are formed from atomic concepts, roles and individuals, according to the following syntax:</p><formula xml:id="formula_3">C ::= | ⊥ | A | {a} | C 񮽙 C 1 | C 񮽙 C 1 | ¬C | ∃R.C | ∀R.C | ≥ n R | ≤ n R</formula><p>where A is an atomic concept from A, R is a role, a is an individual from I, C and C 1 are concepts, and n is a non-negative integer. An axiom is of the form</p><formula xml:id="formula_4">C 񮽙 D (concept inclusion axiom), R 񮽙 R 1 (role inclusion axiom), Trans(R) (transitivity axiom), C(a) (concept membership axiom), R(a, b) (role membership axiom), =(a, b) (equality axiom), or 񮽙 =(a, b) (inequality axiom),</formula><p>where C, D are concepts, R, R 1 are atomic roles in R, and a, b are individuals in I. <ref type="bibr">We use C ≡ D to denote C 񮽙 D and D 񮽙 C.</ref> A DL knowledge base L is a finite set of axioms. Since DLs are fragments of first-order logic with equality, where atomic concepts (resp. roles) are unary (resp. binary) predicate symbols, and individuals are constants, L has the firstorder semantics. When we say predicate symbols in L, we refer to atomic concepts or atomic roles in L. L is consistent (or satisfiable) if L has a first-order model. For an axiom F , the entailment relation L |= F is defined as in firstorder logic, i.e., L entails F if all models of L are models of F . Note that if L is inconsistent, L entails everything.</p><p>A DL expression, also called a DL query in <ref type="bibr" target="#b3">[4]</ref>, which is allowed to appear in rules of a logic program, is either (i) a concept inclusion axiom F or its negation ¬F ; or (ii) of the form C(t) or ¬C(t), where C is a concept, and t is a term (i.e., a variable or a constant); or (iii) of the form R(t 1 , t 2 ) or ¬R(t 1 , t 2 ), where R is a role, and t 1 and t 2 are terms; or (iv) of the form =(t 1 , t 2 ) or 񮽙 =(t 1 , t 2 ), where t 1 and t 2 are terms. An atomic DL expression is either C(t) or R(t 1 , t 2 ), where C is an atomic concept and R an atomic role. For convenience, we denote a DL expression by Q(t), where t denotes all terms occurring in the expression (e.g., t 1 and t 2 in (iii)), and Q denotes the remaining part of the expression (e.g., R or ¬R in (iii)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Normal DL Logic Programs</head><p>Let L be a DL knowledge base built over a vocabulary Ψ = (A ∪ R, I), and Π be a normal logic program built over Φ = (P, C). To extend Π with DL expressions relative to L, we first extend Φ such that: (i) all constants in C are individuals in I (i.e., C ⊆ I), so that constants occurring in DL expressions are individuals, and (ii) some atomic concepts and roles in A ∪ R are included in P (as unary and binary predicate symbols, respectively), so that we can make conclusions about them in the same way as other predicate symbols in P. To ensure decidability, we require that P and C be finite. Let Ω = P ∩ (A ∪ R) denote the set of predicate symbols shared by Π and L. Definition 1. Let L be a DL knowledge base. A normal DL logic program Π with DL expressions relative to L consists of a finite set of rules of form <ref type="formula" target="#formula_1">(1)</ref>, where H is an atom, and each A i and B i are either atoms or DL expressions.</p><p>Note that when the predicate symbol of an atom in Π is in Ω, the atom is also an atomic DL expression.</p><p>A ground instance of a rule (resp. a DL expression) in Π is obtained by replacing all variables with constants in C. Let ground(Π) denote the set of ground instances of all rules in Π. The Herbrand base HB Π of Π relative to L is the set of all ground atoms P (t 1 , ..., t m ), where P ∈ P occurs either in Π or in L and each t i is in C. Any subset of HB Π is a Herbrand interpretation (or simply interpretation) of Π relative to L. When the context is clear, we omit the phrase "relative to L."</p><p>For an interpretation I, let I| Ω = {A ∈ I | the predicate symbol of A is in</p><formula xml:id="formula_5">Ω} and I − | Ω = {A ∈ I − | the predicate symbol of A is in Ω}. We say that I is consistent with L if L ∪ I| Ω ∪¬I − | Ω is consistent. Note that when I is consistent with L, L must be consistent.</formula><p>Since DL expressions must be evaluated against L, the satisfaction relation for normal logic programs needs to be extended to normal DL logic programs. In the sequel, by a literal we refer to A or not A, where A is an atom or a DL expression.</p><p>Definition 2. Let Π be a normal DL logic program with DL expressions relative to a DL knowledge base L, I an interpretation, and l a ground literal. We use I |= L l to denote that I satisfies l under L, which is defined as follows:</p><p>1. For a ground atom A ∈ HB Π , which is not an atomic DL expression,</p><formula xml:id="formula_6">I |= L A if A ∈ I. 2. For a ground DL expression A, I |= L A if L ∪ I| Ω ∪¬I − | Ω |= A. 3. For a ground atom or a ground DL expression A, I |= L not A if I 񮽙 |= L A. For a rule r in ground(Π), I |= L body(r) if for each (positive or negative) literal l in body(r), I |= L l; I |= L r if I 񮽙 |= L body(r) or I |= L head(r). I is a model of Π relative to L if I is consistent with L and I |= L r for all r ∈ ground(Π). Note that when L is inconsistent, Π has no model relative to L. Example 1. Let L = {¬B(a)} and Π = {A(X) ← not ¬(A 񮽙 B)(X)}. Let P = {A}, C = {a} and Ω = {A}. Note that ¬(A񮽙B)(X)</formula><p>is a DL expression, and A(X) is both an atom and an atomic DL expression. We have HB Π = {A(a)} and ground(Π) = {A(a) ← not ¬(A 񮽙 B)(a)}. Π has two models relative to L: I 1 = ∅ and I 2 = {A(a)}. For the rule r in ground(Π), I 1 񮽙 |= L body(r), I 2 |= L body(r), and I 2 |= L head(r).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Well-Supported Models</head><p>The notion of well-supportedness in logic programming is defined by Fages in <ref type="bibr" target="#b6">[7]</ref> as a key characterization of the standard answer set semantics. For a normal logic program Π, an interpretation I is well-supported if there exists a strict well-founded partial order ≺ on I such that for any A ∈ I, there is a rule A ← body(r) in ground(Π) such that I satisfies body(r) and for every positive literal B in body(r), B ≺ A. A binary relation ≤ is well-founded if there is no infinite decreasing chain A 0 ≥ A 1 ≥ · · ·. A well-supported interpretation I guarantees that every A ∈ I is free of circular justifications in I.</p><p>To extend Fages' well-supportedness condition to normal DL logic programs with DL expressions, we introduce a notion of up to satisfaction. Definition 3. Let Π be a normal DL logic program with DL expressions relative to a DL knowledge base L, I an interpretation consistent with L, and l a ground literal. For any E ⊆ I, we use (E, I) |= L l to denote that E up to I satisfies l under L, which is defined as follows: For any ground atom or ground DL</p><formula xml:id="formula_7">expression A, (E, I) |= L A if for every F with E ⊆ F ⊆ I, F |= L A; (E, I) |= L not A if for no F with E ⊆ F ⊆ I, F |= L A. For a rule r in ground(Π), (E, I) |= L body(r) if for every literal l in body(r), (E, I) |= L l.</formula><p>As the phrase "up to" suggests, for any ground (positive or negative) literal l, (E, I) |= L l means that for all interpretations F between E and I, F |= L l. This implies that the truth of l depends on E and ¬I − and is independent of atoms in I \ E, since for any A ∈ I \ E and any interpretation F with E ⊆ F ⊆ I, whether or not A is in F , F |= L l.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1. Let l be a ground literal. For any</head><formula xml:id="formula_8">E 1 ⊆ E 2 ⊆ I, if (E 1 , I) |= L l then (E 2 , I) |= L l.</formula><p>Proof: Straightforward from Definition 3.</p><p>񮽙 񮽙 Theorem 1 shows that the up to satisfaction is monotonic. In addition, it has the following two properties.</p><formula xml:id="formula_9">Proposition 1. For any ground DL expression A, (E, I) |= L A iff L ∪ E| Ω ∪¬I − | Ω |= A. Proof: (E, I) |= L A means that E ⊆ I and for every F with E ⊆ F ⊆ I, F |= L A. Then, by Definition 2, (E, I) |= L A means that for every F with E ⊆ F ⊆ I, L ∪ F | Ω ∪¬F − | Ω |= A. Note that F = E ∪ (F \ E) and F − = I − ∪ (I \ F ). So (E, I) |= L A means that for every F with E ⊆ F ⊆ I, L ∪ E | Ω ∪ ¬I − | Ω ∪ (F \ E) | Ω ∪ ¬(I \ F ) | Ω |= A<label>(2)</label></formula><p>Then, to prove this proposition it suffices to prove that the entailment (2) holds for every F with E ⊆ F ⊆ I iff the following entailment holds:</p><formula xml:id="formula_10">L ∪ E | Ω ∪ ¬I − | Ω |= A<label>(3)</label></formula><p>Note that for any model M of the left side of the entailment <ref type="formula" target="#formula_9">(2)</ref> or <ref type="formula" target="#formula_10">(3)</ref>, we have E ⊆ M ⊆ I. Assume that the entailment (2) holds for every F with E ⊆ F ⊆ I. Let M be a model of the left side of the entailment (3). Since E ⊆ M ⊆ I, M is a model of the left side of the entailment (2), where F = M . Then, M is a model of A (the right side of the entailment <ref type="formula" target="#formula_9">(2)</ref>). This means the entailment (3) holds.</p><p>Conversely, assume the entailment (3) holds. Let M be a model of the left side of the entailment (2). M is also a model of the left side of the entailment (3) and thus M is a model of A (the right side of the entailment <ref type="formula" target="#formula_10">(3)</ref>). This means the entailment (2) holds.</p><p>񮽙 񮽙 Proposition 2. For any ground atom A ∈ HB Π , which is not an atomic DL expression,</p><formula xml:id="formula_11">(E, I) |= L A iff A ∈ E; (E, I) |= L not A iff A 񮽙 ∈ I.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof: Straightforward from Definitions 3 and 2. 񮽙 񮽙</head><p>Next we extend the well-supportedness condition for normal logic programs to normal DL logic programs by means of the up to satisfaction. Definition 4. Let Π be a normal DL logic program with DL expressions relative to a DL knowledge base L, and I an interpretation consistent with L. I is wellsupported if there exists a strict well-founded partial order ≺ on I such that for any A ∈ I, there exists E ⊂ I, where for every B ∈ E, B ≺ A, such that either</p><formula xml:id="formula_12">(i) L ∪ E| Ω ∪¬I − | Ω |= A, or (ii) there is a rule A ← body(r) in ground(Π) such that (E, I) |= L body(r).</formula><p>The above conditions (i) and (ii) imply that the truth of A ∈ I is determined by E and ¬I − . Since for every B ∈ E, B ≺ A, the truth of A is not circularly dependent on itself. As a result, a well-supported interpretation I of Π guarantees that every A ∈ I is free of circular justifications in I.</p><p>Observe in Definition 4 that due to the occurrence of DL expressions, some A ∈ I may be supported by no rule A ← body(r) in ground(Π) such that</p><formula xml:id="formula_13">I |= L body(r). Instead, A is supported by L such that L ∪ I| Ω ∪¬I − | Ω |= A.</formula><p>This is a special property of the well-supportedness condition for normal DL logic programs. The next example further illustrates this property.</p><p>Example 2. Let L = {B(a), B 񮽙 A} and Π = {A(X) ← C(X)}. Let P = {A, C}, C = {a} and Ω = {A}. We have HB Π = {A(a), C(a)} and ground(Π) = {A(a) ← C(a)}. Π has two models relative to L: I 1 = {A(a)} and I 2 = {A(a), C(a)}. Only I 1 is a well-supported model, where for A(a) ∈ I 1 , we have E = ∅ and condition (i) of Definition 4 holds. Note that there is no rule of the form A(a) ← body(r) in ground(Π) such that I 1 |= L body(r).</p><p>The following result shows that Definition 4 is a proper extension to Fages' well-supportedness condition. Assume that I is a well-supported model of Π relative to L. By Definition 4, there exists a strict well-founded partial order ≺ on I such that for any A ∈ I, there exists E ⊂ I, where for every B ∈ E, B ≺ A, and there is a rule r as above in ground(Π) such that (E, I) |= L body(r). Note that (E, I) |= L body(r) implies E |= L body(r) and I |= L body(r), which implies that both I and E satisfy body(r). This means that for every positive literal A i in body(r), A i ∈ E and thus A i ≺ A. As a result, for any A ∈ I, there is a rule r as above in ground(Π) such that I satisfies body(r) and for every positive literal A i in body(r), A i ≺ A. This shows that I is a well-supported model of Π under Fages' definition.</p><p>Assume I is a well-supported model of Π under Fages' definition. There exists a strict well-founded partial order ≺ on I such that for any A ∈ I, there is a rule r as above in ground(Π) such that I satisfies body(r) and for every positive literal A i in body(r), A i ≺ A. Let E ⊂ I and for every A i ∈ body(r), A i ∈ E. Then, E contains no B i in body(r), since no B i is in I. For any F with E ⊆ F ⊆ I, F satisfies body(r) and thus F |= L body(r). That means (E, I) |= L body(r). As a result, for any A ∈ I, there exists E ⊂ I, where for every B ∈ E, B ≺ A, and there is a rule r as above in ground(Π) such that (E, I) |= L body(r). This shows that I is a well-supported model of Π relative to L. 񮽙 񮽙</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Well-Supported Answer Set Semantics</head><p>We define an answer set semantics for normal DL logic programs whose answer sets are well-supported models. We first define an immediate consequence operator.</p><p>Definition 5. Let Π be a normal DL logic program relative to a DL knowledge base L, and I an interpretation consistent with L. For E ⊆ I, define</p><formula xml:id="formula_14">T Π (E, I) ={A | A ← body(r) ∈ ground(Π) and (E, I) |= L body(r)}.</formula><p>By Theorem 1, when the second argument I is a model of Π, T Π is monotone w.r.t. its first argument E.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3. Let Π be a normal DL logic program with DL expressions relative to a DL knowledge base L, and I a model of Π relative to L. For any E 1 ⊆ E 2 ⊆ I, T Π (E 1 , I) ⊆ T Π (E 2 , I) ⊆ I.</head><p>Proof: For any A ∈ T Π (E 1 , I), there is a rule A ← body(r) in ground(Π) such that (E 1 , I) |= L body(r). Since E 1 ⊆ E 2 , by Theorem 1, (E 2 , I) |= L body(r), and thus A ∈ T Π (E 2 , I). This shows T Π (E 1 , I) ⊆ T Π (E 2 , I). Since E 2 ⊆ I, it follows (I, I) |= L body(r) and A ∈ T Π (I, I). Therefore, T Π (E 1 , I) ⊆ T Π (E 2 , I) ⊆ T Π (I, I). Note that (I, I) |= L body(r) means I |= L body(r). Since I is a model of Π relative to L, I |= L body(r) implies A ∈ I. This shows that when I is a model of Π relative to L, every A ∈ T Π (I, I) is in I. Hence,</p><formula xml:id="formula_15">T Π (E 1 , I) ⊆ T Π (E 2 , I) ⊆ T Π (I, I) ⊆ I.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>񮽙 񮽙</head><p>Therefore, for any model I of Π relative to L, the sequence</p><formula xml:id="formula_16">񮽙T i Π (∅, I)񮽙 ∞ i=0 , where T 0 Π (∅, I) = ∅ and T i+1 Π (∅, I) = T Π (T i Π (∅, I), I</formula><p>), converges to a fixpoint, denoted T α Π (∅, I). This fixpoint has the following properties.</p><formula xml:id="formula_17">Theorem 4. Let I be a model of Π relative to L. (1) T α Π (∅, I) ⊆ I. (2) L ∪ T α Π (∅, I)| Ω ∪¬I − | Ω is consistent. (3) For any model J of Π relative to L with J ⊂ I, T α Π (∅, I) ⊆ T α Π (∅, J) ⊆ J.</formula><p>Proof: (1) It suffices to prove that for any i ≥ 0,</p><formula xml:id="formula_18">T i Π (∅, I) ⊆ I. It is obvious for i = 0. Assume T k Π (∅, I) ⊆ I for k ≥ 0. For i = k + 1, by Theorem 3, T k+1 Π (∅, I) = T Π (T k Π (∅, I), I) ⊆ I. Therefore, T α Π (∅, I) ⊆ I. (2) Since I is a model of Π relative to L, L ∪ I| Ω ∪¬I − | Ω is consistent. Since T α Π (∅, I) ⊆ I, L ∪ T α Π (∅, I)| Ω ∪¬I − | Ω is also consistent.</formula><p>(3) By Definition 3, for any rule body body(r) in ground(Π) and any E 1 and E 2 with E 1 ⊆ E 2 ⊆ J, if (E 1 , I) |= L body(r) then (E 2 , J) |= L body(r). Then, by Definition 5, T Π (E 1 , I) ⊆ T Π (E 2 , J). Next we prove that for any i ≥ 0,</p><formula xml:id="formula_19">T i Π (∅, I) ⊆ T i Π (∅, J) ⊆ J. It is obvious for i = 0. Assume T i Π (∅, I) ⊆ T i Π (∅, J) ⊆ J for any i ≤ k ≥ 0. For i = k + 1, by Theorem 3, T k+1 Π (∅, I) = T Π (T k Π (∅, I), I) ⊆ T k+1 Π (∅, J) = T Π (T k Π (∅, J), J) ⊂ J. Therefore, T α Π (∅, I) ⊆ T α Π (∅, J) ⊆ J.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>񮽙 񮽙</head><p>We define answer sets for normal DL logic programs using the above fixpoint.</p><p>Definition 6. Let Π be a normal DL logic program relative to a DL knowledge base L, and I a model of Π relative to L. I is an answer set of Π relative to L if for every</p><formula xml:id="formula_20">A ∈ I, either A ∈ T α Π (∅, I) or L ∪ T α Π (∅, I)| Ω ∪¬I − | Ω |= A.</formula><p>It is immediate that when L = ∅, a model I is an answer set of Π relative to</p><formula xml:id="formula_21">L iff I = T α Π (∅, I</formula><p>). The answer set semantics for Π relative to L is then defined by answer sets of Π. That is, a ground literal l is credulously (resp. skeptically) true in Π relative to L if I |= L l for some (resp. every) answer set I of Π relative to L.</p><formula xml:id="formula_22">Example 3. Consider Example 1. For I 1 = ∅, T α Π (∅, I 1 ) = ∅, so I 1 is an answer set of Π relative to L. For I 2 = {A(a)}, T 0 Π (∅, I 2 ) = ∅ and T 1 Π (∅, I 2 ) = T Π (∅, I 2 ) = ∅, so T α Π (∅, I 2 ) = ∅. For A(a) ∈ I 2 , A(a) 񮽙 ∈ T α Π (∅, I 2 ) and L ∪ T α Π (∅, I 2 )| Ω ∪¬I − 2 | Ω 񮽙 |= A(a). Thus I 2 is not an answer set of Π relative to L.</formula><p>Consider Example 2. For</p><formula xml:id="formula_23">I 1 = {A(a)}, T 0 Π (∅, I 1 ) = ∅ and T 1 Π (∅, I 1 ) = T Π (∅, I 1 ) = ∅, so T α Π (∅, I 1 ) = ∅. For A(a) ∈ I 1 , A(a) 񮽙 ∈ T α Π (∅, I 1 ), but L ∪ T α Π (∅, I 1 )| Ω ∪¬I − 1 | Ω |= A(a)</formula><p>, so I 1 is an answer set of Π relative to L. It is easy to verify that I 2 = {A(a), C(a)} is not an answer set of Π relative to L.</p><p>The following result shows that answer sets must be minimal models. </p><formula xml:id="formula_24">(∅, I) ⊆ T α Π (∅, J) ⊆ J. Let S = I \ J.</formula><p>Note that S is not empty and for any A ∈ S, A 񮽙 ∈ T α Π (∅, I). Since I is an answer set of Π, for any</p><formula xml:id="formula_25">A ∈ S, L∪T α Π (∅, I)| Ω ∪¬I − | Ω |= A. Since J − ⊃ I − , L ∪ J| Ω ∪¬J − | Ω |= A. Since every A ∈ S is in J − , L ∪ J| Ω ∪¬J − | Ω |= ¬A.</formula><p>This means that L ∪ J| Ω ∪¬J − | Ω is not consistent, and thus J is not a model of Π relative to L. We then have a contradiction. Therefore, I is a minimal model of Π relative to L.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>񮽙 񮽙</head><p>The next result shows that answer sets are exactly well-supported models. Proof: Assume that I is an answer set relative to L. We can construct a level mapping f : I → N , where N is an integer, as follows: For each A ∈ I, we assign f (A) = i, where i ≥ 0 is the smallest number such that either</p><formula xml:id="formula_26">L ∪ T i Π (∅, I)| Ω ∪¬I − | Ω |= A or there is a rule A ← body(r) in ground(Π) such that (T i Π (∅, I), I) |= L body(r).</formula><p>We then define a strict well-founded partial order ≺ on I such that for any A, B ∈ I, B ≺ A iff f (B) &lt; f(A). For each A ∈ I with f (A) = i, we always have E = T i Π (∅, I) ⊂ I, where for every B ∈ E, B ≺ A, such that either L ∪ E| Ω ∪¬I − | Ω |= A or there is a rule A ← body(r) in ground(Π) such that (E, I) |= L body(r). By Definition 4, I is a well-supported model relative to L.</p><p>Conversely, assume that I is a well-supported model relative to L. Then, there exists a strict well-founded partial order ≺ on I such that for any A ∈ I, there exists E ⊂ I, where for every B ∈ E, B ≺ A, such that either L ∪ E| Ω ∪¬I − | Ω |= A or there is a rule A ← body(r) in ground(Π) such that (E, I) |= L body(r). Such a partial order establishes a level mapping f : I → N so that for any A ∈ I, A can be derived from some E ⊂ I at lower levels in the way as above. Next, we show that for every A ∈ I at level i ≥ 0 we have E = T i Π (∅, I) satisfying the above conditions. First, each A ∈ I at the lowest level (i = 0) does not depend on any other atom B ∈ I, i.e., there is no B ∈ I with B ≺ A. By the assumption that there exists E ⊂ I, where for every B ∈ E, B ≺ A, such that either L ∪ E| Ω ∪¬I − | Ω |= A or there is a rule A ← body(r) in ground(Π) such that (E, I) |= L body(r), we have E = ∅. Therefore, for each A ∈ I at level 0, we have E = T 0 Π (∅, I) which satisfies the above conditions.</p><p>As the induction hypothesis, assume that for any i ≤ n and any A ∈ I at level i, we have E = T i Π (∅, I) such that either L ∪ E| Ω ∪¬I − | Ω |= A or there is a rule A ← body(r) in ground(Π) such that (E, I) |= L body(r). Then, by Theorem 3, for each A ∈ I at level i ≤ n, we have E = T n Π (∅, I) which satisfies the above conditions.</p><p>Consider A ∈ I at level n + 1. Then, there exists E ⊂ I, where for every B ∈ E, B ≺ A, such that either (1) L ∪ E| Ω ∪¬I − | Ω |= A, or (2) there is a rule A ← body(r) in ground(Π) such that (E, I) |= L body(r). Next, we show that when using T n+1 Π (∅, I) to replace E, the conditions (1) and (2) still hold for every A ∈ I at level n + 1.</p><p>For every B ∈ E, since B is at a level below n+1, by the induction hypothesis,</p><formula xml:id="formula_27">either (a) L ∪ T n Π (∅, I)| Ω ∪¬I − | Ω |= B, or (b) there is a rule B ← body(r) in ground(Π) such that (T n Π (∅, I), I) |= L body(r).</formula><p>For case (a), we distinguish between two cases: (i) B ∈ T n Π (∅, I). In this case, if we replace B in E by T n+1 Π (∅, I), the conditions (1) and (2) above still hold for each A ∈ I at level n + 1. (ii) B 񮽙 ∈ T n Π (∅, I). Then, for no i ≤ n, B ∈ T i Π (∅, I); thus B is an atomic DL expression. In this case, if we replace B in E by T n+1</p><formula xml:id="formula_28">Π (∅, I), the condition (1) above still holds, since L ∪ T n Π (∅, I)| Ω ∪¬I − | Ω |= B. Consider the condition (2). (E, I) |= L body(r) means that for every F with E ⊆ F ⊆ I, F |= L body(r). Let us replace B in E by T n+1 Π (∅, I). Since B is a ground atomic DL expression, by Proposition 1, (E \{B}∪T n+1 Π (∅, I), I) |= L B, because L ∪ (E \ {B} ∪ T n+1 Π (∅, I))| Ω ∪¬I − | Ω |= B.</formula><p>This shows that for any body(r),</p><formula xml:id="formula_29">(E \ {B} ∪ T n+1 Π (∅, I), I) |= L body(r) iff (E ∪ T n+1 Π (∅, I), I) |= L body(r). Then, when (E, I) |= L body(r), (E ∪ T n+1 Π (∅, I), I) |= L body(r) and thus (E \ {B} ∪ T n+1 Π (∅, I), I</formula><p>) |= L body(r). This shows that after replacing B in E by T n+1 Π (∅, I), the condition (2) above still holds, Therefore, if we replace B in E by T n+1 Π (∅, I), the conditions <ref type="formula" target="#formula_1">(1)</ref> and <ref type="formula" target="#formula_9">(2)</ref>   <ref type="formula" target="#formula_1">(1)</ref> and <ref type="formula" target="#formula_9">(2)</ref> above still hold. As a result, if we replace all B ∈ E by T n+1 Π (∅, I), the conditions (1) and (2) above still hold. Therefore, for every A ∈ I at level n + 1. we have E = T n+1</p><formula xml:id="formula_30">Π (∅, I) such that either L ∪ E| Ω ∪¬I − | Ω |= A or there is a rule A ← body(r) in ground(Π) such that (E, I) |= L body(r). Consequently, for every A ∈ I, either L ∪ T α Π (∅, I)| Ω ∪¬I − | Ω |= A or A ∈ T α Π (∅, I). This shows that I is an answer set of Π relative to L. 񮽙 񮽙 Example 4. Let L = ∅ and Π : A(g). B(g) ← C(g). C(g) ← ((A 񮽙 ¬C) 񮽙 B)(g).</formula><p>Let P = {A, B, C}, C = {g} and Ω = {A, B, C}. HB Π = {A(g), B(g), C(g)} and ground(Π) = Π. Π has only one model relative to</p><formula xml:id="formula_31">L, I = {A(g), B(g), C(g)}.</formula><p>This model is not an answer set, since it is not a well-supported model of Π relative to L. Note that we can use a fresh DL concept D to replace the DL expression (A 񮽙 ¬C) 񮽙 B and add to L an axiom D ≡ (A 񮽙 ¬C) 񮽙 B. This yields</p><formula xml:id="formula_32">Π 񮽙 : A(g). B(g) ← C(g). C(g) ← D(g). L 񮽙 : D ≡ (A 񮽙 ¬C) 񮽙 B.</formula><p>Using the same P, C and Ω as above, Π 񮽙 has the same answer sets relative to</p><formula xml:id="formula_33">L 񮽙 as Π relative to L.</formula><p>The following result shows that this answer set semantics is a proper extension to the standard answer set semantics for normal logic programs.</p><p>Theorem 7. Let L = ∅ and Π be a normal logic program without DL expressions. An interpretation I is an answer set of Π relative to L iff I is an answer set of Π under the standard answer set semantics.</p><p>Proof: By Theorem 6, I is an answer set of Π relative to L iff I is a wellsupported model of Π relative to L. By Theorem 2, I is a well-supported model of Π relative to L iff I is a well-supported model of Π under Fages' definition. Then as shown in <ref type="bibr" target="#b6">[7]</ref>, the well-supported models of Π under Fages' definition are exactly the answer sets of Π under the standard answer set semantics. 񮽙 񮽙</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Decidability Property</head><p>For a normal DL logic program Π with DL expressions relative to a DL knowledge base L, the decidability of computing answer sets of Π relative to L depends on the decidability of satisfiability of L. Since DLs are fragments of first-order logic, the satisfiability of L is undecidable in general cases. However, if L is built from the description logic SHOIN or SROIQ, its satisfiability is decidable <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b11">12]</ref>.</p><p>Let L be a DL knowledge base built from a decidable description logic such as SHOIN or SROIQ. Since HB Π and ground(Π) are finite, it is decidable to determine if an interpretation I is a model of Π relative to L. For any E ⊆ I and any ground atom or DL expression A in ground(Π), it is decidable to determine if (E, I) |= L A (resp. (E, I) |= L not A) holds, and thus it is decidable to determine if (E, I) |= L body(r) holds for each rule r in ground(Π). Since ground(Π) consists of a finite set of rules, it takes finite time to compute the fixpoint T α Π (∅, I). As a result, it is decidable to determine if an interpretation I is an answer set of Π relative to L. Since Π has only a finite set of interpretations, it is decidable to compute all answer sets of Π relative to L.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Related Work</head><p>Although many approaches to integrating rules and DLs have been proposed in the literature <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19]</ref>, to the best of our knowledge dl-programs <ref type="bibr" target="#b3">[4]</ref> are the first framework which extends normal logic programs under the standard answer set semantics to logic programs with arbitrary DL expressions relative to an external DL knowledge base. Four different answer set semantics have been defined for dl-programs. The first one, called weak answer set semantics <ref type="bibr" target="#b3">[4]</ref>, easily incurs circular justifications by self-supporting loops, so a second one, called strong answer set semantics, was introduced <ref type="bibr" target="#b3">[4]</ref>. Answer sets under the strong answer set semantics are not minimal models of a dl-program, then a third one, called FLP-reduct based answer set semantics, was proposed <ref type="bibr" target="#b4">[5]</ref>. This semantics is based on the concept of FLP-reduct from <ref type="bibr" target="#b5">[6]</ref>. It turns out, however, that none of the three answer set semantics extends the key well-supportedness condition of the standard answer set semantics to dl-programs, so that their answer sets may incur circular justifications by self-supporting loops. To resolve this problem, a fourth semantics, called well-supported answer set semantics, was recently introduced <ref type="bibr" target="#b19">[20]</ref>, which extends the well-supportedness condition to dl-programs. Dl-programs differ in fundamental ways from normal DL logic programs. First, in a dl-program, Π and L share no predicate symbols, so DL expressions Q(t) must occur together with predicate mapping operations S i op i P i . Note that in dl-programs one cannot use only dl-atoms of the form DL[Q](t) to express all DL expressions Q(t) because that would cut the knowledge flow from Π to L. Second, in a dl-program, DL expressions (dl-atoms) are not allowed to occur in a rule head, so no conclusions about L can be inferred from Π. Third, in this paper we extend the well-supportedness condition to normal DL logic programs. The extension process is similar to that in <ref type="bibr" target="#b19">[20]</ref> by introducing an up to satisfaction relation (Definition 3), but the formalization of the well-supportedness condition is significantly different. For dl-programs, since Π and L share no predicate symbols, a model I of Π is well-supported if and only if for each A ∈ I there is a rule A ← body(r) in ground(Π) such that I satisfies body(r) and the evidence of the truth of body(r) is not circularly dependent on A in I. For normal DL logic programs, however, the situation is much more complicated. As illustrated in Example 2, since Π and L share some predicate symbols, a model I of Π relative to L would be well-supported even if some A ∈ I is not supported by any rule A ← body(r) in ground(Π) such that I satisfies body(r). This presents additional difficulties in formalizing the well-supportedness condition for normal DL logic programs.</p><p>DL+log <ref type="bibr" target="#b18">[19]</ref> (and its variant such as guarded hybrid knowledge bases <ref type="bibr" target="#b10">[11]</ref>) is closely related to but differs significantly from normal DL logic programs. Syntactically, it divides predicate symbols into Datalog predicates and DL predicates. The former type can only occur in Π, while the latter is not allowed to occur (as DL expressions) behind the negation operator not. Semantically, it considers first-order interpretations, instead of Herbrand interpretations, and defines a semantics with a class of first-order models, called NM-models. In an NM-model, DL predicates can take arbitrary truth values (as in first-order logic), but Datalog predicates take truth values that must be minimal (as in logic programming) when the truth values of all DL predicates are fixed. Consider a DL+log program with Π = {B(g) ← A(g)} and L = {A 񮽙 C}. A, C must be DL predicates. Let B be a Datalog predicate. This program has at least three NM-models:</p><formula xml:id="formula_34">I 1 = {A(g), B(g)}, I 2 = {A(g), B(g), C(g)} and I 3 = {C(g)}.</formula><p>In contrast, if we take Π as a normal DL logic program relative to L, where P = {B}, C = {g} and Ω = ∅, Π has a unique well-supported model/answer set ∅ relative to L.</p><p>Disjunctive dl-programs <ref type="bibr" target="#b15">[16]</ref> are closely related to normal DL logic programs, but differ significantly at least in three ways. Let Π be a disjunctive dl-program relative to L, where Π is built over a vocabulary Φ = (P, C), P is a finite set of predicate symbols, and C is a nonempty finite set of constants. (1) All concepts and roles occurring in Π are required to be included in P, so that all of them are interpreted over the Herbrand base HB Π of Π. This strict requirement does not seem to be intuitive in some cases. For Example 4, since D is a fresh concept of L 񮽙 introduced to represent (A 񮽙 ¬C) 񮽙 B, D is expected to be interpreted against L 񮽙 in first-order logic. But in a disjunctive dl-program, D must be included in P and thus be interpreted over the Herbrand base HB Π 񮽙 . <ref type="formula" target="#formula_9">(2)</ref> The semantics of disjunctive dl-programs is based on FLP-reduct. Like the FLP-reduct based semantics for dl-programs <ref type="bibr" target="#b4">[5]</ref>, this FLP-reduct based semantics for disjunctive dl-programs yields answer sets that are minimal but not necessarily well-supported models. For Example 4, let Π 񮽙 be a disjunctive dl-program. I = {A(g), B(g), C(g), D(g)} is an answer set of Π 񮽙 relative to L 񮽙 under the FLP-reduct based semantics. Observe that the evidence of the truth of B(g), C(g), D(g) in the answer set can only be inferred via a self-supporting loop B(g) ⇐ C(g) ⇐ D(g) ⇐ B(g). (3) Disjunctive dl-programs allow only atomic DL expressions in rule bodies. We cannot have a disjunctive dl-program with Π = {A ← ¬A} and L = ∅, since ¬A is not an atomic DL expression. One might think that this issue could be handled by introducing a fresh concept B to represent the DL expression ¬A, which yields a disjunctive dl-program with Π 񮽙 = {A ← B} and L 񮽙 = {B ≡ ¬A}.</p><p>However, this would produce an answer set I = {A}, which is not a wellsupported model of Π.</p><p>Extensions of logic programs with DL expressions, such as dl-programs, DL+log, disjunctive dl-programs, and normal DL logic programs, are different in fundamental ways from embeddings of rules and DLs into some unifying logic formalisms, such as the embedding <ref type="bibr" target="#b1">[2]</ref> to first-order autoepistemic logic <ref type="bibr" target="#b16">[17]</ref> and the embedding <ref type="bibr" target="#b17">[18]</ref> to the logic of Minimal Knowledge and Negation as Failure (MKNF) <ref type="bibr" target="#b14">[15]</ref>. The two embeddings employ modal logics and transform rules Π and DL axioms L to autoepistemic (resp. MKNF) logic formulas Π 񮽙 and L 񮽙 with modal operators. Then, the semantics of Π and L is defined by the semantics of Π 񮽙 ∪ L 񮽙 under autoepistemic (resp. MKNF) modal logic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Summary</head><p>We have introduced a new extension, called normal DL logic programs, of normal logic programs with DL expressions relative to an external DL knowledge base. In normal DL logic programs, arbitrary DL expressions are allowed to appear in rule bodies and atomic DL expressions allowed in rule heads. We extended the key condition of well-supportedness for normal logic programs under the standard answer set semantics to normal DL logic programs and defined an answer set semantics which satisfies the extended condition of well-supportedness. As a result, answer sets under the well-supported semantics are free of circular justifications. We show that the answer set semantics for normal DL logic programs is decidable if the underlying description logic is decidable (e.g. SHOIN or SROIQ).</p><p>As future work, we will study computational properties of normal DL logic programs w.r.t. different DLs, and extend normal DL logic programs to disjunctive DL logic programs, where the head of a rule is a disjunction of atoms.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Theorem 2 .</head><label>2</label><figDesc>Let L = ∅ and Π be a normal logic program without DL expres- sions. An interpretation I is a well-supported model of Π relative to L iff I is a well-supported model of Π under Fages' definition. Proof: Let I be an interpretation of Π relative to L. I is also an interpretation of Π. Since L = ∅, for any A ∈ I the condition (i) of Definition 4 does not hold. Since Π is a normal logic program without DL expressions, each A i and B i occur- ring in the body of each rule r of the form A ← A 1 , · · · , A m , not B 1 , · · · , not B n in ground(Π) are ground atoms. For such rules, I |= L body(r) iff every A i is in I and no B i is in I.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Theorem 5 .</head><label>5</label><figDesc>Let Π be a normal DL logic program with DL expressions relative to a DL knowledge base L. If I is an answer set of Π relative to L, then I is a minimal model of Π relative to L. Proof: Assume, on the contrary, that I is not a minimal model relative to L. Let J ⊂ I be a minimal model relative to L. By Theorem 4, T α Π</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>above still hold. For case (b), B ∈ T n+1 Π (∅, I). So if we replace B in E by T n+1 Π (∅, I), the conditions</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Mcguinness</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Patel-Schneider</surname></persName>
		</author>
		<title level="m">The Description Logic Handbook: Theory, Implementation and Applications</title>
		<editor>P.F.</editor>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Embedding approaches to combining rules and ontologies into autoepistemic logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>De Bruijn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Tompits</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eleventh International Conference on Principles of Knowledge Representation and Reasoning</title>
		<meeting>the Eleventh International Conference on Principles of Knowledge Representation and Reasoning</meeting>
		<imprint>
			<publisher>KR</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="485" to="495" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Rules and ontologies for the semantic web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ianni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Krennwallner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Polleres</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Conference on Web Reasoning and Rule Systems (RR 2008)</title>
		<meeting>the 2nd International Conference on Web Reasoning and Rule Systems (RR 2008)</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="1" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Combining answer set programming with description logics for the semantic web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ianni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lukasiewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Schindlauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Tompits</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">172</biblScope>
			<biblScope unit="page" from="1495" to="1539" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A uniform integration of higherorder reasoning and external evaluations in answer-set programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ianni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Schindlauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Tompits</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI 2005</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="90" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Recursive aggregates in disjunctive logic programs: Semantics and complexity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Faber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Leone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Pfeifer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logics in Artificial Intelligence: European Workshop</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="200" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Consistency of clark&apos;s completion and existence of stable models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Fages</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Methods of Logic in Computer Science</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="51" to="60" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The stable model semantics for logic programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gelfond</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Conference on Logic Programming (ICLP-1988)</title>
		<meeting>the 5th International Conference on Logic Programming (ICLP-1988)</meeting>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="page" from="1070" to="1080" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">OWL 2: The next step for OWL</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Grau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Parsia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Web Semantics</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="309" to="322" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Description logic programs: Combining logic programs with description logics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Grosof</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Volz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">D</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>WWW</publisher>
			<biblScope unit="page" from="48" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Guarded hybrid knowledge bases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Heymans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Bruijn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Predoiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Feier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">V</forename><surname>Niewenborgh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory and Practice of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="411" to="429" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The even more irresistible SROIQ</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Kutz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth International Conference on Principles of Knowledge Representation and Reasoning (KR-2006)</title>
		<meeting>the Tenth International Conference on Principles of Knowledge Representation and Reasoning (KR-2006)</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="57" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">From SHIQ and RDF to OWL: the making of a web ontology language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Van Harmelen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Web Semantics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="7" to="26" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">SWRL: A Semantic Web rule language combining OWL and RuleML</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Boley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tabet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Grosof</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dean</surname></persName>
		</author>
		<ptr target="http://www.w3.org/Submission/SWRL" />
	</analytic>
	<monogr>
		<title level="m">W3C Member Submission</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Nonmonotonic databases and epistemic queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI-1991</title>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="381" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A novel combination of answer set programming with description logics for the semantic web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lukasiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1577" to="1592" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Semantical considerations on nonmonotonic logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">C</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="75" to="94" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Reconciling description logics and rules</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">DL+log: Tight integration of description logics and disjunctive datalog</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth International Conference on Principles of Knowledge Representation and Reasoning (KR-2006)</title>
		<meeting>the Tenth International Conference on Principles of Knowledge Representation and Reasoning (KR-2006)</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="68" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Well-supported semantics for description logic programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">D</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI 2011</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="1081" to="1086" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
