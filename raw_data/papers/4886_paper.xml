<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T17:04+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Quantifying Maintainability in Feature Oriented Product Lines</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gentzane</forename><surname>Aldekoa</surname></persName>
							<email>galdekoa@eps.mondragon.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Mondragon University Mondragon</orgName>
								<address>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Salvador</forename><surname>Trujillo</surname></persName>
							<email>strujillo@ikerlan.es</email>
							<affiliation key="aff1">
								<orgName type="institution">IKERLAN Mondragon</orgName>
								<address>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Goiuria</forename><surname>Sagardui</surname></persName>
							<email>gsagardui@eps.mondragon.edu</email>
							<affiliation key="aff2">
								<orgName type="institution">Mondragon University Mondragon</orgName>
								<address>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oscar</forename><surname>Díaz</surname></persName>
							<email>oscar.diaz@ehu.es</email>
							<affiliation key="aff3">
								<orgName type="institution">Basque Country Univ. San Sebastián</orgName>
								<address>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Quantifying Maintainability in Feature Oriented Product Lines</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Families of products are steadily emerging for distinct settings such as embedded systems, navigational systems, financial applications or even web applications. This shifts the attention from individual product-centric development to software product line development where the focus is on constructing reusable assets from which customer-specific products are obtained. This paper tackles the maintenance of an entire family of products, describing our approach to quantifying maintainability. We report our experience measuring the maintainability index of each product in the family, and then propose a generalization of the results in terms of the entire family or product line. This exposes a number of benefits towards the improvement of product-line maintainability, enhancing ultimately customer-specific products.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Software Product Lines (SPL) are defined as a set of software-intensive systems, sharing a common, managed set of features that satisfy the specific needs of a particular market segment or mission and that are developed from a common set of core assets in a prescribed way <ref type="bibr" target="#b4">[6]</ref>.</p><p>The SPL paradigm distinguishes between domain engineering and product engineering, where construction of the reusable assets and their variability is separated from production of the SPL products. These reusable assets include the architecture, software components, design models and, in general, any artifact that is prepared and liable to be reused.</p><p>These assets are the base on top of upon which products are created deciding its variability, which is expressed as features (i.e. increments in product functionality) <ref type="bibr" target="#b2">[4]</ref>. Distinct techniques exist to realize feature implementations. Feature Oriented Programming provides models and tools where the realization of each feature is modularized <ref type="bibr">[1]</ref>. An SPL product is then obtained by composing customerdesired features.</p><p>Quality measurement is a main requirement in software development. SPLs are not an exception. However, most measures and techniques use a holistic approach where the artifact to be measured is assessed as a whole. This could be contra-intuitive for SPL products which are obtained as the synthesis of a set of features. From this perspective, the question is whether the quality (whatever this means) of an SPL product can be obtained from the quality of the features the product supports. And this in turn, poses the question of how to assess feature quality. Notice that features are inconclusive pieces of code which do not make sense in isolation but assembled to a base or platform. In this regard, they are different from components which can be run in isolation.</p><p>This feature-based measurement would permit users to select features based on the expected contribution the feature makes to the final quality of the SPL product, or even to restrict the available products to those below a certain value for a specific quality attribute <ref type="bibr" target="#b1">[3]</ref>.</p><p>To assess the feasibility of this approach, this work focuses on the Maintainability Index (MI) as the measure to be assessed. The MI is largely used to help reduce system's tendency toward "code entropy" or degraded integrity. Existing tools enable to quantify MI for individual software products.</p><p>The findings of this work include the difficulty of ascertaining MI by directly measuring the feature. Rather the feature impact is assessed as the difference between SPL products, some exhibiting the feature and some others not. This indirect way permits us to assess the contribution of a feature by measuring proper products rather than adapting existing MI techniques to the inconclusive products that features represent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Product Line Maintainability</head><p>The adoption of SPL is reported in several case studies <ref type="bibr" target="#b4">[6]</ref>, <ref type="bibr" target="#b14">[16]</ref>. In general, prior SPL experiences reported a number of general and potential benefits, namely, (i) productivity gains, (ii) faster time-tomarket, (iii) decreased labour efforts, and (iv) improved product quality. Our work elaborates on such quality issues, specifically on maintainability from an SPL perspective.</p><p>Maintainability is the ease with which a software system can be modified to correct faults, improve performance, or adapt to a changing environment <ref type="bibr" target="#b8">[10]</ref>. The literature shows several efforts to characterize and quantify software maintainability. The most widely accepted proposes the use of a polynomial regression model where regression analysis is used as a tool to ACCEPTED FOR PUBLICATION AT: 12th European Conference on Software Maintenance and Reengineering <ref type="bibr">(CSMR 2008)</ref>. Athens, Greece. <ref type="bibr">April 1-4, 2008</ref> explore the relationship between software maintainability and software metrics <ref type="bibr" target="#b15">[17]</ref>.</p><p>Prior work analyzed maintenance in traditional product-centric software development scenarios where the focus was on individual products. However, our work introduces an SPL scenario, and this poses a number of differences.</p><p>Distinct quality dimensions are introduced in SPL. A product is obtained from the product-line reusable assets. Hence, it is needed to measure such assets, not the product itself. The significance is that the complexity of maintenance arises as product's assets are not maintained, but reusable assets are <ref type="bibr" target="#b10">[12]</ref>.</p><p>Error propagation has more impact in an SPL than in an individual product development. While developing an individual product, errors are propagated inside such product. However, one error in a reusable core asset (of the product line) can be propagated to a number of products as it is used by them.</p><p>Change probability. It is more likely to change a reusable asset than an asset for an individual product. This happens as the domain to serve SPL products is larger and can require new functionalities faster than a single customer.</p><p>These differences of SPL development from individual product-centric development vindicate a study of maintainability that should address not only final product code, but also the SPL platform that produces such products.</p><p>More to the point, SPL developers no longer maintain each individual products (produced from the SPL), but rather they maintain the reusable assets from which those products are produced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Quantifying SPL Maintainability</head><p>Our intention is not to measure maintainability in a qualitative way, but in a quantitative way. This implies that our aim is to quantify the product line. As our goal was to use existing measures instead of inventing new ones, we selected the maintainability index.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Maintainability Index</head><p>A program's maintainability is calculated through a Maintainability Index (MI) <ref type="bibr" target="#b13">[15]</ref>, which uses a combination of widely-used and commonly-available measures. Note that all are based on average-per-codemodule measurement. The MI of a program is a polynomial:</p><formula xml:id="formula_0">( ) ( ) ' 23 . 0 ln 2 . 5 171 g aveV aveV MI × − × − = ( ) perCM aveLOC × × + × − 4 . 2 sin 50 ln 2 . 16</formula><p>where (i) aveV is the computational complexity of a program's module measured directly from source code <ref type="bibr" target="#b7">[9]</ref>, (ii) aveV(g') measures the number of linearlyindependent paths through a program module <ref type="bibr" target="#b11">[13]</ref></p><note type="other">, (iii) aveLOC is the average count of lines of code per module. Non Commenting Source Statements are measured, and (iv) perCM is the average percent of lines of comments per module.</note><p>The larger the MI, the more maintainable is the program. MI has been widely used and tested in industrial cases <ref type="bibr" target="#b12">[14]</ref> and compared <ref type="bibr" target="#b5">[7]</ref>. Nonetheless, MI measurement is not a trivial task, which requires sophisticated tooling such as SemanticDesigns 1 <ref type="bibr" target="#b3">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Feature Oriented Programming</head><p>Feature Oriented Programming (FOP) is a paradigm to SPL development where features are the building blocks of products <ref type="bibr" target="#b2">[4]</ref>. Features are units incrementing application functionality by which different products can be distinguished and defined within an SPL. In general, an SPL is characterized by the set of features it supports, e.g. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Approach</head><p>Focusing on Java, feature realization is achieved through Jak files. A first approach would be to measure directly the MI of Jak files. However, a number of problems prevented us from doing so.</p><p>First, existing tools are targeted to Java or C. So, Jak-specific measurement tooling is unavailable (i.e. new tooling would be required).</p><p>Second, Jak can be measured adapting existing MI. However, the measurement of refinements would require further study because a refinement is not a complete Java class, but an extension. So, it is likely that a new MI for refinements would be necessary.</p><p>Third, refinements may override existing code which would make the MI result to change. Thus, there are some interactions among features we may want to detect. These interactions would affect to product's MI <ref type="bibr" target="#b10">[12]</ref>.</p><p>In other words, feature addition does not always have a monotonic effect on the MI measure. The addition of a new feature could result in a reduction of the MI for the resulting product since a feature can make the code of the resulting product harder to maintain. Therefore, calculating the MI for each feature separately, and then, aggregating those values to obtain the MI of the product could be wrong (at least using the model used in this work for feature realization).</p><p>As a result, an indirect way to measure feature MI was devised. Let P be the set of total products an SPL can generate. Let P+ and P-be a total cover of P, which refer to the products exhibiting feature F and the products that lack feature F, respectively. The MI impact for feature F can be ascertained from MI(P+) and MI(P-).</p><p>This intuition is formalized in terms of a matrix. Each row stands for a product, and each column represents the MI contribution of a given feature F (the value we want to obtain). Next subsection elaborates on the details using a case study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Experimental Quantification</head><p>Our aim is to experimentally quantify maintainability following the approach sketched before. We evaluate our approach with 2 case studies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.1.">Case Studies.</head><p>The first case is a simple product line of calculators called MUKalk, which we developed <ref type="bibr" target="#b0">[2]</ref>. This product-line consists of 15 features, yielding hundreds of distinct calculator products. This case study enables us to evaluate initially our ideas <ref type="bibr" target="#b0">[2]</ref>. However, this case (i) was developed by us, and (ii) consisted only of a few classes. So, these reasons led us to consider that our initial ideas may not scale. Hence, we decided to evaluate our ideas with an external case.</p><p>We selected GPL (Graph Product Line) as (i) it has more classes (i.e. MUKalk consists of 3 Java classes and GPL of 16), and (ii) it is one of the case studies provided by AHEAD Tool Suite <ref type="bibr">[1]</ref> (this means that at least it has been used before by others).</p><p>GPL is a product line of graph manipulation programs. GPL can be downloaded together with AHEAD Tool Suite <ref type="bibr">[1]</ref>. GPL product line provides 18 features, which are typically sketched using a feature model, representing feature variability in a domain (i.e. features that are mandatory, optional and the way they are arranged into groups) <ref type="bibr" target="#b6">[8]</ref>. <ref type="figure" target="#fig_0">Figure 1</ref> shows the feature model for GPL.</p><p>We used GPL to first measure the MI for each product, then from this information we obtained the MI for each feature, and finally we elaborated on the overall MI of the product-line. Considering all the features of GPL we built all the possible products (147) and get measures of the MI for each product using SemanticDesigns' tooling. Next step was to create a system of equations with these results to get the values of MI for each feature (the equations system for GPL is partially shown in <ref type="figure">Figure 2</ref>). To this end, we created a matrix where the rows contain equations. There is one row per product. The number of columns is the number of features (read from left to right as product expressions in AHEAD). For instance, first equation in <ref type="figure">Figure 2</ref> represents product P001 in <ref type="table" target="#tab_1">Table 1</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2. GPL Equation System</head><p>While creating this system, we assumed that • (composition operator) was addition. This assumption was backed by recent studies showing AHEAD's duality where the rate of refinements within total is around 10%. Thus, the most of the code (90%) are introductions <ref type="bibr" target="#b0">[2]</ref>. Therefore, we can argue that • would be addition if the majority of the code is introduced. (This premise was later confirmed in our experiments.) MatLab 2 was used to resolve the matrix equation system. To this end, a vector (MI_vector) with all the MI values for products was created. Next, we show a partial vector with some values (the original vector has 147). <ref type="bibr">MI_vector=[153.96,146.62,149.50,153.23, 150.32,148.71,153</ref>.46]'</p><p>Then, a matrix specifying product features (PF) was created: 147 rows (1 per product) and 18 columns (1 per feature). Note that 1 designates the feature was present, whereas 0 means was not. Next, PF matrix is partially shown (the original has 147 rows). Note that 10 features out of 18 have an impact below 1 (positive and negative values). The lowest impact was 0.0119 and corresponds to feature s Number . The average impact was 1.6498.</p><p>MI incremented for 8 features and decremented for 9 (the base has an absolute value). So, these results seemed reasonable as some features improve MI (positive values), whereas others deteriorate it (remind that the larger MI means more maintainable).</p><p>MatLab resolution provides a range of errors (for these resolution) from 0 (product P147) to 1.2414 (product P008). </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. GPL Feature Model 4.4.2. Products MI. Considering all the features of GPL we built all the possible products (147) and get measures of the MI for each product using SemanticDesigns' tooling. Table 1 shows partially these results. At first glance, note that the MI variation is low, from 143.88 to 155.04. Each built product size ranges from 156 KB to 264 KB.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>MatLab used those entries (MI_vector and PF) to resolve an equation using the solveAxb function we created purposely. This function uses SVD command 3 . x = solveAxb (PF, MI_vector) Our function returned the values of each MI impact. The variation of the values (i.e. the partial impact on MI of each feature) ranged from -3.8017 of feature r MSTPrim to 6.1788 of feature o DirectedOnlyVertices .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><head>Table 1 shows</head><label>1</label><figDesc>partially these results. At first glance, note that the MI variation is low, from 143.88 to 155.04. Each built product size ranges from 156 KB to 264 KB.</figDesc><table>Product 
Features 
MI 
P001 
WeightedOnlyVertices•Number• 
DirectedOnlyVertices•BFS•base 

153.96 

P002 
WeightedWithNeighbours•Number• 
DirectedWithNeighbours•BFS•base 

146.62 

… 
P147 
WeightedWithEdges• 
UndirectedWhitEdges•Number• 
MSTPrim•DFS•Connected•Cycle•base 

146.80 

Table 1. Product measures 

4.4.3. Feature MI. </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head></head><label></label><figDesc>The average error is 0.2736. To evaluate these results, we calculate the product MI based on the values we obtain from equations.</figDesc><table>2 

We 
used 
specifically 
Matlab 
2006a 
version. 
http://www.mathworks.com/.</table></figure>

			<note place="foot" n="1"> Semantic Designs. http://www.semdesigns.com/</note>

			<note place="foot" n="3"> In linear algebra, the singular value decomposition (SVD) is an important factorization of a rectangular real or complex matrix, with several applications in signal processing and statistics (from http://en.wikipedia.org/wiki/Singular_value_decomposition).</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.4.">Product Line MI.</head><p>It is possible to elaborate on the MI value of each feature in order to study the MI of the entire product line. We sketched the feature model of GPL (see <ref type="figure">Figure 1</ref>), and annotate each feature with its corresponding MI value.</p><p>A first proposal to characterize the MI of the product-line would be the summation of the values of all features together. In GPL, the result would be 175.6524. However, this value is even higher than that of the most maintainable product (154.9087 of P043). This is because not all features can be selected in the same product (e.g. alternative features and exclusion dependencies). In addition, MI is based on average and not on summation. Hence, summation can neglect the sense of MI.</p><p>Alternatively, we characterize a product-line's MI by its range of values. Those values for GPL are: the lowest value is 144.4391 (P080), the highest is 154.9087 (P043), and the average is 149.2546. We believe this range characterizes better the SPL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Lessons Learned</head><p>We encountered many problems during the MI measurement of GPL. Most were not related with GPL, but with the quantification process itself. We believe that these problems hold to the measurement of product lines in general. Solutions to these problems in order to simplify future works are discussed below. Dependencies among Features: Impact of Order. We realize that the order in which a feature appears impacts on the whole product MI (i.e. the order is important as it affects to the product and to its maintainability). This means that (i) the feature does not have a fixed MI value, but it has an average, and (ii) the product MI depends on the feature order. Monotonicity. AHEAD may produce a non monotonic effect when previous code is not preserved (e.g. method overriding). This occurs scarcely, but it causes slight alterations in our estimations for MI as we calculate the average of those interactions. We detect this problem in GPL example when adding BFS feature to 3 different products and compare those 3 products without BFS. The impact of adding BFS ranged from 0.57, 0.72 and 0.97 (for each product). This occurs (without feature dependency) because monotonicity is not preserved. More to the point, BFS overrides different code and causes different changes. This implies that the feature impact is not independent, but depends on prior composed code.</p><p>Artifact Heterogeneity. This work focuses on code maintenance but there are as well other artifacts to maintain in an SPL, such as documents, requirements specification, architecture, production plan, models and all the artifacts or core assets that form the platform. Generality of Experiences. There are distinct approaches and paradigms to SPL development from which we chose AHEAD. It would be interesting to develop the same SPL using different variability implementation techniques, and evaluate whether the same MI are obtained for the same product constructed with different approaches Range of Maintainability Index. Prior work on the maintenance of C language code showed that values of MI ranging from 65 to 85 (or higher) seem to offer a good maintenance. However, in our case study measuring Java, we found values ranging from 145 to 155 (these figures are similar to our initial case study results). Thus, there is a significant difference between 65-85 and 145-155 ranges. We believe that such difference could be caused from the different languages that are used (i.e. C vs. Java). So, the range may depend on the language. This premise is backed by a recent work that suggests that MI can differ severely depending on the language <ref type="bibr" target="#b9">[11]</ref>. Exploiting SPL Maintainability. Our initial intention was just to quantify maintainability index of an SPL. We realize that the ultimate goal is really to exploit such data. Using MI impact enables to locate features where implementation may be enhanced, improving overall product's MI. The focus should be placed on features most used, which depends on feature commonality <ref type="bibr" target="#b1">[3]</ref>. Hence, we may focus on features where either MI, either feature commonality are large. On these features, we can take design decisions such as (i) simplifying feature code, (ii) refactoring feature code using bad smells in code, or (iii) splitting feature code among new created features.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusions</head><p>The need for SPL measurement, and particularly maintainability quantification, is a major issue currently in SPL development. We concentrated on Feature Oriented Programming as it provides a systematic approach to SPL development where a model to separate artifacts within features is provided.</p><p>This paper reported our experience on quantifying SPL maintainability. It introduced an initial model to measure it, and presented some experimental results with a product line case study. Our results confirmed partially our assumptions that need to be evaluated with further cases. We are currently using our approach on an industrial embedded system, which results could prove or refute our ideas.</p><p>The maintenance effort in SPL is significantly reduced as SPL developers are no longer maintaining each individual product (produced from the SPL), but they maintain the reusable assets from which those products are produced (SPL features). In our case, this meant maintaining 18 features code instead of 147 products code.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Experience Measuring Maintainability in Software Product Lines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Aldekoa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Al</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JISBD</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Automated reasoning on feature models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Benavides</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ruiz Cortés</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Trinidad</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Scaling Step-Wise Refinement, IEEE TSE</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Al</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2004-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Baxter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Al</forename></persName>
		</author>
		<title level="m">DMS®: Program Transformations for Practical Scalable Software Evolution. ICSE</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Software Product Lines -Practices and Patterns</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Clements</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Al</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Using Metrics to Evaluate Software System Maintainability</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Coleman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ash</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lowther</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">W</forename><surname>Oman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page">27</biblScope>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Staged Configuration Using Feature Models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Al</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Halstead</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Elements of Software Science. Operating, and Programming Systems Series</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<date type="published" when="1977" />
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">IEEE Standard Computer Dictionary: A Compilation of IEEE Standard Computer Glossaries</title>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Maintainability Index Revisited. System Quality and Maintainability at CSMR</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kuiper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Al</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Lehman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Al</forename></persName>
		</author>
		<title level="m">Program Evolution. Process of Software Change</title>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>Academia Press</publisher>
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Software Complexity, Crosstalk</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Mccabe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">H</forename><surname>Watson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Defense Software Engineering</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">12</biblScope>
			<date type="published" when="1994-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Maintainability measurements on industrial source code maintenance activities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Pearse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Oman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sei</forename><forename type="middle">Maintainability</forename><surname>Index</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Feature Oriented Model Driven Development: A Case Study for Portlets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Trujillo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Al</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Software Maintainability Metrics Models in Practice</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">D</forename><surname>Welker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Al</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Defense Soft. Eng</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">11</biblScope>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
