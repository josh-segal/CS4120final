<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:57+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">BRAID: Stream Mining through Group Lag Correlations</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yasushi</forename><surname>Sakurai</surname></persName>
							<email>sakurai.yasushi@lab.ntt.co.jp</email>
							<affiliation key="aff0">
								<orgName type="laboratory">NTT Cyber Space Laboratories</orgName>
								<orgName type="institution" key="instit1">Carnegie Mellon University</orgName>
								<orgName type="institution" key="instit2">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Spiros</forename><surname>Papadimitriou</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">NTT Cyber Space Laboratories</orgName>
								<orgName type="institution" key="instit1">Carnegie Mellon University</orgName>
								<orgName type="institution" key="instit2">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christos</forename><surname>Faloutsos</surname></persName>
							<email>christos@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="laboratory">NTT Cyber Space Laboratories</orgName>
								<orgName type="institution" key="instit1">Carnegie Mellon University</orgName>
								<orgName type="institution" key="instit2">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">BRAID: Stream Mining through Group Lag Correlations</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>The goal is to monitor multiple numerical streams, and determine which pairs are correlated with lags, as well as the value of each such lag. Lag correlations (and anti-correlations) are frequent, and very interesting in practice: For example, a decrease in interest rates typically precedes an increase in house sales by a few months; higher amounts of fluoride in the drinking water may lead to fewer dental cavities, some years later. Additional settings include network analysis, sensor monitoring, financial data analysis, and moving object tracking. Such data streams are often correlated (or anti-correlated), but with an unknown lag. We propose BRAID, a method to detect lag correlations between data streams. BRAID can handle data streams of semi-infinite length, incrementally, quickly, and with small resource consumption. We also provide a theoretical analysis , which, based on Nyquist&apos;s sampling theorem, shows that BRAID can estimate lag correlations with little, and often with no error at all. Our experiments on real and realistic data show that BRAID detects the correct lag perfectly most of the time (the largest relative error was about 1%); while it is up to 40,000 times faster than the naive implementation .</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>The processing and mining of data streams have attracted on increasing amount of interest recently. Data streams ap- * This work was done while this author was visiting Carnegie Mellon University. † This material is based upon work supported by the National Science Foundation under Grants No.</p><p>IIS-0083148, IIS-0113089, IIS-0209107 IIS-0205224 INT-0318547 SENSOR-0329549 EF-0331657IIS-0326322 CNS-0433540 by the Pennsylvania Infrastructure Technology Alliance (PITA) Grant No. 22-901-0001. Additional funding was provided by Intel and Northrop-Grumman Corporation. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation, or other funding parties.</p><p>pear in a variety of settings, such as environmental, medical and socioeconomic systems. Typical data-stream applications include network analysis, sensor monitoring, financial data analysis, and moving object tracking. In all these situations, the data sources generate data with no end in sight, making it impossible to store all the historical data. Moreover, we want fast response times, in 'any time' fashion.</p><p>There are many, fascinating research problems in such settings, as we survey later, like clustering <ref type="bibr" target="#b19">[20]</ref>, summarization <ref type="bibr" target="#b33">[34]</ref>, and forecasting <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b29">30]</ref>. Here we focus on a less-studied problem, namely on lag correlations. Our goal is to monitor k numerical sequences, X1, . . ., X k , and to determine automatically all the pairs of sequences that have a lag correlation. That is, we want to report all the pairs of sequences Xi and Xj, for which sequence Xi follows sequence Xj, with an unknown, arbitrary, lag l. We also want BRAID to report the lag l for each such pair of sequences.</p><p>Let's focus on two sequences first (k = 2), and then we generalize for more. Without loss of generality, we can assume that the two sequences have the same length n, by zero-padding the shortest. Then, the sub-problem we want to solve is as follows:</p><p>Problem 1 (Pair-wise Lag Correlation). Given two co-evolving sequences of equal length n= 1, 2, . . ., determine, at any point of time, two things: (a) whether there is a lag correlation between them, and (b) if yes, what is the lag length l.</p><p>The full problem we want to solve is as follows:</p><p>Problem 2 (Group Lag Correlation). Given k coevolving sequences of equal length n, determine, at any point of time, which pairs have a lag correlation, and report all such pairs, as well as the corresponding lags.</p><p>Intuitively, two sequences have a lag correlation of l if they look very similar when one is delayed by l time-ticks. The formal definition of the lag correlation is given in Definition 1 (Section 3.1). <ref type="figure" target="#fig_0">Figure 1</ref> (a) illustrates two lag-correlated sequences X and Y , with lag l=1300 time-ticks. is called the cross-correlation function (CCF) in time-series literatures. We will give the exact definitions for all these symbols and terms later.</p><p>We continue the discussion focusing on two streams, for simplicity. If the sequences X and Y were static, the problem would be trivial: simply compute the CCF (for lag l=0, 1, 2, . . .) and report the lag l, for which the CCF is maximized. However, when X and Y continuously increase in length, the problem is challenging. We need a method which will monitor X and Y , and whenever the user wants, the method should determine whether there is a lag correlation, and if yes, the value l of the lag. Specifically, we need a method that has the following characteristics:</p><p>• 'Any-time' processing, and fast. The computation time per time tick should be sub-linear (and, ideally, constant) on the length n of the sequences.</p><p>• Nimble: The memory space requirement should also be sub-linear on the length n.</p><p>• Accurate: Given that the exact results require too much space and time, we need approximations. Such approximation should introduce small error.</p><p>We propose BRAID, a lag capture method for two or more data streams. To our knowledge, BRAID is the first to possess all the above characteristics. The idea is to use careful approximations, exploiting the Nyquist sampling theorem. The net effect is that BRAID has dramatically better performance in terms of speed and memory, while it maintains excellent accuracy. Our experiments on real and realistic streams show that BRAID is up to 40,000 times faster than the straightforward lag computation, while maintaining relative error of 1% or less. The rest of the paper is organized as follows. Section 2 gives related work on data streams and stream mining. Section 3 describes our method, BRAID. We show how lags of data streams can be captured. Section 4 presents an enhanced algorithm for better accuracy. Section 5 gives our theoretical analysis for BRAID. Section 6 reviews the results of the experiments, which clearly show the effectiveness of BRAID. Section 7 is a brief conclusion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">SURVEY</head><p>Time-series and sensor networks have been attracting much interest recently. Although there are numerous publications in these research topics, we have not seen any method for that can automatically determine arbitrary lag correlations. We provide a survey of the related literatures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Indexing, compression, and DSMS</head><p>For indexing of time-series data, Agrawal et al. <ref type="bibr" target="#b1">[2]</ref> proposed to use the DFT (Discrete Fourier Transform) to extract features for indexing, with R*-trees as the underlying spatial access method. Follow-up work examined several related problems, including subsequence matching <ref type="bibr" target="#b12">[13]</ref>, the Adaptive Piecewise Constant Approximation (APCA) <ref type="bibr" target="#b23">[24]</ref>, indexing for Dynamic Time Warping (DTW) <ref type="bibr" target="#b22">[23]</ref>, similarity query processing for multi-dimensional data streams <ref type="bibr" target="#b25">[26]</ref>. Feature extraction, summarization and lossy compression are closely related, with powerful tools like wavelets <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref> and random projections <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b14">15]</ref>. Remotely related is also the work on data stream management systems (DSMSs). Sample systems include Aurora <ref type="bibr" target="#b0">[1]</ref>, Stream <ref type="bibr" target="#b28">[29]</ref>, Telegraph <ref type="bibr" target="#b6">[7]</ref> and Gigascope <ref type="bibr" target="#b8">[9]</ref> OSCAR <ref type="bibr" target="#b7">[8]</ref>. Algorithmic work includes query processing <ref type="bibr" target="#b27">[28]</ref>, scheduling <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b5">6]</ref>, load shedding <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b30">31]</ref>. <ref type="bibr">Guha et al. [20]</ref> have proposed an algorithm that solves the k-median problem for data streams in a single pass. <ref type="bibr">Domingos et al. [12]</ref> have presented an algorithm for constructing decision trees. The work in <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b30">31]</ref> focuses on streams with concept drifting. Zhu et al. <ref type="bibr" target="#b34">[35]</ref> study burst detection in streams. AWSOM <ref type="bibr" target="#b29">[30]</ref> is one of the first streaming methods for forecasting, in a single time sequence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Pattern discovery -single sequence</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Pattern discovery -multiple sequences</head><p>Multiple streams have also attracted significant interest. <ref type="bibr">Ganti et al. [16]</ref> propose a generic framework for streaming mining. Zhu et al. <ref type="bibr" target="#b33">[34]</ref> focus on monitoring multiple streams in real time. They use the "short window" Fourier Transform to summarize streams, and then compute all the pairwise correlations. However, the method will clearly miss any lag correlation that is longer than the window w of the short-window Fourier Transform. MUSCLES <ref type="bibr" target="#b32">[33]</ref> applies multi-variate linear regression on multiple co-evolving time sequences; moreover, it expects the user to specify a constant, upper limit m on the longest possible lag that it will consider (the default is m=5).</p><p>In conclusion, none of the above methods satisfies the specifications that we listed in the introduction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PROPOSED METHOD</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Preliminaries</head><p>A data stream X is a discrete sequence of numbers { x1, . . ., xt, . . ., xn }, where xn is the most recent value. Notice that n increases with every new time-tick.</p><p>The definition of the correlation coefficient R(0) between two time sequences X and Y of equal length n and zero lag, is a traditional one, known as Pearson's ρ coefficient:</p><formula xml:id="formula_0">ρ = R(0) = P t ((xt − ¯ x) * (yt − ¯ y)) σ(x) * σ(y)<label>(1)</label></formula><p>where ¯ x, ¯ y denote the mean of X and Y , respectively. For lag l (l ≥ 0), we consider only the common part of X and the shifted Y ; that is, only n − l time ticks, and the equation   becomes</p><formula xml:id="formula_1">R(l) = P n t=l+1 (xt − ¯ x)(y t−l − ¯ y) q P n t=l+1 (xt − ¯ x) 2 q P n−l t=1 (yt − ¯ y) 2<label>(2)</label></formula><formula xml:id="formula_2">¯ x = 1 n − l n X t=l+1 xt, ¯ y = 1 n − l n−l X t=1 yt</formula><p>where R(l) denotes the correlation coefficient, when X is delayed by l. Notice that we can easily handle the symmetric case; that is, when Y is the one delayed.</p><p>We are interested in high absolute values of R(l). Thus, we call score at lag l the absolute value of R(l), that is</p><formula xml:id="formula_3">score(l) = |R(l)|<label>(3)</label></formula><p>Definition 1 (Lag Correlation). Two sequences X and Y have a lag correlation of l, and specifically, that X lags Y by lag l, if 1. the score (=absolute value of the correlation coefficient ) between xt and y t−l is above a threshold γ, say γ = 0.4, and is actually a local maximum.</p><p>2. and this is the earliest such maximum, if more maxima exist.</p><p>The first requirement is straightforward. For the second requirement, the reasoning is more subtle: if the two sequences are periodic with the same period T , (which is often the case with real sequences -say, daily, or yearly periodicities), there will be many local maxima (l, l+T , l+2 * T , . . .).</p><p>Clearly, the earliest of these lags is the most important. Another subtle point from time series analysis is that the estimate R(l) for large values of the lag l ≈ n are undesirable, because the original and shifted time sequences will have too few overlapping time-ticks. Thus, following recommendations from the time series analysis <ref type="bibr" target="#b3">[4]</ref>, we restrict the maximum lag m to be n/2. Notice that even with this restriction, the maximum considered lag m increases with time, since we made it a function of the sequences' length. This changing nature of m creates subtle, but hard problems for all the earlier methods that we mentioned in the survey.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Main ideas behind BRAID</head><p>As we mentioned earlier, if we had infinite space and time, the problem would be trivial:</p><p>Naive Solution. At time n, we would access all the values of X and Y , we would compute the CCF, that is, the R(l) for all values of the lag l (=0,1, . . .), and we would choose the earliest maximum score above γ, or report that there is no lag correlation.</p><p>Our solution is based on the three major steps, each described next.</p><p>Observation 1. The correlation coefficient R() is an algebraic measure <ref type="bibr" target="#b20">[21]</ref>. That is, it can be computed incrementally.</p><p>More specifically, all we need is some sufficient statistics (namely, sums, sum of squares, sum products); then, R can be easily computed. Let Sx(1, n) be the sum of X of length n (i.e., Sx(1, n) = P n t=1 xt), and Sxx(1, n) be the sum of the squares of X (i.e., Sxx(1, n) = P n t=1 x 2 t ). Sxy(l) means the inner-product for X and the shifted Y :</p><formula xml:id="formula_4">Sxy(l) = n X t=l+1 xty t−l (4)</formula><p>We shall refer to all these values collectively as sufficient statistics . Given our sufficient statistics, the correlation coefficient R(l) is obtained by:</p><formula xml:id="formula_5">R(l) = C(l) p V x(l + 1, n) · V y(1, n − l)<label>(5)</label></formula><p>where C(l) is the covariance of X and Y :</p><formula xml:id="formula_6">C(l) = Sxy(l) − Sx(l + 1, n) · Sy(1, n − l) n − l</formula><p>and V x(l + 1, n) means the variance of the subsequence of X, starting from t = l + 1:</p><formula xml:id="formula_7">V x(l + 1, n) = Sxx(l + 1, n) − (Sx(l + 1, n)) 2 n − l (6)</formula><p>The variance V y(1, n − l) of Y is computed similarly. In conclusion, for the given value of lag l, we only need to keep track of five numbers, the sufficient statistics, because they are enough to help us estimate the correlation R(l), at any point of time. Although important, this observation is not enough to have a streaming method: It still needs linear time to compute the cross-correlation function (CCF) between the two given sequences X and Y . To reduce the lag-estimation time, we introduce an approximation:</p><p>Observation 2 (Geometric Probing). We compute (probe) the CCF at values of the lag l that form a geometric progression. Thus, we need only O(log n) numbers to estimate the CCF.</p><p>Specifically, instead of computing R(l) for every possible value of the lag l, we propose to keep track of only a geometric progression of the lag values: l= 0,1, 2, 4, . . ., 2 i , . . .. The justification is that it achieves a dramatic reduction in computation time, since we need only O(log n) numbers to keep track of, instead of O(n) that the "Naive Solution" requires. As we show later (see Theorem 4), this approximation introduces little error, and occasionally zero error. The intuition is that our method will give good accuracy for small l, exactly because for small l's we have many points to interpolate; it may give a larger error for large lag l, but the relative error will probably be small.</p><p>There is only one remaining problem: The space required grows linearly with the length n. The reason is subtle: in order to have the ability to compute the correlation coefficient R(l) at any time t (t = n, n + 1, . . .) we need to keep a sliding window of size l. Since l grows geometrically up to m = n/2, eventually we need O(n) space.</p><formula xml:id="formula_8">(a-1) (b-1) (c-1) (a-2) (b-2) (c-2)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Observation 3. We use the smoothed version of sequences to estimate the CCF. Thus, we achieve O(log n) space and O(1) time by geometric probing and sequence smoothing.</head><p>We propose to solve the above problem with our third and final idea, an approximation: Instead of operating on the original time sequences, we also compute their smoothed version, by computing the means of non-overlapping windows. The window widths will be powers of g=2, although any other number would also be acceptable. Let X be the original time sequence, and Ax h be its smoothed version with windows (window average) of length 2 h . That is, Ax0 is the original sequence; Ax1 consists of n/2 ticks, with the pair means; Ax2 has n/4 ticks, with the quadruplet means, and so on. At time n, we need O(log n) levels; for each level, we compute the sufficient statistics. Ax h and its sufficient statistics need to be computed every 2 h time ticks. On average, we require O(1) time to update the sufficient statistics since P log m h=0 1/2 h ≈ 2. Not only 'smoothing' saves space, but we can further prove that it results into a small or even zero error, under certain assumptions. Formally we approximate: R(l) ≈ ˆ R1(l/2), and in general</p><formula xml:id="formula_9">R(l) ≈ ˆ R h (l/2 h )<label>( 7 )</label></formula><p>wherê R h () is the correlation coefficient of the h-level smoothed sequences, andˆR0andˆ andˆR0() ≡ R(). Lemma 1 in Section 5.1.1 gives a theoretical justification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">BRAID</head><p>As we mentioned, the correlation R(l) of Equation <ref type="formula" target="#formula_5">(5)</ref> can be calculated incrementally. Moreover, we operate on increasingly coarser (smoother) representations of the sequences, by using window averages, with increasing window size. <ref type="figure" target="#fig_0">Figure 2 (b-1)</ref> shows an example of the window average. We compute the average of data points falling within a window, and organize all the windows hierarchically. The window size increases as the level of the hierarchy becomes higher.</p><p>BRAID is a lag capture method for data streams. To obtain a smoother curve to find the local maximum of the CCF, we can use an off-the-shelf interpolation method. We chose cubic splines <ref type="bibr" target="#b13">[14]</ref>, but the choice of interpolation method is orthogonal to BRAID.</p><p>We give some examples to explain how BRAID approximates the correlation coefficients and captures the lag for which the sequences are correlated.   </p><formula xml:id="formula_10">compute R 0 (0, t); delete R 0 (0, t − 1); // Compute the correlation coefficient for the level h for h = 0 to 񮽙log m񮽙 do if t mod 2 h = 0 then compute R h (1, t h ); delete R h (1, t h − 1); else break; endif endfor // Fit splines on the graph R h (l/2 h ) vs l // The series of l is a geometric progression // l = {0,1,2,4,. . . ,2 h ,. . . ,2 񮽙log m񮽙 } ˆ R h := Spline(R 0 (0), R 0 (1/2 0 ),R 1 (2/2 1 ),. . . ,R h (l/2 h ),. . . );</formula><p>extract the optimal lag fromˆRfromˆ fromˆR h (if any); are computed from the window averages for higher levels. Thus, we use a cubic spline to interpolate the missing correlation coefficients between the approximated coefficients. It effectively estimates that the correlation coefficients vary between these lags. Finally, we can see the lag correlation (if any) from the local maximum of the cubic spline curve (solid line in <ref type="figure" target="#fig_5">Figure 2 (c-2)</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Algorithm</head><p>Before introducing our algorithm, we give some definitions. Let Ax h (t) be the window average at time tick t for level h. Ax h (t) is computed as:</p><formula xml:id="formula_11">Ax h (t) = Ax h−1 (2t − 1) + Ax h−1 (2t) 2<label>(8)</label></formula><formula xml:id="formula_12">t = 1, . . . , n/2 h</formula><p>with Ax0(t) ≡ xt. We are now able to define the "sufficient statistics" for the window averages. The sum of Ax h and the sum of the squares on Ax h at t are obtained as:</p><formula xml:id="formula_13">Sx h (1, t) = Sx h (1, t − 1) + Ax h (t) Sxx h (1, t) = Sxx h (1, t − 1) + (Ax h (t)) 2<label>(9)</label></formula><p>The inner-product of Ax h and Ay h for lag l at t is incrementally updated every 2 h time ticks.</p><formula xml:id="formula_14">Sxy h (l, t) = Sxy h (l, t − 1) + Ax h (t) · Ay h (t − l)<label>(10)</label></formula><p>By using the obtained sufficient statistics, we can derive the correlation coefficient R h (l, t) as:</p><formula xml:id="formula_15">R h (l, t) = C h (l, t) p V x h (l + 1, t) · V y h (1, t − l)<label>(11)</label></formula><p>Algorithm SumKeeping(X) // Compute sum and sum square compute</p><formula xml:id="formula_16">Sx 0 (1, t), Sx 0 (2, t), Sxx 0 (1, t), Sxx 0 (2, t); delete Sx 0 (1, t − 2), Sx 0 (2, t − 1), Sxx 0 (1, t − 2), Sxx 0 (2, t − 1); for h = 1 to 񮽙log n񮽙 do if t mod 2 h = 0 then // Compute window average for h compute Ax h (t h ); delete Ax h−1 (t h−1 − 3), Ax h−1 (t h−1 − 2);</formula><p>// Compute sums and sum squares for h compute</p><formula xml:id="formula_17">Sx h (1, t h ), Sx h (2, t h ), Sxx h (1, t h ), Sxx h (2, t h ); delete Sx h (1, t h − 2), Sx h (2, t h − 1), Sxx h (1, t h − 2), Sxx h (2, t h − 1); else break; endif endfor Algorithm ProductKeeping(X, Y )</formula><p>// Compute inner-products compute Sxy 0 (0, t), Sxy 0 (1, t); delete Sxy 0 (0, t − 1), Sxy 0 (1, t − 1); for h = 1 to 񮽙log n񮽙 do if t mod 2 h = 0 then // Compute inner products for h compute Sxy h (1, t h ); delete Sxy h (1, t h − 1); else break; endif endfor where</p><formula xml:id="formula_18">C h (l, t) = Sxy h (l, t) − Sx h (l + 1, t) · Sy h (1, t − l) t − l V x h (l + 1, t) = Sxx h (l + 1, t) − (Sx h (l + 1, t)) 2 t − l</formula><p>The basic algorithm for incremental computations is shown in <ref type="figure" target="#fig_8">Figures 3 and 4</ref>. In these figures, t h denotes the time tick for level h (i.e., t h = t/2 h ).</p><p>For each incoming data point, we first incrementally update the window averages and their sufficient statistics for every level (See <ref type="figure" target="#fig_9">Figure 4)</ref>. We then approximate the correlation coefficient of the two sequences at l, R(l, t), from their window averages (See <ref type="figure" target="#fig_8">Figure 3)</ref>. By using multiple window sizes, we can compute the correlation coefficients for only a geometric progression of lags l:</p><formula xml:id="formula_19">l = {0, 1, 2, 4, 8, . . . , 2 h , . . . , 2 񮽙log m񮽙 }</formula><p>The missing correlation coefficients caused by the approximation are estimated by interpolation with a cubic spline. After interpolation, we can use any known method to find the local maxima -we chose Brent's method <ref type="bibr" target="#b4">[5]</ref>. If a high enough local maximum exists, we report the corresponding lag.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">ENHANCED BRAID</head><p>In <ref type="figure" target="#fig_8">Figures 3 and 4</ref>, the number of window averages that BRAID computes for each level, is 1. In fact, as described, BRAID is extremely nimble: for example, for two sequences of size ≈ 2 20 (1 million long each), it requires about 5 * log 2 20 =5*20 = 100 float numbers, which is about 800 bytes -way less than 1KB!</p><p>The question is what can we do in the highly likely case that larger memory is available. The proposed solution is to enhance our probing scheme, so that we can probe in many more places (= lags), while still using O(log n) space.</p><p>To make our probing denser, one idea would be to have windows of powers of g, where g 񮽙 = 2. A simpler idea, that we propose and implemented, is the use a mix of arithmetic plus geometric probing. So far, BRAID uses only one window at each smoothing level (0, 1, . . . , h). We propose to use b &gt; 1 such windows, say, b = 4 instead (See <ref type="figure">Figure 5)</ref>.</p><p>The algorithm shown in Section 3.3.1 keeps one number for each level, that is b = 1, with one exception, namely that the bottom level has 2b coefficients. While computing the correlation coefficients at l, we end up sampling the CCF in a mixture of geometric and arithmetic progressions: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">THEORETICAL ANALYSIS</head><p>In this section we give a theoretical analysis to show the accuracy and complexity of BRAID. Again, we focus on two sequences X and Y . To simplify the discussion, and without loss of generality, we assume that the given sequences X and Y are normalized to zero mean and unit standard deviation (i.e., ¯ x = ¯ y = 0 and σ(x) = σ(y) = 1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Accuracy</head><p>Our upcoming experiments show that we can closely estimate lag correlations despite our two approximations, the geometric probing and the smoothing. It turns out that this can be explained. In fact, if X and Y are "smooth" enough, then the errors introduced by smoothing and by probing are small. In fact, the probing error can even be zero, if  the input sequences each has a Nyquist frequency. Next we elaborate on each type of error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Smoothing</head><p>Informally, the intuition is the following: Observation 4. For sequences with low frequencies, smoothing introduces only small error.</p><p>Let xt be the values of the original sequence X at time t (t = 1, . . . , n), andˆxtandˆ andˆxt h be the smooth version of xt (t h = 񮽙t/2 h 񮽙). Given the Haar wavelet coefficients of X, wi (i = 1, . . . , n), then the error in the approximation of Equation <ref type="formula" target="#formula_0">(11)</ref> depends on the energy in the high frequencies.</p><formula xml:id="formula_20">n X t=1 (xt − ˆ xt h ) 2 = X i&gt;n/2 h w 2 i<label>(12)</label></formula><p>Since very few of the wavelet coefficients of real data sets are often significant and a majority are small <ref type="bibr" target="#b17">[18]</ref>, Equation <ref type="formula" target="#formula_0">(12)</ref> shows that the error is limited to a very small value for most of practical data.</p><p>Theorem 1. Let R be the correlation coefficient between sequences X and Y , then</p><formula xml:id="formula_21">R = 2 h X t h ˆ xt h ˆ yt h + ΔC (13)</formula><p>Algorithm SumKeeping(X) // Compute sum and sum square compute Sx 0 (1, t), Sxx 0 (1, t);  where</p><formula xml:id="formula_22">delete Sx 0 (1, t − 2b), Sxx 0 (1, t − 2b); for i = 2 to 2b do compute Sx 0 (i, t), Sxx 0 (i, t); delete Sx 0 (i, t − 1), Sxx 0 (i, t</formula><formula xml:id="formula_23">(1, t h ), Sxx h (1, t h ); delete Sx h (1, t h − 2b), Sxx h (1, t h − 2b); for i = b + 1 to 2b do compute Sx h (i, t h ), Sxx h (i, t h ); delete Sx h (i, t h − 1), Sxx h (i, t</formula><formula xml:id="formula_24">ΔC = X t (ΔxtˆytΔxtˆ Δxtˆyt h + ΔytˆxtΔytˆ Δytˆxt h + ΔxtΔyt) Δxt = xt − ˆ xt h</formula><p>Proof. Since xt = ˆ xt h + Δxt, the covariance is</p><formula xml:id="formula_25">C = X t (ˆ xt h ˆ yt h + ΔxtˆytΔxtˆ Δxtˆyt h + ΔytˆxtΔytˆ Δytˆxt h + ΔxtΔyt)</formula><p>If X and Y are normalized, σ(x) = σ(y) = 1. Thus, we have </p><formula xml:id="formula_26">R = P t xtyt σ(x) * σ(y) = 2 h X t h ˆ xt h ˆ yt h + ΔC</formula><formula xml:id="formula_27">R ≈ R h = P t h ˆ xt h ˆ yt h ˆ σ(x) * ˆ σ(y)<label>(14)</label></formula><p>Proof. By Equation <ref type="formula" target="#formula_0">(12)</ref>, we can see xt &gt;&gt; Δxt, then R &gt;&gt; ΔC, and σ 2 (x) ≈ 2 h ˆ σ 2 (x). Therefore, we have R ≈ R h .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Lag probing</head><p>The second source of error is the fact that BRAID probes a small subset of the actual values of the lag l. It turns out that, for smooth enough sequences, this introduces little, or even no error.</p><p>Observation 5. Let fX and fY be the Nyquist frequencies of X and Y , and let l be the lag length for X and Y . Then BRAID will find the lag correlations perfectly, if 0 ≤ l &lt; lR where lR = 2b fR fR = min(fX , fY ) BRAID uses coarse sequences to find lag correlations efficiently. To avoid missing lag correlations, we also need a reliable criterion upon which to check the accuracy. Before showing the criterion, we need to describe some theorems.</p><p>Theorem 2 (Sampling Theorem). If a continuous function contains no frequencies higher than f high , it is completely determined by its value at a series of points less than 1/2f high apart.</p><p>Proof. See <ref type="bibr" target="#b26">[27]</ref>.</p><p>In the theorem, the minimum sampling frequency, fNq = 2f high , is called the Nyquist frequency.</p><p>We next show the relationship between CCF and the Fourier transform, known as the cross-correlation theorem.</p><p>Theorem 3 (Cross-Correlation Theorem). Let F be the Fourier transform, and R(l) be the CCF of X and Y , then we have</p><formula xml:id="formula_28">F R = FX F * Y (15)</formula><p>where '*' denotes the complex conjugate. Proof. See <ref type="bibr" target="#b26">[27]</ref>.</p><p>Based on Theorems 2 and 3, we can derive the following theorem.</p><p>Theorem 4. Let fX and fY be the Nyquist frequencies of X and Y , and let fR = min(fX , fY ). Then R(l) is perfectly reconstructed from its samples taken uniformly if the sampling (i.e., 'probing') frequency is at least fR.</p><p>Proof. For X and Y , we have</p><formula xml:id="formula_29">FX (f ) = 0 (f &gt; fX /2) FY (f ) = 0 (f &gt; fY /2) then FR(f ) = 0 (f &gt; fR/2, fR = min(fX , fY ))</formula><p>Therefore, fR is the Nyquist frequency of R(l), i.e., R(l) can be reconstructed perfectly if the sampling frequency is fR.</p><p>Since probing by BRAID is not uniform, we need a new lemma. As always, we assume that the stream rate is one measurement per time unit.</p><p>Lemma 2. Given b coefficients for each level, BRAID will have no error in the estimation of a lag correlation of l if</p><formula xml:id="formula_30">2 h ≤ 1 fR (16)</formula><p>where h is the level that covers the lag correlation of l:</p><formula xml:id="formula_31">h = j 񮽙log 2 l b 񮽙 (l ≥ b) 0 ( l &lt; b)<label>(17)</label></formula><p>Proof. Theorem 4 shows that no information is lost if a signal is sampled at fR. Therefore, R(l) can be determined if the interval, 2 h , is less than or equal to 1/fR. Lemma 3. BRAID spots lag correlations of 0 ≤ l &lt; lR:</p><formula xml:id="formula_32">lR = 2b fR (18)</formula><p>Proof. Lag correlations can be detected if the following condition is satisfied:</p><formula xml:id="formula_33">l &lt; 2b &amp; 1 ≤ 1/fR, or l &lt; 4b &amp; 2 ≤ 1/fR, · · · or l &lt; 2 h+1 b &amp; 2 h ≤ 1/fR. R(l) can be determined if 0 ≤ l &lt; 2 h+1 b ≤ 2b/fR.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Complexity</head><p>In this section, we discuss the complexity of BRAID and show that BRAID can efficiently estimate lag correlations.</p><p>Let m be the maximum lag we want to capture. Suppose that m is proportional to the sequence length n.</p><p>Lemma 4. For every pair of sequences, the "Naive Solution" requires space O(n) and time O(n).</p><p>Proof. When xn and yn arrive, it computes the correlation coefficient R(l, n) for each lag l (l = 0, 1, . . . , m). To compute R(l, n), it keeps yt (t=n − m,. . . ,n) and xn. Thus, it needs to store 2m + 3 values and update the m + 1 values. Since m is proportional to n, it requires space O(n) and time O(n).</p><p>Lemma 5. For each pair of sequences, the proposed BRAID requires O(log n) space.</p><p>Proof. BRAID needs to maintain the (log m+2) correlation coefficients since the bottom level has double the number of coefficients. To compute the correlation coefficients, BRAID keeps the log m + 1 values for X and (log m + 2) values for Y . This requires space O(log n). While BRAID needs to maintain sufficient statistics, they are the same complexity. Therefore, the space complexity of BRAID is O(log n).</p><p>Lemma 6. The proposed BRAID requires O(1) amortized time per time-tick for updating sufficient statistics.</p><p>Proof. The window average needs to be computed every 2 h time ticks (h=1,. . . ,log m). On average, BRAID computes one value for each incoming data point, because P log m h=1 1/2 h ≈ 1. Similarly, the sufficient statistics can be updated in O(1) time. Therefore, the amortized time complexity of BRAID is O(1).</p><p>When output is required, BRAID employs interpolation to closely estimate lag correlations.</p><p>Lemma 7. The proposed BRAID requires O(log n) time for interpolating.</p><p>Proof. The cubic spline for the geometric probing requires O(log n) time. See <ref type="bibr" target="#b13">[14]</ref>.</p><p>BRAID can retain more than one correlation coefficient for each level, that is b ≥ 1. Since b is a small constant (i.e., b 񮽙 n), the space required is still O(log n), and the time complexity is O(1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EXPERIMENTS</head><p>To evaluate the effectiveness of BRAID, we performed experiments on real and synthetic datasets. We compared BRAID with the naive implementation. As mentioned in Section 4, we can have "enhanced BRAID", where b &gt; 1. That is, we keep more than one window-average for each level. We performed our experiments with b = 16, on an Intel Xeon 2.8GHz with 1GB of memory, running Linux.</p><p>The experiments were designed to answer the following questions:</p><p>1. How well does BRAID estimate the correlation coefficients for periodic and/or bursty datasets?</p><p>2. How successful is it in spotting lag correlations?</p><p>3. How does it scale with the sequence lengths n in terms of the computation time?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Datasets</head><p>We performed experiments on the following real and synthetic data sets. For synthetic data sets, we used the following:</p><p>• Sines: the data set consists of two sequences of length n = 32, 768. Each sequence is a mixture of sine waves of different frequencies. We chose this setting because it resembles real data, such as network and automobile traffic (daily, weekly, and yearly periodicities), product sales (umbrellas, flu medicine -yearly periodicities), etc.</p><p>• SpikeTrains: a pair of periodic pulse trains with white noise. The period of these sequences is 6500, and the length is 100,000. This data set is also realistic: for example, disk access traffic is bursty <ref type="bibr" target="#b31">[32]</ref>, with daily periodicity; the famous sunspot dataset has spikes, with a 9-11 year periodicity <ref type="bibr" target="#b29">[30]</ref>.</p><p>For Real data sets, we used the following:</p><p>• Humidity, Light, Temperature: humidity, illuminance, and temperature readings, from 55 sensors within several buildings. Each sensor gives a reading every 30 seconds. We chose two sequences for each of the data sets, Humidity and Light, and used all sequences for Temperature.</p><p>• Kursk: Seismic recordings from multiple sensors, showing the explosion of the Russian submarine "Kursk" <ref type="bibr" target="#b24">[25]</ref>. Each sequence has a single burst. We extracted two subsequences of length n=70,000.</p><p>• Sunspots: Number of sunspots per day. The dataset has a period of approximately 11 years 1 . We chose two intervals from the dataset, each length n=25,900, and treated them as if they were two different time sequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Detecting lag correlations</head><p>Figures 8 and 9 show the estimation of BRAID for all data sets. In these figures, "Naive" denotes the exact correlation coefficients computed by the naive implementation. "Approximation" means the correlation coefficients computed from the window averages. BRAID interpolates the missing values between these correlation coefficients. 1 http://csep10.phys.utk.edu/astr162/lect/sun/sscycle.html   <ref type="table" target="#tab_4">Table 2</ref> shows the estimation error of the captured lag correlations. As shown in Definition 1, the most important lag correlation is the earliest local maximum. The experiments clearly demonstrate that BRAID detects the correct lag perfectly, most of the time. The largest relative error was about 1%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Performance</head><p>We theoretically discussed the complexity of BRAID in Section 5.2. However, BRAID needs not only the computation of correlation coefficients, but also overheads including the ones for the interpolation and extraction of the lag correlation from the spline curve. Therefore, we did an empirical study of the computation time. <ref type="figure" target="#fig_0">Figure 10</ref> compares BRAID and the naive implementation in terms of wall clock time under varying sequence lengths n. We used Sines for this experiment. The wall clock time is the average of the processing time to update sufficient statistics for each time tick and detect the lag correlations.</p><p>For stream data, since the sequence length continues to  grow, the computation time also increases. Instead of the O(n) that the naive implementation requires, BRAID can achieve a dramatic reduction in computation time. This trend shown in the figure corresponds to our theoretical discussion in Section 5.2. Theoretically, BRAID requires time O(1) for updating the sufficient statistics; the computation time does not depend on n. In this experiment, the wall clock time increases slightly as n grows. This increase is caused by interpolation, because we need to interpolate through a larger, O(log n) number of points. Specifically, BRAID is up to about 40,000 times faster than the naive implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Effect of probing</head><p>In Section 5.1.2 we provided that says when exactly BRAID can estimate the lag without error. (see Lemma 3) In this section, we will show examples of the criterion and discuss the effect of probing by exploiting Lemma 3 to reinforce our theoretical analysis. <ref type="figure" target="#fig_0">Figure 11</ref> (a) shows the power spectrum of Sines in the frequency domain. Note that Sines #1 and #2 have the same power spectrum. The power spectrum is computed from the normalized sequences. That is, P F 2 = 1 and F 2 (f0) = 0. Intuitively, f on the y-axis means the first f Fourier coefficients. We can observe that in this figure, the energy is distributed in the range of 0 ≤ f ≤ 32. Thus, the Nyquist frequency is fR = 64/n. According to <ref type="bibr">Lemma 3,</ref> we have lR = 1024b. <ref type="figure" target="#fig_0">Figure 11</ref> (b) presents an estimation of BRAID for Sines. We used one coefficient (i.e., b = 1) for each level in <ref type="figure" target="#fig_0">Figure 11</ref> (b). We saw how BRAID can closely estimate the lag correlation with b = 1, because the lag is less than lR = 1024. We next discuss the criterion for real data. Real data often include high frequencies of very small energy. The Nyquist frequency could be extremely high for such data. Since the frequency limit is widely understood in various areas (e.g., audio processing, network analysis, and electrical engineering), we will focus on the frequency components that are larger than a very small value, say 񮽙. We set 񮽙 = 0.01 in this experiment.</p><p>Figures 12 (a) and (b) present the power spectra of Light, and <ref type="figure" target="#fig_0">Figure 12 (c)</ref> shows the estimation for b = 1. The power of the frequency components larger than 񮽙 is distributed in the frequency range of 0 ≤ f ≤ 52. Therefore, we have lR ≈ 630. As shown in <ref type="figure" target="#fig_0">Figure 12</ref> (c), we can spot the lag correlation, because the local maximum is near lR.</p><p>In Lemma 3, we expect the frequency of each sequence to obtain lR. Incremental algorithms have been proposed to compute the frequency in the streaming sense (e.g., <ref type="bibr" target="#b16">[17]</ref>). BRAID can utilize any and all of these solutions to compute the frequency efficiently. However, this research topic is beyond the scope of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Detecting group lag correlations</head><p>We applied BRAID to detecting group lag correlations </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>We have introduced the problem of automatic lag correlation detection on streaming data and proposed BRAID to address this problem, using careful approximations and smoothing. The resulting method has all the desired characteristics:</p><p>1. It is 'any-time': it can give a response at any time, pinpointing the lag if it exists, or declaring that there is no lag correlation. 2. Low resource consumption: it needs O(log n) space, and O(1) time to update the statistics. 3. High accuracy: it detects the correct lag within 1% relative error or less</p><p>Our experiments on real and realistic data show that BRAID works as expected, estimating the unknown lags with excellent accuracy and high speed. Specifically, BRAID can be up to 40,000 times faster than the naive implementation while the largest relative error was 1%. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 (</head><label>1</label><figDesc>b) shows the correlation coefficient R(l) of X and Y as a func- tion of the lag l (=0,1, . . .). The plot shown in Figure 1 (b)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Example of correlated sequences. (a) Two sequences X and Y , with X lagging Y by 1300 timeticks. (b) Their cross correlation function (CCF), peaking at l=1300.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 : Illustration of BRAID. (a- 1 ) (a- 2 )without smoothing. (b- 1 ) (b- 2 ) Using all versions of smoothed sequences allows a partial redundancy. (c- 1 ) (c- 2 ) BRAID keeps track of only a geometric progression of lag values.</head><label>2121212</label><figDesc>Figure 2: Illustration of BRAID. (a-1) (a-2) The "Naive Solution" computes all values of the lag l = 0, . . ., without smoothing. (b-1) (b-2) Using all versions of smoothed sequences allows a partial redundancy. (c-1) (c-2) BRAID keeps track of only a geometric progression of lag values.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Fig- ure 2 (c-1) illustrates how BRAID uses the window aver- ages. The colored (shaded, in B/W) boxes in this figure represent the window averages BRAID uses for computing correlation coefficients and capturing lags. BRAID ignores the white ones and does not calculate their window averages. BRAID maintains one value for each level in the figure, with one exception: the bottom level has double the number of windows. BRAID approximates the correlation coefficients R(l) (l = 1, 2, 4, 8, . . .) of the two sequences from their window aver- ages. It incrementally computes window averages for every level and correlation coefficients for several lags, as shown in Figure 2 (c-2) (circles, squares, triangles etc).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 2 (</head><label>2</label><figDesc>a) illustrates the "naive" method: Figure 2 (a-1) denotes that we keep the values for all the time ticks (shaded). Figure 2 (a-2) shows an illustration of the CCF (cross correlation function) for two fictitious sequences. We need to capture the lag with a high correlation coefficient.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 2 (</head><label>2</label><figDesc>b) illustrates a non-recommended method, which is only useful for explanations. Figure 2 (b-2) illustrates the correlation coefficients calculated from all window averages, that is, all the shaded/colored rectangles in Figure 2 (b-1). The window averages allow a partial redundancy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 2 (</head><label>2</label><figDesc>c) shows the proposed BRAID. Here, we elim- inate the redundant points, favoring the smallest window, which should give more accurate results. Figure 2 (c-2) shows the correlation coefficients obtained from the selected window averages shown in Figure 2 (c-1). In contrast with the smaller lags, the larger lags are sparse because they Algorithm BRAID input: new values at t for k sequences X 1 , . . . , X k output: lag correlations for sequence pairs if any for each sequence X do // Update the sums and sum squares of X SumKeeping(X); for each pair of sequence X and Y do // Update the products of X and Y ProductKeeping(X, Y ); if output is required at t then // Spot a lag correlation if any LagDetecting(X, Y ); report a lag correlation if any; endif endfor Algorithm LagDetecting(X, Y ) // Compute the correlation coefficient of X and Y</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 3 : Algorithm for detecting lag correlations.</head><label>3</label><figDesc>Figure 3: Algorithm for detecting lag correlations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 4 : Algorithm for updating window averages and their sufficient statistics.</head><label>4</label><figDesc>Figure 4: Algorithm for updating window averages and their sufficient statistics.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 5 : Illustration of the enhanced BRAID (b = 4 ). (a) The enhanced algorithm uses the colored windows. (b) It computes four coefficients for each level.</head><label>54</label><figDesc>Figure 5: Illustration of the enhanced BRAID (b = 4). (a) The enhanced algorithm uses the colored windows. (b) It computes four coefficients for each level.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>l</head><label></label><figDesc>Figure 5 shows an example of the enhanced BRAID of b = 4. We compute the correlation coefficients at l: l = {0, 1, . . . , 7; 8, 10, 12, 14; 16, 20, 24, 28; 32, 40, . . .} The enhanced algorithm for incremental computation is shown in Figures 6 and 7. If b = 1, these figures are absolutely equal to Figures 3 and 4 in Section 3.3.1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Algorithm BRAID input:</head><label></label><figDesc>new values at t for k sequences X 1 , . . . , X k output: lag correlations for sequence pairs if any for each sequence X do // Update the sums and sum squares of X SumKeeping(X); for each pair of sequence X and Y do // Update the products of X and Y ProductKeeping(X, Y ); if output is required at t then // Spot a lag correlation if any LagDetecting(X, Y ); report a lag correlation if any; endif endfor Algorithm LagDetecting(X, Y ) // Compute the correlation coefficient of X and Y for i = 0 to b − 1 do compute R 0 (i, t); delete R 0 (i, t − 1); endfor // Compute the correlation coefficient for the level h for h = 0 to 񮽙log(m/b)񮽙 do if t mod 2 h = 0 then for i = b to 2b − 1 do compute R h (i, t h ); delete R h (i, t h − 1); endfor else break; endif endfor // Fit splines on the graph R h (l/2 h ) vs l. The series of l is // a mixture of geometric and arithmetic progressions. ˆ R h := Spline(R 0 (0), R 0 (1/2 0 ),. . . ,R h (l/2 h ),. . . ); extract the optimal lag fromˆRfromˆ fromˆR h (if any);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 6 : Enhanced algorithm for detecting lag cor- relations.</head><label>6</label><figDesc>Figure 6: Enhanced algorithm for detecting lag correlations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>− 1); endfor for h = 1 to 񮽙log n񮽙 do if t mod 2 h = 0 then // Compute window average for h compute Ax h (t h ); delete Ax h−1 (t h−1 − 2b − 1), Ax h−1 (t h−1 − 2b); // Compute sums and sum squares for h compute Sx h</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Algorithm</head><label></label><figDesc>Figure 7: Enhanced algorithm for updating sufficient statistics.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 8 : Estimation of the correlation coefficients (CCF) for Sines, SpikeTrains, and Humidity. The bottom row shows the CCF; "Naive", and BRAID, using dashed and solid lines, respectively.</head><label>8</label><figDesc>Figure 8: Estimation of the correlation coefficients (CCF) for Sines, SpikeTrains, and Humidity. The bottom row shows the CCF; "Naive", and BRAID, using dashed and solid lines, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 8 (</head><label>8</label><figDesc>Figure 8 (a) shows that BRAID perfectly approximates the correlation coefficients of the sinusoidal wave. Figure 8 (b) also indicates that BRAID closely estimates the correlation coefficients using interpolation and captures the lag correlations of the spike. Similar trends are shown in Figure 9. While the data values fluctuate dramatically with time ticks in real datasets, BRAID successfully captures the periodic lag correlations. Table 2 shows the estimation error of the captured lag correlations. As shown in Definition 1, the most important lag correlation is the earliest local maximum. The experiments clearly demonstrate that BRAID detects the correct lag perfectly, most of the time. The largest relative error was about 1%.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Figure 9 : Estimation of correlation coefficients (cross-correlation function CCF) for Light, Kursk, and Sunspots. The bottom row shows the CCF; "Naive", and BRAID, using dashed and solid lines,Figure 10 : Wall clock time as a function of sequence length. BRAID can be up to 40, 000 times faster.</head><label>910000</label><figDesc>Figure 9: Estimation of correlation coefficients (cross-correlation function CCF) for Light, Kursk, and Sunspots. The bottom row shows the CCF; "Naive", and BRAID, using dashed and solid lines, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Figure 12 :</head><label>12</label><figDesc>Figure 11: Estimation of CCF for b = 1 (Sines).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Figure 13 : Example of group lag correlations.</head><label>13</label><figDesc>Figure 13: Example of group lag correlations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>n Length of sequences m Maximum lag (e.g., m = n/2) h Level of BRAID (0, . . . , 񮽙log m񮽙) l Lag (0, . . . , m) xt Value of a sequence X at time t = 1, . . . , n yt Value of a sequence Y at time t = 1, . . . , n Ax h (t), Ay h (t) Disjoint window average of each sequence R(l) Correlation of X and Y for the lag l R h (l)</head><label></label><figDesc></figDesc><table>Correlation coefficient computed from 
window averages X h and Y h at the lag l 
ˆ 
R(l) 
Approximate correlation for the lag l 
γ 
Threshold for correlation coefficients 
k 
Number of sequences 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table>Symbols and definitions. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Estimation error of lag correlations. 

</table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Aurora: a new model and architecture for data stream management</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Carney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Cetintemel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cherniack</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Convey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Tatbul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">B</forename><surname>Zdonik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="120" to="139" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Efficient similarity search in sequence databases. FODO</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Swami</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993-10" />
			<biblScope unit="page" from="69" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Chain : Operator scheduling for memory minimization in data stream systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Babcock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Babu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Datar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGMOD</title>
		<imprint>
			<biblScope unit="page" from="253" to="264" />
			<date type="published" when="2003-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Time Series Analysis: Forecasting and Control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">E</forename><surname>Box</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">M</forename><surname>Jenkins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">C</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
			<publisher>Prentice Hall</publisher>
			<pubPlace>Englewood Cliffs, NJ</pubPlace>
		</imprint>
	</monogr>
	<note>3rd edition</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Algorithm for Minimization without Derivatives</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">P</forename><surname>Brent</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<publisher>Dover Publications</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Operator scheduling in a data stream manager</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Carney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Cetintemel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rasin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">B</forename><surname>Zdonik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cherniack</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-09" />
			<publisher>VLDB</publisher>
			<biblScope unit="page" from="838" to="849" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Telegraphcq: Continuous dataflow processing for an uncertain world</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chandrasekaran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Deshpande</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Raman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Reiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Shah</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-01" />
			<publisher>CIDR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Remembrance of streams past: Overload-sensitive management of archived streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chandrasekaran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004-09" />
			<publisher>VLDB</publisher>
			<biblScope unit="page" from="348" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Gigascope: A stream database for network applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Cranor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Spatscheck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Shkapenyuk</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-06" />
			<publisher>ACM SIGMOD</publisher>
			<biblScope unit="page" from="647" to="651" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Approximate join processing over data streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gehrke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Riedewald</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-06" />
			<publisher>ACM SIGMOD</publisher>
			<biblScope unit="page" from="40" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Processing complex aggregate queries over data streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Dobra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">N</forename><surname>Garofalakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gehrke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rastogi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002-06" />
			<publisher>ACM SIGMOD</publisher>
			<biblScope unit="page" from="61" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Mining high-speed data streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Domingos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hulten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">KDD</title>
		<imprint>
			<biblScope unit="page" from="71" to="80" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Fast subsequence matching in time-series databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ranganathan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Manolopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD</title>
		<meeting>ACM SIGMOD<address><addrLine>Minneapolis, MN</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="419" to="429" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Computer Methods for Mathematical Computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">E</forename><surname>Forsythe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1977" />
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Processing set expressions over continuous update streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ganguly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">N</forename><surname>Garofalakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rastogi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-06" />
			<publisher>ACM SIGMOD</publisher>
			<biblScope unit="page" from="265" to="276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Mining data streams under block evolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Ganti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gehrke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGKDD Explorations</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="10" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Indyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Strauss</surname></persName>
		</author>
		<title level="m">Near-optimal sparse fourier representations via sampling. STOC</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="152" to="161" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Surfing wavelets on streams: One-pass summaries for approximate aggregate queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kotidis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Strauss</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-09" />
			<publisher>VLDB</publisher>
			<biblScope unit="page" from="79" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Xwave: Approximate extended wavelets for streaming data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Shim</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004-09" />
			<publisher>VLDB</publisher>
			<biblScope unit="page" from="288" to="299" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Clustering data streams: Theory and practice</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Meyerson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>O&amp;apos;callaghan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TKDE</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="515" to="528" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Data Mining: Concepts and Techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kamber</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Mining time-changing data streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hulten</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Spencer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Domingos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">KDD</title>
		<imprint>
			<biblScope unit="page" from="97" to="106" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename><surname>Keogh</surname></persName>
		</author>
		<title level="m">Exact indexing of dynamic time warping. VLDB</title>
		<imprint>
			<date type="published" when="2002-08" />
			<biblScope unit="page" from="406" to="417" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Locally adaptive dimensionality reduction for indexing large time series databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename><surname>Keogh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mehrotra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Pazzani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-05" />
			<publisher>ACM SIGMOD</publisher>
			<biblScope unit="page" from="151" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Forensic seismology and the sinking of the kursk</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Koper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hartse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EOS Trans., AGU</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="page" from="45" to="46" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Approximate nn queries on streams with guaranteed error/performance bounds. VLDB</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Ooi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Zhang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004-09" />
			<biblScope unit="page" from="804" to="815" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Signal Processing and Linear Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">P</forename><surname>Lathi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<publisher>Oxford University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Continuously adaptive continuous queries over streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Raman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002-06" />
			<publisher>ACM SIGMOD</publisher>
			<biblScope unit="page" from="49" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Query processing, approximation, and resource management in a data stream management system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Arasu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Babcock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Babu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Datar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">S</forename><surname>Manku</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Olston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rosenstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Varma</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-01" />
			<publisher>CIDR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Adaptive, hands-off stream mining. VLDB</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Brockwell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-09" />
			<biblScope unit="page" from="560" to="571" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Load shedding in a data stream manager. VLDB</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Tatbul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Cetintemel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">B</forename><surname>Zdonik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cherniack</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-09" />
			<biblScope unit="page" from="309" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Data mining meets performance evaluation: Fast algorithms for modeling bursty traffic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Madhyastha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">H</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICDE</title>
		<imprint>
			<date type="published" when="2002-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Online data mining for co-evolving time sequences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B.-K</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Sidiropoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Jagadish</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Biliris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICDE</title>
		<imprint>
			<biblScope unit="page" from="13" to="22" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Statistical monitoring of thousands of data streams in real time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Shasha</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002-08" />
			<publisher>VLDB</publisher>
			<biblScope unit="page" from="358" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Efficient elastic burst detection in data streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Shasha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">KDD</title>
		<imprint>
			<biblScope unit="page" from="336" to="345" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
