<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:27+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">TaintScope: A Checksum-Aware Directed Fuzzing Tool for Automatic Software Vulnerability Detection</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tielei</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Ministry of Education</orgName>
								<orgName type="laboratory">Key Laboratory of Network and Software Security Assurance (Peking University)</orgName>
								<address>
									<postCode>100871</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Institute of Computer Science and Technology</orgName>
								<orgName type="institution">Peking University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tao</forename><surname>Wei</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Ministry of Education</orgName>
								<orgName type="laboratory">Key Laboratory of Network and Software Security Assurance (Peking University)</orgName>
								<address>
									<postCode>100871</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Institute of Computer Science and Technology</orgName>
								<orgName type="institution">Peking University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guofei</forename><surname>Gu</surname></persName>
							<email>guofei@cse.tamu.edu</email>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science &amp; Engineering</orgName>
								<orgName type="institution">Texas A&amp;M University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Zou</surname></persName>
							<email>zouwei@icst.pku.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="department">Ministry of Education</orgName>
								<orgName type="laboratory">Key Laboratory of Network and Software Security Assurance (Peking University)</orgName>
								<address>
									<postCode>100871</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Institute of Computer Science and Technology</orgName>
								<orgName type="institution">Peking University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">TaintScope: A Checksum-Aware Directed Fuzzing Tool for Automatic Software Vulnerability Detection</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>fuzzing</term>
					<term>dynamic taint analysis</term>
					<term>symbolic execu- tion</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Fuzz testing has proven successful in finding security vulnerabilities in large programs. However, traditional fuzz testing tools have a well-known common drawback: they are ineffective if most generated malformed inputs are rejected in the early stage of program running, especially when target programs employ checksum mechanisms to verify the integrity of inputs. In this paper, we present TaintScope, an automatic fuzzing system using dynamic taint analysis and symbolic execution techniques, to tackle the above problem. TaintScope has several novel contributions: 1) TaintScope is the first checksum-aware fuzzing tool to the best of our knowledge. It can identify checksum fields in input instances, accurately locate checksum-based integrity checks by using branch profiling techniques, and bypass such checks via control flow alteration. 2) TaintScope is a directed fuzzing tool working at X86 binary level (on both Linux and Window). Based on fine-grained dynamic taint tracing, TaintScope identifies which bytes in a well-formed input are used in security-sensitive operations (e.g., invoking system/library calls) and then focuses on modifying such bytes. Thus, generated inputs are more likely to trigger potential vulnerabilities. 3) TaintScope is fully automatic, from detecting checksum, directed fuzzing, to repairing crashed samples. It can fix checksum values in generated inputs using combined concrete and symbolic execution techniques. We evaluate TaintScope on a number of large real-world applications. Experimental results show that TaintScope can accurately locate the checksum checks in programs and dramatically improve the effectiveness of fuzz testing. TaintScope has already found 27 previously unknown vulnerabilities in several widely used applications, including Adobe Acrobat, Google Picasa, Microsoft Paint, and ImageMagick. Most of these severe vulnerabilities have been confirmed by Secunia and oCERT, and assigned CVE identifiers (such as CVE). Corresponding patches from vendors are released or in progress based on our reports.</p>
			</abstract>
		</profileDesc>
		<revisionDesc>
				<date type="submission" when="2009" />
		</revisionDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>As a well-known software testing technique, fuzz testing or fuzzing <ref type="bibr" target="#b46">[51]</ref> has proven successful in finding bugs and security vulnerabilities in large software. The idea behind fuzzing is very simple: generating malformed inputs and feeding them to an application; if the application crashes or *Corresponding author hangs, a potential bug/vulnerability is detected. A number of severe software vulnerabilities have been revealed by fuzzing techniques <ref type="bibr" target="#b59">[64]</ref>, <ref type="bibr" target="#b53">[58]</ref>. For example, with the help of fuzzing tools, "Month of Browser Bugs" <ref type="bibr" target="#b5">[10]</ref> and "Month of Kernel Bugs" <ref type="bibr" target="#b6">[11]</ref> published bugs in various browsers and kernels on a daily basis for the month of July and November in 2006.</p><p>Since exhaustive enumeration of an application's input space is typically infeasible, there are two main approaches to obtain malformed inputs: data mutation and data generation <ref type="bibr" target="#b53">[58]</ref>. Mutation-based fuzzing tools generate test cases by randomly modifying well-formed inputs. However, most malformed inputs from such blind modifications will be dropped at an early stage of program running if the target program employs a checksum mechanism to verify the integrity of inputs. The effectiveness of these fuzzing tools is heavily limited by checksum-based integrity checks.</p><p>Recently, symbolic execution and constraint solving based whitebox fuzzing systems (such as KLEE <ref type="bibr" target="#b21">[27]</ref>, SAGE <ref type="bibr" target="#b37">[43]</ref>, <ref type="bibr">SmartFuzz [52]</ref>, EXE <ref type="bibr" target="#b22">[28]</ref>, CUTE <ref type="bibr" target="#b57">[62]</ref>, DART <ref type="bibr" target="#b36">[42]</ref>) can substitute all program inputs with symbolic values, gather input constraints on a program trace and generate new inputs that can drive program executions along different traces. These systems are able to provide good code coverage and have proven to highly improve the effectiveness of traditional fuzzing tools. However, current symbolic execution engines and constraint solvers still cannot accurately generate and solve the constraints that describe the complete process of complex checksum algorithms <ref type="bibr" target="#b58">[63]</ref>. In a word, such whitebox fuzzing systems also cannot automatically generate inputs which satisfy the checksum-based integrity constraints.</p><p>For generation-based fuzzing tools (such as SPIKE <ref type="bibr" target="#b12">[18]</ref>, Peach <ref type="bibr" target="#b10">[15]</ref>, PROTOS <ref type="bibr" target="#b55">[60]</ref>) which construct malformed input data from predefined format specifications, the cost of generating production rules used by fuzzing tools is expensive, especially when the format specifications are undocumented and the source code of the application is not available. Recently, several protocol reverse engineering techniques <ref type="bibr" target="#b20">[26]</ref>, <ref type="bibr" target="#b41">[47]</ref>, <ref type="bibr" target="#b28">[34]</ref>, <ref type="bibr" target="#b25">[31]</ref> are proposed to automatically extract input format specification (even protocol state machine) and translate them into fuzzing specifications. However, they are not able to reverse engineer the checksum algorithms. Thus, the constructed input according to such reverseengineered protocol specification still can be rejected by integrity checks. In addition, none of such systems explicitly discuss how to bypass checksum checks for fuzzing.</p><p>In this paper, we present TaintScope, a checksum-aware directed fuzzing system based on dynamic taint analysis and symbolic execution. The key idea behind TaintScope is that the taint propagation information during program execution can be used to detect and bypass checksum-based integrity checks, and to direct malformed test cases generation. TaintScope can further fix checksum fields in malformed test cases by using combined concrete and symbolic execution techniques. More specifically, this paper makes the following contributions.</p><p>First, we propose a novel approach to infer whether/where a program checks the integrity of input instances and can perform checksum-aware fuzzing. The high level intuition of the approach is illustrated in <ref type="figure" target="#fig_0">Figure 1</ref>. Checksum-based integrity checks behave like a classifier: while all wellformed inputs pass the integrity checks, most malformed inputs fail to pass because of integrity violations. Thus, we assume that there are special branch predicates in the program, corresponding to integrity checks: when the program runs with well-formed inputs, these branch predicates are always True/False; however, when the program runs with malformed inputs, these branch predicates are always False/True. By profiling program traces, TaintScope builds four predicate sets P 1 , P 0 , P ′ 1 and P ′ 0 , where P 1 /P 0 contain the always-true/always-false predicates when the program runs with well-formed inputs, and P ′ 1 /P ′ 0 contain the always-true/always-false predicates when the program runs with malformed inputs, respectively. The predicates in (P 1 ∩ P ′ 0 ) ∪ (P 0 ∩ P ′ 1 ) usually correspond to checksum checks. Unlike existing fuzzing systems, TaintScope can enforce the alteration of the target program's execution trace at located integrity check points, as if the generated test cases did not violate integrity checks. We call this checksum-aware fuzzing. Checksum-aware fuzzing can prevent generated test cases from being prematurely dropped, and this feature is helpful to trigger deep subtle errors in the rest of the program.</p><p>Second, TaintScope is a directed fuzzing tool with finegrained taint analysis at byte level. In contrast to traditional taint analysis with 0/1 taint labels <ref type="bibr" target="#b52">[57]</ref>, TaintScope marks each input byte with a unique label (i.e., the byte's position in an input instance), monitors how the target application accesses and uses the input data, and tracks the propagation of these labels throughout the execution of the program. Consequently, TaintScope is able to accurately identify which input bytes can flow into security-sensitive points (e.g., memory allocation function malloc(), string manipulation function strcpy()). Thus, given a well-formed input instance, TaintScope does not blindly modify the whole input, but focuses on modifying the set of bytes that could affect the values used in security-sensitive points (e.g., system/library calls). Directed fuzzing has three advantages: 1) it dramatically reduces the cardinality of the mutation space because we specially focus on modifying a small part of the original input instance; 2) minor modification conducted by directed fuzzing usually does not break the syntactic structure in the original input instance; 3) the malformed inputs generated by directed fuzzing are more likely to expose security vulnerabilities. Our directed fuzzing idea is motivated by BuzzFuzz <ref type="bibr" target="#b34">[40]</ref>. However, quite different from BuzzFuzz that requires access to an application's source code, TaintScope can directly work on both Linux and Windows binary executables.</p><p>Third, TaintScope is fully automatic, from detecting checksum, directed fuzzing, to repairing crashed samples. TaintScope can fix checksum fields in generated test cases using combined concrete and symbolic execution techniques. Instead of treating all input bytes as symbolic values, TaintScope only substitutes the checksum fields in test cases with symbolic values (i.e., leave the majority input bytes as concrete values), and collects trace constraints on checksum fields. Original complex trace constraints are simplified to simple constraints. By solving such simple constraints, TaintScope can repair generated test cases.</p><p>Finally, we evaluate TaintScope on a number of large real-world applications. Experimental results show that TaintScope can accurately locate the checksum checks in programs and dramatically improve the effectiveness of fuzz testing. TaintScope has already found 27 previously unknown vulnerabilities in several widely used applications, including Adobe Acrobat, Google Picasa, and ImageMagick. We have reported our finding and contacted corresponding vendors. Most of these vulnerabilities have been confirmed by <ref type="bibr">Secunia and oCERT, and assigned CVE identifiers (such as CVE-2009</ref><ref type="bibr">-1882</ref><ref type="bibr">, CVE-2009</ref><ref type="bibr">-2688</ref>). Corresponding patches from vendors are released or in preparation based on our reports.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. OVERVIEW</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Problem Scope and Terminologies</head><p>Checksums <ref type="bibr" target="#b0">[2]</ref> are a common way to check the integrity of data and are widely used in network protocols (e.g., TCP/IP) and many file formats (e.g., ZLIB <ref type="bibr" target="#b29">[35]</ref>, PNG <ref type="bibr" target="#b17">[23]</ref>). There are many sophisticated checksum algorithms used in practice, such as Adler-32, CRC (cyclic redundancy checks) series, and MD5. In this paper, we focus on checksums that are designed to protect against mainly accidental errors that may have been introduced during transmission or storage, instead of those designed to protect against intentional data alteration such as keyed cryptographic hash algorithms. We leave the later as our future work.</p><p>In general, the basic pattern to check the integrity of an input instance is to recompute a new checksum of the input instance and compare it with the checksum attached in the input instance. A mismatch indicates a corrupted input instance. For easy of representation, we use C r and D to represent raw data in the checksum field and other input data that are protected by the checksum field in an input instance, respectively.</p><p>Without loss of generality, we assume that the checksum check condition is equivalent to the condition P :</p><formula xml:id="formula_0">Checksum(D) == T (C r ),</formula><p>where Checksum() denotes the complete process of checksum algorithms and T () denotes the transformation function that is used to transform C r before integrity checks. For instance, the attached checksums are stored as octal numbers in the Tar format <ref type="bibr" target="#b13">[19]</ref>, or stored as hexadecimal numbers in the Intel HEX format <ref type="bibr" target="#b4">[7]</ref>. These raw data C r need to be converted into proper forms before being used in integrity checks. T () is used to describe the transformation process.</p><p>We assume that there are special branch predicates in the program, corresponding to integrity checks P . The predicate P is always true/false when inputting well-formed instances, whereas the predicate is always false/true when inputting malformed instances. One of our goals is to accurately locate potential integrity check points in a binary program rather than identify the checksum algorithm themselves.</p><p>Furthermore, TaintScope specially focuses on modifying the input bytes that can affect the arguments of important API functions, such as memory management functions, string manipulation functions. In this paper, we refer to such input bytes as "hot bytes". Our another goal is to automatically identify hot bytes in a well-formed input.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Motivating Example and System Overview</head><p>As a motivating example, <ref type="figure">Figure 2</ref> shows an example input format. This example input format presents a common image format: MagicNum field declares the file format; FileSize field indicates the real size of an input image; Width and Height fields mean the width and the height of an input image. In this format, image data are stored in  row-major order. Note that the format ends with a checksum field. A four-byte checksum is calculated on the preceding image content in the file for integrity protection. <ref type="figure" target="#fig_2">Figure 3</ref> shows an example code that parses inputs from the example format. The code first recomputes a checksum of an input file (line 4), reads the checksum stored in the file (line 5), and then compares the two values (line 6). If the two values mismatch, the code raises an error and exits immediately. Next, the code reads the Width and Height fields, then allocates memory of size "Width * Height * sizeof(int)". Finally, the code reads image data row by row into the allocated buffer. However, a specially crafted image containing large width and height values can cause an integer overflow in the above expression (line 10) and further lead to an insufficient memory allocation at line 11. A heap overflow will eventually occur when the code reads image data into memory, leading to a potential attack.</p><p>Traditional fuzzing methods such as randomly modifying a well-formed input file are unlikely to find such integer overflow vulnerability in <ref type="figure" target="#fig_2">Figure 3</ref>. Because a simple modification breaks the integrity of the original input, the failed integrity check at line 6 will cause most generated test cases to be rejected. Furthermore, even if there were no integrity check at line 6, traditional fuzzing methods would also be too inefficient. In this example, only eight bytes (Width and Height fields) in an input file are key factors to trigger the integer overflow vulnerability; however, blind modifications need to explore the whole input space. The probability of exactly modifying Width and Height fields is very low. In contrast, TaintScope leverages taint propagation information during program execution to detect checksum checks and generate test cases, which makes triggering vulnerabilities more likely. At a high level, TaintScope has four phases: dynamic taint tracing, detecting checksum check points, directed fuzzing, and repairing crashed samples, as shown in <ref type="figure" target="#fig_3">Figure 4</ref>. We use the program in <ref type="figure" target="#fig_2">Figure 3</ref> to illustrate the basic workflow of TaintScope. Note that TaintScope neither depends on the source code nor on the input format specification.</p><p>Dynamic Taint Tracing. Given a binary program P to test, TaintScope first runs P with a well-formed input I. TaintScope uses an execution monitor to dynamically instrument the program P and monitor how the program P processes the input data I. In particular, the execution monitor records the following information: 1) which input bytes pollute the arguments of specified API functions; and 2) which input bytes each conditional jump instruction (e.g., JZ, JE, JB) depends on. The former is hot bytes information and the latter is checksum information. In addition to the arguments of specified API functions, the execution monitor can also be configured to monitor which input bytes can influence the execution context of any program point.</p><p>In this example, assume that the size of the input file I is 1024 bytes and analysts are interested in the size argument of memory allocation function malloc, the hot bytes report will include entries like this: 0x8048d5b: invoking malloc: [0x8,0xf] which means the instruction at 0x8048d5b calls function malloc and the size argument depends on input bytes in the range from 0x8 to 0xf. Similarly, assume that branch statement line 6 in <ref type="figure" target="#fig_2">Figure 3</ref> is compiled into a JZ instruction at address 0x8048d4f, the checksum information report will include entries like this: 0x8048d4f: JZ: 1024: [0x0, 0x3ff] which means the conditional jump instruction JZ at 0x8048d4f depends on 1024 input bytes in the range from 0x0 to 0x3ff.</p><p>Detecting Checksum Check Points. In this phase, TaintScope uses a checksum detector to locate potential checksum check points in the program P. We present the details of checksum detector in Section III-C. In this example, the checksum detector identifies the conditional jump instruction JZ at 0x8048d4f as an integrity check. Meanwhile, the checksum detector generates a bypass rule, "0x8048d5b: JZ: always-taken", which means the branch instruction JZ at 0x8048d5b needs to be always taken. Similar to Tupni <ref type="bibr" target="#b28">[34]</ref>, TaintScope can also identify checksum fields in each input instance. Directed Fuzzing. In the third phase, a fuzzer module is responsible for generating malformed test cases and feeding them back to the target program. If the checksum detector does not generate bypass rules, the fuzzer directly feeds malformed test cases to the original program; otherwise, the fuzzer feeds malformed test cases to an instrumented program; according to the bypass rules in Bypass Info, the fuzzer alters the execution traces at checksum check points. In particular, all malformed test cases are constructed based on the hot bytes information. The output of this phase is the test cases that could cause the program to crash or consume 100% CPU.</p><p>In this example, the hot byte information directs the fuzzer to modify input bytes in the range from 0x8 to 0xf. Before executing the conditional jump instruction JZ at 0x8048d4f, the fuzzer sets the condition code flag ZF in the eflags register to an opposite Boolean value. Thus, all generated test cases also pass the checksum check and are more likely to trigger the integer overflow vulnerability in the program.</p><p>Repairing Crashed Samples. For the test cases that cause the instrumented program to crash, TaintScope needs to fix checksum fields in the test cases. Note we do not apply checksum fixing in the previous phase for every fuzzing test case because the fixing is relatively expensive (timeconsuming). It makes more sense to perform a delayed repair on only a small number of malformed test cases that actually cause the program to crash/hang. Given a malformed test case, TaintScope only treats the checksum value bytes as symbolic values (i.e., leave the majority input bytes as concrete values) and collects trace constraints. After the execution of checksum check point, TaintScope tries to generate a new test case that can execute a different branch. In this case, let the original complex trace condition be Checksum(D) == T (C r ). If both the raw data in checksum fields C r and other data D are symbolic values, for complex checksum algorithms such as MD5, this constraint cannot be solved. However, in our scenario, only C r corresponds to symbolic values and Checksum(D) is a runtime determinable constant value. Thus, the complex constraint can be simplified to a simple one, which can be solved with current solvers such as STP <ref type="bibr" target="#b33">[39]</ref>. Finally, if the new test case can still cause the original program to crash, a potential vulnerability is detected. Note that this phase can be ignored if the fuzzer directly tests the original program (in the previous phase).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. SYSTEM DESIGN AND IMPLEMENTATION</head><p>In this section, we describe the detailed design and implementation of TaintScope. First, we introduce our fine-grained dynamic taint tracing technique in Section III-A. Next, we present the approaches to identify hot bytes and checksum check points in Section III-B and Section III-C, respectively. Then, we discuss our checksum-aware directed fuzzing technique in Section III-D. We introduce the combined concrete and symbolic execution technique for repairing crashed samples in Section III-E. Finally, we introduce the implementation of TaintScope system in Section III-F.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Fine-grained Dynamic Taint Tracing</head><p>The execution monitor module implements a fine-grained dynamic taint analysis at byte level. Traditional taint analysis systems such as <ref type="bibr" target="#b52">[57]</ref> [61] specially focus on the propagation of all untrusted data and thus mark all input data with a single taint label. In contrast, the execution monitor assigns each input byte a unique label and tracks the propagation of these labels throughout the execution of the program. The execution monitor is built on top of PIN <ref type="bibr" target="#b43">[49]</ref>, a tool for the dynamic instrumentation of programs. The execution monitor supports both Linux and Windows binary executables.</p><p>Taint Source. Analysts can specify a filename or an IP address as a taint source. All data read from the file or received from the IP address are marked. To do this, the execution monitor makes the use of PIN_AddSyscallEntryFunction and PIN_AddSyscallExitFunction PIN APIs to intercept relevant system calls. For example, for file tainting on Linux systems, the execution monitor intercepts system calls such as open, mmap, read, lseek, and close. When the specified file is successfully opened, the execution monitor records the returned file descriptor fd. Each time when the system reads from file descriptor fd, the execution monitor scans the input buffer, and assigns each byte in the input buffer with its offset in the file. According to the return value of read and lseek, the execution monitor updates the file offset. In addition, when the file descriptor fd is closed with close, the execution monitor does not track it again.</p><p>Taint Propagation. Typically, there are two kinds of dependence relationships to consider: data-flow and controlflow dependencies. For data-flow dependencies, the execution monitor instruments data movement instructions (e.g., MOV, PUSH), arithmetic instructions (e.g., SUB, ADD), and logic instructions (e.g., AND, XOR). The execution monitor taints all values written by an instruction with the union of all taint labels associated with values used by that instruction. Note that the eflags register is also considered. For example, assume that the taint labels associated with eax and ebx are {0x6, 0x7} and {0x8, 0x9}, respectively, after the execution of instruction "ADD eax, ebx", the taint labels on eax would be {0x6, 0x7, 0x8, 0x9}; since instruction ADD also affects the eflags register, the taint labels on the eflags are updated to {0x6, 0x7, 0x8, 0x9}. For another example, assume the taint label associated with ecx is {0x100} and 0x8000000 is the base address of an untainted array, after the execution of this instruction "MOV eax, [0x8000000+ecx * 4]", the eax would be associated with {0x100}. Our current execution monitor does not consider control-flow dependencies. We leave that as our future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Identification of Hot Bytes</head><p>Hot bytes refer to the input bytes that affect the values used in security-sensitive operations. Based on the finegrained dynamic taint analysis described in Section III-A, the execution monitor can further identify hot bytes in a well-formed input. By default, the execution monitor checks which input bytes can pollute the arguments of memory allocation functions (e.g., malloc, realloc) and string functions (e.g., strcpy, strcat). Analysts can configure the execution monitor to check other functions, too.</p><p>The execution monitor utilizes PIN's routine instrumentation capability to hook target functions. Before target functions are executed, the execution monitor checks whether their arguments are tainted. The taint marks associated with the arguments clearly reveal which input bytes can affect such arguments. The execution monitor logs such hot bytes information to direct malformed input generation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Locating Checksum Check Points and Checksum Fields</head><p>Checksums, a simple error-detection scheme, are a main challenge that traditional fuzzing tools cannot overcome. In general, the integrity of input data can be checked by recomputing a new checksum and comparing it with the checksum value stored in the data. Any modification to the bytes protected by a checksum would break the integrity of the original input. Thus, there must be a special branch point (e.g., a conditional jump instruction such as JZ, JE) in the program, where all well-formed inputs follow the same branch whereas malformed inputs follow the other one. Our goal is to locate such conditional jump instructions. To do this, TaintScope works as follows:</p><p>Identifying Potential Checksum Check Points. Since a checksum is usually used to protect a considerable number of contiguous bytes, the recomputed checksum value depends on many input bytes. Consequently, the result of the checksum comparison also depends on many input bytes. For instance, the variable recomputed_cksum at line 4 in <ref type="figure" target="#fig_2">Figure 3</ref> depends on all bytes in an input image, and thus the result of the comparison at line 6 also depends on the whole input file.</p><p>According to this feature, the execution monitor first identifies some potential checksum check points in the target program. The execution monitor instruments all conditional jump instructions in the target program. Before the execution of each conditional jump instruction, the execution monitor checks whether the number of marks associated with the eflags register exceeds a predefined threshold value. If so, the conditional jump instruction is considered to be a potential checksum check point. The execution monitor records the relevant information of the instruction in the file Checksum Info.</p><p>This step may identify many candidates, especially when input data are also compressed or encrypted. A decompressed or decrypted byte usually depends on the whole input. However, programs usually first check the integrity of inputs. We have found empirically that the first candidate is most often the real checksum check point.</p><p>Refinement Procedure. In this step, the checksum detector is used to reduce the number of candidate points. Let A be the set of conditional jump instructions recorded in Checksum Info. The checksum detector instruments all instructions in A to capture their behavior, i.e., whether the conditional jumps are taken or not. These branch profile information can be used to accurately locate checksum check points.</p><p>First, the checksum detector runs the program with some well-formed inputs, and then collects and analyzes branch profile data. More specifically, conditional jump instructions that are always taken among all executions are added to set P 1 , whereas conditional jump instructions that are always not taken are added to set P 0 .</p><p>Next, the checksum detector runs the program with some malformed inputs. Note that malformed inputs are generated by modifying well-formed inputs. Similarly, the checksum detector builds another two sets P ′ 1 and P ′ 0 , where P ′ 1 and P ′ 0 contain the always-taken and always-not-taken conditional jump instructions among all executions, respectively. A special case is that an input sample contains multiple checksum fields and these checksums protect different parts of the input sample. For example, a PNG format image consists of many chunks and each chunk has a CRC checksum. Even if we modify the bytes in the last chunk, other chunks can still pass the checksum checks. In other words, the real checksum check point may not be included in P ′ 1 or P ′ 0 . To avoid this problem, the checksum detector can track the propagation of the modified bytes and only count the candidates that are affected by the modified bytes. Finally, the checksum detector computes the set (</p><formula xml:id="formula_1">P 1 ∩P ′ 0 ) ∪ (P 0 ∩P ′ 1 ). The conditional jump instructions in (P 1 ∩P ′ 0 ) ∪ (P 0 ∩ P ′ 1 )</formula><p>behave completely different when the target program runs with well-formed inputs and malformed inputs. The checksum detector outputs such instructions as checksum check points. Furthermore, the checksum detector generates bypass rules in the file Bypass Info. A bypass rule mainly consists of an instruction address, an instruction mnemonic and an action (i.e., always-taken or always-nottaken). These bypass rules are used in checksum-aware fuzzing.</p><p>Checksum Field Identification. TaintScope can also identify the checksum field in an input instance. Similar to Tupni <ref type="bibr" target="#b28">[34]</ref>, TaintScope first identifies the trace predicates that can affect the conditional jump instructions in (</p><formula xml:id="formula_2">P 1 ∩P ′ 0 ) ∪ (P 0 ∩ P ′ 1 )</formula><p>, and then locates the predicates of the form recomputed_chksum==attached_chksum, where recomputed_chksum is a value depending on a considerable number of input bytes and attached_chksum is a value only derived from a few input bytes. The input bytes that can affect attached_chksum are considered as the checksum field.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Directed and Checksum-aware Fuzzing</head><p>Directed Fuzzing. The fuzzer module implements the basic functions of a standard fuzzing tool, i.e., it generates malformed inputs, feeds them to the target program, and records the inputs that cause a crash or 100% CPU usage. However, unlike traditional fuzzing tools that blindly change parts of a well-formed input, our fuzzer specially focuses on modifying the hot bytes in a well-formed input. Specially, the fuzzer generates malformed test cases using attack heuristics. For example, hot bytes that can influence memory allocation functions are set to small, large or negative integer values; hot bytes that flow into string functions are replaced by malformed characters, such as %n, %p.</p><p>Directed fuzzing technique can dramatically reduce the size of mutation space because usually only a small portion of input data are hot bytes. Due to the similarity to wellformed inputs, generated test cases satisfy many primitive constraints and have a high probability to test code within the entire program. In addition, since extreme values in generated test cases may directly affect the arguments of system calls or other important APIs, such malformed test cases have a high probability to trigger potential vulnerabilities.</p><p>Checksum-aware Fuzzing. If the checksum detector has generated bypass rules, the fuzzer would send malformed inputs to an instrumented program. According to instruction address information in bypass rules, the fuzzer instruments the corresponding branch instructions. To force the conditional jump instructions always (not) taken, the condition code flags (e.g., OF, CF, ZF) in the eflags register are set to proper values before the execution of the branch instructions.</p><p>However, in practice, considering the overhead of instrumentation, analysts can directly locate the instructions in the raw binary file and modify the binary to ensure the conditional instructions always (not) taken, a classical technique used in software cracking. Then, the fuzzer module feeds malformed inputs to the modified program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Repairing Test Cases Using Combined Concrete and Symbolic Execution</head><p>TaintScope needs to fix checksum fields in the malformed test cases that cannot pass checksum checks in the original program but cause the instrumented program to crash.</p><p>Since correct checksum fields need to meet the trace constraint Checksum(D) == T (C r ), a direct idea is to collect the constraint by symbolic execution and solve the constraint. However, if all input are replaced by symbolic values, complex checksum algorithms such as MD5 will bring a great challenge to existing solvers to solve the trace constraint <ref type="bibr" target="#b58">[63]</ref>, <ref type="bibr" target="#b18">[24]</ref>.</p><p>To address this challenge, TaintScope only treats the checksum fields as symbolic values and leaves the majority input bytes as concrete values. Thus, the complex trace constraint Checksum(D) == T (C r ) is simplified to the simple one c == T (C r ), where c is a runtime determinable constant value. The simplified constraint does not depend on checksum algorithms any more. Common transformation functions T (), such as conversion from little-endian to bigendian, from hex/oct to decimal numbers, can usually be handled by current constraint solver like STP <ref type="bibr" target="#b33">[39]</ref>. Thus, TaintScope can solve the trace constraints and correctly update the checksum fields in malformed test cases.</p><p>Specifically, TaintScope first runs the original program with a malformed test case and records the execution trace. When the checksum fields are read into memory, TaintScope specifies these memory addresses in the trace file. Then, TaintScope offline symbolically evaluates the recorded trace, like SAGE <ref type="bibr" target="#b37">[43]</ref>.</p><p>When replaying the execution trace, TaintScope maintains a symbolic memory environment, which records a map from concrete addresses/registers to symbolic expressions, and a set of symbolic path conditions, which records the constraints on checksum bytes. The symbolic memory environment would be initialized when checksum fields are read into memory. Subsequently, TaintScope updates the symbolic memory environment and the path condition set according to the semantics of executed X86 instructions.</p><p>For the instructions whose all operands are concrete, TaintScope simply updates the execution context. Since only checksum fields are substituted with symbolic values, operands in most instructions are concrete. Moreover, treating checksum fields as symbolic values does not incur symbolic pointer (i.e., a pointer may refer to many objects) problems. That is why our symbolic memory environment only maps concrete memory addresses/registers (instead of symbolic addresses) to symbolic values.</p><p>In particular, TaintScope can handle global array reads that contain a symbolic index. TaintScope uses IDAPro <ref type="bibr">[6]</ref>, a disassembler, to identify global arrays and their size. Assume that IDAPro identifies 0x8000 is the absolute address of a global array <ref type="bibr" target="#b35">[41,</ref><ref type="bibr" target="#b36">42,</ref><ref type="bibr" target="#b37">43,</ref><ref type="bibr" target="#b38">44]</ref>; for the instruction "mov eax, <ref type="bibr">[0x8000+ecx * 4]</ref>" where ecx holds a symbolic value, TaintScope would mark eax as a symbolic value and generate a long condition:</p><formula xml:id="formula_3">((ecx=0)&amp;&amp;eax=41)||..||((ecx=3)&amp;&amp;eax=44).</formula><p>After the execution of the checksum check point (discussed in Section III-C), TaintScope negates the last path condition and solves the path conditions to generate a new test case that can pass checksum checks in the original program. Finally, if the new test case can cause the original program to crash, a potential vulnerability is detected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F. System Implementation</head><p>We have implemented a prototype of TaintScope fuzzing system. TaintScope consists of four modules, the execution monitor, the checksum detector, the fuzzer, and the replayer. The execution monitor, our dynamic taint analysis engine, is built on top of PIN <ref type="bibr" target="#b43">[49]</ref>. By intercepting low-level system calls, the execution monitor can identify taint sources. Furthermore, the execution monitor makes use of instruction instrumentation to track the propagation of taint data. By routine instrumentation, the execution monitor is able to check the context (e.g., arguments, registers) of specified APIs before the execution of such APIs. The checksum detector also utilizes PIN's instruction instrumentation to profile the behaviors of branch instructions.</p><p>Our fuzzer is a Python program that can mutate wellformed inputs based on hot bytes information and feed malformed test cases to target programs. In particular, the fuzzer leverages the similar attack heuristics used in SPIKE <ref type="bibr" target="#b12">[18]</ref>, i.e., hot bytes are set to extremal values and malformed strings used by SPIKE.</p><p>The replayer, our trace-based symbolic execution module, is responsible to record and replay execution traces, similar to PinSEL <ref type="bibr" target="#b49">[54]</ref>. The replayer also implements a script running in IDAPro <ref type="bibr">[6]</ref> to export statically-known global array information, and then symbolically re-executes the recorded execution trace. The replayer utilizes STP <ref type="bibr" target="#b33">[39]</ref> to build and solve path constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. EVALUATION</head><p>In this section, we present four sets of experiments. In Section IV-B, we evaluated the efficiency of the execution monitor. We sent well-formed images in several formats (e.g., PNG, JPEG, TIFF, BMP, and GIF) to three popular applications (e.g., ImageMagick, Google Picasa, and Adobe Acrobat) and measured the portion of hot bytes in well-formed inputs. In Section IV-C, we evaluated the effectiveness of our checksum detector. We tested eight applications, which employ different checksum algorithms, such as CRC32, MD5, and Alder32. We applied TaintScope to locate checksum check points in these programs. In Section IV-C, we evaluated the accuracy of checksum field identification and the capability of repairing checksum fields for given test cases. In Section IV-E, we show the vulnerabilities we detected in several widely used applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Experiment Setup</head><p>We apply TaintScope to a large number of real-world applications. An incomplete list of the applications is summarized in <ref type="table">Table I</ref>. The "OS" column in <ref type="table">Table I</ref> indicates the operating systems that the applications run on. The applications include popular image viewers (e.g., Google Picasa, ImageMagick), multimedia players (e.g., MPlayer, Winamp), web browsers (e.g., Amaya), widely used libraries (e.g., Libtiff), text editors (e.g., XEmacs), etc.</p><p>For applications on Windows platform, our experiments are conducted on a machine with Intel Core 2 Duo CPU at 3.0 GHz and 3.25GB memory, running Windows XP Professional SP3; for applications on Linux platform, our experiments are conducted on a machine with Intel Core 2 Duo CPU at 2.4 GHz and 4.0GB memory, running Fedora Core 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Hot Bytes Identification</head><p>In the first set of experiments, we evaluated the performance of the execution monitor and measured the portion of hot bytes in well-formed inputs. Specially, according to our previous research <ref type="bibr" target="#b60">[65]</ref>, we found that many integer overflow vulnerabilities are closely related to memory allocation functions. In this experiment, the execution monitor was configured to check the size arguments of memory allocation functions (e.g., malloc, realloc). In other words, input bytes that can flow into memory allocation functions are considered as hot bytes. <ref type="table">Table II</ref> shows the results of the evaluation on three widely used applications: ImageMagick, Google Picasa, and Adobe Acrobat. Particularly, ImageMagick and Google Picasa are two popular image viewers available on many platforms. In our experiments, we tested ImageMagick on Linux and Google Picasa on Windows. We also chose Adobe Acrobat because it can convert images to PDF files.</p><p>We input well-formed images (including PNG, TIF, JPEG, BMP, and GIF formats) to the three applications and applied the execution monitor to track the propagation of input data. Note that well-formed images were obtained either from the Internet (using Google Image Search) or our local disks.</p><p>The "Input Format" and "Input Size" columns in <ref type="table">Table  II</ref> represent the format and size of well-formed images, respectively. We counted the number of hot bytes in wellformed input data, as shown in the "Hot Bytes" column. The size of well-formed inputs is roughly in the range from 1,000 to 7,000 bytes, but the number of hot bytes is less than 50. The reason is that memory allocations during displaying an image usually depend on only a few fields in the image, such as the width, length and color depth fields. We also measured the trace length and performance overhead, as shown in the two rightmost columns. The performance overhead is acceptable. In most cases, instrumented programs took several minutes to display a well-formed image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Checksum Check Points Identification</head><p>Another key feature of TaintScope system is that the checksum detector module can automatically locate potential checksum check points in programs. In the second set of experiments, we evaluated the effectiveness of our checksum detector.</p><p>File formats and checksum algorithms. We chose six known file formats, as shown in the "File Format" column in  <ref type="bibr" target="#b40">[46]</ref> is a general, efficient and portable data format suitable for delta encoding. Open-vcdiff project <ref type="bibr" target="#b8">[13]</ref> extends the standard VCDIFF format and Adler32 checksum is used to detect accidental corruption of data.</p><p>• Tar archive format is widely used on Unix-like systems. A tar archive file is the concatenation of one or more files. Each file in a "tar" package is preceded by a 512-byte header record that contains a checksum value for the whole header.</p><p>• Intel HEX <ref type="bibr" target="#b4">[7]</ref> is a text format, with each line containing hexadecimal values encoding a sequence of data and a checksum value of the data.</p><p>Evaluation Methodology. We tested eight applications, as shown in the first and second columns in <ref type="table" target="#tab_1">Table III</ref>. These eight applications can process file formats mentioned above. We input well-formed and malformed inputs to target applications, respectively, and applied the execution monitor and checksum detector to locate potential checksum check points in target applications. Specifically,</p><p>• We input PNG images to two "closed source" image manipulation applications, Google Picasa and Adobe Acrobat, and applied TaintScope to locate potential CRC check points in the two applications.</p><p>• We input PCAP files to Tcpdump and Snort. The well-formed PCAP file used in our experiment was obtained by capturing network traffic from our local machine. We specified "-v tcp -r" options, which enable Tcpdump and Snort to read TCP packets from a saved PCAP file and perform packet integrity checks such as verifying the IP header and TCP checksums.</p><p>• With "--info" option, sigtool in ClamAV package can verify the integrity of a given CVD file and display detailed information about the file. The well-formed CVD file used in our experiment is daily.cvd in ClamAV package.</p><p>• For VCDIFF and Tar Archive formats, we tested two applications Open-vcdiff and GNU Tar, respectively. Well-formed inputs used in the two tests were created by the two applications themselves. For example, we first used GNU Tar to create a tar archive; then, we applied TaintScope to locate checksum checks when GNU Tar extracted files from the tar archive.</p><p>• For Intel HEX format, we tested GNU objcopy, which can copy the contents of an object file to another. In particular, GNU objcopy can translate an object file into another object file in a different format. We applied TaintScope to locate checksum checks when GNU objcopy translated an Intel HEX object file into other formats.</p><p>Experimental Results. Our checksum identification results are summarized in identify potential checksum checks. The column |A| presents the number of potential checksum checks identified by the execution monitor. Particularly, if a conditional jump instruction depends on more than 16 input bytes, it is considered as a potential checksum check, where the threshold 16 is chosen empirically. For PNG format, the execution monitor identifies a large number of candidates. The main reason is that image data in PNG format are compressed. A byte in decompressed data stream may depend on the entire compressed data. All checks on decompressed data were counted in set A.</p><p>In the second step, TaintScope ran the target program with malformed test cases and employed branch profiling techniques to refine the set A. Considering that programs usually check the integrity of inputs first before further processing them, we modified the bytes in well-formed test cases which can affect the first few candidates in the set A to generate malformed inputs.</p><p>The column |(P 1 ∩ P ′ 0 ) ∪ (P 0 ∩ P ′ 1 )| presents the number of final candidates. Manual inspection revealed these candidates were real checksum check points. For Adobe Acrobat, TaintScope accurately located the CRC check in a binary file named ImageConversion.api. Due to the integrity check failure, Adobe Acrobat refused to decompress image data in malformed PNG images and exited immediately. Thus, TaintScope did not locate the Alder32 checksum points. Considering that both Adobe Acrobat and Google Picasa are closed source applications, we cannot provide more detailed results.</p><p>Because we specified "-v tcp" options, when parsing a PCAP file, Tcpdump and Snort first verified the IP header checksum; for TCP packets, Tcpdump and Snort further verified TCP checksums. While an IP checksum was calculated only for IP header bytes, a TCP checksum was calculated based on the TCP packet. TaintScope accurately located the two checksum check points in Tcpdump and Snort. Similarly, TaintScope accurately identified the checksum checks in other applications.</p><p>The time cost of this phase depends on how many test cases we use. According to our experience, several wellformed test cases and slightly more than ten malformed test cases are enough to locate the checksum check points in target programs. Since processing a test case usually needs several minutes (shown in <ref type="table">Table II</ref>), this phase can typically be done in tens of minutes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Checksum Fields Identification and Repair</head><p>We further evaluated the accuracy of checksum field identification and the capability of repairing checksum fields for malformed test cases. We tested four applications and file formats. The results are shown in <ref type="table" target="#tab_4">Table IV</ref>.</p><p>The third column in <ref type="table" target="#tab_4">Table IV</ref> means the number of checksum fields identified by TaintScope in an input instance; the fourth column means the size (in bytes) of each checksum field identified by TaintScope. For example, TaintScope identified four 4-byte checksum fields in a PNG image. We used 010editor <ref type="bibr">[16]</ref>, a hex editor with binary templates, to parse the PNG image for verification. The output of 010editor reveals that there are four chunks (e.g., IHDR, PLTE, IDAT, and IEND) in the PNG image and each chunk has a 4-byte CRC checksum field.</p><p>TaintScope identified eight 2-byte checksum fields in the well-formed PCAP file. For verification, we used Wireshark <ref type="bibr" target="#b15">[21]</ref> to parse the PCAP file: there are four TCP packets, and each TCP packet has an IP checksum field and a TCP checksum field.</p><p>We also manually compared other outputs of TaintScope with published format specializations. Manual inspection revealed that TaintScope accurately identified the number and the size of checksum fields in each well-formed instance.</p><p>The fifth column in <ref type="table" target="#tab_4">Table IV</ref> indicates that TaintScope can automatically generate valid checksum fields for given test cases. The experiments proceed as follows. First, we deliberately altered the bytes in checksum fields in such well-formed inputs to generate malformed ones. 1 Next, we input these malformed inputs to corresponding applications, and used TaintScope to record and replay the execution traces. TaintScope treated the bytes in checksum fields as symbolic values. After symbolically re-executing the traces, TaintScope generated new test cases. In our experiments, these new generated test cases were identical with those original well-formed ones, i.e., TaintScope generated correct checksum fields.</p><p>The sixth column in <ref type="table" target="#tab_4">Table IV</ref> shows the time (in seconds) TaintScope took to replay recorded traces and solve path constraints. In our experiments, fixing a given test case needs a few minutes, a time-consuming phase.</p><p>In short, TaintScope can accurately identify checksum fields and automatically generate valid checksum fields for given test cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Executable</head><p>File  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Fuzzing Results</head><p>As a fuzzing system, TaintScope has already detected 27 severe vulnerabilities in widely used applications and libraries, such as Microsoft Paint, Adobe Acrobat, Google Picasa, ImageMagick, and Libtiff. Table V summarizes the experimental results. The "#Vulns" column shows the number of vulnerabilities in corresponding applications and the "Checksum-aware" column indicates whether the vulnerabilities are detected by checksum-aware fuzzing or not.</p><p>We manually analyzed the causes of most vulnerabilities and identified five vulnerability types, including buffer overflow, integer overflow, double free, null pointer dereference, and infinite loop. According to our vulnerability reports, Secunia <ref type="bibr" target="#b11">[17]</ref> and oCERT <ref type="bibr" target="#b7">[12]</ref> have confirmed and published security advisories for most of these vulnerabilities and vendors have also released corresponding patches. The "Advisory" column shows the advisory identifier information. CVE-xxxxs represent CVE (Common Vulnerabilities and Exposures) identifiers and SAxxxxs are security advisories from Secunia.</p><p>The rightmost column shows the Secunia's severity rating for the vulnerabilities. "High" is typically used for remotely exploitable vulnerabilities and "Moderate" is typically used for vulnerabilities that require user interaction. Considering that some vulnerabilities are still in the process of being fixed and/or may be easily exploitable, we do not provide detailed information about these vulnerabilities at this time.</p><p>Adobe Acrobat can create PDF files from images. TaintScope constructed images (in two different formats) which can cause Adobe Acrobat to crash or consume 100% CPU. According to our report and the crashing test case, Secunia has confirmed the memory corruption vulnerability and contacted the vendor. The vendor asked Secunia to postpone the publication of the advisory until a fix is available. We have also confirmed the infinite loop in a binary file named ImageConversion.api and already sent the PoC image to Adobe PSIRT (Adobe Product Security Incident Response Team). Adobe has published a security bulletin for the two vulnerabilities and released patches <ref type="bibr">[1]</ref>.</p><p>Microsoft Paint has been included in all versions of Microsoft Windows. TaintScope discovered an integer overflow in gdiplus.dll which causes an erroneous memory allocation in Paint program when Paint opened a malformed JPEG image. Successful exploitation may allow execution of arbitrary code. Microsoft has published a security bulletin MS10-005 <ref type="bibr">[9]</ref> according to our report.</p><p>TaintScope also discovered an integer overflow and an infinite loop in Google Picasa. We first sent the infinite loop information to Google Security Team, however, after the initial contact, we have not heard back from the Google for months. Recently, we found the infinite loop issue has been fixed in its new version. The integer overflow occurs in PicasaPhotoViewer.exe when processing JPEG files, which finally causes a heap buffer overflow. Many vulnerabilities in <ref type="table" target="#tab_6">Table V</ref> were detected by our checksum-aware fuzzing techniques, i.e., TaintScope identified and bypassed checksum checks in binary programs, performed directed fuzzing on the instrumented program, and fixed the checksum fields in malformed test cases that caused instrumented programs to crash.</p><p>As an example, we present the double free vulnerability <ref type="bibr" target="#b16">[22]</ref>   image data row by row. <ref type="figure">Figure 5</ref> shows the source code snippet of the function. Note that lines[n] may be freed twice at lines 580 and 633 if the function malloc at line 577 returns a NULL pointer.</p><p>In our experiments, TaintScope accurately located the CRC checksum check points in wxWidgets and the checksum fields in PNG images. Meanwhile, TaintScope identified the hot bytes in well-formed PNG images which can affect the variable "width" used in line 577. In fact, the variable "width" corresponds to the width field in a PNG image.</p><p>At the fuzzing phase, TaintScope modified the hot bytes to some extremal values and altered the execution flows at the checksum check points. Several malformed test cases triggered the double free vulnerability in the function wxPNGHandler::LoadFile().</p><p>At the phase of repairing test cases, TaintScope first recorded the execution trace with a malformed PNG image, and re-executed the trace using symbolic execution. By solving the trace constraints, TaintScope successfully generated a valid checksum value for the malformed PNG image. The new PNG image can pass initial checksum checks in wxWidgets and trigger the double-free vulnerability.</p><p>Since the width field in a PNG image is protected by checksum values, we believe the vulnerability cannot be detected by random modification.</p><p>For more details on the published vulnerabilities in <ref type="table" target="#tab_6">Table  V</ref>, we refer the readers to Secunia <ref type="bibr" target="#b11">[17]</ref>. For instance, Secunia has developed exploits and PoC code for the vulnerabilities in Gstreamer <ref type="bibr" target="#b3">[5]</ref> and Winamp <ref type="bibr" target="#b14">[20]</ref> (only available for certain types of vendors and governments).</p><p>In summary, our experiments show that:</p><p>• Only a small portion of input data are hot bytes. Thus, directed fuzzing can dramatically reduce the mutation space.</p><p>• TaintScope can accurately locate the checksum check points in programs and the checksum fields in input instances.</p><p>• TaintScope can automatically generate valid checksum fields for malformed test cases.</p><p>• By checksum-aware directed fuzzing, TaintScope has successfully detected a number of serious real-world vulnerabilities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. DISCUSSION</head><p>In this section, we discuss the limitations in the current implementation of TaintScope system. First, TaintScope currently cannot deal with secure integrity check schemes, such as keyed cryptographic hash algorithms or digital signature, which are designed to protect against intentional data alteration. Although TaintScope can locate and bypass such checks at the checksum-aware fuzzing phase, it is impossible for TaintScope system to automatically generate test cases with valid digital signatures. From software testing point of view, some vulnerabilities could be hidden behind such complex application defenses (e.g., digital signatures). We suggest the software developers disable such defense mechanisms at testing phase. We leave the full study of this problem as our future work.</p><p>Second, the effectiveness of TaintScope system may be limited when all input data are encrypted. After data decryption, the complex data dependency relationships will heavily influence hot bytes detection and checksum identification. A mitigation strategy is to configure TaintScope to track the decrypted data only. Recent research such as ReFormat <ref type="bibr" target="#b61">[66]</ref> and Dispatcher <ref type="bibr" target="#b19">[25]</ref> already shows some promising results to locate encryption/decryption routines. Such techniques could be combined with TaintScope to detect the vulnerabilities when the target program processes the decrypted data.</p><p>Third, to infer whether/where a program performs checksum checks, TaintScope relies on both well-formed inputs and malformed inputs. The quality of these inputs also affects the results of checksum check point identifications. In general, target programs (or other third-party programs) are able to produce well-formed samples. Hence, TaintScope obtains malformed inputs by modifying such well-formed samples. Considering that programs usually check the integrity of inputs first before further processing them, TaintScope first identifies some potential checksum check points (see Section III-C), and then modifies the bytes in well-formed samples which can affect these potential checksum check points.</p><p>Due to the complexity of the x86 instruction set, the current execution monitor in TaintScope system does not instrument all kinds of x86 instructions. Floating-point instructions and some infrequently used x86 instructions such as movdqa are not hooked. In addition, the execution monitor also ignores the control flow dependencies. However, previous study <ref type="bibr" target="#b24">[30]</ref> reveals that tracking control flow dependencies may make too many noises. Extending TaintScope to track control flow propagation (similar to <ref type="bibr" target="#b31">[37]</ref> and DYTAN <ref type="bibr" target="#b23">[29]</ref>) and improving data flow propagation are parts of our future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. RELATED WORK</head><p>Traditional Fuzzing. Fuzzing was first proposed by <ref type="bibr">Miller et al. [51]</ref>. The simple tool in <ref type="bibr" target="#b46">[51]</ref> just generated streams of random characters and sent them to target programs, but it was able to crash 25-33% of the utility programs on UNIX system. Since then, a wide range of fuzzing tools have been developed. <ref type="bibr">Sutton et al. [64]</ref> presented a recent overview of fuzzing techniques and tools. Traditionally, there are two main ways to get malformed inputs: data generation and data mutation <ref type="bibr" target="#b53">[58]</ref>. The former (e.g., Spike <ref type="bibr" target="#b12">[18]</ref>, Peach <ref type="bibr" target="#b10">[15]</ref>, SNOOZE <ref type="bibr" target="#b32">[38]</ref>) generates malformed inputs based on predefined specifications and the later (e.g., FileFuzz <ref type="bibr" target="#b2">[4]</ref>) mutates well-formed inputs. However, the common drawback of traditional fuzzing techniques is that most malformed inputs are prematurely dropped. To improve the effectiveness of fuzzing tools, the following two categories of new techniques are proposed.</p><p>Symbolic-execution-based white-box fuzzing. This technique has been widely implemented in numerous tools, such as CUTE <ref type="bibr" target="#b57">[62]</ref>, DART <ref type="bibr" target="#b36">[42]</ref>, SAGE <ref type="bibr" target="#b37">[43]</ref>, SmartFuzz <ref type="bibr" target="#b47">[52]</ref>, EXE <ref type="bibr" target="#b22">[28]</ref>, and KLEE <ref type="bibr" target="#b21">[27]</ref>. In general, based on code instrumentation or program tracing, these tools replace concrete input data with symbolic values, collect and solve the constraints on execution traces and guide input error detection and generation. When testing applications with highly-structured inputs, such as compilers and interpreters, <ref type="bibr">Godefroid et al. [41]</ref> and <ref type="bibr">Majumdar et al. [50]</ref> proposed a variation technique which employs input symbolic grammar specifications. These tools have proven to highly improve the effectiveness of traditional fuzzing tools. They successfully detected serious bugs in GNU coreutils <ref type="bibr" target="#b21">[27]</ref>, large shipped Windows applications <ref type="bibr" target="#b37">[43]</ref>, <ref type="bibr" target="#b35">[41]</ref>, and Linux file systems <ref type="bibr" target="#b22">[28]</ref>.</p><p>With zero knowledge of the checksum algorithm, automatically generating test cases with correct checksum fields is a great challenge. For simple checksum algorithms such as integer addition, existing symbolic execution systems such as Replayer <ref type="bibr" target="#b51">[56]</ref> are able to automatically generate correct checksums. However, as shown in <ref type="bibr" target="#b51">[56]</ref>, the checksum computation significantly increases the complexity of the collected symbolic formula. Furthermore, previous studies <ref type="bibr" target="#b58">[63]</ref> [24] have revealed that current symbolic execution engines and constraint solvers cannot accurately generate and solve the constraints that describe the complete process of complex checksum algorithms. Newsome et al. <ref type="bibr" target="#b51">[56]</ref> also proposed a reasonable scheme to deal with complex checksum algorithms, i.e., iteratively constraining some of the input variables to have the concrete values and then simplifying and solving the trace constraints. Instead, TaintScope directly leaves all bytes concrete except those in the checksum fields, which significantly reduces the complexity of the trace constraints.</p><p>Taint-analysis-based directed fuzzing. The closest work to ours is BuzzFuzz <ref type="bibr" target="#b34">[40]</ref>. BuzzFuzz is a directed dynamic taint-based white-box fuzzing tool. To track taint information, BuzzFuzz needs to instrument an application's source code. The instrumented application is responsible for identifying input data that can influence the values at system calls. However, modern applications make extensive use of third-party libraries. BuzzFuzz cannot instrument such libraries if source code is unavailable, leading to the loss of taint information. In contrast, TaintScope directly works on binary executables and can monitor the execution of all libraries. In addition, TaintScope can bypass checksum checks in programs.</p><p>Flayer <ref type="bibr" target="#b30">[36]</ref> is a taint tracing tool with the ability to redirect the execution flows through the modification of conditional jump instructions. Flayer is based upon functionality from Memcheck <ref type="bibr" target="#b50">[55]</ref> and marks input data only with 0/1 label. Thus, Flayer cannot accurately track the impact of input data on an application's execution. Execution flow alteration is also used in analyzing malware behavior, e.g., exploring multiple execution paths <ref type="bibr" target="#b48">[53]</ref>, and forcing sampled execution to identify various kernel rootkit behaviors <ref type="bibr" target="#b62">[67]</ref>.</p><p>Corpus Distillation <ref type="bibr" target="#b54">[59]</ref> is a feedback-driven fuzzing system that uses a code coverage heuristic to select and mutate input samples. In particular, to overcome checksum problems, Corpus Distillation designed the sub-instruction profiling method, i.e., comparison instructions (such as immediate comparison and rep cmps) are broken into bitsized chunks and the coverage score of these instructions depends on the "depth" of comparison. Based on the subinstruction profiling, Corpus Distillation is able to generate correct CRC checksums in PNG files without the requirement of constraint solving. However, due to the lack of finegrained taint tracking and checksum field identification, to pass the checksum checks, Corpus Distillation has to mutate all bits in an input sample until reaches checksum fields, which may heavily limit its efficiency.</p><p>Moreover, Corpus Distillation and TaintScope can benefit from each other. While TaintScope's checksum check points locating and bypassing techniques can be used in Corpus Distillation to improve the sub-instruction profiling method, the code-coverage-based input sample selection and mutation technique in Corpus Distillation can also be used in the fuzzing phase of TaintScope system.</p><p>Many protocol reverser engineering tools (such as Prospex <ref type="bibr" target="#b25">[31]</ref>, Tupin <ref type="bibr" target="#b28">[34]</ref>, AutoFormat <ref type="bibr" target="#b41">[47]</ref>, Polyglot <ref type="bibr" target="#b20">[26]</ref>, Discoverer <ref type="bibr" target="#b27">[33]</ref>, FFE/x86 <ref type="bibr" target="#b38">[44]</ref>) can be used to guide fuzzing tests. These tools can extract format specifications for input data by analyzing network traffic <ref type="bibr" target="#b27">[33]</ref>, monitoring the execution of a program while it processes input data <ref type="bibr" target="#b41">[47]</ref>, <ref type="bibr" target="#b42">[48]</ref>, <ref type="bibr" target="#b28">[34]</ref>, <ref type="bibr" target="#b20">[26]</ref>, <ref type="bibr" target="#b63">[68]</ref>, or analyzing binary executables directly <ref type="bibr" target="#b38">[44]</ref>. The extracted protocol specifications can be further translated into fuzzing specifications. However, none of these systems explicitly discussed how to bypass checksum checks.</p><p>In addition, <ref type="bibr">Kang et al. [45]</ref> proposed a trace matching algorithm to locate the divergence point between two similar traces. This algorithm could also potentially be applied to locate checksum check points in programs.</p><p>Finally, there are a significant amount of vulnerability detection studies based on static analysis, instead of dynamic fuzzing. We refer the readers to <ref type="bibr">[8]</ref> for further references. In particular, <ref type="bibr" target="#b60">[65]</ref> and <ref type="bibr" target="#b26">[32]</ref> are two binary analysis tools which can identify integer overflow vulnerabilities or insecure uses of sensitive C library calls in binary executables. While TaintScope is mainly a dynamic fuzzing tool, it could also benefit from the advances in this line of work. For example, TaintScope uses similar heuristics in <ref type="bibr" target="#b60">[65]</ref> to specially monitor the size arguments of memory allocation functions and has discovered many integer overflow bugs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSIONS</head><p>In this paper, we present TaintScope, a checksum-aware directed fuzzing system. Based on fine-grained dynamic taint tracking and branch profiling, TaintScope can monitor the impact of input data on an application's execution, identify the input data that can affect the context of security-sensitive operations, and locate checksum-based integrity checks in programs. TaintScope can dramatically reduce the mutation space and bypass checksum checks by execution flow alteration. Furthermore, TaintScope can automatically fix the checksum fields in malformed test cases using combined concrete and symbolic execution techniques.</p><p>We applied TaintScope to a number of large real-world applications. Experimental results show that TaintScope can accurately locate the checksum checks in programs and dramatically improve the effectiveness of fuzz testing. TaintScope has already identified 27 previously unknown vulnerabilities in several widely used applications, including Microsoft Paint, Adobe Acrobat, Google Picasa, and ImageMagick. Most of these vulnerabilities have been confirmed by Secunia and oCERT, and have been assigned CVE identifiers <ref type="bibr">(such as CVE-2009</ref><ref type="bibr">-1882</ref><ref type="bibr">, CVE- 2009</ref><ref type="bibr">-2688</ref><ref type="bibr">, CVE-2009</ref><ref type="bibr">-2347</ref><ref type="bibr">, and CVE-2009</ref><ref type="bibr">-2369</ref>. Corresponding patches from vendors are released or in progress based on our reports.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. The intuition of locating checksum check points</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Figure 2. Example input format</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Example Code</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. TaintScope System Overview</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Figure 5. A double free vulnerability in wxPNGHandler::LoadFile() in wxWidgets 2.8.10</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table III . These six file formats employ different checksum algorithms to calculate checksum values. Specifically, • PNG, a popular image format with lossless compres</head><label>III</label><figDesc></figDesc><table>-
sion, supports two main types of integrity-checking. 
First, PNG images are divided into logical data 
chunks, and each chunk has an associated CRC 
stored with it. The integrity of an image can easily be 
tested without decoding the image. Second, compressed 
data streams within PNG are stored in the zlib format 
[35]. Zlib format stores an Adler-32 checksum value of 
uncompressed data. 
• PCAP [14], a widely used format for dumping network 
packet traces, is supported by many packet analyzers, 
such as Tcpdump, Snort, and Wireshark. Although a 
PCAP file itself does not contain checksum fields, when 
parsing a PCAP file, packet analyzers need to check the 
checksums in TCP/UDP packets in the PCAP file. 
• CVD [3] is an acronym for ClamAV Virus Database. A 
CVD file has a 512-bytes header structure, which stores 
an MD5 checksum value of the whole CVD file. When 
loading a CVD file, ClamAV first checks the integrity 
of the CVD file. 
• VCDIFF (Generic Differencing and Compression Data 
Format) </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table III .0 ) ∪ (P0 ∩ P ′ 1 ) | Detected?</head><label>III</label><figDesc>TaintScope needs two steps to infer whether/where a binary program performs the checksum checks. In the first step, TaintScope ran the target program with well-formed test cases and the execution monitor was used to</figDesc><table>Executable 

Package (Version) 
File Format Checksum Algorithm 
|A| 
|(P1 ∩ P ′ 
PicasaPhotoViewer Google Picasa (3.1) 
PNG 
CRC32 
830 
1 
√ 

Acrobat 
Adobe Acrobat (9.1.3) 
5,805 
1 
√ 

Snort 
snort (2.8.4.1) 
PCAP 
TCP/IP checksum 
2 
2 
√ 

tcpdump 
tcpdump (4.0.0) 
5 
2 
√ 

sigtool 
clamav (0.95.2) 
CVD 
MD5 
2 
1 
√ 

vcdiff 
open-vcdiff (0.6) 
VCDIFF 
Adler32 
1 
1 
√ 

Tar 
GNU Tar (1.22) 
Tar Archive 
Tar checksum 
9 
1 
√ 

objcopy 
GNU binutils (2.17) 
Intel HEX 
Intel HEX checksum 
62 
1 
√ 

Table III 
CHECKSUM IDENTIFICATION RESULTS 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table IV CHECKSUM FIELDS IDENTIFICATION AND FIX RESULTS</head><label>IV</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head></head><label></label><figDesc>in wxWidgets, a popular open source cross- platform GUI toolkit. The double free vulnerability can be exploited to potentially execute arbitrary code via a specially crafted PNG file. A basic functionality of wxWidgets is to load images in a variety of formats. Specifically, the "wxPNGHandler::LoadFile()" func- tion in wxWidgets is responsible for loading an image in the PNG format. This function first checks the CRC checksum values in a PNG image, and then processes the</figDesc><table>Package 

Vuln-Type 
# Vulns Checksum-aware? Advisory 
Severity Rating 
Microsoft Paint Memory Corruption 
1 
N 
CVE-2010-0028 Moderate 

Google Picasa 
Infinite loop 
1 
N 
pending 
N/A 
Integer Overflow 
1 
SA38435 
Moderate 

Adobe Acrobat 
Infinite loop 
1 
N 
CVE-2009-2995 Extremely critical 
Memory Corruption 
1 
N 
CVE-2009-2989 Extremely critical 
ImageMagick 
Integer Overflow 
1 
N 
CVE-2009-1882 Moderate 
CamlImage 
Integer Overflow 
3 
Y 
CVE-2009-2660 Moderate 
LibTIFF 
Integer Overflow 
2 
N 
CVE-2009-2347 Moderate 

wxWidgets 
Buffer Overflow 
2 
N 
CVE-2009-2369 Moderate 
Double Free 
1 
Y 
IrfanView 
Integer Overflow 
1 
N 
CVE-2009-2118 High 
GStreamer 
Integer Overflow 
1 
Y 
CVE-2009-1932 Moderate 
Dillo 
Integer Overflow 
1 
Y 
CVE-2009-2294 High 

XEmacs 
Integer Overflow 
3 
Y 
CVE-2009-2688 Moderate 
Null Dereference 
1 
N 
N/A 
N/A 
MPlayer 
Null Dereference 
2 
N 
N/A 
N/A 
PDFlib-lite 
Integer Overflow 
1 
Y 
SA35180 
Moderate 
Amaya 
Integer Overflow 
2 
Y 
SA34531 
High 
Winamp 
Buffer Overflow 
1 
N 
SA35126 
High 
Total 
27 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>Table V VULNERABILITIES DETECTED BY TAINTSCOPE</head><label>V</label><figDesc></figDesc><table></table></figure>

			<note place="foot" n="1"> Note here we modified checksum fields instead of regular data fields. The reason is that we want to show TaintScope can generate correct/valid checksums for which we have ground truth (the original ones).</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>We are grateful to the anonymous reviewers for their hard work, insightful comments and suggestions. This research was supported in part by the National Development and Reform Commission (NDRC) under Project "A monitoring platform for web safe browsing" and the Research Fund for the Doctoral Program of Higher Education of China under Grant <ref type="bibr">No. 200800011019.</ref> </p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Checksum: From Wikipedia encyclopedia</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">CVD: ClamAV Virus Database</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Filefuzz</forename><surname>Tool</surname></persName>
		</author>
		<ptr target="http://labs.idefense.com/software/fuzzing.php" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">GStreamer Good Plug-ins PNG Processing Integer Overflow Vulnerability</title>
		<ptr target="http://secunia.com/advisories/35205/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hex: From</forename><surname>Intel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wikipedia</surname></persName>
		</author>
		<ptr target="http://en.wikipedia.org/wiki/IntelHEX" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
		<ptr target="http://browserfun.blogspot.com" />
	</analytic>
	<monogr>
		<title level="j">Month of Browser Bugs</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title/>
		<ptr target="http://projects.info-pull.com/mokb/" />
	</analytic>
	<monogr>
		<title level="j">Month of Kernel Bugs</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
				<ptr target="http://www.ocert.org/" />
		<title level="m">Open Source Computer Emergency Response Team</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
				<ptr target="http://code.google.com/p/open-vcdiff/" />
		<title level="m">An encoder/decoder for the VCDIFF (RFC3284) format</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">PCAP: Next Generation Dump File Format</title>
		<ptr target="www.winpcap.org/ntar/draft/PCAP-DumpFileFormat.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title/>
		<ptr target="http://peachfuzz.sourceforge.net/" />
	</analytic>
	<monogr>
		<title level="j">Peach Fuzzing Platform</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Secunia</forename><surname>Website</surname></persName>
		</author>
		<ptr target="http://secunia.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Spike</forename><forename type="middle">Fuzzing</forename><surname>Platform</surname></persName>
		</author>
		<ptr target="http://www.immunitysec.com/resourcesfreesoftware.shtml" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
				<ptr target="http://www.gnu.org/software/tar/" />
		<title level="m">The gnu version of the tar archiving utility</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
				<ptr target="http://secunia.com/advisories/35126/" />
		<title level="m">Winamp MP4 Processing Buffer Overflow Vulnerabilities</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Wireshark: The World&apos;s Most Popular Network Protocol Analyzer</title>
		<ptr target="http://www.wireshark.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Double Free</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vulnerabilities</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">PNG (Portable Network Graphics) Specification Version 1.0. RFC 2083, Internet Engineering Task Force</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Boutell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Automatic patch-based exploit generation is possible: Techniques and implications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Poosankam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2008 IEEE Symposium on Security and Privacy</title>
		<meeting>the 2008 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2008-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Dispatcher: Enabling active botnet infiltration using automatic protocol reverse-engineering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Caballero</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Poosankam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kreibich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th ACM Conference on Computer and Communication Security (CCS&apos;09)</title>
		<meeting>the 16th ACM Conference on Computer and Communication Security (CCS&apos;09)<address><addrLine>Chicago, IL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Polyglot: Automatic extraction of protocol message format using dynamic binary analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Caballero</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on Computer and Communication Security</title>
		<meeting>ACM Conference on Computer and Communication Security</meeting>
		<imprint>
			<date type="published" when="2007-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Unassisted and automatic generation of high-coverage tests for complex systems programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cadar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dunbar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Klee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Symposium on Operating Systems Design and Implementation (OSDI&apos;08)</title>
		<meeting><address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Exe: automatically generating inputs of death</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cadar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Ganesh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Pawlowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th ACM conference on Computer and communications security (CCS&apos;06)</title>
		<meeting>the 13th ACM conference on Computer and communications security (CCS&apos;06)</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="322" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Dytan: A generic dynamic taint analysis framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Clause</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Orso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 2007 International Conference on Software Testing and Analysis (ISSTA&apos;07)</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Penumbra: Automatically identifying failure-relevant inputs using dynamic tainting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Clause</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Orso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 2009 International Conference on Software Testing and Analysis (ISSTA&apos;09)</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Prospex: Protocol specification extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Comparetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wondracek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<meeting><address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Static Detection of Vulnerabilities in x86 Executables</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Felmetsger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Banks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Annual Computer Security Applications Conference (ACSAC)</title>
		<meeting>the Annual Computer Security Applications Conference (ACSAC)<address><addrLine>Miami, FL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Discoverer: Automatic protocol reverse engineering from network traces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th USENIX Security Symposium</title>
		<meeting>the 16th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Tupni: automatic reverse engineering of input formats</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Peinado</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Irun-Briz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS &apos;08: Proceedings of the 15th ACM conference on Computer and communications security</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="391" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">ZLIB compressed data format specification version 3.3. RFC 1950, Internet Engineering Task Force</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Gailly</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Flayer: Exposing Application Internals</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Drewry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ormandy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">First Workshop On Offensive Technologies (WOOT)</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Dynamic spyware analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Egele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of USENIX Annual Technical Conference</title>
		<meeting>USENIX Annual Technical Conference</meeting>
		<imprint>
			<date type="published" when="2007-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">SNOOZE: toward a Stateful NetwOrk prOtocol fuzZEr</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Banks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Felmetsger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Almeroth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kemmerer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Information Security Conference (ISC)</title>
		<meeting>the Information Security Conference (ISC)<address><addrLine>Samos, Greece</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A decision procedure for bit-vectors and arrays</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Ganesh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification (CAV &apos;07)</title>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Taint-based directed whitebox fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Ganesh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Leek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st International Conference on Software Engineering (ICSE&apos;09)</title>
		<meeting>the 31st International Conference on Software Engineering (ICSE&apos;09)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Grammar-based whitebox fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kiezun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Y</forename><surname>Levin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI&apos;08)</title>
		<meeting>the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI&apos;08)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Dart: directed automated random testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Klarlund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI &apos;05: Proceedings of the 2005 ACM SIGPLAN conference on Programming language design and implementation</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="213" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Automated whitebox fuzz testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Molnar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th Annual Network and Distributed System Security Symposium (NDSS&apos;08)</title>
		<meeting>the 15th Annual Network and Distributed System Security Symposium (NDSS&apos;08)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Extracting output formats from executables</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Junghee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Reps</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Liblit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Working Conference on Reverse Engineering</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="167" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Emulating emulation-resistant malware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">G</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hanna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mccamant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Second Workshop on Virtual Machine Security (VMSec)</title>
		<meeting><address><addrLine>Chicago, IL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">The VCDIFF Generic Differencing and Compression Data Format</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Korn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Macdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mogul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Vo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">3284</biblScope>
			<date type="published" when="2002-06" />
		</imprint>
		<respStmt>
			<orgName>Internet Engineering Task Force</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Automatic protocol format reverse engineering through context-aware monitored execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th Annual Network and Distributed System Security Symposium</title>
		<meeting>the 15th Annual Network and Distributed System Security Symposium<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Convicting exploitable software vulnerabilities: An efficient input provenance based approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN-DCCS 2008)</title>
		<meeting>the 38th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN-DCCS 2008)<address><addrLine>Anchorage, Alaska, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Pin: Building Customized Program Analysis Tools with Dynamic Instrumentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-K</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Klauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lowney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">J</forename><surname>Reddi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Hazelwood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 ACM SIGPLAN conference on Programming language design and implementation (PLDI)</title>
		<meeting>the 2005 ACM SIGPLAN conference on Programming language design and implementation (PLDI)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="190" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Directed test generation using symbolic grammars</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R.-G</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEC-FSE companion &apos;07: The 6th</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
				<title level="m">Joint Meeting on European software engineering conference and the ACM SIGSOFT symposium on the foundations of software engineering</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="553" to="556" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">An empirical study of the reliability of UNIX utilities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Fredriksen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bryan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="32" to="44" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Dynamic test generation to find integer bugs in x86 binary linux programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Molnar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><forename type="middle">C</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th USENIX Security Symposium</title>
		<meeting>the 18th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Exploring multiple execution paths for malware analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Moser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SP &apos;07: Proceedings of the 2007 IEEE Symposium on Security and Privacy</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="231" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Automatic logging of operating system effects to guide application-level architecture simulation. SIGMETRICS Perform</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eval. Rev</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="216" to="227" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Valgrind: a framework for heavyweight dynamic binary instrumentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Nethercote</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Seward</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI &apos;07: Proceedings of the 2007 ACM SIGPLAN conference on Programming language design and implementation</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="89" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Replayer: Automatic protocol replay by binary analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Newsome</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th ACM Conference on Computer and Communications Security</title>
		<meeting>the 13th ACM Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2006-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Dynamic taint analysis: Automatic detection, analysis, and signature generation of exploit attacks on commodity software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Newsome</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed Systems Security Symposium</title>
		<meeting>the Network and Distributed Systems Security Symposium</meeting>
		<imprint>
			<date type="published" when="2005-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Violating assumptions with fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Oehlert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Security and Privacy</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="58" to="62" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">Making Software Dumberer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ormandy</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Protos -systematic approach to eliminate software vulnerabilities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Röning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lasko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Takanen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kaksonen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Invited presentation at Microsoft Research</title>
		<meeting><address><addrLine>Seattle, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">An efficient black-box technique for defeating web application attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th Annual Network and Distributed System Security Symposium</title>
		<meeting>the 16th Annual Network and Distributed System Security Symposium<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Cute: a concolic unit testing engine for c</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Marinov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEC/FSE-13: Proceedings of the 10th European software engineering conference held jointly with 13th ACM SIGSOFT international symposium on Foundations of software engineering</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="263" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Impeding malware analysis using conditional code obfuscation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sharif</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lanzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Giffin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th Annual Network and Distributed System Security Symposium</title>
		<meeting>the 15th Annual Network and Distributed System Security Symposium<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<title level="m" type="main">Fuzzing: Brute Force Vulnerability Discovery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Greene</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Amini</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
			<publisher>Addison-Wesley Professional</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">IntScope: Automatically Detecting Integer Overflow Vulnerability in X86 Binary Using Symbolic Execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Zou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th Annual Network and Distributed System Security Symposium</title>
		<meeting>the 16th Annual Network and Distributed System Security Symposium<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Reformat: Automatic reverse engineering of encrypted messages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Grace</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th European Symposium on Research in Computer Security (ESORICS&apos;09)</title>
		<meeting>the 14th European Symposium on Research in Computer Security (ESORICS&apos;09)</meeting>
		<imprint>
			<date type="published" when="2009-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">A forced sampled execution approach to kernel rootkit identification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Cker Chiueh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">10th International Symposium on Recent Advances in Intrusion Detection (RAID&apos;07)</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="219" to="235" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Automatic network protocol analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wondracek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Comparetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16th Network &amp; Distributed System Security Symposium</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
