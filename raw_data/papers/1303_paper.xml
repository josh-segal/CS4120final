<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:38+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Branching vs. Linear Time: Semantical Perspective Version 1.2 ⋆</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sumit</forename><surname>Nain</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Rice University</orgName>
								<address>
									<postCode>77005-1892</postCode>
									<settlement>Houston</settlement>
									<region>TX</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Rice University</orgName>
								<address>
									<postCode>77005-1892</postCode>
									<settlement>Houston</settlement>
									<region>TX</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Branching vs. Linear Time: Semantical Perspective Version 1.2 ⋆</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>The discussion in the computer-science literature of the relative merits of linear-versus branching-time frameworks goes back to early 1980s. One of the beliefs dominating this discussion has been that the linear-time framework is not expressive enough semantically, making linear-time logics lacking in expres-siveness. In this work we examine the branching-linear issue from the perspective of process equivalence, which is one of the most fundamental notions in concur-rency theory, as defining a notion of process equivalence essentially amounts to defining semantics for processes. Over the last three decades numerous notions of process equivalence have been proposed. Researchers in this area do not any-more try to identify the &quot;right&quot; notion of equivalence. Rather, focus has shifted to providing taxonomic frameworks, such as &quot;the linear-branching spectrum&quot;, for the many proposed notions and trying to determine suitability for different applications. We revisit this issue here from a fresh perspective. We postulate three principles that we view as fundamental to any discussion of process equivalence. First, we borrow from research in denotational semantics and take contextual equivalence as the primary notion of equivalence. This eliminates many testing scenarios as either too strong or too weak. Second, we require the description of a process to fully specify all relevant behavioral aspects of the process. Finally, we require observable process behavior to be reflected in its input/output behavior. Under these postulates the distinctions between the linear and branching semantics tend to evaporate. As an example, we apply these principles to the framework of transducers , a classical notion of state-based processes that dates back to the 1950s and is well suited to hardware modeling. We show that our postulates result in a unique notion of process equivalence, which is trace based, rather than tree based.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>One of the most significant recent developments in the area of formal design verification is the discovery of algorithmic methods for verifying temporal-logic properties of finitestate systems <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b51">52,</ref><ref type="bibr" target="#b65">66,</ref><ref type="bibr" target="#b75">76]</ref>. In temporal-logic model checking, we verify the correctness of a finite-state system with respect to a desired property by checking whether a labeled state-transition graph that models the system satisfies a temporal logic formula that specifies this property (see <ref type="bibr" target="#b24">[25]</ref>). Model-checking tools have enjoyed a substantial and growing use over the last few years, showing ability to discover subtle flaws that result from extremely improbable events. While early on these tools were viewed as of academic interest only, they are now routinely used in industrial applications <ref type="bibr" target="#b35">[36]</ref>.</p><p>A key issue in the design of a model-checking tool is the choice of the temporal language used to specify properties, as this language, which we refer to as the temporal property-specification language, is one of the primary interfaces to the tool. (The other primary interface is the modeling language, which is typically the hardware description language used by the designers). One of the major aspects of all temporal languages is their underlying model of time. Two possible views regarding the nature of time induce two types of temporal logics <ref type="bibr" target="#b50">[51]</ref>. In linear temporal logics, time is treated as if each moment in time has a unique possible future. Thus, linear temporal logic formulas are interpreted over linear sequences and we regard them as describing the behavior of a single computation of a program. In branching temporal logics, each moment in time may split into various possible futures. Accordingly, the structures over which branching temporal logic formulas are interpreted can be viewed as infinite computation trees, each describing the behavior of the possible computations of a nondeterministic process.</p><p>In the linear temporal logic LTL, formulas are composed from the set of atomic propositions using the usual Boolean connectives as well as the temporal connectives G ("always"), F ("eventually"), X ("next"), and U ("until"). The branching temporal logic CTL ⋆ augments LTL by the path quantifiers E ("there exists a computation") and A ("for all computations"). The branching temporal logic CTL is a fragment of CTL ⋆ in which every temporal connective is preceded by a path quantifier. Note that LTL has implicit universal path quantifiers in front of its formulas. Thus, LTL is essentially the linear fragment of CTL ⋆ .</p><p>The discussion of the relative merits of linear versus branching temporal logics in the context of system specification and verification goes back to the 1980s <ref type="bibr" target="#b50">[51,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b64">65,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b67">68,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b72">73,</ref><ref type="bibr" target="#b73">74]</ref>. As analyzed in <ref type="bibr" target="#b64">[65]</ref>, linear and branching time logics correspond to two distinct views of time. It is not surprising therefore that LTL and CTL are expressively incomparable <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b50">51]</ref>. The LTL formula F Gp is not expressible in CTL, while the CTL formula AF AGp is not expressible in LTL. On the other hand, CTL seems to be superior to LTL when it comes to algorithmic verification, as we now explain.</p><p>Given a transition system M and a linear temporal logic formula ϕ, the modelchecking problem for M and ϕ is to decide whether ϕ holds in all the computations of M . When ϕ is a branching temporal logic formula, the problem is to decide whether ϕ holds in the computation tree of M . The complexity of model checking for both linear and branching temporal logics is well understood: suppose we are given a transition system of size n and a temporal logic formula of size m. For the branching temporal logic CTL, model-checking algorithms run in time O(nm) <ref type="bibr" target="#b22">[23]</ref>, while, for the linear temporal logic LTL, model-checking algorithms run in time n2 <ref type="bibr">O(m)</ref>  <ref type="bibr" target="#b51">[52]</ref>. Since LTL model checking is PSPACE-complete <ref type="bibr" target="#b66">[67]</ref>, the latter bound probably cannot be improved.</p><p>The difference in the complexity of linear and branching model checking has been viewed by some as an argument in favor of the branching paradigm. In particular, the seeming computational advantage of CTL model checking over LTL model checking made CTL a popular choice, leading to efficient model-checking tools for this logic <ref type="bibr" target="#b23">[24]</ref>. Through the 1990s, the dominant temporal specification language in industrial use was CTL. This dominance stemmed from the phenomenal success of SMV, the first symbolic model checker, which was CTL-based, and its follower VIS, also originally CTL-based, which served as the basis for many industrial model checkers.</p><p>In <ref type="bibr" target="#b74">[75]</ref> we argued that the computational advantage of LTL over CTL is rather illusory. We further argued that in spite of the phenomenal success of CTL-based model checking, CTL suffers from several fundamental limitations as a temporal propertyspecification language, all stemming from the fact that CTL is a branching-time formalism: the language is counterintuitive and hard to use, it does not lend itself to compositional reasoning, and it is fundamentally incompatible with semi-formal verification. In contrast, the linear-time framework is expressive and intuitive, supports compositional reasoning and semi-formal verification, and is amenable to combining enumerative and symbolic search methods. Indeed, the trend in the industry during this decade has been towards linear-time languages, such as ForSpec <ref type="bibr" target="#b6">[7]</ref>, PSL <ref type="bibr" target="#b28">[29]</ref>, and SVA <ref type="bibr" target="#b76">[77]</ref>.</p><p>In spite of the pragmatic arguments in favor of the linear-time approach, one still hears the arguments that this approach is not expressive enough, pointing out that in semantical analyses of concurrent processes, e.g., <ref type="bibr" target="#b70">[71]</ref>, the linear-time approach is considered to be the weakest semantically, yielding the coarsest notion of equivalence. In this paper we address the semantical arguments against linear time and argue that even from a semantical perspective the linear-time approach is quite adequate for specifying systems.</p><p>The gist of our argument is that branching-time-based notions of process equivalence are not reasonable notions of process equivalence, as they distinguish between processes that are not contextually distinguishable. In contrast, the linear-time view does yield an appropriate notion of contextual equivalence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Basic Argument Against Linear Time</head><p>The most fundamental approach to the semantics of programs focuses on the notion of equivalence. Once we have defined a notion of equivalence, the semantics of a programs can be taken to be its equivalence class. In the context of concurrency, we talk about process equivalence. The study of process equivalence provides the basic foundation for any theory of concurrency <ref type="bibr" target="#b61">[62]</ref>, and it occupies a central place in concurrency-theory research, cf. <ref type="bibr" target="#b70">[71]</ref>.</p><p>The linear-time approach to process equivalence focuses on the traces of a process. Two processes are defined to be trace equivalent if they have the same set of traces. It is widely accepted in concurrency theory, however, that trace equivalence is too weak a notion of equivalence, as processes that are trace equivalent may behave differently in the same context <ref type="bibr" target="#b60">[61]</ref>. An an example, using CCS notation, the two processes (a.b) + (a.c) and a.(b + c) have the same set of traces, but only the first one may deadlock when run in parallel with a process such as a.c.</p><p>In contrast, the two processes above are distinguished by bisimulation, a highly popular notion of process equivalence <ref type="bibr" target="#b61">[62,</ref><ref type="bibr" target="#b63">64,</ref><ref type="bibr" target="#b68">69]</ref>. It is known that CTL characterizes bisimulation, in the sense that two states in a transition system are bisimilar iff they satisfy exactly the same CTL formulas <ref type="bibr" target="#b17">[18]</ref> (see also <ref type="bibr" target="#b42">[43]</ref>). This is sometime mentioned as an important feature of CTL. This contrast, between the pragmatic arguments in favor of the adequate expressiveness of the linear-time approach <ref type="bibr" target="#b74">[75]</ref> and its accepted weakness from a processequivalence perspective, calls for a re-examination of process-equivalence theory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Process Equivalence Revisited</head><p>While the study of process equivalence occupies a central place in concurrency-theory research, the answers yielded by that study leave one with an uneasy feeling. Rather than providing a definitive answer, this study yields a profusion 1 of choices <ref type="bibr" target="#b3">[4]</ref>. This situation led to statements of the form "It is not the task of process theory to find the 'true' semantics of processes, but rather to determine which process semantics is suitable for which applications" <ref type="bibr" target="#b70">[71]</ref>. This situation should be contrasted with the corresponding one in the study of sequential-program equivalence. It is widely accepted that two programs are equivalent if they behave the same in all contexts, this is referred to as contextual or observational equivalence, where behavior refers to input/output behavior <ref type="bibr" target="#b77">[78]</ref>. In principle, the same idea applies to processes: two processes are equivalent if they pass the same tests, but there is no agreement on what a test is and on what it means to pass a test.</p><p>We propose to adopt for process-semantics theory precisely the same principles accepted in program-semantics theory.</p><p>Principle of Contextual Equivalence: Two processes are equivalent if they behave the same in all contexts, which are processes with "holes".</p><p>As in program semantics, a context should be taken to mean a process with a "hole", into which the processes under consideration can be "plugged". This agrees with the point of view taken in testing equivalence, which asserts that tests applied to processes need to themselves be defined as processes <ref type="bibr" target="#b25">[26]</ref>. Furthermore, all tests defined as processes should be considered. This excludes many of the "button-pushing experiments" of <ref type="bibr" target="#b60">[61]</ref>. Some of these experiments are too strong-they cannot be defined as processes, and some are too weak-they consider only a small family of tests <ref type="bibr" target="#b25">[26]</ref>.</p><p>In particular, the tests required to define bisimulation equivalence <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b60">61]</ref> are widely known to be too strong <ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b36">37]</ref>. In spite of its mathematical elegance <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b68">69]</ref> and ubiquity in logic <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b4">5]</ref>, bisimulation is not a reasonable notion of process equivalence, as it makes distinctions that cannot be observed. Bisimulation is essentially a structural similarity relation, as it relates states of the processes under comparison. It is a tractable relaxation of isomorphism, rather than an observational comparison relation.</p><p>The most explicit advocacy of using bisimulation-based equivalence (in fact, branching bisimulation) appears in <ref type="bibr" target="#b71">[72]</ref>, which argues in favor of using equivalence concepts that are based on internal structure because of their context independence: "if two processes have the same internal structure they surely have the same observable behavior." It is hard to argue with the last point, but expecting an implementation to have the same internal structure as a specification is highly unrealistic and impractical, as it requires the implementation to be too close to the specification. <ref type="bibr" target="#b1">2</ref> In fact, it is clear from the terminology of "observational equivalence" used in <ref type="bibr" target="#b61">[62]</ref> that the intention there was to formulate a concept of equivalence based on observational behavior, rather than on internal structure. Nevertheless, the terms "observational equivalence" for bisimulationbased equivalence in <ref type="bibr" target="#b61">[62]</ref> is, perhaps, unfortunate, as weak-bisimulation equivalence is in essence a notion of structural similarity.</p><p>Remark 1. One could argue that bisimulation equivalence is not only a mathematically elegant concept; it also serves as the basis for useful sound proof techniques for establishing process equivalence, cf. <ref type="bibr" target="#b42">[43]</ref>. The argument here, however, is not against bisimulation as a useful mathematical concept; such usefulness ought to be evaluated on its own merits, cf. <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b78">79]</ref>. Rather, the argument is against viewing bisimulation-based notions of equivalence as reasonable notions of process equivalence.</p><p>The Principle of Contextual Equivalence does not fully resolve the question of process equivalence. In additional to defining the tests to which we subject processes, we need to define the observed behavior of the tested processes. It is widely accepted, however, that linear-time semantics results in important behavioral aspects, such as deadlocks, being non-observable <ref type="bibr" target="#b60">[61]</ref>. It is this point that contrasts sharply with the experience that led to the adoption of linear time in the context of hardware model checking <ref type="bibr" target="#b74">[75]</ref>; in today's synchronous hardware all relevant behavior, including deadlock and livelock is observable (observing livelock requires the consideration of infinite traces). Compare this with our earlier example, where the process (a.b) + (a.c) may deadlock when run in parallel with a process such as a.c. The problem here is that the description of the process does not tell us what happens when the first summand is selected in the context of the parallel process a.c. The deadlock here is not described explicitly; rather it is implicitly inferred from a lack of specified behavior. This leads us to our second principle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Principle of Comprehensive Modeling:</head><p>A process description should model all relevant aspects of process behavior.</p><p>The rationale for this principle is that relevant behavior, where relevance depends on the application at hand, should be captured by the description of the process, rather than inferred from lack of behavior by a semantical theory proposed by a concurrency theorist. It is the usage of inference to attribute behavior that opens the door to numerous interpretations, and, consequently, to numerous notions of process equivalence. As an example, consider the notion of completed-trace equivalence in <ref type="bibr" target="#b70">[71]</ref>. Implicitly, this notion assumes that the completion of a trace is observable. The Principle of Comprehensive Modeling requires that this observability be modeled explicitly, by the modeler, rather than attributed implicitly by the concurrency theorist.</p><p>Remark 2. It is useful to draw an analogy here to another theory, that of nonmonotonic logic, whose main focus is on inferences from absence of premises. The field started with some highly influential papers, advocating, for example "negation as failure" <ref type="bibr" target="#b20">[21]</ref> and "circumscription" <ref type="bibr" target="#b57">[58]</ref>. Today, however, there is a profusion of approaches to nonmonotonic logic, including numerous extensions to negation as failure and to circumscription <ref type="bibr" target="#b56">[57]</ref>. One is forced to conclude that there is no universally accepted way to draw conclusions from absence of premises. (Compare also to the discussion of negative premises in transition-system specifications <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b36">37]</ref>.) Going back to our problematic CCS process (a.b) + (a.c), the problem is that the process is not receptive to the action c, after it has executed a on the left summand. The position that processes need to be receptive to all allowed inputs from their environment has been argued by many authors <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b53">54,</ref><ref type="bibr" target="#b52">53]</ref>. It can be viewed as an instance of our Principle of Comprehensive Modeling, which says that the behavior that results from an action c by the environment after the process has executed a on the left summand needs to be specified explicitly. From this point of view, process-algebraic formalisms such as CCS <ref type="bibr" target="#b60">[61]</ref> are underspecified, since they leave important behavioral aspects unspecified. For example, if the distinction between normal termination and deadlocked termination is relevant to the application, then this distinction ought to be explicitly modeled. Rather, in CCS there is no observable distinction between normal and deadlocked termination, as both situations are characterized only by the absence of outgoing transitions. Note that the approach in <ref type="bibr" target="#b60">[61,</ref><ref type="bibr" target="#b61">62]</ref> takes communication to be the basic observable, and abstracts away the distinction between input and output, which is critical to our discussion. <ref type="bibr" target="#b2">3</ref> It is interesting to note that transducers, which were studied in an earlier work of Milner <ref type="bibr" target="#b59">[60]</ref>, which led to <ref type="bibr" target="#b60">[61]</ref>, are receptive. Transducers are widely accepted models of hardware. We come back to transducers in the next section.</p><p>Remark 3. The Principle of Comprehensive Modeling is implicit in a paper by Halpern on modeling game-theoretic situations <ref type="bibr" target="#b39">[40]</ref>. The paper shows that a certain gametheoretic paradox is, in fact, a consequence of deficient modeling, in which states of agents do not capture all relevant aspects of their behavior. Once the model is appropriately enriched, the paradox evaporates away. For extensive discussions on modeling multi-agent systems, see Chapters 4 and 5 in <ref type="bibr" target="#b33">[34]</ref> and Chapter 6 in <ref type="bibr" target="#b38">[39]</ref>.</p><p>The Principle of Comprehensive Modeling can be thought of as the "Principle of Appropriate Abstraction". Every model is an abstraction of the situation being modeled. A good model necessarily abstracts away irrelevant aspects, but models explicitly relevant aspects. The distinction between relevant and irrelevant aspects is one that can be made only by the model builder and users. For example, a digital circuit is a model of an analog circuit in which only the digital aspects of the circuit behavior are captured <ref type="bibr" target="#b37">[38]</ref>. Such a model should not be used to analyze non-digital aspects of circuit behavior, such as timing issues or issues of metastable states. Such issues require richer models. The Principle of Comprehensive Modeling does not call for infinitely detailed models; such models are useless as they offer no abstraction. Rather, the principle calls for models that are rich enough, but not too rich, depending on the current level of abstraction. Whether or not deadlocked termination should be considered distinct from normal termination depends on the the current level of abstraction; at one level of abstraction this distinction is erased, but at a finer level of abstraction this distinction is material. For further discussion of abstraction see <ref type="bibr" target="#b48">[49]</ref>.</p><p>The Principle of Comprehensive Modeling requires a process description to model all relevant aspects of process behavior. It does not spell out how such aspects are to be modeled. In particular, it does not address the question of what is observed when a process is being tested. Here again we propose to follow the approach of program semantics theory and argue that only the input/output behavior of processes is observable. Thus, observable relevant aspects of process behavior ought to be reflected in its input/output behavior.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Principle of Observable I/O:</head><p>The observable behavior of a tested process is precisely its input/output behavior.</p><p>Of course, in the case of concurrent processes, the input/output behavior has a temporal dimension. That is, the input/output behavior of a process is a trace of input/output actions. The precise "shape" of this trace depends of course on the underlying semantics, which would determine, for example, whether we consider finite or infinite traces, the temporal granularity of traces, and the like. It remains to decide how nondeterminism is observed, as, after all, a nondeterministic process does not have a unique behavior. This leads to notions such as may testing and must testing <ref type="bibr" target="#b25">[26]</ref>. We propose here to finesse this issue by imagining that a test is being run several times, eventually exhibiting all possible behaviors. Thus, the input/output behavior of a nondeterministic test is its full set of input/output traces.</p><p>One could also argue that by allowing a test to observe all input/output traces and by allowing infinite traces, our notion of test is too strong, resulting in an overly fine notion of process equivalence. Similarly, in modeling security protocols, cf.</p><p>[28], we may want to require a weaker notion of observability of outputs. We recognize that in some applications one may choose to use a coarser notion of equivalence than the one we use here. Since our focus in this paper is on showing that trace equivalence is not too coarse, we do not pursue these points further here.</p><p>It should be noted that the approach advocated here is diametrically opposed to that of <ref type="bibr" target="#b71">[72]</ref>, who argues against contextual equivalence: "In practice, however, there appears to be doubt and difference of opinion concerning the observable behavior of systems. Moreover, what is observable may depend on the nature of the systems on which the concept will be applied and the context in which they will be operating." In contrast, our guiding principles say that (1) by considering all possible contexts, one need not worry about identifying specific contexts or testing scenarios, and (2) process description ought to describe the observable behavior of the process precisely to remove doubts about that behavior. In our opinion, the "doubt and difference of opinion" about process behavior stem from the underspecificity for formalisms such as CCS and CSP.</p><p>Remark 4. In the same way that bisimulation is not a contextual equivalence relation, branching-time properties are not necessarily contextually observable. Adapting our principles to property observability we should expect behavioral properties to be observable in the following sense. If two processes are distinguished by a property ϕ, that is, P 1 satisfies ϕ, but P 2 does not satisfy ϕ, there has to be a context C such that the set of input-output traces of C[P 1 ] is different than that of C[P 2 ]. Consider, however, the CTL property AGEF p, which says that from all given states of the process it is possible to reach a state where p holds. It is easy to construct processes P 1 and P 2 , one satisfying AGEF p and one falsifying it, such that C[P 1 ] and C[P 2 ] have the same set of input-output traces for all contexts C. Thus, AGEF p is a structural property rather than an observable property.</p><p>In the next section we apply our approach to transducers; we show that once our three principles are applied we obtain that trace-based equivalence is adequate and fully abstract; that is, it is precisely the unique observational equivalence for transducers. We believe that this holds in general; that is, under our three principles, trace-based equivalence provides the "right" notion of process equivalence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Case Study: Transducers</head><p>In this section, we apply the approach discussed above to a very simple notion of process: transducers <ref type="bibr" target="#b59">[60]</ref>. We choose this notion of process, as it trivially satisfies the Principle of Comprehensive Modeling and the Principle of Observable I/O, since the behavior of a transducer is fully described by its state-transition and output functions.</p><p>Transducers constitute a fundamental model of discrete-state machines with input and output channels <ref type="bibr" target="#b40">[41]</ref>. They are still used as a basic model for sequential computer circuits <ref type="bibr" target="#b37">[38]</ref>. We use nondeterministic transducers as our model for processes. We define a synchronous composition operator for such transducers, which provides us a notion of context. We then define linear observation semantics and prove adequacy and full-abstraction results for trace equivalence in terms of it. Thus, this case study provides a concrete example in which our philosophical approach can be tested.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Nondeterministic Transducers</head><p>A nondeterministic transducer is a state machine with input and output channels. The state-transition function depends on the current state and the input, while the output depends solely on the current state (thus, our machines are Moore machines <ref type="bibr" target="#b40">[41]</ref>). Definition 1. A transducer is a tuple, M = (Q, q 0 , I, O, Σ, σ, λ, δ), where -Q is a countable set of states. -q 0 is the start state. -I is a finite set of input channels. -O is a finite set of output channels. -Σ is a finite alphabet of actions (or values). -σ : I ∪ O → 2 Σ − {∅} is a function that allocates an alphabet to each channel. -λ : Q × O → Σ is the output function of the transducer. λ(q, o) ∈ σ(o) is the value that is output on channel o when the transducer is in state q. -δ : Q × σ(i 1 ) × . . . × σ(i n ) → 2 Q , where I = {i 1 , . . . , i n }, is the transition function, mapping the current state and input to the set of possible next states.</p><p>Both I and O can be empty. In this case δ is a function of state alone. This is important because the composition operation that we define usually leads to a reduction in the number of channels. Occasionally, we refer to the set of allowed values for a channel as the channel alphabet. This is distinct from the total alphabet of the transducer (denoted by Σ).</p><p>We represent a particular input to a transducer as an assignment that maps each input channel to a particular value. Formally, an input assignment for a transducer (Q, q 0 , I, O, Σ, σ, λ, δ) is a function f : I → Σ, such that for all i ∈ I, f (i) ∈ σ(i). The entire input can then, by a slight abuse of notation, be succinctly represented as f (I).</p><p>We point to three important features of our definition. First, note that transducers are receptive. That is, the transition function δ(q, f ) is defined for all states q ∈ Q and input assignments f . There is no implicit notion of deadlock here. Deadlocks need to be modeled explicitly, e.g., by a special sink state d whose output is, say, "deadlock". Second, note that inputs at time k take effect at time k + 1. This enables us to define composition without worrying about causality loops, unlike, for example, in Esterel <ref type="bibr" target="#b10">[11]</ref>. Thirdly, note that the internal state of a transducer is observable only through its output function. How much of the state is observable depends on the output function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Synchronous Parallel Composition</head><p>In general there is no canonical way to compose machines with multiple channels. In concrete devices, connecting components requires as little as knowing which wires to join. Taking inspiration from this, we say that a composition is defined by a particular set of desired connections between the machines to be composed. This leads to an intuitive and flexible definition of composition.</p><p>A connection is a pair consisting of an input channel of one transducer along with an output channel of another transducer. We require, however, sets of connections to be well formed. This requires two things: -no two output channels are connected to the same input channel, and -an output channel is connected to an input channel only if the output channel alphabet is a subset of the input channel alphabet. These conditions guarantee that connected input channels only receive well defined values that they can read. We now formally define this notion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2 (Connections). Let M be a set of transducers. Then</head><formula xml:id="formula_0">Conn(M) = {X ⊆ C(M)|(a, b) ∈ X, (a, c) ∈ X⇒b = c} where C(M) = {(i A , o B ) |{A, B} ⊆ M, i A ∈ I A , o B ∈ O B , σ B (o B ) ⊆ σ A (i A )</formula><p>} is the set of all possible input/output connections for M. Elements of Conn(M) are valid connection sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Composition).</head><formula xml:id="formula_1">Let M = {M 1 , . . . , M n }, where M k = (Q k , q k 0 , I k , O k , Σ k , σ k , λ k , δ k )</formula><p>, be a set of transducers, and C ∈ Conn(M). Then the composition of M with respect to C, denoted by || C (M), is a transducer (Q, q 0 , I, O, Σ, σ, λ, δ) defined as follows:</p><formula xml:id="formula_2">-Q = Q 1 × . . . × Q n -q 0 = q 1 0 × . . . × q n 0 -I = n k=1 I k − {i | (i, o) ∈ C} -O = n k=1 O k − {o | (i, o) ∈ C} -Σ = n k=1 Σ k -σ(u) = σ k (u), where u ∈ I k ∪ O k -λ(q 1 , . . ., q n , o) = λ k (q k , o) where o ∈ O k -δ(q 1 , . . ., q n , f (I)) = Π n k=1 (δ k (q k , g(I k ))) where g(i) = λ j (q j , o) if (i, o) ∈ C, o ∈ O j , and g(i) = f (i) otherwise.</formula><p>Definition 4 (Binary Composition). Let M 1 and M 2 be transducers, and C ∈ Conn({M 1 , M 2 }).</p><p>The binary composition of M 1 and M 2 with respect to C is</p><formula xml:id="formula_3">M 1 || C M 2 = || C ({M 1 , M 2 }).</formula><p>The following theorem shows that a general composition can be built up by a sequence of binary compositions. Thus binary composition is as powerful as general composition and henceforth we switch to binary composition as our default composition operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1 (Composition Theorem).</head><formula xml:id="formula_4">Let M = {M 1 , . . ., M n }, where M k = (Q k , q k 0 , I k , O k , Σ k , σ k , λ k , δ k )</formula><p>, be a set of transducers, and C ∈ Conn(M).</p><formula xml:id="formula_5">Let M ′ = M − {M n }, C ′ = {(i, o) ∈ C|i ∈ I j , o ∈ O k , j &lt; n, k &lt; n} and C ′′ = C − C ′ . Then || C (M) = || C ′′ ({|| C ′ (M ′ ), M n }).</formula><p>The upshot of Theorem 1 is that in the framework of transducers a general context, which is a network of transducers with a hole, is equivalent to a single transducer. Thus, for the purpose of contextual equivalence it is sufficient to consider testing transducers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Executions and Traces</head><p>Definition 5 (Execution). An execution for transducer M = (Q, q 0 , I, O, Σ, σ, λ, δ) is a countable sequence of pairs s i , f i l i=0 such that s 0 = q 0 , and for all i ≥ 0,</p><formula xml:id="formula_6">-s i ∈ Q. -f i : I → Σ such that for all u ∈ I, f (u) ∈ σ(u). -s i ∈ δ(s i−1 , f i−1 (I)).</formula><p>If l ∈ N , the execution is finite and its length is l. If l = ∞, the execution is infinite and its length is defined to be ∞. The set of all executions of transducer M is denoted exec(M ). Thus a trace is a sequence of pairs of output and input actions. While an execution captures the real underlying behavior of the system, a trace is the observable part of that behavior. The length of a trace α is defined to be the length of the underlying execution and is denoted by |α|. Definition 7 (Trace Equivalence). Two transducers M 1 and M 2 are trace equivalent, denoted by M 1 ∼ T M 2 , if T r(M 1 ) = T r(M 2 ). Note that this requires that they have the same set of input and output channels.</p><p>We now study the properties of trace equivalence. We first define the composition of executions and traces. Definition 8. Given α = s i , f i n i=0 ∈ exec(M 1 ) and β = r i , g i n i=0 ∈ exec(M 2 ), we define the composition of α and β w.r.t C ∈ Conn({M 1 , M 2 }) as follows</p><formula xml:id="formula_7">α|| C β = (s i , r i ), h i n i=0 where h i (u) = f i (u) if u ∈ I 1 −{i|(i, o) ∈ C} and h i (u) = g i (u) if u ∈ I 2 −{i|(i, o) ∈ C}.</formula><p>Definition 9. Given t = ω i , f i n i=0 ∈ T r(M 1 ) and u = ν i , g i n i=0 ∈ T r(M 2 ), we define the composition of t and u w.r.t C ∈ Conn({M 1 , M 2 }) as follows</p><formula xml:id="formula_8">t|| C u = µ i , h i n i=0</formula><p>where</p><formula xml:id="formula_9">µ i (o) = ω i (o) if o ∈ O 1 − {o|(i, o) ∈ C} and µ i (o) = ν i (o) if o ∈ O 2 − {o|(i, o) ∈ C}</formula><p>, and h i is as defined in Definition 8 above.</p><p>Note that the composition operation defined on traces is purely syntactic. There is no guarantee that the composition of two traces is a trace of the composition of the transducers generating the individual traces. The following simple property is necessary and sufficient to achieve this.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 10 (Compatible Traces). Given</head><formula xml:id="formula_10">C ∈ Conn({M 1 , M 2 }), t 1 = ω 1 i , f 1 i n i=0 ∈ T r(M 1 ) and t 2 = ω 2 i , f 2 i n i=0 ∈ T r(M 2 )</formula><p>, we say that t 1 and t 2 are compatible with respect to C if for all (u, o) ∈ C and for all i ≥ 0, we have</p><formula xml:id="formula_11">-If u ∈ I j and o ∈ O k then f j i (u) = ω k i (o)</formula><p>, for all i ≥ 0 and for j, k ∈ {1, 2}.</p><formula xml:id="formula_12">Lemma 1. Let C ∈ Conn({M 1 , M 2 }), t ∈ T r(M 1 ) and u ∈ T r(M 2 ). Then t|| C u ∈ T r(M 1 || C M 2 )</formula><p>if and only if t and u are compatible with respect to C.</p><p>We now extend the notion of trace composition to sets of traces.</p><formula xml:id="formula_13">Definition 11. Let T 1 ⊆ T r(M 1 ), T 2 ⊆ T r(M 2 ) and C ∈ Conn({M 1 , M 2 }). We define T 1 || C T 2 = {t 1 || C t 2 | t 1 ∈ T r(M 1 ), t 2 ∈ T r(M 2 ), |t 1 | = |t 2 |} Theorem 2 (Syntactic theorem of traces). Let T 1 ⊆ T r(M 1 ) ∩ T r(M 3 ) and T 2 ⊆ T r(M 2 ) ∩ T r(M 4 ), and C ∈ Conn({M 1 , M 2 }) ∩ Conn({M 3 , M 4 }). Then (T 1 || C T 2 ) ∩ T r(M 1 || C M 2 ) = (T 1 || C T 2 ) ∩ T r(M 3 || C M 4 )</formula><p>Using Theorem 2, we show now that any equivalence defined in terms of sets of traces is automatically a congruence with respect to composition, if it satisfies a certain natural property. Definition 12 (Trace-based equivalence). Let M be the set of all transducers. Let R : M → {A ⊆ T r(M )|M ∈ M} such that for all M ∈ M, R(M ) ⊆ T r(M ). Then R defines an equivalence relation on M, denoted by ∼ R , such that for all M 1 , M 2 ∈ M, M 1 ∼ R M 2 if and only if R(M 1 ) = R(M 2 ). Such a relation is called a trace-based equivalence.</p><p>Trace-based equivalences enable us to relativize trace equivalence to "interesting" traces. For example, one may want to consider finite traces only, infinite traces only, fair traces only, and the like. Of course, not all such relativizations are appropriate. We require traces to be compositional, in the sense described below. This covers finite, infinite, and fair traces.</p><p>Definition 13 (Compositionality). Let ∼ R be a trace-based equivalence. We say that ∼ R is compositional if given transducers M 1 , M 2 and C ∈ Conn({M 1 , M 2 }), the following hold:</p><formula xml:id="formula_14">1. R(M 1 || C M 2 ) ⊆ R(M 1 )|| C R(M 2 ). 2. If t 1 ∈ R(M 1 ), t 2 ∈ R(M 2 ), and t 1 , t 2 are compatible w.r.t. C, then t 1 || C t 2 ∈ R(M 1 || C M 2 ).</formula><p>The two conditions in Definition 13 are, in a sense, soundness and completeness conditions, as the first ensures that no inappropriate traces are present, while the second ensures that all appropriate traces are present. That is, the first condition ensures that the trace set captured by R is not too large, while the second ensures that it is not too small. Note, in particular, that trace equivalence itself is a compositional trace-based equivalence. The next theorem asserts that ∼ R is a congruence with respect to composition.</p><formula xml:id="formula_15">Theorem 3 (Congruence Theorem). Let ∼ R be a compositional trace-based equiva- lence. Let M 1 ∼ R M 3 , M 2 ∼ R M 4 , and C ∈ Conn({M 1 , M 2 }) = Conn({M 3 , M 4 }). Then M 1 || C M 2 ∼ R M 3 || C M 4 .</formula><p>An immediate corollary of Theorem 3 is the fact that no context can distinguish between two trace-based equivalent transducers. Corollary 1. Let M 1 and M 2 be transducers, R be a compositional trace-based equivalence and M 1 ∼ R M 2 . Then for all transducers M and all C ∈ Conn({M,</p><formula xml:id="formula_16">M 1 }) = Conn({M, M 2 }), we have that M || C M 1 ∼ R M || C M 2 .</formula><p>Finally, it is also the case that some context can always distinguish between two inequivalent transducers. If we choose a composition with an empty set of connections, all original traces of the composed transducers are present in the traces of the composition. If</p><formula xml:id="formula_17">M 1 ∼ R M 2 , then M 1 || ∅ M ∼ R M 2 || ∅ M .</formula><p>We claim the stronger result that given two inequivalent transducers, we can always find a third transducer that distinguishes between the first two, irrespective of how it is composed with them.</p><p>Theorem 4. Let M 1 and M 2 be transducers, R be a compositional trace-based equivalence and M 1 ∼ R M 2 . Then there exists a transducer M such that for all C ∈ Conn({M,</p><formula xml:id="formula_18">M 1 }) ∩ Conn({M, M 2 }), we have M || C M 1 ∼ R M || C M 2 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Digression: What Is Linear Time Logic?</head><p>The discussion so far has focused on the branching-or linear-time view of process equivalence, where we argued strongly in favor of linear time. This should be distinguished from the argument in, say, <ref type="bibr" target="#b74">[75]</ref> in favor of linear-temporal logics (such as LTL, ForSpec, and the like). In the standard approach to linear-temporal logics, one interprets formulas in such logics over traces. Thus, given a linear-temporal formula ψ, its semantics is the set traces(ψ) of traces satisfying it. A system S then satisfies ψ if traces(S) ⊆ traces(ψ).</p><p>It has recently been shown that this view of linear time is not rich enough <ref type="bibr" target="#b49">[50]</ref>. The context for this realization is an analysis of liveness properties, which assert that something good will happen eventually. In satisfying liveness properties, there is no bound on the "wait time", namely the time that may elapse until an eventuality is fulfilled. For example, the LTL formula F θ is satisfied at time i if θ holds at some time j ≥ i, but j − i is not a priori bounded.</p><p>In many applications, such as real-time systems, it is important to bound the wait time. This has given rise to formalisms in which the eventually operator F is replaced by a bounded-eventually operator F ≤k . The operator is parameterized by some k ≥ 0, and it bounds the wait time to k <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b32">33]</ref>. In the context of discrete-time systems, the operator F ≤k is simply syntactic sugar for an expression in which the next operator X is nested. Indeed, F ≤k θ is just θ ∨ X(θ ∨ X(θ∨ k−4 . . . ∨Xθ)).</p><p>A drawback of the above formalism is that the bound k needs to be known in advance, which is not the case in many applications. For example, it may depend on the system, which may not yet be known, or it may change, if the system changes. In addition, the bound may be very large, causing the state-based description of the specification (e.g., an automaton for it) to be very large too. Thus, the common practice is to use liveness properties as an abstraction of such safety properties: one writes F θ instead of F ≤k θ for an unknown or a too large k.</p><p>This abstraction of safety properties by liveness properties is not sound for a logic such as LTL. Consider the system S described in <ref type="figure">Figure 1</ref> below. While S satisfies the LTL formula F Gq, there is no k ≥ 0 such that S satisfies F ≤k Gq. To see this, note that for each k ≥ 0, the computation that first loops in the first state for k times and only then continues to the second state, satisfies the eventuality Gq with wait time k + 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S :</head><p>q ¬q q <ref type="figure">Fig. 1</ref>. S satisfies F Gq but does not satisfy F ≤k Gq, for all k ≥ 0.</p><p>In <ref type="bibr" target="#b49">[50]</ref>, there is a study of an extension of LTL that addresses the above problem. In addition to the usual temporal operators of LTL, the logic PROMPT-LTL has a new temporal operator that is used for specifying eventualities with a bounded wait time. The new operator is called prompt eventually and is denoted by F p . It has the following formal semantics: For a PROMPT-LTL formula ψ and a bound k ≥ 0, let ψ k be the LTL formula obtained from ψ by replacing all occurrences of F p by F ≤k . Then, a system S satisfies ψ iff there is k ≥ 0 such that S satisfies ψ k .</p><p>Note that while the syntax of PROMPT-LTL is very similar to that of LTL, its semantics is defined with respect to an entire system, and not with respect to computations. For example, while each computation π in the system S from <ref type="figure">Figure 1</ref> has a bound k π ≥ 0 such that Gq is satisfied in π with wait time k π , there is no k ≥ 0 that bounds the wait time of all computations. It follows that, unlike LTL, we cannot characterize a PROMPT-LTL formula ψ by a set of traces L(ψ) such that a system S satisfies ψ iff the set of traces of S is contained in L(ψ). Rather, one needs to associate with a formula ψ of PROMPT-LTL an infinite family L(ψ) of sets of traces, so that a system S satisfies ψ if traces(S) = L for some L ∈ L(ψ). This suggests a richer view of linear-time logic than the standard one, which associates a single set of traces with each formula in the logic. Even in this richer setting, we have the desired feature that two trace-equivalent processes satisfy the same linear-time formulas.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion</head><p>It could be fairly argued that the arguments raised in this paper have been raised before.</p><p>-We are clearly not the first to advocate trace-based notions of process equivalence.</p><p>It is, for example, the standard approach in the framework of I/O automata <ref type="bibr" target="#b53">[54,</ref><ref type="bibr" target="#b69">70]</ref> (though without much of a discussion). See also <ref type="bibr" target="#b0">[1]</ref>. -Testing equivalence, introduced in <ref type="bibr" target="#b25">[26]</ref>, is clearly a notion of contextual equivalence. Their answer to the question, "What is a test?", is that a test is any process that can be expressed in the formalism. So a test is really the counterpart of a context in program equivalence. (Though our notion of context in Section 4, as a network of transducers, is, a priori, richer.) At the same time, bisimulation equivalence has been recognized as being too fine a relation to be considered as contextual equivalence <ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b36">37]</ref>. -Furthermore, it has also been shown that many notions of process equivalence studied in the literature, for example, refusal semantics <ref type="bibr" target="#b16">[17]</ref>, can be obtained as contextual equivalence with respect to appropriately defined notions of directly observable behavior <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b54">55,</ref><ref type="bibr" target="#b62">63]</ref>. These notions fall under the title of decorated-trace equivalence, as they all start with trace semantics and then endow it with additional observables. These notions have the advantage that, like bisimulation equivalence, they are not blind to issues such as deadlock behavior.</p><p>With respect to the first point, this paper is clearly not addressed to those who believe that the trace-based approach to process equivalence is the correct one. As we pointed out earlier, this is not the prevailing view in concurrency theory.</p><p>With respect to the second point, it should be noted that despite the criticisms leveled at it, bisimulation equivalence still enjoys a special place of respect in concurrency theory as a reasonable notion of process equivalence <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b70">71]</ref>. In fact, the close correspondence between bisimulation equivalence and the branching-time logic CTL has been mentioned as an advantage of CTL. Thus, it is not redundant, in our opinion, to reiterate the point that bisimulation and its variants are not contextual equivalences.</p><p>With respect to the third point we note that our approach is related, but quite different, than that taken in decorated-trace equivalence. In the latter approach, the "decoration" of traces is attributed by concurrency theorists. As there is no unique way to decorate traces, one is left with numerous notions of equivalence and with the attitude quoted above that "It is not the task of process theory to find the 'true' semantics of processes, but rather to determine which process semantics is suitable for which applications" <ref type="bibr" target="#b70">[71]</ref>. In our approach, only the modelers know what the relevant aspects of behavior are in their applications and only they can decorate traces appropriately, which led to our Principles of Comprehensive Modeling and Observable I/O. In our approach, there is only one "right" contextual equivalence, which is trace-based equivalence.</p><p>Admittedly, the comprehensive-modeling approach is not wholly original, and has been foretold by Brookes <ref type="bibr" target="#b15">[16]</ref>, who said: "We do not augment traces with extraneous book-keeping information, or impose complex closure conditions. Instead we incorporate the crucial information about blocking directly in the internal structure of traces. " Still, we believe that it is valuable to carry Brookes's approach further, substantiate it with our three guiding principles, and demonstrate it in the framework of transducers.</p><p>An argument that may be leveled at our comprehensive-modeling approach is that it requires a low-level view of systems, one that requires modeling all relevant behavioral aspects. This issue was raised by Vaandrager in the context of I/O Automata <ref type="bibr" target="#b69">[70]</ref>. Our response to this criticism is twofold. First, if these low-level details (e.g., deadlock behavior) are relevant to the application, then they better be spelled out by the modeler rather than by the concurrency theorist. As discussed earlier, whether deadlocked termination should be distinguished from normal termination depends on the level of abstraction at which the modeler operates. It is a pragmatic decision rather than a theoretical decision. Similar, one could imagine two ways for a process to decline an input; it can block when that input is offered, or it can ignore it. It is the modeler who should chose which approach is taken, rather than the theorist. Second, if the distinction between normal termination and deadlocked termination is important to some users but not others, one could imagine language features that would enable explicit modeling of deadlocks when such modeling is desired, but would not force users to apply such explicit modeling. The underlying semantics of the language, say, in terms of structured operational semantics <ref type="bibr" target="#b41">[42]</ref>, can expose deadlocked behavior for some language features and not for others. In other words, Vaandrager's concerns about users being forced to adopt a low-level view should be addressed by designing more flexible languages, and not by introducing new notions of process equivalence. Note that the alternative to our approach is to accept formalisms for concurrency that are not fully specified and admit a profusion of different notions of process equivalence.</p><p>We want to emphasize that it is not our position that branching time has no value. To the contrary, branching-time analysis can be highly useful. For example, it is known that test trace containment between finite-state processes is PSPACE-complete. In contrast, testing similarity between finite-state process is in PTIME <ref type="bibr" target="#b43">[44]</ref>. This led to a proposal of using simulation as a tractable underapproximation for trace-containment <ref type="bibr" target="#b47">[48]</ref>. In fact, for certain models of processes, for example, deterministic transducers, simulation and trace containment coincide.</p><p>Furthermore, sometime the implementation is obtained from the specification via structural refinement, for example, deriving pipelined architectures from non-pipelined architectures. In such cases, establishing a structural relationship between implementation and specification is appropriate <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b55">56]</ref>. This does not mean that in these cases branching-time semantics is appropriate; rather, it means that branching time can be useful in the "service" of linear time. (In fact, it was already shown in <ref type="bibr" target="#b0">[1]</ref> that structural relations can be used to establish trace containment.)</p><p>In conclusion, this paper puts forward an, admittedly provocative, thesis, which is that process-equivalence theory allowed itself to wander in the "wilderness" for lack of accepted guiding principles. The obvious definition of contextual equivalence was not scrupulously adhered to, and the underspecificity of the formalisms proposed led to too many interpretations of equivalence. While one may not realistically expect a single paper to overwrite about 30 years of research, a more modest hope would be for this paper to stimulate a lively discussion on the basic principles of process-equivalence theory.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Definition 6 (</head><label>6</label><figDesc>Trace). Let α = s i , f i l i=0 ∈ exec(M ). The trace of α, denoted by [α], is the sequence of pairs ω i , f i l i=0 , where for all i ≥ 0, ω i : O → Σ and for all o ∈ O, ω i (o) = λ(s i , o). The set of all traces of a transducer M , denoted by T r(M ), is the set {[α]|α ∈ exec(M )}. An element of T r(M ) is called a trace of M .</figDesc></figure>

			<note place="foot" n="1"> This is referred to as the &quot;Next &apos;700 . . .&apos; Syndrome.&quot; [4] 2 Some authors require a relation of similarity, rather then bisimilarity between implementation and specification [44]. The arguments against bisimilarity apply, however, also to similarity.</note>

			<note place="foot" n="3"> The situation in CSP is a bit murkier. In CSP theory, a deadlock is expressed as lack of progress, but, operationally, a refused input is expressed by outputting the special symbol &quot;BLEEP&quot; [45]. (The formalism of Kripke structures, often used in the model-checking literature [25] and in model-checking tools [59], also suffers from lack of receptiveness, as it also does not distinguish between inputs and outputs.)</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment:</head><p>The second author is grateful to E. Clarke, P. Cousot and G. Plotkin for challenging him to consider the semantical aspects of the branching vs. linear-time issue, and to M. Abadi, S. Abramsky, L. Aceto, S. Brookes, K. Cooper, W. Fokkink, O. Grumberg, J. Halpern, C.A.R. Hoare, R. Milner, P. Panagaden, A. Pitts, G. Plotkin, A. Pnueli, and W. Taha for discussions and comments on this topic.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The existence of refinement mappings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="253" to="284" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Composing specifications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languagues and Systems</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="73" to="132" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Observation equivalence as a testing equivalence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Abramsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="225" to="241" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">What are the fundamental structures of concurrency?: We still don&apos;t know! Electr</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Abramsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Notes Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">162</biblScope>
			<biblScope unit="page" from="37" to="41" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Non-well-founded sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Aczel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CSLI Lecture Notes</title>
		<imprint>
			<biblScope unit="issue">14</biblScope>
			<date type="published" when="1988" />
		</imprint>
		<respStmt>
			<orgName>Stanford University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A final coalgebra theorem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Aczel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">P</forename><surname>Mendler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Category Theory and Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1989" />
			<biblScope unit="volume">389</biblScope>
			<biblScope unit="page" from="357" to="365" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The ForSpec temporal logic: A new temporal property-specification logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Armoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Fix</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Flaisher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gerth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Ginsburg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kanza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Landver</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mador-Haim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Singerman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tiemeyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zbar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th Int. Conf. on Tools and Algorithms for the Construction and Analysis of Systems</title>
		<meeting>8th Int. Conf. on Tools and Algorithms for the Construction and Analysis of Systems</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002" />
			<biblScope unit="volume">2280</biblScope>
			<biblScope unit="page" from="296" to="211" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Methodology and system for practical formal verification of reactive hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Beer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ben-David</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Geist</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gewirtzman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Yoeli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc 6th Int. Conf. on Computer Aided Verification</title>
		<meeting>6th Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="volume">818</biblScope>
			<biblScope unit="page" from="182" to="193" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The temporal logic of branching time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ben-Ari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="207" to="226" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Modal Logic and Classical Logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">F A K</forename><surname>Van Benthem</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983" />
			<pubPlace>Bibliopolis, Naples</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">The ESTEREL synchronous programming language: design, semantics, implementation. Science of Computer Programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gonthier</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="87" to="152" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Bisimulation can&apos;t be traced</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Bloom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Istrail</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">R</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="232" to="268" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Experimenting with process equivalence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Bloom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">R</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">101</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="223" to="237" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The meaning of negative premises in transition system specifications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">N</forename><surname>Bol</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">F</forename><surname>Groote</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="863" to="914" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Basic observables for processes. Information and Computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Boreale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pugliese</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="volume">149</biblScope>
			<biblScope unit="page" from="77" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Traces, pomsets, fairness and full abstraction for communicating processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">D</forename><surname>Brookes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 13th Int&apos;l Conf. on Concurrency Theory</title>
		<meeting>13th Int&apos;l Conf. on Concurrency Theory</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002" />
			<biblScope unit="volume">2421</biblScope>
			<biblScope unit="page" from="466" to="482" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A theory of communicating sequential processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">D</forename><surname>Brookes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">W</forename><surname>Roscoe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="560" to="599" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Characterizing finite Kripke structures in propositional temporal logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">C</forename><surname>Browne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="page" from="115" to="131" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Automatic verification of pipelined microprocessor control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>Burch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th Int&apos;l Conf. on Computer Aided Verification</title>
		<meeting>6th Int&apos;l Conf. on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994" />
			<biblScope unit="volume">818</biblScope>
			<biblScope unit="page" from="68" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Branching vs linear logics yet again</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Carmo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sernadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects of Computing</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="24" to="59" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Negation as failure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic and Databases</title>
		<editor>H. Gallaire and J. Minker</editor>
		<imprint>
			<publisher>Plenum Press</publisher>
			<date type="published" when="1978" />
			<biblScope unit="page" from="293" to="322" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Expressibility results for linear-time and branching-time logics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">A</forename><surname>Draghicescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop on Linear Time, Branching Time, and Partial Order in Logics and Models for Concurrency</title>
		<editor>J.W. de Bakker, W.P. de Roever, and G. Rozenberg</editor>
		<meeting>Workshop on Linear Time, Branching Time, and Partial Order in Logics and Models for Concurrency</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1988" />
			<biblScope unit="volume">354</biblScope>
			<biblScope unit="page" from="428" to="437" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Automatic verification of finite-state concurrent systems using temporal logic specifications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">P</forename><surname>Sistla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languagues and Systems</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="244" to="263" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Verification tools for finite-state concurrent systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Long</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Decade of Concurrency -Reflections and Perspectives (Proceedings of REX School)</title>
		<editor>J.W. de Bakker, W.-P. de Roever, and G. Rozenberg</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993" />
			<biblScope unit="volume">803</biblScope>
			<biblScope unit="page" from="124" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Model Checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Peled</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Testing equivalences for processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>De Nicola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hennessy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="83" to="133" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Trace theory for automatic hierarchical verification of speed independent circuits</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">On the security of public key protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dolev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="198" to="207" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">A Practical Introduction to PSL</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Eisner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fisman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Characterizing correctness properties of parallel programs using fixpoints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Int. Colloq. on Automata, Languages, and Programming</title>
		<meeting>7th Int. Colloq. on Automata, Languages, and Programming</meeting>
		<imprint>
			<date type="published" when="1980" />
			<biblScope unit="page" from="169" to="181" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Sometimes and not never revisited: On branching versus linear time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Y</forename><surname>Halpern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="151" to="178" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Modalities for model checking: Branching time logic strikes back</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-L</forename><surname>Lei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th ACM Symp. on Principles of Programming Languages</title>
		<meeting>12th ACM Symp. on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1985" />
			<biblScope unit="page" from="84" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Quantitative temporal reasoning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">K</forename><surname>Mok</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">P</forename><surname>Sistla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Srinivasan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc 2nd Int. Conf. on Computer Aided Verification</title>
		<meeting>2nd Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1990" />
			<biblScope unit="volume">531</biblScope>
			<biblScope unit="page" from="136" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Reasoning about Knowledge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Y</forename><surname>Halpern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Moses</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Bisimulation minimization and symbolic model checking. Formal Methods in System Design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fisler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="39" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Model checking expands verification&apos;s scope. Electronic Engineering Today</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Goering</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Transition system specifications with negative premises</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">F</forename><surname>Groote</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">118</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="263" to="299" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Logic Synthesis and Verification Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">D</forename><surname>Hachtel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Kluwer Academic Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Reasoning About Uncertainty</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Y</forename><surname>Halpern</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, Mass.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">On ambiguities in the interpretation of game trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Y</forename><surname>Halpern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Games and Economic Behavior</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="66" to="96" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Algebraic Structure Theory of Sequential Machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hartmanis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Stearns</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1966" />
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Algebraic Theory of Processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hennessy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Algebraic laws for nondeterminism and concurrency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hennessy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="137" to="161" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Computing simulations on finite and infinite graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">W</forename><surname>Kopke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 36th IEEE Symp. on Foundations of Computer Science</title>
		<meeting>36th IEEE Symp. on Foundations of Computer Science</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="453" to="462" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Communicating Sequential Processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985" />
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Formal verification of out-of-order execution with incremental flushing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">U</forename><surname>Skakkebaek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods in System Design</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="139" to="158" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">A fully abstract trace model for dataflow networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Jonsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th ACM Symp. on Principles of Programming Languages</title>
		<meeting>16th ACM Symp. on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1989" />
			<biblScope unit="page" from="155" to="165" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Bridging the gap between fair simulation and trace containment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kesten</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Piterman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc 15th Int. Conf. on Computer Aided Verification</title>
		<meeting>15th Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003" />
			<biblScope unit="volume">2725</biblScope>
			<biblScope unit="page" from="381" to="393" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Is abstraction the key to computing? Comm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
			<publisher>ACM</publisher>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="36" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">From liveness to promptness</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Kupferman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Piterman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th Int&apos;l Conf. on Computer-Aided Verification</title>
		<meeting>19th Int&apos;l Conf. on Computer-Aided Verification</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007" />
			<biblScope unit="volume">4590</biblScope>
			<biblScope unit="page" from="406" to="419" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Sometimes&quot; is sometimes &quot;not never&quot; -on the temporal logic of programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th ACM Symp. on Principles of Programming Languages</title>
		<meeting>7th ACM Symp. on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1980" />
			<biblScope unit="page" from="174" to="185" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Checking that finite state concurrent programs satisfy their linear specification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Lichtenstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th ACM Symp. on Principles of Programming Languages</title>
		<meeting>12th ACM Symp. on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1985" />
			<biblScope unit="page" from="97" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">Distributed Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">A</forename><surname>Lynch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">An introduction to input/output automata</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">A</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Tuttle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CWI Quarterly</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="219" to="246" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">Trace, failure and testing equivalences for communicating processes. Int&apos;l J. of Parallel Programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">G</forename><surname>Main</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="383" to="400" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Correctness of pipelined machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Manolios</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Int&apos;l Conf. on Formal Methods in Computer-Aided Design</title>
		<meeting>3rd Int&apos;l Conf. on Formal Methods in Computer-Aided Design</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000" />
			<biblScope unit="volume">1954</biblScope>
			<biblScope unit="page" from="161" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">Nonmonotonic Logic: Context-Dependent Reasoning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">W</forename><surname>Marek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Trusczynski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Circumscription -a form of non-monotonic reasoning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mccarthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="27" to="39" />
			<date type="published" when="1980" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<title level="m" type="main">Symbolic Model Checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
			<publisher>Kluwer Academic Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Processes: a mathematical model of computing agents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic Colloquium</title>
		<imprint>
			<publisher>North Holland</publisher>
			<date type="published" when="1975" />
			<biblScope unit="page" from="157" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">A Calculus of Communicating Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">92</biblScope>
			<date type="published" when="1980" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<monogr>
		<title level="m" type="main">Communication and Concurrency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Specification-oriented semantics for communicating processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">R</forename><surname>Olderog</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="9" to="66" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Concurrency and automata on infinite sequences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th GI Conf. on Theoretical Computer Science</title>
		<editor>P. Deussen</editor>
		<meeting>5th GI Conf. on Theoretical Computer Science<address><addrLine>Berlin/New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1981" />
			<biblScope unit="volume">104</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Linear and branching structures in the semantics and logics of reactive systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th Int. Colloq. on Automata, Languages, and Programming</title>
		<meeting>12th Int. Colloq. on Automata, Languages, and Programming</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1985" />
			<biblScope unit="volume">194</biblScope>
			<biblScope unit="page" from="15" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Specification and verification of concurrent systems in Cesar</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename><surname>Queille</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th ACM Symp. on Principles of Programming Languages</title>
		<meeting>8th ACM Symp. on Principles of Programming Languages</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1982" />
			<biblScope unit="volume">137</biblScope>
			<biblScope unit="page" from="337" to="351" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">The complexity of propositional linear temporal logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">P</forename><surname>Sistla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="733" to="749" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Comparing linear and branching time temporal logics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stirling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Temporal Logic in Specification</title>
		<editor>B. Banieqbal, H. Barringer, and A. Pnueli</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1987" />
			<biblScope unit="volume">398</biblScope>
			<biblScope unit="page" from="1" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">The joys of bisimulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stirling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">23th Int. Symp. on Mathematical Foundations of Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998" />
			<biblScope unit="volume">1450</biblScope>
			<biblScope unit="page" from="142" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">On the relationship between process algebra and input/output automata</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">W</forename><surname>Vaandrager</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th IEEE Symp. on Logic in Computer Science</title>
		<meeting>6th IEEE Symp. on Logic in Computer Science</meeting>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="387" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">The linear time -branching time spectrum I; the semantics of concrete, sequential processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Van Glabbeek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Process Algebra</title>
		<editor>J.A. Bergstra, A. Ponse, and S.A. Smolka</editor>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="3" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">What is branching time and why to use it?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Van Glabbeek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Current Trends in Theoretical Computer Science; Entering the 21st Century</title>
		<editor>G. Paun, G. Rozenberg, and A. Salomaa</editor>
		<imprint>
			<publisher>World Scientific</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="469" to="479" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Linear vs. branching time: A complexity-theoretic perspective</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 13th IEEE Sym.. on Logic in Computer Science</title>
		<meeting>13th IEEE Sym.. on Logic in Computer Science</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="394" to="405" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Sometimes and not never re-revisited: on branching vs. linear time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 9th Int&apos;l Conf. on Concurrency Theory, Lecture Notes in Computer Science 1466</title>
		<editor>D. Sangiorgi and R. de Simone</editor>
		<meeting>9th Int&apos;l Conf. on Concurrency Theory, Lecture Notes in Computer Science 1466</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Branching vs. linear time: Final showdown</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Int. Conf. on Tools and Algorithms for the Construction and Analysis of Systems</title>
		<meeting>7th Int. Conf. on Tools and Algorithms for the Construction and Analysis of Systems</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001" />
			<biblScope unit="volume">2031</biblScope>
			<biblScope unit="page" from="1" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">An automata-theoretic approach to automatic program verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Wolper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st IEEE Symp. on Logic in Computer Science</title>
		<meeting>1st IEEE Symp. on Logic in Computer Science</meeting>
		<imprint>
			<date type="published" when="1986" />
			<biblScope unit="page" from="332" to="344" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<monogr>
		<title level="m" type="main">A Practical Guide for SystemVerilog Assertions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Vijayaraghavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ramanathan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<monogr>
		<title level="m" type="main">The Formal Semantics of Programming Languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Winskel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Flow faster: Efficient decision algorithms for probabilistic simulations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hermanns</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Eisenbrand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">N</forename><surname>Jansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 13th Int&apos;l Conf. on Tools and Algorithms for the Construction and Analysis of Systems</title>
		<meeting>13th Int&apos;l Conf. on Tools and Algorithms for the Construction and Analysis of Systems</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007" />
			<biblScope unit="volume">4424</biblScope>
			<biblScope unit="page" from="155" to="169" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
