<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:53+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Noncanonical LALR(1) Parsing *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sylvain</forename><surname>Schmitz</surname></persName>
							<email>schmitz@i3s.unice.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">Laboratoire I3S</orgName>
								<orgName type="institution">Université de Nice -Sophia Antipolis &amp; CNRS</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Noncanonical LALR(1) Parsing *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1007/11779148</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Noncanonical parser, deterministic parser, LALR, two-stack automaton ACM categories: D31 [Programming Languages]: Formal Definitions and Theory-Syntax</term>
					<term>D34 [Programming Languages]: Processors- Parsing</term>
					<term>F42 [Mathematical Logic and Formal Languages]: Grammars and Other Rewriting Systems-Parsing</term>
				</keywords>
			</textClass>
			<abstract>
				<p>This paper addresses the longstanding problem of the recognition limitations of classical LALR(1) parser generators by proposing the usage of noncanonical parsers. To this end, we present a definition of noncanon-ical LALR(1) parsers, NLALR(1). The class of grammars accepted by NLALR(1) parsers is a proper superclass of the NSLR(1) and LALR(1) grammar classes. Among the recognized languages are some nondeter-ministic languages. The proposed parsers retain many of the qualities of canonical LALR(1) parsers: they are deterministic, easy to construct, and run in linear time. We argue that they could provide the basis for a range of powerful noncanonical parsers.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Testimonies abound on the shortcomings of classical LALR(1) parser generators like YACC <ref type="bibr" target="#b8">[9]</ref>. The problem lies in the large expressivity gap between what can be specified using the context-free grammar they are fed with, and what can actually be parsed by the LALR(1) automaton they produce. Transforming a grammar until its LALR(1) parser becomes deterministic is arduous, and can obfuscate the attached semantics; moreover, some languages are simply not deterministic.</p><p>The expressivity gap vanishes when general parsers <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b14">15]</ref> are preferred. Such a choice is however done at the expense of the detection of ambiguities. While this might seem acceptable for well established languages, for which the scrutiny of many implementors has pinpointed all ambiguous constructs, there always remains a risk of runtime problems if an unexpected ambiguity appears. The avoidance of such problems is clearly a desirable guarantee, thus motivating our option of restricting to some subclass of the unambiguous grammars.</p><p>This paper advocates an almost forgotten way of diminishing the expressivity gap: the usage of noncanonical parsers. We apply it to LALR(1) parsing by means of a generic construction. Therefore, we also allow immediate application to other LR-based parsing methods.</p><p>Noncanonical parsers have been thoroughly investigated on a theoretical level <ref type="bibr" target="#b11">[12]</ref>. Surprisingly, there are very few practical noncanonical parsing methods, and their formal study remains largely unexplored. Indeed, the only one of clear practical interest is an extension to SLR(1) parsing <ref type="bibr" target="#b12">[13]</ref>. Noncanonical parsers are however a powerful means of reducing the expressivity gap, while still rejecting any ambiguous syntax. In this they can be compared to LALR(k) parsers with k &gt; 1 <ref type="bibr" target="#b2">[3]</ref>, or, to a larger extent, to parsers allowing unbounded regular lookaheads <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b6">7]</ref>. Like the latter, noncanonical parsers can recognize nondeterministic languages. The classes of grammars accepted by both methods are incomparable in general, but the class of languages accepted by noncanonical parsers is strictly wider than the one accepted by regular lookahead parsers <ref type="bibr" target="#b11">[12]</ref>. And there is a winning argument in favor of noncanonical parsers: they can also increase the size of their lookahead window, possibly to an unbounded length <ref type="bibr" target="#b7">[8]</ref>. This point motivates our study of noncanonical LALR(1) parsers, since NSLR(1) parsers are unfit for such extensions: their lookahead computation is not contextual.</p><p>Also in contrast with NSLR(1), our definitions rely on a prefix equivalence relation: we use the LR(0) equivalence so that the resulting parsers are LALR(1), but finer equivalences could just as easily be used. Our specific choice of LALR(1) parsers can be explained by their wide adoption, their practical relevance, and the existence of efficient and broadly used algorithms for their generation <ref type="bibr" target="#b4">[5]</ref>. We express our computations in the same framework and obtain a simple and efficient practical construction. The additional complexity of generating a NLALR(1) parser instead of a LALR(1) or a NSLR(1) one, as well as the increase of the parser size and the overhead on parsing performances are all quite small. Therefore, the improved parsing power comes at a fairly reasonable price.</p><p>The paper is organized as follows: Section 2 briefly introduces noncanonical parsing; Section 3 recalls the formal details of the canonical LALR(1) definition, which will be extended for its noncanonical counterpart in Section 4. We refer the interested reader to a separate research report <ref type="bibr" target="#b9">[10]</ref> for a complete study, including grammar classes comparisons, alternative definitions for noncanonical LALR-based parsers, a concrete example of application, and omitted proofs.</p><p>Notation The basic terminology, definitions, and notational conventions used in this paper are classical <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b10">11]</ref>. Our context-free grammars are reduced and</p><formula xml:id="formula_0">augmented to G ′ = N ′ , T ′ , P ′ , S ′ = N ∪ {S ′ }, T ∪ {$}, P ∪ {S ′ →S$}, S ′ .</formula><p>As usual, A, B, C, . . . denote nonterminals in N ′ ; a, b, c, . . . denote terminals in T ′ ; u, v, w, . . . denote strings in T ′ * ; X, Y, Z denote symbols in V ′ ; α, β, γ, . . . denote strings in V ′ * ; ε is the empty string or empty sequence; k : α is the prefix of length k of string α. Rightmost derivations are denoted by ⇒ rm , whereas leftmost derivations are denoted by ⇒ lm . Noncanonical LALR(1) Parsing  </p><formula xml:id="formula_1">3 q1: B→a · {a} A→a · {b, a} q5: A→a · q4: D→ · b D→ · aD S→A · D S→AD · q10: S→BC · {$} C→C · A A→ · a q6: D→a · D D→ · aD D→ · b q8: D a A S B A S ′ → · S$ S→ · BC S→ · AD A→ · a B→ · a q11: q0: a C q9: S→B · C C→ · CA C→ · A A→ · a q3: C→CA · D→b · q12: D→aD · q2: S ′ →S · $</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Noncanonical Parsing</head><p>A bottom-up parser reverses the derivation steps which lead to the terminal string it parses. For most bottom-up parsers, including LALR ones, these derivations are rightmost, and therefore the reduced phrase is the leftmost one, called the handle of the sentential form. Noncanonical parsers allow the reduction of phrases which may not be handles <ref type="bibr" target="#b0">[1]</ref>. A noncanonical parser is able to suspend a reduction decision where its canonical counterpart would not be deterministic, explore the remaining input, perform some reductions, resume to the conflict point and use nonterminalsresulting from the reduction of a possibly unbounded amount of input-in its lookahead window to infer its parsing decisions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Parsing Example</head><p>Consider for instance grammar G 1 with rules S→BC | AD, A→a, B→a, C→CA | A, D→aD | b, generating the language</p><formula xml:id="formula_2">L G1 = aa + | aa * b.</formula><p>The state q 1 in the automaton of <ref type="figure" target="#fig_1">Figure 1a</ref> is inadequate: the parser is unable to decide between reductions A→a and B→a when the lookahead is a. We see on the derivation trees of <ref type="figure" target="#fig_1">Figure 1b</ref> that, in order to choose between the two reductions, the parser has to know if there is a b at the very end of the input. This need for an unbounded lookahead makes G 1 non-LR. A parser using a regular lookahead would solve the conflict by associating the distinct regular lookaheads a * b and a + $ with the reductions to A and B respectively.</p><p>However, we notice that a single lookahead symbol (D or C) is enough: if the parser is able to explore the context on the right of the conflict, and to parsing stack input stack actions q 0 aaa$ shift q 0 q 1 aa$ shift</p><p>The inadequate state q 1 is reached with lookahead a. The decision of reducing to A or B can be restated as the decision of reducing the right context to D or C. In order to perform the latter decision, we shift a and reach a state s 1 where we now expect a * b and a * $. We are pretty much in the same situation as before: s 1 is also inadequate. But we know that in front of b or $ a decision can be made:</p><formula xml:id="formula_3">q 0 q 1 s 1 a$ shift</formula><p>There is a new conflict between the reduction A→a and the shift of a to a position D→a · D.</p><p>We also shift this a. The expected right contexts are still a * b and a * $, so the shift brings us again to s 1 :</p><formula xml:id="formula_4">q 0 q 1 s 1 s 1 $ reduce using A→a</formula><p>The decision is made in front of $. We reduce the a represented by s 1 on top of the parsing stack, and push the reduced symbol A on top of the input stack:</p><formula xml:id="formula_5">q 0 q 1 s 1 A$ reduce using A→a</formula><p>Using this new lookahead, the parser is able to decide another reduction to A:</p><formula xml:id="formula_6">q 0 q 1 AA$ reduce using B→a</formula><p>We are now back in state q 1 . Clearly, there is no need to wait until we see a completely reduced symbol C in the lookahead window: A is already a symbol specific to the reduction to B:</p><formula xml:id="formula_7">q 0 BAA$ shift q 0 q 3 AA$ shift q 0 q 3 q 7 A$</formula><p>reduce using C→A q 0 q 3 CA$ shift q 0 q 3 q 6 A$ shift q 0 q 3 q 6 q 11 $ reduce using C→CA q 0 q 3 C$ shift q 0 q 3 q 6 $ reduce using S→BC q 0 S$ shift, and then accept <ref type="table">Table 1</ref>: The parse of the string aaa by the NLALR(1) parser for G 1 . reduce some other phrases, then, it will reduce this context to a D or a C. When coming back to the conflict point, it will see a D or a C in the lookahead window. <ref type="table">Table 1</ref> presents a noncanonical parse for a string in L G1 . The noncanonical machine is not very different from the canonical one, except that it uses two stacks. The additional stack, the input stack, contains the (possibly reduced) right context, whereas the other stack is the classical parsing stack. Reductions push the reduced nonterminal on top of the input stack. There is no goto operation per se: the nonterminal on top of the input stack either allows a parsing decision which had been delayed, or is simply shifted.</p><p>We will now see how to transform and extend the canonical LALR(1) parser of <ref type="figure" target="#fig_1">Figure 1a</ref> to perform these parsing steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Construction Principles</head><p>The LALR(1) construction relies heavily on the LR(0) automaton. This automaton provides a nice explanation for LALR lookahead sets: the symbols</p><formula xml:id="formula_8">q9 q12 D b a a A→a · {D, b} B→a · {C, A} s1 = {q5, q8}: q1: A→a · {A, $} D→a · D D→ · aD D→ · b</formula><p>Figure 2: State q 1 extended for noncanonical parsing.</p><p>in the lookahead set for some reduction are the symbols expected next by the LR(0) parser, should it really perform this reduction.</p><p>Let us compute the lookahead set for the reduction A→a in state q 1 . Should the LR(0) parser decide to reduce A→a, it would pop q 1 from the parsing stack (thus be in state q 0 ), and then push q 4 . We read directly on <ref type="figure" target="#fig_1">Figure 1a</ref> that three symbols are acceptable in q 4 : D, a and b. Similarly, the reduction B→a in q 1 has {C, A, a} for lookahead set, read directly from state q 3 .</p><p>The intersection of the lookahead sets for the reductions in q 1 is not empty: a appears in both, which means a conflict. Luckily enough, a is not a totally reduced symbol : D and C are reduced symbols, read from kernel items in q 4 and q 3 . The conflicting lookahead symbol a could be reduced, and later we might see a symbol on which we can make a decision instead. Thus, we shift the lookahead symbol a in order to reduce it and solve the conflict later. All the other symbols in the computed lookaheads allow to make a decision, so we leave them in the lookaheads sets, but we remove a from both sets.</p><p>Shifting a puts us in the same situation we would have been in if we had followed the transitions on a from both q 3 and q 4 , since the noncanonical generation simulates both reductions in q 1 . We create a noncanonical transition from q 1 on a to a noncanonical state s 1 = {q 5 , q 8 }, which will behave as the union of states q 5 and q 8 . State s 1 will thus allow a reduction using A→a inherited from q 5 , and the shifts of a, b and D inherited from q 8 . We therefore need to compute the lookaheads for reduction using A→a in q 5 . Using again the LR(0) simulation technique, we see on <ref type="figure" target="#fig_1">Figure 1a</ref> that this reduction would lead us to either q 7 or to q 11 . In both cases, the LR(0) automaton would perform a reduction to C that would lead next to q 6 . At this point, the LR(0) automaton expects either the end of file symbol $, should a reduction to S occur, or an A or an a. The complete lookahead set for the reduction A→a in q 8 is thus {A, a, $}.</p><p>The new state s 1 is also inadequate: with an a in the lookahead window, we cannot choose between the shift of a and the reduction A→a. As before, we create a new transition on a from s 1 to a noncanonical state s ′ 1 = {q 5 , q 8 }. State q 5 is the state accessed on a from q 6 . State q 8 is the state accessed from q 8 if we simulate a shift of symbol a.</p><p>State s ′ 1 is the same as state s 1 , and we merge them. The noncanonical computation is now finished. <ref type="figure" target="#fig_5">Figure 2</ref> sums up how state q 1 has been transformed and extended. Note that we just use the set {q 5 , q 8 } in a noncanonical LALR(1) automaton; items represented in <ref type="figure" target="#fig_5">Figure 2</ref> are only there to ease understanding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">LALR(1) Parsers</head><p>LALR parsers were introduced as practical parsers for deterministic languages. Rather than building an exponential number of LR(k) states, LALR(k) parsers add lookahead sets to the actions of the small LR(0) parser. We briefly recall some important definitions and results on LR(0) and LALR(1) parsers.</p><p>Valid Items and Prefixes A dotted production A→α · β of G is a valid LR <ref type="formula">(0)</ref> item for string γ in V ′ * if</p><formula xml:id="formula_9">S ′ ⇒ rm * δAz⇒ rm δαβz = γβz.<label>(1)</label></formula><p>If such a derivation holds in G, then γ in V ′ * is a valid prefix. The set of valid items for a given string γ in V ′ * is denoted by Valid(γ). Two strings δ and γ are equivalent if and only if they have the same valid items.</p><p>The valid item sets are obtained through the following computations:</p><formula xml:id="formula_10">Kernel(ε) = {S ′ → · S$},<label>(2)</label></formula><formula xml:id="formula_11">Kernel(γX) = {A→αX · β | A→α · Xβ ∈ Valid(γ)},<label>(3)</label></formula><formula xml:id="formula_12">Valid(γ) = Kernel(γ) ∪ {B→ · ω | A→α · Bβ ∈ Valid(γ)}.<label>(4)</label></formula><p>LR <ref type="formula">(</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">NLALR(1) Parsers</head><p>There is a number of differences between the LALR(1) and NLALR(1) definitions. The most visible one is that we accept nonterminals in our lookahead sets. We also want to know which lookahead symbols are totally reduced. Finally, we are adding new states, which are sets of LR <ref type="formula">(0)</ref> states. Therefore, the objects in most of our computations will be LR(0) states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Valid Covers</head><p>We have recalled in the previous section that LR(0) states can be viewed as collections of valid prefixes. A similar definition for NLALR(1) states would be nice. However, due to the suspended parsing actions, the language of all prefixes accepted by a noncanonical parser is no longer a regular language. This means the parser will only have a regular approximation of the exact parsing stack language. The noncanonical states, being sets of LR(0) states (i.e., sets of equivalence classes on valid prefixes), provide this approximation. We therefore define valid covers as valid prefixes covering the parsing stack language.</p><p>Definition 1 String γ is a valid cover in G for string δ if and only if γ is a valid prefix and γ⇒ * δ. We writê δ to denote some cover of δ and Cover(L) to denote the set of all valid covers for the set of strings L.</p><p>Remember for instance configuration q 0 q 1 aa$ from <ref type="table">Table 1</ref>. This configuration leads to pushing state s 1 = {q 5 , q 8 }, where both valid prefixes (B|BC)a and Aa * a of q 5 and q 8 are valid covers for the actual parsing stack prefix aa. Thus in s 1 we cover the parsing stack prefix by (B | BC | Aa * )a.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Noncanonical Lookaheads</head><p>Noncanonical lookaheads are symbols in V ′ . Adapting the computation of the LALR(1) lookahead sets is simple, but a few points deserve some explanations.</p><p>First of all, noncanonical lookahead symbols have to be non null, i.e. X is non null if X⇒ * ax. Indeed, null symbols do not provide any additional right context information-worse, they can hide it. If we consider that we always perform a reduction at the earliest parsing stage possible, then they will never appear in a lookahead window.</p><p>Totally Reduced Lookaheads Totally reduced lookaheads form a subset of the noncanonical lookahead set such that none of its elements can be further reduced. A conflict with a totally reduced symbol as lookahead of a reduction cannot be solved by a noncanonical exploration of the right context, since there is no hope of ever reducing it any further.</p><p>We define here totally reduced lookaheads as non null symbols which can follow the right part of the offending rule in a leftmost derivation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2</head><p>The set of totally reduced lookaheads for a reduction A→α in LR(0) state q is defined by RLA(q, A→α) = {X | S ′ ⇒ lm * zAγXω, γ⇒ * ε, X⇒ * ax, and q = [ˆ zα]}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Derived Lookaheads</head><p>The derived lookahead symbols are simply defined by extending (5) to the set of all non null symbols in V .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3</head><p>The set of derived lookaheads for a reduction A→α in LR(0) state q is defined by DLA(q, A→α) = {X | S ′ ⇒ * δAXω, X⇒ * ax, and q = [ ˆ δα]}.</p><p>We obviously have that</p><formula xml:id="formula_14">LA(q, A→α) = DLA(q, A→α) ∩ T ′ .<label>(6)</label></formula><p>Conflicting Lookahead Symbols Last, we need to compute which lookahead symbols would make the state inadequate. A noncanonical exploration of the right context is required for these symbols. They appear in the derived lookahead sets of several reductions and/or are transition labels. However, the totally reduced lookaheads of a reduction are not part of this lookahead set, for if they are involved in a conflict, then there is no hope of being able to solve it.</p><p>Definition 4 Conflicts lookahead set for a reduction using A→α in set s of LR <ref type="formula">(0)</ref> states is defined as CLA(s, A→α) = {X ∈ DLA(q, A→α) | q ∈ s, X 񮽙 ∈ RLA(q, A→α), (q, X) or (∃p ∈ s, ∃B→β 񮽙 = A→α ∈ P, X ∈ DLA(p, B→β))}.</p><p>We then define the noncanonical lookahead set for a reduction using A→α in set s of LR <ref type="formula">(0)</ref>  We illustrate these definitions by computing the lookahead sets for the reduction using A→a in state s 1 = {q 5 , q 8 } as in Section 2.2: RLA(q 5 , A→a) = {A, $}, DLA(q 5 , A→a) = {A, a, $}, CLA(s 1 , A→a) = {a} and NLA(s 1 , A→a) = {A, $}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Noncanonical States</head><p>We said at the beginning of this section that states in the NLALR(1) automaton were in fact sets of LR(0) states. We denote by δ the noncanonical state accessed upon reading string δ in V ′ * .</p><p>Definition 5 Noncanonical state δ is the set of LR(0) states defined by</p><formula xml:id="formula_15">ε ={[ε]} and δX = {[ ˆ γAX] | X ∈ CLA(δ, A→α), [ˆ γα] ∈ δ} ∪ {[ϕX] | [ϕ] ∈ δ}.</formula><p>Noncanonical transition from δ to δX on symbol X, denoted by (δ, X), exists if and only if δX 񮽙 = ∅. Reduction (δ, A→α) exists if and only if there exists a reduction (q, A→α) and q is in δ.</p><p>Note that these definitions remain valid for plain LALR(1) states since, in absence of a conflict, a noncanonical state is a singleton set containing the corresponding LR(0) state.</p><p>A simple induction on the length of δ shows that the LR(0) states considered in the noncanonical state δ provide a valid cover for any accessing string of the noncanonical state. It basically means that the actions decided in a given noncanonical state make sense at least for a cover of the real sentential form prefix that is read.</p><p>The approximations done when covering the actual sentential form prefix are made on top of the previous approximations: with each new conflict, we need to find a new set of LR(0) states covering the parsing stack contents. This stacking is made obvious in the above definition when we writêwritê γAX. It means that NLALR(1) parsers are not prefix valid, but prefix cover valid.</p><p>Throughout this paper, we use the LR(0) automaton to approximate the prefix read so far. We could use more powerful methods-but it would not really be in the spirit of LALR parsing any longer; see <ref type="bibr" target="#b9">[10]</ref> for alternative methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">NLALR(1) Automata</head><p>Here we formalize noncanonical LALR(1) parsing machines. They are a special case of two-stack pushdown automata (2PDA). As said before, the additional stack serves as an input for the parser, and reductions push the reduced nonterminal on top of this stack. This behavior of reductions excepted, the definition of a NLALR(1) automaton is similar to the LALR(1) one.</p><p>Definition 6 Let M = (Q ∪ V ∪ {$, }, R) be a rewriting system. A configuration of M is a string of the form εX 1 . . . X 1 . . . X n ω$ where X 1 . . . X n and ω are strings in V * . We say that M is a NLALR(1) automaton if its initial configuration is εw$ with w the input string in T * , its final configuration is εS$, and if each rewriting rule in R is of the form</p><p>• shift X in state δ, defined if there is a transition (δ, X) δX ⊢ shift δδX,</p><p>• or reduce by rule A→X 1 . . . X n of P in state δX 1 . . . X n with lookahead X, defined if A→X 1 . . . X n is a reduction in δX 1 . . . X n and lookahead</p><formula xml:id="formula_16">X is in NLA(δX 1 . . . X n , A→X 1 . . . X n ) δX 1 . . . δX 1 . . . X n X ⊢ A→X 1 . . . Xn AX.</formula><p>The following rules illustrate Definition 6 on state s 1 of the NLALR(1) automaton for G 1 :</p><formula xml:id="formula_17">s 1 a ⊢ shift s 1 s 1 , s 1 b ⊢ shift s 1 {q 9 }, s 1 D ⊢ shift s 1 {q 12 }, s 1 A ⊢ A→a AA and s 1 $ ⊢ A→a A$.</formula><p>According to Definition 6, NLALR(1) automata are able to backtrack by a limited amount, corresponding to the length of their window, at reduction time only. We know that noncanonical parsers using a bounded lookahead window operate in linear time <ref type="bibr" target="#b11">[12]</ref>; the following theorem precisely shows that the total number of rules involved in the parsing of an input string is linear in respect with the number of reductions performed, which itself is linear with the input string length. This theorem uses an output effect τ which outputs the rules used for each reduction performed by M ; we then call (M, τ ) a NLALR(1) parser.</p><p>Theorem 1 Let G be a grammar and (M, τ ) its NLALR(1) parser. If π is a parse of w in M , then the number of parsing steps |π| is related to the number |τ (π)| of derivations producing w in G and to the length |w| of w by</p><formula xml:id="formula_18">|π| = 2|τ (π)| + |w|.</formula><p>Since all the conflict lookahead symbols are removed from the noncanonical lookahead sets NLA, the only possibility for the noncanonical automaton to be nondeterministic would be to have a totally reduced symbol causing a conflict. A context-free grammar G is NLALR(1) if its NLALR(1) automaton is deterministic, and thus if no totally reduced symbol can cause a conflict.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Computing the Lookaheads and Covers</head><p>The LALR(1) lookahead sets that are defined in Equation (5) can be expressed using the following definitions <ref type="bibr" target="#b4">[5]</ref>, where lookback is a relation between reductions and nonterminal LR(0) transitions, includes and reads are relations between nonterminal LR(0) transitions, and DR-standing for directly reads-is a function from nonterminal LR(0) transitions to sets of lookahead symbols.</p><formula xml:id="formula_19">([δα], A→α) lookback ([δ], A), (7) ([δβ], A) includes ([δ], B) iff B→βAγ and γ⇒ * ε, (8) ([δ], A) reads ([δA], C) iff ([δA], C) and C⇒ * ε, (9) DR([δ], A) = {a | ([δA], a)}.<label>(10)</label></formula><p>Using the above definitions, we can rewrite Equation <ref type="formula" target="#formula_13">(5)</ref> as</p><formula xml:id="formula_20">LA(q, A→α) = 񮽙 (q,A→α) lookback • includes * • reads * (r,C) DR(r, C).<label>(11)</label></formula><p>This computation for LALR(1) lookahead sets is highly efficient. It can entirely be performed on the LR(0) automaton, and the union can be interleaved with a fast transitive closure algorithm <ref type="bibr" target="#b13">[14]</ref> on the includes and reads relations.</p><p>Since we have a very efficient and widely adopted computation for the canonical LALR(1) lookahead sets, why not try to use it for the noncanonical ones?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2</head><p>RLA(q, A→α) = {X | X⇒ * ax, ψ⇒ * ε, C⇒ρB · ψXσ ∈ Kernel(δρB) and</p><formula xml:id="formula_21">(q, A→α) lookback • includes * ([δρ], B)}.</formula><p>This theorem is consistent with the description of Section 2.2, where we said that C was a totally reduced lookahead for reduction B→a in q 1 : item S→B · C is in the kernel of state q 3 accessed by (q 0 , B), and (q 1 , B→a) lookback (q 0 , B). DR(r, C).</p><p>We are still consistent with the description of Section 2.2 since, using this new definition of the DR function, DR(q 0 , B) is {a, C, A}.</p><p>To find the valid covers that approximate a sentential form prefix using the LR(0) automaton and to find the LALR lookahead sets wind up being very similar operations. This allows us to reuse our relational computations for the automaton construction itself, as illustrated by the following theorem.</p><p>Theorem 4 Noncanonical state δ is the set of LR(0) states defined by</p><formula xml:id="formula_22">ε ={[ε]} and δX = {[γCX] | X ∈ CLA(δ, A→α), q ∈ δ and (q, A→α) lookback • includes * • reads * ([γ], C)} ∪ {[ϕX] | [ϕ] ∈ δ}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Practical Construction Steps</head><p>We present here a more informal construction, with the main steps leading to the construction of a NLALR(1) parser, given the LR(0) automaton.</p><p>1. Associate a noncanonical state s = {q} with each LR(0) state q. This process always terminates since there is a bounded number of LR(0) states and thus a bounded number of noncanonical states.</p><p>Let us conclude this section with a few words on the size of the generated parsers. Since NLALR(1) states are sets of LR(0) states, we find an exponential function of the size of the LR(0) automaton as an upper bound on the size of the NLALR(1) automaton. This bound seems however pretty irrelevant in practice. The NLALR(1) parser generator needs to create a new state for each lookahead causing a conflict, which does not happen so often. All the grammars we studied created transitions to canonical states very quickly afterwards. Experimental results with NSLR(1) parsers show that the increase in size is negligible in practice <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>We have presented a construction for noncanonical LALR(1) parsers. Such parsers are practical for some difficult syntax problems. They improve on both noncanonical SLR(1) parsers and canonical LALR(1) parsers, and their generation is only slightly more complex while their size and their performances are comparable.</p><p>For practical uses, we feel we would need an unbounded lookahead version of NLALR parsers. Though the cost to pay might be a quadratic parsing time in the worst case, the freedom offered to the grammar writer would probably be worth it. The ability to specify finer equivalence relations instead of the LR(0) one would prove its usefulness in this setting where precision becomes critical.</p><p>In complement to previous theoretical work on noncanonical parsing <ref type="bibr" target="#b11">[12]</ref>, it would be interesting to formally study practical noncanonical parsers. To this end, we expect the concept of valid covers modulo an equivalence relation to be a good starting point.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The conflict position in state q 1 for G 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>0 )</head><label>0</label><figDesc>States LR automata are pushdown automata that use equivalence classes on valid prefixes as their stack alphabet Q. We therefore denote explicitly states of a LR parser as q = [δ], where δ is some valid prefix in q the state reached upon reading this prefix. For instance, in the automaton of Figure 1a, state q 2 is the equivalence class {S}, while state q 8 is the equivalence class described by the regular language Aa * a. A pair ([δ], X) in Q × V is a transition if and only if δX is a valid prefix. If this is the case, then [δX] is the state accessed upon reading δX, thus the notation [δX] also implies 1 a transition from [δ] on X, and [δα] a path on α. LALR(1) Automata The LALR(1) lookahead set of a reduction using A→α in state q is LA(q, A→α) = {1:z | S ′ ⇒ rm * δAz and q = [δα]}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>states as NLA(s, A→α) = 񮽙 q∈s DLA(q, A→α) − CLA(s, A→α).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Theorem 3</head><label>3</label><figDesc>Let us extend the directly reads function of (10) to DR([δ], A) = {X | ([δA], X) and X⇒ * ax}; then DLA(q, A→α) = 񮽙 (q,A→α) lookback • includes * • reads * (r,C)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>2 .</head><label>2</label><figDesc>Iterate while there exists an inadequate 2 state s: (a) if it has not been done before, compute the RLA and DLA lookahead sets for the reductions involved in the conflict; save their values for the reduction and LR(0) state involved; (b) compute the CLA and NLA lookahead sets for s; (c) set the lookaheads to NLA for the reduction actions in s; (d) • if the NLA lookahead sets leave the state inadequate, meaning there is a conflict on a totally reduced lookahead, then report the conflict, and use a conflict resolution policy or terminate with an error; • if CLA is not empty, create transitions on its symbols and create new states if no fusion occurs. New states get new transition and reduction sets computed from the LR(0) states they contain. If these new states result from shift/reduce conflicts, the transitions from s on the conflicting lookahead symbol now lead to the new states.</figDesc></figure>

			<note place="foot" n="1"> We always assume when writing [δX] that Valid(δX) is not the empty set.</note>

			<note place="foot" n="2"> We mean here inadequate in the LR(0) sense, thus no lookaheads need to be computed yet.</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The Theory of Parsing, Translation, and Compiling. Volume I: Parsing. Series in Automatic Computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alfred</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<idno>1972. ISBN 0-13-914556-7</idno>
		<ptr target="http://portal.acm.org/citation.cfm?id=SERIES11430.578789" />
		<imprint>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Practical arbitrary lookahead LR parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manuel</forename><forename type="middle">E</forename><surname>Bermudez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karl</forename><forename type="middle">M</forename><surname>Schimpf</surname></persName>
		</author>
		<idno type="doi">0022-0000.doi:10.1016/0022-0000(90)90037-L</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="230" to="250" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">A Practical method for Constructing Efficient LALR(k) Parsers with Automatic Error Recovery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philippe</forename><surname>Charles</surname></persName>
		</author>
		<ptr target="http://jikes.sourceforge.net/documents/thesis.pdf" />
		<imprint>
			<date type="published" when="1991-05" />
		</imprint>
		<respStmt>
			<orgName>New York University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">LR-Regular grammars-an extension of LR(k) grammars</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rina</forename><surname>Karelčulikkarelˇkarelčulik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Cohen</surname></persName>
		</author>
		<idno type="doi">0022-0000.doi:10.1016/S0022-0000(73</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="80050" to="80059" />
			<date type="published" when="1973" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Efficient computation of LALR(1) look-ahead sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Deremer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Pennello</surname></persName>
		</author>
		<idno type="doi">0164-0925.doi:10.1145/69622.357187</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="615" to="649" />
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An efficient context-free parsing algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jay</forename><surname>Earley</surname></persName>
		</author>
		<idno type="doi">0001-0782.doi:10.1145/362007.362035</idno>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="94" to="102" />
			<date type="published" when="1970" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A bounded-connect construction for LR-Regular parsers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacques</forename><surname>Farré</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">José Fortes</forename><surname>Gálvez</surname></persName>
		</author>
		<ptr target="http://springerlink.com/content/e3e8g77kxevkyjfd" />
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<editor>Reinhard Wilhelm</editor>
		<imprint>
			<biblScope unit="volume">2027</biblScope>
			<biblScope unit="page" from="244" to="258" />
			<date type="published" when="2001" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Bounded-connect noncanonical discriminating-reverse parsers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacques</forename><surname>Farré</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">José Fortes</forename><surname>Gálvez</surname></persName>
		</author>
		<idno type="doi">0304-3975.doi:10.1016/j.tcs.2003.10.006</idno>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">313</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="73" to="91" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">YACC -yet another compiler compiler</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stephen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing science technical report</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<date type="published" when="1975-07" />
			<publisher>Murray Hill</publisher>
		</imprint>
		<respStmt>
			<orgName>AT&amp;T Bell Laboratories</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Noncanonical LALR(1) parsing. Technical Report I3S/RR-2005-21-FR, Laboratoire I3S</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sylvain</forename><surname>Schmitz</surname></persName>
		</author>
		<ptr target="http://www.i3s.unice.fr/∼mh/RR/2005/RR-05.21-S.SCHMITZ.pdf" />
		<imprint>
			<date type="published" when="2005-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">LR(k) and LL(k) Parsing</title>
		<idno>3-540-51732-4</idno>
	</analytic>
	<monogr>
		<title level="m">Seppo Sippu and Eljas Soisalon-Soininen. Parsing Theory</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1990" />
			<biblScope unit="volume">II</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Noncanonical extensions of bottom-up parsing techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">H</forename><surname>Szymanski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Williams</surname></persName>
		</author>
		<idno type="doi">0097-5397.doi:10.1137/0205019</idno>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="231" to="250" />
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kuo-Chung</forename><surname>Tai</surname></persName>
		</author>
		<idno type="doi">0164-0925.doi:10.1145/357073.357083</idno>
	</analytic>
	<monogr>
		<title level="j">Noncanonical SLR(1) grammars. ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="295" to="320" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Depth first search and linear graph algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
		<idno type="doi">0097-5397.doi:10.1137/0201010</idno>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="146" to="160" />
			<date type="published" when="1972" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Efficient Parsing for Natural Language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Masaru</forename><surname>Tomita</surname></persName>
		</author>
		<idno>ISBN 0-89838-202-5</idno>
		<imprint>
			<date type="published" when="1986" />
			<publisher>Kluwer Academic Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
