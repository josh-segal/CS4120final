<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T17:07+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Mondrix: Memory Isolation for Linux using Mondriaan Memory Protection</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>October 23-26, 2005</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emmett</forename><surname>Witchel</surname></persName>
							<email>witchel@cs.utexas.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Sciences</orgName>
								<orgName type="department" key="dep2">School of Electrical and Computer Engineering</orgName>
								<orgName type="laboratory">MIT Computer Science and Artificial Intelligence Laboratory Cambridge</orgName>
								<orgName type="institution" key="instit1">University of Texas at Austin Austin TX</orgName>
								<orgName type="institution" key="instit2">Purdue University West Lafayette</orgName>
								<address>
									<postCode>78712, 47907, 02139</postCode>
									<region>Indiana, MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Junghwan</forename><surname>Rhee</surname></persName>
							<email>rhee@purdue.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Sciences</orgName>
								<orgName type="department" key="dep2">School of Electrical and Computer Engineering</orgName>
								<orgName type="laboratory">MIT Computer Science and Artificial Intelligence Laboratory Cambridge</orgName>
								<orgName type="institution" key="instit1">University of Texas at Austin Austin TX</orgName>
								<orgName type="institution" key="instit2">Purdue University West Lafayette</orgName>
								<address>
									<postCode>78712, 47907, 02139</postCode>
									<region>Indiana, MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Asanovi´c</forename><surname>Krste</surname></persName>
							<email>krste@csail.mit.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Sciences</orgName>
								<orgName type="department" key="dep2">School of Electrical and Computer Engineering</orgName>
								<orgName type="laboratory">MIT Computer Science and Artificial Intelligence Laboratory Cambridge</orgName>
								<orgName type="institution" key="instit1">University of Texas at Austin Austin TX</orgName>
								<orgName type="institution" key="instit2">Purdue University West Lafayette</orgName>
								<address>
									<postCode>78712, 47907, 02139</postCode>
									<region>Indiana, MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Asanovi´c</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Sciences</orgName>
								<orgName type="department" key="dep2">School of Electrical and Computer Engineering</orgName>
								<orgName type="laboratory">MIT Computer Science and Artificial Intelligence Laboratory Cambridge</orgName>
								<orgName type="institution" key="instit1">University of Texas at Austin Austin TX</orgName>
								<orgName type="institution" key="instit2">Purdue University West Lafayette</orgName>
								<address>
									<postCode>78712, 47907, 02139</postCode>
									<region>Indiana, MA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Mondrix: Memory Isolation for Linux using Mondriaan Memory Protection</title>
					</analytic>
					<monogr>
						<title level="m">SOSP&apos;05</title>
						<meeting> <address><addrLine>Brighton, United Kingdom</addrLine></address>
						</meeting>
						<imprint>
							<date type="published">October 23-26, 2005</date>
						</imprint>
					</monogr>
					<note>Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee.-5/05/0010 ...$5.00.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>Categories and Subject Descriptors D45 [Operating systems]: Reliability General Terms Reliability Keywords fine-grained memory protection *</keywords>
			</textClass>
			<abstract>
				<p>This paper presents the design and an evaluation of Mondrix, a version of the Linux kernel with Mondriaan Memory Protection (MMP). MMP is a combination of hardware and software that provides efficient fine-grained memory protection between multiple protection domains sharing a linear address space. Mondrix uses MMP to enforce isolation between kernel modules which helps detect bugs, limits their damage, and improves kernel robustness and maintainability. During development, MMP exposed two kernel bugs in common, heavily-tested code, and during fault injection experiments, it prevented three of five file system corruptions. The Mondrix implementation demonstrates how MMP can bring memory isolation to modules that already exist in a large software application. It shows the benefit of isolation for robustness and error detection and prevention, while validating previous claims that the protection abstractions MMP offers are a good fit for software. This paper describes the design of the memory supervisor, the kernel module which implements permissions policy. We present an evaluation of Mondrix using full-system simulation of large kernel-intensive workloads. Experiments with several benchmarks where MMP was used extensively indicate the additional space taken by the MMP data structures reduce the kernel&apos;s free memory by less than 10%, and the kernel&apos;s runtime increases less than 15% relative to an unmodified kernel.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Reliability and security are quickly becoming users' biggest concerns due to the increasing reliance on computers in all areas of society. Operating systems written in unsafe languages are efficient, but they crash too often and are susceptible to malicious attacks. Crashes and security breaches incur large costs in lost productivity and increased system administration overhead. Many of these incidents could be reduced in severity or even avoided, if a fault in a single software module was caught before it propagated throughout the system. Faults often lead to illegal memory accesses, and wild writes can cause further modules to fail. Memory isolation, which forbids one software module from reading or writing another module's memory without permission, is therefore a crucial component of a robust system.</p><p>Mondriaan Memory Protection (MMP) <ref type="bibr" target="#b42">[43]</ref> is a recently proposed fine-grained memory protection scheme that provides wordgranularity memory isolation in hardware. Previous work investigated the use of MMP for user-level applications <ref type="bibr" target="#b42">[43]</ref> and sketched how an operating system might employ MMP <ref type="bibr" target="#b41">[42]</ref>. In this paper, we present the design and evaluation of Mondrix, a version of the Linux 2.4.19 kernel enhanced with MMP to provide memory isolation between kernel modules. Mondrix runs on top of versions of the SimICS <ref type="bibr" target="#b26">[27]</ref> and Bochs <ref type="bibr" target="#b22">[23]</ref> system simulators, which are modified to model MMP hardware. The main contributions of this paper are:</p><p>• The design and implementation of a fine-grained kernel memory protection system. A small module containing interfaces to MMP hardware and the permissions tables forms the most privileged layer and lives underneath the rest of the kernel. More complex permission abstractions and management policies are layered in separate higher-level modules.</p><p>• Implementation of a compartmentalized Linux kernel with eleven isolated modules, including ad-hoc modules already present in the Linux kernel such as unix domain sockets, a network device driver split into two modules, and a disk device driver split into three modules.</p><p>• Several modifications to the original MMP hardware design to improve cross-domain calls and stack permission handling.</p><p>• An evaluation of the performance and space overheads of the full Mondrix implementation for a range of kernel-intensive application workloads. The results show that Mondrix executes less than 15% more cycles (instructions and memory stalls) than an unmodified kernel, and its data structures reduce the amount of kernel free memory by less than 10%.</p><p>• Results from fault-injection experiments showing how Mondrix can catch errors before they cause data corruption. Five fault-injection experiments caused file corruption in Linux, and Mondrix prevented file system corruption in three of those five experiments.</p><p>One advantage of MMP hardware memory isolation is that it is compatible with existing legacy code written in unsafe languages. An alternative approach is to rewrite system code in a safe language, such as Java or C#, that use a combination of a strict type system and garbage collection to avoid a large class of memory access errors encountered at run time. For example, Microsoft is using safe languages <ref type="bibr" target="#b10">[11]</ref> in their next generation Windows Vista operating system. Safe languages can incur large performance overheads and require unsafe extensions to interface to the lower levels of a machine (though such extensions can be used sparingly). High performance implementations of safe languages require optimizing compilers and run-time systems, which increases the amount of code that must be trusted.</p><p>Although MMP requires a hardware change, it is backwards compatible with existing instruction sets and compiled user applications. The recent introduction of the NX bit <ref type="bibr" target="#b1">[2]</ref> to the x86 architecture by AMD and Intel indicates that manufacturers are willing to add compatible hardware features to improve software robustness. We focus on the application of MMP to a conventional operating system in this paper, but note that MMP is designed to provide protected sharing for many kinds of large extensible software systems, such as web browsers and web servers. Mondrix could be extended to exploit additional MMP features, for example to provide more efficient yet safe user-level interfaces to kernel data structures.</p><p>Preventing illegal memory accesses is not sufficient to guarantee system reliability and security. Other failure modes include API violations, excessive resource consumption, and synchronization or locking errors. New static analysis <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b2">3]</ref> techniques can help locate many of these other sources of software failure as well as some types of illegal memory access. But these analyses can sometimes find thousands of possible violations, overwhelming the ability of developers to fix them all. Also, most analyses are unsound, so they do not find all errors. Although these techniques are useful, they are complementary to dynamic checking of memory accesses.</p><p>Our fault injections experiments validate the usefulness of memory isolation in detecting failures and preventing failures from damaging system state. Mondrix is able to eliminate file system corruption in three of five cases, and it detects memory use violations in 90% of executions that lead to kernel panics.</p><p>The paper takes a bottom-up approach in describing the Mondrix design. We begin in Section 2 with a review of the primitives provided by the MMP hardware. We present new schemes to provide protected control transfer between domains and to manage stack permissions, influenced by our experience in developing Mondrix. Section 3 presents for the first time the design and implementation of the memory supervisor, a software layer that sits below the kernel and which uses the raw MMP hardware to provide a number of permissions abstractions for higher levels of software. Section 4 describes the modifications made to Linux, including how the kernel shares memory with protected modules for disk, networking, and other services. We also describe policies for managing protected memory regions and for handling interrupts safely. We used full-system simulation with a modified SimICS and Bochs x86 simulator to evaluate the performance of Mondrix (Section 5). Under a variety of kernel-intensive workloads, we observe less than a 10% reduction in kernel free memory, and a slowdown of less than 15%. We review related work in Section 6 before concluding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">MMP FEATURES</head><p>The three main features of MMP are memory protection, protected cross-domain calling, and stack protection. This section briefly reviews the main MMP features, and describes how MMP has been modified from the original design <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b41">42]</ref> to support Mondrix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Memory protection</head><p>MMP adopts Lampson's term <ref type="bibr" target="#b21">[22]</ref>, protection domain, to refer to a lightweight context that determines permissions for executing code. As shown in <ref type="figure" target="#fig_0">Figure 1</ref>, MMP overlays an address space with multiple disjoint protection domains, each with a unique set of permissions. Each column represents one protection domain, while each row represents a range of memory addresses. In Mondrix, the address space is the kernel virtual address space. There is no domain-specific portion of an address; a pointer refers to the same kernel memory location from any domain. Every thread is associated with exactly one protection domain at any point in its execution, and any number of threads may be in the same protection domain at the same time. The color in each box represents the permissions that a protection domain has to access the region of memory in the box. MMP allows any number of memory regions within a domain, and each region can begin and end at any word-aligned address.</p><p>The MMP implementation <ref type="figure">(Figure 2</ref>) stores compressed permissions information in permissions tables held in main memory, and caches the tables using an on-chip protection lookaside buffer (PLB) <ref type="bibr" target="#b20">[21]</ref>. MMP hardware in the processor pipeline uses the PLB to check permissions on every load, store, and instruction fetch, and raises a protection exception if the executing thread does not have permissions for an attempted access. Implementing memory permission checks has limited impact on a typical out-of-order superscalar processor pipeline. The PLB is comparable in size and access latency to a conventional TLB, and the PLB hit rate is high <ref type="bibr" target="#b42">[43]</ref>. Because permission checks are separate from address translation, data can be speculatively read and used before permissions checks are completed. Permissions checks need only be completed prior to final instruction commit. The permissions table is the only in-memory structure whose size is large and whose size scales with application memory use.</p><p>MMP preserves the user/kernel mode distinction, where kernel mode enables access to privileged control registers and privileged instructions. The CPU encodes whether a domain is user or ker- <ref type="figure">Figure 2</ref>: The major components of the Mondriaan memory protection system. On a memory reference, the processor checks permissions for the effective address in the protection lookaside buffer (PLB). In parallel, accesses are range checked with the registers that delimit permissions for a region of the stack: sb, fb, and sl. If permissions are not found in either check then hardware or software looks up the effective address in the memory-resident permissions table. The permissions come from the stack protection table if the miss address is a stack address, otherwise they come from the protection table. The reload mechanism caches the matching entry from the permissions table in the PLB. The gate lookaside buffer (GLB) caches information for cross-domain call entry sites held in the switch &amp; return gate table. The CDST register points to the current top of the cross-domain call stack.</p><p>nel mode using the high bit of the PD-ID control register (a zero high bit implies a kernel domain). Protection domain 0 is used to manage the permissions tables for other domains, and can access all of memory without the mediation of a permissions table. Only the bottom half of the memory supervisor (see Section 3) resides in PD 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Cross-domain calling</head><p>Cross-domain calling in MMP provides a two-way guarantee; first that a thread can only enter a callee's domain at specified points (switch gates), and second that a thread returning from a cross-domain call will return to the caller's domain only at the instruction following the call to the corresponding switch gate. The processor switches domains when a call instruction's target has a switch gate permission, or it executes a return instruction marked with a return gate permission. The programmer places switch gates on the first instruction of a routine (which is why they are called switch gates, not call gates), so call sites do not have to be identified when exporting a function, and a single indirect call instruction can call both exported and non-exported routines. The programmer places return gates on the return instruction of an exported routine.</p><p>Gates require more information than regular memory permissions, and so are stored in a separate gate table and cached with a separate gate lookaside buffer (GLB) <ref type="figure">(Figure 2</ref>). This is an improvement over the previous MMP design that did not dedicate a table to gates. The number of gates, even for a large system, is low (less than 1,000 in Mondrix), because modules tend to have many  <ref type="table">The format of entries in the gate table. The gate table  encodes cross-domain call points, with switch gates encoding  the callee's protection domain.</ref> more internal functions than exported entry points <ref type="table">. The gate table  is stored in memory in an open hash table to</ref> allow rapid retrieval on a GLB miss. Each entry has the format shown in <ref type="figure" target="#fig_1">Figure 3</ref>. The first word contains the byte address of the gate instruction. The second word of the entry specifies the gate type, and if it is a switch gate, the destination protection domain.</p><p>MMP gates are simpler than those present in the x86, IA-64 <ref type="bibr" target="#b9">[10]</ref>, or PA-RISC because they do not cause a stack switch. They are similar in spirit, though simpler in implementation to call and return capabilities (used in EROS <ref type="bibr" target="#b32">[33]</ref>), and capabilities used in Multics <ref type="bibr" target="#b30">[31]</ref>. By enforcing call/return semantics on cross-domain calls, MMP limits the possible implementations of exception mechanisms <ref type="bibr" target="#b29">[30]</ref>. Exception management techniques are beyond the scope of this paper, but we note that call/return was sufficient to handle exception support for Mondrix.</p><p>The previous MMP design required hardware for the crossdomain call stack. The Mondrix version of MMP uses protected memory in the user area, that the hardware can write, but software (outside of the memory supervisor) can only read. Mondrix MMP retains the CDST register that points to the current top of the crossdomain call stack. The Mondrix memory supervisor saves and restores this register on a context switch.</p><p>For each cross domain call, the processor pushes the return address of the call instruction whose target is the switch gate, the current protection domain ID, and the current value of the fb register (an addition from previous work whose function is explained in the next section). These values are popped and verified on a cross-domain return. A domain can establish which domain called it by reading the cross-domain call stack, and it can trust the value because the cross-domain call stack is only writable by hardware.</p><p>One issue in Mondrix is cross-domain calls that do not change protection domain ID. The processor executes return gates in the callee's domain, which causes problems if a domain calls a function that it also exports. Consider, for example, kmalloc. The core kernel exports this routine to modules, so it must place a return gate on its last instruction. If the kernel were to call it via a regular function call, the instruction with the return gate would fault because a regular function call does not push the state needed for a cross-domain return onto the cross-domain call stack. Therefore a domain must either mark the entry points to exported functions with a switch gate, or it must duplicate exported functions. We chose to mark exported functions with a switch gate, avoiding the task of classifying function calls into domain-crossing and non-domain-crossing. Unfortunately, this decision has the consequence of more than doubling the number of cross-domain calls (Section 5.2.1).</p><p>Cross-domain calls require modifications to the processor hardware. Each instruction fetch checks the GLB for the presence of a gate. Each instruction cache line has an additional bit indicating if there are any gates associated with instructions on that line. If the bit is clear, then no further action needs to be taken on a GLB miss. If the bit is set and the GLB misses, the GLB must be refilled from the gate table. If the bit is set and there is a hit in the GLB, the cached gate is used. Instruction cache lines are initially brought in after a miss with the "gate present" bit set, but the bit is cleared down if a subsequent GLB miss and gate table walk determines there are no gates on the line.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Stack permissions</head><p>Stack storage must be protected differently from other memory, because stacks are associated with threads that can move between protection domains. The Mondrix MMP stack permissions design fixes problems in the previous MMP designs <ref type="bibr" target="#b41">[42]</ref>, where different threads resident in the same protection domain had access to each other's stacks. This issue is addressed by adding more per-thread hardware.</p><p>Mondrix maintains two parallel forms of thread-local stack permissions. Stack permission registers designate stack frames in the current domain as readable and writable (between the frame base register (fb) and the stack limit register sl), and earlier frames (between the stack base register sb and fb) as read-only. Stacks grow down, so the stack base register is at a higher address than the stack limit register. A separate stack write permissions table allows individual words of earlier stack frames (between sb and fb) to be thread-writable (see <ref type="figure">Figure 2)</ref>. A stack location is writable if it lies between the read-only and read-write register addresses (fb and sl), or if its stack write permissions bit is set.</p><p>The stack registers and permission table support the common idioms of stack use. The registers allow read-write access to stack frames for the thread's execution in the current domain, and readonly access to previous frames. Stack accesses to the current frame and reads from previous frames are handled efficiently. The stack permissions table supports existing calling conventions with parameters that point to writable stack-allocated data structures. The stack write permissions table encodes whether a given stack address is writable by the thread, using one bit per word, and the contents of this table is cached in the PLB.</p><p>On a cross-domain call the hardware saves the current frame base on the cross-domain call stack, and the current stack pointer becomes the new frame base (unless the stack pointer points outside sb and sl in which case the processor faults). Cross-domain calls move all stack frames that were allocated in the previous domain into the read-only area between sb and fb.</p><p>The memory supervisor only allows a thread to grant write permissions on its current frame area, a thread may not grant itself write permissions on a previous domain's frames. The memory supervisor flushes stack permissions information from the PLB when a thread is descheduled, and also unloads and reloads a thread's stack permission register during context switches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">THE MEMORY SUPERVISOR</head><p>This section describes the features and implementation of the Mondrix memory supervisor, which was designed to easily slip "under" an existing kernel to form the most privileged software layer. The supervisor is split into two pieces, a top and a bottom. The bottom layer (which is not checked by MMP hardware) has the sole job of writing the permissions tables in memory. The top layer does everything else, including presenting a hardwareindependent memory protection interface to the rest of the kernel, enforcing memory protection policies, tracking memory sharing, and implementing group protection domains.</p><p>This section describes the top layer of the supervisor. The purpose of Mondrix is to provide memory isolation, and the memory supervisor enforces policies about memory sharing, such as a domain can't give itself write permission on a piece of memory that was exported to it read-only. If the top half of the supervisor decides a permissions request is valid, it passes the request to the bottom half which updates the protection tables.</p><p>This section defines several terms (including access and ownership) for memory use, and then presents the intuitions behind the supervisor's policies for memory sharing, as well as a detailed summary of of the policy <ref type="table" target="#tab_0">(Table 1</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Definitions for memory use</head><p>A region of memory can be accessed, each word of memory has a domain that owns it, and permission to access memory can be exported from one domain to another.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Access permissions</head><p>A domain's permission, gate, and stack tables jointly describe its access permissions, i.e., the operations it can perform on memory such as execute a return gate or write a location. We call memory accessible if there is some way for a domain to access it without causing a fault, i.e., by reading, writing, or executing it. Memory is shared when it is accessible by more than one domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Memory ownership</head><p>Memory ownership is a component of permissions policy that is implemented entirely within the memory supervisor. Ownership identifies the domain that has ultimate authority on permissions and use of a memory region. The address space is divided into non-overlapping regions, where each region is owned by exactly one protection domain. The supervisor itself owns all of memory initially. An owner can set arbitrary access permissions on memory that it owns, and can grant arbitrary access permissions or export permissions on that memory to other domains. For example, a domain that wants to generate code would give itself read-write permission on the buffer, write the code, then change its permissions to execute-read.</p><p>Memory ownership is much coarser grain than memory protection, and changes much less frequently. The supervisor maintains ownership information using a sorted list of memory regions and their owners.</p><p>In Mondrix, the only way for a domain to cede ownership of memory is to create a new domain using that memory. The supervisor could provide a chown call, which would allow a domain to give ownership of a memory region to another domain, but this was not found necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Export permissions</head><p>The memory supervisor also implements export permissions, which describe how a domain can grant permissions to another domain. Ownership conveys unlimited export permissions, but non-owner domains can have restricted export permissions. For instance, an owner domain can give another domain (call it domain X) read-write access permissions on a buffer, but limit it to readonly export permissions. Domain X can read and write the buffer, but cannot grant read-write permissions on the buffer to a third domain Y.</p><p>The current Mondrix supervisor implements a limited form of export permissions, based on ownership and access permissions. An owner can export permissions freely, while a non-owner can export only up to its access permissions level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Permissions and memory allocation</head><p>The Mondrix design allows protection, entirely managed by the supervisor, to be separated from dynamic memory allocation, which is managed by the kernel. This allows the main kernel allocators (the page and the slab <ref type="bibr" target="#b4">[5]</ref> allocator) to remain outside the supervisor, and lets the kernel retain custom memory allocators, i.e., allocators that manage their own free list such as the Linux inode or socket allocators.</p><p>The supervisor provides special API calls (perm alloc and perm free) to support allocators that provide memory to other domains. A domain (call it domain X) calls an allocator domain (call it domain Z), and the allocator domain determines the start address and length of the memory that X will receive. The allocator domain then calls the memory supervisor to establish permissions for X on the memory it has chosen. The supervisor determines that the permissions are for X by reading the cross-domain call stack.</p><p>An allocator domain can own the memory it allocates, which is the fast path used by the slab and page allocators, or it can have export permissions, which is used by the custom allocators because they do not own the memory they allocate; they get it from the slab or page allocator.</p><p>The memory supervisor is also responsible for revoking permissions when required, e.g., when a memory region is freed or when a domain is deleted. The supervisor must revoke the permissions because it can not trust other domains to do so correctly.</p><p>The supervisor keeps track of which domains have access permissions to memory. This has three significant advantages. The first advantage is that the supervisor prevents domains from leaking permissions by automatically deleting permissions when necessary. The second advantage is that memory need not be tracked by kernel code after it is allocated. The owning domain simply shares the memory, and frees it as usual. The owning domain does not need to track the domains to which it exports permissions, reducing the changes in kernel code to use MMP. The final advantage is that revoking permissions from only the domains that have it is significantly faster than checking all domains for access rights.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Thread-local stack permissions</head><p>The memory supervisor is responsible for managing thread-local stack permissions. Threads can control permissions only for frames in their current domain; the supervisor rejects permission change requests for memory between the most recently saved frame base and the stack base. If a thread grants write permission to a frame, it must revoke permissions on the frame before the frame returns, or it will leak permissions (just as a domain which does not properly revoke permissions on a buffer leaks permissions). On scheduling events, the kernel calls the supervisor to save and reload the threadlocal CPU registers (sb, fb, sl, CDST, and the stack table base).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Creating and deleting domains</head><p>The supervisor manages the creation and deletion of protection domains. A domain can create a new domain by subdividing, passing ownership of a region of its own memory to the new child domain. The supervisor tracks the parental relationships between domains using a tree, with the supervisor itself at the root. When a domain is deleted, ownership of its memory regions passes to its closest extant ancestor. The supervisor must also revoke permissions on memory owned by the deleted domain from all domains.  While there are many details in the table, the supervisor policy follows a few general rules: a non-owner can not dictate permissions to an owner; a non-owner can not downgrade the permissions of another domain; a non-owner can not upgrade its own permissions. <ref type="table" target="#tab_0">Table 1</ref> refers to an ordering on permissions values. Mondrix uses a partial order. Read-write, execute-read, and gate permissions all compare equal, so a non-owning domain can convert between these permissions values. All of these values compare greater than read-only, which in turn compares greater than no permissions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Permissions policy</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Group protection domains</head><p>A group protection domain is a collection of memory regions, each with a specified permission. Group domains are useful when multiple domains need access to the same set of memory regions, and where the memory segments in that set change over time. They are not essential to Mondrix's function, but they are a powerful tool.</p><p>A regular protection domain can create a group protection domain and then grant access permissions to the group for multiple memory segments. Another protection domain can then join the group domain to gain the permissions specified by the segments in the group. This process is shown in <ref type="figure">Figure 4</ref>, where PD 1 exports two memory regions read-only to a group protection domain that is joined by PD 3. When a domain grants or revokes permissions to a group, the memory supervisor adds or revokes permissions on the new memory for every domain in the group. All domains are members of a special global group maintained by the supervisor that contains memory regions with global access permissions. The supervisor can reduce the cost of updating group permissions by sharing appropriately aligned pieces of the underlying trie-based permission table across domains.</p><p>One example use of group domains is for the kernel inode structure, which records metadata information for file system objects. Several modules (such as the EIDE disc driver and the interpreter loader) need read access to inodes. The kernel creates a readonly group protection domain of inodes that a module can join to get read permissions on these memory areas. The memory locations that hold inodes change over time as inodes are allocated and deleted, and the kernel keeps the group protection domain of inodes up to date by adding the new ones to the group, and deleting the old ones from the group.</p><p>The memory supervisor regulates which protection domains can join a group. Group domains, like any access control mechanism with groups <ref type="bibr" target="#b31">[32]</ref>, must address difficult issues of how group membership is managed. The memory supervisor would enforce the policy chosen by the system designer, but we defer to the literature for possible policies, and simply present the group mechanism. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">COMPARTMENTALIZING LINUX</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>printk</head><p>This is an ad-hoc collection of the kernel functions and data consisting of printk and related functions (e.g., sprintf, vsprintf). ide-mod ide-disk ide-probe-mod Collectively, the EIDE disk driver.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>unix</head><p>Unix domain sockets (used by syslogd).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>rtc</head><p>The real time clock.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>binfmt misc</head><p>The interpreter loader (supporting #!/bin/sh).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8390">ne</head><p>The bottom and top halves of the network driver, controlling an NE2000 network interface card. The code in Mondrix is divided into the protection domains shown in <ref type="table" target="#tab_2">Table 2</ref>. The partition of code into domains is arbitrary, but Mondrix uses several guiding principles. It isolates each kernel module in its own domain. If the kernel developers think of a collection of functions as a module, then that collection can control its memory permissions in Mondrix. The disk and network device drivers are sub-divided into several modules and each module resides in its own domain.</p><p>Mondrix also collects certain functions into domains in order to increase memory isolation within the kernel. Domain 0 holds the bottom half of the memory supervisor. Domain 1 holds the top half of the memory supervisor. Most of the kernel is resident in domain 2, while domain 3 holds the collection of kernel functions that print, write and format strings (included the dreaded sprintf function, cause of many buffer overflows).</p><p>The division into protection domains forces all memory sharing between modules to be explicit. The principle of least privilege dictates that each kernel module has the minimum memory permissions necessary for correct operation, but this desire must be balanced against performance and ease of programming. For example, the printk domain was granted permission to read all kernel strings. Kernel strings are contiguous in memory and granting read permission for each string would be tedious, error-prone and less efficient. Individual modules export read permission to printk for individual strings or for their string section. All write access to stack variables (mostly for proc filesystem calls to sprintf) is provided and removed explicitly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Loading modules into protection domains</head><p>Linux kernel modules are object files that a user loads into a running kernel using the insmod program. The insmod program reads a module from disk, then links it against the currently running kernel (based on symbol information it receives from a system call), resolving any undefined symbols in the object module.</p><p>After checking the module, the kernel calls the memory supervisor to set correct memory permissions on the module. The supervisor needs the length of the program sections (already provided by insmod), and for every function its start address (also already provided) and the address of the return instruction (Mondrix's insmod provides this additional information). Program section information is used to properly set the initial permissions for the module, while function entry and exit information is used to guarantee that switch and return gates are set only at the start and at the return instruction of a function respectively. The memory supervisor places the obvious permissions on each section (e.g., execute-read permission on the text section).</p><p>The supervisor needs the address of the return instruction for public functions in the module that other domains call, so it can set a return gate on the function. With gcc versions 3.3.x, the return instruction is placed arbitrarily in the function to allow outlining of uncommonly executed code, so Mondrix stores the return instruction addresses in the kernel modules. <ref type="figure" target="#fig_3">Figure 5</ref> shows how permissions and ownership information change when a domain is created to hold a newly loaded module. In the before state, the kernel (in PD 1) owns all of physical memory. In the after state, it has subdivided, and loaded a module into PD 2. Permissions for the module's code and static data are given by the shaded regions, and correspond to the object file layout of program sections. The kernel allows the module in PD 2 to own its static code and data, but it retains ownership of the rest of the address space.</p><p>Previous work <ref type="bibr" target="#b41">[42]</ref> predicted that symbol information could implicitly define sharing relationships. Code and data can be exported by name (using the EXPORT SYMBOL directive in Linux). While this is the currently encouraged method for exporting functions in the Linux kernel, there is plenty of legacy code that exports functions anonymously by passing their address directly. Kernel code assigns the addresses of regular and static functions to structures of function pointers that it passes to other domains. The names of the static functions are not visible to the other domains, but the function pointers are! Unfortunately, import and export of function name symbols is only an incomplete record of true inter-domain calling behavior.</p><p>As bad as the situation is for code, it is worse for data. C's ambiguity between pointer and array, and the relative rarity of importing data by named symbol makes imports nearly useless as an indicator of true inter-domain data sharing. Most code uses extern declarations for data instead of EXPORT SYMBOL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Disk driver</head><p>Many kernel drivers are split into two parts, a device-dependent bottom half and a device-independent top half, where each half is an independently loaded kernel module. The EIDE disk driver has one top half (ide-mod) and two bottom halves, one to gather disk controller information (ide-probe-mod), and one to gather disk geometry information (ide-disk). Different halves of a driver share data structures, and call each other frequently.</p><p>Adapting device drivers for Mondrix consists of placing explicit calls to the memory supervisor that manage access permissions on memory used by the driver and shared with other parts of the system. In order to increase memory isolation, Mondrix grants permission on page and buffer cache memory regions before calling the disk driver to read or write the data, and revokes permissions once the I/O is done. The EIDE disk model in Bochs does not support DMA, but the EIDE disk model in SimICS does, so Mondrix controls the permissions for both DMA and programmed I/O data transfer.</p><p>Another part of device safety is proper programming of device registers. In one file system corruption prevention experiment (Section 5.1.2), Mondrix was able to determine that the disk controller was programmed with a bad address range because it read from an illegal location. Mondrix could do more of this kind of checking; specifically it could check memory bounds for every I/O request (DMA or PIO) without changing the interface. A small I/O bounds check domain is created, and only this domain gets write access to memory mapped I/O device control registers. The kernel or driver calls into the I/O domain to write to the DMA engine registers. The bounds checker checks the values and performs the writes. Writing device control registers is already slow compared to normal memory references, so the additional latency of the cross-domain call and check should not have a significant impact on overall performance. This approach would catch DMA programming errors, but would not prevent a faulty device from writing out of its programmed bounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Network driver</head><p>The NE2000 network driver has a chip-specific portion (8390), which coordinates the reception and transmission of packets and handles device interrupts and initialization, and a board-specific portion (ne), which moves data onto and off of the network card. Mondrix must give the 8390 module read-write permissions on certain fields in the sk buff, which is the kernel data structure which manages packet data. It must give the ne module read or read-write permission (for transmission or reception) on the packet data itself.</p><p>Mondrix allows the ne module to retain read permission on packet data while packets can be retransmitted. It allows readwrite access to the 8390 module to 8 words (32 of 144 bytes) in the sk buff structure, none of which are kernel data structure pointers (though some of the fields point to packet data). This policy limits the damage a malfunctioning driver can do to the kernel and increases the chances that a malfunctioning driver would be detected by an illegal memory reference. Mondrix allows kernel programmers to balance memory isolation with performance. A more restrictive permissions policy would remove write access to the 8390 module for sk buffs that are on the free list.</p><p>It is unfortunate that the only Ethernet device model Bochs supports is the NE2000, since the NE2000 is not a sophisticated device (it does not support DMA), but adding an additional Ethernet hardware model to the Bochs machine simulator was beyond the scope of this work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Interrupts</head><p>Handling device interrupts is an important operating system task, and MMP allows them to proceed in a protected way. Interrupts do not cause a protection domain switch, but jump to shared interrupt stubs that are marked executable in every domain using the global group protection domain. The interrupt assembly stubs are a shared library, albeit a simple one that has no data.</p><p>The stubs must be verified by inspection, as they are now (about 50 lines of assembly code), since they are trusted in every domain. The transfer from the interrupt stub to a C handler routine has a switch gate, causing a domain crossing to the handler's domain. Distributing the assembly stubs to all protection domains does not create a new vulnerability since the correct functioning of the machine is dependent on the correct functioning of the interrupt assembly stubs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Inlining</head><p>In C, header files sometimes include inlined functions that reference a module's internal data. Any domain that calls the inlined function needs permission to access the inlined data. Sometimes the domain exporting the inlined function should export permissions on its data, and sometimes an inlined function should be uninlined to avoid giving other domains permission to read or write its sensitive data. Mondrix uses both approaches, on a case by case basis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">Slab allocator</head><p>The kernel slab allocator <ref type="bibr" target="#b4">[5]</ref> is called frequently for small memory objects, allocated out of caches (kmem cache t). Mondrix takes advantage of the fact that the domain that allocates a cache is almost always the one that allocates memory from it. Mondrix manages the permissions for entire slabs (usually pages) internal to the caches. This does not compromise safety because the supervisor checks (with hardware providing integrity) if the calling domain owns the cache, and if not, provides permissions only for the individual object requested. However with this policy, a domain that owns a cache can write into memory that was not yet allocated and not cause a fault.</p><p>Like many decisions about how tightly to control memory permissions in Mondrix, optimizing the slab allocator trades speed and isolation. Mondrix chooses speed in this case, but the fault injection results (Section 5.1.2) indicate a high degree of isolation with this policy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EXPERIMENTAL EVALUATION</head><p>This section analyzes the performance of Mondrix executing on the SimICS <ref type="bibr" target="#b26">[27]</ref> and Bochs <ref type="bibr" target="#b22">[23]</ref> machine simulator. We added a functional model of the MMP hardware to each simulator, and booted Mondrix on the modified simulator. The memory supervisor in Mondrix handles all permissions requests, and its bottom half writes the permissions tables, so all instruction and memory traffic from that code is present. The model includes a cache simulation, gathers workload statistics, and checks all accesses for correct permissions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Functional evaluation</head><p>Our hypothesis when building Mondrix was that the memory isolation it provides would allow the kernel to detect data structure corruption, limiting damage from bugs. Mondrix exposed a latent bug in Linux, and we injected faults into Mondrix to see how effective it would be at detecting and avoiding data structure corruption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Mondrix exposes a Linux error</head><p>Converting Linux to Mondrix exposed a case where, during kernel initialization, the kernel freed the stack memory on which it was executing. The kernel continued to use the stack memory after it freed it, even making calls into dynamically loaded modules.</p><p>proc pid lookup is a function in the proc file system (a pseudo-filesystem for processes control and information) that looks up a user area based on the process identifier. The function calls free task struct on the task it looks up. The call should not actually free the task structure because the function decrements a reference count that was incremented earlier in proc pid lookup. free task struct only frees the task structure if the structure's reference count is zero. But the reference count is zero at one point during kernel initialization, so free task struct actually frees the task structure. Since the task structure and the kernel stack are in the same allocation unit, the kernel stack is freed along with the task structure. In one case, the kernel frees the memory for the stack on which it is executing. Since the Mondrix memory supervisor revokes all permissions on memory that is freed, it reports many protection violations from the kernel reading and writing the stack memory it just freed. Another call to free task struct is made in proc pid delete inode, where it should be balanced by a previous increment of the use count on the task struct memory. But again this routine causes the kernel to free the stack memory on which it is executing. The code that manipulates the reference counts for the task structure was changed during the development of version 2.5, and versions 2.6.x use the new system. We did not check if the new code manifests the same bug we found in 2.4.19, because we have not ported our kernel changes to 2.6.x.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Fault injection experiments</head><p>In order to demonstrate Mondrix's effectiveness at containing memory corruption in the presence of kernel bugs, we ran a series of experiments injecting faults into Mondrix. We use the same fault injection code used in the Rio file cache studies <ref type="bibr" target="#b7">[8]</ref> and Nooks <ref type="bibr" target="#b37">[38]</ref>, which changes instructions and data in the kernel binary in a way that models the effect of real software bugs. Once the kernel loads all of its modules, the fault injection code injects faults and the kernel tries to run a small workload consisting of find and wget to simulate normal use of the disk and network.</p><p>Corrupting the file system is one of the worst possible outcomes from a kernel failure. After each fault injection experiment we ran the Unix file system consistency check program fsck. If fsck deleted files or directories in its effort to reconstruct the file system, we classified that run as corrupting the file system. Deleting files and directories goes beyond the metadata fixups (e.g., fixing the free block count) that are common from a kernel crash or hang.</p><p>These experiments were run on Linux's ext2 filesystem. There are journaling file systems (like ext3) that largely avoid the problem of corrupted file systems due to unexpected crashes or kernel behavior. The purpose of the experiment is to show that Mondrix can catch the effect of kernel problems before they propagate and  spread to other parts of the kernel. A corrupt file system is a reasonably common and unpleasant example of kernel bugs' effects rippling out from their point of origin. Five out of 200 fault injection experiments resulted in a corrupt file system. In three of these cases, Mondrix detected a memory permission violation, and in all three cases if Mondrix halted when the MMP protection system detected the violation, it would not have corrupted the file system.</p><p>The three cases are interesting because they display the strengths of MMP, and the diversity of kernel failure symptoms. In one case (simulating a pointer dereference bug) MMP catches the EIDE disk controller reading from dynamically allocated kernel memory. The disk controller does not have access to that memory, but it was passed a bad pointer. In another case (in which a random instruction was deleted), sprintf was passed a pointer to a device lock instead of a character buffer, and it corrupted the lock and nearby data structures. In the final case (simulating failure to initialize a variable), the console driver reads from an address that could be the address of a kernel stack, but is not.</p><p>The proper strategy for dealing with faults in the kernel depends on how the operator wants to balance availability with data integrity. Linux's default behavior on a kernel memory fault is to kill the process context that caused the fault. This can be an effective way of limiting the scope of the problem while keeping the system running. For instance, in one of our fault injection experiments the kernel killed modprobe after it finished loading a module. Because the user process had completed its work, killing the context was a safe and effective course of action. Some faults are more serious, resulting in hangs or kernel panics. Mondrix can detect when faults are corrupting data structures and stop them to limit the scope of the damage.</p><p>The data in <ref type="table" target="#tab_4">Table 3</ref> summarize our fault injection experiments. MMP detected more illegal memory sharing as the symptoms of a fault rose in severity from minor symptoms (possibly killing a user task) to system hangs and kernel panics. This data is suggestive that MMP is detecting important errors as illegal memory sharing, especially in conjunction with the data about file system corruption. However, a lack of symptoms does not always imply correct operation, nor does a hang necessarily imply a major problem. Important data structures can be corrupted when the kernel successfully shuts down, and some hangs occur late in shutdown where they are benign. Subdividing the kernel into more domains might catch more memory data structure corruption (and cost more performance).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Performance evaluation</head><p>We use a performance model to estimate the overhead of adding fine-grained memory protection support to the processor. We assume a processor that can complete one x86 instruction per cycle. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Benchmark</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MySQL</head><p>A MySQL client test from the MySQL distribution. The client connects to the database (on the same machine) and executes 150 test transactions covering the range of database functionality. We model a two level cache hierarchy, based on the Intel Pentium-4, with 16 KB 4-way associative level-one instruction and data caches, and an 8-way associative 2 MB level-two unified cache. Level-one miss penalty is 16 cycles, and level-two miss penalty is 200 cycles (this memory access penalty is low, representing a 4 GHz processor able to access local DRAM in 50 ns). Cache lines are 64 bytes. Main memory size is 256 MB, which is small by today's standards, but is a limitation of the simulation environment. This model represents the performance of an aggressive processor over the next few years.</p><p>SimICS EIDE disk model properly limits disk bandwidth and provides a simple fixed latency for each disk operation. We use a disk latency of 5.5 ms, representing an aggressive 2 ms for the rotational latency of a 15K RPM disk and an average seek time of 3.3 ms (the disk-active workloads make random requests making this number optimistic). The SimICS EIDE disk model includes DMA. <ref type="table" target="#tab_6">Table 4</ref> shows the system-intensive benchmarks we ran on Mondrix to measure the effect of isolating kernel modules in separate protection domains. The benchmarks were chosen as common tasks that stress the disk and network subsystems of Mondrix. The OS was booted fresh before each trial. All utilities were from the Debian Linux distribution as of <ref type="bibr">January, 2005</ref>.</p><p>The configuration of xemacs is a long running test that stresses the virtual memory system with process creations, deletions, scheduling and small file access. It runs for long enough that the kernel memory allocators reclaim memory. The thttpd benchmark is a small web server that serves data and runs cgi scripts. The cgi scripts in turn run several native programs e.g., to print environment variables. This benchmark uses the network heavily and also creates many small processes. The find benchmark is disk and filesystem intensive, as is the MySQL database test.</p><p>The graphs in <ref type="figure" target="#fig_4">Figure 6</ref> (best viewed in color) show the performance of the benchmarks on Mondrix. config-xemacs, find and MySQL run on SimICS, while thttpd runs on Bochs (because SimICS does not have an NE2000 network device model). SimICS's EIDE disk model supports DMA, so the workloads run on SimICS spend only a small amount of time servicing disk interrupts. The NE2000 network device in Bochs does not use DMA, so the time to service network interrupts includes the time for the processor to copy the packet data. Most of the kernel other category in the thttpd workload includes data copying from interrupt processing. Bochs does not model the device latency of the network card.  <ref type="figure" target="#fig_4">Figure 6</ref>: Performance of benchmarks on Mondrix, including instructions, memory stalls, and disk device latency. The other category for user programs is for any program whose individual contribution to performance falls below a threshold. The other category for the kernel includes system calls, kernel threads and interrupt processing that falls below a threshold. Categories like fork exec include all system calls related to forking and execing processes, and fs misc includes most file system calls that are not open, close, read, or write. The mmp bot category is the bottom of the Mondrix memory supervisor that writes the protection tables, while mmp top is the top half of the memory supervisor. The workload's kernel/user execution time split appears at the bottom of the legend.</p><p>The CPU overhead of adding MMP to Mondrix is less than 15% for all benchmarks, and below 8% for the non-networking benchmarks. As explained in Section 4.4, Mondrix tightly controls the permissions on network packets. The numerous calls to mprot export from the kernel's networking code shows up as time spent writing permissions tables (mmp bot in the graph). The MMP overhead could be reduced further by using a pool of preallocated packet buffers. <ref type="table" target="#tab_9">Table 5</ref> shows the performance overhead of Mondrix as compared with an unmodified Linux. CPU and memory overhead is less than 15%. All experiments described in this section use the bitvector format <ref type="bibr" target="#b42">[43]</ref> for the permissions tables.</p><p>Permissions tables are written in response to memory allocation, process creation, and direct calls to the memory supervisor. The slab allocator optimizations (see Section 4.7) are effective at limiting table updates due to memory allocation. The config-xemacs and thttpd benchmark create many processes, and see increased table writing activity because of it. The kernel could keep tables for a process' program sections resident while most of the process' text pages are resident, reducing the overhead of re-executing the same process. Direct calls to the memory supervisor are a matter of programmer policy. Mondrix's tight control of permissions on network buffers is the main contributor to the performance overhead in the bottom of the memory supervisor.</p><p>Much of the kernel overhead for thttpd arises from increased memory traffic due to PLB refils, as explained in Section 5.2.3.</p><p>To keep the overhead from the bottom of the memory supervisor low, the table writing code is heavily optimized. The table writing code uses lookup tables to write permissions in 32-bit words, and the code is optimized to quickly find the proper table given that most allocations are for a page or less.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Benchmark</head><p>Cyc    The find benchmark and MySQL make heavy use of the file system, creating significant idle time. This idle time overlaps much of the Mondrix overhead caused by the additional checks in the inode allocator, the generic block driver, and the slab memory allocator. The code in these subsystems calls the memory supervisor and makes local decisions about granting memory access.</p><p>There were several challenges running the network experiments on Bochs. There is a bug in the Bochs device model which causes occasional transmit errors at the device level. The occurrence of these bugs can be seen as the idle time in the graph as the kernel resets the network card and retransmits the lost packets. Thirteen packet corruptions occurred in this run out of 498 packets (eight packet corruptions occurred in the corresponding test on unmodified Linux).</p><p>In order to minimize the timeout bug and because the simulator does more work (checking permissions) when running Mondrix, simulated time runs at different rates in the Linux and Mondrix benchmarks. Under unmodified Linux the system believes that 40 seconds have elapsed, while under Mondrix the system believes that only 2 seconds have elapsed. The amount of web server related work is the same, but under Linux the benchmark does more user work (klogd runs under Linux and does not have time to run under Mondrix). To compensate we compare only webserver related time for thttpd. The overheads from the memory supervisor are higher in <ref type="table" target="#tab_9">Table 5</ref> than in <ref type="figure" target="#fig_4">Figure 6</ref> because the idle time was subtracted from the total runtime (normalizing to webserver related work) to compute the figures in the table. Only thttpd runs under Bochs, so it is the only benchmark with this problem.</p><p>We investigated removing permissions from sk buffs when Mondrix places them on the free list and reinstating the permissions when they are dequeued. That brings the total overhead up to 19.1% from the 14.8% in the table. <ref type="table">Table 6</ref> summarizes cross-domain calls in Mondrix. Crossdomain calls account for less than 1% of the total execution time for all benchmarks. The protection domain granularity enforced in Mondrix is very fine-grained (justifying architectural support). The table shows that cross-domain calls are frequent (at least once every thousand cycles of kernel activity), and cross-domain calls from a domain to itself are more frequent than calls to other domains. A domain makes cross-domain calls to itself when it calls a function that it also exports to another domain (like the kernel exports kmalloc). As the kernel is split into more domains, more calls will be cross-domain calls.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Evaluation of cross-domain calling in Mondrix</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Benchmark</head><p>Free Mem Used config-xemacs 10.2% thttpd 1.1% find 7.8% MySQL 1.6% <ref type="table">Table 7</ref>: Reduction in free kernel memory after each workload as reported by /proc/meminfo.</p><p>The cost model for a cross-domain call or return is a 5 cycle penalty to flush the pipeline and perform memory accesses plus any memory stall accrued by the memory accesses. Each cross-domain call stores the protection domain, return address and if the protection domain changes, the contents of the fb register. Each crossdomain return loads these values (only loading fb if the protection domain changes). The loads for the permission table base pointers are not included since these can be cached on chip. During all of these benchmarks, the cross-domain call stack never grows deeper than 64 entries, so this data structure does not occupy significant cache area. <ref type="table">Table 7</ref> shows the memory overhead of Mondrix by comparing the output of /proc/meminfo after each benchmark for Mondrix and an unmodified Linux. The memory overhead represents how much less free memory the kernel has after running each benchmark because that is the most conservative metric. For all benchmarks the sum of the Active and Inactive memory in the kernel was within 1% for Mondrix and Linux. The memory supervisor's data structures do not disturb the kernel's active memory use. <ref type="table" target="#tab_11">Table 8</ref> shows how effective the on-chip protections cache (the protection lookaside buffer (PLB)) is at caching permissions. On a PLB miss, the cost model for the refill is 1 cycle per load plus any memory stall the load incurs. The PLB caches permissions data for heap, text and stack memory (but it does not cache gate information). All benchmarks spend less than 4% of their execution time refilling the PLB. The PLB refill cost is spread through execution of all domains including the memory supervisor. The networking benchmark writes the permissions table frequently, so it spends the most time refilling the PLB.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Evaluation of memory use in Mondrix</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3">PLB refill traffic</head><p>The memory supervisor keeps the PLB consistent with the permissions table by flushing the PLB when necessary. The PLB is implemented as a ternary CAM <ref type="bibr" target="#b42">[43]</ref>, so permissions can be flushed for power-of-two sized virtual address regions. The supervisor flushes the PLB for address ranges that could become stale when it writes the protection tables, and it flushes the PLB of stack permissions on a process switch.</p><p>The PLB miss rate is a bit lower than typical second level cache miss rates. The PLB can effectively cache information for regions larger than a page, like the kernel text and data sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Benchmark</head><p>PLB time PLB mr config-xemacs 0.8% 0.51% thttpd 3.8% 0.87% find 0.4% 0.07% MySQL 1.7% 0.22% </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>Nooks <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b37">38]</ref> provides device driver safety using conventional hardware. Nooks uses conventional paging hardware to isolate modules by putting them in different addressing contexts (protection domains). These domains execute with full kernel privileges, but they differ in their view of memory permissions. Crossing Nook boundaries is expensive because it requires changing virtual address context and copying parameters. To minimize boundary crossings, Nooks places multiple kernel modules in the same protection domain. MMP can enforce the natural, fine-grained module boundaries established by the Linux kernel developers. The frequency of cross-domain calls in the MMP system (Section 5.2.1) is at least an order of magnitude greater than Nooks <ref type="bibr" target="#b36">[37]</ref> without a decrease in performance, indicating that MMP offers greater modularity and isolation.</p><p>Nooks is an elegant solution to the specific problem of bringing safety to OS extensions for existing hardware, while MMP is a proposal for a general-purpose architectural mechanism for protected sharing, which we have applied to the problem of safe OS extensions in this paper. MMP can also be used to provide safe user extensions, and a variety of other applications like data watchpoints, optimistic compiler optimizations, and efficient read barriers for garbage collection.</p><p>Mondrix contains modules that are not device drivers (like support for unix domain sockets) and whose memory access and calling relationship to the rest of the kernel is not as well behaved as device drivers. It provides protection domains for these ad-hoc modules just as it provides protection for device drivers. Nooks relies on the specific calling relationship drivers have with the kernel and could not isolate modules like the unix domain socket module. In several fault injection experiments where Mondrix caught a sharing violation in advance of a kernel panic, the unix domain was the source of the violation.</p><p>Nooks includes a recovery system <ref type="bibr" target="#b37">[38]</ref> that can safely restart a failed device driver. It tracks kernel objects and tries to reclaim resources on a fault. Mondrix does not have a recovery mechanism but recovery can be done at a coarser level of granularity than isolation, so Mondrix could use many of Nook's techniques while the MMP hardware should increase the efficiency of the Nooks implementation.</p><p>Nooks consists of 22,266 non-comment lines of code, including 924 lines of Linux kernel changes. The top of the Mondrix memory supervisor is 3,922 lines of non-comment code, the bottom is 1,730 and Mondrix requires 1,909 lines of kernel changes. Mondrix requires more kernel changes because memory permissions are managed at a finer granularity, requiring more calls to the memory supervisor. The advantage to adding hardware is that the trusted computing base can be kept small and understandable, as evidenced by the size of the memory supervisor. The functional complexity of the hardware design is quite low, as it has a well-defined behavior that only needs to consider a single dynamic instruction at a time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Language-based protection</head><p>Microsoft plans to use safe languages (called "managed code") to implement new features in its next next generation operating system, called "Vista" <ref type="bibr" target="#b10">[11]</ref>. One of the reasons for the switch to managed code is to provide safety for kernel extensions. Vista's trusted computing base will be orders of magnitude larger than Mondrix's. At this point it is unclear if malicious attacks will be stopped by safe languages, or if attacks will cause resource exhaustion rather than crashes. It is also unclear if the performance cost for the safety of such a system will be acceptable. The switch to a system consisting entirely of managed code (if it can be done) will take many years, during which the vulnerabilities in non-managed code will persist. The operating system and its drivers are a large program to recode, but there is research on how to recode an OS for a safe language <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b18">19]</ref>.</p><p>There have been several operating systems that use safe languages as their primary extensibility mechanism <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b40">41]</ref>, with SPIN <ref type="bibr" target="#b3">[4]</ref> a large, recent example. SPIN demonstrates how an operating system written in a safe language (Modula-3) can be made efficient in terms of CPU and memory consumption. But device drivers in SPIN are written in C, because rewriting existing driver code is too much work. Also, because of their low-level nature, many device drivers require unsafe programming language features <ref type="bibr" target="#b3">[4]</ref>. One advantage of MMP is that it efficiently supports legacy code, written in unsafe languages.</p><p>The SPIN project included a linker design <ref type="bibr" target="#b35">[36]</ref> whose goals are similar to the gate design in Mondrix. In SPIN, a typesafe reference to a domain gives permission to call that domain's functions. Mondrix allows more fine-grained control. A module may export a different arbitrary subset of its functions to each other domain.</p><p>CCured <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b8">9]</ref> is a language-based approach to adding memory safety to C. It is unclear whether it is more programmer effort to create Mondrix, or to port Linux to CCured. One issue with CCured for operating systems is the requirement of wrappers for libraries not compiled with a CCured compiler. Since proprietary device drivers are often distributed in binary-only format, manufacturers would have to provide wrappers, or they could be reverse engineered. CCured performance is variable, with slowdowns from 0-81%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Hardware-based protection</head><p>Intel and AMD have announced support for the NX bit in the page table <ref type="bibr" target="#b1">[2]</ref>, indicating their willingness to add hardware to make software more reliable. Any attempt to execute an instruction from a region with the NX bit set would cause a fault. Security-conscious applications can set the NX bit on their stack, heap, and data sections, that would prevent some malicious attacks. However many attacks overwrite data in jump tables and function pointers, and these attacks will not be prevented by the NX bit.</p><p>The operating system for the Cambridge CAP computer <ref type="bibr" target="#b39">[40]</ref>, and Multics <ref type="bibr" target="#b30">[31]</ref> were written to run on hardware that supported capabilities, which provided some of the isolation guarantees of MMP. However, the structure of these systems is different from a modern OS due to hardware imposed restrictions. For instance, Multics limits the number of subsystems in a process to 8, and only allows a subsystem to call another with a higher identifier.</p><p>MMP has been compared to segments <ref type="bibr" target="#b23">[24]</ref> and capabilities <ref type="bibr" target="#b42">[43]</ref>. It has the flexibility of segments, but with the simplicity and backwards compatibility of linear addressing. It provides some of the most attractive features of capabilities, like fine-grained protection domains and flexible resource sharing, while maintaining a backwards compatible programming model and providing simple rights revocation. Hardware capabilities require a fundamentally incompatible change in the processor instruction set, complicate permission revocation <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b5">6]</ref>, and have trouble allowing domains to see different permissions on a region of memory accessed via a shared capability. Many of these problems have been addressed in recent software-based capability systems <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b34">35]</ref>, but the incompatible programming model problem remains a significant hurdle.</p><p>XOM <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b24">25]</ref> is a hardware design and OS implementation of an untrusted OS on trusted hardware. Its goals are different from Mondrix (Mondrix empowers the developer while XOM empowers content providers), but the hardware/OS co-design issues are a close match.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">OS structure</head><p>Single-address space operating systems place all processes in a single, large address space <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b13">14]</ref>, and many use protection domains to specify memory permissions for different thread contexts <ref type="bibr" target="#b20">[21]</ref>. The granularity of protection in these systems is a page to match the underlying paging hardware. MMP's finer granularity allows the protection techniques of single address space OSes to be applied to legacy operating systems.</p><p>The modularity of Mondrix resembles that found in many microkernel designs <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b14">15]</ref>, but without the performance problems of protection domain switches being coupled with address space switches.</p><p>Lightweight virtual machines like Xen <ref type="bibr" target="#b11">[12]</ref> and Denali <ref type="bibr" target="#b38">[39]</ref> can get some benefits of fault containment by replicating entire OS/application environments. But they do not address the detection of faults within an OS or application, they just provide an alternative to a crash should such an error take place.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION</head><p>MMP provides a practical solution to the longstanding goal of fine-grained memory protection. MMP provides fine-grained protection with backwards compatibility for operating systems, ISAs and programming models, using only a small amount of additional hardware that is not on the processor critical path. MMP avoids additional confusing programmer-visible abstractions, yet can support most of the best ideas previously proposed for segmented or capability systems.</p><p>Our experience in building Mondrix indicates that MMP's programming model fits naturally with how modern software is designed and written. MMP provides hardware enforcement of existing module boundaries, improving software maintainability and robustness. Mondrix's use of hardware memory protection increases Linux's robustness from software errors.</p><p>Modularity is a proven technique for providing flexible and stable systems, but current hardware and operating systems provide only crude, and therefore neglected, support for modular software systems. We believe fine-grained memory protection of the kind provided by MMP should be a standard component of future computing platforms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGEMENTS</head><p>Thanks to Jungwoo Ha for help with the networking experiments. Thanks to Fletcher Mattox for late night disabling of network port security policies.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 : A visual depiction of multiple memory protection do- mains within a single shared address space.</head><label>1</label><figDesc>Figure 1: A visual depiction of multiple memory protection domains within a single shared address space.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The format of entries in the gate table. The gate table encodes cross-domain call points, with switch gates encoding the callee's protection domain.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 : An example of a group protection domain. In this case, protection domain 1 has read-write permissions on two regions of memory. It grants read-only permissions on both to group protection domain 1. Protection domain 3 joins the group protection domain (indicted by the arrow labeled "mem- ber"), gaining read-only permission to the two pieces of mem- ory from GPD 1 (indicated by the two arrows from GPD 1</head><label>41</label><figDesc>Figure 4: An example of a group protection domain. In this case, protection domain 1 has read-write permissions on two regions of memory. It grants read-only permissions on both to group protection domain 1. Protection domain 3 joins the group protection domain (indicted by the arrow labeled "member"), gaining read-only permission to the two pieces of memory from GPD 1 (indicated by the two arrows from GPD 1 to PD 3).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 : A before and after picture for domain creation with module loading. For each domain, the thicker bar shows the protection information, and the thinner side bar shows owner- ship information.</head><label>5</label><figDesc>Figure 5: A before and after picture for domain creation with module loading. For each domain, the thicker bar shows the protection information, and the thinner side bar shows ownership information.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>6 : Cross-domain calling behavior for workloads running on Mondrix. The XD column is the percentage of total execu- tion time each workload spends doing cross-domain calls (in- cluding compute cycles and memory references). The Ca col- umn is the number of cross-domain calls in millions. The Cy/Ca column is the average number of non-idle kernel cycles (in- struction and memory stall) between cross-domain calls. The Self/Other column indicates the percentage of cross-domain calls that a domain makes to itself versus those that cause a domain change.</head><label>6</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><head>Table 1 summarizes</head><label>1</label><figDesc>the supervisor's API and policies for man- aging memory ownership and permissions. There are two calls to set permissions on memory regions: mprot sets permission for the current domain while mprot export sets permission in another domain. The pd subdivide call creates a new domain, while pd free deletes a domain. Memory allocator domains call the su- pervisor perm alloc and perm free routines to give the caller of the allocator access permissions in the memory being allocated.</figDesc><table>Before 

Call 

After 

Comments 

Caller 

Target 

Caller 

Target 

own? 

access 

own? 

access 

own? 

access 

own? 

access 

y 

X 

mprot(ptr, len, A); 

y 

A 

An owner can grant itself arbitrary permissions. 

n 

B 

// Change own permissions. 

n 
A≤B ? A : ERROR 

A non-owner can only downgrade its permissions. 

y 

X 

n 

Y 
mprot export(ptr, len, C, target); 

y 

X 

n 

C 
An owner can override a domain's permissions. 

n 

X 

y 

Y 
// Change others permissions. 

n 

X 

y 

ERROR 
It is an error for a non-owner to override an owner's permissions. 

n 

D 

n 

E 

n 
C≤D ? D : ERROR 

n 
C≥E ? C : ERROR 
A non-owner can only export at its access level, and can only upgrade another 
non-owner's permissions. 

y 

X 

n 

none 
pd subdivide(ptr, len, E); 

n 

none 

y 

E 
A domain can only subdivide with memory it owns and does not share. 

n 

X 

// Create new domain. 

n 

ERROR 
A domain cannot subdivide with memory it does not own. 

n 

X 

y 

Y 
pd free(target); 
// Delete domain. 

y/n 

none 
The supervisor revokes permissions on memory owned by a deleted domain 
from all other domains. The memory owned by the deleted domain becomes 
owned by its parent, which may or may not have been the caller. 

y 

X 

n 

none 
perm alloc(ptr, len); 

y 

X 

n 

RW 
When the allocator owns memory, it allocates it with read-write permissions. 

n 

X 

y 

X 
// Access permissions granted to 

n 

ERROR 
A domain cannot allocate memory to the memory's owner. 

n 

F 

n 

G 
// caller of memory allocator. 

n 

G 

n 
F≥G ? F : ERROR 
A non-owning domain allocates at the access permission it has, and cannot 
downgrade the permissions of another non-owning domain. 

y 

X 

n 

X 
perm free(ptr, len); 

y 

X 

n 

none 
A free revokes permission from all sharing domains. 

n 

X 
// Access permissions revoked 
// from caller of memory allocator 

n 

ERROR 

A non-owning domain cannot free memory. 

Table 1: Memory supervisor policy for memory ownership and permissions. The Before column shows the state of the calling domain and the target domain before the supervisor call, identified by 

the Call column. The After column shows the state after the call. A 'y' (or 'n') in the own? column indicates the domain owns (or does not own) the memory being manipulated. An 'X' or 'Y' in an 
access column indicates an arbitrary memory access permission, though an 'X' in the before and after columns indicates the value has not changed. Other uppercase letters indicate a specific (but 
arbitrary) permissions value; "none" indicates no permissions; "RW" indicates read-write permissions. Columns for domains not involved in a particular call are left empty. An ERROR outcome 
anywhere in a row indicates the supervisor call returns an error for that call. The operator ? :, borrowed from the C language, indicates conditional state. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Mondrix kernel modules. Each module is resident in 
its own domain even when several modules share a description. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Fault injection experiments on Mondrix. Faults either 
resulted in a clean shutdown (this category includes cases where 
the faulting process (and/or others) is terminated), a hang or a 
panic. The # runs column shows the number of instances for 
each symptom (200 runs total). The MMP catch column indi-
cates the number of runs where Mondrix caught a memory per-
missions problem (which was not caught by the kernel's page 
table). 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>Table 4 :</head><label>4</label><figDesc></figDesc><table>The names and descriptions of the benchmarks run on 
Mondrix to evaluate MMP support in the Linux kernel. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>config − xemacs</head><label>−</label><figDesc></figDesc><table>Time (cycles) 

67.11*10^6 
5.50*10^9 
10.94*10^9 
16.37*10^9 

Percentage of execution time 

0 

20 

40 

60 

80 

100 

idle(1.6%) 
u: 
other(4.8%) 
u: 
ld(22%) 
u: 
as(3.5%) 
u: 
cc1(27%) 
u: 
sed(15.4%) 
border between K/U 
k: 
other(3.5%) 
k:user_page_fault(12.8%) 
k: 
mmp_top(0.7%) 
k: 
mmp_bot(2.4%) 
k: 
exit(1.8%) 
k: 
read(2%) 
k: fork_exec(2.4%) 

Kernel (25.7%) User (72.7%) 

thttpd 

Time (cycles) 

4.19*10^6 
75.50*10^6 
146.80*10^6 
218.10*10^6 

Percentage of execution time 

0 

20 

40 

60 

80 

100 

idle(3.1%) 
u: 
other(4.6%) 
u: cgi−progs(7.9%) 
u: cgi−script(13.9%) 
u: 
thttpd(4.2%) 
u: 
syslogd(3%) 
border between K/U 
k: 
other(11.4%) 
k:user_page_fault(15%) 
k: 
mmp_top(2%) 
k: 
mmp_bot(8.9%) 
k: 
exit(3.8%) 
k: open_close(3.7%) 
k: 
write(4.4%) 
k: 
read(2.7%) 
k: fork_exec(8.1%) 
k: interrupt(3.6%) 
Kernel (63.3%) User (33.6%) 

find 

Time (cycles) 

67.11*10^6 
4.97*10^9 
9.87*10^9 

Percentage of execution time 

0 

20 

40 

60 

80 

100 

idle(80.5%) 
u: 
other(0.9%) 
u: 
grep(1.7%) 
u: 
swapper(1.3%) 
border between K/U 
k: 
other(1.8%) 
k: 
mmp_top(1.2%) 
k: 
mmp_bot(1.3%) 
k: open_close(1.8%) 
k: 
read(8.5%) 
k: interrupt(1.1%) 

Kernel (15.6%) User (3.9%) 

MySQL 

Time (cycles) 

2.10*10^6 
69.21*10^6 
136.31*10^6 
203.42*10^6 

Percentage of execution time 

0 

20 

40 

60 

80 

100 

idle(35.4%) 
u:mysql_client_test(8.1%) 
u: 
mysqld(18.5%) 
border between K/U 
k: 
other(4.2%) 
k:user_page_fault(3%) 
k: 
mmp_top(3.3%) 
k: 
mmp_bot(4%) 
k: 
fs_misc(1.1%) 
k: open_close(1.2%) 
k: 
write(17.2%) 
k: 
read(4%) 

Kernel (38%) User (26.6%) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head>Table 5 :</head><label>5</label><figDesc></figDesc><table>Performance overheads for workloads on Mondrix, as 
compared with Linux. The Cyc column shows the number of 
cycles (in billions) for the workloads, and in parenthesis, the 
slowdown of the workload compared with Linux. The Mbot 
column shows the percentage of time spent in the bottom half of 
the memory supervisor, writing permissions tables, while Mtop 
shows the time spent in the top half of the memory supervisor. 
The Kern column shows the overhead in the remaining kernel 
code including code added to the kernel to manage memory 
permissions and PLB refills. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><head>Table</head><label></label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><head>Table 8 :</head><label>8</label><figDesc></figDesc><table>The PLB time column is the percentage execution 
time of each benchmark that the hardware refills the PLB. The 
PLB mr column is the miss rate of the PLB. 

</table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Mach: A new kernel foundation for unix development</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Accetta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">V</forename><surname>Baron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Bolosky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">B</forename><surname>Golub</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">F</forename><surname>Rashid</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tevanian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">W</forename><surname>Young</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Summer Usenix</title>
		<meeting>Summer Usenix</meeting>
		<imprint>
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Advanced Micro Devices</surname></persName>
		</author>
		<ptr target="http://www.amd.com/" />
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The slam project: Debugging system software via static analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sriram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;02</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Extensibility, safety and performance in the SPIN operating system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><forename type="middle">N</forename><surname>Bershad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Savage</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Przemyslaw</forename><surname>Pardyak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Emin Gun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><forename type="middle">E</forename><surname>Sirer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Fiuczynski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Craig</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Susan</forename><forename type="middle">J</forename><surname>Chambers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Eggers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP-15</title>
		<meeting><address><addrLine>Copper Mountain, Colorado</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="267" to="284" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The slab allocator: An object-caching kernel memory allocator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeff</forename><surname>Bonwick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Summer</title>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="87" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Hardware support for fast capability-based addressing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicholas</forename><forename type="middle">P</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><forename type="middle">W</forename><surname>Keckler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">J</forename><surname>Dally</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS-VI</title>
		<meeting><address><addrLine>San Jose, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="319" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">An Operating System Structure for Wide-Address Architectures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Chase</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995-08" />
		</imprint>
		<respStmt>
			<orgName>University of Washington</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The Rio file cache: Surviving operating system crashes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wee</forename><forename type="middle">Teck</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Subhachandra</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gurushankar</forename><surname>Aycock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Rajamani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lowell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS-VII</title>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">CCured in the real world</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Condit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mcpeak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Intel Itanium Architecture Software Developer&apos;s Manual v2</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Intel</forename><surname>Corp</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Microsoft Windows Vista Developer Center</title>
		<ptr target="http://msdn.microsoft.com/windowsvista/default.aspx" />
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
	<note>Microsoft Corporation</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Xen and the art of virtualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Dragovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fraser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Pratt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Warfield</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Barham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Neugebauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;03</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">RacerX: Effective, static detection of race conditions and deadlocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawson</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ken</forename><surname>Ashcraft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP-19</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Self-paging in the nemesis operating system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Steven</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Operating Systems Design and Implementation</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="73" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The performance of microkernel-based systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hermann</forename><surname>Härtig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Hohmuth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jochen</forename><surname>Liedtke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Schonberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean</forename><surname>Wolter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP-16</title>
		<imprint>
			<date type="published" when="1997-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Experiences building a communication-oriented javaos. Software: Practice and Experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Hartman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Larry</forename><surname>Peterson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andy</forename><surname>Bavier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Bigot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Bridges</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brady</forename><surname>Montz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rob</forename><surname>Piltz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Todd</forename><surname>Proebsting</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oliver</forename><surname>Spatscheck</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1107" to="1126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The Mungi single-address-space operating system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gernot</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Elphinstone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jerry</forename><surname>Vochteloo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Russell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jochen</forename><surname>Liedtke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Practice and Experience</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="901" to="928" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">IBM System/38 support for capability-based addressing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Merle</forename><forename type="middle">E</forename><surname>Houdek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><forename type="middle">G</forename><surname>Soltis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roy</forename><forename type="middle">L</forename><surname>Hoffman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th Symposium on Computer Architecture</title>
		<meeting>the 8th Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1981-05" />
			<biblScope unit="page" from="341" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Broad new os research: Challenges and opportunities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Galen</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Larus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Tarditi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ted</forename><surname>Wobber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Workshop on Hot Topics in Operation Systems</title>
		<meeting>the 10th Workshop on Hot Topics in Operation Systems</meeting>
		<imprint>
			<date type="published" when="2005-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An overview of the mesa processor architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Richard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">D</forename><surname>Johnsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the first international symposium on architectural support for programming languages and operating systems</title>
		<meeting>the first international symposium on architectural support for programming languages and operating systems</meeting>
		<imprint>
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Architectural support for single address space operating systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><forename type="middle">J</forename><surname>Koldinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><forename type="middle">S</forename><surname>Chase</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Susan</forename><forename type="middle">J</forename><surname>Eggers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="175" to="186" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Protection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Butler Lampson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th Annual Princeton Conference on Information Sciences and Systems</title>
		<meeting>the 5th Annual Princeton Conference on Information Sciences and Systems<address><addrLine>Princeton University</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1971" />
			<biblScope unit="page" from="437" to="443" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">bochs: The cross platform IA-32 emulator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Lawton</surname></persName>
		</author>
		<ptr target="http://bochs.sourceforge.net/" />
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Capability-Based Computer Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henry</forename><forename type="middle">M</forename><surname>Levy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984" />
			<publisher>Digital Press</publisher>
			<pubPlace>Bedford, Massachusetts</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Implementing an untrusted operating system on trusted hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Lie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chandramohan</forename><surname>Thekkath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Horowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;03</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Architectural support for copy and tamper resistant software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Lie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chandramohan</forename><surname>Thekkath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ban</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Horowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS-IX</title>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Simics: A full system simulation platform</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">S</forename><surname>Magnusson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Christensson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Eskilson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Forsgren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hallberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hogberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Larsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Moestedt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Werner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="50" to="58" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">CMC: A Pragmatic Approach to Model Checking Real Code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madanlal</forename><surname>Musuvathi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andy</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawson</forename><forename type="middle">R</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI-5</title>
		<imprint>
			<date type="published" when="2002-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">CCured: type-safe retrofitting of legacy code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><surname>Mcpeak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Westley</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="128" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A single intermediate language that supports multiple implementations of exceptions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Norman</forename><surname>Ramsey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon Peyton Jones</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="285" to="298" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Protection and the control of information sharing in Multics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jerome</forename><forename type="middle">H</forename><surname>Saltzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="388" to="402" />
			<date type="published" when="1974-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">The protection of information in computer systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Jerome</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">D</forename><surname>Saltzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schroeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE 63 9</title>
		<meeting>the IEEE 63 9</meeting>
		<imprint>
			<date type="published" when="1975" />
			<biblScope unit="page" from="1278" to="1308" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">EROS: A Capability System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><forename type="middle">S</forename><surname>Shapiro</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
		<respStmt>
			<orgName>University of Pennsylvania</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">EROS: a fast capability system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><forename type="middle">S</forename><surname>Shapiro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><forename type="middle">M</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">J</forename><surname>Farber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Operating Systems Principles</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="170" to="185" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Design of the EROS trusted window system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><forename type="middle">S</forename><surname>Shapiro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Vanderburgh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Northup</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Chizmadia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Safe dynamic linking in an extensible operating system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Sirer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fiuczynski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Pardyak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">N</forename><surname>Bershad</surname></persName>
		</author>
		<idno>TR-95-11-01</idno>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
		<respStmt>
			<orgName>University of Washington</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Improving the reliability of commodity operating systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><forename type="middle">N</forename><surname>Bershad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henry</forename><forename type="middle">M</forename><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP-19</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Recovering device drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><forename type="middle">N</forename><surname>Muthukaruppan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henry</forename><forename type="middle">M</forename><surname>Bershad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI-6</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Scale and performance in the denali isolation kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Whitaker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Shaw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gribble</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI &apos;02</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">The Cambridge CAP Computer and Its Operating System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maurice</forename><forename type="middle">V</forename><surname>Wilkes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roger</forename><forename type="middle">M</forename><surname>Needham</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979" />
			<publisher>North Holland</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Project Oberon: The Design of an Operating System and Compiler</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Niklaus</forename><surname>Wirth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Hardware works, software doesn&apos;t: Enforcing modularity with Mondriaan memory protection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emmett</forename><surname>Witchel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krste</forename><surname>Asanovi´casanovi´c</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HotOS-9</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Mondrian memory protection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emmett</forename><surname>Witchel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Josh</forename><surname>Cates</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krste</forename><surname>Asanovi´casanovi´c</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">10th International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<imprint>
			<date type="published" when="2002-10" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
