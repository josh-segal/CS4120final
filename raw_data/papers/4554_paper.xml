<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:53+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher>Springer</publisher>
				<availability status="unknown"><p>Copyright Springer</p>
				</availability>
				<date type="published" when="2006">2006</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sylvain</forename><surname>Schmitz</surname></persName>
							<email>schmitz@i3s.unice.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">Laboratoire I3S</orgName>
								<orgName type="institution">Universidad de Las Palmas de Gran Canaria</orgName>
								<address>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacques</forename><surname>Farré</surname></persName>
							<email>jacques.farre@unice.fr</email>
							<affiliation key="aff1">
								<orgName type="institution">Université de Nice -Sophia Antipolis &amp; CNRS</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
					</analytic>
					<monogr>
						<title level="j" type="main">Lecture Notes in Computer Science</title>
						<imprint>
							<publisher>Springer</publisher>
							<biblScope unit="page" from="253" to="264"/>
							<date type="published" when="2006">2006</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1007/11812128</idno>
					<note>Shift-Resolve Parsing: Simple, Unbounded Lookahead, Linear Time * José Fortes Gálvez * Also in shorter form in Oscar H. Ibarra and Hsu-Chun Yen, editors, CIAA&apos;06, vol-ume 4094 of</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Shift-resolve, noncanonical parser, regular lookahead, two- stack pushdown automaton, position graph ACM categories: D31 [Programming Languages]: Formal Definitions and Theory-Syntax</term>
					<term>D34 [Programming Languages]: Processors- Parsing</term>
					<term>F42 [Mathematical Logic and Formal Languages]: Grammars and Other Rewriting Systems-Parsing</term>
				</keywords>
			</textClass>
			<abstract>
				<p>This paper introduces a mechanism for combining unbounded looka-head exploration with linear time complexity in a deterministic parser. The idea is to use a resolve parsing action in place of the classical reduce. The construction of shift-resolve parsers is presented as a two-step algorithm, from the grammar to a finite nondeterministic automaton, and from this automaton to the deterministic parser. Grammar classes comparisons are provided.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Common deterministic parser generators <ref type="bibr" target="#b4">[5]</ref> provide a parser developer with two interesting static guarantees: that the input grammar is unambiguous, and that the resulting parser will process its input string in linear time. There is however a major issue with these parser generation algorithms: they cannot provide a deterministic parser for an arbitrary context-free grammar, resulting in the infamous conflicts between possible parsing actions. Their inability to deal with parsing decisions that need more than the pre-established k lookahead terminal symbols is to blame for a large part of it.</p><p>Two different parsing techniques allow to circumvent this limitation to bounded lookaheads in bottom-up parsers, but to keep the unambiguity guarantee. The first, called regular lookahead parsing, uses a finite state automaton to explore an unbounded right context <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b5">6]</ref>. The linear time guarantee is however lost. The second, called noncanonical parsing, explores the right context using the parser itself. The latter can thus perform some reductions in this right context, return to the conflict point, and use a bounded number of the newly reduced symbols to yield a deterministic decision <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b11">12]</ref>. However, the preset bound on the reduced lookahead length-in practice the bound is k = 1-hampers the power of the noncanonical methods.</p><p>We want to have our cake and eat it too: we want linear time parsing, ambiguity detection, and no user defined bound on the lookahead length. Shiftresolve parsing is a new combination of the regular and noncanonical strategies that achieves all these properties. To this end, we make the following contributions.</p><p>• We propose a new parsing action, resolve (Section 2.1), which combines the classical reduction with a pushback, i.e. it rewinds the stack down to the point where the reduction should take place. The exact amount of pushback is not fixed, but computed for each reduction as a minimal necessary length.</p><p>• By promoting the resolve action as a replacement for the reduce action, our parsers properly integrate noncanonical resolutions in the right context exploration (Section 2.2). One could fear that a quadratic time complexity would stem from this combination. We avoid it by ensuring that the pushback lengths remain bounded.</p><p>• We present the construction of shift-resolve parsers as the determinization of a phrase recognizer (Section 4). The algorithm generalizes similar constructions for LR parsers. The choice of the approximations used in order to have a finite recognizer is left open, and we use a lattice of possible approximations (Section 3.2). Hence, our method is highly generic and allows for tradeoffs between descriptional complexity and classes of accepted grammars.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Shift-Resolve Parsing</head><p>A bottom-up parser operates by reverting the derivations that led from the axiom of the grammar to the input string. Each of these reversions is the reduction of a phrase α to a nonterminal A, where A→α is a rule of P . A canonical parser always reduces the leftmost phrase in a given sentential form, called the handle of the sentential form, but a noncanonical parser partially ignores this ordering. It is able to reduce a phrase further right from a handle, and to use the additional information provided by the newly reduced nonterminals to infer its parsing decisions. Indeed, a single nonterminal symbol describes a complete context-free language, and, using only a few nonterminals as lookahead, a noncanonical parser has an impressive amount of right context information at its disposal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The Approach</head><p>We make here the simplifying choice of always using completely reduced lookahead symbols: symbols as they appear in the grammar rule we are exploring, <ref type="table" target="#tab_0">$  a  b  c  S  A  B  C  D  q0  s4  s5  s1  s2  s3  q1  r1'0  q2  s8  s6  s7  q3  s8  s9  s10  q4</ref> s8 and cannot be reduced without reducing the entire rule.</p><formula xml:id="formula_0">r5'0 r5'0 q5 s8 r7'0 r7'0 q6 s11 s8 q7 s8 r4'0 r4'0 q8 r8'0 r9'0 s8 s12 s13 q9 s8 r6'0 r6'0 q10 s14 s8 q11 r2'0 q12 r9'1 s8 r8'1 r8'1 q13 r8'1 s8 r9'1 r9'1 q14 r3'0</formula><p>As usual in noncanonical parsing <ref type="bibr" target="#b0">[1]</ref>, a deterministic two-stack model is used to hold the current sentential form. The parsing (or left) stack corresponds to the traditional LR stack, while the input (or right) stack initially contains the input string. Two operations allow to move symbols from the top of one stack to the top of the other: a shift of a symbol from the input stack to the parsing stack, and a pushback of a bounded number of symbols the other way around. A reduction using rule A→α removes the topmost |α| symbols from the parsing stack and pushes A on top of the input stack.</p><p>We compute, for each reduction, the minimal bounded reduced lookahead length needed to discriminate it from other parsing actions. This lookahead exploration is properly integrated in the parser. Once the parser succeeds in telling which action should have been done, we either keep parsing if it was a shift, or need to reduce at an earlier point. The pushback brings the parser back at this point; we call the combination of a pushback and a reduction a resolution.</p><p>No cost is paid in terms of computational complexity, since shift-resolve parsers are linear in the length of the input text. A simple proof is that the only re-explored symbols are those pushed back. Since pushback lengths are bounded, and since each reduction gives place to a single pushback, the time linearity is clear if the number of reductions is linear with the input length. This last point stems from the fact that our method detects and rejects cyclic grammars.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Parsing Example</head><p>Let us consider the extended grammar with rules</p><formula xml:id="formula_1">S ′ 1 −→S, S 2 −→ACa, S 3 −→BDb, A 4 −→AD, A 5 −→a, B 6 −→BC, B 7 −→b, C 8 −→c, D 9 −→c. (G 1 )</formula><p>Grammar G 1 can require an unbounded lookahead if we consider approximated parsing methods, like for instance a LR(0) approximation, which provides the basis for most practical parsing methods. We have here a non-null pushback: the resolve action r 9 '1, which would have needed an unbounded terminal lookahead, is solved using the stacked C and the lookahead a. The pushback of length 1 emulates a reduced lookahead inspection of length 2. <ref type="table">Table 2</ref>: The parse of the string acca by the shift-resolve parser for G 1 .</p><formula xml:id="formula_2">q 0 aq 4 DCa$ r 5 '0 q 0 ADCa$ s 2 q 0 Aq 2 DCa$ s 7 q 0 Aq 2 Dq 7 Ca$ r 4 '0 q 0 AC$ s 2 q 0 Aq 2 Ca$ s 6 q 0 Aq 2 Cq 6 a$ s 11 q 0 Aq 2 Cq 6 aq 11 $ r 2 '0 q 0 S$ s 1 q 0 Sq 1 $ r 1 '0, accept</formula><p>reading Ac, the lookahead for the reduction to C is a, while the one for the reduction to D is c + a. After reading Bc, the lookaheads are c + b and b respectively. Thus, if we use a LR(0) approximation, we need an unbounded terminal lookahead length in order to choose between the reduction to C or D, when seeing the last input symbol a or b after a sequence c + . Grammar G 1 is not LALR(1). If we try to use more advanced parsers, G 1 is not NSLR(1) <ref type="bibr" target="#b14">[15]</ref>-it is NSLR(2)-, and the time complexity of XLR(∞) parsing <ref type="bibr" target="#b1">[2]</ref> -LR-Regular using a LR(0) approximation-according to G 1 is quadratic. <ref type="table" target="#tab_0">Table 1</ref> contains the parse table for shift-resolve parsing according to G 1 . The table is quite similar to a LR(1) table, with the additional pushback length information, but describes a parser with much more lookahead information. States are denoted by q i ; shift entries are denoted as s i where i is the new state of the parser; resolve entries are denoted as r i 'j where i is the number of the rule for the reduction and j the pushback length. The reduction according to rule S ′ 1 −→S indicates that the input is successfully parsed. <ref type="table">Table 2</ref> details the parsing steps on the valid input acca. Symbols are interleaved with states in the parsing stack in order to ease the reading, and are not actually used.</p><p>The originality of shift-resolve parsing resides in that <ref type="table" target="#tab_0">Table 1</ref> is not the result of a very precise computation; in fact, we used the worst approximation we tolerate. Still, the parsing time is linear and no preset lookahead length was </p><formula xml:id="formula_3">S ′ → · S$ S ′ →S · $ S S→AC · a S→ACa · S→ · ACa S→A · Ca a A C A→ · AD A→AD · A→A · D A D A→AD · A→ · AD A→A · D A D A→ · a A→a · a D→ · c D→c · c D→ · c D→c · c C→ · c C→c · c d2 r2 r8 d8 r9 d9 r5 d9 r9 d5 d4 d4 r4 r4 $ (b) Position graph</formula><p>Figure 1: Representing the derivation of string accca in G 1 .</p><p>necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Grammatical Representation</head><p>The shift-resolve parsing table presented in <ref type="table" target="#tab_0">Table 1</ref> is the result of a two-steps process: the first step builds a finite nondeterministic automaton from the grammar, and the second generates the deterministic shift-resolve parser from it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Position Graph</head><p>We consider here a graph representation of a context-free grammar. This graph can be seen as the set of all left to right walks in all possible derivation trees for the grammar. The nodes of this graph are positions to the immediate left or immediate right of a derivation tree node. The vertices tell which other positions are reachable. We label each position with a dotted rule giving its local context. For instance, with G 1 , any tree node ν A with symbol A can nondeterministically derive a node ν a with symbol a from A→a, or two nodes ν ′ A and ν D with symbols A and D from A→AD. Following this idea, we find that the local context of ν ′ A provides us with more information than the mere symbol A: the symbol A in question is in front of a dot in the position A→ · AD.</p><p>If we make this local context explicit in the labels of the positions, then the relations between these positions become visible. These transitions are of three types: symbol transitions  <ref type="figure" target="#fig_3">Figure 2</ref>: Nondeterministic automaton for Grammar G 1 using κ 0 .</p><formula xml:id="formula_4">(G) = h(L(b(G))). · C · A · D A · D · S · S→AC · a S→A · Ca S→ · ACa S→ · BDb S→B · Db S→BD · b ε ε ε ε ε ε ε ε ε C→ · c c C→c · C · S→BDb · ε ε A→ · a A→a · A→ · AD A→A · D D→ · c D→c · A→AD · ε ε ε a C A B D b A a · S S→ACa · ε D B→ · BC B→B · C B B→BC · B→ · b b B→b · · B B · C ε c d9 d2 d3 r6 d6 d8 d7 r4 d4 d5 r3 r5 r9 r8 r7 r2 S ′ → · S$ S ′ → · S$ S ε ε $</formula><p>In order to uniquely identify a single position in the position graph, we define valid positions for a grammar G as triples</p><formula xml:id="formula_5">δd i [A i −→α · α ′ ]r i y such that S⇒ rm * δAy⇒ rm δd i αα ′ r i y in b(G).<label>(1)</label></formula><p>For instance, the position labeled by C→ · c in <ref type="figure">Figure 1b</ref>  </p><formula xml:id="formula_6">δ[A i −→α · Xα ′ ]y X −→ δ[A i −→αX · α ′ ]y,<label>(2)</label></formula><formula xml:id="formula_7">δ[A i −→α · Bα ′ ]y dj −→ δαd j [B j −→ · β]r j uy if α ′ ⇒ * u in b(G), and (3) δαd j [B j −→β · ]r j uy rj −→ δ[A i −→αB · α ′ ]y if α ′ ⇒ * u in b(G).<label>(4)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Position Equivalences</head><p>We are eager to put explicit labels on our positions because we intend to collapse the position graph into a finite graph. The equivalence relations defined to this end will preserve the local context, and thus use the position labels. </p><formula xml:id="formula_8">[p] κ χ −→ κ [q] κ iff ∃p ′ ∈ [p] κ , q ′ ∈ [q] κ , p ′ χ −→ q ′ .<label>(5)</label></formula><p>Simple Equivalence Relation <ref type="figure" target="#fig_3">Figure 2</ref> is not a Rorschach test but the collapsed position graph Γ κ0 for G 1 using a simple equivalence relation κ 0 between positions.</p><p>Definition 3 Two positions are simply equivalent if and only if they have the same dotted rule as label, i.e.</p><formula xml:id="formula_9">δ[A→α · α ′ ]y κ 0 γ[B→β · β ′ ]z iff A→α · α ′ = B→β · β ′ .<label>(6)</label></formula><p>While very basic, this equivalence relation is fine enough to yield a working shift-resolve parser for G 1 . It is the simplest equivalence relation we will use for shift-resolve parsing.</p><p>Base Positions The addition of base positions to N as in <ref type="figure" target="#fig_3">Figure 2</ref> is straightforward. We identify them as δ[ · A]y or δ[A · ]y whenever S⇒ rm * δAy in G; Equations (3) and (4) are then replaced by</p><formula xml:id="formula_10">δ[A i −→α · Bα ′ ]y ε −→ δα[ · B]uy if α ′ ⇒ * u in b(G),<label>(7)</label></formula><formula xml:id="formula_11">δα[ · B]uy dj −→ δαd j [B j −→ · β]r j uy,<label>(8)</label></formula><formula xml:id="formula_12">δαd j [B j −→β · ]r j uy rj −→ δα[B · ]uy, and<label>(9)</label></formula><formula xml:id="formula_13">δα[B · ]uy ε −→ δ[A i −→αB · α ′ ]y if α ′ ⇒ * u in b(G).<label>(10)</label></formula><p>When the number |N | of nonterminals is small compared to the number |P | of rules of G, as quite often in practical grammars, base positions allow to significantly diminish the size of Γ κ0 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lattice of Equivalence Relations</head><p>The usual partial order on Eq(N )-the complete lattice of all equivalence relations on N -is the inclusion relation ⊆. For any two elements κ a and κ b of Eq(N ), κ a ∧ κ b is the greatest lower bound or meet, defined as</p><formula xml:id="formula_14">κ a ∧ κ b = κ a ∩ κ b .<label>(11)</label></formula><p>Finer equivalence relations are obtained when using the meet of two equivalence relations; they result in larger collapsed position graphs. Let K be the set of all equivalence relations that are included in κ 0 ; K is an obvious interval sublattice of Eq(N ), ordered by the inclusion relation. We will only make use of equivalence relations in K: if κ is in K, then κ = κ 0 ∧ κ ′ for some κ ′ in Eq(N ). Equivalence relations in K abound: for instance, a relation κ k with LR(k) precision could be written as κ 0 ∧ l k with</p><formula xml:id="formula_15">δ[A→α · α ′ ]y l k γ[B→β · β ′ ]z iff k : h(y) = k : h(z);<label>(12)</label></formula><p>the set of equivalence classes using l k is <ref type="bibr">[N ]</ref> l k = T ′k -the set of different sequences of k terminals. An experimental parser generator with a much finer equivalence relation is currently available from the Internet at the following address: http://serdis.dis.ulpgc.es/ ∼ ii-pl/ftp/dr.</p><p>If κ = κ 0 ∧ κ ′ , we can still optimize the size of Γ κ with base positions. If p is a position in N , then we only have to identify <ref type="bibr">[p]</ref> κ as a pair <ref type="bibr">([p]</ref>  <ref type="bibr">where</ref> [p] κ0 can be a base position.</p><formula xml:id="formula_16">κ0 , [p] κ ′ ),</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Nondeterministic Automaton</head><p>We call a collapsed position graph Γ κ using an equivalence relation κ in K a nondeterministic automaton.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Preserving Grammar Derivations</head><formula xml:id="formula_17">Theorem 1 If S⇒ * δAρ⇒δr i αα ′ d i ρ = γα ′ d i ρ = γσ holds in b(G), then ν 0 γ −→ * κ [δr i [A i −→α · α ′ ]d i x] κ σ −→ * κ ν 1 with ρ⇒ * x holds in Γ κ . Proof</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Shift-Resolve Parsers</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Shift-Resolve Parser Construction</head><p>We now describe how to extract a deterministic shift-resolve parser from a nondeterministic automaton Γ κ . The algorithm is based on a subset construction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>States of the Shift-Resolve Parser</head><p>The states of the shift-resolve parser are sets of items <ref type="bibr">[ν, sr , d]</ref>, where ν is an equivalence class on N using κ-i.e. a state in Γ κ -, sr a parsing action-either a production number or 0 to code a shift-, and d is a nonnegative integer to code the distance to the resolution point. By convention, we assume that d is null whenever sr denotes a shift. Initial state's item set is computed as</p><formula xml:id="formula_18">I q0 = C({[ν 0 , 0, 0]}),</formula><p>where the closure C of an item set I is the minimal set such that </p><formula xml:id="formula_19">C(I) = I ∪ {[ν ′ , 0, 0] | [ν, sr , d] ∈ C(I), ν di −→ κ ν ′ } ∪ {ι | [ν, sr , d] ∈ C(I), ν ri −→ κ ν ′ , ¬(</formula><formula xml:id="formula_20">= [ν ′ , sr , d]))},</formula><p>where, by noting L the terminal language produced by a sequence of symbols, we discard superfluous ε-reductions with the help of the conditions</p><formula xml:id="formula_21">null (i) iff A i −→α, L(α) = {ε} null (I) iff [[δ[A→αX · β]y] κ , sr, d] ∈ I, L(X) = {ε}.</formula><p>Transition from state item set I with symbol X is defined as follows.   <ref type="figure" target="#fig_7">Figure 3</ref> presents the details of the item sets computations for states q 8 and q 12 of the shift-resolve parser presented in <ref type="table" target="#tab_0">Table 1</ref>. Lemma 1 states that two positions reachable from ν 0 by the same language will appear in a single item set of the shift resolve parser.</p><formula xml:id="formula_22">· , r8, 1 S→AC · a, r9, 1 B→B · C, r8, 1 S→B · Db, r8, 1 C→ · c D→ · c c C c C→c · D→c · S→AC · a, r8, 0 B→B · C, r8, 0 S→B · Db, r8, 0 S→BD · b, r9, 0 A→A · D, r9, 0 S→A · Ca, r9, 0 C→ · c D→ · c</formula><formula xml:id="formula_23">∆(I, X) = C({[ν ′ , sr , d ′ ] | [ν, sr , d] ∈ I, ν X −→ κ ν ′ , ((sr = 0 and d ′ = 0) or (sr 񮽙 = 0 and d ′ = d + 1))})</formula><p>Lemma 1 Let z be a terminal string in T * , u and v two strings in</p><formula xml:id="formula_24">(T ∪ {d i | i ≤ |P |} ∪ {r i | i ≤ |P |}) * such that h(u) = h(v) = z, ν 0 u −→ * κ ν, ν 0 v −→ * κ ν ′ in Γ k and ν 񮽙 = ν ′ .</formula><p>Then there exists a cover string ϕ in</p><formula xml:id="formula_25">V * for (u, v) such that {[ν, sr , d], [ν ′ , sr ′ , d ′ ]} is included in the item set ∆(I q0 , ϕ).</formula><p>Proof. We outline the proof by induction on the length |u| + |v|.</p><p>If u = v = ε, then z = ε and ϕ = ε is a cover for (ε, ε). There are three possible atomic steps that allow to increase |u| + |v|: append a single d i or r i to either u or v, or append a terminal symbol a to both.</p><p>If u = u ′ d i and ϕ is a cover for (u ′ , v), then ϕ is also a cover for (u, v). If u = u ′ a, v = v ′ a and ϕ is a cover for (u ′ , v ′ ), then ϕa is clearly a cover for (u, v). If u = u ′ r i and ϕ is a cover for (u ′ , v), then two different cases arise. The first case occurs when null (i), ϕ = ϕ ′ γ, L(γ) = ε, ϕ ′ = δX with L(X) 񮽙 = ε or ϕ ′ = ε. Then ϕ ′ is a cover for (u, v). The second case occurs otherwise, and then ϕ is clearly a cover for (u, v). 񮽙 Parser <ref type="table">Table Parser table entries</ref>, i.e., shifts and resolves, are computed from the item set I q of each state q as follows.</p><formula xml:id="formula_26">T (q, X) = if ∀ι = [[δ[A→α · Xβ]x] κ , sr , d] ∈ I q ,</formula><p>sr = r: resolve r with pushback d (if r = 1 and d = 0, accept) otherwise: shift to q ′ such that I q ′ = ∆(I q , X)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Shift-Resolve Grammars</head><p>Rejection Condition A grammar is inadequate if and only if two different state item sets are built with identical item sets except for some pushback length(s); otherwise, we write it is a ShRe(κ) grammar. It follows that the worst-case space complexity of the shift-reduce parser for G is O(2 |Γκ||P | ). More powerful shift-resolve parsers can be obtained at the price of descriptional complexity if we add to the condition that one such state should be ∆-reachable from the other.</p><p>Theorem 2 If G is ambiguous, then it is not ShRe(κ) for any κ in K. Proof. We merely outline the proof.</p><p>Since G is an ambiguous context-free grammar, we can find two leftmost derivations S ⇒ lm * xAρ ⇒ lm xαα ′ ρ = xασ and S ⇒ lm * yBσ ⇒ lm yβσ in G, with Aαα ′ 񮽙 = Bβ, and such that there is a z in T * with xα⇒ * z and yβ⇒ * z.</p><p>Such derivations are mirrored in the nondeterministic automaton Γ κ by two</p><formula xml:id="formula_27">positions ν = [δ[A→α · α ′ ]s] κ and ν ′ = [γ[B→β · ]t] κ such that ν 0 u −→ * κ ν χ −→ * κ ν 1 and ν 0 u ′ −→ * κ ν ′ χ ′ −→ * κ ν 1 , with h(u) = h(u ′ ) = z (13) h(χ) = h(χ ′ ) = σ.<label>(14)</label></formula><p>In such a situation, there is a prefix ϕ in V * such that some items [ν, sr , d] and [ν ′ , sr ′ , d ′ ] are included in the item set of ∆(I q0 , ϕ). The right context of this shift-resolve parser state is σ$ * , an infinite regular language. Since ν 񮽙 = ν ′ (Aαα ′ 񮽙 = Bβ and κ = κ 0 ∧ κ ′ ), we are bound to find two item sets only differing on the pushback lengths, and therefore G is found inadequate. 񮽙</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Grammar Classes</head><p>The classes of ShRe(κ k )-κ k is defined as the meet of k 0 and l k from Equation (12)-grammars are not comparable with the classes of LR(k) grammars. For instance, we can produce a shift-resolve parser for the grammar with rules</p><formula xml:id="formula_28">S→AC | BCb, A→d, B→d, C→aCb | c (G 2 )</formula><p>using κ 0 , but G 2 is not LR(k) for any value of k-as a matter of fact, it is not LR-Regular either. Conversely, for k &gt; 0, we can put an unbounded number of null nonterminals between a conflict and its resolution. For instance, the grammar with rules</p><formula xml:id="formula_29">S→Aa | Bb, A→cAE | c, B→cBE | c, E→ε (G 3 )</formula><p>is LR(1) but not ShRe(κ) for any κ: once we reach the a or b symbol allowing to resolve, we would need to pushback an unbounded number of E symbols in order to have the c we intend to reduce on top of the parsing stack. A simplification we made in the shift-resolve construction makes it possible for a LR(0) to be inadequate using κ k . This is the case for the grammar with rules S→Sa | B, A→a, B→dBA | b.</p><p>(G 4 ) <ref type="figure" target="#fig_8">Figure 4</ref> shows how the resolution in a shift-resolve state with a single possible reduction (here B→b) can be tricked into an useless exploration of the right context caused by the κ k approximations. The issue can be tackled on the nondeterministic automaton level by choosing a finer equivalence relation, for instance κ = κ 0 ∧ c 1 where</p><formula xml:id="formula_30">B→b · , 0, 0 S→B · , r7, 0 S→S · a, r7, 0 S ′ →S · $, r7, 0 B→dB · A, r7, 0 A→ · a, 0, 0 b q0 S→Sa · , r7, 1 A→a · , 0, 0 S→S · a, r7, 1 S ′ →S · $, r7, 1 B→dbA · , r5, 0 S→B · , r5, 0 S→S · a, r5, 0 S ′ →S · $, r5, 0 B→db · A, r5, 0 A→ · a, 0, 0 a S→Sa · , r7, 2 A→a · , 0, 0 S→S · a, r7, 2 S ′ →S · $, r7, 2 B→dbA · , r5, 0 S→B · , r5, 0 S→S · a, r5, 0 S ′ →S · $, r5, 0 B→db · A, r5, 0 A→ · a,</formula><formula xml:id="formula_31">δ[A→α · α ′ ]y c 1 γ[B→β · β ′ ]z iff h(δ) : 1 = h(γ) : 1. (15)</formula><p>The issue can also be tackled on the subset construction level if we test whether following r i transitions in the nondeterministic automaton is necessary for a resolution, and if not, fill the entire parser table line with this resolution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Related Work</head><p>Shift-resolve parsing is related to two areas: parsing techniques and nondeterministic grammatical representations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Parsing Techniques</head><p>The presence of conflicts in deterministic parsers is a widely acknowledged issue. Transforming an input grammar until no more conflicts can be found is a tedious task, can obfuscate the grammar, and may result in convoluted semantic actions. It is therefore tempting for a parser developer to trade the two static guarantees-unambiguity and linear time recognition-for his confidence in his own skill in the handling of ambiguities and a reasonable chance of having a linear time parser <ref type="bibr" target="#b15">[16]</ref>. Another line of research is to see how far one can go without sacrificing the static guarantees.</p><p>This line has given birth to the LR-Regular <ref type="bibr" target="#b3">[4]</ref> and noncanonical <ref type="bibr" target="#b13">[14]</ref> parser families. To the best of our knowledge, the only other combination of the two families <ref type="bibr" target="#b6">[7]</ref> is an extension to DR(k) parsing <ref type="bibr" target="#b7">[8]</ref>. It suffers from a worst-case quadratic parsing time complexity inherent to DR(k) parsing with non LR(k) grammars.</p><p>Using only completely reduced symbols in noncanonical parsing was already investigated with the Leftmost SLR(1) parsers <ref type="bibr" target="#b14">[15]</ref>, and discarded as less powerful than Noncanonical SLR(1) parsing. We improve on LSLR(1) parsers by allowing a non-predefined lookahead length and more powerful approximations in our grammatical representations.</p><p>Finally, to the extent of our knowledge, Grammar G 1 is the first published instance of a quadratic parsing time complexity with a regular lookahead parser.</p><p>Nondeterministic Grammatical Representations Before becoming a classical presentation <ref type="bibr" target="#b8">[9]</ref> and a classical implementation <ref type="bibr" target="#b4">[5]</ref> for LR(k) parser constructions, nondeterministic grammatical representations were used for efficient LR(k) testing <ref type="bibr" target="#b10">[11]</ref>. Item grammars are a very similar representation <ref type="bibr" target="#b9">[10]</ref>. They have also been used as a unifying framework for parsing methods <ref type="bibr" target="#b12">[13]</ref>. Our idea of using the lattice of equivalence relations for the various possible approximations seems to be new.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>Shift-resolve parsing is a novel parsing method with an attractive combination of properties: the produced parsers are deterministic, they can use an unbounded lookahead, and they run in linear time. Their generation is the result of a highly generic algorithm working on a nondeterministic automaton. It is easy to design new approximations for the automaton in order to improve the grammatical coverage.</p><p>The next logical step is the investigation of which conditions would yield shift-resolve parsers that keep running in linear time even if we allow unbounded pushback lengths.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>X</head><label></label><figDesc>−→, and a two kinds of ε-transitions: derivation transitions di −→ and reduction transitions ri −→ where i is a rule number. Figure 1 presents the portion deriving accca of the position graph for G 1 , along with the traditional derivation tree representation. We emulate an infinite number of end of file markers with a looping transition $ −→. We introduce the bracketed grammar b(G) of a context-free grammar G as the grammar with rules A i −→d i αr i whenever A i −→α is a rule of G. We also define a homomorphism h that removes all the d i and r i symbols from a string. An immediate consequence is that L</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>is identified by the expression d 2 Ad 8 [C 8 −→ · c]r 8 ar 2 . Definition 1 The position graph I = N , −→→ of grammar G associates the (potentially infinite) set N of valid positions for G with the labeled relation −→ defined by</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Definition 2</head><label>2</label><figDesc>The collapsed position graph Γ κ = [N ] κ , −→ κ of a position graph I = N , −→→ associates [N ] κ the finite set of equivalence classes [p] κ over N modulo κ with the labeled relation −→ κ defined by</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Let us denote by ν 0 = [ε[S ′ → · S$]ε] κ the equivalence class on N using κ containing ε[S ′ → · S$]ε, and by ν 1 = [ε[S ′ →S · $]ε] κ the one containing ε[S ′ →S · $]ε. We also denote by χ −→ * κ the transitive reflex- ive closure of −→ κ , labeled with χ the sequence of labels on the individual relations. We show here a simple result: paths in a nondeterministic automaton correspond to derivations in the bracketed grammar.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>null (i) and null (I)), ((sr = 0 and ι = [ν ′ , i, 0]) or (sr 񮽙 = 0 and ι</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Item sets of some states of the shift-resolve parser for Grammar G 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Item sets exhibiting the inadequacy of Grammar G 4 using κ 0 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table>Shift-resolve parsing table for G 1 . 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head></head><label></label><figDesc>. A straightforward induction on the length of γ. 񮽙</figDesc><table>Size of the Nondeterministic Automaton The index of κ 0 is |G|, thus, 
the size of Γ κ0∧κ ′ is in the worst case O(|[N ] κ ′ |.|G|) where |[N ] κ ′ | is the index 
of κ ′ . 

</table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The Theory of Parsing, Translation, and Compiling. Volume I: Parsing. Series in Automatic Computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alfred</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1972" />
			<publisher>Prentice Hall</publisher>
			<biblScope unit="page" from="0" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Extending lookahead for LR parsers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Theodore</forename><forename type="middle">P</forename><surname>Baker</surname></persName>
		</author>
		<idno type="doi">0022-0000.doi:10.1016/0022-0000(81)90030-1</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="243" to="259" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Practical arbitrary lookahead LR parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manuel</forename><forename type="middle">E</forename><surname>Bermudez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karl</forename><forename type="middle">M</forename><surname>Schimpf</surname></persName>
		</author>
		<idno type="doi">0022-0000.doi:10.1016/0022-0000(90)90037-L</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="230" to="250" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">LR-Regular grammars-an extension of LR(k) grammars</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rina</forename><surname>Karelčulikkarelˇkarelčulik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Cohen</surname></persName>
		</author>
		<idno>0022-0000</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="66" to="96" />
			<date type="published" when="1973" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Bison version 2.1</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Donnely</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Stallman</surname></persName>
		</author>
		<ptr target="http://www.gnu.org/software/bison/manual/" />
		<imprint>
			<date type="published" when="2005-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A bounded-connect construction for LR-Regular parsers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacques</forename><surname>Farré</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">José Fortes</forename><surname>Gálvez</surname></persName>
		</author>
		<ptr target="http://springerlink.com/content/e3e8g77kxevkyjfd" />
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<editor>Reinhard Wilhelm</editor>
		<imprint>
			<biblScope unit="volume">2027</biblScope>
			<biblScope unit="page" from="244" to="258" />
			<date type="published" when="2001" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Bounded-connect noncanonical discriminating-reverse parsers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacques</forename><surname>Farré</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">José Fortes</forename><surname>Gálvez</surname></persName>
		</author>
		<idno type="doi">0304-3975.doi:10.1016/j.tcs.2003.10.006</idno>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">313</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="73" to="91" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">A Discriminating Reverse Approach to LR(k) Parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">José</forename><surname>Fortes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gálvez</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
		<respStmt>
			<orgName>Universidad de Las Palmas de Gran Canaria and Université de Nice-Sophia Antipolis</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Parsing Techniques: A Practical Guide</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dick</forename><surname>Grune</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Ceriel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Jacobs</surname></persName>
		</author>
		<idno>ISBN 0-13-651431-6</idno>
		<ptr target="http://www.cs.vu.nl/∼dick/PTAPG.html" />
		<imprint>
			<date type="published" when="1990" />
			<publisher>Ellis Horwood Limited</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A parsing automata approach to LR theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephan</forename><surname>Heilbrunner</surname></persName>
		</author>
		<idno type="doi">0304-3975.doi:10.1016/0304-3975(81)90067-0</idno>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="117" to="157" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On the complexity of LR(k) testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Harry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><forename type="middle">G</forename><surname>Hunt</surname><genName>III</genName></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><forename type="middle">D</forename><surname>Szymanski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ullman</surname></persName>
		</author>
		<idno type="doi">0001-0782.doi:10.1145/361227.361232</idno>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="707" to="716" />
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Noncanonical LALR(1) parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sylvain</forename><surname>Schmitz</surname></persName>
		</author>
		<idno type="doi">3-540-35428-X.doi:10.1007/1177914810</idno>
	</analytic>
	<monogr>
		<title level="m">DLT&apos;06</title>
		<editor>Zhe Dang and Oscar H. Ibarra</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="volume">4036</biblScope>
			<biblScope unit="page" from="95" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Towards a unifying theory of context-free parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Schöbel-Theuer</surname></persName>
		</author>
		<idno>126-1994</idno>
		<ptr target="http://citeseer.ist.psu.edu/117476.html" />
	</analytic>
	<monogr>
		<title level="m">ASMICS Workshop on Parsing Theory</title>
		<editor>G. Pighizzini and P. San Pietro</editor>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="89" to="100" />
		</imprint>
		<respStmt>
			<orgName>Università di Milano</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Noncanonical extensions of bottom-up parsing techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">H</forename><surname>Szymanski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Williams</surname></persName>
		</author>
		<idno type="doi">0097-5397.doi:10.1137/0205019</idno>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="231" to="250" />
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kuo-Chung</forename><surname>Tai</surname></persName>
		</author>
		<idno type="doi">0164-0925.doi:10.1145/357073.357083</idno>
	</analytic>
	<monogr>
		<title level="j">Noncanonical SLR(1) grammars. ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="295" to="320" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Efficient Parsing for Natural Language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Masaru</forename><surname>Tomita</surname></persName>
		</author>
		<idno>ISBN 0-89838-202-5</idno>
		<imprint>
			<date type="published" when="1986" />
			<publisher>Kluwer Academic Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
