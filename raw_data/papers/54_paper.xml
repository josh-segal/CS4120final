<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:28+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Streaming Scalable Video over WiMAX Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Somsubhra</forename><surname>Sharangi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">School of Computing Science</orgName>
								<orgName type="department" key="dep2">School of Computing Science</orgName>
								<orgName type="institution">Simon Fraser University Surrey</orgName>
								<address>
									<region>BC</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ramesh</forename><surname>Krishnamurti</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">School of Computing Science</orgName>
								<orgName type="institution">Simon Fraser University Burnaby</orgName>
								<address>
									<region>BC</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohamed</forename><surname>Hefeeda</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Simon Fraser University Surrey</orgName>
								<address>
									<region>BC</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Streaming Scalable Video over WiMAX Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Broadcasting multiple scalable video streams over wireless broadband access networks in real time is a challenging problem, because of the limited channel capacity and variable bit rate of the videos. The difficulty is further increased in the presence of receiver buffer size limitations which may introduce buffer overflow possibilities. The Multicast/Broadcast Service feature of mobile WiMAX network is a promising technology for providing wireless video broadcast services. In this article, we describe a substream selection problem which arises when multiple scalable video streams are broadcast based on the Multicast/Broadcast Service feature to a number of buffer size constrained receivers. We first show that the problem is NP-Complete and design a polynomial time approximation algorithm based on convex optimization and dynamic programming techniques. We mathematically prove that the solution obtained through our algorithm is always within a constant factor of the optimal solution. Through simulation we show that under real time requirements our algorithm provides solutions which are within 1dB of the optimal solutions.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Video multicasting to mobile devices has emerged as one of the popular services over upcoming next generation wireless networks. Several promising applications like mobile TV, mobile video-conferencing and mobile multiplayer gaming make use of these services. Technologies from traditional cellular wireless telecommunication networks, terrestrial TV broadcast networks, last mile Internet access networks and other such domains are being proposed for realizing these applications. The IEEE standard 802.16 <ref type="bibr" target="#b0">[1]</ref> or WiMAX is a technology which was originally designed for providing last mile wireless broadband access and it is now being considered for providing mobile TV services. For example, Yota Telecom <ref type="bibr" target="#b1">[2]</ref> has recently started a TV service with 25 channels over its 10Mbps mobile WiMAX network, and UDCast <ref type="bibr" target="#b2">[3]</ref> has announced plans for developing broadcast TV service supporting around 50 channels over mobile WiMAX. Observing this trend we expect to see more deployments of WiMAX based mobile TV services in the near future. Maintaining high quality of service in video delivery is one of the main challenges for these applications. Even though a considerable amount of work has been done to make these deployments a reality, several issues still remain unattended.</p><p>In the WiMAX physical layer, data is transmitted over multiple carriers in Time Division Duplex (TDD) frames. As illustrated in <ref type="figure" target="#fig_0">Figure 1</ref>, each frame contains header information and upload/download maps followed by bursts of user data. Since video dissemination is expected to be a prevalent traffic pattern in future networks, the WiMAX standard defines a service called Multicast and Broadcast Service (MBS) in the MAC layer to facilitate broadcast and multicast. Although streaming video can be transmitted as a unicast service, broadcast and multicast are more resource efficient. Using MBS, a certain area in each TDD frame can be set aside for multicast-only or broadcast-only data, as shown in <ref type="figure" target="#fig_0">Figure 1</ref>. The entire frame can also be designated as a download-only broadcast frame. A major task of the MBS module is to allocate video data to the multicast/broadcast data area in each frame, such that, the real time nature of the video stream is maintained. This results in stringent QoS and efficiency demands on the allocation algorithm.</p><p>In this paper, we propose an efficient multimedia broadcast framework over mobile WiMAX networks utilizing the MBS features. In particular, our paper considers broadcasting multiple scalable video streams to mobile receivers. We mathematically formulate the problem of selecting the best set of substreams from the scalable video streams in order to maximize the quality for mobile receivers. We show that this problem is NP-Complete. We propose an approximation algorithm based on dynamic programming techniques, which produces near optimal solutions. Using simulation and mathematical analysis we show that the algorithm is efficient in terms of execution time and achieves high radio resource utilization.</p><p>The rest of this paper is organized as follows. In Section II, we summarize the previous works related to scalable video broadcast over WiMAX. We state our problem and present the analytical formulation for it in Section III. In Section IV, we present an approximation algorithm to efficiently solve our problem. Section V describes our simulation setup and results. Finally, we summarize our findings and conclude the paper in Section VI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. RELATED WORK</head><p>In this section, we first describe previous work with respect to video transmission over WiMAX network, and then describe earlier approaches related to scalable video broadcast in WiMAX networks. Hosein <ref type="bibr" target="#b3">[4]</ref> describes the frame allocation problem for broadcasting variable bit rate video over WiMAX, but does not consider scalable video content. <ref type="bibr">Wang et al. [5]</ref> discuss an architecture for video broadcasting in a multi-basestation WiMAX system. Their work focuses on coverage and spectral efficiency issues and considers only temporal video scalability. Cohen et al. <ref type="bibr" target="#b5">[6]</ref> combine a group of TDD frames together into a super-frame. They describe a cost based scheme where a cost function is associated with each user-channel pair. Three user interaction models are considered: (i) user can either be statically hooked to a channel, (ii) user can choose to listen to a channel, or (iii) the user channel association can keep changing based on the transmission medium conditions. The work in <ref type="bibr" target="#b5">[6]</ref> does not consider the delay requirements which are central to video streaming.</p><p>Jiang et al. <ref type="bibr" target="#b6">[7]</ref> propose a scheme to transmit scalable video streams in which two layers of each video are transmitted separately. The base layer is transmitted as one stream over a reliable channel while the enhancement layer is transmitted as a different stream over a less reliable channel. Conceptually, this work implements a rate adaptive multiple description coding. However, it describes only one stream and it does not address the resource management problem arising in multi stream transmission scenarios. Reguant et al. <ref type="bibr" target="#b7">[8]</ref> consider splitting a video stream into two streams and transmitting them over two different broadcast networks. The first stream is transmitted over a DVB-H network at all times while the second stream is transmitted over WiMAX network most of the time. If the user wants to use some other non-video application in parallel, the stream going through WiMAX is degraded to accommodate that application. This ensures a minimum video quality at all times while maintaining the flexibility of using other applications. While this approach has its benefits, it is not very attractive from a deployment point of view since the service provider has to install and manage the infrastructure for two different kinds of networks. Also the solutions described in both <ref type="bibr" target="#b6">[7]</ref> and <ref type="bibr" target="#b7">[8]</ref> evaluate the performance of video streaming as an application along with other WiMAX applications and do not utilize MBS. In contrast, our approach considers a multimedia-intensive system with extensive use of MBS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. PROBLEM STATEMENT AND HARDNESS</head><p>Our work focuses on optimally utilizing the Multicast/Broadcast Service (MBS) to stream multiple scalable videos to mobile receivers. In this section we state the problem and show that it is NP-Complete. We also present the mathematical formulation of the problem. For quick reference, we list all symbols used in the formulation in <ref type="table" target="#tab_0">Table I</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Problem Statement</head><p>We consider a scenario where a number of scalable video streams are available at a WiMAX base station. Each stream is to be broadcast using MBS to a group of mobile subscribers. At the WiMAX base station, the MBS module allocates a fixed-size data area in the download section of each TDD frame. All video streams are to be allocated only within this MBS data area. As per the mobile WiMAX standard, each MBS data area can transmit a different amount of data depending on the modulation scheme chosen, which is in turn selected based on the wireless channel conditions. For a broadcast application, the modulation scheme is to be selected for a group of subscribers. Since subscribers receiving a broadcast service may have different channel conditions, selecting a modulation scheme which is beneficial to all the subscribers in the group is computationally expensive. Therefore, we assume that the modulation scheme for the broadcast service is a pre-calculated parameter and does not change throughout the transmission. Thus, each MBS area transmits a fixed amount of data, in effect, creating a fixed bandwidth broadcast channel. We consider a scheduling window composed of a number of MBS data areas. Data from the video streams are to be allocated to the MBS areas in the scheduling window. Due to the variable bit rate (VBR) nature of the video streams, the aggregate data rates may exceed the broadcast channel capacity. Hence, in each scheduling window, we need to decide which layers to send for each stream. We assume that the base station has enough buffer space to hold the VBR traffic for one scheduling window. This way, the data rates can be assumed to be constant during a scheduling window, but they vary across scheduling windows. Since the bit rates and the receiver buffer states change in each scheduling window, the allocation has to be computed for every scheduling window. We also assume that all subscribers served by the base station have a fixed amount of buffer which is used to temporarily store the incoming video data before playing out. Thus the optimal substream selection problem we need to solve can be stated as follows.</p><p>Problem 1 (Optimal Substream Selection Problem:): Select the optimal subset of layers from each scalable stream to broadcast over a WiMAX network such that: (1) the total data transmitted in a scheduling window does not exceed the window capacity, (2) the average quality of all selected substreams is maximized, and (3) the subscriber playout buffer does not overflow or underflow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Problem Hardness</head><p>Let us assume that for a given radio modulation scheme, the MBS data area in each frame can accommodate F amount of data and the TDD Frame takes τ time to be transmitted. Let the scheduling window consist of P such frames. Then, the maximum amount of data that can be transmitted within the scheduling window is given as C = PF. We have S scalable video streams. Each scalable stream s, 1 ≤ s ≤ S, has at most L layers. The value of L can be different for each stream.</p><p>Therefore, for each stream we have L substreams to choose from, where a substream l includes layer l and all layers below it. Let the data rates and quality values for selecting substream l of stream s be r sl and q sl respectively. Here r 11 denotes the data rate of the base layer of the first stream. Thus, we have the problem of choosing the substreams such that the average quality across the video streams is maximized subject to the following constraints. The first constraint is that the total data to be transmitted must fit into the MBS areas in the current scheduling window. The second constraint is that the buffers at the subscribers must not run out of data anytime during the scheduling window, and the third constraint is that the base layer of each stream must be transmitted to guarantee a basic service level agreement. Proof: First, we consider a relaxed version of the problem with no buffer overflow or underflow constraints. Thus, we are left with the problem of selecting the substreams such that the average quality is maximized. We assume that in each scheduling window at least all the base layer streams have to be transmitted due to service level agreement. Thus, we further modify the problem by eliminating the base layer constraints, which can be trivially done, by reducing the scheduling window capacity by the sum of data rates of all base layers. Therefore, the modified data capacity can be given</p><formula xml:id="formula_0">as C ′ = C − ∑ s∈S r s1</formula><p>. Now we are left with the problem of deciding which substreams to chose from each stream. We show that this problem is equivalent to the NP-Complete 0-1 Multiple Choice Knapsack Problem (0-1-MCKP) <ref type="bibr" target="#b8">[9]</ref>, which is defined as follows. Given M classes N 1 , . . . , N M of items to pack in some knapsack of capacity W . Each item (i, j), where i ∈ M, j ∈ N i , has a profit p(i, j) and a weight w(i, j). The problem is to choose at most one item from each class such that the profit sum is maximized without having the total weight exceed W . We reduce the 0-1-MCKP problem to Optimal Substream Selection problem in polynomial time as follows. We make the data rates of choosing a substream represent the item weight and the corresponding quality values represent the profit of choosing an item. We also make the streams represent the multiple choice classes and the scheduling window capacity represent the knapsack capacity. Thus, we have an MCKP instance with S classes, L − 1 items per class and a knapsack capacity of C ′ . This means that an efficient solution for the simplified Optimal Substream Selection Problem could be employed to efficiently solve the NP-Complete 0-1-MCKP problem. In other words, the substream selection problem is NP-Hard. In addition, clearly a solution for the simplified Optimal Substream Selection Problem can be verified in polynomial time. Thus the simplified Optimal Substream Selection Problem is NP-Complete. Consequently, the more general Optimal Substream Selection Problem subject to buffer overflow and underflow constraints is also NP-Complete. Initial buffer level for stream s</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Analytical Formulation</head><p>We assume all subscribers have B amount of buffer available for the video streaming application and the data rate and quality values for all substreams of each stream are known ahead of the scheduling window. This information can either be obtained as a separate meta data for each stream or if the scalable video is encoded using H.264/SVC <ref type="bibr" target="#b9">[10]</ref> and the base station is media-aware, this information can be obtained directly from the encoded video stream itself using the Supplementary Enhancement Information (SEI) messages. Let the data rate values of substreams be {r s1 , r s2 , . . . , r SL } and the corresponding quality values be {q s1 , q s2 , . . . , q SL }. Each scheduling window is of duration τP. If substream l of stream s is selected, the amount of data to be transmitted during a scheduling window can be given as τPr sl . Let binary variables x sl take the value 1 if substream l of stream s is selected for transmission in the current scheduling window and 0 otherwise. For a substream, we define a burst as a consecutive set of MBS data areas allocated to the substream in the scheduling window. For any schedule, let n sl be the number of bursts for substream l of stream s. We denote by variables t k sl the starting frame number and by variable w k sl the number of MBS data areas in burst k for substream l of stream s. The solution of the optimum substream selection problem should generate a list &lt; l, n, &lt; t 1 sl , w 1 sl &gt;, . . . , &lt; t n sl , w n sl &gt;&gt; for each stream. In the list, l denotes the selected substream, n denotes the number of bursts required for transmitting substream l, and &lt; t k sl , w k sl &gt; denote the starting point and width of burst k, respectively. For a subscriber receiving channel s, let the buffer level at the beginning of scheduling window be u s . We need to ensure that all data received during a scheduling window are also consumed in the same window. In other words ∑ n sl k=1 w k sl = τPr sl . At the same time we need to ensure that buffer overflow and underflow does not occur. At the end of each burst, the total data received is given by ∑ k i=1 w i sl . During that period the total data consumed is given by τ(t k sl + w k sl )r sl . Now in order to avoid underflow, the difference of these two terms must be greater than zero for all bursts. Similarly, the overflow conditions can be applied by constraining the difference to be never greater than B. Our objective is to maximize the average video quality over all the streams. We use the PSNR values of the streams to denote quality and take an arithmetic average of the PSNRs of the selected streams to denote the average quality. Let us assume that the data to be transmitted for each substream can be divided into b sl number of F sized data blocks. Consequently, we have the following optimization problem.</p><formula xml:id="formula_1">Maximize 1 S S ∑ s=1 L ∑ l=1 x sl q sl (P1) such that S ∑ s=1 L ∑ l=1 x sl b sl ≤ P (1a) L ∑ l=1 x sl ≤ 1 (1b) u s + k ∑ i=1 w i sl F − τ(t k sl + w k sl )r sl ≤ B (1c) u s + k−1 ∑ i=1 w i sl F − τ(t k−1 sl + w k−1 sl )r sl ≥ 0 (1d) [t k sl . . .t k sl + w k sl ] ∩ [t ¯ k ¯ sl . . .t ¯ k ¯ sl + w ¯ k ¯ sl ] = / 0 (1e) n sl ∑ k=1 w k s = x sl b sl (1f)</formula><p>In the above formulation the constraint (1a) makes sure that the selected substreams can be transmitted within the broadcast bandwidth. Constraint (1b) ensures that at most one substream is selected for each stream. Constraints (1c) and (1d) represent the buffer overflow and underflow constrains, respectively. Constraint (1e) implies that no two bursts of data blocks should be allocated to the MBS area of the same TDD Frame.</p><p>Here the operator [. . .] denotes integer interval. This constraint is required because the streams are transmitted over a timeshared, multiple-access wireless channel where only one burst can be transmitted at a time. <ref type="bibr">Constraints (1f)</ref> implies that if a layer is selected, then all the data blocks corresponding to the layer must be allocated in the schedule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. PROPOSED APPROXIMATION ALGORITHM</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Overview of the Proposed Algorithm</head><p>The proposed algorithm is called Substream Selection Algorithm and is denoted by SSA. The high level idea of the algorithm is as follows. We first find a set of near optimal substreams given the data capacity of a scheduling window. Then, we allocate them to the MBS areas in the frames of the scheduling window. If no feasible allocation is found, we reduce the problem instance by discarding the substream with lowest quality among all substreams. We solve the optimal substream selection problem again for the reduced set of substreams. This cycle is repeated until, either a feasible solution is found, or none of the substreams are selected. The block diagram of this general scheme is shown in <ref type="figure" target="#fig_2">Figure 2</ref>. First, we design an approximation algorithm for the multiple choice knapsack problem. Then, the frame allocation is done in a modified weighted round robin manner. As we showed in Theorem 1, the problem of selecting optimal scalable substreams is equivalent to solving a 0-1 Multiple Choice Knapsack Problem. This problem has been well studied in the mathematical programming community and several near optimal solution schemes exist. The reader is referred to the survey by Lin <ref type="bibr" target="#b10">[11]</ref> for a summary of the main results. Dynamic programming is one of the techniques used for designing approximation algorithms for the 0-1 Multiple Choice Knapsack Problem. However, dynamic programming solutions are often memory intensive and may involve large constants. In our algorithm we derive both an upper bound and lower bound on the value of the solution. These bounds significantly reduce the solution search space <ref type="bibr" target="#b11">[12]</ref>. <ref type="figure" target="#fig_3">Figure 3</ref> summarizes the pseudo-code of the SSA algorithm. There are three main steps of the algorithm: (i) Finding an approximate solution to the substream selection problem, (ii) Allocating the selected substreams to the MBS data areas of the scheduling window, and (iii) Validating the schedule to confirm that there are no buffer underflow or overflow conditions. We describe each step in the following.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Details of the Proposed Algorithm</head><p>1) Approximate Substream Selection: In a naive dynamic programming solution we construct a table of all possible data rates for the given streams (i.e., 1 . . . ∑ r SL ) and their resulting quality values. We note that multiple quality values can result for a single aggregate data rate value depending on the composition of the substreams selected. Then, we search for the highest quality entry in the table such that the data rate is less than the scheduling window capacity. In our proposed algorithm, we first derive bounds on the solution value which will reduce the size of the search space. Then, we construct a dynamic programming table for all quality values within the bounds and find the solution substreams using backtracking.</p><p>Bounding the Optimum Solution Value: A lower bound on the optimal solution is obtained from a solution to the linear relaxation of the 0-1 MCKP problem as follows. A solution x * c to the linear relaxation has the following two properties: (1) x * c contains at most two fractional values and (2) when there are two fractional values in x * c , they belong to substreams of the same stream. For the proof of these properties the reader is referred to <ref type="bibr" target="#b12">[13]</ref>. Let z * c be the value of the objective function corresponding to x * c . Let Q 0 be the maximum of (a) the objective function value when both the fractional values are dropped from the solution and (b) maximum of the quality values of the fractional variables. If the optimal solution for the integer problem is Q * , it is evident that Q 0 ≤ Q * . From the properties of x * c it is evident that at most two variables are dropped. Since at most two variables are dropped, z * c can be bounded as z * c ≤ 2Q 0 . Also, since the solution obtained by the linear relaxation must be greater than or equal to the solution obtained by the integer program, we have an upper bound on the optimum integer solution as Q 0 ≤ Q * ≤ z * c ≤ 2Q 0 . We note that although the bound is obtained from linear programming theory, we do not require an LP solver to calculate Q 0 . Q 0 can be calculated using the median finding algorithms in linear time <ref type="bibr" target="#b13">[14]</ref>.</p><p>Recursive Table Generation: Now that we know the bounds of the optimal solution value we define a dynamic programming formulation as follows. For all streams s ∈ {1, . . . , S} and all quality values q ∈, {0 . . . , 2Q 0 }, we define V (s, q) as the set of substreams from streams 1, . . . , s such that no two substreams are selected from the same stream and the total quality of the selected substreams is q. If for a quality value q the at most one substream per stream constraint is violated we set the corresponding sum of weights to infinity. Let R(s, q) denote the sum of data rates selected in V (s, q). We assume that the sum of data rates to produce zero quality is zero, i.e., R(s, 0) = 0. Also, for the first stream, the data rate values can be computed easily as just the data rate of the substream, or the minimum of the data rates if more than one substream has the same quality, i.e., R(1, q) = min l {r sl } where q sl = q. In mathematical terms, the first stream data rates can be expressed as in equation (2a). The data rates for the other quality values and other streams can be computed by the recursive definition described in (2b) and the optimum quality can be expressed by equation (2c).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R(1, q) = min</head><p>l {r sl }, where l ∈ L and q sl = q,</p><formula xml:id="formula_2">∞, otherwise. (2a) R(s, q) =      min{R(s − 1, q), min l∈L {r sl +R(s − 1, q − q sl )}}, when q sl ≤ q, R(s − 1, q), otherwise. (2b) Q * = max{q|R(s, q) ≤ PF}.<label>(2c)</label></formula><p>However, the size of the table can still be very large as it is bounded only by Q 0 . Therefore we select a scaling factor K = εQ 0 S , and scale down the quality values to q ′ sl = q sl K . This operation considerably reduces the table size while admitting only a small error factor. We bound the quality degradation due to scaling in our mathematical analysis in Section IV-C.</p><p>Backtracking: Once we have computed the dynamic programming table, the solution quality value is obtained by a simple scanning of the table as in equation <ref type="formula" target="#formula_2">(2c</ref>  2) Data allocation: Once the substreams are selected, it remains to allocate them to the MBS data area such that the subscriber playback buffers do not overflow or underflow. We use a modified version of the weighted round robin algorithm to allocate data to frames. The weighted round robin has been used for scheduling constant bit rate traffic before <ref type="bibr" target="#b14">[15]</ref>. However, for a variable bit rate stream the stream priorities are not static. We derive the priority of a stream based on its buffer level at the subscriber. At the beginning of the scheduling window, for a stream s let the data rate of the selected substream be r s and the buffer level be B s . Then stream s is assigned priority B s r s . A lower value of B s r s denotes higher priority. We also need to allocate the number of frames to a stream in the current round, that is, the length of the burst. The burst length is chosen such that none of the other streams suffer from starvation, nor does it cause overflow or underflow at the receiver buffer. For a stream s the length of the burst is given by min { B s τr s</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>}.</head><p>3) Buffer State Validation: After the schedule is constructed, we check if any buffer constraints are violated. This can be easily determined by verifying the buffer overflow and underflow constraints described in equations (1c) and (1d). If the buffer constraints are violated, the current substreams cannot be allocated within the current scheduling window. Hence, we reduce the problem size and re-compute substreams. The problem size is reduced by discarding the substream with minimum quality value among all substreams. This process is repeated until a feasible solution is found or none of the substreams is selected. We note that even though the scheduler is located at the base station, it is aware of the subscriber buffer size and stream data rates. From this information it can calculate the change in buffer states for a given schedule without any involvement from the subscribers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Correctness and Performance Analysis</head><p>We first prove in Lemma 1 that the data rate and quality values of substreams of a scalable stream constitute a nondominated set. In Lemma 2, we prove the correctness of the recursive formulation described in equations(2a)-(2b). Using Lemma 1 and Lemma 2 we prove the correctness of SSA.</p><p>Lemma 1: Data rates and quality values of substreams extracted from scalable streams constitute non-dominated set.</p><p>Let l and l ′ be two substreams of a given stream s. Substream l is said to be dominated by substream l ′ if including l ′ in the solution always leads to better quality than including substream l. For example, let r sl , r ′ sl be the data rates and q sl , q ′ sl be the quality values of substreams l and l ′ . If r sl &gt; r ′ sl and q sl &lt; q ′ sl then l is dominated by l ′ . Greet et al. <ref type="bibr" target="#b15">[16]</ref> have shown that, for H.264 PSNR scalability, when there is sufficient variability in the video, its rate-distortion characterization is close to a quadratic function which is convex. In our problem, since the streams are variable bit rate videos and layer encoded, the data rate and quality value pair of the layers within a stream can be assumed to form a convex set. This means that our problem instances are already in nondominated form and we can easily solve the linear relaxation of the best quality substream selection problem. Efficient solution to the linear relaxation will help us in efficiently computing the final solution value. We empirically validate this assumption of rate variability and convexity. In <ref type="figure" target="#fig_6">Figure 4a</ref> we plot the sizes of frames of one of our test streams to show the high data rate variability. In <ref type="figure" target="#fig_6">Figure 4b</ref> we plot the data rate and PSNR values of three test streams and validate that they indeed form a convex envelop.</p><p>Lemma 2: The recurrence relations described in equations (2a)-(2c) produce a near optimal substream selection solution.</p><p>Proof: According to Lemma 1, all instances consist of only non-dominated substreams. Thus we only need to prove the correctness of the recurrence relation. We can prove the correctness of the recursive expression by induction. The basis step where s = 1 is true since it will lead to the selection of the maximum quality substream such that the data rate is less than the scheduling window capacity. Now let us assume that it is also true for the case of s − 1 streams. For stream s the expression R(s − 1, q − q sl ) retrieves the weight of the solution and updates it by adding the current data rate. Then all such data rates are compared which can result in quality q and only the minimum is chosen. Since R(s − 1, q) is already minimum, this results in R(s, q) also being minimum for every quality value. Also, since data rates are accumulated only between two different streams only one substream from each stream is selected for all quality values. The solution is not optimal since the quality values are scaled. Proof: By Lemma 2, the solution to the dynamic programming formulation selects substreams such that the average quality is close to the optimal and the total data requirement is less than the scheduling window capacity. Therefore, the capacity constraint and the at most one substream per stream constraint are satisfied. The round robin algorithm assigns MBS data areas to streams one frame at a time. Thus, it guarantees that no two frame bursts are assigned to the same frame. Finally, the buffer state validation step of the algorithm ensures no buffer overflow or underflow instances occur in the schedule. Hence, the SSA algorithm generates a valid solution for the substream selection problem. Next we analyze the approximation factor and time complexity. Let Π be a maximization problem with objective function z, optimal solution S * and optimal objective function value z * . Let I be an instance of Π and ε &gt; 0 be an error parameter. A ′ is an approximation algorithm for the problem Π if for the input pair (I, ε), A ′ outputs a solution S ′ with an objective function value z such that z ≥ (1 − ε)z * .</p><p>Theorem 3 (Approximation Factor): The SSA algorithm described in <ref type="figure" target="#fig_3">Figure 3</ref> is a constant factor approximation algorithm for a constant ε.</p><p>Proof: Let us describe a scaled instance obtained by using quality values q ′ sl as I ′ . Now for all substreams we have q sl − K ≤ Kq ′ sl ≤ q sl . Let A * be an optimal algorithm and Π(I, A * ) the solution obtained by algorithm A * on all instances I. Therefore Π(I : A * ) = Q * . Considering the data rates for all substreams, we have Q * − Π(I ′ , A * )K ≤ SK. Since A is optimal in I ′ we know that Π(I ′ , A) ≥ Π(I ′ , A * ) and applying the above inequality we have</p><formula xml:id="formula_3">KΠ(I ′ , A) ≥ KΠ(I ′ , A * ) ≥ Q * − SK.</formula><p>From properties of q sl , we also know for any feasible solution T that, Π(I, T ) ≥ Π(I ′ , T )K. We thus have:</p><formula xml:id="formula_4">Π(I, A) ≥ Π(I ′ , A * )K ≥ Q * − SK = Q * − εQ 0 .</formula><p>Also the algorithm always returns a solution of value at least Q 0 . Therefore,</p><formula xml:id="formula_5">Π(I, A) ≥ Q * − εQ 0 ≥ Q * − εΠ(I, A), which gives us Π(I, A) ≥ 1 1 + ε Q * ≥ (1 − ε)Q * .</formula><p>Thus algorithm SSA is a constant factor approximation algorithm for constant ε.  log n) time, leading to a total time complexity of O(n log n+nQ * ). This is not polynomial in n since the value of Q * may not be bounded polynomially in n. constant ε, let us select a scale factor K and scaled quality value for each substream q ′ sl according to equations (3a)-(3b). space which includes the O(Q * ) space for saving the backtracking information for constructing the solution.</p><formula xml:id="formula_6">K = εQ 0 S (3a) q ′ sl = ⌊ q sl K ⌋ (3b) Since Q * ≤ 2Q 0 we have Q * K ≤ 2L ε .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. TRACE-DRIVEN EVALUATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Simulation Setup</head><p>We have implemented a point-to-multipoint WiMAX multimedia broadcast simulator and evaluated our algorithm in it using actual scalable video traces. For the WiMAX network parameters we use the 16-QAM modulation scheme with 3/4 convolution turbo coding and 10MHz channel frequency width. Since each TDD frame is 5ms, for a one second scheduling window we will have to allocate data to 200 TDD frames. Also we assume that within each TDD frame we have an MBS data area of 50kb. This gives us a broadcast channel bandwidth of 10Mbps <ref type="bibr" target="#b16">[17]</ref>. At the receiver side we assume a buffer limit of 512kb. For generating the video traffic we use 10 raw (YUV files in 4:2:0 format) video files from the video trace repository of Arizona State University <ref type="bibr" target="#b17">[18]</ref>. For each video we generate a 10 minute workload by starting from a random initial frame and then repeating the frame sequences. Then we encode the videos into H.264/SVC format using the JSVM reference software version 9.18 <ref type="bibr" target="#b18">[19]</ref>. We encode each stream into four PSNR scalable layers using the medium grain scalability (MGS) feature and tune the encoding parameters such that the substreams have average bit rate between 100kbps and 2.5Mbps. In <ref type="table" target="#tab_0">Table II</ref>, we summarize the information of the data rates and quality values of each layer of the different video files.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Simulation Results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) Video Quality:</head><p>In our first experiment, we compare the performance of the SSA algorithm versus the optimum algorithm in terms of video quality. We perform this comparison over a period of 100 consecutive scheduling instances. We keep the receiver buffer size fixed at 512kb, the scheduling window size at 1 sec and vary the number of streams from 10 to 50. The results shown in <ref type="figure">Figure 5a</ref> show that our SSA algorithm produces near optimal solutions, which are less than 1dB from the absolute optimal solutions computed using optimization software GLPK <ref type="bibr" target="#b19">[20]</ref>. We also observe that the proposed SSA algorithm scales well when the number of streams increase. In another experiment we keep the number of streams fixed at 20 and vary the scheduling window from 1 to 10 sec. As we can see from the results of this experiment in <ref type="figure">Figure 5b</ref>, the solution quality improves as the scheduling window grows. These two experiments show that our algorithm produces close to optimal results and it scales well, which means that it can support large scale WiMAX streaming services.</p><p>2  the number of streams. In a second experiment we keep the number of streams fixed and increase the scheduling window. We compare the execution times of our algorithms to that of the optimum. For deriving the optimum solution we first use the GLPK LP solver <ref type="bibr" target="#b19">[20]</ref> to determine the substreams that can be scheduled and then sequence the frames within a scheduling window in a weighted round robin manner. For the SSA algorithm, we compute the running time with error parameters ε = 0.01 and ε = 0.005. For a one second scheduling window we vary the number of streams from 10 to 50 and observe their asymptotic behavior. The execution times of these algorithms are measured on a computer with 1.6GHz dual-core processor and 1GB of memory. The results of the first experiment are shown in <ref type="figure">Figure 6a</ref>. As expected, computing the optimum solution using GLPK takes much longer as the number of streams grow. The SSA algorithm runs well within the time window even as the problem instance sizes grow. For the second experiment we keep the number of streams fixed at 20 and vary the scheduling window size from 1 sec to 10 sec. From the results of the second experiment, depicted in <ref type="figure">Figure 6b</ref>, we can see that the SSA algorithm scales efficiently with increase in window size. For real time operation, the algorithm needs to compute the solution within the scheduling window duration. From <ref type="figure">Figure 6b</ref>, we see that with every one second increment in the scheduling window size the execution time increases by only a few milliseconds. This shows that the SSA algorithm scales well for large problem instances under real-time constraints.</p><p>3) Resource Utilization and Buffer Validation: Next, we evaluate the resource utilization of the SSA algorithm in terms of the scheduling window capacity used. Let the total schedulable data capacity of a scheduling window be PF. If { ¯ r 1 , . . . , ¯ r S } are the data rates of the chosen substreams, the total data sent in the schedule is ∑ Pτ ¯ r s . The capacity utilization is then given by ∑ Pτ ¯ r s PF . As seen in <ref type="figure" target="#fig_8">Figure 7a</ref>, the resource utilization of the SSA algorithm remains close to optimal for different scheduling window capacity sizes. Finally, we verify that the buffer conditions are satisfied by the SSA algorithm. That is, we check if the SSA algorithm causes any buffer overflow or underflow. We found neither overflow nor underflow occurrences for any of the streams. In <ref type="figure" target="#fig_8">Figure 7b</ref>, we display the buffer level dynamics of subscribers receiving the stream Foreman for 300 consecutive scheduling windows, which show that the buffer level never exceeds 500kb, that is, there are no overflow instances. It also shows the the buffer level never goes below zero, which means there are no underflow instances. Similar results were obtained for subscribers receiving other video streams.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CONCLUSION AND FUTURE WORK</head><p>We studied a framework for disseminating scalable video streams over mobile WiMAX networks. We mathematically analyzed the problem of selecting the optimal substreams of scalable video streams under bandwidth constraints. Solving this problem is important because it enables the network operator to transmit higher quality video or more number of video streams at the same capacity. We showed that substream selection problem in presence of bandwidth limitation is NPComplete. We proposed a novel approximation algorithm for this problem. We proved that our algorithm has a small approximation factor of (1 − ε), and it has a time complexity of O( nL ε ), where n = O(∑ L) is the total number of layers, and L is maximum number of layers in a scalable stream. We implemented and validated our algorithm in a simulation setup and studied the impact of a wide range of parameters using multiple video traces. Our simulation results show that the approximation factor of the proposed algorithm is very close to one for practical scenarios. We also verified that our algorithm can run in real time and that it scales well to larger scheduling problems.</p><p>The work in this paper can be extended in different directions. For example, we are currently extending our algorithm to consider the battery constraints of mobile receivers such that, the produced solution not only optimize the video quality but also minimize the energy consumed by mobile receivers.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. WiMAX OFDMA TDD Frame structure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Theorem 1 :</head><label>1</label><figDesc>The Optimal Substream Selection Problem is NP-Complete.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. High-level diagram of the Substream Scheduling Algorithm (SSA).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. The proposed Substream Selection Algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Theorem 2 (Correctness): SSA algorithm described in Fig- ure 3 returns a valid solution for the Substream Selection Problem.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Theorem 4 (Time and Space Complexity): The SSA in Fig- ure 3 has a time complexity of O( nL ε + Pn log n), where n = O(∑ L) is the total number of substreams, L is the maximum number of substreams within a stream, P is the scheduling window size, and ε &gt; 0 is a small constant. The space complexity is O(SQ * ). Proof: The dynamic programming algorithm computes S × 2Q 0 entries for constructing the R(s, q)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Rate-Distortion characteristics of scalable video.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 5 .Fig. 6 .</head><label>56</label><figDesc>Fig. 5. Near optimality of the solutions obtained by the SSA algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Performance of the SSA Algorithm in terms of resource utilization and receiver buffer dynamics.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>TABLE I LIST OF SYMBOLS USED IN FORMULATION Symbol Description S Number of streams L Number of layers q sl PSNR of substream sl r sl Data rate of substream sl b sl Number of frame sized blocks of substream sl n sl Number of frame bursts for substream sl t k sl Start of burst k of substream sl w k sl Width of burst k of substream sl τ</head><label>I</label><figDesc></figDesc><table>Duration of a TDD frame 
F 
Capacity of MBS data in a TDD frame 
P 
Number of frames in scheduling window 
C 
Data capacity of scheduling window 
B 
Buffer size at the receiver 
u s 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>For each enhancement layer i across all streams do 2. Compute ρ i = r sl − r sl−1 and φ i = (q sl − q sl−1 ) 3. Select k largest φ i ρ i such that ∑ i∈k ρ i &lt; PF − ∑ r s1 4. Determine lower bound Q 0 = ∑ φ i + ∑ q s1 5. Compute scale factor K = εQ 0 /S 6. Scale the quality values such that q ′ sl = q sl K 7. For q =14. Allocate σ s = min B s τr s frames to stream s 15. Update B s = B s + σ s * F − σ s τr s 16. If no valid allocation found do 17. Find substream ( ˆ l, ˆ s) such that q ˆ s ˆ l = min s∈S,l∈L {q sl }</head><label></label><figDesc>). The solution substream vectors are found using a backtracking mechanism as follows. While constructing the recursive table, we store the composition of substreams leading to the data rates R(s, q) as a list for each table cell. The solution substream vector is found using the additional information by backtracking from the cell containing the solution quality value.</figDesc><table>Substream Selection Algorithm (SSA) 

1. 1 to 2Q 0 do 
8. For s = 1 to S do 
9. 
If s is 1, Compute R(s, q) using equation (2a) 
10. 
Else, Compute R(s, q) using equation (2b) 
11. Backtrack table R(s, q) to find the substreams s  *  
12. Until all streams are allocated do 
13. Arrange substreams in ascending order of 
B s 
r s 
18. Discard substream ( ˆ 
l, ˆ 
s) 
19. Go to step 3 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>table . Computing each entry takes O(L) time. Hence the table can be completely constructed in O(L·S·2Q 0 ) time or O(nQ * ) time. Computation of Q 0 takes O(n</head><label>.</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>log n). The storage of the table requires O(SQ * )</head><label></label><figDesc></figDesc><table>Thus the table computation 

can now be computed in O( 
nL 
ε 
) time. The round robin 

allocation takes O(n log n) time for sorting the buffer levels 
in each round. The number of rounds depends on the size of 
the scheduling window P. Hence the total time complexity is 

O( 
nL 
ε 
+ Pn </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>TABLE II DATA RATES (kbps) AND PSNR (dB) VALUES OF THE SCALABLE VIDEOS USED IN EVALUATION</head><label>II</label><figDesc></figDesc><table>Name 
1 Layer 
2 Layers 
3 Layers 
4 Layers 
r 1 
q 1 
r 2 
q 2 
r 3 
q 3 
r 4 
q 4 
CREW 
306 32.92 
578 34.99 
814 
36.5 1184 37.41 
FOOTBALL 
442 30.50 
827 32.91 1114 33.98 1621 35.55 
MOBILE 
189 35.76 
322 37.87 
442 38.93 
649 40.36 
CITY 
448 29.62 
923 32.21 1288 33.28 1943 34.88 
FOREMAN 
170 
32.9 
407 34.86 
589 
36.0 
890 37.43 
BUS 
185 33.17 
390 35.43 
567 36.41 
857 37.65 
HARBOUR 
577 
31.8 
1025 33.46 1379 34.67 1929 36.25 
NEWS 
121 
35.6 
259 37.55 
372 38.63 
564 
40.5 
SOCCER 
385 29.92 
795 32.18 1095 33.13 1651 34.68 
ICE 
277 32.35 
548 34.71 
767 35.82 1123 37.32 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head></head><label></label><figDesc>) Time Efficiency: We evaluate the running time of our algorithms by changing the problem size in two ways. First we keep the scheduling window capacity fixed and increase</figDesc><table>10 

20 
30 
40 
50 
30 

32 

34 

36 

38 

40 

Number of Streams 

Average Quality (dB) 

OPT 
SSA 

(a) Fixed window size at 1 sec 

2 
4 
6 
8 
10 
30 

32 

34 

36 

38 

40 

Sceduling Window (sec) 

Average Quality (dB) 

OPT 
SSA 

(b) Fixed number of streams at 20 

</table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Broadband Wireless Metropolitan Area Network</title>
		<ptr target="http://standards.ieee.org/getieee802/802.16.html" />
	</analytic>
	<monogr>
		<title level="j">IEEE</title>
		<imprint>
			<biblScope unit="volume">802</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Yota Mobile WiMAX</title>
		<ptr target="http://www.yota.ru/en/info/main/" />
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">UDCAST WiMAX TV</title>
		<ptr target="http://www.udcast.com/products/udcastwimaxtvproducts.htm" />
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Broadcasting VBR traffic in a WiMAX network</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hosein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Vehicular Technology Conference (VTC&apos;08)</title>
		<meeting>of IEEE Vehicular Technology Conference (VTC&apos;08)<address><addrLine>Calgary, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-09" />
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">System architecture and cross-layer optimization of video broadcast over WiMAX</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Venkatachalam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Fang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="712" to="721" />
			<date type="published" when="2007-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On the trade-off between energy and multicast efficiency in 802.16e-like mobile networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Katzir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rizzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Mobile Computing</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="346" to="357" />
			<date type="published" when="2008-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Scalable video streaming over mobile WiMAX</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Juan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Chiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of International Symposium on Circuits and Systems</title>
		<meeting>of International Symposium on Circuits and Systems<address><addrLine>New Orleans, LA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-05" />
			<biblScope unit="page" from="3463" to="3466" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Delivery of H.264 SVC/MDC streams over WiMAX and DVB-T networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Reguant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Prats</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>De Pozuelo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Margalef</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ubiergo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Symposium on Consumer Electronics (ISCE&apos;08)</title>
		<meeting><address><addrLine>Algarve, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-04" />
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Computers and Intractability: A guide to the Theory of NP-Completeness</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979" />
			<publisher>W. H. Freeman and Company</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Overview of the H.264/AVC Video Coding Standard</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Wiegand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Sullivan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Bjøntegaard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Luthra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Circuits and Systems for Video Technology</title>
		<imprint>
			<date type="published" when="2003-07" />
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="560" to="576" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A bibliographical survey on some well-known non-standard knapsack problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Systems and Operation Research</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="274" to="317" />
			<date type="published" when="1998-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Improved fully polynomial time approximation scheme for the 0-1 multiple-choice knapsack problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bansal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Venkaiah</surname></persName>
		</author>
		<ptr target="http://www.iiit.net/cgi-bin/techreports/displaydetail.cgi?id=IIIT/TR/2004/3" />
	</analytic>
	<monogr>
		<title level="j">Tech. Rep</title>
		<imprint>
			<date type="published" when="2004-02" />
		</imprint>
	</monogr>
	<note>International Institute of Information Technology</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The multiple-choice knapsack problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sinha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Zoltners</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="503" to="515" />
			<date type="published" when="1979-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An O(n) Algorithm for the linear multiple choice knapsack problem and related problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Zemel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="123" to="128" />
			<date type="published" when="1984-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Radio resource management for broadcast services in OFDMA-based networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hosein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gopal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE International Conference on Communications Workshops</title>
		<meeting>of IEEE International Conference on Communications Workshops<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-05" />
			<biblScope unit="page" from="271" to="275" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Traffic and quality characterization of the H.264/AVC scalable video coding extension</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Geert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Reisslein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Karam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in MultiMedia</title>
		<imprint>
			<date type="published" when="2008-01" />
			<biblScope unit="page" from="1" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Mobile WiMAX Part I -Overview and Performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gray</surname></persName>
		</author>
		<ptr target="www.wimaxforum.org/technology/downloads/MobileWiMAXPart1OverviewandPerformance.pdf" />
	</analytic>
	<monogr>
		<title level="m">WiMAX Forum, White Paper</title>
		<imprint>
			<date type="published" when="2006-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Arizona State University: Video Traces Research Group</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
	<note>http: //trace.eas.asu.edu</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
				<ptr target="http://ip.hhi.de/imagecomG1/savce/downloads/SVC-Reference-Software.htm" />
		<title level="m">264 AVC/SVC Reference Software</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">GNU Linear Programming Kit</title>
		<ptr target="http://www.gnu.org/software/glpk/glpk.html" />
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
