<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:57+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Stream Monitoring under the Time Warping Distance</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yasushi</forename><surname>Sakurai</surname></persName>
							<email>sakurai.yasushi@lab.ntt.co.jp</email>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">NTT Cyber Space Laboratories</orgName>
								<orgName type="laboratory" key="lab2">NTT Cyber Space Laboratories</orgName>
								<orgName type="institution">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christos</forename><surname>Faloutsos</surname></persName>
							<email>christos@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">NTT Cyber Space Laboratories</orgName>
								<orgName type="laboratory" key="lab2">NTT Cyber Space Laboratories</orgName>
								<orgName type="institution">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Masashi</forename><surname>Yamamuro</surname></persName>
							<email>yamamuro.masashi@lab.ntt.co.jp</email>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">NTT Cyber Space Laboratories</orgName>
								<orgName type="laboratory" key="lab2">NTT Cyber Space Laboratories</orgName>
								<orgName type="institution">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Stream Monitoring under the Time Warping Distance</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>The goal of this paper is to monitor numerical streams, and to find subsequences that are similar to a given query sequence, under the DTW (Dynamic Time Warping) distance. Applications include word spotting, sensor pattern matching, and monitoring of bio-medical signals (e.g., EKG, ECG), and monitoring of environmental (seismic and volcanic) signals. DTW is a very popular distance measure, permitting accelerations and decelerations, and it has been studied for finite, stored sequence sets. However, in many applications such as network analysis and sensor monitoring , massive amounts of data arrive continuously and it is infeasible to save all the historical data. We propose SPRING, a novel algorithm that can solve the problem. We provide a theoretical analysis and prove that SPRING does not sacrifice accuracy, while it requires constant space and time per time-tick. These are dramatic improvements over the naive method. Our experiments on real and realistic data illustrate that SPRING does indeed detect the qualifying subsequences correctly and that it can offer dramatic improvements in speed over the naive implementation .</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Data streams have attracted the interest of various communities (theory, database, data mining, and networking), due to their many important applications, such as financial analysis, network monitoring, mobile services, and sensor network management. The most fundamental support needed in these applications is efficient monitoring of timeseries data streams. Since the data streams arrive online at high bit rates and are potentially unbounded in size, the resource limitations unavoidably imply a trade-off -it is practically impossible to keep all historical data in the allotted * This material is based upon work supported by the National Science Foundation under Grants No. SENSOR-0329549 EF-0331657IIS-0326322 IIS-0534205. This work is also supported in part by the Pennsylvania Infrastructure Technology Alliance (PITA), Intel, NTT, and HewlettPackard. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation, or other funding parties. memory, but fast query processing must be ensured.</p><p>These applications require a subsequence-matching mechanism to monitor data streams. And in addition, since the sampling rates of streams are frequently different and their time period varies in practical situations, the mechanism should be robust against noise and provide scaling of the time axis. In this paper, we address the problem of efficiently monitoring multiple numerical streams under the DTW (Dynamic Time Warping) distance. DTW is one of the most useful distance measures because of its characteristics: DTW is a transformation that allows sequences to be stretched along the time axis to minimize the distance between the sequences.</p><p>Many algorithms have been proposed to monitor data streams in an online fashion. However, to the best of our knowledge, this is the first study that investigates time warping for monitoring data streams. Intuitively, this problem is equivalent to subsequence matching in an online fashion.</p><p>The problem is illustrated in <ref type="figure" target="#fig_0">Figure 1</ref>. The query sequence is the sinusoid pattern at the left. The stream, shown on the right, consists of three flat and noisy parts and two (noisy) sinusoids, not of the same period. Our system is able to spot the sinusoids after some stretching or shrinking. The matches are marked with vertical lines. Our system not only works continuously, in a streaming fashion, but also has dramatically better performance than a straightforward implementation in terms of speed and memory. The performance of our system does not depend on the past length of the data stream. The savings can reach and exceed several orders of magnitude.</p><p>Our contributions are as follows:</p><p>1. We present SPRING, a new, streaming method for subsequence matching in data streams. The method is fast, accurate, and nimble, requiring constant space and time per time-tick.</p><p>2. We carefully define the problem of disjoint queries, a cross between best-match and range queries, so that it is suitable for a streaming setting.</p><p>3. We carried out extensive experiments on real and realistic data, which show that SPRING works as expected; SPRING is up to 650,000 times faster than the naive method.</p><p>The remainder of the paper is organized as follows. Section 2 describes related work on data streams and DTW. In Section 3 we formally define the problem of monitoring data streams under the DTW distance. We then describe SPRING, our method for solving this problem. Section 4 discusses the accuracy and complexity of SPRING. Section 5 reviews the results of the experiments, which clearly show the effectiveness of SPRING. Section 6 is a brief conclusion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related Work</head><p>Related work falls broadly into two categories. The first category includes work on DTW, where methods have been developed for sequence matching, but the focus is typically on indexing of stored data sets, not on stream processing. The other category includes work on data streams. These methods focus on comparing streams under various L p distances, on clustering, and on summarizing. We review each category.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Sequence indexing for DTW</head><p>The Dynamic Time Warping distance (DTW) is a very popular distance function that allows for scaling along the time axis <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b11">12]</ref>. Many sequence-matching methods for DTW have been proposed, especially in speech recognition <ref type="bibr" target="#b14">[15]</ref> and bioinformatics <ref type="bibr" target="#b10">[11]</ref>.</p><p>Within the database community, several indexing methods for DTW have been proposed, but the focus is mainly on whole sequence matching. <ref type="bibr">Yi et al. and Kim et al. [19, 9]</ref> have proposed lower bounding measures for DTW that guarantee no false dismissals. Keogh <ref type="bibr" target="#b7">[8]</ref> proposed a search method based on global constraints that appear in dynamic programming. Global constraints (e.g., the SakoeChiba Band and the Itakura Parallelogram <ref type="bibr" target="#b14">[15]</ref>) limit the scope of the warping path. Zhu et al.'s search method <ref type="bibr" target="#b20">[21]</ref> is also based on global constraints and represents an improvement over the one proposed by Keogh <ref type="bibr" target="#b7">[8]</ref>. <ref type="bibr">Sakurai et al. [17]</ref> proposed the FTW method with successive approximations, refinements and additional optimizations, to accelerate "whole sequence" matching under DTW.</p><p>Wong et al. studied subsequence matching for DTW <ref type="bibr" target="#b17">[18]</ref>. They introduce a sliding window approach and propose indexing all possible prefixes with a spatial access method. Clearly, their focus is on stored data sets, as opposed to data streams.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Pattern discovery in data streams</head><p>Although none of the streaming methods deals with DTW, we review them here because they examine related topics, such as pattern discovery, summarization, and lossy compression for data streams An interesting method using sketches to discover representative trends in time-series was proposed by Indyk et al. <ref type="bibr" target="#b3">[4]</ref>. A representative trend is the section of a sequence with the smallest sum of "distances" among all other sections of the same length. This method uses random projections <ref type="bibr" target="#b5">[6]</ref> for dimensionality reduction and FFT to quickly compute the sum of distances. Gilbert et al. <ref type="bibr" target="#b1">[2]</ref> use wavelets to compress the data into a fixed amount of memory, by keeping track of the largest Haar wavelet coefficients and carefully updating them on-line. Guha et al. <ref type="bibr" target="#b2">[3]</ref> solve the k-median problem in a single pass over for data streams. Zhu et al.</p><p>[21] studied burst detection in streams. AWSOM <ref type="bibr" target="#b12">[13]</ref> is one of the first streaming methods for forecasting and is intended to discover arbitrary periodicities in single time sequences.</p><p>Multiple streams have also attracted significant interest. Ganti et al. <ref type="bibr" target="#b0">[1]</ref> proposed a generic framework for streaming mining. <ref type="bibr">Zhu et al. [20]</ref> focused on monitoring multiple streams in real time. Their proposed StatStream computes the pairwise correlations among all streams. SPIRIT <ref type="bibr" target="#b13">[14]</ref> addressed the problem of capturing correlations and finding hidden variables corresponding to trends in collections of data streams. Sakurai et al. <ref type="bibr" target="#b15">[16]</ref> proposed BRAID, which efficiently detects lag correlations between data streams. However, none of the above methods examines subsequence matching on streams, under the DTW distance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Proposed Method</head><p>First, we define the problems and some fundamental concepts, then we describe the intuition behind our approach, and finally we give algorithms for solving the problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Dynamic time warping</head><p>Intuitively, the Dynamic Time Warping (DTW) distance of two sequences is the sum of tick-to-tick distances after the two sequences have been optimally warped to match each other. Let us formally consider the two sequences X = (x 1 , x 2 , . . . , x n ) of length n and Y =(y 1 , y 2 , . . . , y m ) of length m. Their DTW distance D(X, Y ) is defined as:  </p><formula xml:id="formula_0">D(X, Y ) = f (n, m) f (t, i) = 񮽙x t − y i 񮽙 + min ⎧ ⎨ ⎩ f (t, i − 1) f (t − 1, i) f (t − 1, i − 1) (1) f (0, 0) = 0, f(t, 0) = f (0, i) = ∞ (t = 1, . . . , n; i = 1, . . . , m)</formula><p>where 񮽙x t − y i 񮽙 = (x t − y i ) 2 is the distance between two numerical values. Notice that any other choice (say, absolute difference: 񮽙x t − y i 񮽙 = |x t − y i |) would be fine; our algorithms are completely independent of such choices. The DTW distance is computed with the "time warping matrix", which stores the values of the function of Equation 1. Specifically, DTW requires O(nm) time since the time warping matrix consists of nm elements. Note that the space complexity is O(m) since the algorithm needs only two columns (i.e., the current and previous columns) of the time warping matrix to compute the DTW distance.</p><p>Given an evolving sequence X(= x 1 , . . . , x n ) and a fixed-length query sequence Y (= y 1 , . . . , y m ), we want to find the subsequences of X that are similar to Y in the sense of the DTW distance. We will give the exact definitions for this problem later (Section 3.1.2). A naive way of subsequence matching would be to compute the time warping matrices starting from every time-tick (See <ref type="figure" target="#fig_1">Figure 2)</ref>. The naive solution requires O(n 2 m) time to find the qualifying subsequence of length l starting from x t (i.e., ending at x t+l−1 ). We show that this approach can be considerably improved without loss of accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Problem definition</head><p>A data stream X is a discrete, semi-infinite sequence of numbers x 1 , x 2 , . . ., x n , . . ., where x n is the most recent value. Notice that n increases with every new time-tick. Let X[t s : t e ] denote the subsequence starting from timetick t s and ending at t e . We want to find the subsequence X[t s : t e ] that has high similarity to a fixed-length query sequence Y (i.e., the subsequence with a small value of</p><formula xml:id="formula_1">D(X[t s : t e ], Y )).</formula><p>When X is a fixed-length sequence, the problem can be formulated as the usual two versions: "best-match query", and "range query". The best-match version, with fixedlength X, is an important stepping stone. Specifically, the sub-problem we want to solve is as follows:</p><p>Problem 1 (Best-match query) Given sequences X of length n and Y of length m, find the subsequence X[t s : t e ] whose DTW distance from Y is the smallest among those of all possible subsequences</p><formula xml:id="formula_2">X[t : j], that is, D(X[t s : t e ], Y ) ≤ D(X[t : j], Y ) for any pair of t = 1, . . . , n and j = t, . . . , n.</formula><p>The full problem we want to solve is one in which the data sequence X is actually a stream of semi-infinite length. In this case, the best-match query makes little sense, since we can never be sure if the future will bring up a better match than the one we have already found. The range query version is suitable in the streaming case. However, a subtle point should be noted: whenever the query Y matches a subsequence of X (say X[t s : t e ]), we expect that there will be several other matches by subsequences which heavily overlap with the "local minimum" best match. Thus, in the standard range query version, we propose adding a second condition that aims to discard all these extra matches. These matches would be doubly harmful: (a) they could potentially flood the user with redundant information and (b) they would slow down the algorithm by forcing it to keep track of and report all these useless "solutions".</p><p>We shall use the term "optimal" subsequence hereafter, to denote exactly the subsequence that is the local best, among a set of overlapping, qualifying subsequences of X. Thus, the main problem we propose and solve in this work is as follows: The additional challenge is to find a streaming solution, which, at time n, will process a new value of X and report each match as early as possible.</p><p>To simplify our presentation, we will focus on the bestmatch query first, and then discuss how to handle the disjoint queries for data streams. Our basic ideas can be applied to both types of query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">Naive solution</head><p>For the best-match problem for a fixed length data sequence X (Problem 1), the most straightforward (and slowest) solution would be to consider all the possible subsequences X[t s : t e ] (1 ≤ t s ≤ t e ≤ n) and apply the standard DTW dynamic programming algorithm, which requires O(n 2 ) matrices. The time complexity would be O(n 3 m) (or O(n 2 m) per time-tick). Not only is this method extremely expensive, but it also cannot be extended to the streaming case. We refer to it as Super-Naive.</p><p>A better solution, but still not good enough, is as follows: to find a qualifying subsequence X[t s : t e ], we would compute the distance between Y and all possible subsequences of X using O(n) matrices and then choose the minimum distance. We refer to this method as Naive.</p><p>Let f t (k, i) be the distance of the element (k, i) in the tth time warping matrix, which starts from t. The minimum distance of the subsequence matching between X and Y can be obtained as follows:</p><formula xml:id="formula_3">D(X[t s : t e ], Y ) = f ts (t e − t s + 1, m) = min(f t (k, m)) f t (k, i) = 񮽙x t+k−1 − y i 񮽙 + min ⎧ ⎨ ⎩ f t (k, i − 1) f t (k − 1, i) f t (k − 1, i − 1) (2) f t (0, 0) = 0, f t (k, 0) = f t (0, i) = ∞ (t = 1, . . . , n; k = 1, . . . , n − t + 1; i = 1, . . . , m).</formula><p>Since the naive solution needs O(n) matrices, O(nm) numbers have to be updated for each time-tick.</p><p>The processing of disjoint queries has to be done in the same way. The naive solution computes the distances of all possible subsequences, and then chooses the one that gives the minimum distance from each group of overlapping subsequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Basic ideas</head><p>Our solution is based on the two ideas described below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Star-padding</head><p>The naive solution creates a new time warping matrix for every time-tick. Instead of the naive solution that needs O(n) matrices, we propose using only a single matrix to obtain the minimum distance of subsequences of X.</p><p>Our first proposed idea is to prefix the sequence Y with a special value ("*"), that always gives zero distance. This value stands for the "don't care" interval, that is, the interval (−∞ : +∞). Let Y = (y 1 , y 2 , . . . , y m ) be a query sequence. We introduce its augmented version Y 񮽙 :</p><formula xml:id="formula_4">Y 񮽙 = (y 0 , y 1 , y 2 , . . . , y m ) (3) y 0 = (−∞ : +∞).</formula><p>We use Y 񮽙 to compute the DTW distances of Y and subsequences of X, instead of operating on the original sequence of Y .</p><p>Observation 1 Once we introduce the star-padding, we need only a single time-warping matrix to find the best subsequence of X.</p><p>Star-padding dramatically reduces both time and space since we need to update only O(m) numbers per time-tick to derive the minimum distance, instead of O(nm), which the naive solution requires. As we show later (see Theorem 1), star-padding guarantees that we obtain the minimum distance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Subsequence time warping matrix (STWM)</head><p>Star-padding is a good first step, and it can tell us (a) what the ending of the matching subsequence is, and (b) what its distance from the query sequence is. However, such applications often also need the starting time-tick of the match. This is the motivation behind our second idea, the "subsequence time warping matrix" (STWM): we augment the time warping matrix and have each of its cells to record the starting position of each candidate subsequence. More specifically, the (t, i) cell of the usual time warping matrix contains the value d(t, i), which is the best distance to match the prefix of length t from X with the prefix of length i from Y (i.e., t = 1, . . . , n; i = 1, . . . , m); our proposed STWM will also record s(t, i), that is, the starting position corresponding to d(t, i). In other words, the values s(t, i) and d(t, i) in the STWM mean that the subsequence from s(t, i) through t gives distance d(t, i), which is the best we can achieve for the t-and i-prefix of X and Y , respectively. We will give an arithmetical example of an STWM later ( <ref type="figure" target="#fig_4">Figure 5</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Observation 2</head><p>The subsequence time warping matrix (STWM) includes the distance value and starting position of each subsequence. Thus, we can identify the qualifying subsequence in a stream fashion.</p><p>We update the starting position accompanied by the distance value as well as the distance value itself. By using the matrix, we can identify which subsequence gave the minimum distance during stream processing.</p><p>In brief, from the above discussion we can summarize that our solution (i.e., the combination of star-padding and STWM) efficiently discards information about nonqualifying subsequences using a single matrix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">SPRING</head><p>In this section, we propose algorithms for solving the problems described in Section 3.1.2.</p><p>Our method, SPRING, efficiently detects high-similarity subsequences in data streams. <ref type="figure" target="#fig_2">Figure 3</ref> illustrates how this is done. SPRING uses the STWM of X and Y 񮽙 , in which each element (t, i) retains both distance and starting position. SPRING reports all qualifying subsequences for disjoint queries, while giving the most similar subsequence X[t s : t e ] for best-match queries. Before introducing our algorithms, we give the details of the star-padding and STWM.</p><p>Given a sequence Y = (y 1 , . . . , y m ), we have the starpadding of Y , i.e., Y 񮽙 = (y 0 , y 1 , . . . , y m ) where y 0 = (−∞ : +∞). Let X be a sequence of length n, we can then derive the minimum distance D(X[t s : t e ], Y ) from the matrix of X and Y 񮽙 .</p><formula xml:id="formula_5">D(X[t s : t e ], Y ) = d(t e , m) = min(d(t, m)) d(t, i) = 񮽙x t − y i 񮽙 + d best (4) d best = min ⎧ ⎨ ⎩ d(t, i − 1) d(t − 1, i) d(t − 1, i − 1) d(t, 0) = 0, d(0, i) = ∞ (t = 1, . . . , n; i = 1, . . . , m).</formula><p>As well as the distance d(t, i), the matrix contains the starting position:</p><formula xml:id="formula_6">s(t, i) = ⎧ ⎨ ⎩ s(t, i − 1) (d(t, i − 1) = d best ) s(t − 1, i) (d(t − 1, i) = d best ) s(t − 1, i − 1) (d(t − 1, i − 1) = d best ).<label>(5)</label></formula><p>We obtain the starting position of D(X[t s : t e ], Y ) as:</p><formula xml:id="formula_7">t s = s(t e , m).<label>(6)</label></formula><p>The optimal warping path is obtained using the distance computation, and the starting position of the best subsequence is propagated through the matrix on the optimal warping path.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Algorithm</head><p>Let d i and d 񮽙 i be arrays of m distance values, and let s i and s 񮽙 i be arrays of m integers. The DTW distance of each subsequence can be incrementally computed as:</p><formula xml:id="formula_8">d i = 񮽙x t − y i 񮽙 + d best (7) d best = min(d i−1 , d 񮽙 i , d 񮽙 i−1 ) d 0 = d 񮽙 0 = 0 where d i = d(t, i), and d 񮽙 i = d(t − 1, i) at time-tick t.</formula><p>Similarly, we obtain the starting position of the subsequence as:</p><formula xml:id="formula_9">s i = ⎧ ⎨ ⎩ s i−1 (d i−1 = d best ) s 񮽙 i (d 񮽙 i = d best ) s 񮽙 i−1 (d 񮽙 i−1 = d best )<label>(8)</label></formula><p>where s i = s(t, i), and s 񮽙 i = s(t − 1, i). Thus, we update m distance values and m integers for each time-tick.</p><p>The stream processing for best-match queries is straightforward; it simply uses Equations <ref type="formula">(7)</ref> and <ref type="formula" target="#formula_9">(8)</ref>, and reports the best subsequence when the user requires it.</p><p>For disjoint queries, the most straightforward algorithm would be: as soon as we find a matching subsequence (i.e., with distance ≤ 񮽙), we report it and then initialize the array of d i . This algorithm satisfies the first condition of Problem 2 (i.e., d m ≤ 񮽙) and is useful if the user wants a quick response. This algorithm, however, does not satisfy the second condition of the problem. In fact, it may miss the optimal subsequence, if there are multiple overlapping subsequences within 񮽙.</p><p>We introduce an new algorithm, which is carefully designed to (a) guarantee no false dismissals for the second condition of Problem 2 and (b) report each match as early as possible. As <ref type="figure" target="#fig_3">Figure 4</ref> illustrates, for each incoming data point, we first incrementally update the distance d i and determine the starting position s i according to the computation of d i . The algorithm reports the subsequence after confirming that the current optimal subsequence cannot be replaced by the upcoming subsequences. The idea is to keep track of the minimum distance, d min , while investigating the group of overlapping subsequences. We report the subsequence that gives d min when the arrays of d i and s i satisfy</p><formula xml:id="formula_10">∀ i , d i ≥ d min ∨ s i &gt; t e<label>(9)</label></formula><p>which means that the captured optimal subsequence cannot be replaced by the upcoming subsequences. Otherwise, the Algorithm SPRING input: a new value xt at t output: qualifying subsequence if any for i = 1 to m do Compute di and si by Equations <ref type="formula">(7)</ref>   Here, we use <ref type="figure" target="#fig_4">Figure 5</ref> to illustrate how the algorithm works.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 1</head><p>Assume that 񮽙 = 15, X = ( <ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b12">13)</ref>, and Y = (11, 6, 9, 4). The element (t, i) of the matrix contains d(t, i) and s(t, i). At t = 3, we found candidate subsequence X[2 : 3] whose distance d(3, 4) = 14 below 񮽙. At t = 4, although the distance d(4, 4) = 38 is larger than 񮽙, we do not report X <ref type="bibr">[2 : 3]</ref> since d(4, 3) = 2, which means X[2 : 3] can be replaced by the upcoming subsequences. We then capture the optimal subsequence X[2 : 5] at t = 5. X <ref type="bibr">[2 : 5]</ref> is reported at t = 7 since we now know that none of the upcoming subsequences will be/is the optimal subsequence. Finally, because subsequences starting from t = 7 may be candidates for the next group, we do not initialize d(7, 1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Theoretical Analysis</head><p>Our upcoming experiments show that SPRING can efficiently spot qualifying subsequences. In this section, we do a theoretical analysis to demonstrate the accuracy and complexity of SPRING.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Accuracy</head><p>Theorem 1 Given sequences X and Y , the DTW distance between X and Y 񮽙 (i.e., the star-padding of Y ) is the minimum distance between Y and all subsequences of X.  Proof: Let X[t s : t e ] be the subsequence that gives the minimum distance, then</p><formula xml:id="formula_11">f ts (t e − t s + 1, m) = min(f t (k, m)) (t = 1, .</formula><p>. . , n; k = 1, . . . , n − t + 1).</p><p>From d(t, 0) = 0, we have</p><formula xml:id="formula_12">d(t s , 1) = f ts (1, 1).</formula><p>Since the optimal warping path from element (t s , 1) through (t e , m) gives the minimum distance, Equation <ref type="formula">(4)</ref> chooses the same warping path from (t s , 1). Thus, we have</p><formula xml:id="formula_13">d(t e , m) = f ts (t e − t s + 1, m).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>Lemma 1 SPRING guarantees no false dismissals for bestmatch queries.</p><p>Proof: By Theorem 1, the DTW distance between X and Y 񮽙 is equal to the minimum distance between Y and subsequences of X. Since the subsequence time warping matrix contains the starting position, SPRING spots the subsequence that gives the minimum distance. 2</p><p>Lemma 2 SPRING guarantees no false dismissals for disjoint queries.</p><p>Proof: Let d min be the minimum distance computed from X[t s : t e ]. At time-tick t (t &gt; t e ), the overlapping subsequences give a larger distance if</p><formula xml:id="formula_14">∀ i , d i ≥ d min .</formula><p>The upcoming candidate subsequences do not overlap with</p><formula xml:id="formula_15">X[t s : t e ] if ∀ i , s i &gt; t e .</formula><p>SPRING (See <ref type="figure" target="#fig_3">Figure 4)</ref> reports X[t s : t e ] only if</p><formula xml:id="formula_16">∀ i , d i ≥ d min ∨ s i &gt; t e .</formula><p>Thus, it does not miss the optimal subsequence. SPRING initializes d i whose elements satisfy s i ≤ t e after reporting the optimal subsequence. Let s(t, i) ≤ t e . If the warping paths starting from s(t, i) and passing through (t, i) give a distance that exceeds 񮽙, the other subsequences passing through (t, i) also give a larger distance. Otherwise, all subsequences passing through (t, i) are included in the group of overlapping subsequences, which means that there is no need to report them. Thus, SPRING is guaranteed not to discard the upcoming candidate subsequences. 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Complexity</head><p>Let X be an evolving sequence of length n and Y be a sequence of fixed-length m. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Experiments</head><p>To evaluate the effectiveness of SPRING, we carried out experiments on real and synthetic data sets. Our experiments were conducted on an Intel Xeon 2.8GHz with 1GB of memory, running Linux.</p><p>The experiments were designed to answer the following questions:</p><p>1. How successful is SPRING in capturing sequence patterns?</p><p>2. How does it scale with the sequence lengths n in terms of the computational time and memory space?</p><p>3. How well does SPRING handle multiple streams?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Discovery of sequence patterns</head><p>We present case studies on real and realistic data sets to demonstrate the effectiveness of our approach in discovering the qualifying subsequences for disjoint queries. <ref type="figure" target="#fig_6">Figure 6</ref> shows how SPRING detects the qualifying subsequences. If multiple qualifying subsequences exist, we point them all out. <ref type="table" target="#tab_4">Table 2</ref> shows the details of the experimental results. In this table, 'Distance' means the DTW distance between the query sequence and each subsequence. 'Output time' indicates the time-tick at which SPRING reports the subsequence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MaskedChirp</head><p>We used a synthetic data set, MaskedChirp, which consists of discontinuous sine waves with white noise. We varied the period of each disjoint sine wave in the sequence. We chose this setting because it resembles real data, such as voice data, which include sound and silent parts with varying time periods. <ref type="figure" target="#fig_6">Figure 6</ref> (a) shows that SPRING can perfectly identify all sound parts (i.e., the subsequences from #1 to #4) and that it is robust against noise. <ref type="table" target="#tab_4">Table 2</ref> shows that the output time of each captured subsequence is very close to its end position. For example, the output time of subsequence #4 is 18844, which is close to its end position 18052 (=15171 + 2882 -1), while our method guarantees the provision of the optimal subsequence. Note that the output time does not depend on threshold 񮽙.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Temperature</head><p>We used temperature measurements (degrees Celsius) in the Critter data set, which comes from small sensors. The sensors give a reading approximately every minute. In this data set there are many missing values, which arise all the time. This is the same data set that was used previously <ref type="bibr" target="#b15">[16]</ref>.</p><p>As shown in <ref type="figure" target="#fig_6">Figure 6</ref> (b), there are two similar patterns that significantly fluctuate with weather conditions (which range from 20 to 32 degrees). SPRING is not sensitive at all to the missing values. Actually, SPRING finds the days when the temperature fluctuates from cool to hot.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Kursk</head><p>The data set for <ref type="figure" target="#fig_6">Figure 6</ref> (c) consists of seismic recordings from multiple sensors at different locations, which show the explosion of the Russian submarine Kursk <ref type="bibr" target="#b9">[10]</ref> in 2000. Each sequence has single or multiple bursts.</p><p>The explosions shown in these sequences look similar; however, the intervals between large spikes are slightly different. This phenomenon was due to differences in environmental conditions such as underwater temperature. As can be seen in the figure, SPRING is not affected by the difference in the environmental conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sunspots</head><p>We know that sunspots appear in cycles. For example, during one 30-year period within the so-called "Maunder Minimum", only about 50 sunspots were observed, as opposed to the normal 40,000-50,000 spots. The average number of visible sunspots varies over time, increasing and decreasing in a regular cycle of between 9.5 and 11 years, averaging about 10.8 years <ref type="bibr" target="#b0">1</ref> . Each value in <ref type="figure" target="#fig_6">Figure 6</ref> (d) indicates the number of sunspots per day. SPRING can capture bursty sunspot periods and identify the time-varying periodicity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Performance</head><p>We did experiments to evaluate the efficiency and to verify the complexity of SPRING, which discussed in Section 4.2. <ref type="figure">Figure 7</ref> compares SPRING and the naive implementation in terms of computation time for varying sequence lengths n. <ref type="figure">Figure 8</ref> shows the amount of memory space 1 http://csep10.phys.utk.edu/astr162/lect/sun/sscycle.html required to keep the time warping matrix (matrices). The plots were generated using MaskedChirp, which allowed us to control the sequence length. The length of the query sequence for these experiments was 256. The wall clock time is the average processing time needed to update the time warping matrix (matrices) for each time-tick and to capture the qualifying subsequences.</p><p>As we expected, SPRING identifies the qualifying subsequences much faster than the naive implementation (See <ref type="figure">Figure 7)</ref>. The trend shown in the figure agrees with our theoretical discussion in Section 4.2. Compared with O(nm), which the naive implementation requires, SPRING achieves a dramatic reduction in computation time: it requires constant time; i.e., it does not depend on n. In fact, SPRING is up to 650,000 times faster than the naive implementation.</p><p>SPRING is able to provide information about the ar-  rangement (i.e., the warping path) of the optimal subsequence and the query sequence although we assume that our method is required to keep track of the position of the optimal subsequence. In <ref type="figure">Figure 8</ref>, SPRING(path) indicates the space requirements of the former case, and SPRING shows that of the latter. The space requirement of SPRING(path) depends on the captured data. The figure, however, shows that it is clearly lower than that of the naive implementation. As we expected, SPRING needs a small constant space to keep track of the subsequence position, which shows a dramatic improvement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Extension to multiple streams</head><p>We extend SPRING to handle multiple streams ("vector" streams), where each time-tick has not just a number, but a whole vector of k numbers, and the query is also a set of k sequences of m time-ticks. The driving application is motion capture data. A Motion Capture (or "mocap") sequence is created by recording motion information from a human actor while the actor is performing an action (e.g., walking, running, kicking). Special markers are placed on the joints of the actor (e.g., knees, hips, elbows), and their x-, y-and zvelocities are recorded, about 60 times per second. Eventually, a whole motion X is a time-evolving vector with k=62 dimensions and 60 samples per second, spanning several seconds.</p><p>The query Y is again a k-dimensional time sequence whose the goal is to find a matching subsequence within X. The intuition is the following: if Y is a walking motion, we want to find intervals in X that contain a walking-like motion.</p><p>We used a single sequence of 7 consecutive motions (See <ref type="figure">Figure 9)</ref>, and other 4 sequences as query sequences, where each query sequence contains one of the 4 motions; walking, jumping, punching, and kicking. The data were from the CMU motion capture database 2 . We modified the algorithm of SPRING for the motion capture to report the starting and ending positions of the range of overlapping subsequences. SPRING perfectly captures all 7 motions shown in <ref type="figure">Figure 9</ref> while still maintaining scalability. Due to the space limitations we omit the detailed experimental results.</p><p>(1) walking (2) jumping (3) walking (4) punching (5) walking (6) kicking (7) punching <ref type="figure">Figure 9</ref>. Sequence of 7 motions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions</head><p>We introduced the problem of subsequence matching under DTW, over data streams, and we propose SPRING, a new, fast algorithm to solve the problem. Notice that the DTW distance has been studied for finite, stored sequence sets (e.g., <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b20">21]</ref>). While we focus on stream processing in this paper, SPRING can obviously be applied to stored sequence sets, too, complementing the above solutions, and potentially making them faster.</p><p>In conclusion, SPRING has the following characteristics:</p><p>• It is fast and nimble: in contrast to the naive solution, SPRING requires only a single matrix to find the qualifying subsequences, and only constant space and time per time-tick; that is, it does not depend on the past length of data stream X.</p><p>• It guarantees no false dismissals.</p><p>• On real and realistic data, SPRING works as expected, discovering the qualifying subsequences quickly and accurately. Specifically, SPRING was up to 650,000 times faster.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 . Illustration of stream monitoring under the DTW distance. The left and right columns show the query sequence and stream, respectively.</head><label>1</label><figDesc>Figure 1. Illustration of stream monitoring under the DTW distance. The left and right columns show the query sequence and stream, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 . Illustration of subsequence match- ing under the DTW distance. The black squares denote the optimal warping path in the time warping matrix. The naive solution has to maintain the matrices starting from ev- ery time-tick.</head><label>2</label><figDesc>Figure 2. Illustration of subsequence matching under the DTW distance. The black squares denote the optimal warping path in the time warping matrix. The naive solution has to maintain the matrices starting from every time-tick.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 . Illustration of SPRING. SPRING uses only a single matrix to capture all qualifying subsequences for disjoint queries.</head><label>3</label><figDesc>Figure 3. Illustration of SPRING. SPRING uses only a single matrix to capture all qualifying subsequences for disjoint queries.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Algorithm for disjoint queriesprints the optimal subsequences.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 . Illustration of the proposed algo- rithm. The upper number shows the distance in each element of the matrix. The number in parentheses shows the starting position.</head><label>5</label><figDesc>Figure 5. Illustration of the proposed algorithm. The upper number shows the distance in each element of the matrix. The number in parentheses shows the starting position.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Lemma 3 The naive solution requires O(nm) space and O(nm) time per time-tick. Proof: The naive solution has to maintain O(n) time warp- ing matrices, and updates O(nm) numbers every time- tick to identify qualifying subsequences. Thus, it requires O(nm) time. Since the naive solution keeps two arrays of m numbers for each matrix, overall, it needs O(nm) space. 2 Lemma 4 SPRING requires O(m) space and O(m) time per time-tick. Proof: SPRING keeps a single matrix, and updates O(m) numbers every time-tick. Thus, SPRING requires O(m) space and time. 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Discovery of sequence patterns in MaskedChirp, Temperature, Kursk, and Sunspots. The left and right columns show the query sequences and data sequences, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 . Wall clock time for disjoint queries as a function of sequence length. SPRING is up to 650 Figure 8 . Memory space consumption for dis- joint queries as a function of sequence length. SPRING can handle data streams with a small constant memory space.</head><label>76508</label><figDesc>Figure 7. Wall clock time for disjoint queries as a function of sequence length. SPRING is up to 650,000 times faster.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>Table 1 . Symbols and definitions Symbol Definition X Data sequence/stream of length n xt Value/element of X at time t = 1, . . . , n X[ts : te] Subsequence of X, including elements in positions ts through te Y Queryin the t-th time warping matrix of X and Y d(t, i), di Distance of (t, i) in the matrix of X and Y 񮽙 s(t, i), si Starting position of (t, i)</head><label>1</label><figDesc></figDesc><table>sequence of length m 
yi 
i-th element of Y 
Y 񮽙 
Star-padding of Y 
D(X, Y ) DTW distance between X and Y 
ft(k, i) 
Distance of the element (k, i) </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>: t e ] such that: t e ], Y ) ≤ 񮽙, and 2. among several overlapping matches, report only the local minimum; that is, D(X[t s : t e ], Y ) is the small- est value in the group of overlapping subsequences that satisfy the first condition.</head><label></label><figDesc></figDesc><table>Problem 2 (Disjoint query) Given a stream X (that is, an 
evolving data sequence, which at the time of interest has 
length n), a query sequence Y of fixed-length m, and a 
threshold 񮽙, report all subsequences X[t s 1. the subsequences are close enough to the query se-
quence: D(X[t s </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>// Reset dmin and the array of di dmin = ∞; for i = 1 to m do if si ≤ te then di = ∞; endif endif if dm ≤ 񮽙 ∧ dm &lt; dmin then dmin = dm; ts = sm; te = t; endif Substitute d 񮽙 i for di; Substitute s 񮽙 i for si;</head><label></label><figDesc></figDesc><table>(8); 
if dmin ≤ 񮽙 then 
if ∀i, di ≥ dmin ∨ si &gt; te then 
Report (dmin, ts, te); 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="true"><head>Table 2 . Results of disjoint queries.</head><label>2</label><figDesc></figDesc><table>Query sequences 
Matching subsequences 
Data sets 
Threshold Starting 
Output 
Length 
񮽙 
position 
Length Distance 
time 
MaskedChirp 
2048 
100 
513 
2015 
10.05 
3176 
4614 
2366 
11.39 
7601 
9103 
3969 
18.59 
14137 
15171 
2882 
12.42 
18844 
Temperature 
3000 
1000 
13293 
3602 
820.1 
17830 
24406 
4073 
6.5 
28653 
Kursk 
4000 
5.0e+9 
28013 
3981 
7.06e+8 
36711 
Sunspots 
2000 
8.0e+5 
2466 
1717 
5.67e+5 
5591 
6878 
1599 
5.45e+5 
9509 
9734 
1587 
4.87e+5 
12257 
13266 
1994 
5.48e+5 
16532 

0.001 

0.01 

0.1 

1 

10 

100 

1000 

10000 

1e+03 
1e+04 
1e+05 
1e+06 
Wall clock time (ms) 

Sequence length 

Naive 
SPRING 

</table></figure>

			<note place="foot" n="2"> http://mocap.cs.cmu.edu/</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Mining data streams under block evolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Ganti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gehrke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGKDD Explorations</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="10" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Surfing wavelets on streams: One-pass summaries for approximate aggregate queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kotidis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Strauss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB<address><addrLine>Rome, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-09" />
			<biblScope unit="page" from="79" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Clustering data streams: Theory and practice</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Meyerson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>O&amp;apos;callaghan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TKDE</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="515" to="528" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Identifying representative trends in massive time series data sets using sketches</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Indyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB<address><addrLine>Cairo, Egypt</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-09" />
			<biblScope unit="page" from="363" to="372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Hierarchical filtering method for content-based music retrieval via acoustic input</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-S</forename><forename type="middle">R</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-R</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Multimedia</title>
		<meeting>ACM Multimedia</meeting>
		<imprint>
			<date type="published" when="2001-10" />
			<biblScope unit="page" from="401" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Extensions of lipschitz mappings into hilbert space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lindenstrauss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Contemporary Mathematics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="189" to="206" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Automatic modeling of a 3d city map from real-world video</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kawasaki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Yatabe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ikeuchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sakauchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Multimedia (1)</title>
		<meeting>ACM Multimedia (1)</meeting>
		<imprint>
			<date type="published" when="1999-11" />
			<biblScope unit="page" from="11" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Exact indexing of dynamic time warping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename><surname>Keogh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB<address><addrLine>Hong Kong, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-08" />
			<biblScope unit="page" from="406" to="417" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An index-based approach for similarity search supporting time warping in large sequence databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-W</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">W</forename><surname>Chu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="2001-04" />
			<biblScope unit="page" from="607" to="614" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Forensic seismology and the sinking of the kursk</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Koper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hartse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EOS Trans., AGU</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="page" from="45" to="46" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Bioinfomatics: Sequence and Genome Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">W</forename><surname>Mount</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<pubPlace>Cold Spring Harbor, New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Memorybased forecasting for weather image patterns</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Otsuka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Horikoshi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Suzuki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kojima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th Conference on Artificial Intelligence (AAAI)</title>
		<meeting>the 17th Conference on Artificial Intelligence (AAAI)</meeting>
		<imprint>
			<date type="published" when="2000-07" />
			<biblScope unit="page" from="330" to="336" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Adaptive, hands-off stream mining</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Brockwell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-09" />
			<biblScope unit="page" from="560" to="571" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Streaming pattern discovery in multiple time-series</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB<address><addrLine>Trondheim, Norway</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-09" />
			<biblScope unit="page" from="697" to="708" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Fundamentals of Speech Recognition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Rabiner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B.-H</forename><surname>Juang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
			<pubPlace>Englewood Cliffs, N. J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Braid: Stream mining through group lag correlations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sakurai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGMOD</title>
		<meeting>ACM SIGMOD<address><addrLine>Baltimore, Maryland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-06" />
			<biblScope unit="page" from="599" to="610" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Ftw: Fast similarity search under the time warping distance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sakurai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Yoshikawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of PODS</title>
		<meeting>PODS<address><addrLine>Baltimore, Maryland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-06" />
			<biblScope unit="page" from="326" to="337" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Efficient subsequence matching for sequence databases under time warping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S F</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IDEAS</title>
		<imprint>
			<date type="published" when="2003-09" />
			<biblScope unit="page" from="139" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Efficient retrieval of similar time sequences under time warping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B.-K</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="1998-02" />
			<biblScope unit="page" from="201" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Statistical monitoring of thousands of data streams in real time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Shasha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB<address><addrLine>Hong Kong, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-08" />
			<biblScope unit="page" from="358" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Warping indexes with envelope transforms for query by humming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Shasha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIG-MOD</title>
		<meeting>ACM SIG-MOD<address><addrLine>San Diego, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-06" />
			<biblScope unit="page" from="181" to="192" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
