<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:56+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">BooM: A Decision Procedure for Boolean Matching with Abstraction and Dynamic Learning</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chih-Fan</forename><surname>Lai</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">EE Dept./GIEE National</orgName>
								<orgName type="institution">GIEE National Taiwan University</orgName>
								<address>
									<postCode>10617</postCode>
									<settlement>Taipei</settlement>
									<country key="TW">Taiwan</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jie-Hong</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
							<email>jhjiang@cc.ee.ntu.edu.tw</email>
							<affiliation key="aff1">
								<orgName type="department">CSIE Dept. Fu</orgName>
								<orgName type="institution">Taiwan University</orgName>
								<address>
									<postCode>10617</postCode>
									<settlement>Taipei</settlement>
									<country key="TW">Taiwan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kuo-Hua</forename><surname>Wang</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Jen Catholic University</orgName>
								<address>
									<addrLine>Hsinchuang</addrLine>
									<postCode>24205</postCode>
									<country key="TW">Taiwan</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">BooM: A Decision Procedure for Boolean Matching with Abstraction and Dynamic Learning</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>B63 [Logic Design]: Design Aids-automatic synthesis</term>
					<term>verification General Terms Algorithms</term>
					<term>design</term>
					<term>verification Keywords Boolean matching</term>
					<term>satisfiability solving</term>
					<term>learning</term>
					<term>abstraction</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Boolean matching determines whether two given (in)completely-specified Boolean functions can be identical or complementary to each other under permutation and/or negation of their input variables. Due to its broad applications in logic synthesis and verification, it attracted much attention. Most prior efforts however were incomplete and/or restricted to certain special matching conditions. In contrast, this paper focuses on the computation kernel of Boolean matching and proposes a complete generic framework. Through conflict-driven learning and abstraction, the capacity of Boolean matching scales up due to the effective pruning of infeasible matching solutions. Experiments show encouraging results in resolving hard instances that are otherwise unsolvable.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Boolean matching is an important subject of both theoretical and practical interest. Given two (in)completelyspecified Boolean functions, Boolean matching (under NPNequivalence) determines if they can be identical or complementary to each other under certain input permutation and/or negation. From a theoretical standpoint, the computational complexity of Boolean matching (known as Boolean congruence, Boolean isomorphism, and other variants, which received attention dating back to the nineteenth century) situates in between coNP and Σ p 2 in the polynomial hierarchy <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b3">4]</ref>. Thus it is a good candidate for examining the open question about the collapse of the polynomial hierarchy. From a practical standpoint, it has broad applications in logic synthesis and verification, for instance, library binding <ref type="bibr" target="#b4">[5]</ref>, FPGA technology mapping <ref type="bibr" target="#b7">[8]</ref>, logic verification <ref type="bibr" target="#b12">[13]</ref>, engineering change order <ref type="bibr" target="#b10">[11]</ref>, etc.</p><p>The demand from practical applications drives the advances of Boolean matching algorithms over the last two decades. By the survey <ref type="bibr" target="#b4">[5]</ref> and recent developments <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b18">19]</ref>, prior methods can be classified into four categories: spectral, signature-based, canonical-form-based, and, the more recent, SAT-based methods. Spectral methods are complete, but often with prohibitive computation cost. Signature-based methods are effective, but mostly incomplete due to their intrinsic limitations <ref type="bibr" target="#b11">[12]</ref>. Canonical-form-based methods are complete, and have been improved recently, see, e.g., <ref type="bibr" target="#b1">[2]</ref> for a review. SAT-based methods are complete <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b18">19]</ref>; however, the strengths of modern propositional satisfiability (SAT) solvers have not been fully exploited yet. Among prior Boolean matching techniques, only a few took the general NPN-equivalence into account. Even if this general problem is considered, their computation costs may still be too expensive to be practical. Furthermore, spectral, signature-based, and canonical-form-based methods are not easily extendable to deal with incompletely specified functions, see, e.g., <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b0">1]</ref> for a recent treatment.</p><p>We show that these shortcomings can be naturally resolved under a general computation framework, named BooM, a decision procedure dedicated to Boolean matching. In essence Boolean matching is a decision problem of solving quantified Boolean formulas (QBFs). Particularly its special problem structure allows effective conflict-driven learning for search space reduction, which is beyond the capability of a generic QBF solver.</p><p>The features of BooM are summarized as follows. 1) It handles NPN-equivalence, and both completely and incompletely specified functions. 2) It is equipped with abstraction and dynamic learning techniques for effective search space reduction. 3) It supports the search of one matching solution and of all solutions. 4) It admits easy integration with signature-based techniques for search space reduction, and helps signature-based Boolean matching be complete. 5) It uses memory efficient data structures, specifically, andinverter graphs (AIGs) and conjunctive normal form (CNF) formulas, for scalable Boolean function representation. Experimental results show the effectiveness of BooM in conquering instances hard to solve without learning and abstraction.</p><p>Compared with the closest prior work <ref type="bibr" target="#b16">[17]</ref>, BooM outperforms it and can be much scalable. This prior method relies on the sum-of-products representation of the two functions to be matched, and consists of two separate computation phases: first learning and second SAT solving. Since there is no feedback between these two phases, the first phase can be interpreted as static learning in a sense. In contrast, our learning and SAT solving are interactive (with feedback). Infeasible solutions are learned from a conflict produced by SAT solving; SAT solving searches a solution in the space refined by learning. Hence the learning in BooM is more global and dynamic. As SOP representation may not be always available especially for large designs, the prior method can be limited. This paper is organized as follows. Section 2 gives the preliminaries. Boolean matching under NPN-equivalence is presented in Section 3, and P-equivalence in Section 4. Experimental evaluation is provided in Section 5. Finally Section 6 concludes this paper and outlines future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARIES</head><p>As conventional notation, a set of Boolean variables is denoted with an upper-case letter, e.g., X; its elements are in lower-case letters, e.g., xi ∈ X. The ordered version (namely, vector) of a set X = {x 1 , . . . , x n } is denoted as x = (x 1 , . . . , x n ). The cardinality of a set X (respectively x) is denoted as |X| (respectively | x|). The set of truth valuations of</p><formula xml:id="formula_0">x is denoted [[ x]], e.g., [[(x1, x2)]] = {(0, 0), (0, 1), (1, 0), (1, 1)}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Boolean Matching</head><p>A permutation π over X is a bijection function π : X → X; a negation ν over X is a componentwise mapping with ν(xi) = xi or ¬xi. We let π( x) and ν( x) be the shorthand for (π(x 1 ), . . . , π(x n )) and (ν(x 1 ), . . . , ν(x n )), respectively.</p><p>Given two (completely specified) functions f ( x) and g( y) with | x| = | y|, Boolean matching under NPN-equivalence determines if these two functions can be equivalent or complementary (the second "N" of "NPN") to each other under negation (the first "N") and permutation (the "P") of their input variables. Its special cases include NP-equivalence</p><formula xml:id="formula_1">(determining if f ( x) = g(ν • π( x)</formula><p>) for some negation ν and permutation π) and P-equivalence (determining if f ( x) = g(π( x)) for some permutation π). We call ν • π (respectively π) a matching solution for NP-equivalence (respectively P-equivalence) if f ( x) = g(ν • π( x)) (respectively f ( x) = g(π( x))). In the sequel, unless otherwise said, we shall assume | x| = | y| = n.</p><p>Boolean matching for two incompletely specified functions is similar, except that the functional equivalence is asserted only under the care-conditions of both functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Propositional Satisfiability</head><p>By assuming the reader's familiarity with circuit-to-CNF conversion <ref type="bibr" target="#b15">[16]</ref> and SAT solving, including conflict-based learning <ref type="bibr" target="#b14">[15]</ref> and other commonly used techniques in modern SAT solvers, e.g., <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b9">10]</ref>, we omit to provide the background knowledge.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">MATCHING FOR NPN-EQUIVALENCE</head><p>Given two functions f ( x) and g( y), optionally with their care-conditions f c ( x) and g c ( y), respectively, we decide whether f and g can be NPN-equivalent under the care-conditions. In particular, this problem can be divided into two subtasks by deciding whether f and g or whether f and ¬g are NPequivalent. Consequently we focus on Boolean matching under NP-equivalence. Formally speaking, this task is to decide the validity of the second-order formula</p><formula xml:id="formula_2">∃ν • π, ∀ x.((fc( x) ∧ gc(ν • π( x))) ⇒ (f ( x) ≡ g(ν • π( x)))), (1)</formula><p>which is convertible to a first-order formula as shown below.</p><p>To represent y = ν • π( x), we introduce the 0-1 matrix:</p><formula xml:id="formula_3">     x 1 ¬x 1 x 2 ¬x 2 · · · x n ¬x n y 1 a 11 b 11 a 12 b 12 · · · a 1n b 1n y 2 a 21 b 21 a 22 b 22 · · · a 2n b 2n . . . . . . . . . . . . . . . . . . . . . . . . y n a n1 b n1 a n2 b n2 · · · a nn b nn     <label>(2)</label></formula><p>By asserting n j=1</p><p>(a ij + b ij ) = 1 for i = 1, . . . , n, and</p><formula xml:id="formula_4">(3) n i=1 (a ij + b ij ) = 1 for j = 1, . . . , n,<label>(4)</label></formula><p>this matrix represents some legal mapping ν • π, for a ij = 1 and b ij = 1 indicating mapping x j to y i and mapping ¬x j to yi, respectively. These cardinality constraints <ref type="formula">(3)</ref> and <ref type="formula" target="#formula_4">(4)</ref> can be expressed by a propositional formula ϕC of 2n 2 Boolean variables a ij and b ij , for i, j = 1, . . . , n. By asserting the formula</p><formula xml:id="formula_5">ϕA = n i,j=1 ((aij ⇒ (yi ≡ xj))(bij ⇒ (yi ≡ ¬xj))),</formula><p>a solution to ϕ C induces some unique mapping ν • π. Conversely a mapping ν • π corresponds to some unique solution to ϕC . Hence in the sequel we shall not distinguish a mapping ν • π and its corresponding solution to ϕ C . In practice, ϕ C and ϕ A are written in CNF.</p><p>Clearly solving Formula (1) is equivalent to solving the following (first-order) QBF</p><formula xml:id="formula_6">∃ a, ∃ b, ∀ x, ∀ y.(ϕ C ∧ ϕ A ∧ ((f c ∧ g c ) ⇒ (f ≡ g))),<label>(5)</label></formula><p>where a = (a 11 , . . . , a nn ) and b = (b 11 , . . . , b nn ). That is, we look for a truth assignment to variables a and b that satisfies ϕC and makes the miter constraint</p><formula xml:id="formula_7">Ψ = ϕ A ∧ f c ∧ g c ∧ (f ≡ g) (6)</formula><p>unsatisfiable. For simplicity, unless otherwise said we shall assume that f c and g c are tautologies in the sequel.</p><p>The key to solving Formula (5) is to effectively reduce the search space. By exploiting the functional properties specific to f and g (such as variable symmetry, unateness, and other functional properties), a preprocessing step is possible to screen out from ϕ C a substantial amount of infeasible solutions. Let formula Φ 0 characterize the remaining solutions of variables a and b after the preprocessing. We show below how the solution space corresponding to legal ν • π can be effectively refined in a sequence</p><formula xml:id="formula_8">Φ 0 , Φ 1 , . . . , Φ k , (Φ i+1 ⇒ Φ i )</formula><p>, along the solution search process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Boolean Matching with Dynamic Learning</head><p>We discuss two different Boolean matching goals: to search one matching solution and to search all matching solutions. Figure 1: Search one Boolean matching solution remaining matching solutions after the ith iteration. No solution to Φ i indicates that f and g cannot be matched; otherwise, a solution to Φ i corresponds to a candidate mapping ν•π. Further justification by the second SAT solving instance is needed to check whether this solution makes the miter formula Ψ unsatisfiable. If yes, the procedure terminates since ν • π is indeed a matching solution. Otherwise, the procedure learns from this (conflict) solution and strengthens Φ i to Φ i+1 accordingly. This action blocks not only this current solution of Φ i but also other infeasible solutions from occurrence in later search. (Ordinary learning blocks only the current conflict solution.) The procedure continues with Φ i+1 in the new iteration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Searching one matching solution</head><p>Below we show how to strengthen Φ i through learning.</p><p>Fact 1. Given two functions f ( x) and g( y) for Boolean matching under NP-equivalence, if</p><formula xml:id="formula_9">f ( u) = g( v) for u ∈ [[ x]] and v ∈ [[ y]], then any mapping ν • π with ν • π( u) = v is infeasible.</formula><p>Example 1. For two functions f (x 1 , x 2 , x 3 ) and g(y 1 , y 2 , y 3 ) with f (1, 0, 1) = g(0, 1, 1), then f and g cannot be matched under NP-equivalence by the six mappings with y = (¬x1, ¬x2, x3),</p><formula xml:id="formula_10">(¬x 1 , x 3 , ¬x 2 ), (x 2 , x 1 , x 3 ), (x 2 , x 3 , x 1 ), (¬x 3 , x 1 , ¬x 2 ), and (¬x 3 , ¬x 2 , x 1 ).</formula><p>Fact 1 can be rephrased in the language of formulas Φ i and Ψ as follows.</p><formula xml:id="formula_11">Proposition 1. Given two functions f ( x) and g( y) for Boolean matching under NP-equivalence, if f ( u) = g( v) for u ∈ [[ x]] and v ∈ [[ y]] with v = ν •π( u) for some ν •π satisfying Φ i , then conjuncting Φ i with the clause κ = n i,j=1 lij for literals lij = aij, if vi = uj; bij, otherwise, excludes from Φ i exactly the mappings {ν • π | ν • π ( u) = ν • π( u)}.</formula><p>In essence a satisfying solution to the miter formula Ψ with respect to a solution of Φ i reveals additional infeasible matching solutions. Letting Φ i+1 = Φ i ∧ κ prevents the above procedure from searching the learned infeasible solutions in later iterations. As a result, a single clause with n 2 literals is added in each iteration. </p><formula xml:id="formula_12">(a 11 ∨ b 12 ∨ a 13 ∨ b 21 ∨ a 22 ∨ b 23 ∨ b 31 ∨ a 32 ∨ b 33 ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>It excludes the previously listed six infeasible mappings.</head><p>The pruning power of a learned clause can be characterized as follows.</p><p>Proposition 2. For Boolean matching under NP-equivalence, the clause κ learned from a satisfying solution to f ( x) ≡ g( y) with y = ν •π( x) for some ν •π prunes n! infeasible mappings.</p><p>However the sets of mappings pruned by two different learned clauses may not be disjoint.</p><p>Since there are 2 2n distinct truth assignments to variables x and y, the number of different learned clauses is upper bounded by 2 2n . This fact also asserts the termination of the procedure. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Searching all matching solutions</head><p>When the Boolean matching objective is to find all matching solutions rather than just one, applying the procedure of <ref type="figure" target="#fig_0">Figure 1</ref> to find the solutions one by one can be overkill. <ref type="figure">Figure 2</ref> sketches a more effective procedure for this purpose. This procedure is the same as that of <ref type="figure" target="#fig_0">Figure 1</ref> except that there is only one SAT solving kernel for one combined formula Φ i ∧ Ψ.</p><p>Unlike the procedure of <ref type="figure" target="#fig_0">Figure 1</ref> (where, effectively, variables a and b have higher decision orders than the other variables in making truth assignments), the procedure of <ref type="figure">Figure 2</ref> imposes no restriction on the variable decision order. This freedom makes it much more effective. On the other hand, since this procedure terminates only when all infeasible solutions are pruned, sometimes its termination may take a long time. Nevertheless its number of SAT solving iterations has the same upper bound as that of <ref type="figure" target="#fig_0">Figure 1</ref> for a similar reason.</p><p>Proposition 4. The procedure of <ref type="figure">Figure 2</ref> for Boolean matching under NP-equivalence terminates within O(2 2n ) iterations.</p><p>Note that the computation of <ref type="figure">Figure 2</ref> can be understood as performing quantifier elimination of variables x and y of Formula (5). The resultant formula (in terms of variables a, b) characterizes all matching solutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Boolean Matching with Abstraction</head><p>We propose a new preprocessing method and introduce abstract Boolean matching. Definition 1. Given a Boolean function f ( x), a variable subset X * ⊆ X, and a variable z, the abstract function f * of f with respect to the (X * , z)-abstraction α is defined to be f * (</p><formula xml:id="formula_13">x * , z) = f (α(x1), . . . , α(xn)) for α(x i ) = x i , if x i ∈ X * ;</formula><p>z, otherwise.</p><p>Variables X * are referred to as the concrete variables, and z is the abstract variable.</p><p>Given two functions f ( x) and g( y), let f * be the abstract function of f with respect to the (X * , z)-abstraction α. The abstract Boolean matching determines if f * (</p><p>x * , z) and g( y) can be equivalent under the variable mapping</p><formula xml:id="formula_14">y = α • ν • π( x) for some ν • π. (The function α is phase-preserving, i.e., α(¬x i ) = ¬α(x i ).) To represent y = α • ν • π( x)</formula><p>, we define the 0-1 matrix:</p><formula xml:id="formula_15">     x * 1 ¬x * 1 · · · x * k ¬x * k z ¬z y 1 a 11 b 11 · · · a 1k b 1k a 1(k+1) b 1(k+1) y2 a21 b21 · · · a 2k b 2k a 2(k+1) b 2(k+1) . . . . . . . . . . . . . . . . . . . . . y n a n1 b n1 · · · a nk b nk a n(k+1) b n(k+1)     <label>(7)</label></formula><p>with k+1 j=1</p><p>(aij + bij) = 1 for i = 1, . . . , n, and</p><formula xml:id="formula_16">n i=1 (aij + bij) = 1 for j = 1, . . . , k.<label>(8)</label></formula><p>Furthermore, let aij = 1 and bij = 1 indicate (yi ≡ xj) and (yi ≡ ¬xj), respectively, for j = 1, . . . , k; let a i(k+1) = 1 and b i(k+1) = 1 indicate (y i ≡ z) and (y i ≡ ¬z), respectively. All of these constraints can be expressed with a Boolean formula and a solution to it corresponds to some legal ν • π with respect to the abstraction α. <ref type="bibr" target="#b1">2</ref> To solve the abstract Boolean matching, the procedures of Figures 1 and 2 can be applied with a similar learning mechanism. Again let Φ i be the formula characterizing the remaining matching solutions after the ith iteration.</p><formula xml:id="formula_18">Proposition 5. For abstract Boolean matching of f * ( x * , z) and g( y) under NP-equivalence, if f (α( u)) = g( v) for u ∈ [[ x]] and v ∈ [[ y]] with v = α • ν • π( u) for some α • ν • π satisfying Φ i , then conjuncting Φ i with the clause κ = n i=1 k+1 j=1 lij for literals lij = a ij , if v i = u * j , bij, otherwise, where u * ∈ [[( x * , z)]] for f * ( u * ) = f (α( u)), excludes from Φ i exactly the mappings {α • ν • π | α • ν • π ( u) = α • ν • π( u)}.</formula><p>So a learned clause is of size n(k + 1).</p><p>The abstract Boolean matching of f * and g is useful for two reasons. First, the computation is simplified (f * is simpler than f and the leaned clauses are shorter). Second, its solutions reveal useful information for the Boolean matching of f and g. <ref type="bibr" target="#b1">2</ref> Note that z and ¬z are allowed to map to multiple variables in Y since Eq. (9) imposes no cardinality constraint for j = k + 1. In contrast, one of x * i and ¬x * i maps to a unique variable in Y .</p><p>Proposition 6. If a mapping between the concrete variables X * and some Y ⊆ Y (with |X * | = |Y |) is shown infeasible in the abstract Boolean matching of f * and g, then in the original Boolean matching of f and g any mappings between X and Y having the same sub-mapping between X * and Y must be infeasible as well.</p><p>By conducting abstract Boolean matching for different sets of concrete variables, it can be applied as preprocessing to filter out infeasible matching solutions for the original Boolean matching problem.</p><p>For the preprocessing purpose, the procedure of <ref type="figure">Figure 2</ref> is more effective for abstract Boolean matching than that of <ref type="figure" target="#fig_0">Figure 1</ref>. In fact, the termination condition can be relaxed to quit at any iteration since the remaining matching solutions characterized by Φ i in the abstract Boolean matching will be a legitimate over-approximation of the matching solutions in the original Boolean matching.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">MATCHING FOR P-EQUIVALENCE</head><p>Since Boolean matching under P-equivalence is a special case of matching under NP-equivalence, the computation framework of NP-equivalence can be customized for P-equivalence.</p><p>To represent y = π( x), Matrix (2) for NP-equivalence is applicable by removing the columns indexed by ¬x 1 , . . . , ¬x n . Moreover, the cardinality constraints are the same as Eq. <ref type="formula">(3)</ref> and Eq. (4) but excluding the bij terms. They can be expressed by a CNF formula (new ϕC ) with n 2 variables and 2n(C n 2 + 1) = O(n 3 ) clauses. By asserting n i,j=1 (a ij ⇒ (y i ≡ x j )) (new ϕ A ), legal permutations can be characterized using a Boolean formula. Thus Boolean matching under P-equivalence can be formulated as solving the QBF (5) with the updated ϕC and ϕA.</p><p>Similar to the NP-equivalence case, the procedures of Figures 1 and 2 are applicable here. As a matter of fact, leaning for P-equivalence can be made more efficient. Let Φ i characterize the remaining matching solutions at the ith iteration.</p><p>Proposition 7. Given two functions f ( x) and g( y) for Boolean matching under P-equivalence, if f ( u) = g( v) for u ∈ <ref type="bibr">[[ x]</ref>] and v ∈ <ref type="bibr">[[ y]</ref>] with v = π( u) for some π satisfying Φ i , then conjuncting Φ i with the clause κ = n i,j=1 lij for literals</p><formula xml:id="formula_19">l ij = a ij , if v i = 0 and u j = 1; ∅, otherwise,</formula><p>excludes from Φ i exactly the mappings {π | π ( u) = π( u)}.</p><p>Note that the above condition "if v i = 0 and u j = 1" can be equivalently replaced with "if v i = 1 and u j = 0." Clearly for u ∈ <ref type="bibr">[[ x]</ref>] with m u i 's equal to 1, then the corresponding learned clause is of m(n − m) literals.</p><p>Example 3. The learned clause corresponding to f (1, 0, 1) = g(0, 1, 1) can be (a11 ∨ a13) or, equivalently, (a22 ∨ a32).</p><p>The pruning power of a learned clause can be characterized as follows.</p><p>Proposition 8. For Boolean matching under P-equivalence, the clause κ learned from a satisfying solution u ∈ <ref type="bibr">[[ x]</ref>] to f ( u) ≡ g(π( u)) for some π prunes m!(n − m)! infeasible permutations, where m is the number of 1's in u.</p><p>Observe that the larger the difference between the numbers of 1's and 0's in u is, the stronger the pruning power of the learned clause is. Hence it may be beneficial to search satisfying solutions in such biased truth assignments.</p><p>For every u ∈ <ref type="bibr">[[ x]</ref>] with k 1's, there are C n k possible v ∈ <ref type="bibr">[[ y]</ref>] having the same number of 1's. Hence the number of possible learned clauses and thus learning iterations is upper bounded</p><formula xml:id="formula_20">by 1 2 ((C n 0 ) 2 + (C n 1 ) 2 + · · · + (C n n ) 2 ) = 2 2n ·(n− 1 2 )! 2 √ πn! ≤ 2 2n 2 √ π .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 9. The Boolean matching procedures of Figures 1 and 2 for P-equivalence both terminate within O(2 2n ) iterations.</head><p>Preprocessing with abstraction can be pursued in Boolean matching under P-equivalence similar to that for NP-equivalence. We omit the exposition to save space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EXPERIMENTAL RESULTS</head><p>BooM was programmed in C language within the ABC <ref type="bibr" target="#b5">[6]</ref> package using MiniSAT <ref type="bibr" target="#b9">[10]</ref> as the underlying solver. All experiments were conducted on a Linux machine with Xeon 2.5GHz CPU and 26GB RAM.</p><p>Circuits from the MCNC, ISCAS89 and ITC99 benchmark suites were chosen. Sequential circuits were converted to combinational ones by the ABC command comb. To test the full power of BooM, we make the computation harder by matching each primary output of a circuit independently. 3 A function is matched against its synthesized version with its inputs permuted in a reverse/random order (for P-equivalence checking), and in addition negated randomly (for NP-equivalence checking). Functions with support sizes between 10 and 39 were experimented. Specifically there are 717 functions with an average of 114.74 AIG nodes (ranging from 15 to 2160 nodes) and 23.74 variables.</p><p>The baseline preprocessing of BooM to reduce the search space consists of detecting functional properties of NE-symmetry and unateness, and simulating Type 1 and Type 2 vectors of <ref type="bibr" target="#b18">[19]</ref>. For two symmetry groups that can be uniquely mapped between the two functions to be matched, BooM breaks the symmetry by assigning an arbitrary variable mapping. <ref type="figure" target="#fig_2">Figure 3</ref>: Runtime with and without learning <ref type="figure" target="#fig_2">Figure 3</ref> shows the effect of learning (as an example, in the context of searching all matching solutions under P-equivalence). The x-and y-axes correspond to the runtimes with and without learning, respectively. A spot in the figure corresponds to the result of a function. As most of the spots are above the 45-degree line, learning is evidentally useful. <ref type="figure">Figure 4</ref> shows the effect of abstraction (in the same context as <ref type="figure" target="#fig_2">Figure 3</ref> with learning applied). The abstraction <ref type="bibr" target="#b2">3</ref> When multiple outputs are considered simultaneously, e.g., in <ref type="bibr" target="#b18">[19]</ref>, many more mutual signatures can be deduced to reduce the search space substantially. <ref type="figure">Figure 4</ref>: Runtime with and without abstraction is conducted for enumerating half of all possible abstract matchings with two concrete variables. Only functions with non-empty clauses learned from abstraction are plotted. As can be seen, abstraction achieves clear improvement. Many instances timed out after 600 seconds without abstraction can be effectively resolved with abstraction. Nevertheless, there are a few cases where abstraction does not help.</p><formula xml:id="formula_21">¡ £ ¤ ¥ ¦ § ¢ ¨ © ¢ ¢ ! " # # $ ( ( ¡ £ ¤ ¥ ¦ % &amp; ' ) 0 1 2 3 4 2 5 6 7 8 9 0 ) @ A 2 B C ' 0 ' D E # §</formula><formula xml:id="formula_22">¡ £ ¤ ¥ ¦ § ¢ ¨ © ¢ ! © " # ' ' ¡ £ ¤ ¥ ¦ $ % &amp; ( ) 0 1 2 3 1 4 5 6 7 8 ) ( 9 @ A 3 ( B @ 4 ( ) C &amp; D # §</formula><formula xml:id="formula_23">$ £ £ ¥ ¤ ¤ ¥ ¥ ¥ ¥ % &amp; ' ( ) 0 1 2 ( 3</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 5: Cumulative runtime for P-equivalence</head><p>Figures 5 and 6 show the cumulative runtime for matching under P-equivalence and NP-equivalence, respectively. In these figures, the x-and y-axes are indexed by the cumulative number of solved instances and cumulative runtime, respectively. In the legends, "one sol" and "all sol" indicate the targets of searching one matching solution (Section 3.1.1) and searching all matching solutions (Section 3.1.2), respectively; "learn" indicates learning being applied; "abs" indicates preprocessing using abstraction being turned on. The solved instances under each of these six options were sorted by their runtimes in an ascending order before the accumulation. (Among the solved functions in searching one matching solution using both learning and abstraction, the maximum input sizes are 39 and 38 for matching under P-equivalence and NP-equivalence, respectively.) These two figures reveal, as expected, that matching under NP-equivalence is much harder than that under P-equivalence. Moreover, the performance of searching all matching solutions is comparable to that of searching one solution in the P-equivalence case, but far worse in the NP-equivalence case. One explanation might be that, since the configuration space for NP-equivalence is <ref type="figure">Figure 6</ref>: Cumulative runtime for NP-equivalence much larger, searching all matching solutions requires many more refinement iterations and thus becomes less effective. In all the above experiments, a matching instance consists of a pair of functions, whose variables are in reverse order. To see the effect of variable ordering, we alternatively prepared matching instances with random order. For searching all matching solutions under P-equivalence, 531 out of the 717 functions can be solved within 600 seconds under both orders, and the corresponding total-runtime ratio of reverse order to random order is 1.00 to 1.06. Since there seems no strong bias when using these two orders, the results under reverse ordering may be more or less representative.</p><formula xml:id="formula_24">¢ ¥ $ ¥ ¥ ¥ ¥ $ ¥ % &amp; ' ( ) 0 1 2 ( 3</formula><p>Experience of matching incompletely-specified functions (data not shown due to space limitation) suggested that it takes longer time to solve than matching completely-specified counterparts. The reason can be twofold: First, more assignments on average are tried before the miter constraint is satisfied. Second, the miter constraint becomes more complex in representing the care conditions. Hence the runtime per learning iteration is larger. Nevertheless matching incompletely-specified functions is indeed feasible under the BooM framework.  <ref type="figure" target="#fig_3">Figure 7</ref> compares BooM and DepQBF <ref type="bibr" target="#b8">[9]</ref>, a state-of-theart QBF solver, in searching one matching solution under Pequivalence. The x-and y-axes correspond to the runtimes of BooM and DepQBF, respectively, after the same preprocessing. As can be seen, BooM outperforms DepQBF due to its unique and powerful domain-specific learning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSIONS AND FUTURE WORK</head><p>We have formulated Boolean matching as QBF solving and exploited domain-specific knowledge for effective search space reduction. A decision procedure BooM, equipped with abstraction and dynamic learning, has been proposed as a generic computation framework for Boolean matching under NPN-equivalence for both completely and incompletely specified functions. Experiments showed promising results. As various Boolean matching techniques can be built and integrated on top of BooM, we anticipate Boolean matching can be made scalable and practical in more applications. Moreover, the success of BooM may suggest that it worths to customize decision procedures for other computation problems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 sketches</head><label>1</label><figDesc>Figure 1 sketches the procedure for finding one solution. It takes on two input functions f and g, possibly with their care-conditions fc and gc. A preprocessing step is first conducted to strengthen ϕC yielding Φ 0 . It fast prunes infeasible matching solutions based on functional properties and an abstraction technique, to be explained in Section 3.2. After preprocessing, an iterative procedure is conducted between two interacting SAT solving instances to refine the solution space. The first SAT solving instance solves Φ i , i.e., the</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>1 1Figure 2 :</head><label>12</label><figDesc>Figure 2: Search all Boolean matching solutions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Proposition 3 .</head><label>3</label><figDesc>The Boolean matching procedure of Fig- ure 1 for NP-equivalence terminates within O(2 2n ) iterations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Comparison between BooM and DepQBF</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The authors are grateful to Bo-Han Wu for helpful discussion, and National Science Council for grants 96-2221-E-002-278-MY3 and 98-2221-E-030-016.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Signature based Boolean matching in the presence of don&apos;t cares</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Abdollahi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="642" to="647" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A trasnform-parametric approch to Boolean matching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Agosta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Bruschi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Pelosi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Sciuto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Design Integr. Circuits Syst</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="805" to="817" />
			<date type="published" when="2009-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Symmetry detection and Boolean matching utilizing a signature-based canonical form of Boolean functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Abdollahi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pedram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Design Integr. Circuits Syst</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1128" to="1137" />
			<date type="published" when="2008-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The Boolean isomorphism problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Thierauf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. on Foundations of Computer Science</title>
		<meeting>IEEE Symp. on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="422" to="430" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A survey of Boolean matching techniques for library binding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Benini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>De Micheli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Design Automation of Electronic Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="193" to="226" />
			<date type="published" when="1997-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">ABC: A system for sequential synthesis and verification</title>
		<ptr target="http://www.eecs.berkeley.edu/∼alanmi/abc/" />
		<imprint/>
		<respStmt>
			<orgName>Berkeley Logic Synthesis and Verification Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">On the computational complexity of some classical equivalence relations on Boolean functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Borchert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ranjan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Stephan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Forschungsberichte Mathematische Logik</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<date type="published" when="1995-12" />
		</imprint>
		<respStmt>
			<orgName>Universität Heidelberg, Bericht Nr</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Boolean matching for LUT-based logic blocks with applications to architecture evaluation and technology mapping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-Y</forename><surname>Hwang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Design Integr. Circuits Syst</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1077" to="1090" />
			<date type="published" when="2001-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Depqbf</surname></persName>
		</author>
		<ptr target="http://fmv.jku.at/depqbf/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An extensible SAT-solver</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Eén</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Sörensson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SAT</title>
		<meeting>SAT</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="502" to="518" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">DeltaSyn: An efficient logic-difference optimizer for ECO synthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Krishnaswamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Modi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Puri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCAD</title>
		<meeting>ICCAD</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Limits of using signatures for permutation independent Boolean comparison</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mohnke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Molitor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ASP-DAC</title>
		<meeting>ASP-DAC</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="459" to="464" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Application of BDDs in Boolean matching techniques for formal logic combinational verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mohnke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Molitor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal on Software Tools for Technology Transfer</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="10" />
			<date type="published" when="2001-05" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Chaff: Engineering an efficient SAT solver</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Moskewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Madigan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="530" to="535" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">GRASP: A search algorithm for propositional satisfiability</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Marques-Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sakallah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="506" to="521" />
			<date type="published" when="1999-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On the complexity of derivation in propositional calculus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Tseitin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Studies in Constructive Mathematics and Mathematical Logic</title>
		<imprint>
			<date type="published" when="1970" />
			<biblScope unit="page" from="466" to="483" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Incremental learning approach and SAT model for Boolean matching with don&apos;t cares</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-M</forename><surname>Chan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCAD</title>
		<meeting>ICCAD</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="234" to="239" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Fast Boolean matching with don&apos;t cares</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Chai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kuehlmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">R</forename><surname>Newton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Symp. on Quality Electronic Design</title>
		<meeting>Int. Symp. on Quality Electronic Design</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="346" to="351" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Simulation and SAT-based Boolean matching for large Boolean networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-M</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-C</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="396" to="401" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
