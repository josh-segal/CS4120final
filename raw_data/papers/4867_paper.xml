<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T17:04+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Towards Completely Automatic Decoder Synthesis</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hsiou-Yuan</forename><surname>Liu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yen-Cheng</forename><surname>Chou</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen-Hsuan</forename><surname>Lin</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Graduate Institute of Electronics Engineering National Taiwan University</orgName>
								<address>
									<postCode>10617</postCode>
									<settlement>Taipei</settlement>
									<country key="TW">Taiwan</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jie-Hong</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
							<email>jhjiang@cc.ee.ntu.edu.tw</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">Graduate Institute of Electronics Engineering National Taiwan University</orgName>
								<address>
									<postCode>10617</postCode>
									<settlement>Taipei</settlement>
									<country key="TW">Taiwan</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Towards Completely Automatic Decoder Synthesis</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>B63 [Logic Design]: Design Aids-automatic synthesis General Terms algorithms</term>
					<term>logic synthesis</term>
					<term>verification Keywords Craig interpolation</term>
					<term>decoder</term>
					<term>finite state transition system</term>
					<term>SAT solving</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Upon receiving the output sequence streaming from a sequential encoder, a decoder reconstructs the corresponding input sequence that streamed to the encoder. Such an encoding and decoding scheme is commonly encountered in communication , cryptography, signal processing, and other applications. Given an encoder specification, decoder design can be error-prone and time consuming. Its automation may help designers improve productivity and justify encoder correct-ness. Though recent advances showed promising progress, there is still no complete method that decides whether a de-coder exists for a finite state transition system. The quest for completely automatic decoder synthesis remains. This paper presents a complete and practical approach to automating decoder synthesis via incremental SAT solving and Craig interpolation. Experiments show that, for decoder-existent cases, our method synthesizes decoders effectively; for decoder-nonexistent cases, our method concludes the non-existence instantly while prior methods may fail.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Encoding and decoding processes are the cornerstone of information processing in digital communication, cryptography, digital signal processing, fault tolerant computing, and various other applications. Depending on the application, the characteristic of an encoding/decoding scheme varies. Coding systems can be designed so as to, for example, detect or correct errors in reliable communication <ref type="bibr" target="#b9">[11]</ref>, to make messages unintelligible in cryptography <ref type="bibr" target="#b14">[16]</ref>, to compress information in data processing and storage <ref type="bibr" target="#b10">[12]</ref>, to be resilient to soft errors in chip design <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b11">13]</ref>, and so on. Despite the diversity, encoding/decoding systems can often be modelled as finite state machines 1 , e.g., convolutional codes in error correction, line codes in Ethernet and RFID, stream ciphers in symmetric encryption, etc. This paper considers the following encoding/decoding scheme. The encoder receives an input sequence and produces an output sequence; the decoder re-derives the input sequence by length-bounded partial observation of the output sequence.</p><p>As a decoder is usually harder to design than its corresponding encoder due to the fact that additional features (such as error correction) may need to be imposed, decoder design can be error prone and time consuming. Automating the process of decoder design may substantially reduce design cycle and improve circuit designers' productivity. Even if an automatically synthesized decoder would not match the same quality as a manual design, it could still be useful to justify whether the encoder is properly specified and to check if the manually crafted decoder is functionally correct. These reasons strongly motivate the study of automatic decoder synthesis.</p><p>Recently Shen et al. <ref type="bibr" target="#b12">[14,</ref><ref type="bibr" target="#b13">15</ref>] studied the decoder synthesis problem. A bounded decoder existence checking method was proposed <ref type="bibr" target="#b12">[14]</ref>, where the checking is with respect to a prespecified parameter on observable output windows. If a decoder exists, an ALLSAT-based procedure is invoked to compute and simplify the corresponding decoding functions. The necessity of pre-specifying the checking bound prevents decoder synthesis from being a fully automatic process. A later attempt <ref type="bibr" target="#b13">[15]</ref> got one step closer to unbounded decoder existence checking. Despite its soundness, the proposed checking is unfortunately incomplete. Essentially there are cases that the checking never halts, in particular, when a decoder does not exist. <ref type="figure" target="#fig_0">Figure 1</ref> shows one such example, where a decoder does not exist, but the checking fails to decide. <ref type="bibr" target="#b1">2</ref> Nevertheless, the approach works well on practical design instances. This paper continues the quest for a sound and complete approach to automatic decoder synthesis. The main advances include the following results: Firstly, a necessary and sufficient condition for decoder existence is identified. Secondly, a complete decoder existence checking procedure is proposed with guaranteed termination within O(N 2 ) iterations, where N is the number of states of a state transition system. Thirdly, an interpolation-based decoder synthesis approach is proposed, which eliminates the need for ALL-SAT in enumerating all satisfying assignments and makes a decoder derivable along the existence checking. (Shen et al.</p><p>[14] suggested as future work using interpolation-based relation determinization <ref type="bibr" target="#b5">[7]</ref> for decoder generation. Our interpolation formulation for decoder synthesis can be more direct and simpler than the prior method <ref type="bibr" target="#b5">[7]</ref>.) Finally, two techniques, CNF encoding of disjunctive constraints and incremental time-frame expansion with reused looping constraints, are proposed to enhance the efficiency of incremental SAT solving. Experiments show that our algorithm successfully decides decoder existence, while the prior method may fail, and effectively synthesizes decoders if they do exist. This paper is organized as follows. Section 2 gives the preliminaries. Our main results on decoder existence checking and synthesis are presented in Section 3. Implementation issues are discussed in Section 4. The proposed methods are evaluated with experimental results in Section 5. Finally Section 6 concludes this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARIES</head><p>As conventional notation, the cardinality of a vector x = (x 1 , . . . , x k ) is denoted as | x| = k. For x being a vector of Boolean variables, its set of truth valuations is denoted <ref type="bibr">[[ x]</ref>], e.g., <ref type="bibr">[</ref>[(x 1 , x 2 )]] = {(0, 0), (0, 1), (1, 0), (1, 1)}.</p><p>Let V = {v1, . . . , v k } be a finite set of Boolean variables. A literal l is either a Boolean variable vi or its negation ¬vi. A clause C is a disjunction of literals. A conjunction of clauses is in the so-called conjunctive normal form (CNF). In the sequel, a clause set S = {C1, . . . , C k } shall mean to be the CNF formula C1 ∧ · · · ∧ C k . An assignment over V gives every variable v i a Boolean value either 0 or 1. A CNF formula is satisfiable if there exists a satisfying assignment such that the formula evaluates to 1. Otherwise it is unsatisfiable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">SAT Solving and Craig Interpolation</head><p>We assume the reader's familiarity with satisfiability (SAT) solving, Craig interpolation, and circuit-to-CNF conversion. We omit essential backgrounds and refer the reader to <ref type="bibr" target="#b6">[8]</ref>.</p><p>To introduce terminology and convention for later use, we restate the following theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1 (Craig Interpolation Theorem). [4]</head><p>For two Boolean formulas φA and φB, with φA ∧ φB unsatisfiable, there exists a Boolean formula ψ A referring only to the common variables of φ A and φ B such that φ A implies ψ A and ψ A ∧ φ B remains unsatisfiable.</p><p>The Boolean formula ψ A is referred to as the interpolant of φ A with respect to φ B . We shall assume that φ A and φ B are in CNF. So a refutation proof of φ A ∧ φ B is available from a SAT solver. Further, an interpolant circuit ψA can be constructed from the refutation proof in linear time <ref type="bibr" target="#b7">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">State Transition Systems</head><p>We model a synchronous sequential circuit as a (finite state) transition system in terms of two characteristic functions I( s), representing the initial states, and T ( x, s, y, s ), representing the transition relation, where s, s , x, and y are referred to as the current-state variables, next-state variables, input variables, and output variables, respectively. In the sequel, we shall specify a transition system with its transition relation only when its initial states are immaterial. Moreover, as we are concerned about deterministic systems, we sometimes abuse the relation notation to mean the transition function T : <ref type="bibr">[[ x</ref></p><formula xml:id="formula_0">]] × [[ s]] → [[ y]] × [[ s ]].</formula><p>For a state transition system T , we distinguish three types of states: First, a dangling state is a state without predecessors or, recursively, a state with only dangling predecessors. (For a state pair (</p><formula xml:id="formula_1">q ∈ [[ s]], q ∈ [[ s ]]) satisfying ∃ x, ∃ y.</formula><p>T ( x, q, y, q ), we call q the predecessor of q .) Second, a recurrent states is a state that can reach itself within a finite number of transition steps. (So a recurrent state must be non-dangling.) Third, a transient state is a non-dangling state not in any loop. (Therefore these three types form a partition on the state space of T .)</p><p>For decoder synthesis to be discussed, we apply timeframe expansion on a transition system T ( x, s, y, s ), similar to bounded model checking <ref type="bibr" target="#b1">[2]</ref>. In the sequel, the variable vector v instantiated at time-frame t shall be denoted as v t . With a slight extension, the transition relation unrolled at time t shall be denoted as T t to mean T ( x t , s t , y t , s t+1 ), where t can be positive or negative with respect to a reference time point at t = 0. Similarly, we let T * denote the transition relation the same as T except that variables x, s, y, and s of T are substituted with fresh new variables</p><formula xml:id="formula_2">x * , s * ,</formula><p>y * , and s * , respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Problem Statement</head><p>Given an encoder in the form of a state transition system T , which transforms an input sequence to an output sequence according to the transition relation, the decoder to-be-synthesized aims to reproduce the input sequence by observing the output sequence.</p><p>For a decoder to be realizable, we shall base assumptions on the following facts. Firstly, since the lengths of input and output sequences can be unbounded, decoding must be done online (processing data piece-by-piece serially) rather than offline (processing entire data at once). Secondly, since the decoder should have only finite memory, the input value at a time point should be decided upon observing only a finite portion of the output sequence. Thirdly, in general the input sequence cannot be recovered since the very first input value because, to determine the input value at time t, some output values before t need to be known. Therefore a certain delay may be necessary before an input value can be uniquely determined. In certain applications (such as communicating and reactive systems) losing first few input values is immaterial. A decoder may or may not recover a certain prefix of an input sequence depending on whether or not past output values are needed.</p><p>For decoder synthesis, only the reachable non-dangling states of a transition system T are of our interests. Given an exact or over-approximated care-state set S C , it can be exploited to accelerate decoder existence checking and improve decoder synthesis. (The care-state set SC can be generated by exact or approximated reachability analysis. For example, the latter approach was taken in <ref type="bibr" target="#b12">[14]</ref> by time-frame expansion for dangling-state removal.) In the sequel, we shall simply assume that a care-state set SC is given. Moreover, we shall not distinguish a characteristic function and the set that it represents. (When care states are not known, we treat all states as care states, thus having characteristic function SC ( s) = 1.) Similar to the conventions T t and</p><formula xml:id="formula_3">T * of T , we let S t C mean SC ( s t ) and S * C mean SC ( s * ).</formula><p>Another source of don't cares comes from inputs. Often we are only interested in decoding a design under its certain operation modes. This paper assumes a transition system has been constrained to its proper operation modes from its original design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">MAIN ALGORITHMS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Decoder Existence</head><p>The necessary and sufficient condition for decoder existence with respect to a pre-specified observation constraint can be stated as follows.</p><p>Theorem 2 (see also <ref type="bibr" target="#b12">[14]</ref>). Given a transition system T ( x, s, y, s ), suppose that to determine is the input</p><formula xml:id="formula_4">i 0 ∈ [[ x 0 ]] at some relative reference time point of t = 0 by observing the outputs o t ∈ [[ y t ]] at time t = −n, . . . , p for n, p ≥ 0. Input i 0 can be uniquely determined from o −n , . .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. , o p if and only if the formula</head><formula xml:id="formula_5">p t=−n T t ∧ T * t ∧ ( y t = y * t ) ∧ ( x 0 = x * 0 ) ∧ p+1 t=−n S t C ∧ S * C t ,<label>(1)</label></formula><p>is unsatisfiable, where predicate "=" asserts the bit-wise equivalence of its two argument variable vectors and " =" asserts the negation.</p><p>Intuitively, the input sequence of a state transition system can be reverse engineered if the input at some time point can be uniquely determined from its proximate output string. In essence, the parameter (n, p) defines an observation window on the output sequence for decoder synthesis. By sliding the window along an output sequence, the original input sequence can be recovered. (When n is non-zero, the first n values of an input sequence cannot be determined. Hence in decoder synthesis it is desirable for n to be small.) For simplicity, unless otherwise said we shall assume that SC ( s) = 1 in the sequel. Formula (1) can be visualized as the circuit construction shown in <ref type="figure" target="#fig_1">Figure 2</ref>(a), where T is meant to be the transition function instead of relation. In the sequel, we call it the (n, p)-miter, denoted M (n, p), of transition system T from the −n th to p th time-frame. Hence M (n, p) equally denotes Formula (1).</p><p>Notice that Formula (1) tests decoder existence only with respect to a pre-specified n, p parameter. Its satisfiability yields no conclusive answer whether the decoder does not exist at all or the decoder exists at some larger n, p. When there is no decoder at all, the test for even larger n, p may continue forever. A terminate condition must be imposed to prevent infinite trials.</p><p>The following lemma asserts the necessary and sufficient condition for decoder existence. </p><formula xml:id="formula_6">M (n, p) ∧ L ± n,p ∨ (L − n ∧ L + p ) ,<label>(2)</label></formula><p>where</p><formula xml:id="formula_7">L ± n,p = 0 i=−n p+1 j=1 ( s i = s j ) ∧ ( s * i = s * j ) ,<label>(3)</label></formula><formula xml:id="formula_8">L − n = −1 i=−n 0 j=i+1 ( s i = s j ) ∧ ( s * i = s * j )</formula><p>, and (4)</p><formula xml:id="formula_9">L + p = p i=1 p+1 j=i+1 ( s i = s j ) ∧ ( s * i = s * j ) ,<label>(5)</label></formula><p>is satisfiable under some n, p. (L − n and L + p are defined to be false for n = 0 and p = 0, respectively.)</p><p>Proof. Consider T ∧ T * as the product transition system of T and T * . It induces state transitions in the product state space <ref type="bibr">[[ s]</ref></p><formula xml:id="formula_10">] × [[ s * ]]. (⇐) The satisfiability of Formula (2) under some n, p in- dicates M (n, p) ∧ L ± n,p or M (n, p) ∧ L − n ∧ L + p is satisfiable. Let ( q 0 ,</formula><p>q * 0 ) be a satisfying state at time t = 0. The former suggests ( q 0 , q * 0 ) is in a loop of the product transition system T ∧ T * . As a consequence, a satisfying output sequence o −n = o * −n , . . . , o p = o * p can be infinitely extended in both positive and negative directions. By Lemma 1, the decoder does not exist. The latter suggests that ( q 0 , q * 0 ) is a state that can be reached by a loop satisfying L − n and can reach another loop satisfying L + p . Because of these two loops, a satisfying output sequence can be infinitely extended in both positive and negative directions, and thus the decoder does not exist as well.</p><p>(⇒) Consider the contrapositive. Suppose there is no n, p that make Formula (2) satisfiable. It implies that any ( q 0 , q * 0 ) satisfying M (n, p) is neither in some loop, nor between two loops. Moreover, because T ∧ T * is a finite state transition system, any output sequence satisfying M (n, p) cannot be infinitely extended to both positive and negative directions. By Lemma 1, a decoder must exist. Note that the looping constraint L ± n,p of Formula <ref type="formula" target="#formula_6">(2)</ref> is not essential. If M (n, p) ∧ L ± n,p is satisfiable, then there must exist some n ≥ n and</p><formula xml:id="formula_11">T 0 T -1 T 1 T p T -n 񮽙 񮽙 = ≠ = = = = T* 0 T* -1 T* 1 T* p T* -n 񮽙 񮽙 = = = = = = = L − L + = = = = = = = L ± (a) (b)</formula><formula xml:id="formula_12">p ≥ p making M (n , p ) ∧ L − n ∧ L + p</formula><p>satisfiable. This constraint however can be useful in shortening the witnessed counterexample to decoder existence. On the contrary,</p><formula xml:id="formula_13">L − n ∧ L + p is irreplaceable by L ± n ,p for some n , p because the state ( q 0 , q * 0 ) ∈ [[ s 0 ]] × [[ s * 0 ]] satisfying M (n, p) ∧ L − n ∧ L + p</formula><p>can be a transient state between two loops rather than in a loop.</p><p>By Theorems 2 and 3, the existence of a decoder for a given transition system T can be checked with the algorithmic flow in <ref type="figure" target="#fig_3">Figure 3</ref>. Among the three SAT solving instances of the procedure, the first and second follow from Theorems 2 and 3, respectively. The third, on the other hand, is optional. That is, if the second formula</p><formula xml:id="formula_14">M (n, p) ∧ (L ± n,p ∨ (L − n ∧ L + p )</formula><p>) is unsatisfiable, then both n and p can directly be incremented by 1 to start a new iteration. Solving the third formula M (n, p) ∧ (L − n ∨ L + p ), however, may result in better termination condition with smaller n and p as the following proposition suggests.</p><formula xml:id="formula_15">Proposition 1. Assume that M (n, p) is satisfiable but not M (n, p) ∧ (L ± n,p ∨ (L − n ∧ L + p )). If M (n, p) ∧ L − n (respectively M (n, p)∧L + p )</formula><p>is satisfiable, then incrementing p (respectively n) only achieves the tightest increase on current (n, p) without missing any termination condition.</p><formula xml:id="formula_16">Proof. Consider first the formula M (n, p) ∧ L − n . For M (n, p) satisfiable but not M (n, p)∧(L ± n,p ∨(L − n ∧L + p ))</formula><p>, then a satisfying solution to it must correspond to a valid loop in the negative time-frames while there is no valid loop in the positive time-frames. Since the truth assignments in this loop can be arbitrary extended to the negative direction, the current satisfying assignment of M (n, p) ∧ L − n must remain valid for M (n + 1, p) ∧ L − n+1 . Moreover, for this assignment, no new loop can be created in the positive time-frames satisfying M (n+1, p)∧L + p because M (n+1, p)∧L + p ⇒ M (n, p)∧L + p . Therefore incrementing n can neither exclude the current satisfying solution, nor make this assignment a counterexample. On the other hand, even if incrementing n results in satisfiable M (n + 1, p) ∧ L ± n+1,p , the same loop can be created M (n, p+1)∧L ± n,p+1 . Consequently, we only need to increment p. Similarly, for M (n, p) ∧ L + p , we only need to increment n.</p><p>The procedure of <ref type="figure" target="#fig_3">Figure 3</ref> always terminates as the following theorem asserts. Proof. When no decoder exists, a counterexample must be in the form of either a loop or two connected (statedisjoint) loops in the product space of T ∧ T * . In either case, the transition span of a counterexample is upper bounded by |S C | 2 . Hence n + p ≤ |S C | 2 .</p><p>When a decoder exists, the unsatisfiability of M (n, p) can always be established whenever the transition span of the longest loop and the transition span of the longest connected two loops have been reached, which are both upper bounded by |S C | 2 . Hence n + p ≤ |S C | 2 .</p><p>(When SC ( s) = 1, of course n + p ≤ 2 | s| .) Corollary 1. The procedure of <ref type="figure" target="#fig_3">Figure 3</ref> always terminates with a correct answer.</p><p>Upon termination, however, the corresponding (n, p) may not be minimal because in a solving iteration, when the first SAT instance is satisfiable but not the second and third, the increment of both n and p is not tight. Essentially in this case we do not know whether incrementing p only or n only leads to a better solution.</p><p>In the decoder existence checking, both n and p start from 0 and increase by 1 until either a decoder is found or its existence is falsified. This increment permits simplification to the looping constraints of Formulas (3), (4), and (5). Consider the simplification of Formula (3). Observe that n and p are simultaneously incremented only because of the unsatisfiability of</p><formula xml:id="formula_17">M (n, p)∧(L − n ∨L + p ). Moreover, M (n+1, p+1) ⇒ M (n, p), L − n ⇒ L − n+1 , and L + p ⇒ L + p+1</formula><p>. Therefore the satisfiability of can thus be simplified to Formula (6) below. Similarly, we have Formulas <ref type="formula">(7)</ref> and <ref type="formula" target="#formula_21">(8)</ref>.</p><formula xml:id="formula_18">M (n + 1, p + 1) ∧ (L − n+1 ∨ L + p+1 ) can</formula><formula xml:id="formula_19">L ± n,p = p+1 j=1 ( s −n = s j ) ∧ ( s * −n = s * j ) ∨ 0 j=−n ( s p+1 = s j ) ∧ ( s * p+1 = s * j ) ,<label>(6)</label></formula><formula xml:id="formula_20">L − n = 0 j=−n+1 ( s −n = s j ) ∧ ( s * −n = s * j )</formula><p>, and (7)</p><formula xml:id="formula_21">L + p = p j=1 ( s p+1 = s j ) ∧ ( s * p+1 = s * j ) .<label>(8)</label></formula><p>As a result, the original quadratic numbers of equality constraints are reduced to linear. The looping constraints of Formula (2) are shown in <ref type="figure" target="#fig_1">Figure 2</ref>(b) in connection to the miter constraint M (n, p) shown in <ref type="figure" target="#fig_1">Figure 2</ref>(a). The equality signs in this figure signify the equality constraints imposed on the state variables among the time-frames of M (n, p).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Decoder Synthesis</head><p>When a decoder exists, we proceed synthesizing it under the (n, p) observation window returned by the above decoder existence checking procedure. The decoder can be synthesized for all bits x 0 at once or for every bit x 0 i ∈ x 0 one at a time. For the sake of optimality, we adopt the latter strategy. By synthesizing the decoding function f i for each bit x 0 i ∈ x 0 , the actual necessary window, specified by (ni, pi) for some 0 ≤ pi ≤ p and −pi ≤ ni ≤ n, can be substantially DecoderSynthesis input: transition system T , care states S C , parameter (n, p) output: decoding functions begin 01 for i = 1, . . . , | x| 02 search minimal n i and p i for M i (n, p, n i , p i ) unsat 03 derive f i by interpolation on φ iA ∧ φ iB 04 return (f 1 , . . . , f | x| ) end reduced. Specifically, the formula</p><formula xml:id="formula_22">p t=−n T t ∧ T * t ∧ p+1 t=−n S t C ∧ S * C t ∧ p i t=−n i y t = y * t ∧(x 0 i = x * i 0 ). (9) denoted M i (n, p, n i , p i ), must remain unsatisfiable as M (n, p).</formula><p>So the corresponding decoding function f i to be derived by interpolation from the refutation proof of Mi(n, p, ni, pi) may have fewer support variables and a simpler circuit structure.</p><p>The validity of synthesizing one decoding function at a time stems from the following fact, provable by M (n,</p><formula xml:id="formula_23">p) = | x| i=1 M i (n, p, n, p). Proposition 2.</formula><p>For a state transition system T ( x, s, y, s ), M (n, p) is unsatisfiable if and only if M i (n, p, n, p) is unsatisfiable for every i = 1, . . . , | x|.</p><p>For unsatisfiable Mi(n, p, ni, pi), Craig interpolation (Theorem 1) can be exploited to derive the decoding function fi of x 0 i as Theorem 5 suggests. (A similar construction using Craig interpolation has been proposed in <ref type="bibr" target="#b6">[8]</ref> for logic synthesis application.)</p><p>Theorem 5. For a transition system T ( x, s, y, s ) with unsatisfiable Mi(n, p, ni, pi), let formulas φi A and φi B be φi A :</p><formula xml:id="formula_24">p t=−n T t ∧ p+1 t=−n S t C ∧ x 0 i , and<label>(10)</label></formula><p>φi B :</p><formula xml:id="formula_25">p t=−n T * t ∧ p+1 t=−n S * C t ∧ p i t=−n i y t = y * t ∧ ¬x * i 0 . (11)</formula><p>Then the interpolant ψ i A of φ i A with respect to φ i B is a valid decoding function for x 0 i ∈ x 0 . Proof. Observe first that M i (n, p, n i , p i ) and φ i A ∧ φ i B are satisfiability equivalent. So φ i A ∧ φ i B is unsatisfiable.</p><p>By Theorem 1, we know that the interpolant ψ i A refers only to y −n i , . . . , y p i , the common variables of φi A and φi B . For φ i A ⇒ ψ i A by Theorem 1, any output sequence Based on Theorem 5, the procedure of interpolation-based decoder synthesis is sketched in <ref type="figure" target="#fig_2">Figure 4</ref>.</p><formula xml:id="formula_26">o −n i ∈ [[ y −n i ]], . . ., o p i ∈ [[ y p i ]]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">IMPLEMENTATION DETAILS</head><p>We discuss two implementation issues and their solutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">CNF Encoding of Disjunctive Constraints</head><p>The disjunctive constraints encountered in this paper are of the form ϕ1 ∨ · · · ∨ ϕ , where ϕi's are CNF formulas. Let ϕi consist of ki clauses {Ci1, . . . ,</p><formula xml:id="formula_27">C ik i }. Then i=1 (C i1 ∧ · · · ∧ C ik i )<label>(12)</label></formula><p>can be converted to CNF as</p><formula xml:id="formula_28">i=1 ((C i1 ∨ ¬c i ) ∧ · · · ∧ (C ik i ∨ ¬c i )) ∧ (c 1 ∨ · · · ∨ c ),<label>(13)</label></formula><p>where c i 's are fresh new variables.</p><p>Proposition 3. Formulas <ref type="formula" target="#formula_5">(12)</ref> and <ref type="formula" target="#formula_5">(13)</ref> are equisatisfiable.</p><p>Thereby the vector inequality can be easily expressed in CNF.</p><p>In decoder existence checking, however, the disjunction list ϕ 1 ∨ · · · ∨ ϕ may increase over time, i.e., increases.</p><p>To support incremental SAT solving, we further modify the above conversion and recursively define</p><formula xml:id="formula_29">Φ i = Φ i−1 ∧ k i j=1 (C ij ∨ ¬c i ) ∧ (b i−1 ∨ c i ∨ ¬b i ),<label>(14)</label></formula><p>for Φ0 = 1 and b0 = 0.</p><p>Proposition 4. Formula <ref type="formula" target="#formula_5">(13)</ref> and formula Φ ∧ b are equisatisfiable.</p><p>Note that, since literal b can be asserted by unit assumption <ref type="bibr" target="#b4">[5]</ref>, Formula <ref type="formula" target="#formula_5">(14)</ref> is extendable to arbitrary for incremental solving. Thereby the looping constraints can be incrementally expressed in CNF.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Incremental Time-Frame Expansion</head><p>There are different strategies of inserting a new time-frame into an expanded array of time-frames. Due to the looping constraints, in the decoder existence checking procedure of <ref type="figure" target="#fig_3">Figure 3</ref> we prefer the following insertion strategy.</p><p>For n to be incremented, a new time-frame is inserted between the 0 th and the −1 st time-frames, rather than appending before the −n th . Effectively, the variables with original time-indices t = −1, −2, . . ., and −n of Formula (2) are relabelled with t = −2, −3, . . ., and −(n + 1), respectively. For p to be incremented, on the other hand, a new time-frame is inserted between the 0 th and the 1 st time-frames, rather than appending after the p th . Effectively, the variables with original time-indices t = 1, 2, . . ., and p are relabelled with t = 2, 3, . . ., and p + 1, respectively. Moreover the reconnection between the new time-frame and existing time-frames can be done via proper utilization of unit assumptions.</p><p>Under this strategy, all the clauses of looping constraints added before remain in use. Only two equality constraints (i.e., s −(n+1) = s 0 and s p+1 = s 0 for n incremented, and s −n = s 1 and s p+2 = s 1 for p incremented) need to be added per time-frame expansion. In contrast, if we were to append a new time-frame at the end of the array, we would have to add (n + p + 2) looping constraints related to the new time-frame added. It results in a more complicated formula and less effective reuse of learned clauses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EXPERIMENTAL RESULTS</head><p>The proposed method, named Decosy, were implemented in ABC <ref type="bibr" target="#b2">[3]</ref>. The experiments were conducted on a Linux machine with Xeon 2.53GHz CPU and 48GB RAM. The benchmark circuits and executable codes of prior work <ref type="bibr" target="#b12">[14,</ref><ref type="bibr" target="#b13">15]</ref> were obtained online <ref type="bibr">[6]</ref>. The profiles of circuits XGXS, XFI, Scrambler, PCIE, and T2Ethernet can be found in <ref type="bibr" target="#b12">[14]</ref>. Two additional designs: the HM series, implementing the Hamming codes for correcting any 1-bit error, and AD, implementing the 0-1 alternation detector of <ref type="figure" target="#fig_0">Figure 1</ref>, were created. The circuits in Verilog were converted to the blif format for optimization in ABC. The final decoder circuits were mapped into standard cells with the mcnc.genlib library.</p><p>We conducted three sets of experiments: comparison with <ref type="bibr" target="#b12">[14]</ref> on decoder generation in <ref type="table" target="#tab_2">Table 1</ref>, comparison with <ref type="bibr" target="#b13">[15]</ref> on decoder existence checking and generation in <ref type="table" target="#tab_3">Table 2</ref>, and comparison with <ref type="bibr" target="#b13">[15]</ref> on decoder existence checking for circuits without decoders in <ref type="table" target="#tab_4">Table 3</ref>. Note that the executables of <ref type="bibr" target="#b12">[14,</ref><ref type="bibr" target="#b13">15]</ref> were implemented in OCaml running zChaff <ref type="bibr" target="#b8">[10]</ref>, whereas ours were implemented in C running MiniSat <ref type="bibr" target="#b4">[5]</ref>. The reported runtimes in <ref type="bibr" target="#b12">[14]</ref> and <ref type="bibr" target="#b13">[15]</ref>, which were obtained on different machine settings, were repeated in the parentheses in the fifth column of <ref type="table" target="#tab_3">Table 2</ref> and the second column of <ref type="table" target="#tab_4">Table 3</ref> for reference. It is interesting to notice the curious runtime inconsistencies. <ref type="table" target="#tab_2">Table 1</ref> compares decoder generation results of <ref type="bibr" target="#b12">[14]</ref> and Decosy with respect to the pre-specified parameters given in <ref type="bibr" target="#b12">[14]</ref>, which are not repeated here to save space. The obtained decoder circuits were optimized with ABC under script strash; dsd; strash; dc2; dc2; dch; map. The decoder area, delay, and computation time (including decoder generation time plus script optimization time in seconds) are shown. (The decoders generated by <ref type="bibr" target="#b12">[14]</ref> were in Verilog format, and were converted to blif for optimization under the same script.) As shown, the optimization script effectively reduced all of the decoders generated by the prior method and Decosy within 2.13 seconds. Except for PCIE and T2Ethernet, Decosy achieved similar or better results. For PCIE and T2Ethernet, the xor-minimization efforts of <ref type="bibr" target="#b12">[14]</ref> were likely taking effect (as noted in <ref type="bibr" target="#b12">[14]</ref> that communication circuits are commonly xor-dominated). On the other hand, for the larger circuits XFI and HM <ref type="bibr" target="#b13">(15,</ref><ref type="bibr" target="#b9">11)</ref>, Decosy achieved more impressive improvements. (For the HM circuits, the prior method missed decoder generation at the time-frame expansion where the decoder is supposed to exist, perhaps due to implementation problems. The data, marked ' §' in <ref type="table" target="#tab_2">Table 1 as well as in Table 2</ref>, were obtained by our own re-implementation of <ref type="bibr" target="#b12">[14]</ref> for referential purposes.) <ref type="table" target="#tab_3">Table 2</ref> compares the results of <ref type="bibr" target="#b13">[15]</ref> and Decosy for decoder existence checking plus decoder generation. It lists obtained parameters (n, p, n † , p † ), numbers of decoder inputs/registers, circuit area/delay, and runtime, where n † = max i n i and p † = max i p i by the notation of Section 3.2. The runtime includes checking decoder existence and script optimization, same as those of <ref type="table" target="#tab_2">Table 1</ref>. <ref type="table" target="#tab_4">Table 3</ref> compares the runtime (in seconds) of <ref type="bibr" target="#b13">[15]</ref> and Decosy for decoder nonexistence checking. Circuits XGXS_err, XFI_err, Scrambler_err, PCIE_err, and T2Ethernet_err are obtained via design error insertion in <ref type="bibr" target="#b12">[14]</ref>. The HM_err circuits, on the other hand, were derived by embedding noisy channels with memory and multi-bit flipping capability into the HM circuits. These circuits and AD have no decoders. In all the cases Decosy concluded decoder nonexistence under parameters (n, p) = (0, 0), i.e., without time-frame expansion, except for the HM_err series requiring multiple time-frame expansion. It tends to suggest that Decosy can be effective in detecting decoder non-existence and beneficial to assisting design verification. In contrast, the prior method <ref type="bibr" target="#b13">[15]</ref> is incomplete and less effective.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSIONS</head><p>We have presented the first sound and complete approach   to automatic decoder synthesis. Experiments showed that our method, based on incremental SAT-solving and Craig interpolation, effectively determined decoder (non)existence and generated decoders, if they exist. To optimize decoder, using a script of synthesis commands has turned out to be effective, despite potential further improvements. The synthesized decoders exhibit qualities comparable to prior work, which equipped with xor-based decoder optimization. Hence our approach may potentially benefit the design and verification of encoding/decoding systems in various applications.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: A 0-1 alternation detector with unspecified initial states.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: (a) Decoder (n, p)-miter of transition system T ; (b) looping constraints L − , L + , and L ± for the state variables of the (n, p)-miter in (a).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Theorem 4 .</head><label>4</label><figDesc>Given a transition system T ( x, s, y, s ) and its care-state set SC ⊆ [[ s]], the decoder existence checking procedure of Figure 3 terminates with n + p ≤ |SC | 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Decoder existence checking.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Algorithm: Decoder synthesis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>[[ x 0 ]] at time t = 0 that are consistent (in terms of[[ y t ]], constrained by the transition relation T . Proof. (⇐) The encoder input cannot be uniquely deter- mined by output sequences of bounded lengths as this infinite output sequence provides a counterexample. (⇒) Consider the contrapositive. For every pair of distinct inputs i1 0 and i2 0 , any output sequence consistent with both i 1 0 and i 2 0 is bounded from below or above. Because T is of finite states, as long as the output sequence is long enough a state pair ( q1, q2) ∈ [[ s]] × [[ s]], for q1 and q2 on the= l (ends after t = u). Let l * and u * be= l * − 1, . . . , u * + 1, its corresponding input at t = 0 is unique. Thus the decoder of T exists.</head><label></label><figDesc></figDesc><table>Lemma 1. The decoder of a transition system T ( s, x, s , y) 
does not exist if and only if there exist two distinct inputs 

i 1 
0 , 
i 2 
0 ∈ input-output traces) with some same infinite output sequence 

..., o −1 , o 0 , o 1 , ..., 

for o t ∈ state 
traces consistent with 
i 1 
0 and 
i 2 
0 , respectively, will even-

tually repeat. This repetition makes the output sequences 
unboundedly extendable. Therefore, for those output se-
quences bounded from below (above), there exists a global 
lower bound l ≤ 0 (upper bound u ≥ 0) such that none of 
them starts before t the minimum lower bound and maximum upper bound, 
respectively, among all distinct input pairs 
i 1 
0 and 
i 2 
0 . By 

observing any output sequence with t It is important to notice that the infinity of the output se-
quence must go in both positive and negative directions. A 
decoder exists if every output sequence consistent with two 
distinct inputs 
i1 
0 , 
i2 
0 , if unbounded in length, extends to 

infinity in only one direction. 
Based on Lemma 1, the following theorem lays the com-
putational foundation for decoder existence checking. 

Theorem 3. The decoder of a transition system T ( s, x, s , y) 
does not exist if and only if the formula 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>that makes φ i A satisfiable and thus asserts x 0 i will be in the onset of ψ i A . For ψ i A ∧ φ i B un- satisfiable by Theorem 1, any output sequence o −n i , . . . , o p i that makes φB satisfiable and thus asserts ¬x * i 0 will be in the offset of ψ i A . On the other hand, since φ i A ∧ φ i B is un- satisfiable, there is no output sequence o −n i , . . . , o p i in both onset and offset of ψ i A . Hence ψ i A defines a valid decoding function for x 0 i of x 0 .</head><label></label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><head>Table 1 : Comparison on Decoder Generation.</head><label>1</label><figDesc></figDesc><table>circuit 
[14] 
Decosy 
area ratio 
delay ratio 
area/delay 
time 
area/delay 
time 
XGXS 
269/7.4 
1.23 = 1.17+0.06 
286/7.3 
0.08 = 0.02+0.06 
1.06 
0.99 
XFI 
5697/14.4 
492.58 = 490.45+2.13 
3978/14.3 
4.02 = 3.21+0.81 
0.70 
0.99 
Scrambler 
736/3.8 
1.88 = 1.83+0.05 
640/3.8 
0.25 = 0.19+0.06 
0.87 
1 
PCIE 
171/5.8 
1.04 = 1.02+0.02 
190/6.6 
0.08 = 0.04+0.04 
1.11 
1.14 
T2Ethernet 
299/7.5 
22.67 = 22.62+0.05 
583/9.0 
1.47 = 1.37+0.10 
1.95 
1.20 
HM(7,4) 
255  § /7.3  § 
0.12  § = 0.03  § +0.09  § 
255/7.3 
0.08 = 0.01+0.07 
1 
1 
HM(15,11) 
4232  § /13.8  § 
56.82  § = 55.86  § +0.96  § 
3279/13.2 
1.33 = 0.35+0.98 
0.77 
0.96 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Comparison on Decoder Existence Checking and Decoder Generation. 

circuit 
[15] 
Decosy 
area 
delay 
(n, p, n  † , p  † ) 
#in/#reg 
area/delay 
time 
(n, p, n  † , p  † ) 
#in/#reg 
area/delay 
time 
ratio 
ratio 
XGXS 
(1, 1, −1, 1) 
11/0 
293/7.5 
3.31 (2.70) 
(1, 1, −1, 1) 
11/0 
295/7.1 
0.07 
1.01 
0.95 
XFI 
(3, 0, 1, 0) 
67/66 
5697/14.4 
1001.77 (1144.32) 
(3, 1, 1, 0) 
67/66 
3913/12.5 
8.59 
0.69 
0.87 
Scrambler 
(2, 0, 1, 0) 
65/64 
736/3.8 
13.55 (10.46) 
(1, 1, 1, 0) 
65/64 
640/3.8 
0.42 
0.87 
1 
PCIE 
(1, 2, −2, 2) 
11/0 
163/6.1 
5.1 (3.91) 
(1, 2, −2, 2) 
11/0 
190/6.6 
0.07 
1.17 
1.08 
T2Ethernet 
(1, 4, −4, 4) 
11/0 
269/6.9 
137.26 (113.89) 
(1, 4, −4, 4) 
11/0 
526/9.7 
1.81 
1.96 
1.41 
HM(7,4) 
(0, 0, 0, 0) 
7/0 
255  § /7.3  § 
0.12  § (NA) 
(0, 0, 0, 0) 
7/0 
255/7.3 
0.05 
1 
1 
HM(15,11) 
(0, 0, 0, 0) 
15/0 
4232  § /13.8  § 
56.92  § (NA) 
(0, 0, 0, 0) 
15/0 
3279/13.2 
2.02 
0.77 
0.96 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="true"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Comparison on Decoder Existence Checking. 

circuit 
[15] 
Decosy 
(w/o decoder) 
time 
time 
XGXS_err 
2.17 (1.23) 
0.01 
XFI_err 
39.71 (44.58) 
0.01 
Scrambler_err 
3.96 (3.26) 
0.08 
PCIE_err 
2.94 (1.67) 
0.01 
T2Ethernet_err 
128.73 (21.49) 
0.04 
HM(7,4)_err 
1.35 (NA) 
0.01 
HM(15,11)_err 
3.01 (NA) 
0.01 
AD 
&gt; 6000 (NA) 
0.01 

</table></figure>

			<note place="foot" n="1"> Memoryless (or combinational) encoding/decoding can be thought of as a single-state finite state machine. 2 The problem results from the misconception that the notion of unique states [15] exactly captures the essence of decoder existence. However, there are state transition systems that consist of purely unique states and yet have no decoder as the example of Figure 1 suggests.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was supported in part by the National Science Council under grants NSC 99-2221-E-002-214-MY3 and NSC 99-2923-E-002-005-MY3.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Low power error resilient encoding for on-chip data buses</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Bertozzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Benini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>De Micheli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design, Automation and Test in Europe (DATE)</title>
		<meeting>Design, Automation and Test in Europe (DATE)</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="102" to="109" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Symbolic model checking without BDDs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Tools and Algorithms for the Construction and Analysis of Systems (TACAS)</title>
		<meeting>Int&apos;l Conf. on Tools and Algorithms for the Construction and Analysis of Systems (TACAS)</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="193" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">ABC: A system for sequential synthesis and verification</title>
		<ptr target="http://www.eecs.berkeley.edu/∼alanmi/abc/" />
		<imprint/>
		<respStmt>
			<orgName>Berkeley Logic Synthesis and Verification Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Three uses of the Herbrand-Gentzen theorem in relating model theory and proof theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Craig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="269" to="285" />
			<date type="published" when="1957" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An extensible SAT-solver</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Eén</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Sörensson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Theory and Applications of Satisfiability Testing (SAT)</title>
		<meeting>Int&apos;l Conf. on Theory and Applications of Satisfiability Testing (SAT)</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="502" to="518" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Interpolating functions from large Boolean relations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-H</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-P</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-L</forename><surname>Hung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Computer-Aided Design (ICCAD)</title>
		<meeting>Int&apos;l Conf. on Computer-Aided Design (ICCAD)</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="779" to="784" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">To SAT or not to SAT: Scalable exploration of functional dependency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-H</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mishchenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-Y</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="457" to="467" />
			<date type="published" when="2010-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Interpolation and SAT-based model checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Computer Aided Verification (CAV)</title>
		<meeting>Int&apos;l Conf. on Computer Aided Verification (CAV)</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Chaff: Engineering an efficient SAT solver</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Moskewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Madigan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automation Conference (DAC)</title>
		<meeting>Design Automation Conference (DAC)</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="530" to="535" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Moon</surname></persName>
		</author>
		<title level="m">Error Correction Coding: Mathematical Methods and Algorithms</title>
		<imprint>
			<publisher>Wiley-Interscience</publisher>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Introduction to Data Compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sayood</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
	<note>3rd edition</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Coding for system-on-chip networks: A unified framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sridhara</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shanbhag</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on VLSI Systems</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="655" to="667" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Synthesizing complementary circuits automatically</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computer-Aided Design of Integrated Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1191" to="1202" />
			<date type="published" when="2010-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A halting algorithm to determine the existence of decoder</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Formal Methods in Computer Aided Design (FMCAD)</title>
		<meeting>Formal Methods in Computer Aided Design (FMCAD)</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="91" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Trappe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Washington</surname></persName>
		</author>
		<title level="m">Introduction to Cryptography with Coding Theory</title>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
	<note>2nd edition</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
