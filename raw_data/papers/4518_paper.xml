<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:52+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Dynamic Deadlock Analysis of Multi-Threaded Programs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saddek</forename><surname>Bensalem</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Universit√© Joseph Fourier</orgName>
								<address>
									<settlement>Verimag, Grenoble</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Klaus</forename><surname>Havelund</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Kestrel Technology</orgName>
								<address>
									<settlement>Palo Alto</settlement>
									<country>California USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Dynamic Deadlock Analysis of Multi-Threaded Programs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>This paper presents a dynamic program analysis algorithm that can detect deadlock potentials in a multi-threaded program by examining a single execution trace, obtained by running an instrumented version of the program. The algorithm is interesting because it can identify deadlock potentials even though no deadlocks occur in the examined execution, and therefore it scales very well in contrast to more formal approaches to deadlock detection. It is an improvement of an existing algorithm in that it reduces the number of false positives (false warnings). The paper describes an implementation and an application to three case studies.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The Java programming language <ref type="bibr" target="#b1">[2]</ref> explicitly supports concurrent programming through a selection of concurrency language concepts, such as threads and monitors. Threads execute in parallel, and communicate via shared objects that can be locked using synchronized access to achieve mutual exclusion. However, with concurrent programming comes a new set of problems that can hamper the quality of the software. Deadlocks form such a problem category. That deadlocks pose a common problem is emphasized by the following statement in <ref type="bibr" target="#b22">[23]</ref>: "Among the most central and subtle liveness failures is deadlock. Without care, just about any design using synchronization on multiple cooperating objects can contain the possibility of deadlock".</p><p>In this paper we present a dynamic program analysis algorithm that can detect the potential for deadlocks in a program by analyzing a trace (log file) generated from a successful deadlock free execution of the program. The algorithm is interesting because it catches existing deadlock potentials with very high probability even when no actual deadlocks occur during test runs. A basic version of this algorithm has previously been implemented in the commercial tool Visual Threads <ref type="bibr" target="#b15">[16]</ref>. This basic algorithm, however, can give false positives (as well as false negatives), putting a burden on the user to refute such. Our goal is to reduce the amount of false positives reported by the algorithm, and for that purpose we have modified it as reported in this paper. Detection of errors in concurrent programs by analysis of successful runs was first suggested for low-level data races in <ref type="bibr" target="#b25">[26]</ref>. Other forms of data races have later shown to be detectable using related forms of analysis, such as high-level data races <ref type="bibr" target="#b3">[4]</ref> and atomicity violations <ref type="bibr" target="#b4">[5]</ref>.</p><p>Two types of deadlocks have been discussed in the literature <ref type="bibr" target="#b26">[27]</ref>  <ref type="bibr" target="#b21">[22]</ref>: resource deadlocks and communication deadlocks. In resource deadlocks, a process which requests resources must wait until it acquires all the requested resources before it can proceed with its computation. A set of processes is resource deadlocked if each process in the set requests a resource held by another process in the set, forming a cycle of lock requests. In communication deadlocks, messages are the resources for which processes wait. In this paper we focus only on resource deadlocks. In Java, threads can communicate via shared objects by for example calling methods on those objects. In order to avoid data races in these situations (where several threads access a shared object simultaneously), objects can be locked using the synchronized statement, or by declaring methods on the shared objects synchronized, which is equivalent. For example, a thread t can obtain a lock on an object A and then execute a statement S while having that lock by executing the following statement: synchronized(A){S}. During the execution of S, no other thread can obtain a lock on A. The lock is released when the scope of the synchronized statement is left; that is, when execution passes the curly bracket: '}'. Java also provides the wait and notify primitives in support for user controlled interleaving between threads. While the synchronized primitive is the main source for resource deadlocks in Java, the wait and notify primitives are the main source for communication deadlocks. Since this paper focuses on resource deadlocks, we shall in the following focus on Java's capability of creating and executing threads and on the synchronized statement.</p><p>The difficulty in detecting deadlocks comes from the fact that concurrent programs typically are non-deterministic: several executions of the same program on the same input may yield different behaviors due to slight differences in the way threads are scheduled. Various technologies have been developed by the formal methods community to circumvent this problem, such as static analysis and model checking. Static analysis, such as performed by tools like JLint <ref type="bibr" target="#b2">[3]</ref>, PolySpace <ref type="bibr" target="#b24">[25]</ref> and ESC <ref type="bibr" target="#b10">[11]</ref>, analyze the source code without executing it. These techniques are very efficient, but they often yield many false positives (false warnings) and additionally cannot well analyze programs where the object structure is very dynamic. Model checking has been applied directly to software (in contrast to only designs), for example in the Java PathFinder system (JPF) developed by NASA <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b28">29]</ref>, and in similar systems <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b11">12]</ref>. A model checker explores all possible execution paths of the program, and will therefore theoretically eventually expose a potential deadlock. This process is, however, quite resource demanding, in memory consumption as well in execution time, especially for large realistic programs. Static analysis and model checking are both typically complete (no false negatives), and model checking in addition is typically sound (no false positives). The algorithm presented in this paper is neither sound nor complete, but it scales and it is very effective: it finds bugs with high probability and it yields few false positives. The technique is based on trace analysis: a program is instrumented to log synchronization events when executed. The algorithm then examines the log file, building a lock graph, which reveals deadlock potentials by containing cycles. The algorithm has been implemented in the Java PathExplorer tool <ref type="bibr" target="#b19">[20]</ref>, which in addition analyzes Java programs for various forms of data races <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b3">4]</ref> and conformance with temporal logic properties <ref type="bibr" target="#b6">[7]</ref>. Although the implementation is Java specific, the principles and theory presented are universal and apply in full to multi-threaded programs written in languages like C and C++ as well. In fact, two of the case studies involve C++ programs. In this case the programs must currently be manually instrumented. The algorithm was first described in <ref type="bibr" target="#b7">[8]</ref>.</p><p>Some additional closely related work specifically requires mentioning. In earlier work we presented the GoodLock algorithm <ref type="bibr" target="#b16">[17]</ref> which attempts to improve the basic lock graph algorithm presented in <ref type="bibr" target="#b15">[16]</ref> by reducing false positives in the presence of gate locks (a common lock taken first by involved threads). This algorithm was based on building acyclic lock trees (rather than cyclic lock graphs as in <ref type="bibr" target="#b15">[16]</ref>) but it could only detect deadlocks between pairs of threads. The algorithm presented in this paper also tries to reduce false positives in presence of gate locks, but can detect deadlocks between any number of threads, and builds directly on the cyclic graph model in <ref type="bibr" target="#b15">[16]</ref>. In addition, the algorithm also reduces false positives arising from code segments that cannot possibly execute concurrently. In parallel work <ref type="bibr" target="#b0">[1]</ref>, included in these proceedings, an algorithm extending the GoodLock algorithm is suggested for reducing false positives, also in presence of gate locks. This algorithm uses a combination of acyclic lock trees and cyclic lock graphs to represent locking patterns in a program run. In that work a framework is furthermore suggested for using static analysis in combination with dynamic analysis to detect deadlocks. In these pieces of work a single execution trace is used as a basis for the dynamic analysis. Also presented at PADTAD'05 was work by IBM <ref type="bibr" target="#b12">[13]</ref> where several execution traces, generated from several runs of the program being tested, are used to create a single locking model that is then analyzed. This approach is useful to reduce false negatives (missed errors).</p><p>The paper is organized as follows. Section 2 introduces preliminary concepts and notation used throughout the rest of the paper. Section 3 introduces an example that illustrates the notion of deadlock and the different forms of false positives that are possible. Section 4 presents the basic algorithm suggested in <ref type="bibr" target="#b15">[16]</ref> (the algorithm is only explained in few words in <ref type="bibr" target="#b15">[16]</ref>). The subsequent two sections 5 and 6 suggest modifications, each reducing false positives. Section 7 shortly describes the implementation of the algorithm and presents the results of three case studies. Finally, Section 8 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>A directed graph is a pair G = (S, R) of sets satisfying R ‚äÜ S √ó S. The set R is called the edge set of G, and its elements are called edges. A path p is a non-empty graph G = (S, R) of the form S = {x 1 , x 2 , . . . , x k } and R = {(x 1 , x 2 ), (x 2 , x 3 ), . . . , (x k‚àí1 , x k )}, where the x i are all distinct, except that x k may be equal to x 1 , in which case the path is a cycle. The nodes x 0 and x k are linked by p; we often refer to a path by the natural sequence of its nodes, writing, say, p = x 1 , x 2 , . . . , x k and calling p a path from x 1 to x k . In case where the edges are labeled with elements in W , G is triplet (S, W, R) and called a labeled graph with R ‚äÜ S √ó W √ó S. A labeled path, respectively cycle, is a labeled graph with the obvious meaning. Given a sequence œÉ = x 1 , x 2 , . . . , x n , we refer to an element at position i in œÉ by œÉ <ref type="bibr">[i]</ref> and the length of œÉ by |œÉ|. We let &lt;&gt; denote the empty sequence, and the concatenation of two sequences œÉ 1 and œÉ 2 is denoted by œÉ 1 œÉ 2 . We denote by œÉ i the prefix x 1 , . . . , </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">An Example</head><p>We shall with an example illustrate the three categories of false positives that the basic algorithm reports, but which the improved algorithm will not report. The first category, single threaded cycles, refers to cycles that are created by one single thread. Guarded cycles refer to cycles that are guarded by a gate lock "taken higher" up by all involved threads. Finally, thread segmented cycles refer to cycles between thread segments that cannot possibly execute concurrently. The program in <ref type="figure" target="#fig_1">Figure 1</ref> illustrates these three situations, and a true positive. The real deadlock potential exists between threads T 2 and T 3 , corresponding to a cycle on L 1 and L 2 . The single threaded cycle within T 1 clearly does not represent a deadlock. The guarded cycle between T 1 and T 2 does not represent a deadlock since both threads must acquire the gate lock G first. Finally, the thread segmented cycle between T 1 and T 3 does not represent a deadlock since T 3 will execute before T 1 executes its last two synchronization statements.</p><p>When analyzing such a program for deadlock potentials, we are interested in observing all lock acquisitions and releases, and all thread starts and joins. The program can be instrumented to emit such events. A lock trace œÉ = e 1 , e 2 , . . . , e n is a finite sequence of lock and unlock events and start and join events. Let E œÉ denote the set of events occurring in œÉ. Let T œÉ denote the set of threads occurring in E œÉ , and let L œÉ denote the set of locks occurring in E œÉ . We assume for convenience that the trace is reentrant free in the sense that an already acquired lock is never re-acquired by the same thread (or any other thread of course) before being released. Note that Java supports reentrant locks by allowing a lock to be re-taken by a thread that already has the lock. However, the instrumentation can generate reentrant free traces if it is recorded how many times a lock has been acquired nested by a thread. Normally a counter is introduced that is incremented for each lock operation and decremented for each unlock operation. A lock operation is now only reported if the counter is zero (it is free before being taken), and an unlock operation is only reported if the counter is 0 again after the unlock (it becomes free again). For illustration purposes we shall assume a non-deadlocking execution trace œÉ for this program. It doesn't matter which one since all non-deadlocking traces will reveal all four cycles in the program using the basic algorithm. We shall assume the following trace of line numbered events (the line number is the first argument), which first, after having started T 1 and T 2 from the M ain thread, executes T 1 until the join statement, then executes T 2 to the end, then T 3 to the end, and then continues with T 1 after it has joined on T 3 's termination. The line numbers are given for illustration purposes, and are actually recorded in the implementation in order to provide the user with useful error messages. In addition to the lock and unlock events l(lno, t, o) and u(lno, t, o) for line numbers lno, threads t and locks o, the trace also contains events for thread start, s(lno, t 1 , t 2 ) and thread join, j(lno, t 1 , t 2 ), meaning respectively that t 1 starts or joins t 2 in line number lno. œÉ = s(1, M ain, T1), s(2, M ain, T2), l(3, T1, G), l(4, T1, L1), l(5, T1, L2), u(5, T1, L2), u(6, T1, L1), u(7, T1, G), s(9, T1, T3), l(14, T2, G), l(15, T2, L2), l(16, T2, L1), u(16, T2, L1), u(17, T2, L2), u(18, T2, G), l(19, T3, L1), l(20, T3, L2), u(20, T3, L2), u(21, T3, L1), j(10, T1, T3), l(11, T1, L2), l(12, T1, L1), u(12, T1, L1), u(13, T1, L2)</p><p>Occasionally line numbers will be left out when referring to events. <ref type="bibr" target="#b5">6</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Basic Cycle Detection Algorithm</head><p>In essence, the detection algorithm consists of finding cycles in a lock graph. In the context of multi-threaded programs, the basic algorithm sketched in <ref type="bibr" target="#b15">[16]</ref> works as follows. The multi-threaded program under observation is executed, while just lock and unlock events are observed. A graph of locks is built, with edges between locks symbolizing locking orders. Any cycle in the graph signifies a potential for a deadlock. Hence, we shall initially restrict ourselves to traces including only lock and unlock events (no start or join events). In order to define the lock graph, we introduce a notion that we call a lock context of a trace œÉ in position i, denoted by C L (œÉ, i). It is a mapping from each thread to the set of locks owned by that thread at that position. Formally, for a thread t ‚àà T œÉ we have the following:</p><formula xml:id="formula_0">C L (œÉ, i)(t) = {o | ‚àÉj : j ‚â§ i ‚àß œÉ[j] = l(t, o) ‚àß ¬¨‚àÉk : j &lt; k ‚â§ i ‚àß œÉ[k] = u(t, o)}.</formula><p>Bellow we give a definition that allows to build the lock graph G L with respect to an execution trace œÉ. An edge in G L between two locks l 1 and l 2 means that there exists a thread t which owns the object l 1 while taking the object l 2 .</p><p>Definition 1 (Lock graph) Given an execution trace œÉ = e 1 , e 2 , . . . , e n . We say that the lock graph of œÉ is the minimal directed graph G L = (L, R) such that : L is the set of locks L œÉ , and R ‚äÜ L √ó L is defined by (l 1 , l 2 ) ‚àà R if there exists a thread t ‚àà T œÉ and a position i ‚â• 2 in œÉ s. t.</p><formula xml:id="formula_1">œÉ[i] = l(t, l 2 ) and l 1 ‚àà C L (œÉ, i ‚àí 1)(t).</formula><p>In <ref type="figure" target="#fig_2">Figure 2</ref> we give an algorithm for constructing the lock graph from a lock trace. In this algorithm, we also use the context C L which is exactly the same as in the definition 1. The only difference is that we don't need to explicitly use the two parameters œÉ and i. The set of cycles in the graph G L , denoted by cylces(G L ), represents the potential deadlock situations in the program. The lock graph for the example in <ref type="figure" target="#fig_1">Figure 1</ref> is also shown in <ref type="figure" target="#fig_2">Figure 2</ref>. The numbers indicate line numbers where source respectively target locks are taken.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Eliminating Single Threaded and Guarded Cycles</head><p>In this section we present a solution that removes false positives stemming from single threaded cycles and guarded cycles. In <ref type="bibr" target="#b16">[17]</ref> we suggested a solution, the GoodLock algorithm, based on building synchronization trees. However, this solution could only detect deadlocks between pairs of threads. The algorithm to be presented here is not limited in this sense. The solution is to extend the lock graph by labeling each edge between locks with information about which thread causes the addition of the edge and what gate locks were held by that thread when the target lock was taken. A definition of valid cycles will then include this information to filter out false positives. First, we define the extended lock graph.</p><p>Definition 2 (Guarded lock graph) Given a trace œÉ = e 1 , e 2 , . . . , e n . We say that the guarded lock graph of œÉ is the minimal directed labeled graph G L =</p><note type="other">Input: An execution trace œÉ GL is a graph; CL : [TœÉ ‚Üí 2 LœÉ ] is a lock context; for(</note><formula xml:id="formula_2">i = 1 .. |œÉ|) do case œÉ[i] of l(t, o) ‚Üí GL := GL {(o , o) | o ‚àà CL(t)}; CL := CL ‚Ä† [t ‚Üí CL(t) {o}]; u(t, o) ‚Üí CL := CL ‚Ä† [t ‚Üí CL(t)\{o}] end;</formula><p>for each c in cycles(GL) do print ("deadlock potential:",c); </p><formula xml:id="formula_3">(L, W, R) such that: L is the set of locks L œÉ , W ‚äÜ T œÉ √ó 2 L</formula><p>is the set of labels, each containing a thread id and a lock set, and</p><formula xml:id="formula_4">R ‚äÜ L √ó W √ó L is defined by (l 1 , (t, g), l 2 ) ‚àà R if there exists a thread t ‚àà T œÉ and a position i ‚â• 2 in œÉ s.t. œÉ[i] = l(t, l 2 ) and l 1 ‚àà C L (œÉ, i ‚àí 1)(t) and g = C L (œÉ, i ‚àí 1)(t).</formula><p>Each edge (l 1 , (t, g), l 2 ) in R is labeled with the thread t that took the locks l 1 and l 2 , and a lock set g, indicating what locks t owned when taking l 2 . In order for a cycle to be valid, and hence regarded as a true positive, the threads and guard sets occurring in labels of the cycle must be valid in the following sense.</p><p>Definition 3 (Valid threads and guards) Let G L be a guarded lock graph of some execution trace and c = (L, W, R) a cycle in cycles(G L ), we say that:</p><p>-threads of c are valid if: forall e, e ‚àà R e = e ‚áí thread(e) = thread(e ) -guards of c are valid if: forall e, e ‚àà R e = e ‚áí guards(e) ‚à© guards(e ) = ‚àÖ where, for an edge e ‚àà R, thread(e), resp. guards(e), gives the first, resp. second, component of the label (t, g) of e = (l 1 , (t, g), l 2 ).</p><p>For a cycle to be valid, the threads involved must differ. This eliminates single threaded cycles. Furthermore, the lock sets on the edges in the cycle must not overlap. This eliminates cycles that are guarded by the same lock taken "higher up" by at least two of the threads involved in the cycle. Assume namely that such a gate lock exists, then it will belong to the lock sets of several edges in the cycle, and hence they will overlap at least on this lock. This corresponds to the fact that a deadlock cannot happen in this situation. Valid cycles are now defined as follows:</p><p>Definition 4 (Unguarded cycles) Let œÉ be an execution trace and G L its guarded lock graph. We say that a cycle c ‚àà cycles(G L ) is an unguarded cycle if the guards of c are valid and threads of c are also valid. We denote by cycles g (G L ) the set of unguarded cycles in cycles(G L ).</p><p>We shall in this section not present an explicit algorithm for constructing this graph, since its concerns a relatively simple modification to the basic algorithm -the statement that updates the lock graph becomes:</p><formula xml:id="formula_5">G L := G L {(o , (t, C L (t)), o) | o ‚àà C L (t)}</formula><p>adding the labels (t, C L (t)) to the edges. Furthermore, cycles to be reported should be drawn from: cycles g (G L ).</p><p>Let us illustrate the algorithm with an example. We consider again the execution trace œÉ from Section 3. The guarded graph for this trace is shown in <ref type="figure" target="#fig_3">Figure 3</ref>. The graph contains the same number of edges as the basic graph in <ref type="figure" target="#fig_2">Figure 2</ref>. However, now edges are labeled with a thread and a guard set. In particular, we notice that the gate lock G occurs in the guard set of edges (4, 5) and <ref type="bibr" target="#b14">(15,</ref><ref type="bibr" target="#b15">16)</ref>. This prevents this guarded cycle from being included in the set of valid cycles since it is not guard valid: the guard sets overlap in G. Also the single threaded cycle (4, 5) ‚Üî (11, 12) is eliminated because it is not thread valid: the same thread T 1 occurs on both edges. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Eliminating Segmented Cycles</head><p>In the previous section we saw the specification of an algorithm that removes false positives stemming from single threaded cycles and guarded cycles. In this section we present the full algorithm that in addition removes false positives stemming from segmented cycles. We assume that traces now also contain start and join events. Recall the example in <ref type="figure" target="#fig_1">Figure 1</ref> and that the basic algorithm reports a cycle between threads T 1 (line 11-12) and T 3 (line 19-20) on locks L 1 and L 2 . However, a deadlock is impossible since thread T 3 is joined on by T 1 in line 10. Hence, the two code segments: line 11-12 and line 19-20 can never run in parallel. The algorithm to be presented will prevent such cycles from being reported by formally introducing such a notion of segments that cannot execute in parallel. A new directed segmentation graph will record which segments execute before others. The lock graph is then extended with extra label information, that specifies what segments locks are acquired in, and the validity of a cycle now incorporates a check that the lock acquisitions are really occurring in parallel executing segments. The idea of using segmentation in runtime analysis was initially suggested in <ref type="bibr" target="#b15">[16]</ref> to reduce the amount of false positives in data race analysis using the Eraser algorithm <ref type="bibr" target="#b25">[26]</ref>. We use it in a similar manner here to reduce false positives in deadlock detection.</p><p>More specifically, the solution is during execution to associate segment identifiers (natural numbers, starting from 0) to segments of the code that are separated by statements that start or join other threads. For example, if a thread t 1 currently is in segment s and starts another thread t 2 , and the next free segment is n + 1, then t 1 will continue in segment n + 1 and t 2 will start in segment n + 2. From then on the next free segment will be n + 3. It is furthermore recorded in the segmentation graph that segment s executes before n + 1 as well as before n + 2. In a similar way, if a thread t 1 currently is in segment s 1 and joins another thread t 2 that is in segment s 2 , and the next free segment is n + 1, then t 1 will continue in segment n + 1, t 2 will be terminated, and from then on the next free segment will be n + 2. It is recorded that s 1 as well as s 2 execute before n + 1. <ref type="figure" target="#fig_7">Figure 5</ref> illustrates the segmentation graph for the program example in <ref type="figure" target="#fig_1">Figure 1</ref>. In order to give a formal definition of the segmentation we need to define two functions. The first one, C S (œÉ), segmentation context of the trace œÉ, gives for each position i of the execution trace œÉ, the current segment of each thread t at that position. </p><formula xml:id="formula_6">CS(œÉ) = f0(œÉ, C init S , 1, 0)</formula><p>, where the function f0 is defined by left-to-right recursion over the trace œÉ as follows:</p><formula xml:id="formula_7">f0(e œÉ, CS, i, n) = Ô£± Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£≤ Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£≥ f0(œÉ, CS, i + 1, n) if e ‚àà {l(t,o),u(t,o)}, f0(œÉ, CS ‚Ä†[i ‚Üí CS[i ‚àí 1] ‚Ä† t1 ‚Üí n + 1 t2 ‚Üí n + 2 , i + 1, n + 2) if e = s(t1, t2), f0(œÉ, CS ‚Ä†[i ‚Üí CS[i ‚àí 1] ‚Ä†[t1 ‚Üí n + 1], i + 1, n + 1) if e = j(t1, t2). f0(&lt;&gt;, CS, i, n) = CS</formula><p>The second function needed, # alloc , gives the number of segments allocated in position i of œÉ. This function is used to calculate what is the next segment to be assigned to a new execution block, and is dependent on the number of start events s(t 1 , t 2 ) and join events j(t 1 , t 2 ) that occur in the trace up and until position i, recalling that each start event causes two new segments to be allocated. Formally we define it as follows :</p><formula xml:id="formula_8"># alloc (œÉ, i) = |œÉ i ‚Üì s | * 2 + |œÉ i ‚Üì j |.</formula><p>We can now define the notion of a directed segmentation graph, which defines an ordering between segments. Informally, assume that in trace position i a thread t 1 , being in segment s 1 = C S (œÉ)(i ‚àí 1)(t 1 ), executes a start of a thread t 2 . Then t 1 continues in segment n = # alloc (œÉ, i ‚àí 1) + 1 and t 2 continues in segment n + 1. Consequently, (s 1 , n) as well as (s 1 , n + 1) belongs to the graph, meaning that s 1 executes before n as well as before n + 1. Similarly, assume that a thread t 1 in position i, being in segment s 1 = C S (œÉ)(i ‚àí 1)(t 1 ), executes a join of a thread t 2 , being in segment s 2 = C S (œÉ)(i ‚àí 1)(t 2 ). Then t 1 continues in segment n = # alloc (œÉ, i‚àí1)+1 while t 2 terminates. Consequently (s 1 , n) as well as (s 2 , n) belongs to the graph, meaning that s 1 as well as s 2 executes before n. The formal definition of the segmentation graph is as follows.</p><p>Definition 5 (Segmentation graph) Given an execution trace œÉ = e 1 , . . . , e n . We say that a segmentation graph of œÉ is the directed graph G S = (N , R) where: N = {n | 0 ‚â§ n ‚â§ # alloc (œÉ, |œÉ|)} is the set of segments, and R ‚äÜ N √ó N is the relation given by (s 1 , s 2 ) ‚àà R if there exists a position</p><formula xml:id="formula_9">i ‚â• 1 s.t. œÉ[i] = s(t 1 , t 2 ) ‚àß s 1 = C S (œÉ)(i ‚àí 1)(t 1 ) ‚àß (s 2 = # alloc (œÉ, i ‚àí 1) + 1 ‚à® s 2 = # alloc (œÉ, i ‚àí 1) + 2), or œÉ[i] = j(t 1 , t 2 ) ‚àß (s 1 = C S (œÉ)(i ‚àí 1)(t 1 ) ‚à® s 1 = C S (œÉ)(i ‚àí 1)(t 2 )) ‚àß s 2 = # alloc (œÉ, i ‚àí 1) + 1.</formula><p>The following relation happens-before reflects how the segments are related in time during execution.</p><p>Definition 6 (Happens-Before relation) Let G S = (N , R) be a segmentation graph, and G * S = (N , R * ) its transitive closure. Then given two segments s 1 and s 2 , we say that s 1 happens before s 2 , denoted by s 1 s 2 , if (s 1 , s 2 ) ‚àà R * .</p><p>Note that for two given segments s 1 and s 2 , if neither s 1 s 2 nor s 2 s 1 , then we say that s 1 happens in parallel with s 2 . Before we can finally define what is a lock graph with segment information, we need to redefine the notion of lock context, C L (œÉ, i), of a trace œÉ and a position i, that was defined on page 6. In the previous definition it was a mapping from each thread to the set of locks owned by that thread at that position. Now we add information about what segment each lock was taken in. Formally, for a thread t ‚àà T œÉ we have the following :</p><formula xml:id="formula_10">C L (œÉ, i)(t) = {(o, s) | ‚àÉj : j ‚â§ i ‚àß œÉ[j] = l(t, o) ‚àß ¬¨(‚àÉk : j &lt; k ‚â§ i ‚àß œÉ[k] = u(t, o)) ‚àß C S (œÉ)(j)(t) = s}</formula><p>An edge in G L between two locks l 1 and l 2 means, as before, that there exists a thread t which owns an object l 1 while taking the object l 2 . The edge is as before labeled with t as well as the set of (gate) locks. In addition, the edge is now further labeled with the segments s 1 and s 2 in which the locks l 1 and l 2 were taken by t.</p><p>Definition 7 (Segmented and guarded lock graph) Given an execution trace œÉ = e 1 , e 2 , . . . , e n . We say that the segmented and guarded lock graph of œÉ is the minimal directed graph G L = (L œÉ , W, R) such that:</p><formula xml:id="formula_11">-W ‚äÜ N √ó (T œÉ √ó 2 LœÉ ) √ó N is the set of labels (s 1 , (t, g), s 2 )</formula><p>, each containing the segment s 1 that the source lock was taken in, a thread id t, a lock set g (these two being the labels of the guarded lock graph in the previous section), and the segment s 2 that the target lock was taken in, Each edge (l 1 , (s 1 , (t, g), s 2 ), l 2 ) in R is labeled with the thread t that took the locks l 1 and l 2 , and a lock set g, indicating what locks t owned when taking l 2 . The segments s 1 and s 2 indicate in which segments respectively l 1 and l 2 were taken.</p><formula xml:id="formula_12">-R ‚äÜ L œÉ √ó W √ó L œÉ is defined by (l 1 , (s 1 , (t, g), s 2 ), l 2 ) ‚àà R if</formula><p>In order for a cycle to be valid, and hence regarded as a true positive, the threads and guard sets occurring in labels of the cycle must be valid as before.</p><p>In addition, the segments in which locks are taken must now allow for a deadlock to actually happen. Consider for example a cycle between two threads t 1 and t 2 on two locks l 1 and l 2 . Assume further that t 1 takes l 1 in segment x 1 and then l 2 in segment x 2 while t 2 takes them in opposite order, in segments y 1 and y 2 respectively. Then it must be possible for t 1 and t 2 to each take their first lock in order for a deadlock to occur. In other words, x 2 must not happen before y 1 and y 2 must not happen before x 1 . This is expressed in the following definition, which repeats the definitions from Definition 3. </p><formula xml:id="formula_13">R, e = e ‚áí ¬¨ (seg 2 (e 1 ) seg 1 (e 2 ))</formula><p>where, for an edge e = (l 1 , (s 1 , (t, g), s 2 ), l 2 ) ‚àà R, thread(e) = t, guards(e) = g, seg 1 (e) = s 1 and seg 2 (e) = s 2 .</p><p>Valid cycles are now defined as follows.</p><p>Definition 9 (Unsegmented and unguarded cycles) Let œÉ be an execution trace and G L its segmented and guarded lock graph. We say that a cycle c ‚àà cycles(G L ) is an unsegmented and unguarded cycle if the guards of c are valid, the threads of c are valid, and the segments of c are valid. We denote by cycles s (G L ) the set of unsegmented and unguarded cycles in cycles(G L ). <ref type="figure">Figure 4</ref> presents an algorithm for constructing the segmentation graph and lock graph from an execution trace. The set of cycles in the graph G L , denoted by cylces s (G L ), see Definition 9, represents the potential deadlock situations in the program. The segmentation graph (G S ) and lock graph (G L ) have the structure as outlined in Definition 5 and Definition 7 respectively. The lock context (C L ) maps each thread to the set of locks owned by that thread at any point in time. Associated with each such lock is the segment in which it was acquired. The segment context (C S ) maps each thread to the segment in which it is currently executing. The algorithm should after this explanation and the previously given abstract definitions be self explanatory. Consider again the trace œÉ from Section 3. The segmented and guarded lock graph and the segmentation graph for this trace are both shown in <ref type="figure" target="#fig_7">Figure 5</ref>. The segmentation graph is for illustrative purposes augmented with the statements that caused the graph to be updated. We see in particular that segment 6 of thread T 3 executes before segment 7 of thread T 1 , written as 6 7. Segment 6 is the one in which T 3 executes lines 19 and 20, while segment 7 is the one in which T 1 executes lines 11 and 12. The lock graph contains the same number of edges as the guarded graph in <ref type="figure" target="#fig_3">Figure 3</ref>, and the same (thread,guard set) labels. However, now edges are additionally labeled with the segments in which locks are taken. This makes the cycle (19, 20) ‚Üî (11, 12) segment invalid since the target segment of the first edge (6) executes before the source segment of the second edge (7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Implementation and Experimentation</head><p>The algorithm presented in the previous section has been implemented in the Java PathExplorer (JPaX) tool <ref type="bibr" target="#b19">[20]</ref>. JPaX consists of two main modules, an nization problems. A synchronization problem can most obviously be missed if one or more of the synchronization statements involved in the problem do not get executed. To avoid being entirely in the dark in these situations, we added a coverage module to the system that records what lock-related instructions are instrumented and which of these that are actually executed.</p><p>JPaX's deadlock analyzer has been applied to three NASA case studies: a planetary rover controller for a rover named K9 programmed in 35 thousand lines of C++; a 7,5 thousand line Java version of the K9 rover controller used as part of an attempt to evaluate Java verification tools; and a planner named Europa programmed in approximately 5-10 thousand lines of C++. In the C++ scenarios ASCII log files were generated which were then read and analyzed by the tool. The Java version of the K9 controller was in particular created to evaluate a range of program verification technologies, among them JPaX, as described in <ref type="bibr" target="#b8">[9]</ref>; the other technologies included static analysis and model checking. In this Java experiment JPaX generally came out well in the comparison with the other tools, as being fast and effective. Errors were seeded by a control team and the study groups had as task to detect the errors with the different tools. The deadlock analysis tool found the seeded deadlocks usually during the first run of the tool. In the C++ version of the K9 rover controller the tool found a real deadlock potential that was unknown to the programmer. Also the first time the tool was run. This experiment was performed by hand instrumenting lock and unlock operations in the program, whereas the observer module could be used unmodified. In the planner Europa, the tool similarly found a real deadlock potential that was unknown to the programming team, also in the first run of the tool. This result caused the team to request an integration of the observer part into their development suite for future use.</p><p>The presented algorithm can miss (and hence not report) true positives in some rare cases, where for example a particular execution path causes a gate lock to prevent an error message from being issued, but where another path might contain a deadlock based on the same cycle. Furthermore, it might be argued that cyclic lock patterns represent bad programming style. For this reason, the best application of the algorithm might be to augment warnings given by the basic algorithm with additional information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions and Future Work</head><p>An algorithm has been presented for detecting deadlock potentials in concurrent programs by analyzing execution traces. The algorithm extends an existing algorithm by reducing the amount of false positives reported, and has been implemented in the JPaX tool. Although JPaX analyzes Java programs, it can be applied to applications written in other languages by replacing the instrumentation module. The advantage of trace analysis is that it scales well, in contrast to more formal methods, and in addition can detect errors that for example static analysis cannot properly detect. In current work, we further approach the problem of false positives by developing a framework for generating test cases from warnings issued by this tool. Such test cases will then directly expose the possible deadlocks. An experiment in this direction is described in <ref type="bibr" target="#b16">[17]</ref> where a model checker is used to "investigate" deadlock and data race warnings identified using dynamic analysis. Additional current work attempts to extend the capabilities of JPaX with new algorithms for detecting other kinds of concurrency errors, such as various forms of data races and communication deadlocks.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>x i . Let M : [A m ‚àí‚Üí B] be a finite domain mapping from elements in A to elements in B (the m ‚àí‚Üí operator generates the set of finite domain mappings from A to B, hence partial functions on A). We let M ‚Ä† [a ‚Üí b] denote the mapping M overridden with a mapping to b. That is, the ‚Ä† operator represents map overriding, and [a ‚Üí b] represents a map that maps a to b. Looking up the value mapped to by a in M is denoted by M [a]. We denote the empty mapping by [ ].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Example containing four lock cycles</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. The basic algorithm and the lock graph</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Guarded lock graph</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Formally, C S (œÉ) is the mapping with type: [N ‚Üí [T œÉ ‚Üí N ]], associated to trace œÉ, that maps each position into another mapping that maps each thread id to its current segment in that position. It is defined as follows. Let C init S = [0 ‚Üí [main ‚Üí 0]], mapping position 0 to the mapping that maps the main thread to segment 0. Then C S (œÉ) is defined by the use of the auxiliary function f 0 : T race √ó Context √ó P osition √ó Current Segment ‚Üí Context:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>there exists a thread t ‚àà T œÉ and a position i ‚â• 2 in œÉ such that: œÉ[i] = l(t, l 2 ) and (l 1 , s 1 ) ‚àà C L (œÉ)(i‚àí1)(t) and g = {l | (l , s) ‚àà C L (œÉ)(i‚àí1)(t)} and s 2 = C S (œÉ)(i‚àí1)(t)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Definition 8 (</head><label>8</label><figDesc>Valid threads, guards and segments) Let G L be a segmented and guarded lock graph of some execution trace and c = (L, W, R) a cycle in cycles(G L ), we say that: -threads of c are valid if: forall e, e ‚àà R, e = e ‚áí thread(e) = thread(e ) -guards of c are valid if: forall e, e ‚àà R, e = e ‚áí guards(e) ‚à© guards(e ) = ‚àÖ -segments of c are valid if: forall e, e ‚àà</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Segmented lock graph (above) and segmentation graph (below)</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Detecting Potential Deadlocks with Static Analysis and Run-Time Monitoring</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">D</forename><surname>Stoller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Parallel and Distributed Systems: Testing and Debugging (PADTAD) track of the 2005 IBM Verification Conference</title>
		<meeting>the Parallel and Distributed Systems: Testing and Debugging (PADTAD) track of the 2005 IBM Verification Conference<address><addrLine>Haifa, Israel</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2005-11" />
		</imprint>
	</monogr>
	<note>These proceedings</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">The Java Programming Language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gosling</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Applying Static Analysis to Large-Scale, Multi-threaded Java Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Artho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th Australien Software Engineering Conference</title>
		<editor>D. Grant</editor>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2001-08" />
			<biblScope unit="page" from="68" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Artho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
		<title level="m">High-level Data Races. Software Testing, Verification and Reliability (STVR)</title>
		<imprint>
			<date type="published" when="2003-12" />
			<biblScope unit="volume">13</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Using Block-Local Atomicity to Detect Stale-Value Concurrency Errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Artho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd International Symposium on Automated Technology for Verification and Analysis</title>
		<meeting><address><addrLine>Taiwan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Boolean and Cartesian Abstractions for Model Checking C Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Podelski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of TACAS&apos;01: Tools and Algorithms for the Construction and Analysis of Systems</title>
		<meeting>TACAS&apos;01: Tools and Algorithms for the Construction and Analysis of Systems<address><addrLine>Genova, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Rule-Based Runtime Verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Barringer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Fifth International VMCAI conference: Verification, Model Checking and Abstract Interpretation</title>
		<meeting>Fifth International VMCAI conference: Verification, Model Checking and Abstract Interpretation</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004-01" />
			<biblScope unit="volume">2937</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Reducing False Positives in Runtime Analysis of Deadlocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bensalem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002-10" />
		</imprint>
		<respStmt>
			<orgName>NASA Ames Research Center</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Internal report</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Experimental Evaluation of Verification and Validation Tools on Martian Rover Software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Brat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Drusinsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Giannakopoulou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lowry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Pasareanu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Visser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Washington</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods in System Design</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Bandera : Extracting Finite-state Models from Java Source Code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Corbett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">B</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hatcliff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">S</forename><surname>Pasareanu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robby</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Laubach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Conference on Software Engineering</title>
		<meeting>the 22nd International Conference on Software Engineering<address><addrLine>Limerich, Ireland</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Extended Static Checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Detlefs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Rustan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Saxe</surname></persName>
		</author>
		<idno>159</idno>
		<imprint>
			<date type="published" when="1998" />
			<publisher>Compaq Systems Research Center</publisher>
			<pubPlace>Palo Alto, California, USA</pubPlace>
		</imprint>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Multithreaded Java Program Test Generation. Software Testing and Verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Edelstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Farchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Nir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ratsaby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ur</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="volume">41</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Cross-Run Lock Discipline Checker for Java</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Farchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Nir-Buchbinder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ur</surname></persName>
		</author>
		<ptr target="http://alphaworks.ibm.com/tech/contest" />
	</analytic>
	<monogr>
		<title level="m">Tool presented at the Parallel and Distributed Systems: Testing and Debugging (PADTAD) track of the 2005 IBM Verification Conference</title>
		<meeting><address><addrLine>Haifa, Israel</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Model Checking for Programming Languages using VeriSoft</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th ACM Symposium on Principles of Programming Languages</title>
		<meeting>the 24th ACM Symposium on Principles of Programming Languages<address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-01" />
			<biblScope unit="page" from="174" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Instrumentation of Java Bytecode for Runtime Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Formal Techniques for Java-like Programs</title>
		<meeting>Formal Techniques for Java-like Programs<address><addrLine>Zurich, Switzerland, 2003. ETH Zurich</addrLine></address></meeting>
		<imprint>
			<biblScope unit="volume">408</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Runtime Checking of Multithreaded Applications with Visual Threads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Harrow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIN Model Checking and Software Verification</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000" />
			<biblScope unit="volume">1885</biblScope>
			<biblScope unit="page" from="331" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Using Runtime Analysis to Guide Model Checking of Java Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIN Model Checking and Software Verification, volume 1885 of LNCS</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="245" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Special issue of STTT containing selected submissions to the 4th SPIN workshop</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Pressburger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal on Software Tools for Technology Transfer</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="366" to="381" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
	<note>Model Checking Java Programs using Java PathFinder</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Monitoring Java Programs with Java PathExplorer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ro¬∏suro¬∏su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Workshop on Runtime Verification (RV&apos;01)</title>
		<meeting>the First International Workshop on Runtime Verification (RV&apos;01)<address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier Science</publisher>
			<date type="published" when="2001-07" />
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="page" from="97" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An Overview of the Runtime Verification Tool Java PathExplorer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ro¬∏suro¬∏su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods in System Design</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2004-03" />
		</imprint>
	</monogr>
	<note>Extended version of [19</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A Practical Method for Verifying Event-Driven Software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICSE&apos;99, International Conference on Software Engineering</title>
		<meeting>ICSE&apos;99, International Conference on Software Engineering<address><addrLine>Los Angeles, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Deadlock Detection in Distributed Database Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Knapp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="page" from="303" to="328" />
			<date type="published" when="1987-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Concurrent Programming in Java, Design Principles and Patterns</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lea</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Java Model Checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Stern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Skakkebaek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th IEEE International Conference on Automated Software Engineering</title>
		<meeting>the 15th IEEE International Conference on Automated Software Engineering</meeting>
		<imprint>
			<date type="published" when="2000-09" />
			<biblScope unit="page" from="253" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">An Automatic Run-Time Error Detection Tool</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Polyspace</surname></persName>
		</author>
		<ptr target="http://www.polyspace.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Eraser: A Dynamic Data Race Detector for Multithreaded Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Savage</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sobalvarro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="391" to="411" />
			<date type="published" when="1997-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Deadlock Detection in Distributed Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Singhal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="page" from="37" to="48" />
			<date type="published" when="1989-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Model-Checking Multi-threaded Distributed Java Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">D</forename><surname>Stoller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIN Model Checking and Software Verification</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000" />
			<biblScope unit="volume">1885</biblScope>
			<biblScope unit="page" from="224" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Visser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Brat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Lerda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Model Checking Programs. Automated Software Engineering</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2003-04" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
