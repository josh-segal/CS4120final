<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:45+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Multi-version and Single-display Strategy in Undo Scheme</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiangming</forename><surname>Yang</surname></persName>
							<email>yangjiangming@fudan.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing and Information Technology</orgName>
								<orgName type="laboratory">Shanghai key Laboratory of computer software testing and evaluating</orgName>
								<orgName type="institution">Fudan University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qiwei</forename><surname>Zhang</surname></persName>
							<email>qiweizhang@fudan.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing and Information Technology</orgName>
								<orgName type="laboratory">Shanghai key Laboratory of computer software testing and evaluating</orgName>
								<orgName type="institution">Fudan University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ning</forename><surname>Gu</surname></persName>
							<email>ninggu@fudan.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing and Information Technology</orgName>
								<orgName type="laboratory">Shanghai key Laboratory of computer software testing and evaluating</orgName>
								<orgName type="institution">Fudan University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Genxing</forename><surname>Yang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing and Information Technology</orgName>
								<orgName type="laboratory">Shanghai key Laboratory of computer software testing and evaluating</orgName>
								<orgName type="institution">Fudan University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhenyu</forename><surname>Liu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing and Information Technology</orgName>
								<orgName type="laboratory">Shanghai key Laboratory of computer software testing and evaluating</orgName>
								<orgName type="institution">Fudan University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">The Multi-version and Single-display Strategy in Undo Scheme</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Consistency maintenance is one of the most significant challenges in groupware systems. In groupware systems, the effect of incorrect execution will be more extensive for it is done in distributed group editors, so the user will have more dependence on Undo. While intention violation puzzle has never been addressed in any published work, it will destroy the consistency and lead to a crash. We propose a Mark &amp; Retracing based method to reach the goal of consistency maintenance and achieve Multi-version and Single-display strategy in undo scheme. It is different from operation transformation method and provides a new perspective into group editors.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Group editors are one of the most commonly used groupware applications <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b13">14]</ref>. It allows multiple users to participate in the editing and modification of shared data objects, such as word, graphics, and media documents, using a computer network. Techniques for building group editors have been widely applied and practiced <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b11">12]</ref>. Group editors have also been acknowledged as powerful research vehicles in exploring solution to consistency problems <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b13">14]</ref>.</p><p>Undo is a common operation, which can help user to quickly recover from the incorrect execution in document editor system and make the work more safe and efficient. The effect of incorrect execution will be more extensive for it is done in distributed group editors, so the user will have more dependence on Undo <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b17">18]</ref>. But it is very difficult to support Undo in distributed group editors <ref type="bibr" target="#b12">[13]</ref>. No current solution can do the complete support to Undo any operation at any time (dealing with intention violation puzzle) <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b10">11]</ref>.</p><p>DiskEdit is the first group editor system to support Undo operation. It allows undoing by any order, but this execution can not violate with any other existing operations <ref type="bibr" target="#b6">[7]</ref>.</p><p>AdOPTed allows Undo execution to more operations but it requires undoing by the time order of operations <ref type="bibr" target="#b7">[8]</ref>. Doctor C. Sun tried to support undoing any operation at any time in REDUCE system, but the system can not ensure the Undo operation's validity in some especial situations <ref type="bibr" target="#b9">[10]</ref>. C. Sun et al. <ref type="bibr" target="#b10">[11]</ref> fixed this bug by recording the order of document's characters additionally. But it needs extra memories and makes its complexity raised, which indicates that it is very difficult to do the make up only from the point of relationship among operations. The three systems above are all based on the operational transformation technique, because operational transformation method will never get the user's state when this user produces it and review the user's intention, thus the user's intention cannot be maintained. Violations between users' intentions will still lead to the inconsistent results among group users. We will discuss this problem below.</p><p>We must pay attention that even in the single document editor system, not all the Undo operations is valid. So we also need to avoid the situations below:</p><p>Undo an Insert operation when the data inserted has been removed.</p><p>Undo an undone operation.</p><p>To deal with group Undo, we should firstly ensure that its executions to all the local operations are valid. We call this "Undo Operation's Precondition". This paper is organized as follows. First, the intention violation puzzle and consistency model are introduced in Section 2 and 3, respectively. Then, the Mark &amp; Retrace struction and algorithm are proposed in Section 4. The proof is given in Section 5. In Section 6, Some Undo puzzles and intention violation puzzle are discussed. Finally, we compare with some related works and make the conclusion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Intention Violation Puzzle</head><p>For a long time many people only focus on the basic concurrency control because of the complexity of group editors system. Not until recently have they paid attention to the intention maintenance. In fact, the problem of intention-violation in group editors system, which is a part of intention maintenance, has been existed for a long time and hasn't been solved so far.</p><p>In follow discussion we use the same definition of casual ordering relation "→", independent relation "񮽙" and operation effects relation "≺" in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b13">14]</ref>. Suppose the initial state of sharing document is "abc". Operations C 1 and C 2 are executed at the same time, which expressed as C 1 񮽙 C 2 , and C 1 =Insert <ref type="bibr">["d", 2]</ref> and C 2 =Insert <ref type="bibr">["d", 2]</ref>.</p><p>Generic algorithm of group editors system defaults these two "d" as different so as to avoid intention-violation. However the involvement of Undo operation makes it necessary to attach importance to this problem. This problem becomes more urgent and hard to avoid and it especially concentrates on the concurrency intention-violation.</p><p>Consider a system including two users and the initial state of sharing document is vacant. <ref type="figure" target="#fig_0">Fig.1</ref> show order of user's producing and executing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 1. The order of users' producing and executing in intention-violation</head><p>It is obvious to see that user U 1 wants to delete "a" while user U 2 wants to reverse "a". In the distributed group editors system there exist a great deal of instances when two or more users' executions will are violating with each other and we call it intention-violation. (x, y) in the figures represents the user's state vector after an execution.</p><p>Intention-violation will badly affect the system and will destroy the results' consistency among the group users. This divergence will be larger and larger with the continuance of editor. It is worth attention that the expressions of execution toward one user are not always the same because of the different arriving time caused by the lag of network, which adds to our difficulty.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">A Consistency Model</head><p>Consistency maintenance is one of the most significant challenges in designing and realizing real-time group editors system <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b13">14]</ref>, in which CCI model framework has received most acknowledgement <ref type="bibr" target="#b13">[14]</ref>. Li et al. <ref type="bibr" target="#b4">[5]</ref> pointed out that it might have other operation effecting relation violation (ERV) problems in consistency maintenance <ref type="bibr" target="#b4">[5]</ref> and therefore proposed a CSM model. The condition S and M in CSM model is a more strict description of intention preservation in CCI model. We conclude this change into:</p><p>1. Causality preservation: all the operations are executed according to their casual ordering. For any two oper-</p><formula xml:id="formula_0">ations O 1 and O 2 , if O 1 → O 2 , then O 1 is executed before O 2 at all sites.</formula><p>2. Convergence: when the same set of operations has been executed at all sites, all copies of the shared document are identical.</p><p>3. Intention preservation: the effect of executing any operation at any site achieves the same effect as at its generation site.</p><p>(a) If O is a Delete operation, the same character is deleted at the both sites;</p><p>(b) For an operation O, one discretional operation is described as O'. Without loss of generality, assume C(O) ≺ C(O 񮽙 ) when they were firstly executed at one site. Then require it keep</p><formula xml:id="formula_1">C(O) ≺ C(O 񮽙 ) at any other sites. C(O) ≺ C(O 񮽙 )</formula><p>is a total order relation. This relation and any other transferred relations based on it should be maintained at all sites.</p><p>We will not discuss too much about more express methods. We just want to point out that revised CCI model is the conclusion of two previous models. It has guaranteed all the conditions in CCI and CSM model. So we can still call it CCI model. See also <ref type="bibr" target="#b1">[2]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">A Generic Mark &amp; Retrace Algorithm</head><p>State Vector based timestamping <ref type="bibr" target="#b0">[1]</ref> has been widely used to make judgment of the causal relationship between operations. In timestamping scheme, every site has its own state vector. After an operation's generation at one site, it will multicast together with the site's timestamping. Also, to achieve causality preservation, we only need to guarantee that a remote operation at one site satisfies the executing conditions <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b13">14]</ref>: The operation is causally-ready for execution. But even if it satisfies the causally ordered execution, the execution order will be different because of the different arriving order from every site. In next step we only have to focus on the topic that when an operation satisfies the execution conditions, how we can execute it correctly to maintain the convergence and intention preservation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">A Mark &amp; Retrace framework</head><p>The difficulty in achieving convergence and intention preservation is that there exist interactions between some independent operations which lead to the changes of operations' position and area. OT method will search the operations which may cause these changes and judge their effects first. And then it will adjust current operation to the correct position and area <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b13">14]</ref>. Mark &amp; Retrace method tries concealing such effects in document and converse the document to the user's view at the operations' generation time. In this way we can directly find an accurate position. The advantage of this method is that we do not have to think of the complex relations between operations. We only need to focus on each operation's effect on user's view.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2. Document's liner structure and user's view</head><p>Any document is a liner structure composed by characters. Without loss of generality, assume each character is indivisible and each operation only aims at one character. Actually any complex insertion or deletion operation can be quickly divided into a group of indivisible operations. So this assumption will not affect operation's ability. Under this assumption, each character may have several operations aiming at itself while each operation only aims at one character. Then we save the operation together with its timestamp to the character's liner node. So besides the information of character and its corresponding operations, we have also added the visible/invisible mark information on every liner structure of document, which shows whether the current node is visible or invisible. So a document structure might be expressed the <ref type="figure" target="#fig_1">Fig.2</ref>:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">The Retracing Procedure &amp; Control Algorithm</head><p>Assume the liner structure of document at site S is expressed as Doc S and S's state vector is SV S . Consider SV is a timestamp which satisfies the executing condition. Then the Retracing procedure can be expressed as Proc.1: if O wants the node to be ineffective then 6:</p><formula xml:id="formula_2">Procedure 1 Retracing (Doc S , SV ),</formula><formula xml:id="formula_3">Counter++ 7:</formula><p>if O wants the node to be effective then 8:</p><p>Counter-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>9:</head><p>if SV Oins ≤ SV and Counter=0 then 10:</p><p>Set the character node effective 11:</p><formula xml:id="formula_4">else 12:</formula><p>Set the character node ineffective 13: end for For every character node, assume that the Insert and Delete operations attached are timestamped by SV Oins and SV O del . And in Retracing procedure, "Delete" and "Undo operation toward Insert" mean want the node to be ineffective while "Undo operation toward Delete" means want the node to be effective.</p><formula xml:id="formula_5">Procedure 2 Control-Algorithm (Doc S , O), execute O on Doc S 1: Retracing(Doc S , SV O ) 2:</formula><p>Execute the operation O 3: Attach the operation with its timestamp to the character node.</p><formula xml:id="formula_6">4: SV S [R] ⇐ SV S [R] + 1 5: Retracing(Doc S , SV S )</formula><p>When a remote operation O generates at site R and timestamped by SV O is causally-ready for execution, we can express the execution process at site S whose state vector is SV S as Proc.2:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Operation Execution</head><p>The focus of this section is on how an operation O is executed:</p><p>If O denotes a Delete operation, just find the characters in the address space (count the effective character nodes in the liner structure of Doc S ) to find the position.</p><p>If O denotes an Insert operation, find the position in the address space (count the effective character nodes in the liner structure of Doc S to find the range between two adjoining effective character nodes), build a new character node, initialize the mark and Insert it to an accurate position within the range.</p><p>To realize the comparability between two Insert operations, we refer to the technique of maintaining operation transformation order <ref type="bibr" target="#b13">[14]</ref>. Given the T Order relation to represent the right-and-left relation between two inserted characters. Given two character nodes CN a and CN b . The attached operations are generated at site a and site b, and are timestamped by SV a and</p><formula xml:id="formula_7">SV b . We have T Order(CN a ) &lt; T Order(CN b ), iff: (1) sum(SV a ) &lt; sum(SV b ), or (2) a &lt; b when sum(SV a ) = sum(SV b ), where sum(SV ) = 񮽙 N −1 i=0 SV [i].</formula><p>The T Order relation is a total order which is transitive and any two T Order are comparable.</p><p>The process to determine an accurate position of a new operation O is to scan every Insert in this range from left to right. There are two kinds of Insert operations in this range. Some of these operations are casually before operation O. We force the new Insert O to insert on the left side of these Insert operations, so when Range-Scan scans to these operations, it will directly end itself (Range-Scan Function, line 9-12). The other Insert operations are concurrent with operation O. We compare them by comparing the T Order relation (Range-Scan Function, line 4-8). The inserting position is saved in the P . The new operation will be inserted on the left side of P . We can sketch the scanning process as Func.3.</p><p>Retracing process locates the Insert into a one-and-only range. Range-Scan process determines a one-and-only position for this Insert in the range and keeps it from being affected by concurrent operations. Then we explain how algorithm maintains the convergence and intention preservation in detail in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">A Consistency Model</head><p>Suppose that originally, every site has the same initial document state and that all the character node orders at every site are the same. Given n operations to be executed, we shall discuss how to ensure that all the sites still have the same character nodes orders after the operations' execution. return CN b</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Two operations</head><p>Consider the situation where there are two operations O 1 and O 2 . If they are casually ordered, since the execution order is certain, the result will be certain too. If they are concurrent, we prove the following theorem. Proof. First, consider the scan-range (i.e. the range between CN a and CN b in the Range-Scan process) of the two operations.</p><p>1. If the scan-ranges of the two operations have no shared part, it is obvious that the two operations do not affect each other due to the retracing process.  (b) P (A) = P (B). we will discuss this situation specially.</p><p>Next, we would like to prove situation above. Assume in two different execution order (O 1 is executed before or after O 2 ), operation O 1 will get two different insert positions P 1 and P 2 , which represent the neighboring character nodes (include visible and invisible) on the right of insert position. Without loss of generality, assume that P 1 represents the insert position when O 1 is executed before O 2 while P 2 represents the position when O 1 is executed after O 2 . There are only two possibilities which can make Range-Scan process return character node P 1 . One is T Order(O 1 ) &lt; T Order(P 1 ) (Range-Scan Function, line 5-6) and the other is P 1 → O 1 (Range-Scan Function, line 10-11).</p><p>First of all, we will prove that when C(P 1 ) 񮽙 = C(P 2 ), P 1 will not be O 2 . If O 2 is P 1 , since P 1 is obtained in the case that O 1 is executed before O 2 , in the Range-Scan process O 1 and O 2 will get the return value at the same position and satisfies T Order(O 1 ) &lt; T Order(P 1 ). So when O 2 is executed first, O 1 and O 2 will also get the return value at the same position. Because T Order(O 1 ) &lt; T Order(P 1 ), P 2 is O 2 and C(P 1 ) = C(P 2 ), which contradicts our assumption, the assumption is false. i.e., P 1 will not be O 2 .</p><p>Let's go on to discuss the situation when C(P 1 ) ≺ C(P 2 ). If the position is obtained in the situation of P 1 → O 1 , when O 2 is executed before O 1 , there are two possibilities. (1) if O 2 is inserted on the right of P 1 , then operation O 1 will get the same position P 1 as well. <ref type="formula">(2)</ref> if O 2 is inserted on the left of P 1 (C(O 2 ) 񮽙 = C(P 1 )), the only result will be C(O 2 ) &lt; C(P 1 ), which contradicts with assumption. If the position is obtained in the situation of T Order(O 1 ) &lt; T Order(P 1 ), in Range-Scan process, only when insert position of O 2 is on the right of P 1 can make P 1 &lt; P 2 by line 7-8 in Range-Scan process. </p><formula xml:id="formula_8">we have C(O 2 ) ≺ C(O 1 ).</formula><p>Since there is no other operation on the left of O1 which is causally ordered with O 1 , O 2 can only get the return value on the left of P 1 by line 5-6 in Range-Scan process. So its T Order certainly precedes the T Order of operation attached on the character node of return position, which certainly precedes T Order of O 1 . So we have T Order(O 1 ) &gt; TOrder(O 2 ) by transitive. But according to Range-Scan, only when T Order(O 1 ) &lt; T Order(O 2 ) can we get C(P 2 ) ≺ C(P 1 ) after O 1 's execution, which contradicts the result T Order(O 1 ) &gt; T Order(O 2 ) we got before. So the assumption is false.</p><p>The execution effects of the two operations have no relation with their execution order.2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">N operations</head><p>Theorem 2 Orders of character nodes at every site are still consistent when n operations have been executed.</p><p>Proof. First, when all the document orders at every site are consistent, executing two operations under the execution condition, a consistent order is certain to be obtained. Then suppose the orders of character nodes at every site are consistent after we have executed n − 1 operations in the order which meets the execution condition. What we want to prove is that the orders of character nodes at every site are still consistent when n operations have been executed.</p><p>Suppose executing n operations under the execution condition at two sites, whose order can be expressed as which still meet the execution condition. According to the assumption, the orders of character nodes at every site are consistent after we have executed n − 1 operations in the order which meets the execution condition, so the orders of document's character nodes are still consistent after these two sequences have been executed. So all the orders of character node at the sites' are consistent after n operations have been executed in the order which meets the execution condition. <ref type="bibr" target="#b1">2</ref> </p><formula xml:id="formula_9">O 1 O 2 O 3 . .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Summary</head><p>We have proved that after executing several operations in any order which meets the execution condition, the orders of character nodes at every site will keep consistent. It is to say that the order in which two operations are executed at one site for the first time has been kept at any other sites, which satisfies condition (b) of intention preservation. In addition, the key to the correctness of a Delete operation is that it can find the correct effective character node and the consistency of orders of character node ensures it to count to the correct effective character node, which satisfies condition (a) of intention preservation. Both of the orders of character nodes and effective/ineffective marks of every character node at all sites are kept consistent, so the documents are convergent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Some Undo Puzzles</head><p>C.Sun et al. pointed out four Undo puzzle in <ref type="bibr" target="#b9">[10]</ref>. The evaluation of the ability to solve the difficult problems is an important parameter of a system.</p><p>We have enumerated the processes of dealing with some problems by Mark &amp; Retrace and compare them with the methods by other systems in <ref type="bibr" target="#b17">[18]</ref>. Comparing with the new method(We have a new Retracing process) in this paper, only the analyses of overlapping deletes puzzle is different. But in Retracing procedure, the set of valid operations in a given is certain so the result of counter is also certain and the visible/invisible mark as well. When there are several deletions in algorithm, the character node is visible only when all the deletions are undone, otherwise it will keep invisible.</p><p>Mark &amp; Retrace does not need to do any special disposal to these puzzles. This kind of repeated Delete operations is actually an execution violation which is the cause of intention-violation. We will discuss it in the next part.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Intention Violation Puzzle</head><p>Directly broadcasting the current state of users who cause the intention-violation of course can solve the problem. However it needs high speed of local response so we hope to reach our goal by means of local data.</p><p>To deal with violation is easy but to judge the origin of violation is complex. Intention-violation may happen when several users are doing multi-execution, so how to separate all the operations causing intention-violation has been the key to solve the problem.</p><p>The two independent and separated execution sequences apply us the base of selection. If the effects of two independent sequences are different, there must exists an intention violation. In our group editors system, we will warn users for intention violation events. When there exists intention violation, the algorithm maintains the intention of users if SV Ot ≤ SV O1 and SV Ot ≤ SV O2 then 5:</p><formula xml:id="formula_10">R 1 ⇐ R 1 ∪ {O t } 6:</formula><p>if SV Ot ≤ SV O1 and SV Ot ≤ SV O2 then 7:</p><formula xml:id="formula_11">R 2 ⇐ R 2 ∪ {O t } 8:</formula><p>if SV Ot ≤ SV O1 and SV Ot ≤ SV O2 then 9:</p><formula xml:id="formula_12">R 3 ⇐ R 3 ∪ {O t } 10: end for 11: R 1 ⇐ R 1 ∪ R 3 , R 2 ⇐ R 2 ∪ R 3 12:</formula><p>When it is finished, the two sequences of operations are saved in R 1 and R 2 .</p><p>who want character node to be invisible, namely Multiversion and Single-display strategy <ref type="bibr" target="#b14">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Related Works</head><p>The initial concept of Mark &amp; Retrace was proposed early in <ref type="bibr" target="#b16">[17]</ref> but was not able to solve the dOPT puzzle. It needs additional disposal when there are several concurrent operations at one position, but <ref type="bibr" target="#b16">[17]</ref> lack such support to this situation.</p><p>Algorithm dOPT, adOPTed and GOTO are based on TP2, <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b13">14]</ref>, but cannot fully satisfy TP2. NICE reported notification server <ref type="bibr" target="#b8">[9]</ref> and SOCT3/4 used the sequence method <ref type="bibr" target="#b15">[16]</ref>, but neither of them is able to resolve the false-tie (ERV) puzzle. GOT maintains the convergence by the method of a global total order of execution. But Li et al. <ref type="bibr" target="#b4">[5]</ref> pointed out that the original GOT will fail in the case of complicated false-tie (ERV) scenarios but the details have not been published. <ref type="bibr">Li et al.</ref>[5] also pointed out that although the solution of false-tie (ERV) has been realized in <ref type="bibr" target="#b11">[12]</ref>, it is still not published. Imine et al. <ref type="bibr" target="#b3">[4]</ref> tried to support TP2 by expanding IT function but fails in solving dOPT puzzle. Li et al. <ref type="bibr" target="#b4">[5]</ref> reported a solution and also gave the proof. We have explained that our Mark &amp; Retrace method can satisfy the CCI model in fully replicated architecture, deal with dOPT puzzle and false-tie(ERV) puzzle and get the operation's amortized efficiency O(c · logn) <ref type="bibr" target="#b1">[2]</ref>.</p><p>We discuss the support to undo operation based on the current work at last. Among the algorithms above, adOPTed supports the sequential undo operations by maintaining a multiple dimensions data structure <ref type="bibr" target="#b7">[8]</ref>. REDUCE supports undo any operation at any time by inversing the undo operation <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>. But when facing undo puzzles, it needs to maintain the operations relation additionally, which adds to the time complexity of algorithm (nonlinear time complexity). Mark &amp; Retrace method also can support any undo and can solve the undo puzzles in <ref type="bibr" target="#b17">[18]</ref> more easily while keeping the execution efficiency O(c log n) <ref type="bibr" target="#b1">[2]</ref>. None of the current methods has considered the intention violation in undo operation <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b10">11]</ref>. Although REDUCE can maintain convergence in the intention violation and obtain the effect of Multi-version and Single-display strategy, it lacks related examining method and enough hints to users. In this paper, we propose a new solution to Multi-version and Singledisplay strategy and plan to discuss the Multi-version and Multi-display strategy and its related examining and warning method in the further work. More information is available in <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b17">18]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Conclusions</head><p>In this paper we propose a strategy which can maintain CCI model in fully replicated architecture, which is different from OT. It does not ensure the operation's execution correctness by modifying the operation but by Retracing process. Since Mark &amp; Retrace process will not affect the left-and-right relation between characters, it is easier to maintain operations' order. It can not only achieve all the consistency targets in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b13">14]</ref>, but can support any undo in replicated architecture more efficiently as well.</p><p>For space reason, we have not given more details of efficiency optimization. More information is available in <ref type="bibr" target="#b1">[2]</ref>. We plan to discuss more about the Multi-version and Multidisplay strategy in undo intention violation and the support to update operation and tree based structures of Mark &amp; Retrace Algorithm.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Theorem 1</head><label>1</label><figDesc>If O 1 and O 2 are concurrent, the execution ef- fects of two operations have no relation with their execution order.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>2 .</head><label>2</label><figDesc>If the scan-ranges of the two operations have one shared part. As shown in Fig.3, −→ AC denotes O 1 's scan- range, − − → BD denotes O 2 's scan-range. The relative po- sition (left or right) of C and D is ignored in our fol- lowing proof since it has no impact on the proof. Then consider two cases: (a) P (A) 񮽙 = P (B). Without loss of generality, as- sume P (A) &lt; P(B). If O 1 ends with a return position in − − → AB, it is obvious that the operations do not affect each other. If O 1 ends with a return</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Scan-Range of two operations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>retrace the address space of Doc S with timestamp SV 1: for all character node CN i of liner structure of Doc S do 2: Set Counter ⇐ 0 3: Consider any operation O of CN i 4: if O is timestamped by SV O and SV O ≤ SV then 5:</head><label></label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Function 3 Range-Scan(CN a , CN b , CN new ), scan charac- ter nodes between CN a and CN b , then return the position of CN new 1: P ⇐ Nill and CN scan ⇐ CN a .right 2: repeat 3: Compare CN new with CN scan 4: if CN scan 񮽙 CN new then 5: if T Order(CN new ) &lt; T Order(CN scan ) and P = Nill then) &gt; T Order(CN scan ) and CN scan → P then 8: P ⇐ Nill 9: if CN scan → CN new then 10: if P = Nill then14: until CN scan = CN b 15: if P 񮽙 = Nill then</head><label>3</label><figDesc></figDesc><table>6: 

P ⇐ CN scan 

7: 

if T Order(CN new 11: 

P ⇐ CN scan 

12: 

exit the loop 

13: 

CN scan ⇐ CN scan .right 
16: 

return P 
17: else 

18: 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>It satisfies T Order(O 1 ) &gt; TOrder(O 2 ) and O 2 → P 1 . Furthermore, since O 1 񮽙 O 2 , P 1 has been executed before O 2 , which contradicts the execution conditions caused by O 2 → P 1 . So the assumption is false. When C(P 2 ) ≺ C(P 1 ), if O 2 is inserted on the right of P 1 , since it is certain that P 1 → O 2 or P 1 񮽙 O 2 , whether it is executed before or after O 1 will not affect O 1 's execution according to the Range-Scan process. Since O 2 is not P 1 ,</head><label>satisfies</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>. O n and O k1 O k2 O k3 . . . O kn . Without loss of gen- erality, suppose O ki = O 1 . Since O 1 O 2 O 3 . . . O n meets the execution condition, O ki and O k1 O k2 O k3 . . . O ki−1 are concurrent. The change of any two concurrent operations' execution order does not affect the result of the document, so we can switch O ki with O ki−1 , O ki−2 , O ki−3 , . . . , O k2 and O k1 in turn and obtain O ki O k1 O k2 . . . O ki−1 O ki+1 . . . O kn . Since O ki = O 1 and after the adjustment the first operation of every sequence is O 1 , we can execute the first operation of every se- quence first. Here, all the sites' orders are still consistent and the operation sequences to be executed are changed to O 2 O 3 . . . O n and</head><label></label><figDesc></figDesc><table>O k2 O k3 . . . O ki−1 O ki+1 . . . O kn </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Procedure 4 Separate violation operations 1: Suppose two operation O 1 and O 2 with timestamp SV O2 and SV O1 can directly cause the violation 2: Operation set R 1 , R 2 , R 3 are initially empty. R 1 ⇐ R 1 ∪ {O 1 } and R 2 ⇐ R 2 ∪ {O 2 } 3: for all operaion O t which is timestamped by SV Ot inim , ∀t, 1 ≤ t ≤ m do</head><label>4</label><figDesc></figDesc><table>corresponding operations to this character node 
O i1 , O i2 , O i3 , . . . , O 4: 

</table></figure>

			<note place="foot">Proceedings of the 2005 The Fifth International Conference on Computer and Information Technology (CIT&apos;05) 0-7695-2432-X/05 $20.00 © 2005 IEEE</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Acknowledgments</head><p>The authors wish to thank Yan Yu for her help in improving the final presentation of this article. The authors are very appreciative to Du Li, Chengzheng Sun for their suggestions. The work reported in this paper has been supported by the National Natural Science Foundation of China (60473124) and Shanghai Development Foundation of Science and Technology (036505001).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Concurrency control in groupware systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A</forename><surname>Ellis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">J</forename><surname>Gibbs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Conference on the Management of Data</title>
		<meeting>the ACM Conference on the Management of Data<address><addrLine>Portland Oregon</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1989-05" />
			<biblScope unit="page" from="399" to="407" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Consistency maintenance based on the mark &amp; retrace technique in groupware systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on Supporting Group Work</title>
		<meeting>ACM Conference on Supporting Group Work<address><addrLine>Sanibel Island, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-05" />
		</imprint>
	</monogr>
	<note>Under review</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Document marking scheme for preserving intention of operation in cooperative editing system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Luo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Software</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="160" to="164" />
			<date type="published" when="1999-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Proving correctness of transformation functions in real-time groupware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Imine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Molli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Oster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rusinowitch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European CSCW&apos;03 Proceedings</title>
		<imprint>
			<date type="published" when="2003-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Preserving operation effects relation in group editors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on CSCW 2004</title>
		<meeting>ACM Conference on CSCW 2004<address><addrLine>Chicago, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004-11" />
			<biblScope unit="page" from="437" to="446" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Ensuring content and intention consistency in real-time group editors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th IEEE International Conference on Distributed Computing Systems (ICDCS&apos;04)</title>
		<meeting>the 24th IEEE International Conference on Distributed Computing Systems (ICDCS&apos;04)</meeting>
		<imprint>
			<date type="published" when="2005-03" />
			<biblScope unit="page" from="748" to="755" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A framework for undoing actions in collaborative system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Knister</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer-Human Interaction</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="295" to="330" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An integrating, transformation-oriented approach to concurrency control and undo in group editors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ressel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Nitsche-Ruhland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gunzenbauser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on CSCW 1996</title>
		<meeting>ACM Conference on CSCW 1996</meeting>
		<imprint>
			<date type="published" when="1996-11" />
			<biblScope unit="page" from="288" to="297" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Flexible notification for collaborative systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on CSCW 2002</title>
		<meeting>ACM Conference on CSCW 2002<address><addrLine>Chicago, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-11" />
			<biblScope unit="page" from="77" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Undo any operation at any time in group editors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on CSCW 2000</title>
		<meeting>ACM Conference on CSCW 2000<address><addrLine>Philadelphia, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-12" />
			<biblScope unit="page" from="191" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Undo as concurrent inverse in group editors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer-Human Interaction</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="309" to="361" />
			<date type="published" when="2002-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">The coword and copowerpoint project</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Operation transformation in realtime group editor: issuer, algorithm, and achievement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A</forename><surname>Ellis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on CSCW 1998</title>
		<meeting>ACM Conference on CSCW 1998<address><addrLine>Seattle, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-11" />
			<biblScope unit="page" from="59" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Achieving convergence, causality-preservation, and intentionpreservation in real-time cooperative editing systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer-Human Interaction</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="63" to="108" />
			<date type="published" when="1998-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Operational transformation for collaborative word processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on CSCW 2004</title>
		<meeting>ACM Conference on CSCW 2004<address><addrLine>Chicago, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-11" />
			<biblScope unit="page" from="437" to="446" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Copies convergence in a distributed realtime collaborative environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Vidot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ferrie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Suleiman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Conference on CSCW 2000</title>
		<meeting>ACM Conference on CSCW 2000<address><addrLine>Philadelphia, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-12" />
			<biblScope unit="page" from="171" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A concurrency control method based on document marking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Gu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Research and Development</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1662" to="1667" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A document mark based on method supporting group undo</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CSCW&apos;2004 Workshop on Collaborative Editing Systems</title>
		<meeting><address><addrLine>Chicago, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-11" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
