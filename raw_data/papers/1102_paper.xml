<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:38+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Efficient Algorithm for the Exact Analysis of Multiclass Queueing Networks with Large Population Sizes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giuliano</forename><surname>Casale</surname></persName>
							<email>giuliano.casale@polimi.it</email>
							<affiliation key="aff0">
								<orgName type="institution">Neptuny R&amp;D via Durando</orgName>
								<address>
									<addrLine>10-G</addrLine>
									<postCode>I-20158</postCode>
									<settlement>Milan</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">Politecnico di Milano -DEI</orgName>
								<address>
									<addrLine>Via Ponzio 34/5</addrLine>
									<postCode>I-20133</postCode>
									<settlement>Milan</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An Efficient Algorithm for the Exact Analysis of Multiclass Queueing Networks with Large Population Sizes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C4 [Performance of Systems]: Modeling techniques General Terms Algorithms</term>
					<term>Performance</term>
					<term>Theory Keywords Product-form queueing networks</term>
					<term>computational algorithms</term>
					<term>exact analysis</term>
					<term>normalizing constant</term>
					<term>multiclass models</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We introduce an efficient algorithm for the exact analysis of closed multiclass product-form queueing network models with large population sizes. We adopt a novel approach, based on linear systems of equations, which significantly reduces the cost of computing normalizing constants. With the proposed algorithm, the analysis of a model with N circulating jobs of multiple classes requires essentially the solution of N linear systems with order independent of population sizes. A distinguishing feature of our approach is that we can immediately apply theorems, solution techniques, and de-compositions for linear systems to queueing network analysis. Following this idea, we propose a block triangular form of the linear system that further reduces the requirements, in terms of both time and storage, of an exact analysis. An example illustrates the efficiency of the resulting algorithm in presence of large populations.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Analytical performance modeling of computer and communication systems is often carried out using queueing network models. For historical reasons, closed product-form networks <ref type="bibr" target="#b1">[2]</ref> have been the focus of the field for over twenty Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. SIGMetrics/Performance'06, <ref type="bibr">June 26-30, 2006</ref> years <ref type="bibr" target="#b27">[28]</ref>. Using these models, classic performance problems as the capacity planning of computer systems can be easily tackled, typically with much less computational effort than simulation (see, e.g., <ref type="bibr" target="#b16">[17]</ref> for an overview of applications). Moreover, computational algorithms for models with product-form solution have largely inspired further research. For instance, queueing networks with extended features that are successfully applied in several areas including software performance evaluation, parallel system analysis, and modeling of networks with priorities or blocking (e.g., <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b36">37]</ref>), can be solved by means of modified versions of the algorithms proposed for product-form networks.</p><p>The distinguishing feature of product-form models is that simple closed-form expressions are known for the equilibrium distribution of network state probabilities. The challenge is to efficiently compute the normalizing constant that assures that state probabilities sum to one. Excellent developments in the field <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b33">34]</ref> have shown that exact solution methods are computationally feasible in several cases of interest. However, the computational requirements usually become prohibitive when a large multiclass population is present in the network. This has led to the well-known conclusion that typically multiclass queueing networks are intractable for large population sizes. This is a severe difficulty of the theory that has been addressed for practical purposes only by approximation techniques as local iterative methods (e.g., <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b35">36]</ref>), bounds and asymptotic expansions (e.g., <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b38">39]</ref>), or with the truncation of Euler summations when numerically inverting the generating function of the normalizing constant <ref type="bibr" target="#b9">[10]</ref>.</p><p>The results presented in this paper indicate that efficient exact algorithms for multiclass models with large populations are possible. In the following sections, we introduce a novel approach for computing normalizing constants that is efficient even in this difficult case. The algorithm is based on the solution of systems of linear equations involving normalizing constants, and follows from a simple consideration. Several recurrence equations for normalizing constants have been proposed in previous works <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b32">33]</ref>. Clearly, each of them gives an alternative description of the structure of the normalizing constant. We propose to use the simultaneous information of a set of recurrence equations to reduce the cost of computing normalizing constants.</p><p>In particular, the proposed algorithm has the following structure. We consider a set of networks derived from the model to be solved, and defined in such a way that all normalizing constants can be related by a system of linear equations. Then, we increase in a linear fashion, and simultaneously for all networks, the total population from 1 to N , being N the sum of class populations in the original model. After each increase, we compute normalizing constants using the linear system. Finally, we determine performance measures of interest for the original model. In this way, an exact analysis requires essentially the solution of N linear systems. Moreover, despite the composition of the set of networks, and hence linear system structure, may change while increasing populations, linear system order is always independent of population sizes. As a consequence, we show that the computational cost is mostly determined by the number of queues and classes, rather than by the total population, which is usually the largest of the three parameters.</p><p>There are benefits and drawbacks connected to the introduction of linear systems of equations into queueing network analysis. Besides the significant reduction of computational complexity, that is anyway a fundamental motivation, there are other significant advantages. For instance, the new approach promotes the application of linear algebra techniques to the analysis of product-form networks. We show an application of this idea by defining a block triangular form of the linear system coefficient matrix that significantly reduces time and storage requirements. Moreover, the diffusion of specialized software for linear algebra, like computer algebra systems (e.g., <ref type="bibr" target="#b37">[38]</ref>), may reduce implementation efforts.</p><p>We found instead two drawbacks regarding uniqueness and numerical accuracy of solutions achievable with standard (inexact) linear system solvers. Concerning the latter, we believe that the new algorithm, besides the related theoretical results, is also of practical interest due to its efficiency. Thus, granting result correctness is a fundamental objective of the present analysis. A simple and definitive solution to numerical accuracy problems follows by adopting an exact linear system solver in implementations (e.g., <ref type="bibr" target="#b5">[6]</ref>). This has a limited impact on the asymptotic complexity of the algorithm that remains, also in the worst case, the exact technique of choice for multiclass models with large population sizes. Further, an exact solution let us avoid floating-point range exceptions that frequently arise in normalizing constant algorithms. Concerning uniqueness, we discuss some cases where the linear system does not have a unique solution due to a singular coefficient matrix. We propose strategies to address the problem.</p><p>The paper is organized as follows. In Section 2 we give preliminary definitions. Related work is critically analyzed in Section 3, where we also introduce the solution approach based on linear systems. Section 4 defines the algorithm that is further examined in Section 5 using linear algebra techniques. Computational requirements are discussed in Section 6. A numerical example is presented in Section 7. Finally, Section 8 gives conclusions and outlines future work. Theorem proofs are reported in the final appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARIES AND NOTATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Multiclass Closed Queueing Networks</head><p>Let us consider a closed product-form model composed by M load-independent queues, R job classes and an arbitrary number of delays. The population size for class s is Ns, and the population vector is N ≡ (N1, . . . , Ns, . . . , NR). We denote by N = È R s=1 Ns the total population. The loading ρ ks (also called in the literature service demand) is the product between the mean service time per visit and the mean number of visits of class s at queue k. We denote by ρ0s the sum of delays for class s.</p><p>Exact algorithms considered in the following sections perform recursions on the number of jobs and queues in the model. Without loss of generality, we indicate the population currently processed by the recursion with the Rdimensional vector n ≡ <ref type="bibr">(n1, . . . , ns, . . . , nr, 0, . . . , 0)</ref>, where ns &gt; 0, 1 ≤ s ≤ r. Hence r, r ≤ R, is the number of non-empty classes of the current population. We denote by n = È r s=1 ns the total population of n. Let 0 be the zero vector, and let es be a vector of all zeros except for the s-th element that is one. In several algorithms, e.g., Convolution <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b32">33]</ref>, LBANC <ref type="bibr" target="#b8">[9]</ref>, and MVA <ref type="bibr" target="#b33">[34]</ref>, n spans the population set</p><formula xml:id="formula_0">prod(N) = {n | 0 ≤ n ≤ N} ,<label>(1)</label></formula><p>with cardinality card(prod(N)) = É R s=1 (Ns + 1). As we show later in the paper, a class recursion algorithm as RE-CAL <ref type="bibr" target="#b12">[13]</ref> may be instead reformulated as a recursion on</p><formula xml:id="formula_1">lin(N) = {0, e1, 2e1, . . . , N1e1, N1e1 + e2, N1e1 + 2e2, . . . , N1e1 + N2e2, . . . , N}, (2)</formula><p>where card(lin(N)) = N + 1. A graphical comparison of the two sets is given in <ref type="figure" target="#fig_2">Figure 1</ref>. Note that for large multiclass populations card(lin(N)) &lt;&lt; card(prod(N)). While recurring, several intermediate models are solved for each population n. We denote by j ≡ j(n) the population of an intermediate model solved when the current population is n. The related network structure is specified by a multiplicity vector m ≡ (m1, . . . , m k , . . . , mq) such that, for each queue type k, 1 ≤ k ≤ q, the intermediate model contains m k ≥ 1 queues of that type <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b23">24]</ref>. Here q, q ≤ M , is the number of queue types for the current population. The total number of queues is m = È q k=1 m k . All m k queues of type k have identical loadings for the r nonempty classes. With a slight abuse of notation, we denote by ρ ks the loading of class s jobs at queues of type k. If not otherwise stated, we assume that for two queue types k and k 񮽙 such that k 񮽙 = k 񮽙 there exists at least one class s, 1 ≤ s ≤ r, such that ρ ks 񮽙 = ρ k 񮽙 s . Hence, each queue type defines a balanced subnetwork of maximum size. Note that by this definition q ≡ q(r), and q is non-decreasing with r.</p><p>We call input network a network that has the same M queues of the model that we want to solve recursively, but with population not necessarily equal to N. The structure of the input network for the current population n is denoted by M ≡ (M1, . . . , M k , . . . , Mq), where È q k=1 M k = M . Very often, intermediate model structure will be specified using M. For instance, an intermediate model with multiplicity vector m = M + eq can be obtained by adding to the input network with population n a queue of type q.</p><p>For the rest of the paper, if not otherwise stated, k, s, c, 1 ≤ k ≤ q, 1 ≤ s ≤ r, 1 ≤ c ≤ r − 1, will index queue types and non-empty classes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Summarizing Example</head><p>As a summarizing example, let us assume that we want to solve recursively a model with M = 3, R = 2, N = (8, 13), delays ρ01 = 3, ρ02 = 7, and loadings ρ11 = 10, ρ12 = 5,</p><formula xml:id="formula_2">(1,0) (0,1) (1,1) (2,0) (0,2) (2,1) (0,3) (1,2) (2,2) (2,3) (1,3) (0,0) a) prod(N) (0,0) (1,0) (2,0) (2,1) (2,2) (2,3)</formula><p>b) lin(N) <ref type="figure" target="#fig_2">Figure 1</ref>: Population sets for N = (2, 3) ρ21 = 10, ρ22 = 9, ρ31 = 10, ρ32 = 9. For illustration purposes, we recursively process, for each n ∈ lin(N), a set of 2(q + 1) intermediate models (m, j) with multiplicity</p><formula xml:id="formula_3">m ∈ {M, M + e1, . . . , M + eq},<label>(3)</label></formula><p>and population</p><formula xml:id="formula_4">j ∈ {n, n − er}.<label>(4)</label></formula><p>By the definitions, we have the following cases:</p><p>• if 1 ≤ n1 ≤ 8 and n2 = 0 then r = 1. In this case all queues have identical loadings, thus q = 1, ρ01</p><formula xml:id="formula_5">= 3, ρ11 = 10, M = 3e1, (m, j) ∈ {(3e1, n1e1), (3e1, n1e1 − e1), (4e1, n1e1), (4e1, n1e1 − e1)}.</formula><p>• If 1 ≤ n1 ≤ 8 and 1 ≤ n2 ≤ 13 then r = 2, q = 2, ρ01 = 3, ρ02 = 7, ρ11 = 10, ρ12 = 5, ρ21 = 10, ρ22 = 9,</p><formula xml:id="formula_6">M = e1 + 2e2, (m, j) ∈ {(e1 + 2e2, n1e1 + n2e2), (e1 + 2e2, n1e1 + n2e2 − e2), (2e1 + 2e2, n1e1 + n2e2), (2e1 + 2e2, n1e1 + n2e2 − e2), (e1 + 3e2, n1e1 + n2e2), (e1 + 3e2, n1e1 + n2e2 − e2)}.</formula><p>Models for n = 0 are solved using termination conditions specified later. Thus, we do not define a specific notation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Normalizing Constant Equations</head><p>We denote by G ≡ G(m, j) the normalizing constant of a model with multiplicity m and j = (j1, . . . , js, . . . , jr, 0, . . . , 0) jobs. From the BCMP theorem <ref type="bibr" target="#b1">[2]</ref>, it follows that</p><formula xml:id="formula_7">G = 񮽙 m 񮽙 i=0 fi(ji),<label>(5)</label></formula><p>where the summation is taken on the state-spacé</p><formula xml:id="formula_8">(j0, . . . , ji, . . . , jm) | m 񮽙 i=0 jis = js, jis ≥ 0, 1 ≤ s ≤ r µ ,</formula><p>where ji = (ji1, . . . , jis, . . . , jir), is the population at station i, and the product-form factors fi for queues and delays (the latter is associated to the index i = 0) are defined as</p><formula xml:id="formula_9">fi(ji) = ´ É s ρ j 0s 0s /j0s!, if i = 0, ( È s jis)! É s ρ j is is /jis!, if 1 ≤ i ≤ m.<label>(6)</label></formula><p>Note that the number of operations required by <ref type="formula" target="#formula_7">(5)</ref>   Throughout the paper, we consider the following normalizing constant recurrence equations. The convolution expressions <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b32">33]</ref> for G, i.e.,</p><formula xml:id="formula_10">G = G −k + r 񮽙 s=1 ρ ks Gs, 1 ≤ k ≤ q,<label>(7)</label></formula><p>and for G +k , i.e.,</p><formula xml:id="formula_11">G +k = G + r 񮽙 s=1 ρ ks G +k s , 1 ≤ k ≤ q.<label>(8)</label></formula><p>Note that, without loss of generality, we consider only q convolution expressions among the m possible, referring to the removal of any of the identical queues of type k.</p><p>We also introduce the network population constraints for the models with j = n, i.e.,</p><formula xml:id="formula_12">nsG = ρ0sGs + q 񮽙 k=1 m k ρ ks G +k s , 1 ≤ s ≤ r.<label>(9)</label></formula><p>which are an application of Little's Law <ref type="bibr" target="#b29">[30]</ref>, and generalize to the case m k &gt; 1 a similar set of equations presented in <ref type="bibr" target="#b31">[32]</ref>. A straightforward proof of <ref type="formula" target="#formula_12">(9)</ref> is given at the end of this section. Termination conditions for recursions based on (7)-(9) are G = f0(j), for normalizing constants of models with m = 0, and G = 1, for normalizing constants of models with j = 0. The conditions are consistent assuming 0 0 = 1. Performance measures can be computed using the following formulas <ref type="bibr" target="#b32">[33]</ref> for the mean throughput of class s Xs(m, j) = Gs/G,</p><p>and for the mean class s queue length for queues of type k</p><formula xml:id="formula_14">Q ks (m, j) = ρ ks G +k s /G.<label>(11)</label></formula><p>Related measures, as utilizations or response times, can be easily obtained from the above measures (e.g., <ref type="bibr" target="#b28">[29]</ref>). Note that a straightforward proof of (9) follows by inserting (10) and (11) for j = n into the population constraint for a closed model <ref type="bibr" target="#b24">[25]</ref>, given by ns = ρ0sXs(m, n) + È k m k Q ks (m, n). This motivates the choice of the name for (9).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">ANALYSIS OF RELATED WORK</head><p>This section introduces the new solution approach based on linear systems of normalizing constant recurrence equations. In order to prepare background for the new algorithm, we reformulate popular computational algorithms for closed networks as linear systems of normalizing constant recurrence equations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Recursive Solution Using Linear Systems</head><p>Most exact algorithms for product-form networks compute normalizing constants using the linear recurrence equations (7)-(9). In general, a solution can be obtained by different techniques. We propose a novel approach where, for each population n considered by the recursion, a vector g ≡ g(n) of normalizing constants of intermediate models is computed using a linear system of equations <ref type="formula" target="#formula_10">(7)</ref>-(9). The elements of g change with the considered algorithm, and will be described later. Due to the linearity of <ref type="formula" target="#formula_10">(7)</ref>- <ref type="formula" target="#formula_12">(9)</ref>, the technique takes the form of a sequence of linear systems</p><formula xml:id="formula_15">Ag = r 񮽙 s=1 Bsgs,<label>(12)</label></formula><p>where the matrix A ≡ A(n) describes the linear dependencies between the variables in g, the gs ≡ g(n − es) vectors are computed recursively, and the Bs ≡ Bs(n) matrices determine the linear system known terms from the gs vectors.</p><p>In general, if n ∈ lin(N), then Bs is the zero matrix for 1 ≤ s ≤ r − 1. Therefore, from (12) it follows that the recursive solution of queueing network models using a sequence of linear systems requires to select:</p><p>1. the set of processed populations n, typically either lin(N) or prod(N),</p><p>2. the elements of the g vector for all processed n,</p><p>3. the mix of equations <ref type="formula" target="#formula_10">(7)</ref>- <ref type="formula" target="#formula_12">(9)</ref> such that A is an invertible matrix and hence <ref type="formula" target="#formula_0">(12)</ref> has a unique solution.</p><p>In the next sections, we show how to reformulate popular computational algorithms in the form (12).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Analysis of the Convolution Algorithm</head><p>We begin with an analysis of the Convolution algorithm. In the convolution approach, <ref type="formula" target="#formula_10">(7)</ref> is considered for an arbitrary queue k, and recursively applied to the constants G −k and Gs in the right hand side until the network contains queues or jobs. Hence, a linear system reformulation may consider, for all n ∈ prod(N), a vector g composed by the normalizing constants of intermediate models (m, j) with population j = n and multiplicity</p><formula xml:id="formula_16">m ∈ {M, M − eq, M − 2eq, . . . , M − Mqeq, M − Mqeq − eq−1, M − Mqeq − 2eq−1, . . . , e1, 0}.</formula><p>The number of intermediate models considered for each n is thus card(g) = M + 1. For each n ∈ prod(N), the mix of equations for <ref type="formula" target="#formula_0">(12)</ref> is</p><formula xml:id="formula_17">񮽙 G − G −k = r È s=1 ρ ks Gs,<label>(13)</label></formula><p>that is the set of all possible equations <ref type="formula" target="#formula_10">(7)</ref> such that</p><p>1. the unknown normalizing constants in the left hand side are all elements of the g vector, 2. the normalizing constants in the right hand side are known terms belonging to the gs vectors, which are recursively computed.</p><p>Thus, looking at (12), the A matrix is defined by the coefficients of the normalizing constants in the left hand sides, while the Bs matrices depend on the right hand sides only. This notation will be used throughout the rest of the paper.</p><p>As an example, a model with M = 3 queues, q = 3 queue types, and no delays can be solved by means of the following linear system</p><formula xml:id="formula_18">¾ 񮽙 񮽙 1 −1 0 0 0 1 −1 0 0 0 1 −1 0 0 0 1 ¿ 񮽙 񮽙 ¾ 񮽙 񮽙 G G −3 G −2,3 G −1,2,3 ¿ 񮽙 񮽙 = r 񮽙 s=1 ¾ 񮽙 񮽙 ρ 3s Gs ρ 2s G −3 s ρ 1s G −2,3 s 0 ¿ 񮽙 񮽙,</formula><p>where we used the termination condition for m = 0 in the last equation. It is clear from the example that the Convolution algorithm has a coefficient matrix independent of both population and loadings, and that is always invertible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Application Example</head><p>We now show a first application of linear systems of normalizing constant recurrence equations. We modify the Convolution algorithm by introducing new equations. We consequently modify the linear system and the recursive structure of the algorithm to account for the new unknowns.</p><p>In general, it is quite difficult to integrate, at least in an efficient manner, <ref type="formula" target="#formula_11">(8)</ref> and <ref type="formula" target="#formula_12">(9)</ref> within <ref type="formula" target="#formula_0">(13)</ref>, since they introduce several new G +k unknowns. Instead, it may be helpful to include additional convolution expressions <ref type="formula" target="#formula_10">(7)</ref> for different choices of k.</p><p>We consider a system of equations <ref type="formula" target="#formula_10">(7)</ref> for all 1 ≤ k ≤ q. In this case, the normalizing constants in g are of intermediate models (m, j) with population j = n and multiplicity</p><formula xml:id="formula_19">{m | 0 ≤ m ≤ M}.<label>(14)</label></formula><p>Thus card(g) = É q k=1 (m k + 1). Considering the same example seen before, and omitting G −1,2,3 = 0, we have now </p><formula xml:id="formula_20">¾ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 1 −1 0 0 0 0 0 1 0 −1 0 0 0 0 1 0 0 −1 0 0 0 0 1 0 0 −1 0 0 0 1 0 0 0 −1 0 0 0 1 0 −1 0 0 0 0 1 0 0 0 −1 0 0 0 1 0 −1 0 0 0 0 1 0 0 −1 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 G G −1 G −2 G −3 G −1,2 G −1,3 G −2,</formula><formula xml:id="formula_21">ρ 3s G −1 s ρ 1s G −2 s ρ 3s G −2 s ρ 1s G −3 s ρ 2s G −3 s ρ 3s G −1,2 s ρ 2s G −1,3 s ρ 1s G −2,3 s ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 ,</formula><p>which is an overdetermined linear system with 12 equations and just 7 unknowns. Therefore, using the additional equations, and provided that the resulting matrix is invertible, we may avoid to recursively evaluate some terms of the right hand side by moving them into the vector of unknowns. For instance, let us assume r = 2 and observe that the constants G −1,2 , G −1, <ref type="bibr" target="#b2">3</ref> and G −2,3 are the normalizing constants of networks with a single queue and no delays, thus equal to the product-form factors f3, f2 and f1, respectively. Considering as new unknowns the normalizing constants G1 and G −k 1 , 1 ≤ k ≤ 2, and reducing the matrix to square by dropping unnecessary variables and equations, we get ¾ 񮽙 񮽙 񮽙 񮽙 񮽙</p><formula xml:id="formula_22">1 −ρ 11 −1 0 0 0 1 −ρ 21 0 0 −1 0 0 0 1 −ρ 21 0 0 0 0 1 −ρ 31 0 0 0 0 0 0 1 −ρ 11 0 0 0 0 1 −ρ 31 ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 G G 1 G −1 G −1 1 G −2 G −2 1 ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 = ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 ρ 12 G 2 ρ 22 G 2 f 3 + ρ 22 G −1 2 f 2 + ρ 32 G −1 2 f 3 + ρ 12 G −2 2 f 1 + ρ 32 G −2 2 ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 ,</formula><p>which has a unique solution if all loadings of class 1 are distinct. Thus, with the inclusion of additional convolution expressions we found a way to avoid the recursion on classthe original algorithm to the just N1 + N2 + 1 of the new formulation. This clearly leads to significant computational savings for models with large population sizes. Nevertheless, new overheads are introduced for linear system solution (e.g., the cost of LU factorization <ref type="bibr" target="#b19">[20]</ref>). However, the main problem is that, even if the result generalizes easily to models with a larger number of queues, for r &gt; 2 the increased number of unknowns typically makes impossible to process a lin(N) population set, and this is intrinsically related to the use of (7) in the linear system. Since the scope of the present paper is to develop a general lin(N) recursion, we shall not consider the proposed variant of the Convolution algorithm in the following sections, as well as the inclusion of <ref type="formula" target="#formula_10">(7)</ref> in linear systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Analysis of the RECAL Algorithm</head><p>In this section, we discuss the relation between RECAL <ref type="bibr" target="#b12">[13]</ref> and a lin(N) recursion based on (9) for s = r. We begin by first reviewing RECAL. In this algorithm, each queue is univocally associated to a special class, called selflooping class, composed by jobs looping indefinitely through the station. Queues have to be changed into load-dependent stations in order to serve self-looping jobs. The advantage is that the normalizing constant can then be computed using the following efficient class recursion. Let <ref type="formula" target="#formula_0">(15)</ref> be the set of combinations with repetition of k elements among n, which has cardinality card(</p><formula xml:id="formula_23">D n k = {(d1, . . . , dn) | 񮽙 t dt = k, dt ≥ 0, 1 ≤ t ≤ n}</formula><formula xml:id="formula_24">D n k ) = n+k−1 k ¡ .</formula><p>Then, the normalizing constant h(v, j) of a network with M queues, a delay server, population vector v for the M self-looping classes, and current population j = n for the remaining r classes, satisfies the following recurrence equation</p><formula xml:id="formula_25">h(v, n) = 񮽙 d∈D M +1 nr c(v, d)h(v + d, n − nrer),<label>(16)</label></formula><p>where</p><formula xml:id="formula_26">d ≡ (d0, d1, . . . , d k , . . . , dM ), c(v, d) = ρ d 0 0r d0! M 񮽙 k=1 񮽙 v k + d k v k 񮽙 ρ d k kr ,<label>(17)</label></formula><p>and with termination condition h(v, 0) = 1 for all v. Note that the normalizing constant of the input network with population N and no self-looping classes is immediately obtained by computing h(0, N) with (16). Furthermore, if ρ0r = 0, then the summation is on (d1, . . . , dM ) ∈ D M nr . We remark that we did not mention the m vector since RECAL assumes that the number of queues in a model is always equal to M , and that intermediate models differ only for the number of self-looping jobs and non-empty classes. Hence, RECAL has no queue recursions. However, we show that a different interpretation of (16) is possible, as proved by the following theorem. Theorem 1. Let q ≡ M for all populations, and let each type k, 1 ≤ k ≤ M , be composed by m k identical queues with loadings equal to those of queue k, 1 ≤ k ≤ M , of the input network. Then, the recursive insertion nr − 1 times of <ref type="formula" target="#formula_12">(9)</ref> for class r into all its right hand side normalizing constants gives <ref type="bibr" target="#b15">(16)</ref> </p><formula xml:id="formula_27">by setting v k = m k − 1, 1 ≤ k ≤ M .</formula><p>Informally, Theorem 1 states that (16) is equivalent to the class-r population constraint, provided that the M queues in the input network are never aggregated into the same queue type. Furthermore, the theorem has the important consequence of showing that, from the relation v k = m k − 1, the addition of self-looping jobs at queue k is equivalent to the insertion of new queues into the balanced subnetwork k. Therefore, two very different physical interpretations of RECAL may be considered.</p><p>Moreover, Theorem 1 shows that the definition of queue types implicitly assumed in RECAL differs from that adopted in Section 2.1. But since our queue type definition, which aggregates maximal balanced subnetworks into a single type, is indeed the most efficient for models with a large number of identical queues, we conclude that RECAL can be largely improved in this case, as recently shown by <ref type="bibr" target="#b23">[24]</ref>. A possible approach to address the problem consists in recursively solving (9) for class r using the queue type definition that aggregates maximal balanced subnetworks. Note that the artifice of considering single-job classes in order to reduce computational costs may also be applied to (9).</p><p>From the above observations, we have the following linear system reformulation of RECAL</p><formula xml:id="formula_28">Ò nrG = ρ0rGr + È q k=1 m k ρ kr G +k r ,<label>(18)</label></formula><p>for a set of populations n ∈ lin(N), and where the left hand side unknowns refer to intermediate models (m, j) having population j = n and multiplicity</p><formula xml:id="formula_29">m ∈ ¨ M + (d1, . . . , dq) | (d0, d1, . . . , dq) ∈ D q+1 N−n © , with card(g) = q+N−n N−n ¡</formula><p>. Thus, the cardinality of g increases while recurring on populations. The extension of (18) by including (8) into the linear system leads us to consider the LBANC algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Analysis of the LBANC Algorithm</head><p>The LBANC algorithm <ref type="bibr" target="#b8">[9]</ref> has been shown in <ref type="bibr" target="#b26">[27]</ref> to be the unnormalized version of the MVA algorithm <ref type="bibr" target="#b33">[34]</ref>. The computational requirements of the two methods are very similar, and the main difference is that LBANC uses normalizing constants, while MVA works directly with mean performance indices.</p><p>Concerning linear systems of normalizing constant recurrence equations, LBANC illustrates a simultaneous use of (8) and (9). The population recursion is n ∈ prod(N), and the formulation of LBANC discussed in <ref type="bibr" target="#b26">[27]</ref> can be reformulated as the following linear system´G</p><formula xml:id="formula_30">system´ system´G +k − G = È s ρ ks G +k s , 1 ≤ k ≤ q, nrG = ρ0rGr + È k m k ρ kr G +k r ,<label>(19)</label></formula><p>where the left hand side unknowns have population j = n and multiplicity</p><formula xml:id="formula_31">m ∈ {M, M + e1, . . . , M + eq}.<label>(20)</label></formula><p>Therefore, LBANC computes card(g) = q + 1 constants at each population, and it is substantially more efficient than convolution when q &lt;&lt; M, an advantage that has not been previously pointed out in the literature. Another advantage of LBANC is the direct availability of the terms G +k s for (11), which are instead computed in the Convolution algorithm with additional recursions. Nevertheless, the main source of complexity in both LBANC and Convolution remains the prod(N) population recursion. The inclusion of new equations into the linear system (19) in order to reduce computational costs is addressed in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">ALGORITHM DESCRIPTION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Preliminaries</head><p>We initially assume that ρ0s = 0, 1 ≤ s ≤ r − 1. The definition of the new algorithm starts by observing that the inclusion of the r − 1 population constraints for the non-empty classes s 񮽙 = r into (19) does not introduce new unknowns and may increase the number of independent equations in the linear system. Thus, these additional equations have the potential to significantly reduce the cost of computing normalizing constants. In particular, as we prove later, if a certain set of equations <ref type="formula" target="#formula_11">(8)</ref>- <ref type="formula" target="#formula_12">(9)</ref> is considered, and provided that the resulting linear system is non-singular, then we can solve models using an efficient lin(N) recursion with very different computational tradeoffs with respect to existing algorithms.</p><p>We can show that the above observations hold true also for the general case where we drop the ρ0s = 0 conditions. Despite now the additional population constraints introduce new unknowns into the linear system, i.e., the Gc constants for 1 ≤ c ≤ r − 1, we can always exploit the fact that these constants refer to models with jr = nr jobs of class r. This allows us to include into the system also the class r population constraints for the models with j = n − ec, i.e.,</p><formula xml:id="formula_32">nrGc = ρ0rGc,r + q 񮽙 k=1 m k ρ kr G +k c,r , 1 ≤ c ≤ r − 1,<label>(21)</label></formula><p>which allow to compute the new unknowns directly from gr. Hence, the inclusion of the new Gc unknowns is compensated by the availability of additional class r population constraints.</p><p>Finally, we point out that in general the considered linear systems may not have necessarily full rank, but for the sake of simplicity in presenting, we initially take this assumption. Singularity conditions will be discussed in Section 5.2.2, as well as strategies to address the problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Preliminary Analysis</head><p>We now illustrate some difficulties arising when including (8) and (9) into a linear system with the aim of defining a lin(N) recursion. We consider a linear system relating normalizing constants of models with multiplicity m ∈ {M, M+e1, M+e2} and population j ∈ {n, n−e1}. Assume that the current population n is such that r = 2 and q = 2. We have that the linear system defined by (8), 1 ≤ k ≤ q, and (9), 1 ≤ s ≤ r, for a lin(N) recursion is</p><formula xml:id="formula_33">Ag = B2g2,<label>(22)</label></formula><p>where</p><formula xml:id="formula_34">Ag ≡ ¾ 񮽙 񮽙 񮽙 1 −ρ 11 0 0 −1 0 0 0 1 −ρ 21 −1 0 0 −M 1 ρ 11 0 −M 2 ρ 21 n 1 −ρ 01 0 0 0 0 n 2 0 0 0 0 0 0 n 2 ¿ 񮽙 񮽙 񮽙 ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 G +1 G +1 1 G +2 G +2 1 G G 1 ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and</head><p>B2g2 ≡ ¾ 񮽙 񮽙 񮽙 <ref type="formula" target="#formula_33">(22)</ref> is underdetermined, having more unknowns than equations. This indicates that the considered system of equations <ref type="formula" target="#formula_11">(8)</ref>-(9) may be insufficient for a population recursion in lin(N). Thus, a different approach is required to take full advantage of the additional population constraints.</p><formula xml:id="formula_35">ρ 12 0 0 0 0 0 0 0 ρ 22 0 0 0 0 0 0 0 0 0 M 1 ρ 12 0 M 2 ρ 22 0 ρ 02 0 0 M 1 ρ 12 0 M 2 ρ 22 0 ρ 02 ¿ 񮽙 񮽙 񮽙 ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 G +1 2 G +1 1,2 G +2 2 G +2 1,2 G 2 G 1,2 ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 , Note that</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The Linear System</head><p>We propose to solve closed multiclass product-form networks using a population recursion in lin(N). For each recursively processed n ∈ lin(N), we compute the following vector of unknowns</p><formula xml:id="formula_36">g = 񮽙 G + G 񮽙 ,<label>(23)</label></formula><p>where G is a vector of normalizing constants of intermediate models (m, j) having population j ∈ {n, n−e1, . . . , n−er−1} and multiplicity</p><formula xml:id="formula_37">m ∈ {M + (d1, . . . , dq) | (d1, . . . , dq) ∈ D q r−1 }.<label>(24)</label></formula><p>Instead, G + includes all normalizing constants that can be obtained by adding a queue k, 1 ≤ k ≤ q, to the normalizing constants in G, i.e.:</p><formula xml:id="formula_38">G + ≡ {G +k , G +k 1 , . . . , G +k r−1 | 1 ≤ k ≤ q, {G, G1, . . . , Gr−1} ⊆ G}.<label>(25)</label></formula><p>Thus, G + includes constants of intermediate models (m + , j) with population j ∈ {n, n−e1, . . . , n−er−1} and multiplicity</p><formula xml:id="formula_39">m + ∈ {M + (d1, . . . , dq) | (d1, . . . , dq) ∈ D q r }.<label>(26)</label></formula><p>We denote by G + r and Gr the components of gr. Note that by the definitions, g has cardinality</p><formula xml:id="formula_40">card(g) = card(G + ) + card(G) = 񮽙 q + r − 1 r 񮽙 r + 񮽙 q + r − 2 r − 1 񮽙 r,<label>(27)</label></formula><p>which is independent of population sizes. Thus, for fixed r and q, g and gr have identical cardinality, and the linear system order does not increase with n.</p><p>For the current population n, g is computed from gr by the following linear system: 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙</p><formula xml:id="formula_41">G +k − G − r−1 È c=1 ρ kc G +k c = ρ kr G +k r , 1 ≤ k ≤ q ncG − ρ0cGc − q È k=1 m k ρ kc G +k c = 0, 1 ≤ c ≤ r − 1 nrG = ρ0rGr + q È k=1 m k ρ kr G +k r , nrGc = ρ0rGc,r + q È k=1 m k ρ kr G +k c,r , 1 ≤ c ≤ r − 1<label>(28)</label></formula><p>where</p><formula xml:id="formula_42">{G +k , G +k c } ⊆ G + , {G, Gc} ⊆ G, {G +k r , G +k c,r } ⊆ G +</formula><p>r , and {Gr, Gc,r} ⊆ Gr. We denote the four groups of equations, from the top, by (28a), (28b), (28c) and (28d). We motivate the linear system by the following two observations:</p><p>• for each n, we can directly compute all normalizing constants in G from gr by (28c)-(28d).</p><p>• Once that G has been computed, we can determine G + by solving the subsystem (28a)-(28b).</p><p>Thus, the solution of <ref type="formula" target="#formula_11">(28)</ref>  As a consequence of this result, if the coefficient matrix A is non-singular, the system is never underdetermined and (28) has a unique solution. It is important to point out that (24)-(26) define the smallest cardinality vectors for which the above theorem holds, but other definitions of G and G +k may also be considered. Numerical conditioning, singularity, and block triangular form of the coefficient matrix of <ref type="formula" target="#formula_11">(28)</ref> are discussed in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Illustrative Example</head><p>We now show a small example of (28). We consider the same model of Section 4.1.1. We have q = 2 and r = 2, and so g depends on</p><formula xml:id="formula_43">D q r−1 = D 2 1 = {(1, 0), (0, 1)} and D q r = D 2 2 = {(2, 0), (1, 1), (0, 2)}. In particular, we have g = ¢ G + G £ T with G + = ¢ G +1,1 G +1,1 1 G +1,2 G +1,2 1 G +2,2 G +2,2 1 £ T , (29) G = ¢ G +1 G +1 1 G +2 G +2 1 £ T ,<label>(30)</label></formula><p>and similarly gr = g2 = ¢ G + 2 G2</p><p>£ T where</p><formula xml:id="formula_44">G + 2 = ¢ G +1,1 2 G +1,1 1,2 G +1,2 2 G +1,2 1,2 G +2,2 2 G +2,2 1,2 £ T ,<label>(31)</label></formula><formula xml:id="formula_45">G2 = ¢ G +1 2 G +1 1,2 G +2 2 G +2 1,2 £ T .<label>(32)</label></formula><p>Let   Compared to the linear system of Section 4.1.1, the coefficient matrix A is now square, and provided that it is nonsingular, we have a unique solution to the linear system. Hence, a lin(N) recursion is now possible.</p><formula xml:id="formula_46">t zks ≡ (M k + z)ρ ks , then (28) is Ag = B2g2,<label>(33)</label></formula><formula xml:id="formula_47">G +1,1 G +1,1 1 G +1,2 G +1,2 1 G +2,2 G +2,2 1 G +1 G +1 1 G +2 G<label>+2</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">The Computational Algorithm</head><p>The new algorithm has the following structure:</p><p>1: Compute g(N 1 , 0, . . . , 0) 2: for r = 2 to R do 3:</p><p>Initialize g(N 1 , . . . , N r−1 , 0, . . . , 0)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4:</head><p>for nr = 1 to Nr do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5:</head><p>Setup and solve (28) for n = (N 1 , . . . , N r−1 , nr, 0, . . . , 0)</p><p>6: end for</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7: end for 8: Compute performance measures</head><p>Computation of g(N1, 0, . . . , 0). The recursion on the first class can be performed using single-class algorithms proposed in previous works (e.g., <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b8">9]</ref>). Furthermore, under certain assumptions, single class normalizing constants can be computed using closed-form formulas (see, e.g., <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b21">22]</ref>), but exact arithmetic may be required to avoid numerical instabilities.</p><p>Initialization of g(N1, . . . , Nr−1, 0, . . . , 0). At each change of the value of r, also <ref type="formula" target="#formula_3">(23)</ref>- <ref type="formula" target="#formula_11">(28)</ref> change. In particular, the order of the coefficient matrix grows with r, and this has the following implications:</p><p>1. the solution of the linear system becomes more expensive as r increases. Hence, it is better to process the classes with the largest populations first, since they require the largest number of iterations.</p><p>2. At the first population processed after a r change, the vector G + (N1, . . . , Nr−1, 0, . . . , 0) is not available. For instance, when r = 3 the first linear system solved requires G + (N1, N2, 0, . . . , 0) with multiplicity depending on the set D q 3 , but during recursion for r = 2 only intermediate models defined on D q 2 and D q 1 were solved.</p><p>The second issue can be addressed as follows. Let r be the new class to be processed, and assume nr = 1. Note that the constants in G(n − er) = G(N1, . . . , Nr−1, 0, . . . , 0) are known from the recursion on class r − 1. We compute the required G + (n − er) = G + (N1, . . . , Nr−1, 0, . . . , 0) from G(n − er) using the following linear system:</p><formula xml:id="formula_48">񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 G +k − r−1 È c=1 ρ kc G +k c = G, 1 ≤ k ≤ q, − q È k=1 m k ρ kc G +k c = −ncG + ρ0cGc, 1 ≤ c ≤ r − 1<label>(34)</label></formula><p>where {G, Gc} ∈ G(n − er), {G +k , G +k c } ∈ G + (n − er). We point out that the matrix of coefficient of <ref type="formula" target="#formula_3">(34)</ref> is the coefficient matrix C for class r that we will introduce in the next section.</p><p>Performance measures. In order to compute performance measures by (10) and (11), we need to compute G, Gs, 1 ≤ s ≤ R, and G +k s , 1 ≤ k ≤ q, 1 ≤ s ≤ R, for the input network with population N. Note that the intermediate models solved by the linear system for n = N have multiplicity m ≥ M, thus computing performance measures requires to remove the queues added by <ref type="bibr">(24)-(26)</ref>. This task has to be performed in different ways depending on network structure. We have the following two cases: all delays ρ0s, 1 ≤ s ≤ R, are strictly positive; or there exist one or more classes with zero delay. In the first case, we can recursively remove the queues added by (24)-(26) from the linear system solution for n = N using 񮽙 񮽙 񮽙 񮽙 񮽙</p><formula xml:id="formula_49">G = G +k − È R s=1 ρ ks G +k s , 1 ≤ k ≤ q, Gs − Ns ρ0s G = − q 񮽙 k=1 m k ρ ks ρ0s G +k s , 1 ≤ s ≤ R.<label>(35)</label></formula><p>Instead, in the second case we permute class indices so to process last all classes with ρ0s = 0. Then if NR ≥ R, the required normalizing constants can be computed from g(N1, . . . , NR−1, NR − R) by recursive application of <ref type="formula" target="#formula_12">(9)</ref> for class R. This also let us skip the solution of the last R linear systems <ref type="bibr" target="#b27">(28)</ref>. Otherwise, the recursive solution of <ref type="formula" target="#formula_12">(9)</ref> comes to a point where the problem is recursively reduced to removing queues in the normalizing constants computed for class R − 1. Thus, a recursive procedure can be used to compute performance measures in this case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">LINEAR ALGEBRA RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Block Triangular Form</head><p>We now apply linear algebra techniques to simplify (28). We begin by expressing the linear system in the form (12)</p><formula xml:id="formula_50">A(nr)g = Brgr,<label>(36)</label></formula><p>where A(nr) indicates that only the nr coefficients change in A while recurring on class r populations. The main limitation of this dependence is that we cannot reuse the same LU factorization for linear systems depending on the same r. Nevertheless, we show that (23) implicitly defines A(nr) into an upper block triangular form that suggests a straightforward solution to the problem. Note that in (28) the population nr multiplies all and only the constants in G. Therefore, (36) can be expressed using only population-independent matrices as</p><formula xml:id="formula_51">񮽙 C A12 0 nrI 񮽙 񮽙 G + G 񮽙 = 񮽙 B1r B2r 񮽙 gr,<label>(37)</label></formula><p>where I is the identity matrix of order </p><formula xml:id="formula_52">G = n −1 r B2rgr,<label>(38)</label></formula><p>and we only need to solve the linear system</p><formula xml:id="formula_53">CG + = B1rgr − A12G.<label>(39)</label></formula><p>The last two formulas prove that we can recursively solve (28) using matrices that in no way depend on nr. In particular, only C requires a LU factorization, which can anyway be reused for all class r populations. Furthermore, by inserting <ref type="formula" target="#formula_3">(38)</ref> into <ref type="formula" target="#formula_3">(39)</ref> we get</p><formula xml:id="formula_54">CG + = B1r − n −1 r A12B2r ¡ gr,<label>(40)</label></formula><p>and defining</p><formula xml:id="formula_55">F1r ≡ 񮽙 C −1 B1r 0 񮽙 , F2r ≡ 񮽙 −C −1 A12B2r B2r 񮽙 ,</formula><p>where the zero matrix in F1r has size card(G) x card(gr), we may compactly reformulate (28) as</p><formula xml:id="formula_56">g = F1r + n −1 r F2r ¡ gr, nr = 1, . . . , Nr.<label>(41)</label></formula><p>which is a set of recurrence equations in the nr variable.</p><p>Despite that a block Gaussian elimination is typically more efficient than a recursive solution of <ref type="formula" target="#formula_0">(41)</ref>, because F1r and F2r may not preserve the sparsity of C, this compact formulation may be of interest for theoretical reasons due to its simplicity.</p><p>We also point out that an advantage deriving from the above results is that, if loadings and delays are all strictly positive, then the number and the placement of the non-zero coefficients in linear system matrices are fixed for all models with same q and r. Thus, it is possible to optimize the related data structures and algorithms by precomputation. For instance, the position of the non-zeros in C may be easily precomputed. Then, the matrix can be instantiated in an array of minimum size that can be accessed efficiently using hashing. We also remark that linear system solvers perform the same operations and memory accesses for fixed q and r, and this may also be used to optimize implementations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Fine-Grain Decomposition</head><p>Direct solution methods for linear systems, e.g., Gaussian elimination, require a computational effort that is typically cubic with the order of the coefficient matrix <ref type="bibr" target="#b19">[20]</ref>. Starting from this fact, we propose a decomposition of the coefficient matrix C into block triangular form that allows significant computational savings by reducing the order of linear systems. Despite this is not required to grant the correctness of the results, it is useful to limit growth of time and storage requirements.</p><p>The decomposition depends on a partitioning of the set D q r , which immediately implies by (24) a partitioning of G + and thus a decomposition of C. We partition D q r so that combinations (d1, . . . , dq) with same position of nonzero elements are included into the same partition. We denote by P ht the t-th partition composed by combinations with h non-zeros in the same position. For example, D 3 3 can be partitioned into the sets P11 = {(3, 0, 0)}, P12 = {(0, 3, 0)}, P13 = {(0, 0, 3)}, P21 = {(1, 2, 0), (2, 1, 0)}, P22 = {(1, 0, 2), (2, 0, 1)}, P23 = {(0, 2, 1), (0, 1, 2)}, P31 = { <ref type="figure" target="#fig_2">(1, 1, 1</ref>)}. So G + becomes</p><formula xml:id="formula_57">G + = G + (P11) ∪ G + (P12) ∪ . . . ∪ G + (P31).<label>(42)</label></formula><p>where each subset G + (P ht ) contains normalizing constants of intermediate models (m ht , j) with population j ∈ {n, n − e1, . . . , n − er−1} and multiplicity</p><formula xml:id="formula_58">m ht ∈ {M + (d1, . . . , dq) | (d1, . . . , dq) ∈ P ht }.<label>(43)</label></formula><p>Note that, by definition of D q r , the number of non-zeros elements h must range in 1 ≤ h ≤ H where</p><formula xml:id="formula_59">H ≡ min{q, r}.<label>(44)</label></formula><p>Further, note that the number of possible choices for the positions of the h non-zero elements is </p><p>which is an application of Vandermonde's convolution <ref type="bibr" target="#b10">[11]</ref>, and summarizes the effects of the partitioning. We also remark that in (28) two normalizing constants in G + appear in the same equation only if they refer to models differing by at most one queue assigned to different types. This means that non-zero coefficients in C can relate either normalizing constants of the same G + (P ht ), or constants depending on P ht and P h 񮽙 t with |h − h 񮽙 | = 1. Thus, permuting the columns of C to reflect the partitioning of G + , and in particular sorting columns according to the number of non-zeros, we get the block triangular form</p><formula xml:id="formula_61">C ≡ ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 C1 C12 0 . . . 0 0 0 C2 C23 . . . 0 0 0 0 C3 . . . 0 0 . . . . . . . . . . . . . . . . . . 0 0 0 . . . CH−1 CH−1,H 0 0 0 . . . 0 CH ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 ,<label>(48)</label></formula><p>where</p><formula xml:id="formula_62">C h ≡ diag(c h1 , c h2 , . . . , c ht , . . .), 1 ≤ h ≤ H,<label>(49)</label></formula><p>is a diagonal matrix of </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Numerical Properties</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Error Propagation</head><p>Preliminary implementations of the proposed algorithm suggest that roundoff errors tend to accumulate while iterating on populations <ref type="bibr" target="#b18">[19]</ref>. Even on models where C is numerically well conditioned (i.e., has a low condition number <ref type="bibr" target="#b19">[20]</ref>), the computation typically fails if the network contains more than few tens of jobs.</p><p>In order to address the problem in a simple and effective way, we propose to exactly solve (e.g., <ref type="bibr" target="#b5">[6]</ref>) all linear systems (28). This means that exact arithmetic has to be adopted throughout all computations. If this is implemented using rational multiprecision arithmetic libraries (e.g., <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b20">21]</ref>) all digits of operands are kept, and no roundoff is performed. Despite the additional digits introduce some overheads, exact rational arithmetic does not suffer any kind of numerical instability. So we also avoid underflow or overflow problems that typically affect normalizing constant evaluations. Moreover, nowadays multiprecision libraries (e.g., GMP <ref type="bibr" target="#b20">[21]</ref>) offer very good performance for operands with thousands of digits, as we expect in normalizing constants of large models. Other techniques for exact linear algebra may also be adopted, e.g. modular arithmetic <ref type="bibr" target="#b30">[31]</ref> that also provides a natural way for parallelizing linear system solution. We point to Section 6 for a discussion on the cost of adopting exact multiprecision arithmetic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Singular Linear Systems</head><p>We now consider conditions that produce a singular C matrix, and discuss possible solutions. Noting that the loadings for class R are never included in C, we identify the following critical cases:</p><p>1. there exist one or more queue types k with ρ kc = 0 for some c 񮽙 = R. This condition yields columns of all zeros in C. Thus, some unknowns of g are not included into any equation.</p><p>2. There exist linear relations between loadings that let some C h blocks become singular.</p><p>The first case can be easily addressed by removing the unknowns in G + associated with the zero columns. The resulting system is overdetermined and still admits a unique solution.</p><p>The second case is more difficult, because dependencies between loadings may result in a singular C matrix. For instance, there exist singular diagonal blocks if two queue types k1 and k2 have ρ k 1 c = ρ k 2 c for some 1 ≤ c ≤ r−1. Singularity conditions can be enumerated by a symbolic computation of the determinants of the C h blocks. For instance, the C3 diagonal block for q = 3, r = 3 is</p><formula xml:id="formula_63">C 3 = ¾ 񮽙 1 −ρ 11 −ρ 12 1 −ρ 21 −ρ 22 1 −ρ 31 −ρ 32 ¿ 񮽙 , (50)</formula><p>which has determinant det(C3) = ρ21ρ32 +ρ12ρ31 +ρ22ρ11 −ρ22ρ31 −ρ11ρ32 −ρ12ρ21.</p><p>Considering ρ11, we see that for ρ22 񮽙 = ρ32 the value</p><formula xml:id="formula_64">ρ11 = ρ22ρ31 − ρ21ρ32 + ρ12ρ21 − ρ12ρ31 ρ22 − ρ32 (51)</formula><p>gives a zero determinant. Note that the complexity of singularity conditions grows quickly with block order (e.g., the determinant of the C4 block for q = 4 and r = 4 includes over 60 product terms). So, a numerical diagnosis of singularity is recommended in implementations. We propose to address singularity by moving back into the vector of known terms the unknowns responsible for the singularity of (28). This means that an hybrid population recursion has to be performed, where some normalizing constants are computed from linear systems, while the remaining ones are recursively evaluated. For instance, if the normalizing constants G +k c and G +k c of the last t classes are moved back to the right hand side of (28), then we can solve the model for all populations in prod(NR−t+1, . . . , NR) using lin(N1, . . . , NR−t) recursions. In this way, the new normalizing constants in the right hand side are directly available from previous recursions. Finally, the recursion for the last population (NR−t+1, . . . , NR) solves the input network with population N. The computational cost in presence of a singular coefficient matrix is thus an intermediate case between that for non-singular systems and that of existing prod(N) recursions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">COMPUTATIONAL REQUIREMENTS</head><p>Finally, we discuss the computational requirements of the proposed algorithm. In particular, we consider the cost of solving the sequence of systems (39). This task is typically several orders of magnitude slower than all other operations, e.g., (38) and the computation of performance measures. Throughout this section, we assume to use LU factorization, forward and back substitution <ref type="bibr" target="#b19">[20]</ref> to solve <ref type="bibr" target="#b38">(39)</ref>.</p><p>Since the additional complexity due to numerical stabilization is not a theoretical limit to the performance of the proposed algorithm, but rather characterizes the best currently available stable implementation, we first quantify the cost of solving the sequence of linear system regardless of accuracy of solutions. Then, we discuss the asymptotic cost of adopting an exact linear system solver in implementations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Solving the Sequence of Linear Systems</head><p>Let LU t(θ) 񮽙 (2/3)θ <ref type="bibr" target="#b2">3</ref> and LU s(θ) 񮽙 θ 2 be respectively the number of operations and the storage required by a LU factorization of a full-rank square matrix of order θ. Similarly, let BSt(θ) 񮽙 2θ 2 be the total number of operations of forward and back substitution. Assume that C is in the form (48), and denote by θ rh ≡ r−1 r−h ¡ r the order of the diagonal blocks c ht when there are r non-empty classes. Then, from the consideration in Section 5.1.1, the time requirement is of the order of</p><formula xml:id="formula_65">R 񮽙 r=1 H 񮽙 h=1 񮽙 q h 񮽙 񮽙 LU t(θrh) + Nr 񮽙 nr =0 BSt(θ rh ) 񮽙 񮽙 2 R 񮽙 r=1 H 񮽙 h=1 񮽙 q h r − 1 r − h 񮽙 r 񮽙 2 񮽙 1 3 񮽙 r − 1 r − h 񮽙 r + Nr + 1 񮽙 &lt; 2 R 񮽙 r=1 H 񮽙 h=1 q h h! 񮽙 r h (h − 1)! 񮽙 2 񮽙 r h (h − 1)! + Nr + 1 񮽙 ,<label>(52)</label></formula><p>where the case nr = 0 accounts for the initialization of g after a r change, and H ≡ min{q, r}. Note that the formula is typically an upper bound, because it does not account for the computational savings due to the sparsity of C. Moreover, assuming to keep in memory only the LU factorizations for the current value of r, storage requirement is maximum for r = R, and it is of the order of</p><formula xml:id="formula_66">H 񮽙 h=1 񮽙 q h 񮽙 LSs(θ Rh ) 񮽙 H 񮽙 h=1 񮽙 q h R − 1 R − h 񮽙 R 񮽙 2 &lt; H 񮽙 h=1 q h h! 񮽙 R h (h − 1)! 񮽙 2 , (53)</formula><p>which is independent of population sizes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Asymptotic Cost of Stabilization</head><p>If we adopt in implementations an exact solver based on rational multiprecision arithmetic, then we have to account also for the increasing costs of arithmetic operations. Thus, we have in general that the time and storage requirements have to be specified as LU t(θ) ≡ LU t(θ, n), LU s(θ) ≡ LU s(θ, n), and BSt ≡ BSt(θ, n). The exact number of operations required by multiprecision arithmetic strongly depends with implementations, thus we limit to study asymptotic behaviors. Because the number of digits of the coefficients in C is constant, operations required to solve (39) have computational requirements that grow with the number of digits of the unknowns in g and gr. Let us assume all loadings to be scaled to integers <ref type="bibr" target="#b25">[26]</ref>, and let us assume to keep with small overheads a common denominator between the variables, e.g., n1! · · · nr! for the normalizing constants in g, and n1! · · · nr−1!(nr − 1)! for those in gr. Then, the time cost of rational arithmetic operations grows linearly with the number of digits of the numerator, while storage depends by both the size of numerators and of the common denominator. Taking the logarithm of <ref type="formula" target="#formula_7">(5)</ref> in the worst-case of a model with balanced m 񮽙 queues, integer loadings all equal to ρ ≡ max k,s {ρ ks }, 0 ≤ k ≤ q, and population n, we get the following expression log G = log n!</p><formula xml:id="formula_67">m 񮽙 +n−1 n ¡ ρ n n1! · · · nr! &lt; log (m 񮽙 + n − 1) n ρ n n1! · · · nr! ,<label>(54)</label></formula><p>where both numerators and denominators of the logarithm argument are integers. Thus, we see that the growth of the number of digits of the numerator of G is O(n log(m 񮽙 + n)). Thus, for the constants in g, which have m 񮽙 ≤ M + r + 1 accounting also the product-form factor of the delay, the time and storage overhead of exact arithmetic grows at most as O(n log(M + r + n)), which may be regarded as a scale factor for the computational cost in the case without stabilization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Models with Large Population Sizes</head><p>Time and storage complexity formulas prove that the presented algorithm is very efficient for large population sizes, even accounting for stabilization. In particular, assuming constant q, M and R, and considering Ns = κ for all classes, we have that the time requirements grow for κ → +∞ as O(κ), or O(κ 2 log κ) accounting also for numerical stabilization, while under the same conditions the Convolution, LBANC, and the MVA algorithms are approximately O(κ R ). Similarly, RECAL and other efficient class recursions (e.g, <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b23">24]</ref>) require for large population sizes approximately O(κ M ) or O(κ q ) time. Similarly, accounting for stabilization, the storage requirement of the algorithm, grows as O(κ log κ), that is typically several orders of magnitude smaller than existing algorithms. Therefore, the proposed approach may provide substantial computational savings for models with large populations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">NUMERICAL EXAMPLE</head><p>Finally, we compare the efficiency of the proposed algorithm with respect to existing techniques by a numerical example. We solve a model with N = 6000 jobs, M = 25 queues, q = 3 queue types for all populations, and R = 6 classes. The loadings ρ ks for the considered model are given in <ref type="table" target="#tab_5">Table 1</ref>. In the example, the multiplicities M k never change during recursions. Since complexity formulas for RE-CAL are available only for the case with no delays <ref type="bibr" target="#b12">[13]</ref>, for the purpose of comparison we set ρ0s = 0 for all classes.</p><p>We used a preliminary implementation of the algorithm written in C, and based on the exact rational arithmetic routines of the GMP library <ref type="bibr" target="#b20">[21]</ref> version 4.1.4. The algorithm was run on a AMD Athlon64 3000+ processor using the 32-bit mode. The solution of the linear system in block triangular form was performed by reusing the same LU factorization for all populations of class r. The computed normalizing constant was G(N) = 1.21173 × 10 11328 . Since we used exact arithmetic, all digits of G were available at the end of the computation. We also determined throughputs and queue-lengths for all classes and queues. For instance, the throughput of class 2 is X2(N) = 1.45435 × 10 −2 jobs per second, while the average class 1 queue-length at queues of type 1 is Q11(N) = 2.45426 jobs.</p><p>Accounting multiprecision overheads and all operations not modeled by (52), the solution was obtained in 173s. On the considered architecture this is approximately 10 11 operations. During execution, the amount of allocated memory was always less than 20 MBytes, also thanks to the use of specialized data structures for sparse matrices. For the same model, the theoretical number of operations of LBANC is 񮽙 10 19 , 񮽙 10 20 for Convolution, and 񮽙 10 71 for RECAL. Therefore, compared to the other methods, the proposed algorithm is the only computationally feasible on the considered example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSIONS</head><p>We presented a new efficient exact algorithm for computing normalizing constants of closed multiclass product-form networks. The method is based on the new powerful concept of linear systems of normalizing constant recurrence equations, which may indicate further research developments in the area.</p><p>An example presented in the paper shows that the new algorithm can be several orders of magnitude faster than existing techniques on models with large populations. A comparison on non-asymptotic populations, as well as on models with large number of queue types and classes, is left as future work.</p><p>It is currently not clear whether the results presented in the paper may be extended to the load-dependent case. Lack of results concerning the generalization of (8)-(9) to the loaddependent case makes it difficult to establish whether such extension is possible. In particular, the lack of a suitable generalization of (11) to the load-dependent case seems to be the main issue.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>s</head><label></label><figDesc>the normalizing constant of a model with population j − es and multiplicity m + e k . Sim- ilarly, G −k s refers to a model with j − es and m − e k , Gs refers to j − es and m, G +k refers to j and m + e k , and G −k refers to j and m − e k . The removal of multiple queues or jobs is denoted, e.g., by G −k,i s,c referring to j − es − ec and m − e k − ei.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>where Ag ≡ ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 1 −ρ 11 0−t 111 0 −t 021 0 0 n 1 −ρ 01 0 0 0 0 0 −t 011 0 −t 121 0 0 n 1 −ρ 01 0񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>1 ¿</head><label>1</label><figDesc>񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 , and B2g2 ≡ ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙t 012 0 t 122 0 0 0 ρ 02 ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>q+r−2 r−1 ¡ r, and C ≡ C(q, r) is a square diagonal block of order q+r−1 r ¡ r. Using block Gaussian elimination we get</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>.</head><label></label><figDesc>The remaining r − h elements are free to be assigned to any of the h po- sitions, and this can be modeled by a set of combination with repetitions D h r−h . From this considerations, we have immediately card (P ht ) = 񮽙 h + (r − h) − 1 r − h 񮽙 = 񮽙</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>blocks c ht that contains the coef- ficients for the normalizing constants in G + (P ht ). We now prove the following theorem. Theorem 3. The q h ¡ diagonal blocks c ht ⊆ C h are square matrices of order r−1 r−h ¡ r, where r−1 r−h ¡ h rows are convolution expressions (28a), and r−1 r−h ¡ (r −h) rows are population con- straints (28b). Therefore, this form greatly simplifies the solution of (39), since LU factorization is now required only for the diagonal blocks that have order r−1 r−h ¡ r &lt;&lt; q+r−1 r ¡ r.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>j), we denote by G +k</head><label></label><figDesc></figDesc><table>is of the 
order of 

É r 

s=1 

js +m−1 

js 

¡ 

that is infeasible in most cases. 
However, G can be computed using recurrence equations 
involving intermediate models. For compactness, if G ≡ 
G(m, </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>3 ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 = r 񮽙 s=1 ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 ρ 1s Gs ρ 2s Gs ρ 3s Gs ρ 2s G −1 s</head><label></label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>G +1,1 2 G +1,1 1,2 G +1,2 2 G +1,2 1,2 G +2,2 2 G +2,2 1,2 G +1 2 G +1 1,2 G +2 2 G +2 1,2 ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 .</head><label></label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><head>Table 1 : Example multiclass model with N = 6000 jobs belonging to R = 6 classes.</head><label>1</label><figDesc></figDesc><table>Queue 
Class of requests 
Type k 
M k 
ρ k1 
ρ k2 
ρ k3 
ρ k4 
ρ k5 
ρ k6 
1 
12 
17 
4 
15 
6 
20 
2 
2 
5 
16 
7 
16 
17 
5 
17 
3 
8 
2 
18 
19 
8 
18 
12 
Population Ns 1000 1000 1000 1000 1000 1000 

</table></figure>

			<note place="foot" n="1"> when r = 2, so to perform a recursion on lin(N) instead than on prod(N). In this way, the number of recursively evaluated populations drops from the (N1 + 1)(N2 + 1) of</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">ACKNOWLEDGEMENTS</head><p>Additional material of interest for this work can be found in <ref type="bibr" target="#b6">[7]</ref>. I wish to thank my advisor, prof. G. Serazzi, for his help and continuous support of my research. I thank J. Anselmi and the anonymous SIGMetrics reviewers for suggestions that substantially helped in increasing the quality of the paper. I am also in debt with prof. P. Cremonesi for useful discussions. I thank D. Ardagna, M. Roveri, C. Spelta and S. Zanero for constructive comments.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Theorem 1</head><p>We show that the recursive unfolding of <ref type="formula">(9)</ref>  </p><p>where G(m + d, n − nrer) refers to a model with class r less,</p><p>is the number of recursions that terminate with G(m + d, n − nrer) in the right hand side, and m</p><p>is the rising factorial. We get (16) noting that (d0 + . . . + dM )! = nr!, and setting</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Theorem 2</head><p>Note that we can compute from gr each constant in G using a class r population constraint of (28). Therefore, we only need to prove that the number of equations <ref type="formula">(28a)</ref> and <ref type="formula">(</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Theorem 3</head><p>By definition, each block c ht ⊆ C h has coefficients of constants in G + (P ht ). Thus, the number of columns of c ht is</p><p>Note that we can remove at most h stations from m ∈ {M + (d1, . . . , dq) | (d1, . . . , dq) ∈ P ht } so that the resulting model is in <ref type="bibr" target="#b23">(24)</ref>. Hence, the number of convolution expressions is card(P ht )h = </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Analysis of queueing networks with blocking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Balsamo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>De Nitto Personé</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Onvural</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Open, closed, and mixed networks of queues with different classes of customers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Baskett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">M</forename><surname>Chandy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">R</forename><surname>Muntz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">G</forename><surname>Palacios</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J.ACM</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="248" to="260" />
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Multidimensional residues, generating functions, and their application to queueing networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bertozzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mckenna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Rev</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="239" to="268" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The mva priority approximation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Bryant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Krzesinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Lakshmi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">M</forename><surname>Chandy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comp. Sys</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="335" to="359" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Computational algorithms for closed queueing networks with exponential servers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename><surname>Buzen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="527" to="531" />
			<date type="published" when="1973" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Exact solution of linear equations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Cabay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2nd ACM SYMSAC Symposium</title>
		<meeting>of the 2nd ACM SYMSAC Symposium</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1971" />
			<biblScope unit="page" from="392" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">The Throughput Analysis of Product-Form Queueing Networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Casale</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<pubPlace>Milan, Italy</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Politecnico di Milano</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Linearizer: A heuristic algorithm for queuing network models of computing systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">M</forename><surname>Chandy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Neuse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="126" to="134" />
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Computational algorithms for product-form queueing networks models of computing systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">M</forename><surname>Chandy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>Sauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="573" to="583" />
			<date type="published" when="1980" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Calculating normalization constants of closed queuing networks by numerically inverting their generating functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">L</forename><surname>Choudhury</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">K</forename><surname>Leung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Whitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J.ACM</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="935" to="970" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Basic Techniques of Combinatorial Theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J A</forename><surname>Cohen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1978" />
			<publisher>John Wiley and Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Mean value analysis by chain of product form queueing networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Conway</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>De Sousa E Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>Lavenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comp</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="432" to="442" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">RECAL -a new efficient algorithm for the exact analysis of multiple-chain closed queueing networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Conway</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">D</forename><surname>Georganas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J.ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="768" to="791" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Integrated performance models for spmd applications and mimd architectures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cremonesi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gennaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Par. Distr. Sys</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1320" to="1332" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A unifying framework for the approximate solution of closed multiclass queuing networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cremonesi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Schweitzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Serazzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comp</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="1423" to="1434" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Calculating joint queue-length distributions in product-form queueing networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>De Sousa E Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>Lavenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J.ACM</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="194" to="207" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Queueing networks: Solutions and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>De Sousa E Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">R</forename><surname>Muntz</surname></persName>
		</author>
		<idno>CSD-890052</idno>
		<imprint>
			<date type="published" when="1989-09" />
		</imprint>
		<respStmt>
			<orgName>CS Dep. -UCLA</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Linbox: A generic library for exact linear algebra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">G</forename><surname>Dumas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICMS&apos;02</title>
		<meeting>ICMS&apos;02<address><addrLine>Singapore</addrLine></address></meeting>
		<imprint>
			<publisher>World Scientific</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="40" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">What every computer scientist should know about floating-point arithmetic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Goldberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comp. Surv</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="5" to="48" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Matrix computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">H</forename><surname>Golub</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">F</forename><surname>Van Loan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Johns Hopkins Univ. Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">GNU MP: The GNU Multiple Precision Arithmetic Library</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Granlund</surname></persName>
		</author>
		<ptr target="http://www.swox.se/" />
		<imprint>
			<date type="published" when="2000-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On normalizing constants in queueing networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">G</forename><surname>Harrison</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations research</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="464" to="468" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">On the asymptotic behaviour of closed multiclass queueing networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">G</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Coury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Perf. Eval</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="131" to="138" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A new recursive algorithm for computing generating functions in closed queueing networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">G</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">T</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2004 IEEE Int&apos;l MASCOTS Symposium</title>
		<meeting>of the 2004 IEEE Int&apos;l MASCOTS Symposium</meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="223" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Throughput bounds for closed queueing networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kriz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Perf. Eval</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="10" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Dynamic scaling and growth behavior of queueing network normalization constants</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J.ACM</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="492" to="513" />
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A simple derivation of the mva and lbanc algorithms from the convolution algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comp</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="1062" to="1064" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A perspective on queueing models of computer performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>Lavenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Perf. Eval</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="53" to="76" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Quantitative System Performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">D</forename><surname>Lazowska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zahorjan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">S</forename><surname>Graham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">C</forename><surname>Sevcik</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984" />
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A proof of the queueing formula L = λW</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D C</forename><surname>Little</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="383" to="387" />
			<date type="published" when="1961" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">The exact solution of systems of linear equations with polynomial coefficients</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">T</forename><surname>Mcclellan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J.ACM</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="563" to="588" />
			<date type="published" when="1973" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Asymptotic expansions and integral representations of moments of queue lengths in closed markovian networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mckenna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Mitra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J.ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="346" to="360" />
			<date type="published" when="1984-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Queueing networks with multiple closed chains: Theory and computational algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Reiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kobayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM J. Res. Dev</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="283" to="294" />
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Mean-value analysis of closed multichain queueing networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Reiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>Lavenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J.ACM</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="312" to="322" />
			<date type="published" when="1980" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">The method of layers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Rolia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">C</forename><surname>Sevcik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Soft. Eng</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="689" to="700" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Approximate analysis of multiclass closed networks of queues</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Schweitzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Int&apos;l Conf. on Stoch. Control and Optim</title>
		<imprint>
			<biblScope unit="page" from="25" to="29" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Mean value analysis of product form solution queueing networks with repetitive service blocking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sereno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Perf. Eval</title>
		<imprint>
			<biblScope unit="page" from="19" to="33" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pari</forename><surname>The</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Group</surname></persName>
		</author>
		<ptr target="http://pari.math.u-bordeaux.fr/" />
		<imprint>
			<date type="published" when="2004" />
			<pubPlace>Bordeaux</pubPlace>
		</imprint>
	</monogr>
	<note>PARI/GP, version 2.1.5</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Balanced job bound analysis of queueing networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zahorjan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">C</forename><surname>Sevcik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Eager</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Galler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="134" to="141" />
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
