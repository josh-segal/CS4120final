<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T17:02+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">DESIGN REAL-TIME JAVA REMOTE METHOD INVOCATION: A SERVER-CENTRIC APPROACH</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sangig</forename><surname>Rho</surname></persName>
							<email>sangigr@cs.tamu.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Byung</forename><forename type="middle">Kyu</forename><surname>Choi</surname></persName>
							<email>bkchoi@mtu.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Riccardo</forename><surname>Bettati</surname></persName>
							<email>bettati@cs.tamu.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution">Samsung Electronics Suwon</orgName>
								<address>
									<country key="KR">Korea</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution" key="instit1">Michigan Tech. University Houghton</orgName>
								<orgName type="institution" key="instit2">Texas A&amp;M University College Station</orgName>
								<address>
									<postCode>49931, 77843</postCode>
									<region>MI, TX</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">DESIGN REAL-TIME JAVA REMOTE METHOD INVOCATION: A SERVER-CENTRIC APPROACH</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Real-Time</term>
					<term>Java</term>
					<term>Remote Method Invocation</term>
				</keywords>
			</textClass>
			<abstract>
				<p>In this paper, we design a real-time Java Remote Method Invocation (RMI). Real-time timing constraints are preserved in a server centric fashion where Java RMI servers keep information for real-time guarantees. Remote method invocations are modeled as sporadic events and so treated by a Total Bandwidth server, a guaranteed-rate scheduler. The replenishment period of the Total Bandwidth server is determined probabilistically. According to our measurements , the overhead we added for implementing real-time capabilities is negligible and the latency of real-time RMI is very stable and predictable.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A number of efforts have extended component-based systems to support real-time applications, for example with means to specify any real-time properties such as worstcase execution times and deadlines of services. The TAO project <ref type="bibr" target="#b13">[15]</ref> has implemented a CORBA that preserves the priority levels of calls across component boundaries. <ref type="bibr">Stankovic et al. [17]</ref> have proposed an approach for building embedded systems software through component-based techniques. Their VEST toolkit provides a rich set of dependency checks to support distributed embedded system development via components. The specification for realtime CORBA has also been proposed by an OMG working group <ref type="bibr" target="#b14">[16]</ref>. The real-time CORBA specification extends standard CORBA with features for management of CPU, network, and memory resources. It allows to use either server declared or client propagated model for fixed priority scheduling between client and server. All these real-time extensions provide very limited isolation across components in the temporal domain: TAO, for example, relies on static priority scheduling with priority inheritance across components. The temporal behavior of individual components therefore depends on the behavior of other components, specifically on that of higher-priority ones. Due to the priority inheritance, it depends on the execution of remote components as well, for example when a remote high-priority component triggers the execution of methods provided by another local component.</p><p>In this work we use a server-centric approach for scheduling real-time Java RMI <ref type="bibr" target="#b17">[19]</ref>. That enables the isolation of the components from clients in terms of guaranteeing real-time properties of the exported services of the components. The server-centric approach adopts component declared real-time property model instead of client propagated real-time property model for the exported services:</p><p>The components keep the information of real-time properties for the exported services rather than inheriting those from clients in the component declared real-time property model. As a result, clients cannot affect how the workload is executed on the component, and so temporal component isolation is provided.</p><p>This paper is organized as follows. In Section 2, we briefly discuss related work. Our system model is described in Section 3, followed by design details in Section 4. The evaluation is provided in Section 5. Conclusions are in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>The Real-Time Specification for Java (RTSJ) <ref type="bibr" target="#b1">[3]</ref> extends The Java Language Specification <ref type="bibr" target="#b5">[7]</ref> and The Java Virtual Machine Specification <ref type="bibr" target="#b8">[10]</ref> and provides application programming interfaces for real-time capabilities. The RTSJ, coupled with a real-time operating system, leverages the capability of Java for developing real-time systems in the sense that it separates hard real-time, soft real-time and non-real-time threads. The RTSJ Reference Implementation (RI) from TimeSys <ref type="bibr" target="#b18">[20]</ref> and jRate <ref type="bibr" target="#b4">[6]</ref> have implemented the RTSJ.</p><p>However, both the RTSJ and its implementations do not support real-time capabilities for Java RMI. There have been several efforts for integrating the RTSJ with the Java RMI mechanism, for example Jensen <ref type="bibr" target="#b7">[9]</ref>, Clark et al. <ref type="bibr" target="#b3">[5]</ref>, and Wellings et al. <ref type="bibr" target="#b19">[21]</ref>. Jensen <ref type="bibr" target="#b7">[9]</ref> has proposed the Distributed Real-Time Specification for Java (DRTSJ). The DRTSJ addresses predictability of end-to-end timeliness in dynamic distributed real-time systems. In distributed realtime computing systems, end-to-end timing constraints can be maintained over multi-node applications under each node's current environment. The DRTSJ has been designed for general cases of dynamic distributed real-time computing systems. Therefore, it is not easy to know each node's current environment a priori, such as latency properties of OS and network infrastructure, and system resource utilization. To achieve end-to-end multi-node timeliness, the properties of each multi-node application behavior's timeliness need to be propagated to the resource managers of the OS and the Java Virtual Machine (VM) <ref type="bibr" target="#b8">[10]</ref> on each node.</p><p>The DRTSJ suggests three ways to integrate Java RMI with the RTSJ: based on changes to the RTSJ and Java RMI. The first approach does not expect timely delivery of messages and inheritance of scheduling parameters between real-time Java threads and remote objects. It therefore suggests no changes to the RTSJ and Java RMI. The second approach expects timely delivery of messages and inheritance of scheduling parameters between realtime Java threads and real-time remote objects. It therefore suggests extensions required to Java RMI but no extensions required to the RTSJ or the real-time Java VM. The third approach suggests extensions required to Java RMI, the RTSJ and the real-time Java VM to support distributed thread functionality. In distributed thread models, a distributed thread has a system-wide ID and the feature of transparent propagation of its properties along its execution environments. While the last approach can be considered an ultimate solution, due to the practical difficulty of realization, attention has been paid to the second approach. For example, Borg et al. <ref type="bibr" target="#b2">[4]</ref>, following the second, proposed a framework to support real-time RMI. All these approaches are, however, still based on a client propagated real-time property model. Our approach, designed in a server-centric fashion, supports temporal isolation of realtime Java RMI server components. Since Remote method invocations are modeled sporadic events and treated by a Total Bandwidth server the latency of real-time RMI is stable and predictable.</p><p>time units to execute on a reference host, takes </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Task Model</head><p>We assume that remote methods are invoked synchronously: The execution on the caller is temporarily suspended while the thread of control transfers to the component with the remote method. Upon completion of the remote invocation, the thread of control migrates back to the caller, which in turn resumes execution. We provide realtime guarantees in form of deadline guarantees to remote method invocations. We say that we guarantee a deadline <ref type="bibr" target="#b3">5</ref> to a task 6 if we guarantee that every job is completed by at most 5 time units after it has been invoked. In other words, the maximum response time of the remote method is bounded by <ref type="bibr" target="#b3">5</ref> . This can be provided by appropriate timing isolation. By timing isolation we mean that the worst-case response time of jobs in a task does not depend on the processortime demands of other tasks. To provide timing isolation at scheduling level, one can use guaranteed-rate schedulers. Examples of such algorithms are the Constant Utilization Server, the Total Bandwidth Server, and the Preemptive Weighted Fair-queueing Server <ref type="bibr" target="#b9">[11]</ref>. We have chosen the Total Bandwidth Server for our guaranteed-rate scheduling over the other two for two reasons: (1) The Total Bandwidth Server outperforms the Constant Utilization Server in terms of utilizing background time not used by periodic tasks. <ref type="formula">(2)</ref> The proportional share scheduling algorithms, such as the Preemptive Weighted Fair-queueing Server, make no QoS guarantees if the sum of total weights grows very large <ref type="bibr" target="#b10">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The Workload Models</head><p>We expect task invocations to be very bursty in the system we envision, for three reasons: First, any task may consist of invocations from more than one client, thus resulting naturally in a bursty invocation pattern. Second, no explicit policing mechanism exists to shield the system from bursty invocations. Third, even if invocations from clients were periodic, cascaded invocations to subsequent components would still be jittered by execution and scheduling, and so would be bursty. As a result, we model task arrival as sporadic: The detailed arrival time of the nest invocation is unknown a priori, but worst-case execution time and deadline become known upon arrival. The invoked jobs of the sporadic task are scheduled by using a Total Bandwidth Server. Specifically, a Total Bandwidth Server is configured for each remote method of every component. Every Total Bandwidth Server then allocates and controls the amount of CPU time that is consumed for execution of the assigned remote method on the component. As a side effect, it shapes the service interval between successive jobs that invoke the same remote method of the same component. This allows for a simple, utilization-based, admission control for both types of tasks.</p><p>The response time of each job 7 of <ref type="table">Task   6</ref> is what the client experiences as latency. If we do not take into ac- . If a guaranteed-rate scheduler (in the following we limit the presentation to the Total Bandwidth Server) handles the jobs for a given component, and if appropriate admission control ensures that the server is not overloaded, then the relative deadline of Job can be guaranteed to meet its deadline through appropriate admission control. The following shows how our workload models look like. <ref type="table" target="#tab_0">Table 1</ref> describes the notations used for our workload models. , and it also invokes one or more other single-chained remote methods on one or more other components. By single-chained remote method we mean that the execution of the remote method invokes only local methods. In this case, the workload of Job and the maximum response time for getting the result from each single-chained remote method. Therefore, the workload of this kind of Job 7 is calculated by the following:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Invocations of Local Methods</head><formula xml:id="formula_0">¢ £ § ¦ ¥ § § ¦ ¨ £ § " § ¦ ¢ ¤ £ © ¥ § § ¦ ¨ £ § " # § ¦ % $ &amp; © ' ¥ ) ( 0 ¨ £ ) ( 2 1</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Admission Control Policy</head><p>Before new components are created and installed, an admission control step has to make sure that sufficient computing resources on the host can be allocated to the remote methods of the new component without affecting other components on the host. For this, worst-case execution times of remote methods are determined either during system design or system configuration. Similarly, the utilizations allocated to components and their remote methods are defined during system configuration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Proposed Methodology</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Design Issues for Providing Real-Time Capable Java RMI</head><p>We identified three issues that must be addressed when realizing a real-time capable Java RMI System. First, the export of a remote object involves creating a number of Java threads. One of those threads listens for incoming calls to the exported remote object. The others are worker threads for handling each accepted incoming request separately. To guarantee real-time properties, the Java VM must support real-time capable threads. Second, clients must be able to propagate real-time timing constraints to the remote object. This object may in turn invoke remote methods on other remote objects in different Java VMs, thus act as client to other remote objects. Finally, we consider open systems, where we have no control over number and behavior of clients. As a result, invocations can arbitrarily be bursty, due either to relative phasing of client requests, or to the invocation pattern of single clients. One of the features of client arrivals should be aperiodic. There may be bursty arrivals of clients as well. In the following sections, we propose our solutions to the three issues listed above. We adopt an early version of TimeSys RTSJ RI for our implementation base <ref type="bibr" target="#b0">1</ref> . Due to the limited space, however, detailed design of Java classes is not shown in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Real-Time Java Threads</head><p>Whenever an incoming call arrives, the listening thread creates a real-time worker thread for handling the request from the incoming call. The real-time worker thread executes the run() method of class ConnectionHandler. In order to maintain a high responsiveness to incoming requests, we design three types of real-time threads, which differ by their priorities: (1) Worker threads execute the remote method invocations at their assigned priorities. <ref type="formula">(2)</ref> The EDF scheduling thread handles worker threads, and runs at a priority higher than all worker threads. <ref type="formula">(3)</ref> The listening thread runs at priority higher than both worker threads and EDF scheduler. In this way, the listening thread executes like an interrupt service routine, which is very short and provides system responsiveness by executing at highest priority. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The Adjustment of Priorities of Real-Time Worker</head><p>Threads Based on Admitted Utilization During the invocation of an exported remote method on the server side, a real-time worker thread dispatches an up-call to the remote object. At this time, we get the object reference of the remote object and the name of the target method. Our local admission control component provides the information about the workload and utilization of the target method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">A Server-Centric Approach for Preserving Real-Time Timing Constraints</head><p>By server-centric we mean that the real-time server components keep information for meeting real-time guarantees instead of delivering and inheriting the scheduling and release parameters of the server components between clients and themselves. According to our task model, those timing constraints are defined as workload, deadline and utilization of each remote method of an exported remote object. The main reason why we choose the server-centric approach is to provide component isolation, which in turn greatly simplifies the admission control needed for component creation and remote method invocation. We use an utilization-based admission control to guarantee real-time properties of remote method invocation. By utilizationbased admission control we mean that total utilization reserved for each method should be available at the candidate host for remote invocations. The server-centric approach also reduces the overhead of remote invocations, as there is no need to exchange timing information as part of the remote invocation at run-time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Guaranteed-Rate Scheduling for Sporadic Real-Time Tasks</head><p>The Total Bandwidth Server The Total Bandwidth Server is a periodic server and is defined by two rules, consumption and replenishment rules. In this section we follow J. Liu <ref type="bibr" target="#b9">[11]</ref> to describe the operation of the Total Bandwidth Server. Initially, our Total Bandwidth Server sets the server's execution budget</p><formula xml:id="formula_1">¢ ¡ ¤ £ ¦ ¥ ¨ § ©</formula><p>and deadline of the server</p><formula xml:id="formula_2">5 § ! " £ ¨ $ # &amp; % § ¦ '</formula><p>to zero. When a sporadic job with execution time</p><formula xml:id="formula_3">( 0 ) 1 § ! 2 3 ¡ 4 © # 5 ! % 6 # £ § 7 6 9 8 § (</formula><p>arrives at a time t to a job queue with no backlogged jobs, our Total Bandwidth Server sets</p><formula xml:id="formula_4">5 § ! £ ¨ @ # A % § ¦ to (max( 5 - § ! £ ¨ @ # A % § 7 , t) + ( 0 ) 1 § ! 2 3 ¡ 4 © # 5 ! % 6 # £ § ! 6 9 8 § ( / © © #¨$ #¨$ # B " © # - 5 ! % ) and ¢ ¡ ¤ £ ¦ ¥ ¨ § © C equal to ( 0 ) 4 § 2 ¡ 1 © # 5 ! % 6 # £ - §6 D 8 § (</formula><p>. When the current sporadic job of the server finishes, and if the server is backlogged, our Total Bandwidth Server sets</p><formula xml:id="formula_5">5 § ! £ ¨ @ # &amp; % § '</formula><p>to <ref type="formula">(</ref>  evaluates the status of all instances of class javax.realtime.RealtimeThread. There are several requests from instances of class javax.realtime.RealtimeThread for putting their operating system threads into desired operating systems' states, such as start, stop, resume, sleep and suspend. The EDF scheduler also examines whether or not any instance of class javax.realtime.RealtimeThread missed its deadline and whether or not the operating system thread of an ongoing instance of class javax.realtime.RealtimeThread is alive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Probabilistic Approach for Characterizing Total</head><p>Bandwidth Servers Each Total Bandwidth Server is characterized by the two parameters: the maximum budget and the replenishment period. While the maximum budget can be established by an execution-time analysis of the remote methods, it is difficult to choose an optimal replenishment period of the Total Bandwidth Server.</p><p>If we assume that inter-arrival times of client requests for each remote method are distributed based on a given distribution function, we have two options for deciding the replenishment period: One option is to use the minimum inter-arrival time of invocations as the replenishment period. This approach is not applicable to open systems, where little is known about the client population. Setting the invocation period short enough to handle the bursty arrivals caused by bursty client invocations and by phasing of invocations from multiple clients would lead to unacceptably low utilization of host resources. Alternatively, one can take probabilistic approach. In this approach, each Total Bandwidth Server is modeled as a G/D/1 queue <ref type="bibr" target="#b0">[1]</ref>. Client requests arrive in the queue with a randomly distributed arrival time, and the Total Bandwidth Server allows for execution of the requested remote method for the given maximum budget time units in each period of the Total Bandwidth Server. , we can have</p><formula xml:id="formula_6">" !¡ £ " ) # © % $ £ $ ¥ &amp; !¡ ' £ ( ¥1 # " § )</formula><p>, after some manipulation.</p><p>As </p><formula xml:id="formula_7">£ £ " § B D 4 Q ¡6 F I H P F 8 ' 9 0 £ £ " § B D 4 Q ¡6</formula><p>The transition probability matrix T looks like the following:</p><formula xml:id="formula_8">e f f f f f f f f f f g E i h p r q S s u t p E i h p v q w s y x   y t p E i h p r q S s  x S   t p E i h p r q S s  x w w t p   t s     t s t s  x   t s y x w   t s     t s     t s t s y x    t s    t s     t s     t s  t s     t s    t s     t s   S       t        t                      </formula><p>Again, we can get the state probability matrix 3</p><p>, where e f f g DR4</p><formula xml:id="formula_9">" 6 D ¡ 4 " 6 D £ 4 " 6 ¥    e f f g E F ' H # ` ' ¥ ¥ ¥ ` # ¡ ¥ ¥ ¥ ¥ ¥ ¥ ¥ ¥ ¥ ¥ ¥    ' e f f g DR4 ¡6 D ¡ 4 ¡6 D £ 4 ¡6 ¥   </formula><p>Other models of the inter-arrival will produce a similar matrix of probability. In this probabilistic approach, we can get an optimal period of a Total Bandwidth Server, § , which maximizes the value of</p><formula xml:id="formula_10">D  R4 &amp; 6</formula><p>with a given distribution function of inter-arrival times of client requests and the worst-case execution time of each remote method. Finally, the utilization of each remote method can be defined by dividing the maximum budget by the replenishment period § of the Total Bandwidth Server for each remote method. Given these parameters, the Total Bandwidth Server is fully defined.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experimental Evaluation</head><p>In this section, we evaluate the real-time capabilities of the extensions to Java RMI described in the previous sections. First, the average and standard deviation of execution times of a local method are measured on five different Java Virtual Machines (VMs). This experiment illustrates the level at which each Java VM guarantees predictable execution times for local methods. We also use the same local method as a target method for upcalls requested by RMI clients throughout the experiments of this section. In this way, we can later determine the net average overhead of remote method invocations in addition to the execution time of the local method. In a second step, we measure latency of the remote method invocations. This experiment evaluates whether or not our methodology provides predictable latency for a real-time RMI server in the presence of heavily CPU-bound tasks. Finally, we evaluate the performance of the EDF job scheduler and the Total Bandwidth Server that ensure predictable execution times for both periodic and sporadic real-time tasks. In order to focus on real-time performance we use the simple configuration depicted in <ref type="figure" target="#fig_5">Figure 1</ref>, where a network analyzer is directly connected between two hosts (Dell Dimension 4100 Pentium III 933 MHz with memory of 256 Megabytes). We use a Fast Ethernet that supports 100 Mbps. We also use an Agilent Technologies Network Analyzer that has nanosecond timer resolution and Windows 2000 Pro Embedded with two CPUs. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Local Method Execution Time</head><p>For comparison of local execution time, we have used TimeSys 3.1 Real-Time version for OS and five Java VMs: JDK 2 1.3.0-classic VM, JDK 1.3.0-interpreted mode, JDK 1.3.0-mixed mode <ref type="bibr" target="#b16">[18]</ref>, TimeSys Real-Time Specification for Java Reference Implementation (RTSJ RI) <ref type="bibr" target="#b18">[20]</ref>, and TAMU RTSJ RI with Real-Time Remote Method Invocation (RT-RMI), that is, our implementation. <ref type="figure" target="#fig_6">Figure 2</ref> shows the average execution time of a local method for each Java VM. This was measured on the server (Dell Dimension 4100 Pentium III 933 MHz with memory of 256 Megabytes). As can be seen, all JDK versions take less time to execute the local method than the TimeSys RTSJ RI. TimeSys RTSJ RI takes approximately six times longer than JDK 1.3.0-mixed mode. This is because the TimeSys version is 1) targeted toward real-time execution, thus does not contain many optimizations that optimize performance, and 2) is a very preliminary implementation. Because we use an early version of TimeSys RTSJ RI as base to implement TAMU RTSJ RI with RT-RMI, our implementation inherits the overhead of the TimeSys version. Importantly, however, as shown in <ref type="figure" target="#fig_6">Figure 2</ref>, the overhead of adding RT-RMI to our implementation is negligible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Latency of Remote Method Invocation</head><p>In this experiment, the real-time Java RMI performance is measured in terms of averages of the latencies of periodic remote method invocations. We show the latency of remote method invocation by measuring the time difference between the moment of client's sending of the first packet of the RMI request and the moment of server's sending of the last packet of the result. The Agilent Technologies network analyzer captures all packets on the link between the server and the client. We use Ethereal in order to extract timing information from the captured packets by using a refined data display for the RMI protocol. The use of the network analyzer allows our measurements not to perturb the execution of the RMI server. For periodic job arrivals multi-threaded client application generates remote method invocations to the server. Java VM Running One RMI Server and High Background Load We run two non-real-time Java applications that compress big size of files on the RMI server's Java VM to generate a high background load. <ref type="figure" target="#fig_7">Figure 3</ref> shows the latency of remote method invocations on three Java VMs: JDK 1.3.0-interpreted mode, JDK 1.3.0-mixed mode, and TAMU RTSJ RI with RT-RMI. As can be seen, JDK 1.3.0-interpreted and mixed modes show unusual high latencies. It apparently shows sporadic long latencies of JDK 1.3.0-interpreted and mixed modes while TAMU RTSJ RI with RT-RMI shows very predictable latency. TAMU RTSJ RI with RT-RMI, the top line, has larger average latency than those of two JDK 1.3.0 modes. Again, however, as can be recalled from <ref type="figure" target="#fig_6">Figure 2</ref>, the average latency of TAMU RTSJ RI with RT-RMI for executing remote methods is inherited from the early version of TimeSys RTSJ RI. <ref type="figure" target="#fig_8">Figure 4</ref> shows the decomposition of standard deviation of RMI latency. As can be seen, large portion of the deviations are due to RMI protocol handling in non-TAMU JDK versions. Conversely, this figure also clearly demonstrates that our RT-RMI implementation (i.e., addition of real-time worker thread management and Total Bandwidth Server) greatly increases RMI predictability. This result demonstrates that TAMU version clearly supports real-time capability while the other two versions do not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Java VM Running One RMI Server and Varying</head><p>Amount of Background Load <ref type="figure">Figure 5</ref> shows the comparison of average and standard deviation of the RMI server's latencies in server execution environments where other workloads run together. The RMI server consumes 22% of CPU utilization. In <ref type="figure">Figure 5</ref> each label in horizontal axis stands for the following. "None": there is no other workload in the server VM except the RMI server. "BG-25": one background Java thread is running in the RMI server's VM, which consumes 25% of CPU utilization. It is not under control of our EDF scheduler for experiment purposes. "Two RT-10s": two real-time Java threads are running in the RMI server's VM. Each thread performs CPU-bound computations periodically and consumes 10%   <ref type="figure">Figure 5</ref>. RMI Latency with Varying Amount of Background Load of the RMI server's latencies increases very slightly as the workload of a real-time Java thread increases. For example, there is an increase of only 3.68% in average latency of the RMI server when a real-time Java thread consumes 60% of CPU utilization in the RMI server's VM. In addition, <ref type="figure">Fig- ure 6</ref> shows the decomposition of the RMI server's latencies of the same experiment with <ref type="figure">Figure 5</ref>. As can be seen in <ref type="figure">Figure 6</ref>, the averages of the RMI latencies both for invoked method and RMI protocol handling vary little when the workloads of other tasks that run on the RMI server's VM change widely. This result demonstrates that TAMU RTSJ RI with RT-RMI provides predictable latency of remote method invocations even in conditions with varying amount of background load. RMI protocol handling invoked method <ref type="bibr">Latency (millisecs)</ref> no workload 25% of CPU utilization for a background process 20% of CPU utilization for two real-time Java threads 10% of CPU utilization for a real-time Java thread 20% of CPU utilization for a real-time Java thread 30% of CPU utilization for a real-time Java thread 40% of CPU utilization for a real-time Java thread 50% of CPU utilization for a real-time Java thread 60% of CPU utilization for a real-time Java thread <ref type="figure">Figure 6</ref>. Decomposition of RMI Latency with Varying Amount of Background Load</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>In this paper, we designed and implemented a realtime Java Remote Method Invocation (RMI). By using a server centric approach and a Total Bandwidth server, we achieved efficient and effective real-time guarantees for Java RMI applications. We believe that this work is an important and interesting step toward distributed real-time systems, a grand goal of the real-time research community.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>7 can be calculated by the following: Workload of Job 7 Utilization of Total Bandwidth Server for Job 7 Therefore, if we have a correct workload model for each job 7 on a component, Job 7</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>We can model the job 7 of Task 6 as an invocation of a remote method ¡ on a component © , where the execution of the remote method ¡ invokes only local methods on Component © . In this case, the workload of Job 7 is the sum of the worst- case execution time of each local method on Component © . Therefore, the workload of this kind of Job 7 is cal- culated by the following: ¢ £ ¡ ¥ ! ¡ ¨ £ Invocations of Local and Single-Chained Remote Meth- ods We can model the job 7 of Task 6 as an invocation of a remote method § ¦ on a component © § , where the execution of the remote method § ¦ invokes local meth- ods on Component © §</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>7 is the sum of the worst-case execution time of each local method on Component © §</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Following Abeni et al. [1], we describe the sequence of invocations as a random process ¢ ¡ ¤ £ ¦ ¥ ¤ £ ¨ § , where ¡ and ¥ denote the absolute deadline and the ar- rival time of the # ( % request, respectively, and § denotes the period of a Total Bandwidth Server. By the replenishment rules of the Total Bandwidth Server, the absolute deadline is ¡ £</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. The Experiment Environment</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Average and Standard Deviation of Local Method Execution Time on TimeSys 3.1-RT</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. RMI Latency with High Background Load</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Standard Deviation of RMI Latency</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>Table 1 . Notations for Workload Models</head><label>1</label><figDesc></figDesc><table>Notation 
Description </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>After that, the EDF scheduler</head><label></label><figDesc>is again ready by the replenishment rules of the Total Band- width Server and the server becomes backlogged by arrival of a sporadic job, the scheduler changes the status of the server thread as ready. The EDF Scheduler for Total Bandwidth Servers Bandwidth-preserving schedulers (such as the Total Band- width Server) are typically implemented on top of an EDF scheduling mechanism. Therefore, we designed and im- plemented an EDF scheduler class that is compliant with the RTSJ RI. When the EDF scheduler has the control of a CPU, the EDF scheduler first checks whether there is any newly admitted instance of javax.realtime.RealtimeT- hread class or not. If it is, the EDF scheduler creates an instance of class ao.realtor.scheduler.EDFScheduler$Sch- edulableData apiece for managing instances of class java- x.realtime.RealtimeThread.</figDesc><table>5 

 § 
! 
" £ 

¨ 

$ # 
&amp; % 
 § 







+ 

( 
0 ) 
1  § 
! 2 

-

¡ 
4 © 
# 
&amp; 5 
! % 

6 

# 

£ 

 §6 
D 8 

 § 

( 

/ 

© 

© 
#¨@ #¨@ # 
B 
" © 
# 
5 
! % 





' 

) and 


¢ ¡ 
¤ £ 
¦ ¥ 
¨  § 
© 




' 

equal to 

( 
0 ) 
1  § 
! 2 
3 ¡ 
4 © 
# 
5 
! % 

6 

# 

£ 

 §6 
9 8 

 § 

( 

. When the current spo-
radic job of the server finishes and if the server is not back-
logged, our Total Bandwidth Server does nothing. Our 
scheduler should take care of the following: 1) The sched-
uler keeps track of the Total Bandwidth Server's budget 

-

¡ 
¤ £ 
¦ ¥ 
¨  § 
© 
C 
" 
' 




. 2) When the budget 


E ¡ 
4 £ 
F ¥ 
¨  § 
G © 







reaches 
to zero, the scheduler suspends the thread of the sever. 3) 
When the server becomes idle, the scheduler suspends the 
thread of the sever. 4) When the budget 


E ¡ 
4 £ 
F ¥ 
¨  § 
G © 







</table></figure>

			<note place="foot" n="1"> An academic non-commercial version, which is not optimized for better performance.</note>

			<note place="foot" n="2"> Java Development Kit; the standard Java development tools provided by Sun Microsystems.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Integrating Multimedia Applications in Hard Real-Time Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Abeni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Buttazzo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Real Time System Symposium</title>
		<meeting><address><addrLine>Madrid, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">The Real-Time Specification for Java ¡</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Bollella</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Boston</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A Real-Time RMI Framework for the RTSJ</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Borg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wellings</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th Euromicro Conference on Real-Time Systems</title>
		<meeting>the 15th Euromicro Conference on Real-Time Systems</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The Distributed Real-Time Specification for Java: A Status Report</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wellings</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wells</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Embedded Systems Conference</title>
		<meeting>Embedded Systems Conference<address><addrLine>San Francisco</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The Design and Performance of the jRate Real-time Java Implementation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Corsaro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schmidt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Distributed Objects and Applications</title>
		<meeting><address><addrLine>Irvine, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-10" />
		</imprint>
		<respStmt>
			<orgName>University of California</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">The Java ¡ Language Specification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gosling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Joy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Steele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Bracha</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<publisher>AddisonWesley</publisher>
			<pubPlace>Boston</pubPlace>
		</imprint>
	</monogr>
	<note>Second Edition</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
				<ptr target="p://java.sun.com/j2se/1.3/docs/guide/serialization/" />
	</analytic>
	<monogr>
		<title level="m">Available at: htt</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The Distributed Real-Time Specification for Java -An Initial Proposal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Jensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Systems Science and Engineering</title>
		<imprint>
			<date type="published" when="2001-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">The Java ¡ Virtual Machine Specification Second Edition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lindholm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Yellin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Boston</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Real-Time Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">W S</forename><surname>Liu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Supporting Dynamics QoS in Linux</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Goddard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th IEEE Real-Time and Embedded Technology and Applications Symposium</title>
		<meeting>the 10th IEEE Real-Time and Embedded Technology and Applications Symposium<address><addrLine>Toronto, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>De Miguel</surname></persName>
		</author>
		<title level="m">The Fourth IEEE International Symposium on Object-Oriented Real-Time Distributed Computing</title>
		<meeting><address><addrLine>Magdeburg, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-05" />
			<biblScope unit="page" from="379" to="386" />
		</imprint>
	</monogr>
	<note>Solutions to make Java-RMI Time Predictable</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Real-time Specification for Java (RTSJ), developer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Palu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<publisher>com</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Real-time CORBA with TAO</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">C</forename><surname>Schmidt</surname></persName>
		</author>
		<ptr target="http://www.cs.wustl.edu-/¢schmidt/TAO.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An overview of the realtime CORBA specification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">C</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Kuhns</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="56" to="63" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">VEST: An aspectbased composition tool for real-time systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Stankovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Poornalingam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Humphrey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Ellis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Real-Time and Embedded Technology and Applications Symposium</title>
		<meeting>the IEEE Real-Time and Embedded Technology and Applications Symposium<address><addrLine>Toronto, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Sun Microsystems, java -the Java application launcher</title>
		<ptr target="http://java.sun.com/j2se/1.3/-docs/tooldocs/linux/java.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Java ¡ Remote Method Invocation Specification (RMI)</title>
		<imprint>
			<date type="published" when="1999-12" />
		</imprint>
		<respStmt>
			<orgName>Sun Microsystems</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Available at</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Timesys</surname></persName>
		</author>
		<ptr target="http://www.timesys.com" />
	</analytic>
	<monogr>
		<title level="j">The RTSJ Reference Implementation (RI)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A Framework for Integrating the Real-Time Specification for Java and Java&apos;s Remote Method Invocation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wellings</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wells</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Symposium on Object Oriented RealTime Distributed Computing</title>
		<meeting>International Symposium on Object Oriented RealTime Distributed Computing</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
