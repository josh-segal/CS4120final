<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:46+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Multiple-Source Multiple-Sink Maximum Flow in Directed Planar Graphs in Near-Linear Time</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2011-05-11">May 11, 2011</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Glencora</forename><surname>Borradaile</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Oregon State University</orgName>
								<orgName type="institution" key="instit2">Brown University</orgName>
								<orgName type="institution" key="instit3">Brown University</orgName>
								<orgName type="institution" key="instit4">Tel-Aviv University</orgName>
								<orgName type="institution" key="instit5">Carleton University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philip</forename><forename type="middle">N</forename><surname>Klein</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Oregon State University</orgName>
								<orgName type="institution" key="instit2">Brown University</orgName>
								<orgName type="institution" key="instit3">Brown University</orgName>
								<orgName type="institution" key="instit4">Tel-Aviv University</orgName>
								<orgName type="institution" key="instit5">Carleton University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shay</forename><surname>Mozes</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Oregon State University</orgName>
								<orgName type="institution" key="instit2">Brown University</orgName>
								<orgName type="institution" key="instit3">Brown University</orgName>
								<orgName type="institution" key="instit4">Tel-Aviv University</orgName>
								<orgName type="institution" key="instit5">Carleton University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yahav</forename><surname>Nussbaum</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Oregon State University</orgName>
								<orgName type="institution" key="instit2">Brown University</orgName>
								<orgName type="institution" key="instit3">Brown University</orgName>
								<orgName type="institution" key="instit4">Tel-Aviv University</orgName>
								<orgName type="institution" key="instit5">Carleton University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Wulff-Nilsen</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Oregon State University</orgName>
								<orgName type="institution" key="instit2">Brown University</orgName>
								<orgName type="institution" key="instit3">Brown University</orgName>
								<orgName type="institution" key="instit4">Tel-Aviv University</orgName>
								<orgName type="institution" key="instit5">Carleton University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Multiple-Source Multiple-Sink Maximum Flow in Directed Planar Graphs in Near-Linear Time</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2011-05-11">May 11, 2011</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We give an O(n log 3 n) algorithm that, given an n-node directed planar graph with arc capacities, a set of source nodes, and a set of sink nodes, finds a maximum flow from the sources to the sinks. Previously, the fastest algorithms known for this problem were those for general graphs.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The maximum flow problem with multiple sources and sinks in a directed graph with arc-capacities is, informally, to find a way to route a single commodity from a given set of sources to a given set of sinks such that the total amount of the commodity that is delivered to the sinks is maximum subject to each arc carrying no more than its capacity. In this paper we study this problem in planar graphs.</p><p>The study of maximum flow in planar graphs has a long history. In 1956, Ford and Fulkerson introduced the max st-flow problem, gave a generic augmenting-path algorithm, and also gave a particular augmentingpath algorithm for the case of a planar graph where s and t are on the same face Researchers have since published many algorithmic results proving running-time bounds on max st-flow for (a) planar graphs where s and t are on the same face, (b) undirected planar graphs where s and t are arbitrary, and (c) directed planar graphs where s and t are arbitrary. The best bounds known are (a) O(n) <ref type="bibr" target="#b13">[14]</ref>, (b) O(n log log n) <ref type="bibr" target="#b16">[17]</ref>, and (c) O(n log n) <ref type="bibr" target="#b1">[2]</ref>, where n is the number of nodes in the graph.</p><p>Maximum flow in planar graphs with multiple sources and sinks was studied by Miller and Naor <ref type="bibr" target="#b28">[29]</ref>. When it is known how much of the commodity is produced/consumed at each source and each sink, finding a consistent routing of flow that respects arc capacities can be reduced to negative-length shortest paths, which we now know can be solved in planar graphs in O(n log 2 n/ log log n) time <ref type="bibr" target="#b29">[30]</ref>. Otherwise, Miller and Naor gave an O(n log 3/2 n) algorithm for the case where all the sinks and the sources are on the boundary of a single face, and generalized it to an O(k 2 n 3/2 log 2 n)-time algorithm for the case where the sources and the sinks reside on the boundaries of k different faces. <ref type="bibr" target="#b0">1</ref> However, the problem of maximum flow with multiple sources and sinks in planar graphs without any additional restrictions remained open. In general (i.e., non-planar) graphs, multiple sources and sinks can be reduced to the single-source single-sink case by introducing an artificial source and sink and connecting them to all the sources and sinks, respectively-but this reduction does not preserve planarity. For more than twenty years since the problem was explicitly stated and considered <ref type="bibr" target="#b28">[29]</ref>, the fastest known algorithm for computing multiple-source multiple-sink max-flow in a planar graph has been to use this reduction in conjunction with a general maximum-flow algorithm such as that of Sleator and Tarjan <ref type="bibr" target="#b31">[32]</ref> which leads to a running time of O(n 2 log n). For integer capacities less than U , one could instead use the algorithm of Goldberg and Rao <ref type="bibr" target="#b9">[10]</ref>, which leads to a running time of O(n 1.5 log n log U ). No planarity-exploiting algorithm was known for the problem.</p><p>Our Result The main result of this paper is an algorithm for the problem that is optimal up to a small poly-logarithmic factor. Theorem 1.1. There exists an algorithm that solves the maximum flow problem with multiple sources and sinks in an n-node directed planar graph in O(n log 3 n) time.</p><p>Application to computer vision problems Multiple-source multiple-sink min-cut arises in addressing a family of problems associated with the terms metric labeling (Kleinberg and Tardos, <ref type="bibr" target="#b25">[26]</ref>), Markov Random Fields <ref type="bibr" target="#b8">[9]</ref>, and Potts Model (see also <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b14">15]</ref>). In low-level vision problems such as image restoration, segmentation, stereo, and motion, the goal is to assign labels from a set to pixels so as to minimize a penalty function. The penalty function is a sum of two parts. One part, the data component, has a term for each pixel; the cost depends on the discrepancy between the observed data for the pixel and the label chosen for it. The other part, the smoothing component, penalizes neighboring pixels that are assigned different labels.</p><p>For the binary case (when the set of available labels has size two), finding the optimal solution is reducible to multiple-source multiple-sink min-cut. <ref type="bibr" target="#b11">[12]</ref>. For the case of more than two labels, there is a powerful and effective heuristic <ref type="bibr" target="#b3">[4]</ref> using very-large-neighborhood <ref type="bibr" target="#b0">[1]</ref> local search; the inner loop consists of solving the two-label case. The running time for solving the two-label case is therefore quite important. For this reason, researchers in computer vision have proposed new algorithms for max flow and done experimental studies comparing the run-times of different max-flow algorithms on the instances arising in this context <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b26">27]</ref>. All of this is evidence for the importance of the problem.</p><p>For the (common) case where the underlying graph of pixels is the two-dimensional grid graph, our result yields a theoretical speed-up for this important computer-vision subroutine. <ref type="bibr" target="#b1">2</ref> Hochbaum <ref type="bibr" target="#b14">[15]</ref> describes a special case of the penalty function in which the data component is convex and the smoothing component is linear; in this case, she shows that an optimal solution can be found in time O(T (m, n) + n log U ) where U is the maximum label, and T (m, n) is the time for finding a minimum cut. She mentions specifically image segmentation, for which the graph is planar. For this case, by using our algorithm, the optimal solution can be found in nearly linear time Application to maximum bipartite matching Consider the problem of maximum matching in a bipartite planar graph. It is well-known how to reduce this problem to multiple-source, multiple-sink maximum flow. Our result is the first planarity-exploiting algorithm for this problem (and the first near-linear one).</p><p>Techniques To obtain our result, we employ a wide range of sophisticated algorithmic techniques for planar graphs, some of which we adapted to our needs while others are used unchanged. Our algorithm uses pseudoflows <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b15">16]</ref> and a divide-and-conquer scheme influenced by that of <ref type="bibr" target="#b18">[19]</ref> and that of <ref type="bibr" target="#b28">[29]</ref>. We adapt a method for using shortest paths to solve max st-flow when s and t are adjacent <ref type="bibr" target="#b12">[13]</ref>, and a data structure for implementing Dijkstra in a dense distance graph derived from a planar graph <ref type="bibr" target="#b7">[8]</ref>. Among the other techniques we employ are: using cycle separators <ref type="bibr" target="#b27">[28]</ref> recursively while keeping the boundary nodes on a constant number of faces <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b7">8]</ref>, an algorithm for single-source single-sink max flow <ref type="bibr" target="#b1">[2,</ref><ref type="bibr">7]</ref>, an algorithm for computing multiple-source shortest paths <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b4">5]</ref>, a method for cancelling cycles of flow in a planar graph <ref type="bibr" target="#b19">[20]</ref>, an algorithm for finding shortest paths in planar directed graphs with negative lengths <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b29">30]</ref>, and a data structure for range queries in a Monge matrix <ref type="bibr" target="#b20">[21]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Preliminaries</head><p>We assume the reader is familiar with the basic definitions of planar embedded graphs and their duals (cf. <ref type="bibr" target="#b1">[2]</ref>). Let G = (V, E) be a planar embedded graph with node-set V and arc-set E. We use the term arc to emphasize that edges are directed. The term edge is used when the direction of an arc is not important. For each arc a in the arc-set E, we define two oppositely directed darts, one in the same orientation as a (which we sometimes identify with a) and one in the opposite orientation <ref type="bibr" target="#b1">[2]</ref>. We define rev(·) to be the function that takes each dart to the corresponding dart in the opposite direction. It is notationally convenient to equate the edges, arcs and darts of G with the edges, arcs and darts of the dual G * .</p><p>Let S ⊂ V be a set of nodes called sources, and let T ⊆ V − S be a set of nodes called sinks. A flow assignment f (·) is a real-valued function on darts satisfying antisymmetry:</p><formula xml:id="formula_0">f (rev(d)) = −f (d) A capacity assignment c(·) is a real-valued function on darts. A flow assignment f (·) respects the capacity of dart d if f (d) ≤ c(d). f (·)</formula><p>is called a pseudoflow if it respects the capacities of all darts.</p><p>For a given flow assignment f (·), the net inflow</p><formula xml:id="formula_1">(or just inflow) node v is inflow f (v) = dart d:head(d)=v f (d) 3 . The outflow of v is outflow f (v) = −inflow f (v). A flow assignment f (·) is said to obey conservation at node v if inflow f (v) = 0.</formula><p>A feasible flow is a pseudoflow that obeys conservation at every node other than the sources and sinks. A feasible circulation is a pseudoflow that obeys conservation at all nodes. The value of a feasible flow f (·) is the sum of inflow at the sinks, t∈T inflow f (t) or, equivalently, the sum of outflow at the sources. The maximum flow problem is that of finding a feasible flow with maximum value.</p><p>For two flow assignments f , f , the addition f + f is the flow that assigns f (d) + f (d) to every dart d. A residual path in G is a path whose darts all have strictly positive capacities. For two sets of nodes A, B, A G → B is used to denote the existence of some residual a-to-b path in G for some nodes a ∈ A and b ∈ B. Conversely, A G B is used to denote that no such path exists. We will omit the graph G when it is clear from the context.</p><p>The residual graph of G with respect to a flow assignment f (·) is the graph G f with the same arc-set, nodeset, sources and sinks, and with capacity assignment c f (·) such that for every dart</p><formula xml:id="formula_2">d, c f (d) = c(d) − f (d).</formula><p>It is well known that a feasible flow f in G is maximum if and only if S G f T . Let f be a pseudoflow in a planar graph G. Let V + denote the set of nodes {v ∈ V − (S ∪ T ) : inflow f (v) &gt; 0}. Similarly, let V − denote the set of nodes {v ∈ V − (S ∪ T ) : inflow f (v) &lt; 0}. Suppose</p><formula xml:id="formula_3">S ∪ V + G f T ∪ V − .</formula><p>For a graph with n nodes and m edges, there exists an O(m log n)-time algorithm that converts the pseudoflow f into a maximum feasible flow f <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b31">32]</ref>. In planar graphs, this can be done in linear time by first canceling flow cycles using the technique of Kaplan and Nussbaum <ref type="bibr" target="#b19">[20]</ref>, and then by sending back flow from V + and into V − in topological sort order. See Appendix C for details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Overview of the algorithm</head><p>Consider the following recursive approach for finding a maximum multiple-source multiple-sink flow: split the input graph G in two using a simple cycle separator C <ref type="bibr" target="#b27">[28]</ref> and recursively solve the max flow problem in the two subgraphs. When the two recursive calls have been executed, in each of the two subgraphs there is no residual path from any source to any sink. If we further make sure that in each of the two subgraphs there is no residual path from any source to C and from C to any sink, then, since C is a separator, there is no residual path from any source to any sink in G.</p><p>We therefore solve a slightly more general problem recursively in the two subgraphs: roughly speaking, find a flow such that there is no residual path from a source to a sink or to C and no residual path from C to a sink (Section 2). After the two recursive calls there is no residual path from any source to any sink in G. However, the requirement that there is no residual path from any source to C and from C to any sink cannot be achieved by a feasible flow but rather by a pseudoflow in which there might be excess inflow or excess outflow on nodes of C. We deal with this by solving a new max flow problem where nodes of C are treated as sources and sinks, limited in supply/demand by their excess inflow/outflow (Section 3).</p><p>We exploit a relation between primal circulations and dual shortest paths to maintain a succinct representation of the flow during critical phases of the algorithm, using the fact that there are only O( √ n) sources and sinks, all cyclically ordered on C (Section 3.2). Even though our representation does not explicitly store the flow on nearly any arc in the graph, we can augment it efficiently towards optimality while maintaining feasibility. An important tool we use is Fakcharoenphol and Rao's efficient implementation of Dijkstra's algorithm <ref type="bibr" target="#b7">[8]</ref>, which we adapt to our needs.</p><p>The resulting pseudoflow can then be turned into a max flow in linear time using existing techniques <ref type="bibr">(Appendix C)</ref>. This leads to an O(n log 3 n) time algorithm for max flow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Algorithm</head><p>Now we describe the algorithm, referred to as MultipleSourceMultipleSinkMaxFlow, in more detail. In order to treat nodes of the cycle separator both as sources and as sinks in recursive calls, we introduce a new node set A. At the top recursion level, A = ∅. In general, A has constant size; more precisely |A| ≤ 6.</p><p>MultipleSourceMultipleSinkMaxFlow(G, c,S,T ,A) Input: a directed planar graph G with non-negative capacities c, a set S of source nodes, a set T of sink nodes, a set A of at most six nodes Output: a pseudoflow f obeying conservation everywhere but S, T, A and s.t.</p><formula xml:id="formula_4">S G f T , S G f A, A G f T .</formula><p>The algorithm finds a simple cycle separator C <ref type="bibr" target="#b27">[28]</ref> and contracts all edges of C except one. This, essentially, merges all the nodes of C into a single supernode v, and turns C into a self loop. For simplicity of presentation we assume that no sources or sinks lie on C. <ref type="bibr" target="#b3">4</ref> The algorithm then recursively solves the problem on the subgraphs enclosed and not enclosed by that self loop (the self loop itself need not be included in any of the subgraphs), adding the supernode v that represents C to the set A. In order to keep the cardinality of A at most six, the algorithm alternately applies the cycle separator theorem with weights uniformly distributed on all nodes and uniformly distributed on only the nodes of A. This technique is similar to that used in <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b7">8]</ref>.</p><p>After the recursive calls, the algorithm uncontracts the edges of C. At this stage there are no residual paths between sources and sinks in the entire graph, but there might be excess inflow (positive or negative) at the nodes of C. The algorithm then calls the procedure FixConservationOnPath that pushes flow between the nodes of C so that there are no residual paths between nodes of C with positive inflow and nodes of C with negative inflow (the path in the name of the procedure is the cycle C without one edge). This procedure is discussed in Section 3; the interface is:</p><p>FixConservationOnPath(G, P, c, f 0 ) Input: a directed planar graph G, simple path P , capacity function c, and a pseudoflow f 0 Output: a pseudoflow f s.t. (i) f − f 0 satisfies conservation everywhere but P , and</p><formula xml:id="formula_5">(ii) {v ∈ P : inflow(v) &gt; 0} G f {v ∈ P : inflow(v) &lt; 0}.</formula><p>Running Time: O(n log 2 n/ log log n + |P | 2 log 2 n) Next, the algorithm iterates over the nodes a i of A. The algorithm calls the procedure CycleToSingleSinkLimitedMaxFlow that, roughly speaking, pushes as much excess flow as possible from C to a i . If C + i is the set of nodes of C that are reachable via residual paths from some node of C with positive inflow at the beginning of iteration i, CycleToSingleSinkLimitedMaxFlow pushes flow among the nodes of C + i and from the nodes of C + i to a i . The result is that remaining inflow at nodes of C + i is non-negative and there are no residual paths from nodes of C with positive inflow to a i . See Section 4; the interface is:</p><formula xml:id="formula_6">CycleToSingleSinkLimitedMaxFlow(G, c, f 0 , C, a i ) Input: a directed planar graph G with capacities c, a pseudoflow f 0 , a simple cycle C, a sink a i . Assumes: ∀v ∈ C + , inflow f0 (v) ≥ 0, where C + = {v ∈ C : {x ∈ C : inflow f0 (x) &gt; 0} G f 0 → v}. Output: a pseudoflow f s.t. (i) f − f 0 obeys conservation everywhere but C + ∪ {t}, (ii) ∀v ∈ C + , inflow f (v) ≥ 0, (iii) {v ∈ C : inflow f (v) &gt; 0} G f a i .</formula><p>Running Time: O(n log 2 n/ log log n + |C| 2 log 2 n).</p><p>A similar procedure SingleSourceToCycleLimitedMaxFlow is called to push flow from a i to C to eliminate as much negative inflow as possible (using a similarly defined set C − i ). Finally, the algorithm pushes back flow from any nodes of C with positive inflow to S and pushes flow back from T into any nodes of C with negative inflow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 MultipleSourceMultipleSinkMaxFlow(G, c,S,T ,A)</head><p>Input: a directed planar graph G with non-negative capacities c, a set S of source nodes, a set T of sink nodes, a set A consisting of a constant number of nodes A = {a i } k i=1 . Output: a pseudoflow f obeying conservation everywhere except S, T, A and s.t.</p><formula xml:id="formula_7">S G f T , S G f A, A G f T .</formula><p>1: add zero capacity arcs to triangulate and 2-connect G (required for simple cycle separators) 2: find a balanced (w.r.t. |G| and |A|, alternately) cycle separator C in G disjoint from S and T 3: let P be a path comprising of all of C's edges except one edge e 4: contract all the edges of P , turning e into a self loop incident to the only remaining node v of C 5: let G 1 and G 2 be the subgraph of G enclosed and not enclosed by e,</p><formula xml:id="formula_8">respectively 6: f := MultipleSourceMultipleSinkMaxFlow(G 1 , c |G1 , S ∩ G 1 , T ∩ G 1 , (A ∩ G 1 ) ∪ {v}) 7: f := f + MultipleSourceMultipleSinkMaxFlow(G 2 , c |G2 , S ∩ G 2 , T ∩ G 2 , (A ∩ G 2 ) ∪ {v}) 8:</formula><p>uncontract the edges of P 9: f := FixConservationOnPath(G, P, c, f ) 10: for i = 1, 2, . . . , k 11:</p><formula xml:id="formula_9">f := CycleToSingleSinkLimitedMaxFlow(G, c, f , C, a i ) 12:</formula><p>f := SingleSourceToCycleLimitedMaxFlow(G, c, f , a i , C) 13: push positive excess from C to S and negative excess to C from T 14: return f Correctness of Algorithm 1 The correctness of Algorithm 1 is proved in detail in Appendix A. The proof consists of a sequence of lemmas that prove that each step of the algorithm eliminates some undesired residual paths without reintroducing undesired residual paths. The arguments used are elementary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Running Time Analysis</head><p>The number of nodes of the separator cycle C used to partition G into G 1 and G 2 is O( |G|). Therefore, each invocation of FixConservationOnPath, CycleToSingleSinkLimitedMaxFlow and SingleSourceToCycleLimitedMaxFlow in G takes O(|G| log 2 |G|/ log log |G| + |C| 2 log 2 |C|) = O(|G| log 2 |G|) time.</p><p>The way we recursively partition into subgraphs is very similar to that of Fakcharoenphol and Rao <ref type="bibr" target="#b7">[8]</ref>. In their algorithm, they spend O(|G | log 2 |G |) time on each subgraph G in the recursive decomposition and prove a total time bound of O(n log 3 n). By the same arguments, our algorithm runs in O(n log 3 n) time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Eliminating Residual Paths Between Nodes with Positive Inflow and Nodes with Negative Inflow on a Path</head><p>In this section we present an efficient implementation of the fixing procedure which, roughly speaking, given a path with nodes having positive, negative, or zero inflow, pushes flow between the nodes of the path so that eventually there are no residual paths from nodes with positive inflow to nodes with negative inflow. We begin by describing an abstract algorithm for the fixing procedure. The abstract algorithm is given as Algorithm 2. It is similar to a technique used by Venkatesan and Johnson <ref type="bibr" target="#b18">[19]</ref>. Let M be the sum of capacities of all of the darts of G. The algorithm first increases the capacities of darts of the path P and their reverses by M . Let p 1 , p 2 , . . . , p k+1 be the nodes of P . The algorithm processes the nodes of P one after the other. Processing p i consists of decreasing the capacities of d i = p i p i+1 and rev(d i ) by M (i.e., back to their original capacities), and trying to eliminate positive inflow x at p i by pushing at most x units of flow from p i to p i+1 . The intuition for doing so is that the flow after the push either obeys conservation at p i or there are no residual paths from p i to any of the other nodes of P (this is where we use the large capacities on the darts between unprocessed nodes). See appendix B for a formal proof of correctness. Negative inflow at p i is handled in a similar manner by pushing flow from p i+1 to p i .</p><p>Algorithm 2 AbstractFixConservationOnPath(G, P, c, f 0 ) Input: directed planar graph G, simple path P = d 1 d 2 . . . d k , capacity function c, and pseudoflow f 0 Output: a pseudoflow f s.t. (i) f − f 0 satisfies conservation at nodes not on P , and (ii) with respect to f , there are no residual paths from nodes of P with positive inflow to nodes of P with negative inflow.</p><formula xml:id="formula_10">1: f = f 0 2: c[d] = c[d] + M for all darts d of P ∪ rev(P ) 3: for i = 1, 2, . . . , k 4:</formula><p>let p i and p i+1 be the tail and head of d i , respectively </p><formula xml:id="formula_11">for d ∈ {d i , rev(d i )} 6: c[d] := c[d] − M 7: f [d] := min{f [d], c[d]} 8: f [rev(d)] := −f [d] 9:</formula><p>excess := inflow at p i 10:</p><formula xml:id="formula_12">if excess &gt; 0 then d := d i else d := rev(d i )</formula><p>find in which direction flow should be pushed</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>11:</head><p>add to f a maximum feasible flow from tail(d) to head(d) with limit excess 12: return f</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">An Inefficient Implementation</head><p>In this section, we give an inefficient implementation of line 11 of the abstract algorithm. This will facilitate the explanation of the efficient procedure in the next section. We first review the necessary ideas and tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Hassin's algorithm for maximum st-planar flow</head><p>An st-planar graph is a planar graph in which nodes s and t are incident to the same face. Hassin <ref type="bibr" target="#b12">[13]</ref> gave an algorithm for computing a maximum flow from s to t in an st-planar graph. We briefly describe this algorithm here since we use it in implementing line 11 of Algorithm 2.</p><p>Hassin's algorithm starts by adding to G an artificial infinite capacity arc a from t to s. Let d be the dart that corresponds to a and whose head is t. Let t * be the head in G * of the dual of d. Compute in the dual G * a shortest path tree rooted at t * , where the length of a dual dart is defined as the capacity of the primal dart. Let φ[·] denote the shortest path distances from t * in G * . Consider the flow</p><formula xml:id="formula_13">ρ[d ] = φ[head G * (d )] − φ[tail G * (d )]for all darts d<label>(1)</label></formula><p>After removing the artificial arc a from G, ρ is a maximum feasible flow from s to t in G. We say that φ is a face potential vector that induces ρ.</p><p>In our algorithm we are interested in a max flow with limit x from s to t rather than a maximum flow, i.e., a flow whose value is at most a given number x but is otherwise maximal. It is not difficult to see that setting the capacity of the artificial arc a to x instead of infinity results in the desired limited max flow <ref type="bibr" target="#b21">[22]</ref>.</p><p>In our implementation, instead of using an artificial arc from t to s, we use an existing arc whose endpoints are s and t as the arc a above. In order for this to work, the capacity of the dart d that corresponds to a and whose head is t must be zero (as is indeed the case if a is an artificial arc from t to s). This can always be achieved by first pushing flow on d to saturate it. Also note that in this case, we do not remove a from G. Hence, ρ is a feasible circulation, rather than a maximum flow, since flow is being pushed back from t to s along a. To convert it into a maximum flow one just has to undo the flow on a. If we define f by</p><formula xml:id="formula_14">f [d ] = −ρ[d ] if d corresponds to a 0 otherwise ,<label>(2)</label></formula><p>then ρ + f is a maximum feasible st-flow. We will use the fact that this flow can be represented implicitly by the face potential vector φ, and the flow values f [d ] for the two darts corresponding to a.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">The Inefficient Implementation</head><p>Recall that f 0 is the flow at the beginning of the procedure. Observe that the change to the flow in iteration i of the abstract algorithm (line 11) is a flow between the endpoints of the dart d i . As discussed in Section 3.1.1, this flow can be represented as the sum of (i) a circulation ρ i and (ii) a flow on d i and rev(d i ). Summing over the first i iterations, the flow f at that time can be represented as the sum</p><formula xml:id="formula_15">f = ρ + f<label>(3)</label></formula><p>where ρ = i j=1 ρ j is a circulation and f is a flow assignment that differs from f 0 only on the darts of {d j } i j=1 and their reverses. The inefficient implementation of line 11 of the abstract algorithm appears as Algorithm 3. We now describe it. The total flow f is maintained by representing f and the circulation ρ as in Eq. (3). f is represented explicitly, but, in preparation for the efficient implementation, the circulations ρ j are represented implicitly by the face-potentials φ j . By linearity of Eq. (1), the sum φ = i j=1 φ j is the face potential vector that induces the circulation ρ.</p><p>Recall that d is the dart of C such that flow needs to be sent from tail(d) to head(d) (line 10 of Algorithm 2). In lines 1 -3, the procedure pushes as much as possible on d itself. Consequently, either d is saturated or conservation at p i is achieved.</p><p>Next, an implementation of Hassin's algorithm pushes a maximum flow with limit |inflow(p i )| from tail(d) to head(d). The procedure first sets the length of darts to their residual capacities (line 4) and sets the length of rev(d) to be the flow limit |inflow(p i )| (line 5). Since the flow maintained is feasible, all residual capacities are non-negative. The procedure then computes all the head G * (d)-to-f distances φ i [f ] in G * using Dijkstra's algorithm (line 6). Let ρ i be the circulation corresponding to the face-potential vector φ i . The procedure sets val equal to ρ <ref type="bibr">[d]</ref> in line 7, then subtracts val from f <ref type="bibr">[d]</ref> and adds it to f [rev(d)]. Finally, in the last line, the current circulation is added to the accumulated circulation by adding the potential φ i to φ.</p><p>Algorithm 3 Inefficient Implementation of line 11 of AbstractFixConservationOnPath (Algorithm 2)</p><formula xml:id="formula_16">1: residual capacity := c[d] − f [d] − φ[head G * (d)] + φ[tail G * (d)]</formula><p>% push flow on d to make its residual capacity zero as required for Hassin's algorithm 2: val := min{residual capacity, |inflow(p i )|} amount of flow to push on d</p><formula xml:id="formula_17">3: f [d] := f [d] + val ; f [rev(d)] := −f [d]</formula><p>% push excess inflow from tail(d) to head(d) using Hassin's algorithm  </p><formula xml:id="formula_18">4: let [d ] := c[d ] − f [d ] − φ[head G * (d )] + φ[tail G * (d )] for all darts d ∈ G</formula><formula xml:id="formula_19">6: φ i (·) := Dijkstra(G * , , head G * (d)) face potential are distances in G * from head G * (d) w.r.t. residual capacities 7: val := φ i [head G * (d)] − φ i [tail G * (d)]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">An Efficient Implementation</head><p>In this section we give an efficient implementation of Algorithm 2. We first review the necessary tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Fakcharoenphol and Rao's Efficient Dijkstra Implementation</head><p>Let X be a set of nodes. Let H be a planar graph in which the nodes of X lie a single face. Let x 1 , x 2 , · · · be the clockwise order of the nodes of X on that face. Let P be a set of darts not necessarily in the graph H whose endpoints are nodes in X. Fakcharoenphol and Rao <ref type="bibr" target="#b7">[8]</ref> described a data structure that can be used in a procedure that efficiently implements Dijkstra's algorithm in H ∪ P . The procedure takes as input a table D such that D <ref type="bibr">[i, j]</ref> stores the distance between x i and x j in H, an array that stores the lengths of the darts in P , and a node v ∈ X. It is assumed that the lengths in D and in are non-negative. The procedure outputs the distances of the nodes of X from v in H ∪ P in O(|X| log 2 |X| + |P | log |X|)-time.</p><p>We mention a technical issue whose importance will become apparent in the sequel. The procedure partitions the table D into several subtables {D α } α that correspond to distances between pairs of disjoint sets of nodes of X, where each set consists of nodes that are consecutive in X. It is assumed in [8, footnote on p. 884] that for each such subtable D α , a data structure that supports range minimum queries of the form min j1≤j≤j2 {D α [i, j]} for every i, j 1 , j 2 is given. Fakcharoenphol and Rao note that such a data structure can be easily implemented by using a range-search tree <ref type="bibr" target="#b5">[6]</ref> for every row i of D α . The time required to construct all of the range-search trees for D α is proportional to the size of D α .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Price Functions, Reduced Lengths and FR-Dijkstra</head><p>For a directed graph G with dart-lengths (·), a price function is a function φ from the nodes of G to the reals. For a dart d, the reduced length with respect to φ is φ (d) = (d) + φ(tail(d)) − φ(head(d)). A feasible price function is a price function that induces nonnegative reduced lengths on all darts of G (see <ref type="bibr" target="#b17">[18]</ref>).</p><p>Single-source distances form a feasible price function. Suppose that, for some node r of G, for every node v of G, φ(v) is the r-to-v distance in G with respect to (·). Then for every arc uv, φ(v) ≤ φ(u) + (uv), so φ (uv) ≥ 0. Here we assume, without loss of generality, that all distances are finite (i.e., that all nodes are reachable from r) since we can always add arcs with sufficiently large lengths to make all nodes reachable without affecting the shortest paths in the graph.</p><p>We will use the following variant of Fakcharoenphol and Rao's efficient Dijkstra implementation. The procedure FR(D, , φ X , v) takes as input the table D and the array as described above, as well as a feasible price function φ X on the nodes of X and a node v ∈ X. It outputs the distances of the nodes of X from v in H ∪ P w.r.t. the reduced lengths w.r.t. φ X . We stress that lengths in D and in may be negative, but the reduced lengths are all non-negative. The computation takes O(|X| log 2 |X| + |P | log |X|) time.</p><p>This differs from the procedure described in Section 3.2.1 only in the existence of the price function φ X . We cannot afford to compute the entire table of reduced lengths since that would dominate the running time of the algorithm in <ref type="bibr" target="#b7">[8]</ref>. Instead, whenever their algorithm requires some specific reduced length, we can compute it in constant time from D. This, however, does not suffice. Recall that the algorithm in <ref type="bibr" target="#b7">[8]</ref> requires that, for each of the subtables D α , range-search trees that support range minimum queries of the form min j1≤j≤j2</p><formula xml:id="formula_20">{D α [i, j] + φ X [x i ] − φ X [x j ]</formula><p>} for every i, j 1 , j 2 are given. Note that the results of such queries may be different for different price functions. Computing the range-search trees would take O(|X| 2 ) which will dominate the running time of the entire procedure. To overcome this difficulty we use Monge range-query data structures, due to Kaplan and Sharir <ref type="bibr" target="#b20">[21]</ref>, which can be constructed from the table D in O(|X| log |X|) time, and answer queries of the desired form in O(log |X|) time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3">The Procedure</head><p>Finally, we describe the efficient implementation. The procedure keeps track of the inflow at each node of P in an array v <ref type="bibr">[·]</ref>. As in the inefficient implementation, the procedure will maintain the total flow as the sum of a circulation ρ and a flow assignment f that differs from f 0 only on the darts of P ∪ rev(P ). Initially f is set equal to f 0 . The circulation ρ will be represented by a face-potential vector φ. However, we will show that it suffices to maintain just those entries of φ that correspond to faces incident to P .</p><p>Define each dart d's length by</p><formula xml:id="formula_21">(d) = c[d] − f [d]</formula><p>. Let X * be the set of endpoints in the planar dual G * of the darts of P (i.e. the primal faces incident to P ). Let H * be the graph obtained from G * by removing the darts of P . Note that in H * , all the nodes of X * that did not disappear (i.e., that have degree greater than zero) are on the boundary of a single face, see <ref type="figure" target="#fig_3">Figure 1</ref>.</p><p>The procedure uses a multiple-source shortest paths (MSSP) algorithm <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b4">5]</ref> to compute a table D * [·, ·] of X * -to-X * distances in H * with respect to the lengths (·).</p><p>The implementation of lines 1-10 of the abstract algorithm using the chosen representation of f is straightforward. We therefore focus on the implementation of line 11 of Algorithm 2, given as Algorithm 4.</p><p>Consider iteration i of the algorithm. The main difference between the inefficient implementation and the efficient one is in implementing the Dijkstra step for computing shortest paths in the dual. Instead of computing the entire shortest-path tree, the procedure computes just the distance labels of nodes in X * . This is done using the FR data structure, whose initialization requires the X * -to-X * distances in H * with respect to the residual capacities. We now explain how these distances can be obtained.</p><p>The flow on a dart d in the primal is</p><formula xml:id="formula_22">f [d] + φ[head G * (d)] − φ[tail G * (d)].<label>(4)</label></formula><p>Therefore the residual capacity of d is</p><formula xml:id="formula_23">(c[d] − f [d]) − φ[head G * (d)] + φ[tail G * (d)]<label>(5)</label></formula><p>which is its reduced length φ <ref type="bibr">[d]</ref> with respect to the length (·) and price function φ. Suppose that d belongs to H * , i.e. d is not one of the darts of P ∪ rev(P ). The procedure never changes</p><formula xml:id="formula_24">f [d], so f [d] = f 0 [d]. Therefore (d) = c[d] − f 0 [d]</formula><p>. These lengths are known at the beginning of the procedure's execution. The reduced length of an X * -to-X * path</p><formula xml:id="formula_25">Q = d 1 , d 2 , · · · , d j in H * is j i=1 ((d i ) − φ[head G * (d i )] + φ[tail G * (d i )]) = j i=1 (d i ) − φ[end(Q)] + φ[start(Q)].<label>(6)</label></formula><p>Therefore, for any nodes x, y ∈ X * , the x-to-y distance in H * w.r.t. the residual capacity is given by</p><formula xml:id="formula_26">D * [x, y] − φ[y] + φ[x]</formula><p>. Since the procedure maintains the restriction of φ to faces of X * , this distance can be obtained in constant time. Adapting FR's data structure to handle reduced distances w.r.t. a price function φ was discussed in Section 3.2.1.</p><p>Algorithm 4 Efficient Implementation of line 11 of AbstractFixConservationOnPath (Algorithm 2)</p><formula xml:id="formula_27">1: residual capacity := c[d] − f [d] − φ X [head G * (d)] + φ X [tail G * (d)]</formula><p>% push flow on d to make its residual capacity zero as required for Hassin's algorithm</p><formula xml:id="formula_28">2: val := min{residual capacity, |v[p i ]|} amount of flow pushed on d 3: f [d] = f [d] + val ; f [rev(d)] := −f [d] 4: v[tail(d)] = v[tail(d)] − val ; v[head(d)] = v[head(d)] + val</formula><p>update the inflow at pi and pi+1</p><p>% push excess inflow from tail(d) to head(d) using Hassin's algorithm</p><formula xml:id="formula_29">5: let [d ] := c[d ] − f [d ] for all darts d ∈ P ∪ rev(P )</formula><p>lengths of explicit darts are residual capacities (not including circulation component)</p><formula xml:id="formula_30">6: [rev(d)] := |v[p i ]| − φ X [tail G * (rev(d))] + φ X [head G * (rev(d))]</formula><p>set the limit on the residual capacity of rev(d) (adjusted by circulation component)</p><formula xml:id="formula_31">7: φ X i (·) := F R(D * , , φ X , head G * (d)) face potential are distances in G * from head G * (d) w.r.t. the reduced lengths induced by φ X 8: val := φ X i [head(d)] − φ X i [tail(d)]</formula><p>the amount of flow assigned to d by the circulation corresponding to φ X</p><formula xml:id="formula_32">i 9: f [d] := f [d] − val ; f [rev(d)] := −f [(d)]</formula><p>do not push the circulation on d and rev <ref type="bibr">(d)</ref> 10:</p><formula xml:id="formula_33">φ X = φ X + φ X i accumulate the current circulation 11: v[tail(d)] = v[tail(d)] − val ; v[head(d)] = v[head(d)] + val</formula><p>update the inflow at pi and pi+1</p><p>It follows from the above discussion that, after executing line 11 of Algorithm 2 using the efficient implementation (Algorithm 4) for the last time, the flow assignment f maintained by the efficient implementation is the same as the one that would have been computed if the inefficient implementation (Algorithm 3) were used. Moreover, the potential function φ X computed by the efficient implementation is the restriction to X * of the potential function φ that would have been computed by the inefficient implementation.</p><p>In order to output the flow f in the entire graph G, we need to know the potential function φ rather than just its restriction φ X . Observe, however, that any pseudoflow that differs from f by a circulation is a valid output of FixConservationOnPath since a circulation does not change the inflow at any node, nor does it introduce residual paths between nodes that are not connected by a residual path in G f . It therefore suffices to find any feasible circulation χ in G f . This can be done by computing shortest paths in G * w.r.t. the lengths := c − f from an arbitrary node x ∈ G * . Note, however, that for darts of P ∪ rev(P ) these lengths might be negative. We therefore use the O(n log 2 n/ log log n)-time algorithm for shortest paths with negative lengths in planar graphs <ref type="bibr" target="#b29">[30]</ref> to compute a feasible circulation χ. <ref type="bibr" target="#b4">5</ref> The pseudocode for the efficient implementation of FixConservationOnPath is given in appendix D.</p><p>Running Time Analysis Let n and k be the number of nodes in G and in P , respectively. The initialization time is dominated by the O(n log n + k 2 log n) time for MSSP. The execution of each iteration of the main loop is dominated by the call to FR, which takes O(k log 2 k) time. The number of iterations is k − 1, leading to a total of O(k 2 log 2 k) time for execution of the main loop. Computing the circulation χ requires one shortest path computation, which takes O(n log 2 n/ log log n) time. Thus total running time of the efficient implementation of FixConservationOnPath is O(n log 2 n/ log log n + k 2 log 2 k).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Pushing Excess Inflow from a Cycle</head><p>In this section we describe the procedure CycleToSingleSinkLimitedMaxFlow that pushes excess inflow from a cycle to a node not on the cycle. The procedure is given as Algorithm 5. The procedure SingleSourceToCycleLimitedMaxFlow is very similar. We omit its description.</p><p>Algorithm 5 CycleToSingleSinkLimitedMaxFlow(G, c, f 0 , C, t) Input: a directed planar graph G with capacities c, a pseudoflow f 0 , a simple cycle C, a sink a i .</p><p>Assumes: ∀v ∈ C + , inflow f0 (v) ≥ 0, where</p><formula xml:id="formula_34">C + = {v ∈ C : {x ∈ C : inflow f0 (x) &gt; 0} G f 0 → v}. Output: a pseudoflow f s.t. (i) f − f 0 obeys conservation everywhere but C + ∪ {t}, (ii) ∀v ∈ C + , inflow f (v) ≥ 0, (iii) {v ∈ C : inflow f (v) &gt; 0} G f a i .</formula><p>1: let C + := {v ∈ C : there exists a residual path to v from a node x ∈ C with inflow f0 (x) &gt; 0} 2: delete the nodes of C − C + 3: let v 1 , v 2 , . . . , v be the nodes of C + , labeled according to their cyclic order on C 4: add artificial arcs v i v i+1 for 1 ≤ i &lt; 5: let P be the v 1 -to-v path of artificial arcs 6: contract all the edges of P , collapsing C + into the single node v 1 7: f := SingleSourceSingleSinkMaxFlow(G, c − f 0 , c 1 , t) 8: undo the contraction of the edges of P 9: f := FixConservationOnPath(G, P, c, f 0 + f ) −f 0 10: modify f to push back flow to nodes of C + whose inflow w.r.t f 0 + f is negative 11: f := f 0 + f 12: return f To compute C + in Line 1, consider the residual graph of G w.r.t. f 0 . Add a node v and non-zero capacity arcs vw for every node w whose inflow w.r.t. f 0 is positive (these arcs may not preserve planarity). In O(|G|) time, find the set X of nodes that are reachable from v via darts with non-zero capacity. Then C + = C ∩ X.</p><p>Since C + consists of all nodes of C reachable via residual paths from the nodes of C with positive inflow, the flow computed by the procedure involves no darts incident to nodes in C − C + . Thus, restricting the computation to the graph obtained from G by deleting the nodes in C − C + (line 2) does not restrict the computed flow. After deletion, adding artificial arcs between consecutive nodes of C + (line 4) will not violate planarity. Contracting the artificial arcs effectively turns C + into a single node v 1 . Next, the procedure computes a maximum flow f from C + to t w.r.t. residual capacities c − f 0 . This is done by invoking a singlesource single-sink maximum flow algorithm <ref type="bibr" target="#b1">[2]</ref> with source v 1 and sink t (line 7). Uncontracting the artificial arcs turns f into a maximum C + -to-t flow in G w.r.t. the residual capacities c − f 0 . However, some of the nodes of C + may have negative inflow w.r.t. f 0 +f . In line 9, the procedure calls FixConservationOnPath to reroute the flow f among the nodes of C + so that, w.r.t. f 0 + f , there are no residual paths from nodes of C + with positive inflow to nodes of C + with negative inflow. This implies that any node of C + that still has negative inflow has pushed too much flow. Line 10 modifies f to push back such excess flow so that no node of C + has negative inflow w.r.t. f 0 + f . This is done using the procedure of Section 1.1 described in the appendix. Finally, the procedure returns f 0 + f . See Appendix F for a formal proof of correctness.</p><p>We next analyze the running time of this procedure on an n-node graph G and a k-node cycle C. The st-maximum flow computation in line 7 takes O(n log n) time using the algorithm of Borradaile and Klein <ref type="bibr" target="#b1">[2]</ref>. The running time of the procedure is therefore dominated by the call to FixConservationOnPath in line 9 which takes O(n log 2 n/ log log n + k 2 log 2 k) time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Correctness of Algorithm 1</head><p>Proof. The fact that the properties hold just after line 7 follows from the properties of the recursive calls and from the fact that any residual path from a node in one piece to a node in the other consists of a residual path to C and a residual path from C. Note that, because of the contractions in line 4, at this time the cycle C consists of just the node v. The the nonexistence of residual paths with respect to v in the recursive calls implies the nonexistence of residual paths w.r.t. any node of C after the contractions are undone in line 8. Now, let us prove that the properties are maintained until just before the execution of line 13. By the above argument, there is a cut separating S from T ∪A∪C which is saturated just after line 8. The procedure in line 9 only pushes flow between vertices of C, and in lines 10-12, flow is only pushed between the nodes of A and C. These sets are all on the same side of the cut which therefore stays saturated. It follows that S T , S A, and S C at any point after line 7 and before line 13. A similar argument applied to a saturated cut separating A ∪ C from T shows A T and C T .</p><p>Recall that C + i is the set of nodes of C that are reachable via residual paths from some node of C with positive excess at the beginning of iteration i, and that C − i is the set of nodes of C that have residual paths to some node of C with negative excess at the beginning of iteration i.</p><p>Lemma A.5. Just after line 9 of Algorithm 1 is executed, C + 1 C − 1 .</p><p>Proof. Follows from the definition of FixConservationOnPath.</p><formula xml:id="formula_35">Lemma A.6. For all i &lt; j, C + j ⊆ C + i and C − j ⊆ C − i</formula><p>Proof. It suffices to show that, for all i, C + i+1 ⊆ C + i and C − i+1 ⊆ C − i . The flow pushed in iteration i of line 11 can be decomposed into a flow whose sources and sinks are all in C + i and a flow whose sources are in C + i and whose sink is a i . Therefore, the set X of nodes of C with positive inflow immediately after iteration i of line 11 is a subset of C + i . By definition of SingleSourceToCycleLimitedMaxFlow, the set of nodes of C with positive inflow does not change after line 12 is executed. Therefore, C + i+1 is the set of nodes reachable from X by a residual path after iteration i of line 12. By definition of C + i , immediately before iteration i of line 11 there are no C + i -to-{C − C + i } residual paths. By sources lemma(C + i , C − C + i , C + i ), there are no C + i -to-{C − C + i } residual paths immediately after iteration i of line 11 as well. This shows that there are no X-to-{C − C + i } residual paths at that time. The flow pushed in line 12 can be decomposed into a flow whose sources and sinks are all in C − i and a flow whose source is a i and whose sinks are all in C − i . By sinks lemma(C + i , C − C + i , C − i ), there are no C + i -to-{C − C + i } residual paths immediately after iteration i of line 12. This shows that there are no X-to-{C − C + i } residual paths at that time. Hence C + i+1 ⊆ C + i , as desired. The proof of the analogous claim for C − i+1 is similar.</p><p>Lemma A.7. Just after line 11 of Algorithm 1 is executed in iteration i,</p><formula xml:id="formula_36">C + i C − i , C + i+1 {a j } j≤i , {a j } j&lt;i C − i .</formula><p>Proof. The flow pushed in line 11 can be decomposed into a flow whose sources and sinks are all in C + i and a flow whose sources are in C + i and whose sink is a i .</p><formula xml:id="formula_37">• C + i C − i by sources lemma(C + i , C − i , C + i ) • C + i+1 {a j } j&lt;i by sources lemma(C + i+1 , a j , C + i ) • C + i+1 {a i } by definition of CycleToSingleSinkLimitedMaxFlow • {a j } j&lt;i C − i by sources lemma(a j , C − i , C + i )</formula><p>Lemma A.8. Just after line 12 of Algorithm 1 is executed in iteration i,</p><formula xml:id="formula_38">C + i C − i , C + i+1 {a j } j≤i , {a j } j≤i C − i+1 .</formula><p>Proof. The flow pushed in line 12 can be decomposed into a flow whose sources and sinks are all in C − i and a flow whose source is a i and whose sinks are all in C − i .</p><formula xml:id="formula_39">• C + i C − i by sinks lemma(C + i , C − i , C − i ) • C + i+1 {a j } j≤i by sinks lemma(C + i+1 , a j , C − i ) • {a j } j&lt;i C − i+1 by sinks lemma(a j , C − i+1 , C − i )</formula><p>• a i C − i+1 by definition of SingleSourceToCycleLimitedMaxFlow Let C + (C − ) denote the set of nodes in C with positive (negative) inflow just before line 13 is executed.</p><p>Corollary A.9. Just before line 13 of Algorithm 1 is executed,</p><formula xml:id="formula_40">C + C − , C + A, A C − .</formula><p>Lemma A.10. The following are true upon termination:</p><p>1. f is a pseudoflow 2. f obeys conservation everywhere except at S, T, A</p><formula xml:id="formula_41">3. S G f T, S G f A, A G f T .</formula><p>Proof. Since every addition to f along the algorithm respects capacities of all darts, f is a pseudoflow at all times. By induction, the only nodes that do not obey conservations after the recursive calls are those of S, T and A. Subsequent changes to f only violate conservation on the nodes of C, but any such violation is eliminated in line 13. Therefore upon termination f obeys conservation everywhere except S, T and A. Since, by Lemma A.4 and Corollary A.9 before line 13 C + A and C T , the flow pushed back from C + in line 13 must be pushed back to S. Similarly, the flow pushed back to C − must be pushed back from T .</p><p>Let f + (f − ) be the flow pushed back from C + to S (from T to C − ) in line 13. Consider first pushing back f + .</p><p>• S T by sources lemma(S, T, C + )</p><p>• S A by sources lemma(S, A, C + )</p><p>• A T by sources lemma(A, T, C + )</p><p>• S C − by sources lemma(S, C − , C + )</p><formula xml:id="formula_42">• A C − by sources lemma(A, C − , C + )</formula><p>Next consider pushing f − • S T by sinks lemma(S, T, C − )</p><p>• S A by sinks lemma(S, A, C − )</p><p>• A T by sinks lemma(A, T, C − )</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Correctness of Algorithm 2</head><p>Lemma B.1. The following holds immediately after iteration i of the main loop (line 3).</p><p>1. For j ≤ i, j &gt; j, if p j has positive inflow, there is no residual path from p j to p j . If p j has negative inflow, there is no residual path from p j to p j .</p><p>2. For j, j ≤ i, if p j has positive inflow and p j has negative inflow then there is no p j -to-p j residual path.</p><p>Proof. By induction on the number of iterations i of the loop. For i = 0 the invariants are trivially satisfied. First note that the adjustments to capacities and flow in lines 6-8 do not create any new residual paths since capacities are only reduced, and no residual capacity increases. Therefore, it suffices to argue just about the flow pushed in line 11.</p><p>Assume the invariants hold up until the beginning of the i th iteration. We show that the invariants hold at the end of the iteration. Suppose that p i has positive inflow at the end of the i th iteration (the case of negative inflow is similar).</p><p>1. Since the flow pushed in line 11 is limited by |inflow(p i )|, the fact that p i has positive inflow at the end implies that the flow pushed was a maximum flow from p i to p i+1 . Since the capacities of darts between p k+1 and p k for k &gt; i are sufficiently large, the maximality of the flow implies that there are no p i -to-p k residual paths for any k &gt; i.</p><p>The invariant holds for nodes p j with positive inflow and j &lt; i by sinks lemma({p j }, {p j : j &gt; j}, {p i+1 }).</p><p>2. Invariant 2 holds for j, j &lt; i by sinks lemma( {p j : j &lt; i, inflow(p j ) &gt; 0}, {p j : j &lt; i, inflow(p j ) &lt; 0}, {p i+1 }).</p><p>The invariant holds for p i by invoking the sources lemma({p i }, {p j : j &lt; i, inflow(p j ) &lt; 0}, {p i }).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary B.2. Algorithm 2 is correct</head><p>Proof. The flow f − f 0 satisfies conservation everywhere except at nodes of P since the algorithm only pushes flow between nodes of P . By Lemma B.1, with respect to f , there are no residual paths from nodes of P with positive inflow to nodes of P with negative inflow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C Converting a Pseudoflow into a Maximum Feasible Flow</head><p>Let f be a pseudoflow in a planar graph G with node set V , sources S and sinks T . Let V + denote the set of nodes {v ∈ V − (S ∪ T ) : inflow f (v) &gt; 0}. Similarly, let V − denote the set of nodes {v ∈ V − (S ∪ T ) :</p><formula xml:id="formula_43">inflow f (v) &lt; 0}. Suppose S ∪ V + G f T ∪ V − .</formula><p>In this appendix we show how to convert f into a maximum feasible flow f . This procedure was first described for planar graphs by Johnson and Venkatesan <ref type="bibr" target="#b18">[19]</ref>. The original description of the procedure took O(n log n) time, but using the flow cycles canceling technique of Kaplan and Nussbaum <ref type="bibr" target="#b19">[20]</ref> the running time is O(n).</p><p>We begin by converting f to an acycic pseudoflow in linear time <ref type="bibr" target="#b19">[20]</ref>. That is, after the conversion there is no cycle C such that f The total running time is O(n), and since V + , V − are both empty, we get from the invariant S ∪ V + G f T ∪ V − that the resulting pseudoflow is a feasible flow. This is the required flow f .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E Alternative to Line 32 of Algorithm 6</head><p>In this section we show that it is not necessary to use a generic shortest path algorithm that works with negative lengths to compute a feasible circulation χ in line 32 of Algorithm 6. Instead of choosing x to be an arbitrary node in G * , let x be an arbitrary node of X * . Let χ(y) denote the x-to-y distance in G * w.r.t. the lengths . Instead of computing χ using a shortest path algorithm that accepts negative lengths, we will compute it more efficiently in two steps. Pseudocode is given below as Algorithm 7. In the first step we use FR to compute the distances to just the nodes of X * . In the second step we extend these distances to all other nodes using Dijkstra's algorithm.</p><p>In the first step the algorithm computes distances in G * from x to all nodes of X * w.r.t. φ X , the reduced lengths of induced by the feasible price function φ X . This is done by an additional invocation of FR (line 2). Let ψ X denote these distance labels. By definition of reduced lengths and a telescoping sum similar to the one in the derivation of Eq. (6),</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>%</head><label></label><figDesc>reduce the capacities of d and rev(d) by M and adjust the flow appropriately 5:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>lengths are residual capacities 5: [rev(d)] := |inflow(p i )| set the limit on the residual capacity of rev(d)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>the amount of flow assigned to d by the circulation corresponding to φ i 8: f [d] := f [d] − val ; f [rev(d)] := −f [(d)] do not push the circulation on d and rev(d) 9: φ = φ + φ i accumulate the current circulation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: An example illustrating that the nodes of X * are on the boundary of a single face of H * . The diagram shows part of the graph G and some edges of its dual G * . Edges of G are solid blue. Edges of P are bold. Dual edges are double lined red. The dual edges of P are in double lined dashed red.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>[d] &gt; 0 for every dart d of C. Since f is acyclic, the darts with a positive flow induce a topological ordering on the nodes of the graph G. Let v be the last member of V + in the topological ordering, and let d be an arbitrary dart that carries flow into v. We set f [d] = max{f [d] − inflow f (v), 0}, and set f [rev(d)] accordingly. The flow assignment f maintains the invariant S ∪ V + G f T ∪ V − by sinks lemma(S ∪ V + ,T ∪ V − ,{v}). As long as v is in V + , there must be a dart d which carries flow to v. By changing the flow on d we cannot add to V + a new node that appears later than v in the topological ordering. We repeat this process until V + is empty. Since we reduce the flow on each dart at most once, this takes linear time. Next we handle V − while keeping the invariant S ∪ V + G f T ∪ V − in a symmetric way, by repeatedly fixing the first vertex if V − in the topological ordering.</figDesc></figure>

			<note place="foot" n="1"> The time bound of the first algorithm can be improved to O(n log n) using the linear-time shortest-path algorithm of Henzinger et al. [14], and the time bound of the second algorithm can be improved to O(k 2 n log 2 n) using the O(n log n)-time single-source single-sink maximum flow algorithm of Borradaile and Klein [2].</note>

			<note place="foot" n="2"> Note that the single-source, single-sink max-flow algorithm of [2] was implemented by computer-vision researchers [31] and found to be useful in computer vision and to be faster than the competitors. 3 An equivalent definition, in terms of arcs, is inflow f (v) = a∈E:head(a)=v f (a) − a∈E:tail(a)=v f (a).</note>

			<note place="foot" n="4"> This does not lose generality since if a node u ∈ C is a source, one can introduce a new node u and an arc u u whose capacity equals the sum of capacities of arcs outgoing from u. Now consider u as a source instead of u. Since the separator has just O( √ n) nodes, this will not affect the running time. Sinks can be handled in a similar fashion.</note>

			<note place="foot" n="5"> In appendix E, we show how to use one more call to FR followed by a call to Dijkstra&apos;s algorithm to compute these distances. While we think doing so is more elegant and simpler to implement, it does not change the asymptotic running time of the algorithm.</note>

			<note place="foot" n="34">: return f</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank Haim Kaplan and Micha Sharir for discussions of their unpublished data structure <ref type="bibr" target="#b20">[21]</ref>. PNK and SM thank Robert Tarjan for encouraging us to work on this problem.</p></div>
			</div>

			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A survey of very large scale neighborhood search techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ahuja</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">¨</forename><forename type="middle">O</forename><surname>Ergun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Orlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Punnen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="75" to="102" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">An O(n log n) algorithm for maximum st-flow in a directed planar graph</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Borradaile</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">N</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An experimental comparison of min-cut/max-flow algorithms for energy minimization in vision</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Boykov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kolmogorov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1124" to="1137" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Efficient approximate energy minimization via graph cuts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Boykov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Veksler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Zabih</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1222" to="1239" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Multiple source shortest paths in a genus g graph</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Cabello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">W</forename><surname>Chambers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th Annual ACM-SIAM Symposium on Discrete Algorithms</title>
		<meeting>the 18th Annual ACM-SIAM Symposium on Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="89" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Van Kreveld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Overmars</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Schwarzkopf</surname></persName>
		</author>
		<title level="m">Computational Geometry: Algorithms and Applications</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="96" to="99" />
		</imprint>
	</monogr>
	<note>2nd edition edition</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Maximum flows and parametric shortest paths in planar graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Erickson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st Annual ACM-SIAM Symposium on Discrete Algorithms</title>
		<meeting>the 21st Annual ACM-SIAM Symposium on Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="794" to="804" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Planar graphs, negative weight edges, shortest paths, and near linear time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Fakcharoenphol</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">72</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="868" to="889" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Stochastic relaxation, Gibbs distributions, and the Bayesian relation of images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Geman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Geman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="721" to="742" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Beyond the flow decomposition barrier</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="783" to="797" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Solving minimum-cost flow problems by successive approximation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">V</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th Annual ACM Symposium on Theory of Computing</title>
		<meeting>the 19th Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="page" from="7" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Exact maximum a posteriori estimation for binary images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Greig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Porteous</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Seheult</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Royal Statistical Society, Series B</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="271" to="279" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Maximum flow in (s, t) planar networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Hassin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">107</biblScope>
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Faster shortest-path algorithms for planar graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">N</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Subramanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="23" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An efficient algorithm for image segmentation, Markov random fields and related problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Hochbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="686" to="701" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The pseudoflow algorithm: A new algorithm for the maximum-flow problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Hochbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="992" to="1009" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Improved algorithms for min cut and max flow in undirected planar graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">F</forename><surname>Italiano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Nussbaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sankowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wulff-Nilsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 43rd Annual ACM Symposium on Theory of Computing</title>
		<meeting>the 43rd Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Efficient algorithms for shortest paths in sparse networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">B</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="13" />
			<date type="published" when="1977" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Using divide and conquer to find flows in directed planar networks in O(n 3/2 log n) time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">B</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Venkatesan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th Annual Allerton Conference on Communication, Control, and Computing</title>
		<meeting>the 20th Annual Allerton Conference on Communication, Control, and Computing</meeting>
		<imprint>
			<date type="published" when="1982" />
			<biblScope unit="page" from="898" to="905" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Maximum flow in directed planar graphs with vertex capacities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Nussbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th European Symposium on Algorithms</title>
		<meeting>the 17th European Symposium on Algorithms</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="397" to="407" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Finding the maximal empty rectangle containing a query point</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sharir</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
	<note>manuscript</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The lattice structure of flow in planar graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Khuller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Discrete Mathematics</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="477" to="490" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Multiple-source shortest paths in planar graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">N</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th Annual ACM-SIAM Symposium on Discrete Algorithms</title>
		<meeting>the 16th Annual ACM-SIAM Symposium on Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="146" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Shortest paths in directed planar graphs with negative lengths: A linear-space O(n log 2 n)-time algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">N</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mozes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Weimann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Algorithms</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="18" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A fully dynamic approximation scheme for shortest paths in planar graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">N</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Subramanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="235" to="249" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Approximation algorithms for classification problems with pairwise relationships: Metric labeling and Markov random fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kleinberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tardos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th Annual Symposium on Foundations of Computer Science</title>
		<meeting>the 40th Annual Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Dynamic graph cuts for efficient inference in Markov random fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kohli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">H S</forename><surname>Torr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2079" to="2088" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Finding small simple cycle separators for 2-connected planar graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="265" to="279" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Flow in planar graphs with multiple sources and sinks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1002" to="1017" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
	<note>Preliminary version in FOCS</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Shortest paths in planar graphs with real lengths in O(n log 2 n/ log log n) time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mozes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wulff-Nilsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th European Symposium on Algorithms</title>
		<meeting>the 18th European Symposium on Algorithms</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="206" to="217" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Efficient planar graph cuts with applications in computer vision</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">R</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Toeppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cremers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Computer Society Conference on Computer Vision and Pattern Recognition</title>
		<meeting>the IEEE Computer Society Conference on Computer Vision and Pattern Recognition</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="351" to="356" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A data structure for dynamic trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">D</forename><surname>Sleator</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="362" to="391" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Parallel and Dynamic Shortest-Path Algorithms for Sparse Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Subramanian</surname></persName>
		</author>
		<idno>CS-95-04</idno>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
		<respStmt>
			<orgName>Brown University ; Available as Brown University Computer Science</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Input: a directed planar graph G, simple path P = d 1 d 2 . . . d k , capacity function c, and a pseudoflow f 0 Output: a pseudoflow f s.t. (1) f − f 0 satisfies conservation at nodes not on P and (2) w.r.t f , no residual path exists from {v ∈ P : inflow(v) &gt; 0} to {v ∈ P : inflow(v) &lt; 0}. 1: let X * be the set of endpoints in the planar dual G * of the darts of P 2: initialize to zero an array φ X</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">D Pseudocode for FixConservationOnPath Algorithm 6 FixConservationOnPath</title>
		<imprint/>
	</monogr>
	<note>indexed by the nodes of X * 3: let H * be the graph obtained from G * by removing the darts of P 4: compute, using the MSSP algorithm [23, 5], a table D * [·, ·] of distances in H * between nodes of X * w.r.t to f 8: for i = 1, 2, . . . , k 9: ψ X [y] = χ(y) + φ X [x] − φ X [y</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Next, the algorithm runs Dijkstra&apos;s algorithm on G * , initializing the label of each node y of X * to its correct value χ[y]. Since in the dual the darts of P ∪ rev(P ) are only incident to nodes of X * , Dijkstra&apos;s algorithm initialized in this manner correctly outputs the distance labels for all nodes of G * even if some of 6 1: let x be an arbitrary</title>
	</analytic>
	<monogr>
		<title level="m">Since both φ X and ψ X are known, the algorithm can compute the unreduced distances χ[y] for all y ∈ X * (line 4)</title>
		<imprint/>
	</monogr>
	<note>node in X * 2: ψ X = F R(D * , , φ X , x) ∈ G 6: χ := Dijkstra(G * , , x, χ</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Lemma F.1. Algorithm 5 is correct</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">It is possible to do so by only pushing back flow of f (rather than flow of f 0 + f ) since by assumption no node of C + has negative inflow w.r.t. f 0 . By maximality of the flow pushed in line 7, just after line 7 is executed there are no C + -to-t residual paths. Clearly, this remains true when the capacities of the artificial darts are set to zero</title>
	</analytic>
	<monogr>
		<title level="m">Any flow that is pushed by the algorithm originates at C + and terminates at C + ∪ {t}. Therefore, f − f 0 violates conservation only at C + ∪ {t}</title>
		<meeting><address><addrLine>C + , t, C +</addrLine></address></meeting>
		<imprint>
			<biblScope unit="volume">10</biblScope>
		</imprint>
	</monogr>
	<note>Moreover, by definition of FixConservationOnPath, there are no C &gt;0 -to-C &lt;0 residual paths immediately after line 9 is executed, where C &gt;0 (C &lt;0 ) is the set of nodes of C + with positive (negative) inflow at that time. Line 10 pushes flow into C &lt;0 , making all the nodes of C &lt;0 obey conservation. By sinks lemma(C &gt;0 , t, C &lt;0 ) there are no C &gt;0 -to-t residual paths upon termination of the procedure. This completes the proof since C &gt;0 is the set of nodes of C with positive inflow upon termination</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
