<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:29+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">CheckFence: Checking Consistency of Concurrent Data Types on Relaxed Memory Models *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Burckhardt</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Pennsylvania</orgName>
								<orgName type="institution" key="instit2">University of Pennsylvania</orgName>
								<orgName type="institution" key="instit3">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajeev</forename><surname>Alur</surname></persName>
							<email>alur@cis.upenn.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Pennsylvania</orgName>
								<orgName type="institution" key="instit2">University of Pennsylvania</orgName>
								<orgName type="institution" key="instit3">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milo</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
							<email>milom@cis.upenn.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Pennsylvania</orgName>
								<orgName type="institution" key="instit2">University of Pennsylvania</orgName>
								<orgName type="institution" key="instit3">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">CheckFence: Checking Consistency of Concurrent Data Types on Relaxed Memory Models *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D24 [Software Engineer- ing]: Software/Program Verification -Formal Methods, Model Checking</term>
					<term>D13 [Programming Techniques]: Concurrent Pro- gramming</term>
					<term>F31 [Logics and Meanings of Programs]: Specify- ing and Verifying and Reasoning about Programs -Mechanical Verification General Terms Verification Keywords Concurrent Data Structures, Multi-Threading, Shared- Memory Multiprocessors, Memory Models, Lock-Free Synchro- nization, Sequential Consistency, Software Model Checking</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Concurrency libraries can facilitate the development of multi-threaded programs by providing concurrent implementations of familiar data types such as queues or sets. There exist many optimized algorithms that can achieve superior performance on mul-tiprocessors by allowing concurrent data accesses without using locks. Unfortunately, such algorithms can harbor subtle concur-rency bugs. Moreover, they require memory ordering fences to function correctly on relaxed memory models. To address these difficulties, we propose a verification approach that can exhaustively check all concurrent executions of a given test program on a relaxed memory model and can verify that they are observationally equivalent to a sequential execution. Our Check-Fence prototype automatically translates the C implementation code and the test program into a SAT formula, hands the latter to a standard SAT solver, and constructs counterexample traces if there exist incorrect executions. Applying CheckFence to five previously published algorithms, we were able to (1) find several bugs (some not previously known), and (2) determine how to place memory ordering fences for relaxed memory models.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Shared-memory multiprocessors and multi-core chips are now ubiquitous. Nevertheless, programming such systems remains a challenge <ref type="bibr" target="#b45">[44]</ref>. Concurrency libraries such as the java.util.concurrent package JSR-166 <ref type="bibr" target="#b28">[27]</ref> or the Intel Threading Building Blocks <ref type="bibr" target="#b23">[22]</ref> support the development of safe and efficient multi-threaded programs by providing concurrent data types, that is, concurrent implementations of familiar data abstractions such as queues, sets, or maps.</p><p>Client programs with threads that execute concurrently on a multiprocessor can benefit from implementations that are optimized for concurrency. Many sophisticated algorithms that use lock-free synchronization have been proposed for this purpose <ref type="bibr" target="#b18">[17,</ref><ref type="bibr" target="#b19">18,</ref><ref type="bibr" target="#b32">31,</ref><ref type="bibr" target="#b34">33,</ref><ref type="bibr" target="#b35">34,</ref><ref type="bibr" target="#b44">43]</ref>. Such implementations are not race-free in the classic sense because they allow concurrent access to shared memory locations without using locks for mutual exclusion.</p><p>Algorithms with lock-free synchronization are notoriously hard to verify, as witnessed by many formal verification efforts <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b15">14,</ref><ref type="bibr" target="#b47">46,</ref><ref type="bibr" target="#b51">50]</ref> and by bugs found in published algorithms <ref type="bibr" target="#b11">[10,</ref><ref type="bibr" target="#b33">32]</ref>. Many more interleavings need to be considered than for implementations that follow a strict locking discipline. Moreover, the deliberate use of races prohibits the use of classic race-avoiding design methodologies and race-detecting tools <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b13">12,</ref><ref type="bibr" target="#b20">19,</ref><ref type="bibr" target="#b25">24,</ref><ref type="bibr" target="#b37">36,</ref><ref type="bibr" target="#b40">39,</ref><ref type="bibr" target="#b42">41,</ref><ref type="bibr" target="#b50">49]</ref>.</p><p>To make matters worse, most commonly used multiprocessor architectures use relaxed memory ordering models <ref type="bibr" target="#b1">[2]</ref>. For example, a processor may reorder loads and stores by the same thread if they target different addresses, or it may buffer stores in a local queue. Whereas fully lock-based programs are insensitive to the memory model (because the lock and unlock operations are designed to guarantee the necessary memory ordering), implementations that use lock-free synchronization require explicit memory ordering fences to function correctly on relaxed memory models. Fences counteract the ordering relaxations by selectively enforcing memory order between preceding and succeeding instructions. A lack of fences leads to incorrect behavior, whereas an overzealous use of fences impacts performance. Nevertheless, fence placements are rarely published along with the algorithm.</p><p>To help designers and implementors develop correct and efficient programs for relaxed models, we present a method that can statically check the consistency of a data type implementation for a given bounded test program and memory model <ref type="figure" target="#fig_0">(Fig. 1)</ref>. Given the implementation code, a small test program representing the client program, and a choice of memory model, our CheckFence prototype verifies for all concurrent executions of the test that the observed results are consistent with the expected semantics of the data type. If the check fails, a counterexample trace is presented to the user who can then analyze and fix the problem.</p><p>We build upon and further automate the general technique described in our prior case study <ref type="bibr" target="#b3">[4]</ref>. At the heart of this method is an encoding that represents the executions of the test program as solutions to a propositional formula. To obtain this formula, we first compile the code for each thread into a bounded sequence of instructions. Then we separately encode the thread-local program semantics (in the style of CBMC <ref type="bibr" target="#b5">[5]</ref>) and the memory model (in axiomatic form). Once the encoding is complete, we can use a standard SAT solver to solve for erroneous executions.</p><p>Our method proceeds in two steps. First, we perform a specification mining: we automatically create a specification for the given test by enumerating the set of correct observations. An observation is a combination of argument and return values, and it is correct if it is consistent with some atomic interleaving of the operations. For example, for the test in <ref type="figure" target="#fig_0">Fig. 1</ref>,</p><formula xml:id="formula_0">(A = 0, B = 1, X = 0, Y = 1) is a correct observation, whereas (A = 0, B = 1, X = 0, Y = 0) is not.</formula><p>After mining the specification, we then check all executions of the test on the chosen memory model to see that the observed values are contained in the specification. This step is called inclusion check. If the inclusion check fails, we produce a counterexample trace. The trace presents the details of the execution to the user, who can then analyze and fix the problem.</p><p>We implemented this method in a prototype called CheckFence and applied it to five previously published algorithms, writing test programs and C code that closely follows the published pseudocode. We were thus able to 1. Reproduce two known bugs in a concurrent deque algorithm known as "snark" <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b11">10,</ref><ref type="bibr" target="#b27">26]</ref>.</p><p>2. Uncover a not-previously-known bug in a lazy list-based set implementation. The published pseudocode <ref type="bibr" target="#b19">[18]</ref> fails to initialize a field, which was missed by a prior formal verification using the PVS interactive proof system <ref type="bibr" target="#b6">[6]</ref>.</p><p>3. Show numerous failures on architectures with relaxed memory models (the original algorithms assume sequentially consistent architectures), and fix them by inserting appropriate memory ordering fences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Problem Formulation</head><p>In this section, we describe the parameters of the verification problem (test programs, correctness condition, and memory models) more concretely.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Test Programs</head><p>To exercise the implementation code, we use test programs. A test program specifies a finite sequence of operation calls for each thread. It may choose to leave the argument values unspecified, which conveniently allows us to cover many scenarios with a single test. It may also specify initialization code to be performed prior to the concurrent execution of the threads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Correctness Condition</head><p>The basic idea of our method is to compare the set of concurrent executions with the set of serial executions. Given a test program T that makes invocations to the operations of some abstract data type, and an implementation I, we define</p><p>• ET,I,Serial is the set of serial executions. Serial executions are executions by a single processor that interleaves the threads and treats the operations as atomic, that is, does not switch threads within operations.</p><p>• ET,I,Y is the set of multiprocessor executions for memory model Y . The model Y may use relaxed memory ordering rules.</p><p>We define these sets more formally below in Section 2.3.1 and proceed first to a description of how they relate to our correctness condition. For a given execution e we define the observation vector obs(e) to consist of the argument and return values to the operations that occur in e. For test program T and implementation I, we define the observation set as</p><formula xml:id="formula_1">ST,I = {obs(e) | e ∈ ET,I,Serial}</formula><p>The observation set S captures the intended behavior of the data type, and serves as a specification in the following sense. For test T and observation set S, we say that the implementation I satisfies S on memory model Y if and only if ∀e ∈ ET,I,Y : obs(e) ∈ S Because the argument and return values are all that the client program observes, implementations that satisfy the specification are guaranteed to appear to the client program as if they executed the operations atomically.</p><p>Note that we need not necessarily use the same implementation when extracting the specification S and when performing the inclusion check. In practice, it is often sensible to write a reference implementation (which need not be concurrent and is thus simple) to construct the observation set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Memory Models</head><p>We currently support two hardware-level memory models. One is the classic sequential consistency <ref type="bibr" target="#b26">[25]</ref>, which requires that the loads and stores issued by the individual threads are interleaved in some global, total order. Sequential consistency is easiest to understand; however, it is not guaranteed by most multiprocessors <ref type="bibr" target="#b1">[2]</ref>.</p><p>The other model is Relaxed <ref type="bibr" target="#b3">[4]</ref>. It allows the hardware to relax the ordering and atomicity of memory accesses. Specifically, it permits (1) reorderings of loads and stores to different addresses, (2) buffering of stores in local queues, (3) forwarding of buffered stores to local loads, (4) reordering of loads to the same address, and (5) reordering of control-or data-dependent instructions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1">Set of Executions</head><p>For a test T with n threads, an implementation I, and a memory model Y , we define the set of executions ET,I,Y to consist of all execution traces e = (w1, . . . , wn) such that (1) each wi is a finite sequence of basic machine instructions (loads, stores, assignments, and fences) within which all instructions are annotated with the execution values, (2) each instruction sequence wi corresponds to a sequential execution (under standard semantics) of the code for thread i as specified by T, I, and (3) the trace e satisfies the conditions of the memory model Y as defined in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2">Memory Model Axioms</head><p>We now present the core of our axiomatic formulations for sequential consistency and Relaxed. First, we need some common notation. Let A be a set of addresses, and V be a set of values. For a given execution trace e = (w1, . . . , wn), let Xe = Le ∪ Se be the set of memory accesses in the trace, with Le being the set of loads and Se being the set of stores. For an access x ∈ Xe, let a(x) ∈ A be the address of the accessed location, and v(x) ∈ V be the value loaded or stored. For an address a ∈ A, let i(a) ∈ V be the initial value of the memory location a. Let &lt;p be the program order, that is, a partial order on Xe such that x &lt;p y whenever x precedes y within some sequence wi.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sequential</head><p>Consistency. An execution trace e is sequentially consistent if there exists a total order &lt;M over Xe (the memory order) subject to the following conditions. For each load l ∈ Le, let S(l) be the set of stores that are "visible" to l:</p><formula xml:id="formula_2">S(l) = {s ∈ Se | a(s) = a(l) ∧ (s &lt;M l)}</formula><p>Then the following axioms must be satisfied:</p><formula xml:id="formula_3">1. if x &lt;p y, then x &lt;M y 2. if l ∈ Le and S(l) = ∅, then v(l) = i(a)</formula><p>3. if l ∈ Le and s ∈ S(l) and v(l) = v(s), then there exists a store s ∈ S(l) such that s &lt;M s .</p><p>Relaxed. An execution trace e is allowed by the memory model Relaxed if there exists a total order &lt;M over Xe (the memory order) subject to the following conditions. For each load l ∈ Le, let S(l) be the set of stores that are "visible" to l:</p><formula xml:id="formula_4">S(l) = {s ∈ Se | a(s) = a(l) ∧ ((s &lt;M l) ∨ (s &lt;p l))}</formula><p>Then the following axioms must be satisfied:</p><p>1. if x &lt;p y, a(x) = a(y), and y ∈ Se, then x &lt;M y</p><formula xml:id="formula_5">2. if l ∈ Le and S(l) = ∅, then v(l) = i(a)</formula><p>3. if l ∈ Le and s ∈ S(l) and v(l) = v(s), then there exists a store s ∈ S(l) such that s &lt;M s .</p><p>The model Relaxed differs from sequential consistency in two places. For one, axiom 1 has been weakened to allow the memory order to be different from the program order. Secondly, the set S(l) has been modified to allow forwarding of values from stores sitting in a local store queue to subsequent loads by the same processor: S(l) may contain stores that precede a load in program order (s &lt;p l) but are performed globally only after the load is performed (l &lt;M s).</p><p>Seriality. We can conveniently formalize serial executions (executions that interleave the operations atomically) by defining seriality as a special kind of "memory model" as follows. Given T, I and an execution trace e, define an equivalence relation ∼ over Xe such that x ∼ y whenever x, y are part of the same operation. Then, we say e is serial if and only if (1) it is sequentially consistent, and (2) if x ∼ x and y ∼ y , then (x &lt;M y) ⇔ (x &lt;M y ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.3">Comparison to Other Memory Models</head><p>Memory models can be compared in terms of the execution traces they allow. We call a model Y stronger than another model Y if every execution trace that is allowed by model Y is also allowed by Y . For example, seriality is stronger than sequential consistency, and sequential consistency is stronger than Relaxed.</p><p>The purpose of Relaxed is to provide a common, conservative approximation of several memory models (Sun SPARC v9 TSO/PSO/RMO <ref type="bibr" target="#b49">[48]</ref>, Alpha <ref type="bibr" target="#b7">[7]</ref>, and IBM 370/390/zArchitecture <ref type="bibr" target="#b24">[23]</ref>). All of these models are stronger than Relaxed, which implies that once code runs correctly on Relaxed, it will run correctly on the former.</p><p>However, Relaxed is not strictly weaker than the official PowerPC <ref type="bibr" target="#b14">[13]</ref>, IA-64 <ref type="bibr" target="#b22">[21]</ref> and IA-32 <ref type="bibr" target="#b21">[20]</ref> models because it globally orders all stores (the execution in <ref type="figure">Fig. 2</ref> illustrates this point). Even so, Relaxed still captures the most important relaxations of those models and is useful to determine where to place fences. This limitation is not fundamental to our methodology, and we are actively</p><p>Initially, x = y = 0 thread 1 thread 2 thread 3 thread 4 store x, 1 store y, 1 load x, 1 load y, 1 load-load fence load-load fence load y, 0 load x, 0</p><p>Figure 2. An execution trace that is not possible on Relaxed, but not ruled out on PPC, IA-32, and IA-64. On the latter, we represent the load-load fence as follows: (PPC) lwsync, (IA-32) lfence, (IA-64) replace load that precedes the fence with load-acquire.</p><p>working on formalizing a weaker version of Relaxed to close the gap.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Solution</head><p>We now describe how we implemented and applied our method. See <ref type="figure" target="#fig_2">Fig. 3</ref> for a schematic view of the internal structure of the tool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Front-End</head><p>CheckFence has a front-end that compiles the C code into an intermediate representation. This intermediate representation uses a custom language called load-store language (LSL) which precisely defines the possible instruction sequences of stores, loads, fences, and synchronization instructions for each thread.</p><p>The front-end is based on the CIL framework <ref type="bibr" target="#b38">[37]</ref> which parses C and provides us with a cleaned-up and somewhat simplified abstract syntax tree. From there, compilation into LSL is relatively straightforward for most programs. CheckFence translates concurrent data type implementations of realistic detail precisely and automatically, but it may refute some programs if they contain unsupported features. We discuss some of the choices we made in the following paragraphs. See <ref type="figure" target="#fig_3">Fig. 4</ref> for the abstract syntax of LSL.</p><p>C multiprocessor semantics. The C language does not specify a memory model (standardization efforts for C/C++ are still under way). Therefore, executing memory-model sensitive C code on a multiprocessor can have unpredictable effects <ref type="bibr" target="#b2">[3]</ref>. On the machine language level, however, the memory model is officially defined by the hardware architecture. It is therefore possible to write C code for relaxed models by exerting direct control over the C compilation process to prevent optimizations that would alter the program semantics. The details of how to do this (for example, volatile declarations, compiler pragmas, or command line options) are compiler-dependent and beyond the scope of this work. Here, we simply assume a "vanilla" compilation without optimizations, and we apply the hardware-level memory model to the resulting machine-level program.</p><p>Values and types. We found that the types present at C source level can not be relied upon (due to the presence of casts). Therefore, we chose to keep LSL untyped; however, we do track the type    of values at runtime, by distinguishing between undefined, integer, and pointer values. The back-end also recovers some static type information directly from the untyped code by performing a range analysis (see Section 3.4). The runtime types help to automatically detect bugs. For example, we detect if a program uses an undefined value in a computation or a condition.</p><formula xml:id="formula_6">(number) n ∈ N (value) v ::= undefined | n | [ n ] (register) r (primitive op) f (procedure name) p (block tag) t (statement) s ::= (constant) r = v (primitive op) | r = f (r) (store) | * r = r (load) | r = * r (fence X) | fenceX (atomic block) | atomic { s } (procedure call) | p(r)(r) (labeled block) | t : { s } (leave block) | if (r) break t (repeat block) | if (r) continue t (assertion) | assert (r) (assumption) | assume (r)</formula><formula xml:id="formula_7">Pointer C value LSL value &amp;(x) 0x000 [ 0 ] &amp;(x.a) 0x000 [ 0 0 ] &amp;(x.b) 0x008 [ 0 1 ] &amp;(x.b[0]) 0x008 [ 0 1 0 ] &amp;(x.b[1]) 0x00C [ 0 1 1 ] &amp;(x.b[2]) 0x010 [ 0 1 2 ] &amp;(y) 0x014 [ 1 ]</formula><p>Pointer values. We represent pointer values as a sequence of natural numbers [n1 . . . n k ] where (k ≥ 1), representing the base address n1 and sequence of offsets n2, . . . , n k . The offsets may be field or array offsets, providing a unified way of handling arrays and structs. See <ref type="figure" target="#fig_4">Fig. 5</ref> for an example of how C pointers can be represented in this manner. The advantage of keeping the offsets separate from the base address is that we can avoid addition or multiplication when encoding pointer operations in the back-end. Moreover, our range analysis (Section 3.4) can often determine that large portions of the sequence are statically fixed.</p><p>Control flow. To facilitate a minimalistic unrolling of loops in the back end, we retain the nested block structure of the source program. Conditionals are represented by conditional breaks and continues which can exit or repeat an enclosing block identified by its tag.</p><p>Fences. Fences are special machine instructions that guarantee some ordering among the memory accesses that precede and follow it. We currently support four kinds of memory ordering fences: load-load, load-store, store-load and store-store (as used by the Sparc RMO memory model <ref type="bibr" target="#b49">[48]</ref>). An X-Y fence guarantees that all accesses of type X that appear before the fence will be ordered before all accesses of type Y that appear after the fence. Fences can guarantee some ordering among the memory accesses without enforcing full sequential consistency. Synchronization. We currently model all synchronization in LSL using atomic blocks. The instructions within an atomic block are guaranteed to execute in program order, and they are never interleaved with instructions in other threads. See <ref type="figure">Fig. 6</ref> for a pseudocode example of how we model the compare-and-swap instructions using an atomic block. Our lock and unlock operations are based on code from the SPARC v9 architecture manual <ref type="bibr" target="#b49">[48]</ref> and use a spin loop, an atomic load-store primitive, and partial memory ordering fences <ref type="figure">(Fig. 7)</ref>. To avoid an unbounded unrolling of the spin loop, we use a custom reduction for side-effect free spin loops.</p><p>C features. The C language has many features, not all of which are supported by our CheckFence prototype. We are adding features as needed to handle the implementations we wish to study. Already supported are pointers, structs, arrays, full integer arithmetic, limited pointer arithmetic, nested loops, limited gotos, and packed structures. <ref type="bibr" target="#b0">1</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Back-End</head><p>The back-end first transforms the test program T and implementation I by inlining the operation calls and unrolling the loops (more on this in Section 3.3). As a result, the code for each thread is a simple sequence of machine-level instructions comprising only loads, stores, register assignments, fences, and forward branches. We now encode the possible executions as a propositional formula ΦT,I,Y (Z) over boolean variables Z such that each solution of Φ corresponds to an execution e ∈ ET,I,Y (more on this in Sec-tion 3.2.1). Once we have Φ thus encoded, we can perform the specification mining and inclusion check using a standard SAT solver as follows.</p><p>Specification mining. To construct the observation set ST,I we use the following iterative procedure. First, we provide the formula ΦT,I,Serial(Z) as an input to the SAT solver. Next, we run the solver which will return a solution for Z, corresponding to some serial execution e ∈ ET,I,Serial. Let o1 be the observation of this execution. Now, we add additional constraints to the solver to exclude executions that have the observation o1 and run the solver again. If there is another solution, it gives us a new observation o2. By continuing this process (adding constraints to rule out observations we already saw) until the SAT solver determines insatisfiability (say, after k steps), we obtain the observation set ST,I = {o1, o2, . . . , o k }.</p><p>Our practical experience suggests that although the set of serial executions ET,I,Serial can be quite large (due to nondeterministic memory layout and interleavings), the observation set ST,I contains no more than a few thousand elements for the testcases we used. Therefore, the iterative procedure described above is sufficiently fast, especially when used with a SAT solver that supports incremental solving.</p><p>Inclusion check. For a given test T , implementation I, memory model Y , and finite observation set S, we check the inclusion obs(ET,I,Y ) ⊂ S by asking the SAT solver to find a solution for the variables Z subject to the constraints</p><formula xml:id="formula_8">ΦT,I,Y (Z) ∧ ^ o∈S obs(Z) = o</formula><p>If the SAT solver finds a satisfying assignment, then the corresponding execution is a counterexample because its observation is not equal to any observation in S. On the other hand, if the SAT instance is unsatisfiable, the inclusion check passes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Encoding Concurrent Executions</head><p>After inlining I in T and unrolling the loops, the code resembles a machine-level program consisting only of loads, stores, register assignments, fences, and forward branches. Following the definition of ET,I,Y in Section 2.3.1, we can now encode the possible execution traces e = (w1, . . . , wn) by introducing variables to represent the execution values and writing constraints over these variables to capture the conditions (2) and (3). To encode the thread-local semantics (condition 2), we use a formula ∆ T,I,k for each thread k. To encode the memory model (condition 3), we use a formula ΘT,I,Y .</p><p>The thread-local formulae. To obtain ∆ T,I,k , we follow a technique similar to the CBMC tool <ref type="bibr" target="#b5">[5]</ref>; specifically, we use a register SSA (single static assignment) form that guarantees that for each program point and for each register there is statically known, unique instruction that assigned it last.</p><p>For each thread k, we introduce a set of variables V k containing one variable for each instruction, representing the LSL value produced by that instruction. Next, we introduce a set C k of boolean variables containing one variable for each forward branch, representing whether the branch is taken or not. We now create constraints for each assignment to express the relationship between the consumed and produced values, and for each branch to express how the branch condition depends on the value of some register. By taking the conjunction of all these constraints we get a formula ∆ T,I,k (V k , C k ) that captures the possible executions of the thread in an unspecified environment (that is, for unspecified values returned by the loads).</p><p>The memory model formula. We construct a formula ΘT,I,Y to represent the memory model. In our case, Θ is simply the conjunction of the memory model axioms for Y (Section 2.3.2). If we represent the memory order &lt;M by a variable M (ranging over all total orders of X), we thus get a formula ΘT,I,Y (M, V, C) where V = S k V k and C = S k C k . This formula depends on the variables in V because the axioms make reference to the addresses and values used by instructions. It depends on the variables in C because the axioms apply to executed memory accesses only (an access that is skipped over by a branch is not part of the set Xe).</p><p>The combined formula. We combine the thread-local and communication formulae as follows</p><formula xml:id="formula_9">ΦT,I,Y (M, V, C) ≡ ΘT,I,Y (M, V, C) ∧ ^ k ∆ T,I,k (V k , C k )</formula><p>Finally, we need to transform Φ down to the level of the SAT solver, which requires conjunctive normal form ΦT,I,Y (Z) for some set of boolean variables Z. We thus need to replace all quantifiers by finite conjunctions or disjunctions and break M and V down to boolean variables. During this process we introduce auxiliary variables, as follows.</p><p>1. To encode the memory order M , we introduce auxiliary variables {Mxy | x, y ∈ X} such that Mxy represents x &lt;M y.</p><p>To express antisymmetry, we represent Mxy and Myx by the same SAT variable (adjusting the sign of literals). To express transitivity, we add explicit clauses.</p><p>2. To encode the value variables V , we use bitvectors. To get a conservative estimate on the required width, we perform a range analysis (Section 3.4).</p><p>3. For each pair of values v1, v2 ∈ V , we introduce auxiliary variables to represent the equalities v1 = v2. We use separate clauses to break the equalities down to the bit level (which we need only do for equality literals that appear in the formula).</p><p>4. We use for each l ∈ L an auxiliary variable Init l that represents whether S(l) = ∅, and for each s ∈ S and l ∈ L an auxiliary variable Flow sl that represents whether s is the maximal store in S(l).</p><p>The resulting CNF encoding is polynomial: the number of SAT variables and clauses is quadratic and cubic in the size of the unrolled test program, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Loop Bounds</head><p>For the implementations and tests we studied, all loops are statically bounded. However, this bound is not necessarily known in advance. We therefore unroll loops lazily as follows. For the first run, we unroll each loop exactly once. We then run our regular checking, but restrict it to executions that stay within the bounds. If an error is found, a counterexample is produced (the loop bounds are irrelevant in that case). If no error is found, we run our tool again, solving specifically for executions that exceed the loop bounds. If none is found, we know the bounds to be sufficient. If one is found, we increment the bounds for the affected loop instances and repeat the procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Range Analysis</head><p>To reduce the number of boolean variables, we perform a range analysis before encoding Φ. Specifically, we use a simple lightweight flow-insensitive analysis to calculate for each SSA register r and each memory location m sets Sr, Sm that conservatively approximate the values that r or m may contain during a valid execution. We can sketch the basic idea as follows. First, initialize Sr and Sm to be the empty set. Then, keep propagating values as follows until a fixpoint is reached:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ms2</head><p>Two-lock queue <ref type="bibr" target="#b34">[33]</ref> Queue is represented as a linked list, with two independent locks for the head and tail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>msn</head><p>Nonblocking queue <ref type="bibr" target="#b34">[33]</ref> Similar, but uses compare-and-swap for synchronization instead of locks ( <ref type="figure" target="#fig_7">Fig. 9</ref>).</p><p>lazylist Lazy list-based set <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b19">18]</ref> Set is represented as a sorted linked list. Per-node locks are used during insertion and deletion, but the list supports a lock-free membership test.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>harris</head><p>Nonblocking set <ref type="bibr" target="#b17">[16]</ref> Set is represented as a sorted linked list. Compare-and-swap is used instead of locks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>snark</head><p>Nonblocking deque <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b11">10]</ref> Deque is represented as linked list. Uses double-compare-and-swap. <ref type="table">Table 1</ref>. The implementations we studied. We use the mnemonics on the left for quick reference.</p><p>• constant assignments of the form r = c propagate the value c to the set Sr.</p><p>• assignments of the form r = f (r1, . . . , r k ) propagate values from the sets Sr 1 , . . . , Sr k to the set Sr (applying the function).</p><p>• stores of the form * r = r propagate values from the set Sr to the sets {Sm | m ∈ S r }.</p><p>• loads of the form r = * r propagate values from the sets {Sm | m ∈ S r } to the set Sr.</p><p>This analysis is sound for executions that do not have circular value dependencies. To ensure termination, we need an additional mechanism. First, we count the number of assignments in the test that have unbounded range. That number is finite because we are operating on the unrolled, finite test program. During the propagation of values, we tag each value with the number of such functions it has traversed. If that number ever exceeds the total number of such functions in the test, we can discard the value. We use the sets Sr for four purposes: (1) to determine a bitwidth that is sufficient to encode all integer values that can possibly occur in an execution, (2) to determine a maximal depth of pointers, <ref type="formula">(3)</ref> to fix individual bits of the bitvector representation (such as leading zeros), and (4) to rule out as many aliasing relationships as possible, thus reducing the size of the memory model formula.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Results</head><p>We studied the five implementations shown in <ref type="table">Table 1</ref>. All of them make deliberate use of data races. Although the original publications contain detailed pseudocode, they do not indicate where to place memory ordering fences. Thus, we set out to (1) verify whether the algorithm functions correctly on a sequentially consistent memory model, (2) find out what breaks on the relaxed model and (3) add memory fences to the code as required.</p><p>First we wrote symbolic tests <ref type="figure">(Fig. 8)</ref>. To keep the counterexamples small, we started with small and simple tests, say, two to four threads with one operation each. All memory model-related bugs were found on such small testcases. We then gradually added larger tests until we reached the limits of the tool. <ref type="figure" target="#fig_0">Fig. 10</ref> shows the tests we ran for each implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Bugs Found</head><p>We found several bugs that are not related to relaxations in the memory model. The snark algorithm has two known bugs <ref type="bibr" target="#b11">[10,</ref><ref type="bibr" target="#b27">26]</ref>. We found the first one quickly on test D0. The other one requires a fairly deep execution. We found it with the test Dq, which took about an hour.</p><p>We also found a not-previously-known bug in the lazy listbased set: the pseudocode fails to properly initialize the 'marked' field when a new node is added to the list. This simple bug went undetected by a formal correctness proof <ref type="bibr" target="#b6">[6]</ref> because the PVS source code did not match the pseudocode in the paper precisely <ref type="bibr" target="#b29">[28]</ref>. This confirms the importance of using actual code (rather than pseudocode and manual modeling) for formal verification. </p><formula xml:id="formula_10">T0 = ( e | d ) Ti2 = e ( ed | de ) T1 = ( e | e | d | d ) Ti3 = e ( de | dde ) Tpc2 = ( ee | dd ) T53 = ( eeee | d | d ) Tpc3 = ( eee | ddd ) T54 = ( eee | e | d | d ) Tpc4 = ( eeee | dddd ) T55 = ( ee | e | e | d | d ) Tpc5 = ( eeeee | ddddd ) T56 = ( e | e | e | e | d | d ) Tpc6 = ( eeeeee | dddddd )</formula><p>Set tests: (a, c, r for add, contains, remove)</p><formula xml:id="formula_11">Sac = ( a | c ) Sar = ( a | r ) Sacr = ( a | c | r ) Saacr = a ( a | c | r ) Sacr2 = aar ( a | c | r ) Saaarr = aaa ( r | rc ) S1 = (a' | a' | c' | c' | r' | r') Sarr = ( a | r | r )</formula><p>Deque tests: (a l , ar, r l , rr for add/remove left/right)</p><formula xml:id="formula_12">D0 = (a l rr | ar r l ) Db = (rr r l | ar | a l ) Da = a l a l (rr rr | r l r l ) Dm = (a l a l a l | r r r r r r | r l | a r ) Dq = (a l | a l | a r | a r | r l | r l | r r | r r )</formula><p>Figure 8. The tests we used. We show the invocation sequence for each thread in parentheses, separating the threads by a vertical line. Some tests include an initialization sequence which appears before the parentheses. If operations need an input argument, it is chosen nondeterministically out of {0, 1}. Primed versions of the operations are restricted forms that assume no retries (that is, retry loops are restricted to a single iteration).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Missing Fences</head><p>As expected, our testcases revealed that all five implementations require extra memory fences to function correctly on relaxed memory models.</p><p>To give a concrete example, we show the source code for the non-blocking queue with appropriate fences in <ref type="figure" target="#fig_7">Fig. 9</ref>. To our knowledge, this is the first published version of Michael and Scott's non-blocking queue that includes memory ordering fences. We verified that on Relaxed these fences are sufficient and necessary for the tests in <ref type="figure" target="#fig_0">Fig. 10</ref>. Of course, our method may miss some fences if the tests do not cover the scenarios for which they are needed. An interesting observation is that the implementations we studied required only load-load and store-store fences. On some architectures (such as Sun TSO or IBM zSeries), these fences are automatic and the algorithm therefore works without inserting any fences on these architectures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Description of Typical Failures</head><p>Incomplete initialization. A common failure occurs with code sequences that (1) allocate a new node, (2) set its fields to some value and (3) link it into the list. On relaxed memory models, the stores to the fields (in step 2) may be delayed past the pointer store  <ref type="bibr" target="#b34">[33]</ref>, with fences added. It is slightly simplified: the original code stores a counter along with each pointer, which we omit because it is not required in all contexts. No such modifications were made to the other algorithms.</p><p>(in step 3). If so, operations by other threads can read the node fields before they contain the correct values, with fatal results. All five implementations showed this behavior. The fix is the same in all cases: adding a store-store fence between steps (2) and (3). For example, the store-store barrier on line 29 of <ref type="figure" target="#fig_7">Fig. 9</ref> was added for this reason.</p><p>Reordering of value-dependent instructions. Some weak architectures (such as Alpha <ref type="bibr" target="#b7">[7]</ref>) allow loads to be reordered even if they are value dependent. For example, the common code sequence (1) read a pointer p to some structure and (2) read a field p-&gt;f is (somewhat surprisingly) susceptible to out-of-order execution: the processor may perform the load of p-&gt;f before the load of p by speculating on the value of p and then confirming it afterward <ref type="bibr" target="#b31">[30]</ref>. We found this behavior to cause problems in all five implementations. To avoid it, we add a load-load fence between the two instructions. For example, the load-load fence on line 32 in <ref type="figure" target="#fig_7">Fig. 9</ref> was inserted for this reason.</p><p>Reordering of CAS operations. We model the compare-andswap operation without any implied fences <ref type="figure">(Fig. 6)</ref>. As a result, two CAS instructions to different addresses may be reordered. We observed this behavior only for the nonblocking queue, where it causes problems in the dequeue operation ( <ref type="figure" target="#fig_7">Fig. 9</ref>) if the tail is advanced (line 45) before the node is linked into the list (line 37). To fix this problem, we added a store-store fence on line 44.</p><p>Reordering of load sequences. The nonblocking queue uses simple load sequences to achieve some synchronization effects. For example, queue-&gt;tail is loaded a first time on line 31; next, tail-&gt;next is loaded (line 33); then, queue-&gt;tail is loaded a second time (line 35) and the value is compared to the previously loaded value. If the values are the same, the implementation infers that the values that were loaded for queue-&gt;tail and tail-&gt;next are consistent (that is, can be considered to have been loaded atomically). A similar load sequence is used in the enqueue operation (lines 52 and 58). For this mechanism to work, we found that the loads in the sequence must not be reordered, and we added a number of load-load fences to achieve this effect <ref type="bibr">(lines 32, 34, 53, 55, 57)</ref>. The other implementations did not exhibit this behavior.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Quantitative Results</head><p>The performance results confirm that our observation set method provides an efficient way to check bounded executions of concurrent C programs (with up to about 200 memory accesses). Furthermore, they indicate that for our encoding, the choice of the memory model has no significant impact on the tool execution time.</p><p>Inclusion check statistics. To illustrate the character of the inclusion checks, we show statistics and graphs in <ref type="figure" target="#fig_0">Fig. 10</ref>. As described in Section 3.2.1, CheckFence encodes the inclusion problem as a CNF formula which is then refuted by the zChaff SAT solver <ref type="bibr" target="#b36">[35]</ref> (version 2004/11/15). To keep the trends visible, we do not include the time required for the lazy loop unrolling because it varies greatly between individual tests and implementations.</p><p>Specification mining statistics. We show information about the specification mining in <ref type="figure" target="#fig_0">Fig. 11a</ref>. Most observation sets were quite small (less than 200 elements). The time spent for the specification mining averaged about a third of the total runtime <ref type="figure" target="#fig_0">(Fig. 11b)</ref>. However, in practice, much less time is spent for observation set enumeration because (1) observation sets need not be recomputed after each change to the implementation, and (2) we can often compute observation sets much more efficiently by using a small, fast reference implementation (as shown by the data points for "refset").   <ref type="table">Table 1</ref>) and test (listed in <ref type="figure">Fig. 8</ref>), we show (from left to right): the size of the unrolled code, the time required to create the SAT instance, the size of the SAT instance, the resources required by the SAT solver to refute the SAT instance, and the overall time required. All measurements were taken on a 3 GHz Pentium 4 desktop PC with 1GB of RAM, using zchaff <ref type="bibr" target="#b36">[35]</ref>  Impact of range analysis. As described earlier, we perform a range analysis prior to the encoding to obtain data bounds, alias analysis, and range information. This information is used to improve the encoding by reducing the number of boolean variables. <ref type="figure" target="#fig_0">Fig. 11c</ref> shows the effect of the range analysis on runtime. On average, the performance improvement was about 42%. On larger testcases (where we are most concerned), the positive impact is more pronounced (the tool finished up to 3× faster).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Choice of memory model. All tests use the memory model</head><p>Relaxed (see Sections 2.3 and 3.2.1). To find out if the choice of memory model has an effect on the runtime, we separately evaluated the runtime for a sequentially consistent memory model. The results indicate that on average, performance is about 4% faster for sequential consistency, which is insignificant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Related Work</head><p>Most prior work on verification of concurrent data types is based on interactive proof construction and assumes a sequentially consistent memory model <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b15">14,</ref><ref type="bibr" target="#b41">40,</ref><ref type="bibr" target="#b47">46,</ref><ref type="bibr" target="#b51">50]</ref>. To our knowledge, analogous proof strategies for relaxed memory models have not been investigated.</p><p>Specialized algorithms to insert memory fences automatically during compilation have been proposed early on <ref type="bibr" target="#b12">[11,</ref><ref type="bibr" target="#b43">42]</ref>. However, these methods are based on a conservative program analysis, which makes them less attractive for highly optimized implementations: fences can have a considerable performance impact <ref type="bibr" target="#b46">[45,</ref><ref type="bibr" target="#b48">47]</ref> and should be used sparingly.</p><p>Most previous work on model checking executions on relaxed memory models has focused on relatively small and handtranslated code snippets (such as spinlocks or litmus tests). It can be divided into two categories: explicit-state model checking combined with operational memory models <ref type="bibr" target="#b10">[9,</ref><ref type="bibr" target="#b39">38]</ref>, and constraint solving combined with axiomatic memory models <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">15,</ref><ref type="bibr" target="#b52">51]</ref>.</p><p>We prefer the latter approach for two reasons: (1) axiomatic models can more easily capture official specifications because the latter use an axiomatic style, and (2) constraint-based encodings can leverage the advances in SAT solving technology.</p><p>When compared to our earlier case study <ref type="bibr" target="#b3">[4]</ref>, the method presented in this paper differs as follows:</p><p>• We allow the operations of the implementation to be written as C code (rather than requiring a manual translation). This improves the degree of automation and the precision, at the expense of a somewhat larger encoding.</p><p>• Our observation set method is more automatic and more general, because it does not require commit point specifications. Implementations such as the lazy list-based set <ref type="bibr" target="#b19">[18]</ref> are not known to have commit points <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b47">46]</ref>. • Our observation method is faster. <ref type="figure" target="#fig_0">Fig. 12</ref> shows a direct speed comparison on a logarithmic scale; the diagonal lines show constant speed ratios. On average, the speedup was about 2.61×, but it approached an order of magnitude on some tests.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions</head><p>Verifying concurrent data type implementations that make deliberate use of data races and memory ordering fences is challenging because of the many interleavings and counterintuitive instruction reorderings that need to be considered. Conventional verification tools for multithreaded programs are not sufficient because they make assumptions on the programming style (race-free programs) or the memory model (sequential consistency).</p><p>Our CheckFence prototype fills this gap and provides a valuable aid to algorithm designers and implementors because it (1) accepts implementations written as C code, (2) supports relaxed memory models, memory ordering fences, and lock-free synchronization and (3) can verify that the implementation behaves correctly for a given bounded test or will produce a counterexample trace if it does not.</p><p>Future work includes (1) enhancements to the front-end to support more C features and data type implementations from the literature, and (2) the use of SMT solvers and customized decision procedures to improve the efficiency of the back end. We are also working on applying our method to memory models that are weaker than Relaxed (such as the PowerPC model <ref type="bibr" target="#b14">[13]</ref>) or defined at the language level (such as the new Java Memory Model <ref type="bibr" target="#b30">[29]</ref>).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Black-box view of the CheckFence tool.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Schematic view of the components.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. The abstract syntax of LSL</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Representing C pointers in LSL.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .Figure 7 .</head><label>67</label><figDesc>Figure 6. Pseudocode for the compare-and-swap (CAS) operation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Queue tests:</head><label></label><figDesc>(e,d for enqueue, dequeue)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. C code for the non-blocking queue [33], with fences added. It is slightly simplified: the original code stores a counter along with each pointer, which we omit because it is not required in all contexts. No such modifications were made to the other algorithms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. (a) left: statistics about the inclusion checks. For a given implementation (listed in Table 1) and test (listed in Fig. 8), we show (from left to right): the size of the unrolled code, the time required to create the SAT instance, the size of the SAT instance, the resources required by the SAT solver to refute the SAT instance, and the overall time required. All measurements were taken on a 3 GHz Pentium 4 desktop PC with 1GB of RAM, using zchaff [35] version 2004/11/15. (b) right: charts show (on a logarithmic scale) how time and memory requirements increase sharply with the number of memory accesses in the unrolled code. The data points represent the individual tests, grouped by implementation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 .Figure 12 .</head><label>1112</label><figDesc>Figure 10. (a) left: statistics about the inclusion checks. For a given implementation (listed in Table 1) and test (listed in Fig. 8), we show (from left to right): the size of the unrolled code, the time required to create the SAT instance, the size of the SAT instance, the resources required by the SAT solver to refute the SAT instance, and the overall time required. All measurements were taken on a 3 GHz Pentium 4 desktop PC with 1GB of RAM, using zchaff [35] version 2004/11/15. (b) right: charts show (on a logarithmic scale) how time and memory requirements increase sharply with the number of memory accesses in the unrolled code. The data points represent the individual tests, grouped by implementation.</figDesc></figure>

			<note place="foot" n="1"> Many implementations pack structures into a single machine word with the intent of accessing the entire structure atomically (for example, using a compare-and-swap operation).</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Types for safe locking: Static race detection for Java</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Freund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="207" to="255" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Shared memory consistency models: a tutorial</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Gharachorloo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="66" to="76" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Threads cannot be implemented as a library</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-J</forename><surname>Boehm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming Language Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="261" to="268" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Bounded verification of concurrent data types on relaxed memory models: a case study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Burckhardt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer-Aided Verification (CAV)</title>
		<imprint>
			<biblScope unit="volume">4144</biblScope>
			<biblScope unit="page" from="489" to="502" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A tool for checking ANSI-C programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Lerda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools and Algorithms for the Construction and Analysis of Systems (TACAS)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004" />
			<biblScope unit="volume">2988</biblScope>
			<biblScope unit="page" from="168" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Formal verification of a lazy concurrent list-based set algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Colvin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Groves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Luchangco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Moir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer-Aided Verification (CAV)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="volume">4144</biblScope>
			<biblScope unit="page" from="475" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Compaq Computer Corporation. Alpha Architecture Reference Manual</title>
		<imprint>
			<date type="published" when="2002-01" />
		</imprint>
	</monogr>
	<note>4th edition</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Even better DCAS-based concurrent deques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Detlefs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Flood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Garthwaite</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shavit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Steele</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Distributed Computing (DISC)</title>
		<imprint>
			<date type="published" when="1914" />
			<biblScope unit="page" from="59" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Formal specification of abstract memory models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Nowatzyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Research on Integrated Systems</title>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="38" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">DCAS is not a silver bullet for nonblocking algorithm design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Doherty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Detlefs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Grove</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Flood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Luchangco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Moir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shavit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Steele</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Parallel Algorithms and Architectures (SPAA)</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="216" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Automatic fence insertion for shared memory multiprocessing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Midkiff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Supercomputing (ICS)</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="285" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Type-based race detection for Java</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Freund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming Language Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="219" to="232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">PowerPC Architecture Book v2.02. International Business Machines Corporation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Frey</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A formal reduction for lock-free parallel algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hesslink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer-Aided Verification (CAV)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004" />
			<biblScope unit="volume">3114</biblScope>
			<biblScope unit="page" from="44" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">QB or not QB: An efficient execution verification tool for memory orderings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gopalakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Sivaraj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer-Aided Verification (CAV)</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="volume">3114</biblScope>
			<biblScope unit="page" from="401" to="413" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A pragmatic implementation of non-blocking linked-lists</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Harris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Distributed Computing (DISC)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001" />
			<biblScope unit="volume">2180</biblScope>
			<biblScope unit="page" from="300" to="314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A practical multi-word compare-andswap operation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fraser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Pratt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Distributed Computing (DISC)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002" />
			<biblScope unit="volume">2508</biblScope>
			<biblScope unit="page" from="265" to="279" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A lazy concurrent list-based set algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Heller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Luchangco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Moir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Scherer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shavit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Distributed Systems (OPODIS)</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Race checking by context inference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming language design and implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Intel 64 and IA-32 Architectures Software Developer&apos;s Manual</title>
		<imprint>
			<date type="published" when="2006-11" />
			<biblScope unit="volume">3</biblScope>
		</imprint>
	</monogr>
	<note>Intel Corporation</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Intel Itanium Architecture Software Developer&apos;s Manual, Book 2, rev. 2.2</title>
		<imprint>
			<date type="published" when="2006-01" />
		</imprint>
	</monogr>
	<note>Intel Corporation</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Intel Corporation. Intel Threading Building Blocks</title>
		<imprint>
			<date type="published" when="2006-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">International Business Machines Corporation. z/Architecture Principles of Operation</title>
		<imprint>
			<date type="published" when="2000-12" />
		</imprint>
	</monogr>
	<note>first edition</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A simple sequential reasoning approach for sound modular verification of mainstream multithreaded programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Smans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Piessens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Schulte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TV&apos;06 Workshop, Federated Logic Conference (FLoC)</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="66" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">How to make a multiprocessor computer that correctly executes multiprocess programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comp., C</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="690" to="691" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Checking a multithreaded algorithm with + CAL</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Distributed Computing (DISC)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="volume">4167</biblScope>
			<biblScope unit="page" from="151" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">The java.util.concurrent synchronizer framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODC Workshop on Concurrency and Synchronization in Java Programs (CSJP)</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Personal communications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Luchangco</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">The Java memory model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Manson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Pugh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Programming Languages (POPL)</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="378" to="391" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Correctly implementing value prediction in microprocessors that support multithreading or multiprocessing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Sorin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Cain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lipasti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Microarchitecture (MICRO)</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="328" to="337" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Scalable lock-free dynamic memory allocation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Michael</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming Language Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="35" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Correction of a memory management method for lock-free data structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Scott</surname></persName>
		</author>
		<idno>TR599</idno>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
		<respStmt>
			<orgName>University of Rochester</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Simple, fast, and practical non-blocking and blocking concurrent queue algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Distributed Computing (PODC)</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="267" to="275" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Practical implementations of non-blocking synchronization primitives</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Moir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of distributed computing (PODC)</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="219" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Chaff: Engineering an efficient SAT solver</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Moskewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Madigan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="530" to="535" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Effective static race detection for Java</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Whaley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming Language Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="308" to="319" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">CIL: Intermediate language and tools for analysis and transformation of C programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mcpeak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rahul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conf. on Compiler Constr. (CC)</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">An executable specification, analyzer and verifier for RMO</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Parallel Algorithms and Architectures (SPAA)</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="34" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">LOCKSMITH: contextsensitive correlation analysis for race detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Pratikakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hicks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming Language Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="320" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Bounded model checking of concurrent programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Rabinovitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer-Aided Verification (CAV)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005" />
			<biblScope unit="volume">3576</biblScope>
			<biblScope unit="page" from="82" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Eraser: A dynamic data race detector for multithreaded programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Savage</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sobalvarro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comp. Sys</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="391" to="411" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Efficient and correct execution of parallel programs that share memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Shasha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Snir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="282" to="312" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Fast and lock-free concurrent priority queues for multi-thread systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Sundell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Tsigas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Parallel Distrib. Comput</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="609" to="627" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Software and the concurrency revolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Sutter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Larus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Queue</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="54" to="62" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">On the effectiveness of speculative and selective memory fences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Trachsel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Von Praun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Parallel and Distributed Processing Symposium (IPDPS)</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Proving correctness of highly-concurrent linearisable objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vafeiadis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Hoare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles and Practice of Parallel Programming (PPoPP)</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="129" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Conditional memory ordering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Von Praun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Cain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ryu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Computer Architecture (ISCA)</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">The SPARC Architecture Manual Version 9</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Weaver</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Germond</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">A serializability violation detector for shared-memory server programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bodik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming Language Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Automatically verifying concurrent queue algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Yahav</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electr. Notes Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">89</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Nemos: A framework for axiomatic and executable specifications of memory consistency models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gopalakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Slind</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Parallel and Distributed Processing Symposium (IPDPS)</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
