<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:51+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Note on First-order Logic and Security Protocols</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reynald</forename><surname>Affeldt</surname></persName>
							<email>reynald.affeldt@aist.go.jp</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Hubert Comon-Lundh Research Center for Information Security (RCIS)</orgName>
								<orgName type="institution" key="instit2">National Institute of Advanced Industrial Science and Technology (AIST)</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Note on First-order Logic and Security Protocols</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We make a simple observation on the relationship between two formalisms for security protocols. The first one is used for the verification of a bounded number of sessions and can be modeled in first-order logic with rigid variables. The second one is an approximation for the verification of an unbounded number of sessions and is typically used in ProVerif. We show that actually the bounded number of sessions case can be simply represented in a first-order logic setting, without introducing false attacks. This simple observation allows to translate results, which are obtained in one framework into results in the other framework.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>It is convenient and simple to model the security of cryptographic protocols within first-order logic. It is indeed possible then to use general purpose theorem provers such as SPASS (see first experiments for security protocols in <ref type="bibr" target="#b16">[17]</ref>). There are also successful verification tools such as ProVerif <ref type="bibr" target="#b3">[4]</ref>, which are based on first-order logic.</p><p>However, one drawback of such a formalization is that it requires some approximations. First, global properties such as freshness require a heavy encoding to be faithfully represented in firstorder logic (see e.g., <ref type="bibr" target="#b9">[10]</ref>), which is not amenable to further automation.</p><p>Second, pieces of messages that can be replaced with any message (since they cannot be analyzed by the recipient) are abstracted by variables. Such variables are naturally universally quantified in first-order logic. However, if an attacker can indeed replace these messages with an arbitrary forged message (hence a universal quantification), he should be allowed to do it only once for every variable. More precisely, the attacker can choose the substitution, but has to commit on this value. On the other hand, in a first-order logic formulation, since ∀x.φ(x) is equivalent to <ref type="bibr">(∀x.φ(x)</ref>) ∧ (∀y.φ(y)), the attacker may use two distinct substitutions for the same variable. Hence, in general, the attacker model in first-order logic corresponds to a stronger attacker than the real one. We will give concrete examples in Sect. 2.</p><p>It follows that attacks that are found in a first-order logic formulation of security might be false attacks. This has been well-known for a long time and it is the reason why several more accurate formalisms have been designed, for instance using MSR or linear logic <ref type="bibr" target="#b4">[5]</ref>.</p><p>Instead of proving security for an arbitrary number of sessions, much work focuses on finding an attack for a bounded number of sessions (e.g., <ref type="bibr" target="#b14">[15]</ref>). In this setting, there is no need for approximation: the insecurity problem can be translated into deducibility constraints, after guessing an interleaving of actions. Translating this approach in first-order logic is not straightforward, for the same reason as above: we must express that a variable, though universally quantified, can be instantiated only once.</p><p>A simple way to fix the problems and remove the false attacks due to universal quantification is to use rigid variables: while universally quantified, standard variables can be instantiated as many times as we wish, rigid variables get only one instance <ref type="bibr" target="#b2">[3]</ref>. This is exactly what we need for modeling security protocols. We need however one set of rigid variables for each session. Therefore, in practice, this can only be applied for a bounded number of sessions. This is exactly what is done in <ref type="bibr" target="#b12">[13]</ref>: the authors introduce rigid clauses to model the protocol rules when the number of sessions is fixed. Then they design a proof calculus for such clauses and show a termination result.</p><p>To the best of our knowledge, there is no formulation of the security problem for a bounded number of sessions within first-order logic, which avoids false attacks. This is what we do in the present note. Actually, we show that there is a simple translation of rigid variables in first-order logic, which preserves the satisfiability of formulas. It follows for instance that we can capture rigid-validity, hence security for a bounded number of sessions, within first-order logic. Then we can use first-order theorem provers for finding attacks in a bounded number of sessions, without generating false attacks. This can be useful, when trying to reconstruct attacks from candidate attacks found by a theorem prover: this is a simple alternative to <ref type="bibr" target="#b1">[2]</ref>. It can also be used to search simultaneously, with the same tool, for attacks and proofs.</p><p>Using this simple translation of rigid variables in first-order logic, we may considerably simplify the proof rules for rigid clauses of <ref type="bibr" target="#b12">[13]</ref>. We can also extend the calculus, allowing for clauses mixing rigid and non-rigid variables as well as equalities (however only flexible variables are allowed in equalities). Finally, we can translate back and forth results from first-order logic to first-order logic with rigid variables. For instance, from <ref type="bibr" target="#b8">[9]</ref>, we derive a decision result for a bounded number of sessions for protocols including exclusive-or. The other way around, from the decision results on security protocols for a bounded number of sessions, we derive decision results (in co-NP) for fragments of first-order logic.</p><p>We recall some protocol models in Sect. 2, through examples. In Sect. 3, we show the simple translation from rigid clauses to first-order clauses. In Sect. 4 we sketch some possible applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">First-order Models of Protocols</head><p>We give the main ideas about first-order models of protocols (see e.g., <ref type="bibr" target="#b3">[4]</ref> for further details) and examples to illustrate false attacks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">A Standard Model</head><p>Let I be a predicate symbol that captures the intruder's knowledge. The attacker capabilities are described by a set of Horn clauses:</p><formula xml:id="formula_0">(I0) I(x), I(y) → I(x, y) (I1) I(x, y) → I(x) (I2) I(x), I(y) → I([x] y ) (I3) I([x] y ), I(y) → I(x) (I4) → I(pk(x)) (I5) I(x), I(pk(y)) → I({x} pk(y) ) (I6) I({x} pk(y) ), I(y) → I(x) · · ·</formula><p>The function symbol pk represents the public key corresponding to some private key. Public-key encryption and symmetric encryption are respectively represented by {·} · and [·] · . The pairing function ·, · will sometimes be omitted or considered as variadic to ease reading. The rules (I1), (I6), etc. can also be replaced with explicit destructors</p><formula xml:id="formula_1">(I1 ′ ) I(x) → I(π 1 (x)) (I6 ′ ) I(x), I(y) → I(pdec(x, y)) · · ·</formula><p>together with equations π 1 (x, y) = x, pdec({x} pk(y) , y) = x, etc. We will use either of the two formalisms without mention.</p><p>Protocol clauses are modeled considering the protocol as an oracle used by the attacker. Freshness is approximated using a function symbol, which depends on the terms seen at this stage. The following sections illustrate this with examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">An Example of False Attack</head><p>Let us consider a protocol from <ref type="bibr" target="#b6">[7]</ref>, which we write first in the (somewhat ambiguous) Alice-andBob notation:</p><formula xml:id="formula_2">A → B : {pk A , N } pkB B → A : {N, K} pkA A → B : [S] K B → A : N</formula><p>and, more formally, in an extended π-calculus notation (as described e.g., in <ref type="bibr" target="#b0">[1]</ref>):</p><formula xml:id="formula_3">P A (pk A , sk A , pk B ) def = c(x pkB ).νs.νN.c{pk A , N } x pk B . c(x nk ).let (non, k) = pdec(x nk , sk A ) in if non = N then if x pkB = pk B then c[s] k P B (sk B ) def = c(x m ).let (pka, non) = pdec(x m , sk B ) in νk.c{non, k)} pka . c(x sk ).let s = sdec(x sk , k) in cnon P 0 def = !(νsk A .let pk A = pk(sk A ) in cpk A .νsk B .let pk B = pk(sk B ) in cpk B . !P A (pk A , sk A , pk B ) | !P B (sk B )) | !(νsk A .let pk A = pk(sk A ) in cpk A .csk A .νsk B .let pk B = pk(sk B ) in cpk B .csk B . !P A (pk A , sk A , pk B ) | !P B (sk B ))</formula><p>The security property (which we do not display here) states that any secret s generated by an honest identity A for an honest identity B (given as the first input in the process P A ) is never disclosed.</p><p>In first-order logic, the protocol is modeled as</p><formula xml:id="formula_4">(∆1) I(pk(x)), I(pk(y)) → I({pk(x), N (x, y)} pk(y) ) (∆2) I({x, y} pk(z) ) → I({y, K(x, y, z)} x ) (∆3) I({N (x, y), z} pk(x) ) → I([S(x, y, z)] z ) (∆4) I({w} K(x,y,z) ) → I(y)</formula><p>We avoid here the explicit destructors, while they are used in the process description, for readability reasons. (See appendix A for a ProVerif encoding.) Basically, the intruder uses the protocol as an oracle: for each protocol rule, if the intruder can construct a message matching the expected pattern, then it gets the corresponding reply message. For example, the clause (∆1) represents the first action of process P A (session initialization), the clause (∆2) represents the first action of process P B (upon reception from A of {x, y} pk(skB ) which is supposed to be {pk(sk A ), N } pk(skB ) the reply of B is the message {y, K} x ), etc.</p><p>Finally, the security property can be modeled as ¬I(S(sk A , sk B , z)) and I(sk C ) where C is a constant representing a corrupted identity. If the protocol is insecure, then the set of clauses is unsatisfiable: there is a derivation of I(S(sk A , sk B , t)) for some t.</p><p>In the clauses above, the freshness of generated data N , K, and S is abstracted using universally quantified variables. This may be a cause of false attacks as, for instance, every session between A and B will use the same representation of N . For a bounded number of sessions, this problem does not occur as different symbols can be used for nonces occurring in different sessions.</p><p>There are however other sources of false attacks. In the above example, the protocol is (supposedly) secure, while there is a simple derivation of the empty clause: from a honest session of the protocol (i.e., using clauses (∆1) to (∆4) once), we derive I <ref type="figure">(N (x, y)</ref>). Now, for any z such that I(z) we derive I <ref type="figure">({N (x, y)</ref>, z} pk(x) ) using the intruder capabilities. Next, using clause (∆3) we get I( <ref type="bibr">[S]</ref> z ) and, from this clause and I(z), we derive I(S) by decrypting.</p><p>The problem here is that the nonce is first kept secret but eventually revealed. A first-order model leads to a false attack by wrongly inferring that the intruder could have the nonce at an early stage: when the nonce N is revealed, the rule (∆3) is replayed and the intruder gets back <ref type="bibr">[S]</ref> K ′ for a key K ′ of his choice, which he can decrypt. This cannot occur in the process model, as the agents would have moved forward their internal state, preventing the replay of rule (∆3). This kind of problem occurs even for a single session, as shown by the example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Trying to Refine the Model: there are still False Attacks</head><p>The false attack above comes from the ability (in the model) to play again a rule of the protocol after completing it. One may think that this can be fixed by adding some state information at each step of the protocol. While this is quite difficult for an unbounded number of sessions, there is an easy (though expensive) encoding for a bounded number of sessions.</p><p>First, we can get rid of freshness encoding by simply modeling nonces with distinct constants. It is also possible (though expensive; we will avoid this in the encoding of next section), to guess an interleaving of actions and use a different predicate symbol at each step: instead of a single predicate symbol I, we could use symbols I 0 , . . . , I n representing the intruder knowledge after n steps. Then the protocol clauses increase the index of the predicate:</p><formula xml:id="formula_5">I k (t) → I k+1 (u) for k = 0, . . . , n − 1</formula><p>for a rule stating that, at stage k, upon receiving an instance of t, the agent sends the corresponding instance of u. The security is stated as ¬I n (s) where s is the supposed secret. And we have to add the clauses expressing the increasingness of the intruder knowledge:</p><formula xml:id="formula_6">I k (x) → I k+1 (x) for k = 0, . . . , n − 1</formula><p>Finally, clauses reflecting intruder capabilities are replicated n times with the indices 1, . . . , n.</p><p>With such an encoding, the above false attack can be prevented. However, this is not sufficient in general. Here is an (cook-up) example showing again a false attack in this new setting:</p><formula xml:id="formula_7">Example 2.1 A → B : [A, N 0 ] KAB B → A : [B, N 0 , N 1 ] KAB , [B, N 0 , N 2 ] KAB A → B : N 1</formula><p>A, relying on a long term shared secret K AB , wants to establish a short term secret key. B generates two nonces N 1 , N 2 and sends them separately. A acknowledges both nonces by sending back one of them. The new short-term secret is N 1 ⊕ N 2 .</p><p>In a single-session model, there is no attack: the intruder can get either N 1 or N 2 , but not both. However, in a clausal formulation as explained above, we would have two clauses:</p><formula xml:id="formula_8">I 1 ([A, x] KAB ) → I 2 ([B, x, N 1 ] KAB , [B, x, N 2 ] KAB ) I 2 ([B, N 0 , x] KAB , [B, N 0 , y] KAB ) → I 3 (x) From I 2 ([B, x, N 1 ] KAB , [B, x, N 2 ] KAB ) we infer I 2 ([B, x, N 2 ] KAB , [B, x, N 1 ] KAB ).</formula><p>Then using two instances of the second clause, we get immediately I 3 (N 1 ) and I 3 (N 2 ), hence the secret. This is however a false attack: the last rule should not be played twice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Rigid Clauses vs. Classical Clauses</head><p>The best way to prevent the last false attack is to use rigid variables. Encoding a bounded number of sessions does not require then to introduce new predicate symbols, nor to guess the interleaving of messages.</p><p>Let us first introduce the less standard rigid variables and rigid clauses and then show how to get rid of them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Rigid Clauses</head><p>Let F and P be resp. a set of function symbols and a set of predicate symbols with their arities.</p><p>We use the classical vocabulary of first-order logic. To fix notations, if S is a first-order structure and P is a predicate symbol, <ref type="bibr">[[P ]]</ref> S is the interpretation of P in S. Formulas are clauses whose variables are either rigid (written in upper-case) or flexible (written in lower-case). Both types of variables are universally quantified, but rigid variables can only get one instance.</p><p>Example 3.1 Consider the following set of clauses (taken from <ref type="bibr" target="#b12">[13]</ref>):</p><formula xml:id="formula_9">{I(a), I(b), ¬I(X) ∨ I(f (X)), ¬I(f (a)) ∨ ¬I(f (b))}</formula><p>If X was considered as an ordinary first-order variable, this set of clauses would be unsatisfiable: from the three first clauses we can infer both I(f (a)) and I(f (b)). The derivation of an empty clause however requires two instances of the third clause, which is forbidden for rigid variables. We can choose the instance X = a or the instance X = b, but not both.</p><p>The above set clauses is satisfiable in our intended interpretation of rigid variables since both sets of ground clauses</p><formula xml:id="formula_10">{I(a), I(b), ¬I(a) ∨ I(f (a)), ¬I(f (a)) ∨ ¬I(f (b))} and {I(a), I(b), ¬I(b) ∨ I(f (b)), ¬I(f (a)) ∨ ¬I(f (b))} are satisfiable.</formula><p>The next example shows that resolution procedures cannot be easily extended to clauses containing rigid variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 3.2 Consider the following set of clauses:</head><p>{I(X), ¬I(f (x)) ∨ I 0 , ¬I(g(x))} It is unsatisfiable: the first and the third clauses resolve to the empty clause. Consider however that we start by resolving the two first clauses. This yields the new set of clauses</p><formula xml:id="formula_11">{I(f (Y )), I 0 , ¬I(f (x)) ∨ I 0 , ¬I(g(x))}</formula><p>where Y is a new rigid variable resulting from the unification X ? = f (x). We can still choose Y , but we committed to an assignment of X to a term headed with f . Now the set of clauses is satisfiable.</p><p>For a complete resolution procedure, we would have to restart from the beginning, with another choice of clauses to resolve.</p><p>The last example shows that, unlike classical first-order clauses, resolution does not yield a logically equivalent set of clauses. Therefore, resolution theorem proving would have to be reconsidered; this is the reason for complications in <ref type="bibr" target="#b12">[13]</ref>.</p><p>Let us now formalize the model-theoretic part of such calculi. Let S be an F, P-structure whose underlying F-algebra is A. Let C be a set of clauses whose free variables are split into X (rigid free variables) and y (flexible free variables). If σ is an assignment of X in A, we have S, σ |= ∀y.C defined as usual in first-order logic.</p><p>Definition 1 Let C be a set of clauses whose free variables are split into X (rigid free variables) and y (flexible free variables).</p><p>C is satisfiable if there is a F-algebra A such that, for any A-assignment σ of X, there is a structure S whose underlying algebra is A such that S, σ |= ∀y.C.</p><p>In other words, models of formulas with rigid variables are collections of structures, one for each assignment of the rigid variables.</p><p>Example 3.3 On example 3.1, for any of the two assignments X → a and X → b there is a model: {I(a), I(b), I(f (a)), ¬I(f (b))} in the first case and {I(a), I(b), I(f (b)), ¬I(f (a))} in the second case.</p><p>Example 3.4 The one session case of Example 2.1 can be translated into the following rigid clauses (keeping the intruder rules with flexible variables):</p><formula xml:id="formula_12">→ I([A, N 0 ] KAB ) I([A, X] KAB ) → I([B, X, N 1 ] KAB , [B, X, N 2 ] KAB ) I([B, N 0 , Y ] KAB , [B, N 0 , Z] KAB ) → I(Y )</formula><p>Which, together with ¬I <ref type="figure">(N 1 , N 2 )</ref> is satisfiable. In contrast, if the above variables are considered as flexible, it is unsatisfiable (yielding a false attack, as in Example 2.1).</p><p>There are also some traps, for instance,</p><formula xml:id="formula_13">∀x.φ(x) ∧ ψ(x) |=| ∀x, y.φ(x) ∧ ψ(y) while ∀X.φ(X) ∧ ψ(X) |= ∀X, Y.φ(X) ∧ ψ(Y )</formula><p>, as shown by the following example.</p><p>Example 3.5 Consider φ(X) = ψ(X) = P (X) ∧ (¬P (a) ∨ ¬P (b)). On the one hand, ∀X.φ(X) ∧ ψ(X) is satisfiable. Consider the algebra with two constants a and b. For the assignment X → a (resp. X → b), the structure S such that P (a) holds (resp.</p><formula xml:id="formula_14">P (b) holds) satisfies φ(a) ∧ ψ(a) (resp. φ(b) ∧ ψ(b)). On the other hand, ∀X, Y.φ(X) ∧ ψ(Y )</formula><p>is not satisfiable. Consider any algebra containing the constants a and b. For the assignment X → a; Y → b, there cannot be any structure that satisfies φ(a) ∧ ψ(b).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Translation of Rigid Clauses into First-order Clauses</head><p>As shown in the Examples 3.2 and 3.4, (dis)proving might be a difficult task when there are rigid variables. There is however a simple observation, yielding a transformation of rigid clauses into flexible ones: as can be seen from the definition of satisfiability, the interpretation of predicates depends on the assignment of rigid variables. Hence, a simple Skolemization argument suffices to eliminate this dependence and leads back to first-order clauses:</p><p>Theorem 2 For any finite set of clauses C there is an effectively computable set of clauses C ′ , which does not contain any rigid variable, and such that C is satisfiable iff C ′ is satisfiable.</p><p>Proof: C ′ is constructed from C as follows. If X 1 , . . . , X n are the rigid variables of C, for each P ∈ P of arity m we let P ′ be a predicate symbol of arity n + m.</p><formula xml:id="formula_15">If ¬P 1 (s 1 ) ∨ · · · ∨ ¬P n1 (s n1 ) ∨ Q 1 (t 1 ) ∨ · · · ∨ Q n2 (t n2 ) ∈ C we let ¬P ′ 1 (x 1 , . . . , x n , s ′ 1 ) ∨ · · · ∨ ¬P ′ n1 (x 1 , . . . , x n , s ′ n1 ) ∨ Q ′ 1 (x 1 , . . . , x n , t ′ 1 ) ∨ · · · ∨ Q ′ n2 (x 1 , . . . , x n , t ′ n2 )</formula><p>be a clause C ′ ∈ C ′ where x 1 , . . . , x n are distinct variables, which do not occur free in the clause C and s ′ 1 , . . . , s ′ n1 , t ′ 1 , . . . , t ′ n2 are the terms obtained from their unprimed version by replacing each X i with the corresponding x i . If C is satisfiable, then there is an F-algebra A such that, for any A-assignment σ of X 1 , . . . , X n there is a structure S σ such that, for every clause C ∈ C, we have S σ , σ |= ∀y.C. Consider then the structure S ′ (whose underlying algebra is A) such that (a 1 , . . . , a n ,</p><formula xml:id="formula_16">b 1 , . . . , b m ) ∈ [[P ′ ]] S ′ iff (b 1 , . . . , b m ) ∈ [[P ]] S {X 1 →a 1 ;...</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>;Xn →an}</head><p>For any clause C of C, we claim that S ′ |= ∀x, y.C ′ : for any assignment σ ′ of the variables x 1 , . . . , x n respectively and for any assignment θ of the other variables y of the clause, we let σ be the assignment of the rigid variables defined by σ(X i ) = σ ′ (x i ) for every i. By hypothesis, S σ , θ, σ |= C. It follows that, for some literal L ∈ C, S σ , θ, σ |= L. Assume for instance that L is a positive literal (the other case is similar):</p><formula xml:id="formula_17">L = P (u 1 , . . . , u m ) and ([[u 1 ]] θ,σ,A , . . . , [[u m ]] θ,σ,A ) ∈ [[P ]]</formula><p>Sσ . This is equivalent, by definition, to (a 1 , . . . , a n ,</p><formula xml:id="formula_18">[[u 1 ]] θ,σ,A , . . . , [[u m ]] θ,σ,A ) ∈ [[P ′ ]] S ′</formula><p>which, again by construction, yields</p><formula xml:id="formula_19">S ′ , σ ′ , θ |= C ′</formula><p>Conversely, if C ′ is satisfiable, then let S ′ be a structure which satisfies all clauses of C ′ . Consider an arbitrary assignment σ of rigid variables occurring in C. We let S σ be the structure defined by</p><formula xml:id="formula_20">[[P ]] Sσ = {(b 1 , . . . , b m ) | (X 1 σ, . . . , X n σ, b 1 , . . . , b m ) ∈ [[P ′ ]] S ′ } As before, S σ , σ |= ∀y.C iff S ′ |= ∀x, y.C ′ .</formula><p>This extends to clauses with equality, provided that every equality clause does not contain any rigid variable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Examples of Possible Applications</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Automatic Proofs for a Bounded Number of Sessions</head><p>Thanks to the effective procedure given in the proof of Theorem 2, we can use resolution for mechanizing proofs in a bounded number of sessions. We believe that the resulting procedure is simpler, both conceptually and from the complexity point of view, than the one given in <ref type="bibr" target="#b12">[13]</ref>. In addition, it works as well if we have clauses mixing rigid and flexible variables and also if we have (flexible) equations. Though, in the latter case, there is no guarantee for termination.</p><p>Example 4.1 Let us come back to Example 3.4. We translate now the rigid clauses into first-order clauses:</p><formula xml:id="formula_21">→ I(x, y, z, [A, N 0 ] KAB ) I(x, y, z, [A, x] KAB ) → I(x, y, z, [B, x, N 1 ] KAB , [B, x, N 2 ] KAB ) I(x, y, z, [B, N 0 , y] KAB , [B, N 0 , z] KAB ) → I(x, y, z, y) I(x, y, z, N 1 , N 2 ) →</formula><p>Using an appropriate strategy (see next section), resolution terminates in a few steps, yielding in particular the literals I(N 0 , N 1 , N 2 , N 1 ) and I(N 0 , N 2 , N 1 , N 2 ) (which, without the three first components, were used to mount a false attack). On the other side, the goal is decomposed into ¬I(x, y, z, N 1 ) ∨ ¬I(x, y, z, N 2 ) and leads, using the two inferred literals, to clauses ¬I(N 0 , N 2 , N 1 , N 1 ) and ¬I(N 0 , N 1 , N 2 , N 2 ). But the empty clause does not belong to the saturated set: there is no one-session attack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Decidable Fragments of First-order Logic</head><p>Concerning termination, the delicate problem is the design of appropriate strategies, which we do not address thoroughly in this note.</p><p>If we translate back in terms of strategies the constraint solving techniques used for the decidability and complexity proofs for a bounded number of sessions (see <ref type="bibr" target="#b7">[8]</ref>), we will get a decision result for formulas in the following clausal form 1 : Theorem 3 Let f be a function symbol. Assume that all clauses are of one of the following forms:</p><p>1. I z (x, y 0 ) , . . . , I z (x, y n−1 ) → I z (x, f (y 0 , . . . , y n−1 )) with x, y, z pairwise disjoint 2. I z[i←k] (x, s) → I z[i←k+1] (x, t) with Var(t) ⊆ Var(s) ⊆ x and x ∩ z = ∅ 3. I z (x, t) with Var (t) ⊆ x and x ∩ z = ∅ 4. ¬ I z (x, s) with Var (s) ⊆ x and x ∩ z = ∅ where z <ref type="bibr">[i←k]</ref> represents the variable-vector z whose i th element is replaced by k. Then the satisfiability modulo the axioms of encryption/decryption (resp. satisfiability modulo exclusive-or <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b10">11]</ref>, resp. satisfiability modulo Abelian groups <ref type="bibr" target="#b15">[16]</ref>) is co-NP-complete.</p><p>This shows a new decidable fragment of first-order logic. It is related to both the extended Skolem class and the E + class <ref type="bibr" target="#b13">[14]</ref>, but it is not subsumed by any of the two classes. So, as a perspective, if we manage to characterize the appropriate strategy, out of the previous theorem, we could get a new non-trivial decidable class of first-order logic.</p><p>In the case of the axioms of encryption/decryption, the strategy consisting in binary resolution with the free selection defined just below and deletion of redundant clauses is complete and terminating. The free selection function in question is defined as follows. Consider a wellfounded, liftable ordering containing the subterm ordering. For any Horn clause of the form I u 0 (s 0 , t 0 ) , . . . , I u n−1 (s n−1 , t n−1 ) → I u n (s n , t n ):</p><p>• If there is only one maximal literal, then return the corresponding atom.</p><p>• Otherwise, if there is a maximal, negative literal where t i is not a variable, then return the corresponding atom.</p><p>• Otherwise, if the positive literal is maximal and t n is not a variable, then return it.</p><p>• Otherwise, return any atom.</p><p>Of course, known decidable fragments of first-order logic (e.g., the one defined in <ref type="bibr" target="#b8">[9]</ref>) can be used to infer decision algorithms for a bounded number of sessions. But this is less likely to give interesting results as it will impose necessary restrictions on the protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Enhancing First-order Provers for Security Protocols</head><p>Another possible use of the translation given in Theorem 2 is to combine in a single first-order theorem prover the advantages of the approximations and of the bounded number of sessions: using the same engine and specification it is possible to look first for attacks/safety in an exact way for a given number of sessions and then use an approximation for more sessions. Alternatively, in case a candidate attack is found, we could simply check the falsity of the attack using additional clauses.</p></div>
			<note place="foot" n="1"> The part of I&apos;s arguments that model rules ordering is put in subscript position to ease reading.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>We do not claim to contribute here by a deep or difficult result. We believe however that our simple observation is useful for encoding the problem of security for a bounded number of sessions into a first-order clausal form.</p><p>This opens also some perspectives in automated deduction: there is a hidden strategy, which yields a decidable fragment of first-order logic and deserves some attention.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A A False Attack in ProVerif</head><p>Here follows a formalization in ProVerif of the first protocol of Sect. 2.2 whose verification yields a false attack. The clauses rule 1, rule 2, etc. below correspond respectively to the clauses (∆1), (∆2), etc. in Sect. 2.2. With respect to Sect. 2.2, the ProVerif encoding makes some sound simplifications, which are not explained here. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Analyzing Security Protocols with Secrecy Types and Logic Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Blanchet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="102" to="146" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Reconstruction of Attacks against Cryptographic Protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Allamigeon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Blanchet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">18th IEEE Computer Security Foundations Workshop</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="140" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Theorem proving via general matings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">B</forename><surname>Andrews</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="193" to="214" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An Efficient Cryptographic Protocol Verifier Based on Prolog Rules</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Blanchet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th IEEE Computer Security Foundations Workshop</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="82" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A meta-notation for protocol analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Cervesato</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">A</forename><surname>Durgin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">D</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Scedrov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th IEEE Computer Security Foundations Workshop</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An NP decision procedure for protocol insecurity with XOR</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chevalier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Küsters</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rusinowitch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Turuani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">18th IEEE Symp. on Logic in Computer Science (LICS 2003)</title>
		<imprint>
			<biblScope unit="page" from="261" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Combined CPV-TLV Security Protocol Verifier</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Cohen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
		<respStmt>
			<orgName>New York University</orgName>
		</respStmt>
	</monogr>
	<note>Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Résolution de contraintes et recherche d&apos;attaque pour un nombre borné de sessions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Comon-Lundh</surname></persName>
		</author>
		<ptr target="http://www.lsv.ens-cachan.fr/∼comon/CRYPTO/bounded.ps" />
	</analytic>
	<monogr>
		<title level="j">Lecture notes</title>
		<imprint>
			<date type="published" when="2004-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">New decidability results for fragments of first-order logic and application to cryptographic protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Comon-Lundh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Cortier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th Int. Conf. on Rewriting Techniques and Applications (RTA 2003)</title>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">2706</biblScope>
			<biblScope unit="page" from="148" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Security properties: two agents are sufficient</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Comon-Lundh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Cortier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="51" to="71" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Intruder deductions, constraint solving and insecurity decision in presence of exclusive or</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Comon-Lundh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Shmatikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">18th IEEE Symp. on Logic in Computer Science (LICS 2003)</title>
		<imprint>
			<biblScope unit="page">271</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A resolution strategy for verifying cryptographic protocols with cbc encryption and blind signatures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Cortier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rusinowitch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Zalinescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">7th Int. ACM SIGPLAN Conf. on Principles and Practice of Declarative Programming</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="12" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Protocol verification via rigid/flexible resolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Delaune</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lynch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th Int. Conf. on Logic for Programming</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007" />
			<biblScope unit="volume">4790</biblScope>
			<biblScope unit="page" from="242" to="256" />
		</imprint>
	</monogr>
	<note>Artificial Intelligence, and Reasoning</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Resolution decision procedure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">G</forename><surname>Fermüller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Leitsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Hustadt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Tamet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Automated Reasoning</title>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Protocol insecurity with a finite number of sessions, composed keys is NP-complete</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rusinowitch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Turuani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="issue">299</biblScope>
			<biblScope unit="page" from="451" to="475" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Decidable analysis of cryptographic protocols with products and modular exponentiation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Shmatikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th European Symp. on Programming</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004" />
			<biblScope unit="volume">2986</biblScope>
			<biblScope unit="page" from="355" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Towards an automatic analysis of security protocols in first-order logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Weidenbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16th Conference on Automated Deduction</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999" />
			<biblScope unit="volume">1632</biblScope>
			<biblScope unit="page" from="314" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">* the attacker *) I:x &amp; I:y -&gt; I:senc</title>
		<imprint>
			<pubPlace>x,y</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">I:x &amp; I:senc(y, x) -&gt; I:y</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">I:pk(x)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">I:y &amp; I:penc(x, pk(y)) -&gt; I:x</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">*) I:senc(w, k[x, y, z]) -&gt; I:y ; (* rule 4 *) I:penc((N[x,y], z), pk(x)) -&gt; I:senc</title>
		<imprint/>
	</monogr>
	<note>S[x,y,z], z)</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">rule 3 *) I:penc((x, y), pk(z)) -&gt; I:penc</title>
		<imprint>
			<pubPlace>y, k[x,y,z]), x)</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">rule 2 *) I:pk(x) &amp; I:pk(y) -&gt; I:penc((pk(x)</title>
		<imprint/>
	</monogr>
	<note>N[x,y]), pk(y)) . (* rule 1 *</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
