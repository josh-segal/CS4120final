<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:56+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Quantier Elimination via Functional Composition</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jie-Hong</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
							<email>jhjiang@cc.ee.ntu.edu.tw</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering / Graduate Institute of Electronics Engineering</orgName>
								<orgName type="institution">National Taiwan University</orgName>
								<address>
									<postCode>10617</postCode>
									<settlement>Taipei</settlement>
									<country key="TW">Taiwan</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Quantier Elimination via Functional Composition</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>This paper poses the following basic question: Given a quan-tied Boolean formula ∃x.ϕ, what should a function/formula f be such that substituting f for x in ϕ yields a logically equivalent quantier-free formula? Its answer leads to a solution to quantier elimination in the Boolean domain, alternative to the conventional approach based on formula expansion. Such a composite function can be eectively derived using symbolic techniques and further simplied for practical applications. In particular, we explore Craig interpolation for scalable computation. This compositional approach to quantier elimination is analyzably superior to the conventional one under certain practical assumptions. Experiments demonstrate the scalability of the approach. Several large problem instances unsolvable before can now be resolved eectively. A generalization to rst-order logic characterizes a composite function&apos;s complete exibility, which awaits further exploitation to simplify quan-tier elimination beyond the propositional case.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Quantier elimination is a way of transforming a formula with quantiers to an equivalent one without quantiers. Eliminating quantied variables often yields desirable reduction of some sort, and applies to constraint solving, e.g., Gauss elimination for solving systems of linear equations, Fourier-Motzkin elimination for systems of linear inequalities, cylindrical algebraic decomposition <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b1">2]</ref> for systems of polynomial inequalities, and so on. It plays important roles in computation theory, mathematical logic, mathematical programming, scientic computing, and other elds. Its applications are pervasive and profound. This paper is concerned about quantier elimination in propositional logic as well as rst-order logic.</p><p>Quantier elimination in propositional logic augmented with quantiers over propositional variables is a well-studied subject. There are several approaches to this problem: Formula expansion. A conventional approach to quantier elimination is based on formula expansion, ∃x.ϕ = ϕ[x/0] ∨ ϕ <ref type="bibr">[x/1]</ref>, where formula ϕ is expanded under all truth assignments on x by substituting 0 and 1 for x in ϕ. Binary decision diagrams (BDDs), and-inverter graphs (AIGs), and other data structures for Boolean function representation and manipulation can be adopted for the computation. BDDs tended to be a popular approach to such computation, the so-called image computation <ref type="bibr" target="#b2">[3]</ref>. BDD-based computation however has its intrinsic memory-explosion limitation. On the other hand, recent progress in AIG packages <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b12">13]</ref> has made AIG-based quantication a viable alternative to BDD-based one. For example, AIGs have been directly used in unbounded model checking <ref type="bibr" target="#b16">[17]</ref>. Our approach to quantier elimination also uses AIGs extensively.</p><p>Normal-form conversion. Eliminating the existential (respectively universal) quantier of formula ∃x.ϕ (respectively ∀x.ϕ) is easy 1 when ϕ is in disjunctive normal form (DNF) (respectively conjunctive normal form (CNF)). Thereby the normal-form conversion between CNF and DNF can be exploited for quantier elimination, as was suggested in <ref type="bibr" target="#b14">[15]</ref> in application to unbounded model checking.</p><p>Satisability solving. Using a decision procedure, the quantier-free equivalent of ∃x.ϕ can be generated by searching through all satisfying assignments to the non-quantied variables. By collecting these satisfying assignments, one can construct an equivalent quantier-free formula. A detailed exposition of this method can be found, e.g., in <ref type="bibr" target="#b6">[7]</ref> and the references therein.</p><p>Despite these existing approaches, there is not a single best one to quantier elimination for all problem instances. Dierent approaches may have their own strengths and weaknesses. This paper adds to the above list a new item, a compositional approach to quantier elimination, which is by nature closer to the formula-expansion approach. We ask, given a quantied Boolean formula ∃x.ϕ, what should a function/formula f be such that substituting f for x in ϕ, denoted as ϕ[x/f ], yields a logically equivalent quantier-free formula. This paper characterizes the complete exibility of such a composite function f . Furthermore, an eective and scalable derivation of f with reasonable quality is proposed using Craig interpolation. An analysis shows that, under the sparsity assumption of ϕ (which is common in certain practical applications), the new compositional approach is superior to the conventional one based on formula expansion. Practical experience suggests that the new approach often yields much more compact AIGs than the conventional one when the sparsity condition holds. Several problem instances that suer from exponential blow-up by formula expansion are eectively resolvable by functional composition.</p><p>Quantier elimination in rst-order logic is much more complicated and relatively less explored. In fact, exhaustive formula expansion does not work in rst-order logic as variables can take on innite values. Moreover, not every 1 When ϕ is in DNF and CNF, respectively, removing every appearance of literals x, ¬x and the so-induced illegal logic connectives from ϕ yields a quantier-free equivalent of ∃x.ϕ and ∀x.ϕ, respectively. So the computation is achievable in linear time and the size of the resultant quantier-free formula is non-increasing compared to that of ϕ. rst-order theory allows quantier elimination. One of the earliest attempts at quantier elimination in rst-order logic is Tarski's work <ref type="bibr" target="#b20">[21]</ref>, where the rst quantier-elimination procedure of real closed elds was demonstrated. Since then, algorithmic improvements have been achieved, see, e.g., <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b1">2]</ref>. Also quantier elimination has been shown possible in other rst-order theories, such as term algebras, Presburger arithmetic, and other theories <ref type="bibr" target="#b19">[20]</ref>.</p><p>Extending the results of propositional logic, this paper characterizes the complete exibility of composite functions for quantier elimination in rst-order logic. Unlike most prior eorts, which gave concrete quantier-elimination procedures for some specic theories, we rather present a generic viewpoint and show the potential usefulness of the complete exibility in simplifying quantier elimination.</p><p>One of the common practices to quantier elimination of rst-order theories is based on the principle of virtual substitution with elimination sets <ref type="bibr" target="#b22">[23]</ref>. To eliminate a quantier, a nite set of solution terms with their validity conditions is identied for substitution. Our characterized complete exibility may be exploited to reduce elimination sets.</p><p>This paper is organized as follows. After preliminaries are given in Section 2, Section 3 presents the main results on quantier elimination in propositional logic. Section 4 extends the results to rst-order logic. Experimental results and discussions are given in Section 5. Section 6 compares our results with some related work. Finally, Section 7 concludes this paper and outlines future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>Predicate logic. We closely follow the denitions and notation of <ref type="bibr" target="#b5">[6]</ref> about rst-order logic. A rst-order language may consist of logical symbols (including parentheses, sentential connectives, variables, and the (optional) equality symbol) and parameters (including quantier symbols, constant symbols, predicate symbols, and function symbols). Given a language, terms are nite expressions representing names of objects, whereas (well-formed) formulas are nite expressions representing assertions about objects. Given a formula, variables not in the scope of any quantier are called free variables, otherwise bound variables. Formulas without free variables are called sentences.</p><p>As a notational convention, substituting a term t for some variable x in a formula ϕ is denoted as ϕ <ref type="bibr">[x/t]</ref>. We say that t is substitutable for x in ϕ if every variable y in t is not captured by some quantier ∀y or ∃y in ϕ. Substitutability can be achieved through proper renaming of bound variables. By writing ϕ[x/t], this paper assumes that t is substitutable for x in ϕ.</p><p>A structure (or called an interpretation) A of some rst-order language L is a tuple specifying the domain (or universe), denoted |A|, of the variables, and associating the constant, predicate, and function symbols with meanings. A sentence σ of L is true in structure A is denoted as |= A σ.</p><p>Propositional logic can be seen as a special case of rst-order logic, where functions and predicates are interchangeable, so are terms and formulas. Also there is a unique structure B with |B| = {0, 1}. In propositional logic, the positive and negative cofactors of formula ϕ with respect to variable x are ϕ <ref type="bibr">[x/1]</ref> and ϕ[x/0], respectively.</p><p>Propositional satisability and Craig interpolation. A brief introduction to SAT solving and circuit-to-CNF conversion, essential to our development, can be found in <ref type="bibr" target="#b15">[16]</ref>. To introduce terminology and convention for later use, we restate the following theorem.</p><p>Theorem 1 (Craig Interpolation Theorem). <ref type="bibr">[</ref> The Boolean formula ψ A is referred to as the interpolant of φ A with respect to φ B . Modern SAT solvers can be extended to construct interpolants from resolution refutations <ref type="bibr" target="#b15">[16]</ref>. In the sequel, we shall assume that Boolean functions, circuits, and interpolants are represented using AIGs, which can be converted to CNF formulas in polynomial time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Propositional Logic</head><p>In this section we consider quantier elimination of propositional logic augmented with quantiers over propositional variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Composability for Quantier Elimination</head><p>Putting propositional logic in the context of rst-order logic, we note that it has a unique structure/interpretation. Under this unique structure, terms, functions, predicates, and formulas all coincide. This simplicity is crucial to the following development for propositional logic, and will become apparent when we encounter rst-order logic.</p><p>Theorem 2. A quantied Boolean formula ∃y.ϕ(x, y) is logically equivalent to the quantier-free formula ϕ(x, f (x)) for some function f : B n → B if and only if every pair a ∈ B n , b ∈ B with f (a) = b satises ϕ(a, b) ∨ ∀y.¬ϕ(a, y).</p><formula xml:id="formula_0">Proof. (=⇒) For f (a) = b, then ϕ(a, f (a)) = ϕ(a, b). If ϕ(a, b) is true, then ∃y.ϕ(a, y) is true.</formula><p>On the other hand, if ¬ϕ(a, b) is true, then ¬∃y.ϕ(a, y) is true due to the logical equivalence between ϕ(x, f (x)) and ∃y.ϕ(x, y). Hence every pair a ∈ B n , b ∈ B with f (a) = b satises ϕ(a, b) ∨ ∀y.¬ϕ(a, y).</p><p>(⇐=) For the sake of contradiction, assume ∃y.ϕ(x, y) and ϕ(x, f (x)) are not logically equivalent. Then there exists some a ∈ B n such that ¬∃y.ϕ(a, y) ∧ ϕ(a, f (a)) or ∃y.ϕ(a, y) ∧ ¬ϕ(a, f (a)). The former is trivially unsatisable; the latter contradicts with the premise, ϕ(a, f (a)) ∨ ∀y.¬ϕ(a, y).</p><p>In essence the above theorem answers the following question: Given a quantied Boolean formula ∃y.ϕ <ref type="bibr">(x, y)</ref>, what should a function f be such that the composition ϕ(x, f (x)) equals ∃y.ϕ? It also implies the existence of such a function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 1. Given a quantied Boolean formula ∃y.ϕ(x, y), there always</head><p>exists a function f (x) such that ∃y.ϕ(x, y) = ϕ(x, f (x)).</p><p>Proof. The proposition follows from the fact that, for every a ∈ B n , there always exists some b ∈ B such that ϕ(a, b) = 1 if ∃y.ϕ(a, y) is true.</p><p>The following proposition characterizes the complete exibility of a composite function for quantier elimination. Proof. There are four possible valuations of ϕ(a, 0) and ϕ(a, 1) for every a ∈ B n .</p><p>For (ϕ(a, 0), ϕ(a, 1)) = (0, 0), a is a don't-care minterm of f because ϕ(a, f (a)) = 0 independent of the value of f (a). For (ϕ(a, 0), ϕ(a, 1)) = (0, 1), a is an onset minterm of f because ∃y.ϕ(a, y) is true and f (a) = 1 is the only way to make ϕ(a, f (a)) true. For (ϕ(a, 0), ϕ(a, 1)) = (1, 0), a is an oset minterm of f for reason similar to that of case (0, 1). For (ϕ(a, 0), ϕ(a, 1)) = (1, 1), a is a don't-care minterm of f for reason similar to that of case (0, 0). Therefore the composite function f can be minimized using the don't-care con-</p><formula xml:id="formula_1">dition (ϕ[y/1] ∧ ϕ[y/0]) ∨ (¬ϕ[y/1] ∧ ¬ϕ[y/0]).</formula><p>Since universal quantication can be converted to existential quantication by the equality ∀x.ϕ = ¬∃x.¬ϕ, the compositional approach can be used in general quantier elimination of quantied Boolean formulas (QBFs). The quantiers of a QBF can be removed from inside out.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Interpolation of Composite Function</head><p>By Proposition 2, the composite function f can be obtained using symbolic methods. Finding a simple implementation of f under the don't-care exibility hopefully makes ϕ(x, f (x)) simple and facilitates quantier elimination. We exploit Craig interpolation for scalable computation. It relies on the following proposition, whose correctness is immediate by Theorem 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 3. The interpolant with respect to</head><formula xml:id="formula_2">φ A = ¬ϕ[y/0] ∧ ϕ[y/1] and (1) φ B = ¬ϕ[y/1] ∧ ϕ[y/0]<label>(2)</label></formula><p>is a valid implementation of a composite function f satisfying ∃y.ϕ = ϕ[y/f ].</p><p>Interpolation can be seen as a way to derive simple functions as long as the don't-care set is reasonably large. When the don't-care set is large, proving the unsatisability of φ A ∧ φ B is easy and the corresponding refutation proof is simple. So the interpolant size (in term of AIG nodes) is likely to be small.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Analysis of Applicability</head><p>We compare expansion-and composition-based quantier-elimination procedures assuming that AIGs are the underlying data structure. </p><formula xml:id="formula_3">φ B = ¬ϕ[y/1] ∧ ¬ϕ[y/0]<label>(4)</label></formula><p>being the tightest onset and oset, respectively. Notice that interpolation or other symbolic techniques can be applied here to extract a function, say f ,</p><formula xml:id="formula_4">hopefully simpler than ϕ[y/1]. So ϕ[y/0] ∨ f can be simpler than ϕ[y/0] ∨ ϕ[y/1]</formula><p>for quantier elimination. (With interpolation, such simplication however was not empirically observed in our experiments. It may be due to the small size of the don't-care set, which results in ineective interpolation.) <ref type="bibr" target="#b1">2</ref> Observe that Equations (1) and (3) are identical, whereas Equations (2) and (4) dier only in the second term. This slight dierence in fact makes substantial impact on interpolation. When ϕ is a sparse function (with relatively few onset minterms), ϕ[y/0] is very likely a sparse function as well. In this case, the oset corresponding to φ B of Equation <ref type="formula" target="#formula_2">(2)</ref> is much smaller than that of Equation (4). Accordingly, proving the unsatisability of φ A ∧ φ B of Equations <ref type="formula">(1)</ref> and <ref type="formula" target="#formula_2">(2)</ref> is easier to establish than that of Equations <ref type="formula">(3)</ref> and (4). The derived interpolant with respect to Equations <ref type="formula">(1)</ref> and <ref type="formula" target="#formula_2">(2)</ref> can be much smaller. On the contrary, for dense function ϕ the derived interpolant with respect to Equations <ref type="formula">(3)</ref> and <ref type="formula" target="#formula_3">(4)</ref> can be smaller.</p><p>The above sparsity condition commonly holds in practical applications. For instance, the transition relation built up from a set of transition functions of a sequential system appears to be sparse. In fact, the more the transition functions are, the sparser the transition relation is. Under this sparsity assumption, quantier elimination using functional composition is superior to that using formula expansion.</p><p>By a qualitative comparison, expansion-and composition-based quantierelimination methods show dierent characteristics:</p><p>Manipulation complexity. The former requires cofactoring and disjunction operations; the latter requires interpolation (which invokes SAT solving) and composition operations. In addition to the above operations, for both methods AIG minimization also plays an important role in the entire quantication eort.</p><p>Circuit level. The circuit depth of a resultant AIG is shallower for the former and deeper for the latter. On the other hand, the circuit width of a resultant AIG is thicker for the former and thinner for the latter.</p><p>Circuit size. The AIG resulted from the former is often larger than that of the latter in certain applications. This phenomenon can be related to the sparsity assumption and due to the amount of achieved logic sharing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Application to Circuit Optimization</head><p>In addition to quantier elimination, a potential application of (the if-part of) Theorem 2 is to reduce circuit levels. Consider a circuit C implementing some function f (X).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Suppose t is an intermediate signal in the circuit with function g(X) and f (X) = h(X, t) = h(X, g(X)). If g(X) satises Theorem 2, then the circuit can be reexpressed by h[t/0]∨h[t/1], whose circuit level can be potentially smaller than that of h[t/g(X)].</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Predicate Logic</head><p>We study quantier elimination in predicate logic with the following principle.</p><p>Proposition 4. Given a language L in predicate logic and a structure A, then</p><formula xml:id="formula_5">|= A ∀x.(∃y.ϕ(x, y) = ∃F.ϕ(x, F (x))),</formula><p>where ϕ is a formula, F is an n-place function symbol, and x = (x 1 , . . . , x n ) and y are variable symbols of L.</p><p>Proof. By the axiom of choice, such a function can be obtained by letting f (a) = b for every a with some b satisfying ϕ(a, b) or some arbitrary b if ∀y.¬ϕ(a, y).</p><p>Note that the above proof characterizes the complete exibility of the composite function in predicate logic.</p><p>The equality of Proposition 4 suggests an equivalence-preserving transformation (with respect to some structure), and should be distinguished from the satisability-preserving Skolemization <ref type="bibr" target="#b17">[18]</ref> of</p><formula xml:id="formula_6">∀x, ∃y.ϕ(x, y) |= =| ∃F, ∀x.ϕ(x, F x).</formula><p>Unlike propositional logic, the nice coincidence of terms, functions, predicates, and formulas no longer holds in predicate logic. In fact all of them are distinct. Terms are built up from constant symbols, variables, and function symbols. They represent names of objects and should be distinguished from functions. Substituting terms for variables is legitimate, but substituting functions or formulas for variables is not. Quantier elimination through substitution is achievable only when a function can be conditionally expressed by a nite set of terms. Therefore quantier elimination by exhaustive formula expansion does not work in predicate logic. Dierent from propositional logic, a function in predicate logic may not be always expressible with a single term, and sometimes not even nitely expressible. With these dierences in mind, we generalize Theorem 2 in the context of predicate logic as Theorems 3 and 4. </p><formula xml:id="formula_7">i γ i ∧ ϕ(x, t fi ).</formula><p>The above theorems can be applied for universal quantier elimination by ∀x.ϕ = ¬∃x.¬ϕ, and thus work for nested quantier elimination.</p><p>With the following examples, we illustrate the usefulness of the complete exibility of a composite function to simplify quantier elimination. Example 1. Consider the rst-order language L G with equality, 1-place function symbol S, 2-place predicate symbol R. Let structure A = ({0, . . . , 4}; S (successor The graph induced by the structure A is shown in <ref type="figure" target="#fig_3">Figure 1</ref>, where every element of the universe {0, . . . , 4} is represented as a vertex, and every (u, v) ∈ R is represented as a directed edge from u to v. Let ϕ be</p><formula xml:id="formula_8">∃y.((y = x) ∧ R(x, y) ∧ R(y, y)).</formula><p>Then the (x, y)-values satisfying ((y = x) ∧ R(x, y) ∧ R(y, y)) have the property that vertex x connects to a dierent vertex y that has a self-loop. So (x, y)-values are as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>x y 0 1, 2 1 3 2 ∅ 3 0 4 1</head><p>By Theorem 4, a solution function f can be as follows.</p><p>x f (x) 0 2 1 3 2 4 3 0 4 1</p><p>In this case, f can be expressed in terms of S as f (x) = S(S(x)). So ϕ can be transformed into the equivalent quantier-free formula</p><formula xml:id="formula_9">(S(S(x)) = x) ∧ R(x, S(S(x))) ∧ R(S(S(x)), S(S(x))).</formula><p>Example 2. Consider the following formula ϕ in the language of number theory under structure N = (N; 0, S, S −1 , &lt;, +, ·, E), where S −1 is the inverse of the successor function S with S −1 (0) = 0.</p><formula xml:id="formula_10">(S(0) &lt; x) ∧ (x &lt; y) ∧ (∀a, ∀b.(y = a · b → (a = S(0) ∨ b = S(0))) → ∀a, ∀b.(x = a · b → (a = S(0) ∨ b = S(0))))</formula><p>ϕ asserts that x is greater than 1, y is greater than x, and, if y is prime, then x is prime. By the property of Mersenne numbers, the quantication of ∃y.ϕ can be eliminated by substituting 2 x − 1, shorthand for S −1 (S(S(0))Ex), for y in ϕ as</p><formula xml:id="formula_11">(S(0) &lt; x) ∧ (x &lt; (2 x − 1)) ∧ (∀a, ∀b.((2 x − 1) = a · b → (a = S(0) ∨ b = S(0))) → ∀a, ∀b.(x = a · b → (a = S(0) ∨ b = S(0)))),</formula><p>which can be further simplied to</p><formula xml:id="formula_12">(S(0) &lt; x) ∧ (∀a, ∀b.((2 x − 1) = a · b → (a = S(0) ∨ b = S(0))) → ∀a, ∀b.(x = a · b → (a = S(0) ∨ b = S(0)))).</formula><p>Example 3. Consider the following rst-order formula over real closed elds.</p><p>(The notation and symbols are used in the conventional arithmetic sense.)</p><formula xml:id="formula_13">∃x.(a · x 2 + c = 0) (5) Let f (a, c) = −c/a if c/a &lt; 0 or c/a = 0 0 if 0 &lt; c/a .</formula><p>(For 0 &lt; c/a, the value of f (a, c) can be arbitrary and is set to 0.) Quantier elimination by substituting f (a, c) for x in Equation <ref type="formula">(5)</ref> yields</p><formula xml:id="formula_14">((c/a &lt; 0 ∨ c/a = 0) ∧ a · ( −c/a) 2 + c = 0) ∨ (0 &lt; c/a ∧ a · 0 2 + c = 0),</formula><p>which can be simplied to c/a &lt; 0 ∨ c/a = 0. Alternatively, let</p><formula xml:id="formula_15">f (a, c) = (−c/a) 2 .</formula><p>The corresponding quantier-free formula becomes</p><formula xml:id="formula_16">a · (−c/a) 2 2 + c = 0.</formula><p>As this paper focuses on the characterization of the complete exibility of a composite function, how to eectively exploit such exibility in simplifying quantier elimination in predicate logic remains an open problem. In fact interpolation is not directly extensible to generate composite functions due to the dierence between formulas and functions in predicate logic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experimental Results</head><p>The proposed compositional approach to quantier elimination was implemented in the ABC package <ref type="bibr" target="#b0">[1]</ref>; the experiments were conducted on a Linux machine with Xeon 3.4GHz CPU and 6Gb RAM.</p><p>We showed the eectiveness of quantier elimination by constructing the transition relations of circuits taken from ISCAS and ITC benchmark suites. In the transition relation of a circuit, its primary-input variables were existentially quantied.</p><p>Despite recent advances in AIG packages, it was observed that AIG minimization may not be eective when AIG sizes reach tens of thousands of nodes. Hence it is benecial to perform AIG minimization whenever possible before the sizes get too large to be reduced. So in the experiments AIGs were constantly minimized throughout the computation. Specically, for expansion-based quantication, minimization was applied after the disjunction of two cofactored circuits; for composition-based quantication, minimization was applied before circuit-to-CNF conversion for SAT solving, at interpolant simplication, and after functional composition. <ref type="bibr" target="#b2">3</ref> As quantication scheduling is crucial to the scalability of quantier elimination, we adopted a simple strategy: By imposing a postponement threshold (the percentage of AIG-size increase due to quantication), variables whose corresponding quantications result in substantial increase in AIG sizes (exceeding the postponement threshold) are deferred. This threshold is lifted gradually in the iterative computation until all quantiers are eliminated. In the following experiments, the threshold starts at and increases by 10%. The same scheduling strategy is applied for both expansion-and composition-based quantications. <ref type="table">Table 1</ref> compares the two quantication methods based on formula expansion (denoted QE-Exp) and functional composition (denoted QE-Cmp), where an entry with indicates data unavailable due to time-out at the limit of 90000 seconds. The smaller number of every corresponding pair of AIG sizes (circuit depths) between QE-Exp and QE-Cmp is highlighted in bold. The ratio shown in the table is calculated under the exclusion of the 5 unsolvable circuits of QE-Exp.</p><p>As can be seen from Columns 5 and 9 of Table 1, QE-Cmp is much more scalable than QE-Exp. The AIG sizes of QE-Cmp after quantication are typically much smaller than or comparable to those of QE-Exp. Apart from the 5 unsolvable circuits of QE-Exp, s991 is an extreme, where the nal AIG size of QE-Cmp is 3 orders of magnitude smaller than that of QE-Exp. On the other hand, circuit s1196 is an exception, where the result of QE-Cmp is 6 times larger than that of QE-Exp due to the failure to derive reasonable-sized interpolants. Despite the eectiveness of QE-Cmp, there are still cases b14, ..., b22 of the ITC benchmark circuits (not shown in <ref type="table">Table 1</ref>) unsolvable by either of QE-Exp and QE-Cmp. In these cases, the unsatisability of φ A ∧ φ B is hard to establish. Even if an interpolation succeeds, the corresponding interpolant is too large to be useful. Further breakthroughs are needed to overcome these limitations.</p><p>In addition to circuit sizes, we examine the eects of QE-Exp and QECmp on circuit depths. Columns 6 and 10 of <ref type="table">Table 1</ref> show the characteristics of both methods. Compared to Column 4, the transition relations before quantier elimination, QE-Exp yielded circuits with comparable logic levels as shown in Column 6, whereas QE-Cmp produced circuits with many more logic levels as shown in Column 10. QE-Exp (respectively QE-Cmp) can be seen in a sense as quantication with restricted (respectively unrestricted) increase in logic levels. QE-Exp and QE-Cmp are analogous to two-level and multi-level logic minimization, respectively. QE-Cmp therefore can potentially achieve more logic sharing and generate smaller circuits. Since logic-level increase is not immaterial in every application, in this case heavy logic synthesis, e.g., with collapse operation, can be adopted to reduce logic levels. On the other hand, these extreme characteristics about logic levels might hint at the potential reduction power of the proposed optimization method discussed in Section 3.4.</p><p>The proposed method can be easily integrated into the framework of unbounded model checking as suggested in <ref type="bibr" target="#b16">[17]</ref>. Our preliminary experiments on reachability analysis suggested that sparsity is an important factor for QE-Cmp to be eective. Without taking advantage of sparsity in reachability analysis, QE-Cmp may not be as good as QE-Exp. How to enforce sparsity in reachability analysis using QE-Cmp remains to be done.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Prior Work</head><p>Propositional logic. There have been intensive eorts on BDD-based image computation based on the principle of formula expansion, e.g., <ref type="bibr" target="#b21">[22]</ref>, and eorts on SAT-based computation with solution enumeration, e.g., <ref type="bibr" target="#b6">[7]</ref>. The closest to ours, however, is AIG-based formula expansion <ref type="bibr" target="#b16">[17]</ref>.</p><p>This paper proposes a compositional approach to quantier elimination. The complete exibility of the composite function is characterized. Although symbolic techniques, such as BDDs, can be applied, we use SAT solving and Craig interpolation for scalable derivation of the composite function.</p><p>Craig interpolation was adopted in <ref type="bibr" target="#b15">[16]</ref> to approximate image computation and in <ref type="bibr" target="#b7">[8]</ref> to approximate transition relation. This paper uses interpolation to compute exact image and exact transition relation.</p><p>Under the virtual substitution principle of <ref type="bibr" target="#b22">[23]</ref>, quantier elimination by formula expansion can be considered as virtual substitution with two terms <ref type="bibr" target="#b18">[19]</ref>; quantier elimination by functional composition can be considered as virtual substitution with a single term.</p><p>Predicate logic. When generalized to predicate logic, our composite function is similar to the Skolem function <ref type="bibr" target="#b17">[18]</ref> with the following dierences: Firstly, the former is used for quantier elimination with term substitution, whereas the latter is used to rewrite formulas in Skolem normal form using Skolem function symbols. Secondly, quantier elimination with composite functions is structurespecic (i.e., with respect to some structure/interpretation), whereas normal form conversion with Skolem functions is structure-independent (i.e., universal to all structures/interpretations). Thirdly, quantier elimination with composite functions is equivalence preserving, whereas normal form conversion with Skolem functions is only satisability preserving.</p><p>Under predicate logic, our quantier elimination is similar to virtual substitution <ref type="bibr" target="#b22">[23]</ref> with the following dierences: In virtual substitution, a nite elimination set of terms is identied for quantier elimination. The notion of composite functions is not explicit in <ref type="bibr" target="#b22">[23]</ref>. Our emphasis, on the other hand, is on the characterization of the complete exibility of composite functions. In eliminating a quantied variable, a single composite function is characterized, rather than a set of terms of the underlying language. We do not address how to represent a composite function by terms, but suggest the usefulness of exibility in reducing elimination sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions and Future Work</head><p>We have presented a compositional approach to quantier elimination. The complete exibility of composite functions was characterized; Craig interpolation was exploited for eective computation. Experiments showed promising results on extending the capacity of quantier elimination when the sparsity assumption holds. For rst-order logic, our results may shed light on elimination-set minimization as motivated by the examples of Section 4.</p><p>As this paper just showed the rst step, much work remains to be done. The eectiveness of our method on unbounded model checking and on circuit optimization suggested in Section 3.4 needs further investigation. Quantication scheduling under the new compositional approach awaits improvement. Moreover, a hybrid approach to quantier elimination by combining the expansionand composition-based methods may be pursued to keep both AIG sizes and depths small. We anticipate applications of the new quantication method in scalable logic synthesis, where Craig interpolation is evidently gaining importance <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b11">12]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Proposition 2 .</head><label>2</label><figDesc>The equality ∃y.ϕ(x, y) = ϕ(x, f (x)) holds if and only if the composite function f satises (¬ϕ[y/0] ∧ ϕ[y/1]) → f and f → ¬(¬ϕ[y/1] ∧ ϕ[y/0]). That is, ¬ϕ[y/0] ∧ ϕ[y/1] and ¬ϕ[y/1] ∧ ϕ[y/0] are the tightest onset and oset of f , respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Hence</head><label></label><figDesc>¬ϕ[y/0] ∧ ϕ[y/1] and ¬ϕ[y/1] ∧ ϕ[y/0] are the tightest onset and oset of f , respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>The AIG sizes of ϕ[y/0]∨ ϕ[y/1] and ϕ[y/f (x)] are analyzed. The AIGs of ϕ[y/0] and ϕ[y/1] are obtained from ϕ through constant prop- agation. From practical experience, the sizes of ϕ[y/0] and ϕ[y/1] are rarely reduced much, especially for large AIGs. It is possible to apply aggressive mini- mization using don't cares. Specically, in building ϕ[y/0]∨ϕ[y/1], ϕ[y/0] can be used as the don't-care condition to minimize ϕ[y/1], or vice versa (but simultane- ous minimization of ϕ[y/0] and ϕ[y/1] is forbidden). For instance, in minimizing ϕ[y/1] using don't-care condition ϕ[y/0], the optimization is constrained by φ A = ϕ[y/1] ∧ ¬ϕ[y/0] and (3)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Graph dened by the rst-order language LG</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>5] Given two Boolean formulas φ A and φ B , with φ A ∧ φ B unsatisable, then there exists a Boolean formula ψ A referring only to the common variables of φ A and φ B such that φ A → ψ A and ψ A ∧ φ B remains unsatisable.</head><label></label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Theorem 3 . Given a rst-order language L and a structure A, if a formula ∃y.ϕ(x, y) is equivalent to ϕ[y i /t f ] = ϕ(x, t f ), by substituting for y some term t f (nitely expressible in the language) that represents f (x) for some function f : |A| n → |A|, then ϕ(a, b) ∨ ¬∃y.ϕ(a, y) is satised for any a ∈ |A| n , b ∈ |A| with f (a) = b. Unlikey) of some rst-order language L and a structure A, if a function f : |A| n → |A| with f (a) = b satisfying ϕ(a, b) ∨ ¬∃y.ϕ(a, y) is nitely expressible in the language with f =if γ m such that each f i can be expressed with some term t f i , where guard γ i is the predicate dening the applicability of f i over |A| n , then the quantied formula ∃y.ϕ(x, y) is equivalent to</head><label>3</label><figDesc>the necessary and sucient condition of Theorem 2, the converse of Theo- rem 3 is not true because in general the composite function f may not be nitely expressible in the language. For nitely expressible f , however, the converse holds by Theorem 4.</figDesc><table>Theorem 4. Given a formula ϕ(x,  
  

  

f 1 if γ 1 
. . . 

f m </table></figure>

			<note place="foot" n="2"> Practical experience suggests that the size of an interpolant can be sensitive to the amount of don&apos;t cares. It was observed that, for a function f , the AIG size of the interpolant of φ A = f and φ B = ¬f (i.e., interpolation without don&apos;t cares) is typically much (e.g., two orders of magnitude) larger than that of f . Therefore, quantier elimination of ∃y.ϕ(x, y) by interpolating φ A = ϕ(x, y) and φ B = ¬∃y.ϕ(x, y) is ineective.</note>

			<note place="foot" n="3"> A synthesis script of commands ifraig, rewrite, refactor, balance, rewrite, refactor, balance of ABC was applied for AIG minimization.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was supported in part by NSC grants 95-2218-E-002-064-MY3 and 96-2221-E-002-278-MY3.</p></div>
			</div>

			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">ABC: A System for Sequential Synthesis and Verication</title>
		<ptr target="http://www.eecs.berkeley.edu/∼alanmi/abc/" />
		<imprint>
			<date type="published" when="2005" />
		</imprint>
		<respStmt>
			<orgName>Berkeley Logic Synthesis and Verication Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Quantier Elimination and Cylindrical Algebraic Decomposition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">F</forename><surname>Caviness</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A unied framework for the formal verication of sequential circuits</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Coudert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Madre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Computer-Aided Design</title>
		<meeting>Int&apos;l Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="126" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Quantier elimination for real closed elds by cylindrical algebraic decomposition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">E</forename><surname>Collins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automata theory and formal languages</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1975" />
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="134" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Linear reasoning: A new form of the Herbrand-Gentzen theorem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Craig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="250" to="268" />
			<date type="published" when="1957" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">A Mathematical Introduction to Logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">B</forename><surname>Enderton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<publisher>Academic Press</publisher>
		</imprint>
	</monogr>
	<note>2nd edition</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Ecient SAT-based unbounded symbolic model checking using circuit cofactoring</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ganai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Ashar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Computer-Aided Design</title>
		<meeting>Int&apos;l Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="510" to="517" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Interpolant-based transition relation approximation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Computer Aided Verication</title>
		<meeting>Computer Aided Verication</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="39" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Bi-decomposing large Boolean functions via interpolation and satisability solving</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R.-R</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-H</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-L</forename><surname>Hung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automation Conf</title>
		<meeting>Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="636" to="641" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Scalable exploration of functional dependency by interpolation and incremental SAT solving</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-H</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mishchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on Computer-Aided Design</title>
		<meeting>Int&apos;l Conf. on Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="227" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">To SAT or not to SAT: Ashenhurst decomposition in a large scale</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-P</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-H</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R.-R</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Computer-Aided Design</title>
		<meeting>Int&apos;l Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="32" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Scalable don&apos;t-care-based logic optimization and resynthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mishchenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-H</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Symp. on Field Programmable Gate Arrays</title>
		<meeting>Int&apos;l Symp. on Field Programmable Gate Arrays</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="151" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">DAG-aware AIG rewriting: A fresh look at combinational logic synthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mishchenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chatterjee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automation Conference</title>
		<meeting>Design Automation Conference</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="532" to="536" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">FRAIGs: A unifying representation for logic synthesis and verication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mishchenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chatterjee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-H</forename><forename type="middle">R</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">; Eecs</forename><surname>Dept</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Berkeley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Applying SAT methods in unbounded symbolic model checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Computer Aided Verication</title>
		<meeting>Computer Aided Verication</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="250" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Interpolation and SAT-based model checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Computer Aided Verication</title>
		<meeting>Computer Aided Verication</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Advanced unbounded model checking based on AIGs, BDD sweeping, and quantier scheduling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Pigorsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Scholl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Disch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Formal Methods on Computer Aided Design</title>
		<meeting>Formal Methods on Computer Aided Design</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="89" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Translation in From Frege to Gödel, A Source Book in Mathematical Logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Th</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Skolem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Norsk. Mat. Tidsk</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="125" to="142" />
			<date type="published" when="1928" />
			<publisher>Harvard Univ. Press</publisher>
		</imprint>
	</monogr>
	<note>J. van Heijenoort</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Boolean quantication in a rst-order context</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Seidl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Sturm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Workshop on Computer Algebra in Scientic Computing</title>
		<meeting>Int&apos;l Workshop on Computer Algebra in Scientic Computing</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="329" to="345" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">New domains for applied quantier elimination</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Sturm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Workshop on Computer Algebra in Scientic Computing</title>
		<meeting>Int&apos;l Workshop on Computer Algebra in Scientic Computing</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="295" to="301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">A Decision Method for Elementary Algebra and Geometry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tarski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1951" />
			<publisher>University of California Press</publisher>
			<pubPlace>Berkeley</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Implicit enumeration of nite state machines using BDDs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Touati</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Savoj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. on ComputerAided Design</title>
		<meeting>Int&apos;l Conf. on ComputerAided Design</meeting>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="130" to="133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The complexity of linear problems in elds</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Weispfenning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Computation</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="3" to="27" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
