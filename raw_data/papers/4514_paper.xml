<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:52+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Checking the Consistency of Collaboration and Class Diagrams using PVS</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
							<email>.paige@cs.york.ac.uk¤</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="institution">University of York</orgName>
								<address>
									<postCode>YO10 5DD</postCode>
									<settlement>Heslington</settlement>
									<region>York</region>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><forename type="middle">S</forename><surname>Ostroff</surname></persName>
							<email>jonathan@cs.yorku.ca.philb@soc.plym.ac.uk</email>
							<affiliation key="aff1">
								<orgName type="department">School of Computing</orgName>
								<orgName type="institution">York University</orgName>
								<address>
									<addrLine>4700 Keele Street</addrLine>
									<postCode>M3J 1P3</postCode>
									<settlement>Toronto</settlement>
									<region>Ontario</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Phillip</forename><forename type="middle">J</forename><surname>Brooke</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">University of Plymouth</orgName>
								<address>
									<addrLine>Drake Circus</addrLine>
									<postCode>PL4 8AA</postCode>
									<settlement>Plymouth, Devon</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Checking the Consistency of Collaboration and Class Diagrams using PVS</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We present a formal, mechanically checked specification of the consistency constraints between two views of object-oriented systems described in BON: the static view provided by class diagrams annotated with contracts, and the dynamic view provided by collaboration diagrams. The constraints are specified as an extension of the BON metamodel, and are implemented in PVS. They ensure that the sequence of messages appearing in the dynamic view is legal, given the pre-and postconditions of methods appearing in the static view. A sketch of how the constraints might be implemented in the BON CASE tool is also provided.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction and Motivation</head><p>Consistency checking of documents has long been an important task in software development. It has particularly been emphasized with recent work on viewpoint specification <ref type="bibr" target="#b5">[6]</ref> and combining specifications <ref type="bibr" target="#b17">[18]</ref>. With the recent interest in UML <ref type="bibr" target="#b1">[2]</ref>, the consistency checking of independently constructed models of a software system has become of increasingly significant interest.</p><p>Consistency checking of software models involves the use of constraints, algorithms, and tools to check that information described in one model is not contradicted by information described in another model. In a setting where formal specifications of models are available, this is essentially the problem of checking that a conjunction of predicates -each a formal specification of a model -is satisfiable. In general, complete formal specifications of models are usually unavailable, and thus the problem of consistency checking is made more complex and challenging.</p><p>UML is a particularly interesting language for describing software systems and maintaining consistency of description. It supports the use of up to four different views of a single software system. These views may be constructed independently, may overlap, and thus may contradict each other. The intent of using multiple views is to describe different aspects or elements of a system in the most appropriate way. The different descriptions are to be combined to form a consistent, complete, checkable description of the software system that can be used thereafter to generate executable code. This problem is not unique to UML; any modelling language that supports disparate views</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>We outline BON, focusing on the elements of their syntax used throughout the remainder of the paper. In particular, we will make use of the BON text-based notation for writing classes and interfaces, and its graphical notation for writing collaborations. We then briefly summarize the methodology that integrates OO modelling and XP from <ref type="bibr" target="#b12">[13]</ref>, since the methodology provides the motivation for constructing the consistency constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">BON</head><p>BON is an OO method possessing a recommended process as well as a graphical language for specifying object-oriented systems. The language provides mechanisms for specifying classes and objects, their relationships, and assertions (written in first-order predicate logic) for specifying the behaviour of routines and invariants of classes.</p><p>The fundamental construct in BON is the class. A class has a name, an optional class invariant, and zero or more features. A feature may be an attribute, a querywhich returns a value and does not change the system state -or a command, which changes system state but returns nothing. <ref type="figure">Fig. 1</ref>  BON also provides notation for collaboration diagrams, showing the communication between objects. <ref type="figure" target="#fig_0">Fig. 2</ref> shows an example. Numbers that annotate messages are cross-referenced to a scenario box, detailing the purpose of the message. Messages in dynamic diagrams correspond to feature calls. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">A methodology integrating XP and object-oriented modelling</head><p>The motivation for being able to check the consistency of contract-annotated class diagrams and collaboration diagrams comes from the proposal of a methodology integrating XP and OO modelling. A draft of this methodology was presented in <ref type="bibr" target="#b12">[13]</ref>. The methodology, as proposed, makes use of a selection of OO modelling diagrams, source code (e.g., in Eiffel or Java or some other suitable OO programming language), and test drivers. Test drivers provide a fundamental link between OO modelling and XP practices.</p><p>A key difficulty in integrating XP and OO modelling is allowing code to be written before modelling, and to allow modelling before writing code -i.e., to allow developers to select the work product to use at the start of development. It is essential to allow this level of flexibility, so that testing can be carried out when desired, and so that the abstraction capabilities of modelling languages can be fully exploited.</p><p>Elements of the methodology are summarized in <ref type="figure" target="#fig_1">Fig. 3</ref>. The diagram uses UML's package and dependency notations to illustrate the work products delivered by the methodology, and their relationships.</p><formula xml:id="formula_0">The ¢ ¡ ¤ £ ¦ ¥ ¨ § © £ and ¥ £ £ stereotypes are stan- dard UML. The ¢ " ! # % $ ¨ § &amp; $ ¨ ' ( £ ) 0 '</formula><p>stereotype is a refinement of ¥ £ £ 1</p><p>and indicates that the two products must be consistent either by construction or developer intervention. A key element of <ref type="figure" target="#fig_1">Fig. 3</ref> is the relationship between test drivers and collaboration diagrams: a collaboration diagram is viewed as an abstraction of a test driver. Tool support is to be provided so that, given a collaboration diagram, the outline of an executable test driver can be produced; and, given a test driver, a collaboration diagram can automatically be produced. The second key aspect of this diagram is the relationship between class and collaboration diagrams: given one of each such diagrams, we desire to be able to show the consistency of the information contained in both descriptions.</p><p>Descriptions of how the relationships between work products can be established are outlined in <ref type="bibr" target="#b12">[13]</ref>. In this paper, we focus on the relationships involving collaboration diagrams and class diagrams. Specifically, we will describe how consistency between these products can be established directly via use of a metamodel and tools such as PVS. We also sketch how test drivers can be used as an intermediate product for checking the consistency of the two different diagrams.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Foundations and Approaches</head><p>The eventual goal of our work is to be able to check any work product against any other work product for consistency. A work product, in the context of the methodology of <ref type="bibr" target="#b12">[13]</ref>, is defined as any one of:</p><p>-Machine-checkable Eiffel source code, where classes and routines are annotated with pre/postconditions and invariant clauses. -A class diagram, showing classes, assertions, and class relationships. -A collaboration diagram, showing objects and message passing. -A test driver, which is an Eiffel class that executes a sequence of routines on one or more objects and checks that relevant conditions hold.</p><p>Informally, we desire to define a family of consistency relations on the work products of interest. We are specifically concerned, in this paper, with checking the consistency of class diagrams with contracts and collaboration diagrams. There are two general approaches to this. One approach is to define a set of rules that can be applied to a given class diagram and a given collaboration diagram. Due to the inclusion of contracts in the class diagram -which may make use of unexecutable constructs -this process may need tool support and user intervention to check consistency.</p><p>An alternative approach is to do indirect consistency checking of the two work products, via use of test drivers as an intermediate product. This works as follows. We wish to show that a class diagram ¡ is consistent with a collaboration diagram ¢ for a system. First, show that ¡ is consistent with the system's source code (this is easy, via forward or reverse engineering, as supported in any reasonable CASE tool). Then, show that the source code is consistent with any test drivers for the system (again, this is easy -we simply execute the test drivers and if the tests are accepted, the products are consistent). Finally, check that the collaboration diagram ¢ is consistent with the test drivers. This process is more complex and is discussed in the sequel. But if we can establish separate consistency of these three products, then the class diagram and the collaboration diagram will be consistent.</p><p>Thus, one approach to consistency checking of collaboration diagrams and class diagrams is by defining work product consistency in a transitive fashion, and by making use of test drivers as an intermediate product. But it is also desirable in the methodology to be able to check collaboration diagrams against class diagrams directly. This is important because developers may not want to have to create test drivers in order to do consistency checking (and the methodology of <ref type="figure" target="#fig_1">Fig. 3 supports this)</ref>. In the next section, we specify consistency constraints between these diagrams, and then discuss how these constraints can be implemented in a CASE tool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Checking Collaboration Diagrams Against Class Diagrams</head><p>The goal is to check the consistency of one or more BON collaboration diagrams against one or more BON class diagrams, and if the diagrams are not consistent, to report where the inconsistencies arise. Inconsistencies can arise due to object declaration (e.g., an object is unassociated with any class), or routine invocation (e.g., a routine is being called by a client that does not have the ability to do so, based either on information hiding rules, or on preconditions). It is critical to observe that class diagrams contain only contracts, and not implementations, of routines. Further, the BON assertion language, based on first-order predicate logic, contains constructs that are not executable (e.g., quantifiers over unbounded domains). Thus, in general, consistency checking will not be possible by direct simulation of the collaboration diagram, and will likely require user intervention.</p><p>There are several main steps to checking the consistency of class diagrams and collaboration diagrams.</p><p>1. Ensure that the two diagrams are syntactically correct; there is a BON CASE tool that will do this for us. 2. Ensure that the diagrams are semantically correct in the sense that they obey typing and scoping rules (e.g., all classes arising in an interface appear in a class diagram).</p><p>We call these weak metamodel constraints. 3. Check that the sequence of messages being fired in the collaboration diagram is allowable given the pre/postconditions of the routines in the class diagram. These are strong metamodel constraints that will likely require use of external tools to validate.</p><p>We consider these steps in order, skipping (1) since the BON CASE tool is described elsewhere <ref type="bibr" target="#b8">[9]</ref>. The remaining constraints will be specified as an extension of the metamodel of BON first presented in <ref type="bibr" target="#b10">[11]</ref>. Since the BON CASE tool implements the BON metamodel, we thus have a way of ensuring that they are satisfied. At the same time, it is important to extend the metamodel in such a way so that the additional constraints can easily be introduced in to the existing CASE tool, without requiring substantial changes to the existing system. Some of these constraints, e.g., those in (2), are easily implemented in a CASE tool. Other constraints are more complex, and thus we will express them using the PVS language, so that we can thereafter use the PVS system to check the constraints, either interactively or in batch mode. Before specifying the rules in <ref type="formula">(2)</ref> and <ref type="formula">(3)</ref>, we briefly recount the key parts of the BON metamodel from <ref type="bibr" target="#b10">[11]</ref>. The BON metamodel consists of two clusters and one root class,</p><formula xml:id="formula_1">¢ ¡ ¨ ¤ £ ; every BON model is an instantiation of ¢ ¡ ¨ ¤ £</formula><p>. The general outline of the metamodel is in <ref type="figure" target="#fig_2">Fig. 4</ref>.</p><p>Well-formedness constraints in the metamodel are specified as clauses in the invariant of ¢ ¡ ¨ ¤ £ , or in individual classes appearing in the clusters</p><formula xml:id="formula_2">¥ § ¦ © ¨ £ ¥ £ ¥ ¡ ¡ ¨ or¨£ or¨ or¨£ ¥ £ ¥ ¡ ¡ ¨ ¡ ¨</formula><p>. New constraints for the rules in (2) and (3) will also be integrated into the metamodel as invariant clauses (as we discuss shortly).</p><p>We now present the consistency constraints, and in doing so apply the textual dialect of BON. These specifications will be used in formulating machine-checkable PVS specifications which can then be applied in automatically proving that a collaboration diagram is consistent with a class diagram. First, we recap the concept of a routine of a class from <ref type="bibr" target="#b10">[11]</ref>. A routine has a name, a possibly empty sequence of parameters, a set of accessors, a pre-and postcondition, and a specification, which corresponds to the semantics of the routine. (In <ref type="bibr" target="#b10">[11]</ref>, a routine is specialized into queries, which return values, and commands, which change the state of the system; this is a level of complexity that we can ignore in this paper.) Here is the interface of ¡ is given below; missing details may be found in <ref type="bibr" target="#b10">[11]</ref>. A new non-empty type is introduced, and features of the BON class are transformed to PVS functions. The precondition and postcondition are formalized as functions mapping a routine and state (the latter represented as one or two sets of entities) to a boolean value; the state is needed for composing specifications sequentially. Expressing the concept of a routine's specification in PVS is more complicated. The complication does not arise in expressing a specification directly, but in combining specifications. Thus, our formulation of specifications is aimed at being able to (sequentially) compose them. The formalization of specifications of a routine requires a new type, SPECTYPE, which is a record containing the initial and final state variables of a specification, along with the value of the specification; initial and final state are sets of entities. The functions oldstate and newstate produce the entities associated with a routine (given the class in which the routine arises), specifically the parameters, local variables, and accessible attributes. It is necessary to introduce a new type for specifications so that the frame of a specification can be expressed. A specification can now be defined in terms of the new type. </p><formula xml:id="formula_3">¡ £ ¥ ¡ ¨ . ¢ ¤ £ ¦ ¥ ¨ § © § ¡ ¡ £ ¥ ¡ ¨ ¥ ! # " £ % $ ¨ £ ¡ ' &amp; ( # ¥ ) # " £ ) ' ( £ ) ¥ " $ % $ ¨ ¨ 1 0 ¨ ¨ 3 2 ¥ ¥ ¨ £ ¥ ¨ ¤ 5 4 ( ¥ £ ¤ 6 ( ! $ ¨ ' 7 6 ¦ $ ( £ " 8 $ ¦ ¡ ¡ £ ¨ ¥ " ¢ £ ) $ " $ ¦ ! # ¥ " $ 9 $ ¨ ¨ £ 1 2 £ ¥ ¨¨4 ¨¨4 @ B A ! C ¥ @ ¥ A $ ( £ " E D G F H F ¦ I £ ¦ P Q ( ¥ £ S R U T ( ! $ ¨ ' W V ' Y X ` I £ B P ' W V ' 1 a D c b d R e A P g f ¡ ¡ £ ¥ ¡ ¨ $ ( £</formula><formula xml:id="formula_4">feature_pre(rou1,o) IMPLIES feature_post(rou1,o,n)) #)))))</formula><p>The spec_ax axiom states that for a routine the prestate and poststate of a specification are that of the routine, and the value of the specification is a function from pre and poststate to a boolean, where the boolean is <ref type="bibr">'</ref> ¥ ¡ £ if and only if the precondition implies the postcondition (we omit time variables from the PVS translation for simplicity, but it is straightforward to add them).</p><p>The class¨¨</p><formula xml:id="formula_5">class¨ class¨¨ 1 0 ¨ ¢ ¨</formula><p>is defined in <ref type="bibr" target="#b4">[5]</ref>; it represents a packaged, indexable data structure of arbitrary but finite length. Here is an excerpt of its interface. <ref type="bibr">§</ref> ' £ " returns the specified item in the sequence, while return the first element and all but the first element in the sequence, respectively.</p><formula xml:id="formula_6">$ ¥ § ¦ ) $ ¦ £ ¥ ¨ e F ' H R returns ' ¥ ¡ £ iff '</formula><p>is a subsequence of the current object, while , we use the built-in notion of a finite sequence.</p><formula xml:id="formula_7">( ¥ ¢ £ ¢ " £ " ¡ ¤ £ ) $ ¤ F © 6 © ¤ R is ' ¥ ¡ £ iff</formula><formula xml:id="formula_8">¢ £ B ¥ ¨ § § ¨ ¨ 1 0 ¨ ¨ 3 2 B &amp; 4 ¥ © $ ¨ § 1 £ % $ ¡ £ © ¨ 1 &amp; ¨ § ' ( £ 7 " g F § U $ ¡ £ © ¨ 1 &amp; ¨ R $ &amp; ' # § ¤ £ $ ¨ ¨ 8 0 ¨ ¨ 3 2 B &amp; 4 ¢ £ ) ¡ $ &amp; $ ¡ § ¦ ) $ ) £ ¥ ¨ e F' $ ¨ ¨ 1 0 ¨ ¨ 3 2 B &amp; 4 R $ ¦ ¡ ¡ £ ¨ ¥ ( ¥ £ " ¢ £ " ¡ £ ¨ $ ¤ F © 6 ¥ © ¡ $ &amp; R $ ¦ ¡ ¡ £ ¨ ¥ @ ¦ A ! C ¥ @ ¥ A $ ¨ § 1 £ % X ¡ e A P f ¨ ¨ 1 0 ¨ ¨ 3 2 B &amp; 4</formula><p>Now we can specify the concept of a message that appears in a collaboration diagram. Messages were specified in <ref type="bibr" target="#b10">[11]</ref>, but we modify the definition slightly here. Informally, a message corresponds to a routine call invoked on one or more target objects. More formally, a message in a collaboration diagram consists of a source and a target, a routine (which is the implementation of the message) and a message number. In general, the source and target may be sets of objects, but for simplicity we consider only the case where a message is sent from and to a single object. Recursive rules are given in <ref type="bibr" target="#b16">[17]</ref> for unrolling messages applied to clusters; the extension of the PVS description is straightforward. Now we can specify the concept of a collaboration diagram. This requires us to extend the specification of the metamodel from <ref type="bibr" target="#b10">[11]</ref>. Specifically, we must extend the class ¢ ¡ ¨ ¤ £</p><formula xml:id="formula_9">¢ ¤ £ ¦ ¥ ¨ § © § ¨ f Q % @ G ¨ ¥ ! 2 d P ¤ R S b 6 U § ) 1  e'  b I B C ) d e 9 7 r # " ¨ g 9 £ b 6 P ¤ R S e Y W p &amp; T ) % 7 D % $ £ ¥ ¡ 6 ! ¨ &amp;  R S ( ' &amp; § ) d b 7 ¡ 6 A £ E ¨ g @ u ¨ ( 0 ) 2 1 ¥ ( ¥ ) &amp; f R Q ( % &amp; § ) d</formula><p>. A model consists of a set of abstractions (which may be clusters, objects, classes, and object clusters) and a set of relationships. To this class, we add, via inheritance, several private features that will be used to produce all abstractions and relationships that make up collaboration diagrams 1 .</p><p>Aside. BON obeys the single model principle <ref type="bibr" target="#b11">[12]</ref>, in that a unique model of a system exists, from which different views can be generated.  </p><formula xml:id="formula_10">¢ ¤ £ ¦ ¥ ¨ § © § ¨ ¥ ¤ £ E ¨ § ¦ ¨ ¨ ¦ ¨ ¦ ! ¨ s () © ( ¨ ¦ ¨ G s ¥ © ! A 9 ¨ $ P U § U 4 R S b § 2 g 7 C ¨ D £ g h Y r " ¨ g 9 £ i 2 3 ) 4 R  ) d &amp; T U § ) % 7 S ¨ % $ © ¨ ¥ ¨ A h ¨ f Q % @ G ¨ i 2 4 U § ) d &amp; © ' ¤ b d W Y P &amp; § P 3 5 8 7 £ E ¨ ¨ ¤ £ U § ' ¤ X p X2 7 S ¨ % $ T ¨ ¥ ¨ h D $ £ ¥ ¡ 6 9 ¨ i ¥ © ! A ! # " % $ U 3 X a ' ¤ 2 c 2 ` ¤ W Y ' B ¤ b 6 ' ¤ ( e 1  U § P ¤ X p X a ' ¤ &amp; ` ¤ W I ' 3 B ¤ b 6 ' ¤ ( 7 ¨ ¨ ¤ £ E ¨ § ¦ ¨ ¨ ¦ ¨ ¦ ! ¨ s<label>( 0 )</label></formula><formula xml:id="formula_11">4 R  ) d &amp; T U § )  q X q ) d &amp; S B ¤ e  V d 2 4 ) 2 4 R  ) d &amp; © U d )  a W p e) d ( g v x W d  a b 6 P  R Q e Y W  &amp; ) g t w U c ' X p X a W p e) d ( 8 v x W x  ! ¦ 4 3 ¦ £ " ¦ ' $ § ! " ¥ " $</formula><p>states that each object in the source or target of a message occurs in the collaboration diagram.  be an extended model. Consistency between views will be specified as four invariant clauses in¨£</p><formula xml:id="formula_12"> (  2 4 ) 2 4 R  ) d &amp; © U d ) d ( 8  a 2 d P ¤ R S b 6 U § ) g  P U c U 4 R S b d 2 ( e  q e'  b I B C ) d e 9   P U c U 4 R S b § 2 H # " $ ¨ £ ¢ £ © ¨ ¨ ¢ ¡ ¨ £ e A § © £ ) $ ¡ £' ¥ ¢ ¦ ) $ 5 D § ¦ e # ¦ ¨ $ © ¨ ¨ ' $ ¡ ¥ ¥ ¡ ¥ ¦ ¨ ¤ £ ) $ ¡ £' ¥</formula><formula xml:id="formula_13">in¨ in¨£ ¢ £ ¥ ¨ ¨ ¡ ¨ ¤ £ .</formula><p>For each clause, a PVS formulation is provided when it cannot be found in <ref type="bibr" target="#b10">[11]</ref> , respectively.)</p><p>1. Each object appearing in the collaboration diagram has a corresponding class in the class diagram.</p><formula xml:id="formula_14">" ! # ¡ ¡ ¢ &amp; ! 1 " ¥ " $ % ¡ # " ¡ ¢ ¦ ) $ © ¨ % ¢' £ ¢ ( £ $ £ ¥ ¨¨% ¨¨% ! ¢ £ $ " $ 1 D (Note that " ¡ ¢ ¦ ¨ $</formula><p>, defined in <ref type="bibr" target="#b10">[11]</ref>, is the set of abstractions appearing in the class diagram.) 2. Each message in the collaboration diagram has a corresponding routine call, and that call is permitted based on the list of accessors provided with each routine.</p><formula xml:id="formula_15">" " $ © # ¡ ¤ ¡ ¢$ ¦ £ ¨ £ ¦ " £ % " ! # " $ © ¢$ ¦ ! ¥ ¢ ¢ £ % ! ¢ £ $ " $ # " $ © ¢¥ ! ' § £ ¤ ¢ ¤ " " £ ¨ $ " $ ¦ ! # ¥ " $</formula><p>3. Each routine appearing in a message must actually belong to the target class of the message (i.e., routines that are called must exist). This will be checked by the compiler/CASE tool and as such we do not specify it here. However, it is captured in the full specification of the BON metamodel referenced in <ref type="bibr" target="#b10">[11]</ref>. The constraint in <ref type="bibr" target="#b10">[11]</ref> is more general in that it checks all features (including attributes) to ensure that they exist. This ensures that if a message is sent from one object to another, there is a link between the two objects. 4. The constraint in (2) establishes that each message in a collaboration diagram corresponds to a routine call. The routines that are called must be enabled (i.e., their preconditions must be true). A precondition can only be true if the sequence of previous calls to routines left the state of the system satisfying the precondition. To check this, an initial state, § § '</p><p>, must be provided (by the developer). The following condition must be true</p><formula xml:id="formula_16">. § 0 § ' U T ¡ ¤ ¡ ¢ &amp; £ ¤ £$ £ ¢ § ' ( £ " F © R ¥ ¢ ( ¥ £</formula><p>i.e., the developer-supplied initial state (specified as a predicate) must imply the precondition of the first element in the sequence of calls in the collaboration diagram. . This results in a double-state predicate (i.e., in the user-supplied initial state and in the post-state of call § f ). We then project out the post-state and check that the result satisfies the pre-state of call § . Formally:</p><formula xml:id="formula_17">" § Y $ 6¢¢6 1 ¡ ¡ ¢ ) £ ¤ £$ £ ¢££ ¦ © ¤ ' ¢ % ¡ ¡ ¤ ¡ ¢ ! " ¥ " $ &amp; % F ¡ ¡ ¢ &amp; £ ¤ £$ £ ¢ § ' £ " g F © R ¥ ¢$ ( £ " ¢ ¢ ¢ ¡ ¤ ¡ ¢ &amp; £ ¤ £$ £ ¢ § ' ( £ " F § f S R¢$ ( £ " © R T ¡ ¤ ¡ ¢ £ ¤ £$ ¤ ¢ § ' ( £ 7 " g F § R ¥ ¢ ( ¥ £</formula><p>(Recall that the definition of sequential composition is:</p><formula xml:id="formula_18">0 D ¡ $ ¡ £ ¢ ¡ 2 $ 8 $D $ ¡ 4 V 0 2 I £ B P $ % $D $ ¡ 4</formula><p>where $ is an intermediate state, i.e., for every sequential composition, there is an implicit existential quantification that needs to be instantiated and simplified.) is translated to a function mapping a model and a set of entities (the state) to a boolean. The second part is much more challenging. The complexity lies in formalizing the definition of sequential composition: an explicit specification of the state of a routine is required so as to capture the frame of each specification, and to be able to define an intermediate state. seqspecs must be lifted to apply to a finite sequence of specifications in order to formalize constraint (4). This is expressed as function seqspecsn. To complete the PVS formalization of constraint <ref type="formula">(4)</ref>, we define a function to convert a sequence of messages into a finite sequence of SPECTYPEs. Effectively, this extracts the routines from the messages and produces specifications from them. This axiom first declares a local variable, loc_spec, which is the result of sequentially composing the first § specifications in messages in the model. This specification must then imply the precondition of the routine of message § in the model. To use the axiom, we can specify a set of BON models as PVS conjectures, following the approach presented in <ref type="bibr" target="#b10">[11]</ref>. These conjectures effectively posit that the set of models can exist. They must therefore satisfy the consistency constraints. We can then use PVS to import the view consistency axiom as above, and attempt to prove or disprove that the axiom is satisfied by the models.</p><p>Aside. We have not proved the correctness of the translation from BON constraints to PVS axioms and types. In general, proving the correctness of translations for large, full-featured languages, is extremely difficult. We view our PVS specification of the metamodel as a mechanism by which the translation can be tested. We can write conjectures about properties that we would like the metamodel to have, and can use the PVS system to prove or disprove the conjectures. This will give us greater confidence in the correctness of the metamodel and the translation. End of Aside. This is a specification of a consistency relation for collaboration diagrams and class diagrams. We might prefer to have an algorithmic description of the consistency checking process; however, we view an algorithmic description as an implementation of the consistency relation above. The next subsection briefly suggests how the BON CASE tool might support this consistency checking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Implementation and algorithms</head><p>A sketch of an implementation for consistency checking of collaboration diagrams and class diagrams is as follows. First, assume that rules (1), (2), and (3) above, have been checked -this is straightforward and can easily be implemented in the CASE tool framework of <ref type="bibr" target="#b8">[9]</ref> (in fact, most of these rules have already been implemented). Rule (4) is to be checked, informally, as follows: convert the collaboration diagram into an annotated finite state machine (FSM), following this algorithm. Given a user-supplied initial state (specified as an assignment of values to entities), simulate the finite state machine. Each state in the machine represents the execution of a routine; a transition represents the termination of one message and the commencement of the next. On entry to the state, the precondition of the routine is checked; if it is satisfied, simulation continues, otherwise it halts and feedback is provided. On exiting the state, the specification of the routine (i.e.,</p><formula xml:id="formula_19">¥ ! ' § £ ¤ ¢$ ( £ ¢</formula><p>, as above) is added to a constraint store. This constraint store might be a set of conjectures in PVS. One might envision PVS running in the background, discharging obligations as they are generated by the simulation. An alternative to using PVS would be to consider a constraint store akin to that used in constraint programming. A constraint solver could then be applied as each new condition is added.</p><p>To complete the implementation, we must indicate how the "next state" in the state machine is selected. This is done according to sequence number. So, after executing in state ¢ (representing the call ¢ ) which has sequence number , the next state will be the one reachable with sequence number</p><p>. This, of course, assumes that the sequence numbers are contiguous.</p><p>Producing a FSM from a collaboration diagram is straightforward and follows the approach of <ref type="bibr" target="#b2">[3]</ref>. We produce a FSM because it is a simple computational model and it is easy to implement; it is also sufficient for simulating BON collaboration diagrams. Much of the complexity of the translation in <ref type="bibr" target="#b2">[3]</ref> arises from UML's sequence diagrams (including concepts such as return calls, exception handling, and nesting). These problems do not in general arise in BON collaboration diagrams. The above algorithm is currently being implemented in the BON CASE tool of <ref type="bibr" target="#b8">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Checking Collaboration Diagrams against Test Drivers</head><p>We have shown how to directly check collaboration diagrams with class diagrams for consistency. When developing software using the methodology of <ref type="bibr" target="#b12">[13]</ref>, it is possible that developers will have constructed test drivers before models. These can be used not only for the usual testing purposes but also in the consistency checking process, as sketched in Section 3: consistency of class diagrams and collaboration diagrams can be checked transitively via checking collaboration diagrams against test drivers. We briefly sketch how this might be done.</p><p>Assume that we have written a test driver, e.g., in Eiffel. A test driver is a class with a method that creates objects and generates a sequence of messages. An example might be as follows.</p><formula xml:id="formula_20">¢ ¤ £ ¦ ¥ ¨ § © § £ E ¨ £ ¦ 9 ¡ y ¨ ¢ ¥ ( ¡ ¨ ) ( A '  ) ¥ © ! b % 7 ¨ G g Q ¡ ¤ £ g " 9 2 F 7 S ¨ g £ &amp; g 7 S r $ " E ¨ ! ' A 7 § ¦ ¦ 9 ¨  ( '  ) ( § 6 ¢ ¢ ¥ b 1 ¢ ¥ 2 ¢ ¥ &amp; ¢ ¥ ' b C B C ) d e X q ) 6 '  ` ¤ 2 ! 2 ¤ B C ) d e &amp; T ) 6 5 ¤ e &amp; 4 R ¤ £ C ) d b 1 &amp; B C ) d e '  ` ` ¤ b c ) d 2 c 2 F '  H © b § W p &amp;  e ) ! 6 ) 7 6 9 8 £ E ¨ £ ¦ 9 ¡ y ¨</formula><p>We want to determine if the sequence of calls appearing in the test driver is an implementation of the calls appearing in the collaboration diagram. Unfortunately, we cannot just take the FSM constructed in the algorithm of Section 4.1 and simulate it directly. This is insufficient because the test driver may make calls to routines that do not appear in the collaboration diagram (i.e., implementation details). Instead, we take a metamodelling approach. We first specify the concept of a test driver, and then describe the consistency constraints that test drivers and collaboration diagrams must obey. We only sketch the approach here; details can be found in <ref type="bibr" target="#b13">[14]</ref>.</p><p>A describing separate views, as well as further formulae specifying environmental information, e.g., relationships between views. Consistency or inconsistency checking can be carried out using automated theorem provers. The ADORA project <ref type="bibr" target="#b3">[4]</ref> presents an alternative to UML for OO modelling, wherein all information related to a system is integrated into one coherent model. In this latter regard, it is similar to the single model principle described in <ref type="bibr" target="#b11">[12]</ref>. The integrated model allows consistency constraints to be defined between views. A language and tool for supporting these constraints is discussed in <ref type="bibr" target="#b14">[15]</ref>. Some of the constraints that are checked by this tool are also captured in the UML metamodel, and as such are checked by UML-compliant CASE tools.</p><p>Tsiolakis <ref type="bibr" target="#b15">[16]</ref> focuses specifically on consistency checking with the UML, primarily, consistency checks relating class diagrams, sequence diagrams, and state charts. In their approach, diagrams are annotated with extra information relating the separate views, and attributed graph grammars are used as a theoretical underpinning to carry out the consistency checking.</p><p>Our current focus is on implementing the consistency checking described in this paper. Many of the rules are currently built in to the metamodel implementation provided with the tool. The architecture of the tool makes it straightforward to add new rules to the metamodel, or to replace the metamodel entirely with a new set of rules. The basic architecture is shown in <ref type="figure" target="#fig_13">Fig. 5</ref>. Some of the consistency checking cannot be carried out automatically or implemented in the metamodel, e.g., checking that the sequence of messages appearing in a collaboration diagram is allowable, based on contracts. The checks will be sent to the PVS theorem prover and discharged automatically where possible. The paper <ref type="bibr" target="#b10">[11]</ref> describes how we have successfully used PVS for semi-automatically proving that models satisfy the BON metamodel; the same approach can be used for consistency checking between views. As well, we are currently exploring the use of automated verification technology, particularly FDR, for carrying out the sequencing consistency checks. This will also be very useful for consistency checking of test drivers against collaboration diagrams, since we can effectively represent this as a constraint to be checked on traces.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. BON collaboration diagram (without a scenario box)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Work products and their relationships</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. BON metamodel, abstract view</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>FEATURE</head><label></label><figDesc>: TYPE+ ATTRIBUTE, ROUTINE: TYPE+ FROM FEATURE routine_name: [ ROUTINE -&gt; string ] feature_pre: [ ROUTINE, set[ENTITY] -&gt; bool ] feature_post: [ ROUTINE, set[ENTITY], set[ENTITY] -&gt; bool]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>spec: [ ROUTINE, set[ENTITY], set[ENTITY] -&gt; SPECTYPE ] spec_ax: AXIOM (FORALL (rou1:ROUTINE): (FORALL (c:CLASS): (member(rou1,class_features(c)) IMPLIES (spec(rou1,oldstate(rou1,c),newstate(rou1,c)) = (# old_state := oldstate(rou1,c), new_state := newstate(rou1,c), value := (LAMBDA (o:{p1:set[ENTITY] | p1=oldstate(rou1,c)}), (n:{p2:set[ENTITY] | p2=newstate(rou1,c)}):</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>element © occurs before © in the sequence. In producing the PVS formalization of¨¨ of¨ of¨¨ 1 0 ¨ ¨</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>collab_diagram_ax: AXIOM (FORALL (mod1:MODEL): abst(collab_diagram(mod1)) = { da:DYN_ABS | member(da,abst(mod1))} AND rels(collab_diagram(mod1)) = { m:MESSAGE | member(m,rels(mod1)) }) Let ¤ "</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Expressing constraint ( 4 )</head><label>4</label><figDesc>in PVS is challenging. The first part, enabling the first message in the collaboration diagram, can be done as follows. § 0 § '</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>init: [ MODEL, set[ENTITY] -&gt; bool ] init_ax: AXIOM (FORALL (mod1:MODEL): (FORALL (old_s:set[ENTITY]): init(mod1,old_s) IMPLIES feature_pre(calls_model(mod1)(0),old_s)))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Sequential composition 0 can be formalized in PVS as follows, using function seqspecs. It takes as argument two variables of type SPECTYPE and returns a SPECTYPE result, representing the sequential composition of the arguments. seqspecs: [ SPECTYPE, SPECTYPE -&gt; SPECTYPE ] seqspecs_ax: AXIOM (FORALL (s1,s2: SPECTYPE): seqspecs(s1,s2) = (# old_state := old_state(s1), new_state := new_state(s2), value := (LAMBDA (o:{p1:set[ENTITY] | p1=old_state(s1)}), (n:{p2:set[ENTITY] | p2=new_state(s2)}): (EXISTS (i: set[ENTITY]): value(s1)(o,i) AND value(s2)(i,n))) #) )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>seqspecsn: [ finseq[SPECTYPE] -&gt; SPECTYPE ] seqspecsn_ax1: AXIOM (FORALL (seq1: finseq[SPECTYPE]): length(seq1)=2 IMPLIES seqspecsn(seq1) = seqspecs(seq1(0),seq1(1))) seqspecsn_ax2: AXIOM (FORALL (seq1:finseq[SPECTYPE]): length(seq1)&gt;2 IMPLIES seqspecsn(seq1) = seqspecs(seq1(0),seqspecsn(rest(seq1))))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>convert: [ finseq[MESSAGE] -&gt; finseq[SPECTYPE] ] convert_ax: AXIOM (FORALL (msgs1:finseq[MESSAGE]): length(msgs1)=length(convert(msgs1)) AND (FORALL (i:{j:nat|j&lt;length(msgs1)}): (EXISTS (c:CLASS): member(routine_message(msgs1(i)),class_features(c)) IMPLIES convert(msgs1)(i) = spec(routine_message(msgs1(i)), oldstate(routine_message(msgs1(i)),c), newstate(routine_message(msgs1(i)),c))))) Now the view consistency constraint can be formally expressed in PVS. views_consistent: AXIOM (FORALL (mod1:MODEL): (FORALL (i:{j:nat|0&lt;j AND j&lt;length(calls_model(mod1))}): LET loc_spec:SPECTYPE = (seqspecsn(convert(sequence_model(mod1)ˆ(0,i-1)))) IN (EXISTS (new:set[ENTITY]): value(loc_spec)(old_state(loc_spec),new_state(loc_spec)) IMPLIES feature_pre(calls_model(mod1)(i), oldstate(calls_model(mod1)(i), object_class(msg_target(sequence_model(mod1)(i))))))))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Architecture of the BON CASE tool</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head></head><label></label><figDesc>slightly using inheritance, and introduce several new features for checking the consistency of class diagrams and collaboration diagrams. In particular, we add a feature representing the set of objects appearing in a model, the sequence of messages and routine calls appearing in a collaboration diagram, a scenario box (a free-form block of text describing what is represented by the messages), and queries for producing the collaboration diagram view and the class diagram view from the single model. As well, invariant clauses are added to the extension of ¡ ¨ ¤ £ ; further clauses will be added shortly for checking the consistency of the views. Here is the interface of¨£</figDesc><table>In this way, 
consistency of views is guaranteed. Thus, in the metamodel for BON, there 
is a unique class, 


¢ ¡ 


¨ 

¤ £ 

, defining the well-formedness constraints on mod-
els. Features of this class can be used to generate views. New views can be 
added by inheriting from 


¢ ¡ 


¨ 

¤ £ 

and adding new features. It is not within 
the spirit of BON to add new views by adding new subclasses of 


¢ ¡ 


¨ 

¤ £ 

, 

1 The specification supports an arbitrary number of collaboration diagrams and class diagrams 
in a model. 

e.g., 

¡ 

© 

¥ 


¡ 



¡ 


¨ 

¤ £ 

, etc., as this can easily introduce inconsistency be-
tween views. 

The existing class 


¢ ¡ 


¨ 

¤ £ 

includes all features and constraints necessary to model 
collaboration diagrams. However, it is inconvenient to use for validating the consis-
tency of class diagrams and collaboration diagrams directly. Thus, for convenience, we 
restructure 


¢ ¡ 


¨ 

¤ £ 

of¨ 

of¨£ ¢ 

£ 
© ¨ 


¨ 



¢ ¡ 


¨ 

£ 

. Note that all new features, with the exception of those for 
generating new views, are private. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head></head><label></label><figDesc>in PVS, we could introduce a new subtype (representing the type of extended models), and then could map each new routine and constraint in the BON class to a PVS function. However, a new PVS subtype is not strictly needed, since PVS does not provide the object-oriented structuring facilities of BON. Thus, adding new functions or attributes to the PVS specification is in fact eas- ier than adding new features to classes in BON. The translation process is as follows. We introduce new functions (that operate on variables of type MODEL) representing the additional features that we require, i.e., representing class diagrams, collaboration diagrams, etc.</figDesc><table>¢¥ 

£ 
£$ 

5 D 

¦ 

¥ 

# 

¥ 
£ 
£$ 

© ¨ 

¥ 

$ 

¨ 

¨¨¥ 

&amp; 

¨ 

To express¨£ 

express¨ 

express¨£ ¢ 

£ 
© ¨ 


¨ 



¡ 


¨ 

¤ £ 

objects_model: [ MODEL -&gt; set[OBJECT] ] 
sequence_model: [ MODEL -&gt; finseq[MESSAGE] ] 
calls_model: 
[ MODEL -&gt; finseq[ROUTINE] ] 

class_diagram collab_diagram: [ MODEL -&gt; MODEL ] 

The invariant clauses in¨£ 

in¨ 

in¨£ ¢ 

£ 
© ¨ 


¨ 



¢ ¡ 


¨ 

¤ £ 

will each be mapped to PVS ax-
ioms. Here is an example, stating that 

£ 
¤ £$ 

is a projection of 

$ 
¦ £ 
¥ ¨ 


£ 
¦ 
" £ 

(the other axioms 
are straightforward translations of the BON constraints). 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>.</head><label></label><figDesc></figDesc><table>(In the following, we use 

¡ 
¤ ¡ 

to stand for 

¢ ! 
£ 
¤ £ 
¦ 

¡ 
#  § 

¦ 

© 

¥ 

) 
# " 

and 

" ¡ 

for 

£ 

$ 
" $ 
¡ 
#  § 

¦ 

© 

¥ 

H 
" 

</table></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S v</head><p>x e x  6  An implementation of¨</p><p>, in terms of abstract syntax trees and direct simulation of the collaboration diagram, is outlined in <ref type="bibr" target="#b13">[14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Related Work and Conclusions</head><p>The introduction of the UML has spurred much recent research on consistency checking, but the topic has been of past interest and study. Zave and Jackson <ref type="bibr" target="#b17">[18]</ref> presented a framework for composing specifications via conjunction, with the aim of supporting multi-paradigm specification. In their approach, specifications are transformed in to a common semantic domain (in <ref type="bibr" target="#b17">[18]</ref>, they use one-sorted first order logic, but different semantic domains can be chosen) and thereafter combined. They pay particular attention to constructing translations to the common semantic domain so that specifications can be easily and usefully composed, e.g., so as to make consistency checking as straightforward as possible to carry out. The authors' goal is not specifically consistency checking, but suggestions and recommendations as to how to use the approach to make consistency checking easier to carry out are provided. They do not specifically focus on the OO realm, and do not explicitly consider tool support. They recognize the problem of semantic fragmentation, i.e., providing a non-standard semantics to commonly used languages.</p><p>Finkelstein et al. <ref type="bibr" target="#b5">[6]</ref> focus specifically on the problem of detecting inconsistency when combining descriptions of systems from multiple viewpoints. Their work emphasizes that inconsistency is not always undesirable, and that in fact it may provide important information to developers, e.g., related to misunderstandings or confusion with respect to requirements. Thus, their logical framework aims to support developers in identifying inconsistencies and specifying actions to carry out on their identification. Consistency checking is carried out by producing a logical database of formulae</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Extreme Programming Explained, AWL</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Beck</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Booch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rumbaugh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Jacobson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The UML Reference Guide</title>
		<imprint>
			<date type="published" when="1999" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A UML-Based Approach to System Testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Briand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Labiche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. UML 2001</title>
		<meeting>UML 2001</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001" />
			<biblScope unit="volume">2185</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The ADORA Approach to Object-Oriented Modeling of Software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Glinz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Berner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Joos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ryser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Schett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Xia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CAiSE&apos;01</title>
		<meeting>CAiSE&apos;01</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001-06" />
			<biblScope unit="volume">2068</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Eiffel -The Language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992" />
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Inconsistency Handling in Multi-Perspective Specification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Finkelstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gabbay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hunter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Nuseibeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Engineering</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">8</biblScope>
			<date type="published" when="1994-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
				<title level="m">OMG Consortium, UML 1.4 Documentation, 2000. Available at www.omg.org</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Owre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shankar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rushby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Stringer-Calvert</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-11" />
		</imprint>
	</monogr>
	<note>PVS System Guide 2.4, CSL, SRI International</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">A Tool-Supported Integration of BON and JML</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kaminskaya</surname></persName>
		</author>
		<idno>CS-TR-2001-04</idno>
		<imprint>
			<date type="published" when="2001-07" />
		</imprint>
		<respStmt>
			<orgName>York University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Developing BON as an industrial-strength formal method</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Ostroff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. World Congress on Formal Methods</title>
		<meeting>World Congress on Formal Methods</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999-09" />
			<biblScope unit="volume">1709</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Metamodelling and conformance checking with PVS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Ostroff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Fundamental Aspects of Software Engineering</title>
		<meeting>Fundamental Aspects of Software Engineering</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001-04" />
			<biblScope unit="volume">2029</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The Single Model Principle (Extended Abstract)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Ostroff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Requirements Engineering</title>
		<meeting>Requirements Engineering</meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2001-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Proposal for a UML-Based Method for Developing Reliable Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Ostroff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop on Precise UML-Based Methods</title>
		<meeting>Workshop on Precise UML-Based Methods</meeting>
		<imprint>
			<publisher>German Society</publisher>
			<date type="published" when="2001-10" />
			<biblScope unit="volume">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Checking the Consistency of Views in PVS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">F</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Ostroff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Brooke</surname></persName>
		</author>
		<idno>TR-CS-2002-01</idno>
		<imprint>
			<date type="published" when="2002-02" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, York University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A Notation for Integrity Constraints in ADORA Models -Concept and Implementation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Schett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Diplomathesis</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
		<respStmt>
			<orgName>University of Zurich</orgName>
		</respStmt>
	</monogr>
	<note>in German</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Semantic Analysis and Consistency Checking of UML Sequence Diagrams. Diplomarbeit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tsiolakis</surname></persName>
		</author>
		<idno>TR 2001-06</idno>
		<imprint>
			<date type="published" when="2001-04" />
		</imprint>
		<respStmt>
			<orgName>TU-Berlin</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Seamless Object-Oriented Software Architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Walden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-M</forename><surname>Nerson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<publisher>PrenticeHall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Conjunction as Composition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Zave</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jackson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1993-10" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
