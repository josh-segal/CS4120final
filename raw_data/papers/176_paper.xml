<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:32+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Automatically Inferring Quantified Loop Invariants by Algorithmic Learning from Simple Templates</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Soonho</forename><surname>Kong</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Seoul National University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yungbum</forename><surname>Jung</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Seoul National University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cristina</forename><surname>David</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">National University of Singapore</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bow-Yaw</forename><surname>Wang</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Academia Sinica</orgName>
								<orgName type="institution" key="instit1">INRIA</orgName>
								<orgName type="institution" key="instit2">Tsinghua University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kwangkeun</forename><surname>Yi</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Seoul National University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Automatically Inferring Quantified Loop Invariants by Algorithmic Learning from Simple Templates</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>By combining algorithmic learning, decision procedures, predicate abstraction, and simple templates, we present an automated technique for finding quantified loop invariants. Our technique can find arbitrary first-order invariants (modulo a fixed set of atomic propositions and an underlying SMT solver) in the form of the given template and exploits the flexibility in invariants by a simple randomized mechanism. The proposed technique is able to find quantified invariants for loops from the Linux source, as well as for the benchmark code used in the previous works. Our contribution is a simpler technique than the previous works yet with a reasonable derivation power.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Recently, algorithmic learning has been successfully applied to invariant generation. The new approach formalizes the invariant generation problem as an instance of algorithmic learning: to generate an invariant is to learn a concept from a teacher. Using a learning algorithm as a black box, one only needs to design a mechanical teacher that guides the learning algorithm to invariants. The learning-based framework not only simplifies the invariant generation algorithms, the new approach can also automatically generate invariants for realistic C loops at a reasonable cost <ref type="bibr" target="#b14">[15]</ref>. <ref type="figure" target="#fig_2">Figure 1</ref> shows the new framework proposed in <ref type="bibr" target="#b14">[15]</ref>. In the figure, the CDNF algorithm is used to drive the search of quantifier-free invariants. The CDNF algorithm is an exact learning algorithm for Boolean formulae. It computes a  <ref type="bibr">(Grant 2010-0001717)</ref>. This work was partly supported by MoE Tier-2 grant R-252-000-411-112 and by the National Science Council of Taiwan projects No. NSC97-2221-E-001-003-MY3, NSC97-2221-E-001-006-MY3, the FORMES Project within LIAMA Consortium, and the French ANR project SIVES ANR-08-BLAN-0326-01 <ref type="figure" target="#fig_2">Fig. 1</ref>. The learning-based framework representation of an unknown target formula by asking a teacher two types of queries. A membership query asks if a valuation to Boolean variables satisfies the unknown target; an equivalence query asks if a candidate formula is equivalent to the target. With predicate abstraction, the new approach formulates an unknown quantifier-free invariant as the unknown target Boolean formula. One only needs to automate the query resolution process to infer an invariant.</p><p>If an invariant was known, a mechanical teacher to resove queries can be implemented straightforwardly. In the context of invariant generation, no invariant is known. However, a simple randomized automatic teacher is proposed in <ref type="bibr" target="#b14">[15]</ref>. With the help of SMT solvers, user-provided annotations, and coin tossing, one can resolve both types of queries by a simple reduction to the satisfiability problem of quantifier-free formulae. An ingenious feature of this design is its random walk. Due to the lack of information, some queries cannot be resolved decisively. In this case, the teacher simply gives a random answer. The learning algorithm will then look for invariants consistent with both decisive and random answers from the teacher. Since there are sufficiently many invariants for an annotated loop in practice, almost certainly the learning algorithm can find one.</p><p>The work <ref type="bibr" target="#b14">[15]</ref> has, however, one obvious limitation; it can only generate quantifier-free invariants. Yet loops iterating over arrays often require invariants quantified over indices. It will be very useful to extend the new approach to quantified invariants. However, a na¨ıvena¨ıve extension would not work. First of all, it is not clear how to associate an arbitrarily quantified formula with a quantified Boolean formula. There is no counterpart (a Boolean formula) for quantified variables in, say, ∀i.i &gt; 10. Second, there is no exact learning algorithm for quantified Boolean formulae to the best of our knowledge. Even if an abstraction for quantified formulae was available, we could not adopt the same learningbased framework. Third, computability issues must be addressed because the satisfiability problem for arbitrarily quantified formulae is undecidable. Developing an effective invariant generation algorithm for quantified invariants is therefore an interesting challenge to the learning-based framework.</p><p>This article is about our findings in generating quantified invariants with algorithmic learning:</p><p>-We show that a simple combination of algorithmic learning, decision procedures, predicate abstraction, and templates can automatically infer quantified loop invariants. The technique is as powerful as the previous approaches <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b19">20]</ref> yet is much simpler. -The technique needs a very simple template such as "∀k.[]" or "∀k.∃i.[]."</p><p>Our algorithm can generate any quantified invariants expressible by a fixed set of atomic propositions in the form of the given template. Moreover, the correctness of generated invariants is verified by an SMT solver. -The technique works in realistic settings: The proposed technique can find quantified invariants for some Linux library, kernel, and device driver sources, as well as for the benchmark code used in the previous work <ref type="bibr" target="#b19">[20]</ref>. -The technique's future improvement is free. Since our algorithm uses the two key technologies (exact learning algorithm and decision procedures) as black boxes, future advances of these technologies will straightforwardly benefit our approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Motivating Example</head><p>In order to illustrate how our algorithm works, we briefly describe the learning process for the max example from <ref type="bibr" target="#b19">[20]</ref>. Template and Atomic Propositions A template and atomic propositions are provided manually by user. We provide the template ∀k.[]. The postcondition is universally quantified with k and gives a hint to the form of an invariant. By extracting from the annotated loop and adding the last two atomic propositions from the user's guidance, we use the following set of atomic propositions:</p><formula xml:id="formula_0">{m = 0 ∧ i = 0} while i &lt; n do if a[m] &lt; a[i] then m = i fi; i = i + 1 end {∀k.k &lt; n ⇒ a[k] ≤ a[m]}</formula><formula xml:id="formula_1">{i &lt; n, m = 0, i = 0, a[m] &lt; a[i], a[k] ≤ a[m], k &lt; n, k &lt; i}.</formula><p>Query Resolution In this example, 20 membership queries and 6 equivalence queries are made by the learning algorithm on average. For simplicity, let us find an invariant that is weaker than the precondition but stronger than the postcondition. We describe how the teacher resolves some of these queries.</p><p>-Equivalence Query: The learning algorithm starts with an equivalence query EQ(T), namely whether ∀k.T can be an invariant. The teacher answers NO since ∀k.T is weaker than the postcondition. Additionally, by employing an SMT solver, the teacher returns a counterexample {m = 0, k = 1, n = 2, i = 2, a[0] = 0, a[1] = 1}, under which ∀k.T evaluates to true, whereas the postcondition evaluates to false.</p><p>-Membership Query: After a few equivalence queries, a membership query asks whether {i ≥ n, m = 0,</p><formula xml:id="formula_2">i = 0, k ≥ n, a[k] ≤ a[m], a[m] ≥ a[i]</formula><p>} is a part of an invariant. The teacher replies YES since the query is included in the precondition and therefore should also be included in an invariant. -Membership Query: The membership query MEM (</p><formula xml:id="formula_3">{i &lt; n, m = 0, i = 0, k &lt; n, a[k] &gt; a[m], k &lt; i, a[m] ≥ a[i]})</formula><p>is not resolvable because the template is not well-formed (Definition 1) by the given membership query. In this case, the teacher gives a random answer (YES or NO). Interestingly, each answer leads to a different invariant for this query. If the answer is YES , we find an invariant ∀k.</p><formula xml:id="formula_4">(i &lt; n ∧ k ≥ i) ∨ (a[k] ≤ a[m]) ∨ (k ≥ n); if the answer is NO, we find another invariant ∀k.(i &lt; n ∧ k ≥ i) ∨ (a[k] ≤ a[m]) ∨ (k ≥ n ∧ k ≥ i)</formula><p>. This shows how our approach exploits a multitude of invariants for the annotated loop.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Organization</head><p>We organize this paper as follows. After preliminaries in Section 2, we present problems and solutions in Section 3. Our abstraction is briefly described in Section 4. The details of our technique are described in Section 5. We report experiments in Section 6, discuss related work in Section 7, then conclude in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>The abstract syntax of our simple imperative language is given below:</p><formula xml:id="formula_5">Stmt = nop | Stmt; Stmt | x := Exp | b := Prop | a[Exp] := Exp | a[Exp] := nondet | x := nondet | b := nondet | if Prop then Stmt else Stmt | { Pred } while Prop do Stmt { Pred } Exp = n | x | a[Exp] | Exp + Exp | Exp − Exp Prop = F | b | ¬Prop | Prop ∧ Prop | Exp &lt; Exp | Exp = Exp Pred = Prop | ∀x.Pred | ∃x.Pred | Pred ∧ Pred | ¬Pred</formula><p>The language has two basic types: Booleans and natural numbers. A term in Exp is a natural number; a term in Prop is a quantifier-free formula and of Boolean type; a term in Pred is a first-order formula. The keyword nondet is used for unknown values from user's input or complex structures (e.g, pointer operations, function calls, etc.). In an annotated loop {δ} while κ do S {}, κ ∈ Prop is its guard, and δ, ∈ Pred are its precondition and postcondition respectively. Quantifier-free formulae of the forms b, π 0 &lt; π 1 , and π 0 = π 1 are called atomic propositions. If A is a set of atomic propositions, then Prop A and Pred A denote the set of quantifier-free and first-order formulae generated from A, respectively.</p><p>A template t[] ∈ τ is a finite sequence of quantifiers followed by a hole to be filled with a quantifier-free formula in Prop A .</p><formula xml:id="formula_6">τ = [] | ∀I.τ | ∃I.τ.</formula><p>Let θ ∈ Prop A be a quantifier-free formula. We write t <ref type="bibr">[θ]</ref> to denote the first-order formula obtained by replacing the hole in t[] with θ. Observe that any first-order formula can be transformed into the prenex normal form; it can be expressed in the form of a proper template.</p><p>A precondition Pre(ρ, S) for ρ ∈ Pred with respect to a statement S is a first-order formula that guarantees ρ after the execution of the statement S. Let {δ} while κ do S {} be an annotated loop and t[] ∈ τ be a template. The invariant generation problem with template t[] is to compute a first-order formula</p><formula xml:id="formula_7">t[θ] such that (1) δ ⇒ t[θ]; (2) ¬κ ∧ t[θ] ⇒ ; and (3) κ ∧ t[θ] ⇒ Pre(t[θ], S). Observe that the condition (2) is equivalent to t[θ] ⇒ ∨ κ. We have δ ⇒ t[θ] and t[θ] ⇒ ∨ κ for any invariant t[θ]</formula><p>. δ and ∨ κ are subsequently called the strongest under-approximation and weakest over-approximation to invariants respectively.</p><p>A valuation ν is an assignment of natural numbers to integer variables and truth values to Boolean variables. If A is a set of atomic propositions and Var (A) is the set of variables occurred in A, Val Var (A) denotes the set of valuations for Var (A). A valuation ν is a model of a first-order formula ρ (written ν |= ρ) if ρ evaluates to T under ν. Let B be a set of Boolean variables. We write Bool B for the class of Boolean formulae over Boolean variables B. A Boolean valuation µ is an assignment of truth values to Boolean variables. The set of Boolean valuations for B is denoted by Val B . A Boolean valuation µ is a Boolean model of the Boolean formula β (written µ |= β) if β evaluates to T under µ.</p><p>Given a first-order formula ρ, a satisfiability modulo theories (SMT) solver <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b15">16]</ref> returns a model of ν if it exists. In general, SMT solver is incomplete over quantified formulae and may return a potential model (written SMT (ρ) ! → ν). It returns UNSAT (written SMT (ρ) → UNSAT ) if the solver proves the formula unsatisfiable. Note that an SMT solver can only err when it returns a (potential) model. If UNSAT is returned, the input formula is certainly unsatisfiable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CDNF Learning Algorithm [3] The CDNF (Conjunctive Disjunctive Normal</head><p>Form) algorithm is an exact algorithm that computes a representation for any target λ ∈ Bool B by asking a teacher queries. The teacher is required to resolve two types of queries:</p><p>-Membership query MEM (µ) where µ ∈ Val B . If the valuation µ is a Boolean model of the target Boolean formula λ, the teacher answers YES . Otherwise, the teacher answers NO; -Equivalence query EQ(β) where β ∈ Bool B . If the target Boolean formula λ is equivalent to β, the teacher answers YES . Otherwise, the teacher gives a counterexample. A counterexample is a valuation µ ∈ Val B such that β and λ evaluate to different truth values under µ.</p><p>For a Boolean formula λ ∈ Bool B , define |λ| CNF and |λ| DNF to be the sizes of minimal Boolean formulae equivalent to λ in conjunctive and disjunctive normal forms respectively. The CDNF algorithm infers any target Boolean formula λ ∈ Bool B with a polynomial number of queries in |λ| CNF , |λ| DNF , and |B| <ref type="bibr" target="#b2">[3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Problems and Solutions</head><p>Given an annotated loop and a template, we apply algorithmic learning to find an invariant in the form of the given template. We follow the framework proposed in <ref type="bibr" target="#b14">[15]</ref> and deploy the CDNF algorithm to drive the search of invariants. Since the learning algorithm assumes a teacher to answer queries, it remains to mechanize the query resolution process <ref type="figure" target="#fig_2">(Figure 1</ref>). Let t[] be the given template and t[θ] an invariant. We will devise a teacher to guide the CDNF algorithm to infer t <ref type="bibr">[θ]</ref>.</p><p>To achieve this goal, we need to address two problems. First, the CDNF algorithm is a learning algorithm for Boolean formulae, not quantifier-free nor quantified formulae. Second, the CDNF algorithm assumes a teacher who knows the target t <ref type="bibr">[θ]</ref> in its learning model. However, an invariant of the given annotated loop is yet to be computed and hence unknown to us. We need to devise a teacher without assuming any particular invariant t <ref type="bibr">[θ]</ref>.</p><p>For the first problem, we adopt predicate abstraction to associate Boolean formulae with quantified formulae. Recall that the formula θ in the invariant t <ref type="bibr">[θ]</ref> is quantifier-free. Let α be an abstraction function from quantifier-free to Boolean formulae. Then λ = α(θ) is a Boolean formula and serves as the target function to be inferred by the CDNF algorithm.</p><p>For the second problem, we need to design algorithms to resolve queries about the Boolean formula λ without knowing t <ref type="bibr">[θ]</ref>. This is achieved by exploiting the information derived from annotations and by making a few random guesses. Recall that any invariant must be weaker than the strongest under-approximation and stronger than the weakest over-approximation. Using an SMT solver, queries can be resolved by comparing with these invariant approximations. For queries unresolvable through approximations, we simply give random answers.</p><p>Following a similar framework to <ref type="bibr" target="#b14">[15]</ref>, we are able to infer quantified invariants of a given template for annotated loops. Our solution to the quantified invariant generation problem for annotated loops is in fact very general. It only requires users to provide a sequence of quantifiers and a fixed set of atomic propositions. With a number of coin tossing, our technique can infer arbitrary quantified invariants representable by the user inputs. This suggests that the algorithmic learning approach to invariant generation has great potential in invariant generation problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Predicate Abstraction with a Template</head><p>We begin with the association between Boolean formulae and first-order formulae in the form of a given template. Let A be a set of atomic propositions and B(A) = {b p : p ∈ A} the set of corresponding Boolean variables. <ref type="figure" target="#fig_3">Figure 2</ref> shows the abstraction used in our algorithm. The left box represents the class Pred A of first-order formulae generated from A. Boolean formulae over the Boolean variables B(A). The CDNF algorithm infers a target Boolean formula by posing queries in this domain.</p><p>The pair (γ, α) gives the correspondence between the domains Bool B(A) and Prop A . Let us call a Boolean formula β ∈ Bool B(A) a canonical monomial if it is a conjunction of literals, where each variable appears exactly once. Define</p><formula xml:id="formula_8">γ : Bool B(A) → Prop A α : Prop A → Bool B(A) γ(β) = β[b p → p] α(θ) = {β ∈ Bool B(A) : β is a canonical monomial and θ ∧ γ(β) is satisfiable}.</formula><p>Concretization function γ(β) ∈ Prop A simply replaces Boolean variables in B(A) by corresponding atomic propositions in A. On the other hand, α(θ) ∈ Bool B(A) is the abstraction for any quantifier-free formula θ ∈ Prop A . A Boolean valuation µ ∈ Val B(A) is associated with a quantifier-free formula γ * (µ) and a first-order formula t[γ * (µ)]. A valuation ν ∈ Var (A) moreover induces a natural Boolean valuation α * (ν) ∈ Val B(A) .</p><formula xml:id="formula_9">γ * (µ) = p∈A {p : µ(b p ) = T} ∧ p∈A {¬p : µ(b p ) = F} α * (ν)(b p ) = ν |= p</formula><p>The following lemmas characterize relations among these functions: Lemma 1 ( <ref type="bibr" target="#b14">[15]</ref>). Let A be a set of atomic propositions, θ ∈ Prop A , β ∈ Bool B(A) , and ν a valuation for Var (A). Then 1. ν |= θ if and only if α * (ν) |= α(θ); and 2. ν |= γ(β) if and only if α * (ν) |= β. Lemma 2 ( <ref type="bibr" target="#b14">[15]</ref>). Let A be a set of atomic propositions, θ ∈ Prop A , and µ a Boolean valuation for B(A). Then γ * (µ) ⇒ θ if and only if µ |= α(θ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Learning Quantified Invariants</head><p>We present our query resolution algorithms, followed by the invariant generation algorithm. The query resolution algorithms exploit the information derived from the given annotated loop {δ} while κ do S {}. Let ι, ι ∈ Pred. We say ι is an  <ref type="figure" target="#fig_6">Fig. 3</ref>. Counterexamples in equivalence query resolution (c.f. Algorithm 1): (a) a counterexample inside the under-approximation ι but outside the candidate ρ (line 4); (b) a counterexample inside the candidate ρ but outside the overapproximation ι (line 5); (c) a random counterexample ν 0 (or ν 1 ) inside the candidate ρ (or over-approximation ι) but out of the under-approximation ι (or candidate ρ), respectively (line 6 and 7).</p><formula xml:id="formula_10">(κ ∧ ρ ∧ ¬Pre(ρ, S)) → UNSAT then return YES ; 3 if SMT (ι ∧ ¬ρ) ! → ν then return α * (ν); 4 if SMT (ρ ∧ ¬ι) ! → ν then return α * (ν); 5 if SMT (ρ ∧ ¬ι) ! → ν0 or SMT (ι ∧ ¬ρ) ! → ν1 then 6 return α * (ν0) or α * (ν1) randomly; 7 ι ρ ν ρ ν ι ι ι ρ ν 0 ν 1 (a) (b) (c)</formula><p>under-approximation to invariants if δ ⇒ ι and ι ⇒ ι for some invariant ι of the annotated loop. Similarly, ι is an over-approximation to invariants if ι ⇒ ∨ κ and ι ⇒ ι for some invariant ι. The strongest under-approximation δ is an underapproximation; the weakest over-approximation ∨ κ is an over-approximation.</p><p>Better invariant approximations can be obtained by other techniques; they can be used in our query resolution algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Equivalence Queries</head><p>An equivalence query EQ(β) with β ∈ Bool B(A) asks if β is equivalent to the unknown target λ. Algorithm 1 gives our equivalence resolution algorithm. It first checks if ρ = t[γ(β)] is indeed an invariant for the annotated loop by verifying ι ⇒ ρ, ρ ⇒ ι, and κ ∧ ρ ⇒ Pre(ρ, S) with an SMT solver (line 2 and 3). If so, the CDNF algorithm has generated an invariant and our teacher acknowledges that the target has been found. If the candidate ρ is not an invariant, we need to provide a counterexample. <ref type="figure" target="#fig_6">Figure 3</ref> describes the process of counterexample discovery. The algorithm first tries to generate a counterexample inside of underapproximation (a), or outside of over-approximation (b). If it fails to find such counterexamples, the algorithm tries to return a valuation distinguishing ρ from invariant approximations as a random answer (c).</p><p>Recall that SMT solvers may err when a potential model is returned (line 4 -6). If it returns an incorrect model, our equivalence resolution algorithm will give an incorrect answer to the learning algorithm. Incorrect answers effectively guide the CDNF algorithm to different quantified invariants. Note also that random answers do not yield incorrect results because the equivalence query resolution algorithm uses an SMT solver to verify that the found first-order formula is indeed an invariant. In a membership query MEM (µ), our membership query resolution algorithm (Algorithm 2) should answer whether µ |= λ. Note that any relation between atomic propositions A is lost in the abstract domain Bool B(A) . A valuation may not correspond to a consistent quantifier-free formula (for example, b x=0 = b x&gt;0 = T). If the valuation µ ∈ Val B(A) corresponds to an inconsistent quantifier-free formula (that is, γ * (µ) is unsatisfiable), we simply answer NO to the membership query (line 1). Otherwise, we compare ρ = t[γ * (µ)] with invariant approximations. <ref type="figure" target="#fig_4">Figure 4</ref> shows the scenarios when queries can be answered by comparing ρ with invariant approximations. In case 4(a), ρ ⇒ ι does not hold and we would like to show µ |= λ. This requires the following lemma: [], θ 1 ≡ i &lt; 10, and θ 2 ≡ i &lt; 1. We have ∀i.i &lt; 10 ⇒ ∀i.i &lt; 1 but i &lt; 10 ⇒ i &lt; 1. In order to infer more information from ρ ⇒ ι, we introduce a subclass of templates. Using an SMT solver, it is straightforward to check if a template t[] is wellformed with respect to a quantifier-free formula θ by a simple recursion. For instance, when the template is ∀I.t [], it suffices to check SMT (t [θ]∧∃I.¬t <ref type="bibr">[θ]</ref>) → UNSAT and t [] is well-formed with respect to θ. More importantly, well-formed templates allow us to infer the relation between hole-filling quantifier-free formulae.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Membership Queries</head><formula xml:id="formula_11">Lemma 3. Let t[] ∈ τ be a template. For any θ 1 , θ 2 ∈ Prop A , θ 1 ⇒ θ 2 implies t[θ 1 ] ⇒ t[θ 2 ]. 1 ρ ν ι ι ρ (a) (b)</formula><p>Lemma 4. Let A be a set of atomic propositions, θ 1 ∈ Prop A , and t[] ∈ τ a well-formed template with respect to θ 1 . For any</p><formula xml:id="formula_12">θ 2 ∈ Prop A , t[θ 1 ] ⇒ t[θ 2 ] implies θ 1 ⇒ θ 2 .</formula><p>By Lemma 4 and 2, we have µ |= λ from ρ ⇒ ι (line 4) and the well-formedness of t[] with respect to γ * (µ). As in the case of the equivalence query resolution algorithm, incorrect models from SMT solvers (line 3) simply guide the CDNF algorithm to other quantified invariants. Note that Algorithm 2 also gives a random answer if a membership query cannot be resolved through invariant approximations. The correctness of generated invariants is ensured by SMT solvers in the equivalence query resolution algorithm (Algorithm 1). 8 Algorithm 3 shows our invariant generation algorithm. It invokes the CDNF algorithm in the main loop. Whenever a query is made, our algorithm uses one of the query resolution algorithms <ref type="figure" target="#fig_2">(Algorithm 1 or 2)</ref> to give an answer. In both query resolution algorithms, we use the strongest under-approximation δ and the weakest over-approximation κ ∨ to resolve queries from the learning algorithm. Observe that the equivalence and membership query resolution algorithms give random answers independently. They may send inconsistent answers to the CDNF algorithm. When inconsistencies arise, the main loop forces the learning algorithm to restart (line 6). If the CDNF algorithm infers a Boolean formula λ ∈ Bool B(A) , the first-order formula t[γ(λ)] is an invariant for the annotated loop in the form of the template t[].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Main Loop</head><p>In contrast to traditional deterministic algorithms, our algorithm gives random answers in both query resolution algorithms. Due to the undecidability of firstorder theories in SMT solvers, verifying quantified invariants and comparing invariant approximations are not solvable in general. If we committed to a particular solution deterministically, we would be forced to address computability issues. Random answers simply divert the learning algorithm to search for other quantified invariants and try the limit of SMT solvers. They could not be effective if there were very few solutions. Our thesis is that there are sufficiently many invariants for any given annotated loop in practice. As long as our random answers are consistent with one verifiable invariant, the CDNF algorithm is guaranteed to generate an invariant for us.</p><p>Similar to other invariant generation techniques based on predicate abstraction, our algorithm is not guaranteed to generate invariants. If no invariant can be expressed by the template with a given set of atomic propositions, our algorithm will not terminate. Moreover, if no invariant in the form of the given template can be verified by SMT solvers, our algorithm does not terminate either. On the AP : # of atomic propositions, MEM : # of membership queries, EQ : # of equivalence queries, MEMR : fraction of randomly resolved membership queries to MEM , EQR fraction of randomly resolved equivalence queries to EQ, ITER : # of the CDNF algorithm invocations, and σTime : standard deviation of the running time.</p><p>other hand, if there is one verifiable invariant in the form of the given template, there is a sequence of random answers that leads to the verifiable invariant. If sufficiently many verifiable invariants are expressible in the form of the template, random answers almost surely guide the learning algorithm to one of them. Since our algorithmic learning approach with random answers does not commit to any particular invariant, it can be more flexible and hence effective than traditional deterministic techniques in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Experiments</head><p>We have implemented a prototype 2 in OCaml. In our implementation, we use Yices as the SMT solver to resolve queries (Algorithm 1 and 2). <ref type="table">Table 1</ref> shows experimental results. We took two cases from the ten benchmarks in <ref type="bibr" target="#b19">[20]</ref> with the same annotation (max and selection sort). We also chose four for statements from Linux 2.6.28. We translated them into our language and annotated preand post-conditions manually. Sets of atomic proposition are manually chosen from the program texts. Benchmark devres is from library, tracepoint1 and tracepoint2 are from kernel, and rm pkey is from InfiniBand device driver. The data are the average of 500 runs and collected on a 2.66GHz Intel Core2 Quad CPU with 8GB memory running Linux 2.6.28.   Observe that our algorithm is able to infer an arbitrary quantifier-free formula (over a fixed set of atomic propositions) to fill the hole in the given template. A simple template such as ∀k.</p><formula xml:id="formula_13">{(¬ret ∧ ¬break ) ⇒ (∀k.k &lt; n ⇒ pkeys[k ] = key) ∧(¬ret ∧ break ) ⇒ (pkeys[i] = key ∧ pkeyrefs[i] = 0) ∧ ret ⇒ (pkeyrefs[i] = 0 ∧ pkeys[i] = 0) } (c) devres { i = 0 ∧ ¬ret } 1 while i &lt; n ∧ ¬ret do 2 if tbl[i] = addr then 3 tbl[i]:=0; ret:=true 4 else 5 i:=i + 1 6 end {(¬ret ⇒ ∀k. k &lt; n ⇒ tbl[k] = addr) ∧(ret ⇒ tbl[i] = 0) } (b) selection sort { i = 0 } 1 while i &lt; n − 1</formula><formula xml:id="formula_14">{(i ≥ n − 1) ∧ (∀k1.k1 &lt; n ⇒ (∃k2.k2 &lt; n ∧ a[k1] = a[k2]))}</formula><p>[] suffices to serve as a hint in our approach. In this test case, we apply our invariant generation algorithm to compute an invariant to establish the postcondition of the outer loop. For computing the invariant of the outer loop, we make use of the inner loop's specification. We use the following set of atomic propositions:</p><formula xml:id="formula_15">{k 1 ≥ 0, k 1 &lt; i, k 1 = i, k 2 &lt; n, k 2 = n, a[k 1 ] = a[k 2 ], i &lt; n − 1, i = min}. Using the template ∀k 1 .∃k 2 .[],</formula><p>our algorithm infers following invariants in different runs:</p><formula xml:id="formula_16">∀k 1 .(∃k 2 .[(k 2 &lt; n ∧ a[k 1 ] = a[k 2 ]) ∨ k 1 ≥ i]); and ∀k 1 .(∃k 2 .[(k 1 ≥ i ∨ min = i ∨ k 2 &lt; n) ∧ (k 1 ≥ i ∨ (min = i ∧ a[k 1 ] = a[k 2 ]))]).</formula><p>Note that all membership queries are resolved randomly due to the alternation of quantifiers in array theory. Still a simple random walk suffices to find invariants in this example. Moreover, templates allow us to infer not only universally quantified invariants but also first-order invariants with alternating quantifications. Inferring arbitrary quantifier-free formulae over a fixed set of atomic propositions again greatly simplifies the form of templates used in this example.</p><p>rm pkey from Linux InfiniBand Driver <ref type="figure" target="#fig_8">Figure 5</ref>(a) is a while statement extracted from Linux InfiniBand driver. <ref type="bibr" target="#b3">4</ref> The conjuncts in the postcondition represent (1) if the loop terminates without break, all elements of pkeys are not equal to key (line 2); (2) if the loop terminates with break but ret is false, then pkeys[i] is equal to key (line 2) but pkeyrefs <ref type="bibr">[i]</ref> is not equal to zero (line 4); <ref type="formula">(3)</ref>  </p><formula xml:id="formula_17">(∀k.(k &lt; i) ⇒ pkeys[k ] = key) ∧ (ret ⇒ pkeyrefs[i ] = 0 ∧ pkeys[i ] = 0) ∧ (¬ret ∧ break ⇒ pkeys[i ] = key ∧ pkeyrefs[i ] = 0); and (∀k.(¬ret ∨ ¬break ∨ (pkeyrefs[i] = 0 ∧ pkeys[i] = 0)) ∧ (pkeys[k] = key ∨ k ≥ i) ∧(¬ret ∨ (pkeyrefs[i] = 0 ∧ pkeys[i] = 0 ∧ i &lt; n ∧ break )) ∧ (¬break ∨ pkeyrefs[i] = 0 ∨ ret) ∧ (¬break ∨ pkeys[i] = key ∨ ret)).</formula><p>In spite of undecidability of first-order theories in Yices and random answers, each of the 3000 (= 6×500) runs in our experiments infers an invariant successfully. Moreover, several quantified invariants are found in each case among 500 runs. This suggests that invariants are abundant. Note that the templates in the test cases selection sort and tracepoint2 have alternating quantification. Satisfiability of alternating quantified formulae is in general undecidable. That is why both cases have substantially more restarts than the others. Interestingly, our algorithm is able to generate a verifiable invariant in each run. Our simple randomized mechanism proves to be effective even for most difficult cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>Comparing with the work <ref type="bibr" target="#b14">[15]</ref> of generating quantifier-free invariants, we develop the following technical extensions. First, we integrate potential counterexamples in resolving equivalence query algorithm (line 6 -7 in Algorithm 1, and line 3 in Algorithm 2) instead of restarting. Due to the undecidability of satisfiability of quantified formulae, SMT solvers often give potential counterexamples. We exploit potential counterexamples to enhance our algorithm. Second, a new condition (Definition 1) to answer positively in resolving membership queries is proposed. Without this condition, we can answer negatively to membership queries.</p><p>In contrast to previous template-based approaches <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b8">9]</ref>, our template is more general as it allows arbitrary hole-filling quantifier-free formulae. The templates in <ref type="bibr" target="#b19">[20]</ref> can only be filled with formulae over conjunctions of predicates from a given set. Any disjunction must be explicitly specified as part of a template. In <ref type="bibr" target="#b8">[9]</ref>, the authors consider invariants of the form E ∧ n j=1 ∀U j (F j ⇒ e j ), where E, F j and e j must be quantifier free finite conjuctions of atomic facts.</p><p>Existing technologies can strengthen our framework. Firstly, its completeness can be increased by more powerful decision procedures <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b20">21]</ref> and theorem provers <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b18">19]</ref>. Moreover, our approach can be improved by using more accurate approximations from existing invariant generation techniques. The tool InvGen collects reached states satisfying the program invariants, and also computes a collection of invariants for efficient invariant generation <ref type="bibr" target="#b10">[11]</ref>. They can be used as under-and over-approximations, respectively.</p><p>Regarding the generation of unquantified invariants, a constraint analysis approach is proposed in <ref type="bibr" target="#b9">[10]</ref>. Invariants in the combined theory of linear arithmetic and uninterpreted functions are synthesized in <ref type="bibr" target="#b1">[2]</ref>, while InvGen <ref type="bibr" target="#b10">[11]</ref> presents an efficient approach for linear arithmetic invariants. For quantified loop invariants, Skolemization is used for generating universally quantified invariants <ref type="bibr" target="#b6">[7]</ref>. In <ref type="bibr" target="#b17">[18]</ref>, a paramodulation-based saturation prover is extended to generate universally quantified invariants by interpolation.</p><p>With respect to the analysis of properties of array contents, Halbwachs et al. <ref type="bibr" target="#b11">[12]</ref> handle programs which manipulate arrays by sequential traversal, incrementing (or decrementing) their index at each iteration, and which access arrays by simple expressions of the loop index. A loop property generation method for loops iterating over multi-dimensional arrays is introduced in <ref type="bibr" target="#b12">[13]</ref>. For inferring range predicates, Jhala and McMillan <ref type="bibr" target="#b13">[14]</ref> described a framework that uses infeasible counterexample paths. As a deficiency, the prover may find proofs refuting short paths, but which do not generalize to longer paths. Due to this problem, this approach <ref type="bibr" target="#b13">[14]</ref> fails to prove that an implementation of insertion sort correctly sorts an array.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions</head><p>By combining algorithmic learning, decision procedures, predicate abstraction, and templates, we present a technique for generating quantified invariants. The new technique searches for invariants in the given template form guided by query resolution algorithms. We exploit the flexibility of algorithmic learning by deploying a randomized query resolution algorithm. When there are sufficiently many invariants, random answers will not prevent algorithmic learning from inferring verifiable invariants. Our experiments show that our learning-based approach is able to infer non-trivial quantified invariants with this na¨ıvena¨ıve randomized resolution for some loops extracted from Linux drivers.</p><p>Under-and over-approximations are presently derived from annotations provided by users. They can in fact be obtained by other techniques such as static analysis. For deciding the set of atomic propositions, it will be interesting whether existing techniques <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17]</ref> are applicable. The integration of various refinement techniques for predicate abstraction will certainly be an important future work.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>This work was supported by the Engineering Research Center of Excellence Program of Korea Ministry of Education, Science and Technology(MEST) / National Research Foundation of Korea(NRF)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>The max example examines a[0] through a[n − 1] and finds the index of the maximal element in the array. This simple loop is annotated with the precondition m = 0 ∧ i = 0 and the postcondition ∀k.0 ≤ k &lt; n ⇒ a[k] ≤ a[m].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Algorithm 1 :</head><label>1</label><figDesc>Resolving Equivalence Queries /* ι : an under-approximation; ι : an over-approximation */ /* t[]: the given template */ Input: β ∈ Bool B(A) Output: YES , or a counterexample ν s.t. α * (ν) |= β ⊕ λ ρ := t[γ(β)]; 1 if SMT (ι ∧ ¬ρ) → UNSAT and SMT (ρ ∧ ¬ι) → UNSAT and 2 SMT</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Algorithm 2 :</head><label>2</label><figDesc>Resolving Membership Queries /* ι : an under-approximation; ι : an over-approximation */ /* t[]: the given template */ Input: a valuation µ for B(A) Output: YES or NO if SMT (γ * (µ)) → UNSAT then return NO; 1 ρ := t[γ * (µ)]; 2 if SMT (ρ ∧ ¬ι) ! → ν then return NO; 3 if SMT (ρ ∧ ¬ι) → UNSAT and isWellFormed (t[], γ * (µ)) then return YES ; 4 return YES or NO randomly 5</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Resolving a membership query with invariant approximations (c.f. Algorithm 2): (a) the guess ρ is not included in the over-approximation ι (line 3); (b) the guess ρ is included in the under-approximation ι (line 4).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Definition 1 .</head><label>1</label><figDesc>Let θ ∈ Prop A be a quantifier-free formula over A. A well-formed template t[] with respect to θ is defined as follows. -[] is well-formed with respect to θ; -∀I.t [] is well-formed with respect to θ if t [] is well-formed with respect to θ and t [θ] ⇒ ∀I.t [θ]; -∃I.t [] is well-formed with respect to θ if t [] is well-formed with respect to θ and ¬t [θ].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Algorithm 3 :</head><label>3</label><figDesc>Main Loop Input: {δ} while κ do S {} : an annotated loop; t[] : a template Output: an invariant in the form of t[] ι := δ; 1 ι := κ ∨ ; 2 repeat 3 try 4 λ := call CDNF with query resolution algorithms (Algorithm 1 and 2) 5 when inconsistent → continue 6 until λ is defined ; 7 return t[γ(λ)];</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>devres</head><label></label><figDesc>from Linux Library Figure 5(c) shows an annotated loop extracted from a Linux library. 3 In the postcondition, we assert that ret implies tbl [i] = 0, and every element in the array tbl [] is not equal to addr otherwise. Using the set of atomic propositions {tbl [k] = addr , i &lt; n, i = n, k &lt; i, tbl [i] = 0, ret} and the simple template ∀k.[], our algorithm finds following quantified invariants in different runs: ∀k.(k &lt; i ⇒ tbl [k] = addr ) ∧ (ret ⇒ tbl [i] = 0) and ∀k.(k &lt; i) ⇒ tbl[k] = addr. 2 Available at http://ropas.snu.ac.kr/aplas10/qinv-learn-released.tar.gz 3 The source code can be found in function devres of lib/devres.c in Linux 2.6.28</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Benchmark Examples: (a) rm pkey from Linux InfiniBand driver, (b) selection sort from [20], and (c) devres from Linux library.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>selection sort from [ 20 ]</head><label>20</label><figDesc>Consider the selection sort algorithm in Figure 5(b). Let a[] denote the content of the array a[] before the algorithm is executed. The postcondition states that the contents of array a[] come from its old contents.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>if ret is true after the loop, then both pkeyrefs[i ] (line 4) and pkeys[i ] (line 5) are equal to zero. From the postcondition, we guess that an invariant can be universally quantified with k. Using the simple template ∀k.[] and the set of atomic propositions {ret, break , i &lt; n, k &lt; i , pkeys[i ] = 0, pkeys[i ] = key, pkeyrefs[i ] = 0, pkeyrefs[k] = key}, our algorithm finds following quantified invariants in different runs:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head></head><label></label><figDesc>The middle box corresponds to the class Prop A of quantifier-free formulae generated from A. Since we are looking for quantified invariants in the form of the template t[], Prop A is in fact the essence of generated quantified invariants. The right box contains the class Bool B(A) of</figDesc><table>Val Var (A) 

Prop A 
Pred A 

Val B(A) 

Bool B(A) 

λθ.t[θ] 

α  *  

γ  *  

γ 

α 

Fig. 2. The domains Pred A , Prop A , and Bool B(A) 

</table></figure>

			<note place="foot" n="1"> Complete proofs are in [5]</note>

			<note place="foot" n="4"> The source code can be found in function rm pkey of drivers/infiniband/hw/ ipath/ipath mad.c in Linux 2.6.28</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Coq&apos;Art: The Calculus of Inductive Constructions. Texts in Theoretical Computer Science</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Bertot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Castéran</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<publisher>Springer Verlag</publisher>
		</imprint>
	</monogr>
	<note>Interactive Theorem Proving and Program Development</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Invariant synthesis for combined theories</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
		<editor>VMCAI.</editor>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="378" to="394" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Exact learning boolean functions via the monotone theory. Information and Computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">H</forename><surname>Bshouty</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="volume">123</biblScope>
			<biblScope unit="page" from="146" to="153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Counterexample-guided abstraction refinement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Veith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">1855</biblScope>
			<biblScope unit="page" from="154" to="169" />
			<date type="published" when="2000" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Inferring quantified invariants via algorithmic learning, decision procedure, and predicate abstraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Yi</surname></persName>
		</author>
		<idno>ROSAEC-2010-007</idno>
	</analytic>
	<monogr>
		<title level="m">Research On Software Analysis for Error-Free Computing</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
<note type="report_type">Technical Memorandum</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The Yices SMT solver</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Dutertre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">D</forename><surname>Moura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SRI International</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Predicate abstraction for software verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</author>
		<editor>POPL, ACM</editor>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="191" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Complete instantiation for quantified formulas in satisfiabiliby modulo theories</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Moura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">5643</biblScope>
			<biblScope unit="page" from="306" to="320" />
			<date type="published" when="2009" />
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Lifting abstract interpreters to quantified logical domains</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Mccloskey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tiwari</surname></persName>
		</author>
		<editor>POPL, ACM</editor>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="235" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Constraint-based invariant inference over predicate abstraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Venkatesan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">5403</biblScope>
			<biblScope unit="page" from="120" to="135" />
			<date type="published" when="2009" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Invgen: An efficient invariant generator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">5643</biblScope>
			<biblScope unit="page" from="634" to="640" />
			<date type="published" when="2009" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Discovering properties about arrays in simple programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Halbwachs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Péron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In: PLDI</title>
		<imprint>
			<biblScope unit="page" from="339" to="348" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Invariant and type inference for matrices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Hottelier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kovács</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</author>
		<editor>VMCAI.</editor>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="163" to="179" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Array abstractions from proofs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV, volume</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007" />
			<biblScope unit="volume">4590</biblScope>
			<biblScope unit="page" from="193" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Deriving invariants in propositional logic by algorithmic learning, decision procedure, and predicate abstraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Yi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">5944</biblScope>
			<biblScope unit="page" from="180" to="196" />
			<date type="published" when="2010" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Decision Procedures an algorithmic point of view</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Strichman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EATCS</title>
		<imprint>
			<date type="published" when="2008" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Lazy abstraction with interpolants</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>Ball, T., Jones, R.B.</editor>
		<imprint>
			<biblScope unit="volume">4144</biblScope>
			<biblScope unit="page" from="123" to="136" />
			<date type="published" when="2006" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Quantified invariant generation using an interpolating saturation prover</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">4693</biblScope>
			<biblScope unit="page" from="413" to="427" />
			<date type="published" when="2008" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Isabelle/HOL -A Proof Assistant for Higher-Order Logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Nipkow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">C</forename><surname>Paulson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wenzel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">2283</biblScope>
			<date type="published" when="2002" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Program verification using templates over predicate abstraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<publisher>PLDI, ACM</publisher>
			<biblScope unit="page" from="223" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">VS3: SMT solvers for program verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Foster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">5643</biblScope>
			<biblScope unit="page" from="702" to="708" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
