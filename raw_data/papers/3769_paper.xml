<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:46+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Shortest Paths in Directed Planar Graphs with Negative Lengths: a Linear-Space O(n log 2 n)-Time Algorithm</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philip</forename><surname>Klein</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shay</forename><surname>Mozes</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oren</forename><surname>Weimann</surname></persName>
						</author>
						<title level="a" type="main">Shortest Paths in Directed Planar Graphs with Negative Lengths: a Linear-Space O(n log 2 n)-Time Algorithm</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We give an O(n log 2 n)-time, linear-space algorithm that, given a directed planar graph with positive and negative arc-lengths, and given a node s, finds the distances from s to all nodes. The best previously known algorithm requires O(n log 3 n) time and O(n log n) space.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>2.1 Embedded Planar Graphs A planar embedding of a graph assigns each node to a distinct point on the plane, and assigns each edge to a simple arc between the points corresponding to its endpoints, with the property that no arc-arc or arc-point intersections occur except for those corresponding to edge-node incidence in the graph. A graph is planar if it has a planar embedding. Consider the set of points on the sphere that are not assigned to any node or edge; each connected component of this set is a face of the embedding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Jordan Separators for Embedded Planar Graphs</head><p>Miller <ref type="bibr" target="#b16">[17]</ref> gave a linear-time algorithm that, given a triangulated two-connected n-node planar embedded graph, finds a simple cycle separator consisting of at most 2 √ 2 √ n nodes, such that at most 2n/3 nodes are strictly enclosed by the cycle, and at most 2n/3 nodes are not enclosed.</p><p>For an n-node planar embedded graph G that is not necessarily triangulated or two-connected, we define a Jordan separator to be a Jordan curve C that intersects the embedding of the graph only at nodes such that at most 2n/3 nodes are strictly enclosed by the curve and at most 2n/3 nodes are not enclosed. The nodes intersected by the curve are called boundary nodes and denoted V c . To find a Jordan separator with at most 2 √ 2 √ n boundary nodes, add artificial edges with sufficiently large lengths to triangulate the graph and make it two-connected without changing the distances in the graph. Now apply Miller's algorithm.</p><p>The internal part of G with respect to C is the embedded subgraph consisting of the nodes and edges enclosed by C, i.e. including the nodes intersected by C. Similarly, the external part of G with respect to C is the subgraph consisting of the nodes and edges not strictly enclosed by C, i.e. again including the nodes intersected by C.</p><p>Let G 1 (G 0 ) denote the internal (external) part of G with respect to C. Since C is a Jordan curve, the set of points of the plane strictly exterior to C form a connected region. Furthermore, it contains no point or arc corresponding to a node or edge of G 1 . Therefore, the region remains connected when these points and arcs are removed, so the region is a subset of some face of G 1 . Since every boundary node is intersected by C, it follows that all boundary nodes lie on the boundary of a single face of G 1 . Similarly, in G 0 , all boundary nodes lie on the boundary of a single face.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Monotonicity, Monge and Matrix Search</head><formula xml:id="formula_0">- ing A matrix M = (M ij ) is totally monotone if for ev- ery i, i 񮽙 , j, j 񮽙 such that i &lt; i 񮽙 , j &lt; j 񮽙 and M ij ≤ M ij 񮽙 , we also have M i 񮽙 j ≤ M i 񮽙 j 񮽙 .</formula><p>Totally monotone matrices were introduced by Aggarwal et al. in <ref type="bibr" target="#b1">[2]</ref>, who showed that a wide variety of problems in computational geometry could be reduced to the problem of finding row-maxima or row-minima in totally monotone matrices. Aggarwal et al. also give an algorithm, nicknamed SMAWK, that, given a totally monotone n× m matrix M , finds all rowmaxima of M in just O(n + m) time. It is easy to see that by negating each element of M and reversing the order of its columns, SMAWK can be used to find the row minima of M as well.</p><formula xml:id="formula_1">A matrix M = (M ij ) is convex Monge (concave Monge) if for every i, i 񮽙 , j, j 񮽙 such that i &lt; i 񮽙 , j &lt; j 񮽙 , we have M ij + M i 񮽙 j 񮽙 ≥ M ij 񮽙 + M i 񮽙 j (M ij + M i 񮽙 j 񮽙 ≤ M ij 񮽙 + M i 񮽙 j )</formula><p>. It is immediate that if M is convex Monge then it is totally monotone. It is also easy to see that the matrix obtained by transposing M and then reversing the order of the columns is also totally monotone. Thus SMAWK can also be used to find the column minima and maxima of a convex Monge matrix.</p><p>In <ref type="bibr" target="#b12">[13]</ref> Klawe and Kleitman define a falling staircase matrix to be a lower triangular fragment of a totally monotone matrix.</p><p>More precisely, (M, {f (i)} 0≤i≤n+1 ) is an n × m falling staircase matrix if</p><formula xml:id="formula_2">1. for i = 0, . . . , n + 1, f (i) is an integer with 0 = f (0) &lt; f(1) ≤ f (2) ≤ · · · ≤ f (n) &lt; f(n + 1) = m + 1.</formula><p>2. M ij , is a real number if and only if 1 ≤ i ≤ n and 1 ≤ j ≤ f (i). Otherwise, M ij is blank.</p><p>3. for i &lt; k and j &lt; l ≤ f (i), and</p><formula xml:id="formula_3">M ij ≤ M il , we have M kj ≤ M kl .</formula><p>Finding the row maxima in a falling staircase matrix can be easily done using SMAWK in O(n+m) time after replacing the blanks with sufficiently small numbers so that the resulting matrix is totally monotone. However, this trick does not work for finding the row minima. Aggarwal and Klawe <ref type="bibr" target="#b0">[1]</ref> give an O(m log log n) time algorithm for finding row-minima in falling staircase matrices of size n × m. Klawe and Kleitman give in <ref type="bibr" target="#b12">[13]</ref> a more complicated algorithm that computes the row-minima of an n × m falling staircase matrix in O(mα(n)+n) time, where α(n) is the inverse Ackerman function. Again, it is not hard to see that both these algorithms can be used to find the column minima, by transposing and then reversing the order of the columns, as above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Price Functions and Reduced Lengths</head><p>For a directed graph G with arc-lengths 񮽙(·), a price function is a function φ from the nodes of G to the reals. For an arc uv, the reduced length with respect to φ is 񮽙 φ (uv) = 񮽙(uv) + φ(u) − φ(v). A feasible price function is a price function that induces nonnegative reduced lengths on all arcs of G.</p><p>Feasible price functions are useful in transforming a shortest-path problem involving positive and negative lengths into one involving only nonnegative lengths, which can then be solved using Dijkstra's algorithm. For any nodes s and t, for any s-to-t path P , 񮽙 φ (P ) = 񮽙(P ) + φ(s) − φ(t). This shows that an s-to-t path is shortest with respect to 񮽙 φ (·) iff it is shortest with respect to 񮽙(·). Moreover, the s-to-t distance with respect to the original lengths 񮽙(·) can be recovered by adding φ(t) − φ(s) to the s-to-t distance with respect to</p><formula xml:id="formula_4">񮽙 φ (·).</formula><p>Suppose φ is a feasible price function. Running Dijkstra's algorithm with the reduced lengths and modifying the distances thereby computed to obtain distances with respect to the original lengths will be called running Dijkstra's algorithm with φ.</p><p>An example of a feasible price function comes from single-source distances. Suppose that, for some node r of G, for every node v of G, φ(v) is the r-to-v distance in G with respect to 񮽙(·). Then for every arc uv, φ(v) ≤ φ(u) + 񮽙(uv), so 񮽙 φ (uv) ≥ 0. <ref type="bibr">Klein [14]</ref> gives a multiple-source shortest-path algorithm with the following properties. The input consists of a directed planar embedded graph G with non-negative arclengths, and a face f . For each node u in turn on the boundary of f , the algorithm computes (an implicit representation of) the shortest-path tree rooted at u. The basic algorithm takes O(n log n) time and O(n) space on an n-node input graph. In addition, given a set of pairs (u, v) of nodes of G where u is on the boundary of f , the algorithm computes the u-to-v distances. The time per distance computed is O(log n). In particular, given a set S of O( √ n) nodes on the boundary of a single face, the algorithm can compute all S-to-S distances in O(n log n) time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Multiple-Source Shortest Paths: Computing Boundary-to-Boundary Distances</head><p>In fact, the multiple-source shortest-path algorithm does not require that the arc-lengths be nonnegative if the input also includes a table of distances to all nodes from some node on the face f . This observation follows from careful inspection of the algorithm <ref type="bibr" target="#b13">[14]</ref> itself. Alternatively, it also follows from the pricefunction technique of Section 2.4; the table of distances can be used to obtain nonnegative reduced lengths.  </p><formula xml:id="formula_5">such that d 񮽙 i [v] is the r-to-v distance in G for every node v of G i distances rerooting 8 define a price function φ for G such that φ[v]</formula><p>is the r-to-v distance in G: </p><formula xml:id="formula_6">single- source φ[v] = 񮽙 d 񮽙 0 [v] if v belongs to G 0 d 񮽙 1 [v] otherwise</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Algorithm</head><p>The high-level description of the algorithm appears in <ref type="figure">Figure 3</ref>. After finding a Jordan separator and selecting a boundary node as a temporary source node, the algorithm consists of five major steps. The recursive call step is straightforward. Computing intra-part boundary distances uses the algorithm described in Section 2.5.</p><p>Computing single-source inter-part boundary distances is described in Section 4; it is based on the BellmanFord algorithm. Single-source inter-part distances is described in Section 5, and is based on Dijkstra's algorithm. It yields distances to all nodes from the temporary source node. These distances constitute a feasible price function, as described in Section 2.4, that enables us, in rerooting single-source distances, to use Dijkstra's algorithm once more to finally compute distances from the given source.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Computing Single-Source Inter-Part Boundary Distances</head><p>In this section we describe how to efficiently compute the distances in G from r to all boundary nodes (i.e., the nodes of V c ). This is done using δ 0 and δ 1 , the allpairs distances in G 0 and in G 1 between nodes in V c which were computed in the previous stage.  <ref type="figure">Figure 4</ref>: Pseudocode for the single-source inter-part boundary distances stage for calculating shortest-path distances in G from r to all nodes in V c using just δ 0 and δ 1 .</p><formula xml:id="formula_7">e j [v] = 񮽙 min w∈Vc {e j−1 [w] + δ 1 [w, v]}, if j is odd min w∈Vc {e j−1 [w] + δ 0 [w, v]}, if j is even 񮽙 , ∀v ∈ V c 5: B[v] ← e |Vc| [v] for all v ∈ V c</formula><p>The rest of this section describes the algorithm, thus proving Theorem 4.1. The following structural lemma stands in the core of the computation. The same lemma has been implicitly used by previous planarityexploiting algorithms. The proof is straightforward and omitted here.</p><p>Lemma 4.1. Let P be a simple r-to-v shortest path in G, where v ∈ V c . Then P can be decomposed into at most |V c | subpaths P = P 1 P 2 P 3 . . . , where the endpoints of each subpath P i are boundary nodes, and P i is a shortest path in G i mod 2 .</p><p>Lemma 4.1 gives rise to a dynamic programming solution for calculating the from-r distances to nodes of C, which resembles the Bellman-Ford algorithm. The pseudocode is given in <ref type="figure">Fig. 4</ref>. Note that, at this level of abstraction, there is nothing novel about this dynamic program. Our contribution is in an efficient implementation of Step 4.</p><p>The algorithm consists of |V c | iterations. On odd iterations, it uses the boundary-to-boundary distances in G 1 , and on even iterations it uses the boundary-toboundary distances in G 0 .</p><p>Lemma 4.2. After the table e j is updated by the algorithm, e j <ref type="bibr">[v]</ref> is the length of a shortest path in G from r to v that can be decomposed into at most j subpaths P = P 1 P 2 P 3 . . . P j , where the endpoints of each subpath P i are boundary nodes, and P i is a shortest path in</p><formula xml:id="formula_8">G i mod 2 .</formula><p>Proof. By induction on j. For the base case, e 0 is initialized to be infinity for all nodes other than r, trivially satisfying the lemma. For j &gt; 0, assume that the lemma holds for j − 1, and let P be a shortest path in G that can be decomposed into P 1 P 2 . . . P j as above. Consider the prefix P 񮽙 , P 񮽙 = P 1 P 2 . . . P j−1 . P 񮽙 is a shortest r-to-w path in G that can be decomposed into at most j − 1 subpaths as above for some boundary node w. Hence, by the inductive hypothesis, when e j is updated in Line 4, e j−1 <ref type="bibr">[w]</ref> already stores the length of P 񮽙 . Thus e j <ref type="bibr">[v]</ref> is updated in line 4 to be at most e j−1 [w] + δ j mod 2 <ref type="bibr">[w, v]</ref>. Since, by definition, δ j mod 2 <ref type="bibr">[w, v]</ref> is the length of the shortest path in G j mod 2 from w to v, it follows that e j <ref type="bibr">[v]</ref> is at most the length of P . For the opposite direction, since for any boundary node w, e j−1 <ref type="bibr">[w]</ref> is the length of some path that can be decomposed into at most j − 1 subpaths as above, e j [v] is updated in Line 4 to the length of some path that can be decomposed into at most j subpaths as above. Hence, since P is the shortest such path, e j <ref type="bibr">[v]</ref> is at least the length of P . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>From</head><formula xml:id="formula_9">= e j−1 (v k ) + δ i (v k , v 񮽙 ).</formula><p>Note that computing all minima in Line 4 is equivalent to finding the column-minima of A. We define the upper triangle of A to be the elements of A on or above the main diagonal. More precisely, the upper triangle of A is the portion {A kk : k ≤ 񮽙} of A. Similarly, the lower triangle of A consists of all the elements on or below the main diagonal of A. </p><formula xml:id="formula_10">1 ≤ k ≤ k 񮽙 ≤ 񮽙 ≤ 񮽙 񮽙 ≤ |V c | or 1 ≤ 񮽙 ≤ 񮽙 񮽙 ≤ k ≤ k 񮽙 ≤ |V c |)</formula><p>, the convex Monge property holds:</p><formula xml:id="formula_11">A kk + A k 񮽙 񮽙 񮽙 ≥ A kk 񮽙 + A k 񮽙 񮽙 .</formula><p>Proof. Consider the case 1 ≤ k ≤ k 񮽙 ≤ 񮽙 ≤ 񮽙 񮽙 ≤ |V c |, as in <ref type="figure" target="#fig_5">Fig. 5</ref>. Since G i is planar, any pair of paths in G i from k to 񮽙 and from k 񮽙 to 񮽙 񮽙 must cross at some node</p><formula xml:id="formula_12">w of G i . Let b k = e j−1 (v k ) and let b k 񮽙 = e j−1 (v k 񮽙 ). Let ∆(u, v) denote the u-to-v distance in G i for any nodes u, v of G i . Note that ∆(u, v) = δ i (u, v) for u, v ∈ V c . l' k k' l w</formula><p>Figure 5: Nodes k &lt; k 񮽙 &lt; l &lt; l 񮽙 in clockwise order on the boundary nodes. Paths from k to l and from k 񮽙 to l 񮽙 must cross at some node w. This is true both in the internal and the external subgraphs of G We have Proof. We need to show how to find the column minima of the matrix A. It follows directly from Lemma 4.3 that the lower triangle of A is a falling staircase matrix. By <ref type="bibr" target="#b12">[13]</ref>, its column minima can be computed in O(|V c |α(|V c |)) time. Another consequence of Lemma 4.3 is that the column-minima of the upper triangle of A may also be computed using the algorithm in <ref type="bibr" target="#b12">[13]</ref>. To see this consider a counterclockwise ordering of the nodes of</p><formula xml:id="formula_13">A k, + A k 񮽙 ,, 񮽙 = (b k + ∆(v k , w) + ∆(w, v 񮽙 )) + (b k 񮽙 + ∆(v k 񮽙 , w) + ∆(w, v 񮽙 񮽙 )) = (b k + ∆(v k , w) + ∆(w, v 񮽙 񮽙 )) + (b k 񮽙 + ∆(v k 񮽙 , w) + ∆(w, v 񮽙 )) ≥ (b k + ∆(v k , v 񮽙 񮽙 )) + (b k 񮽙 + ∆(v k 񮽙 , v 񮽙 )) = (b k + δ i (v k , v 񮽙 񮽙 )) + (b k 񮽙 + δ i (v k 񮽙 , v 񮽙 )) = A k, 񮽙 + A k 񮽙 ,, The case (1 ≤ 񮽙 ≤ 񮽙 񮽙 ≤ k ≤ k 񮽙 ≤ |V c |) is similar.</formula><formula xml:id="formula_14">|V c | v 񮽙 1 , v 񮽙 2 , . . . , v 񮽙 |Vc| such that v 񮽙 k = v |Vc|+1−k .</formula><p>With this order, the upper triangle of A is in fact a falling staircase matrix. Note that we never actually compute and store the entire matrix A as this would take O(|V c | 2 ) time. We compute the entries necessary for the computation on the fly in O(1) time per element.</p><p>Finally, we obtain A's column minima by comparing the two minima obtained for each column in each of the two triangular portions of A. We thus conclude that A's column minima can be computed in</p><formula xml:id="formula_15">O(2|V c | · α(|V c |) + |V c |) = O(|V c | · α(|V c |)) time.</formula><p>Hence the time it takes to compute the distances between r and all nodes of V c is O(|V c | 2 · α(|V c |). We have thus proved Theorem 4.1. The choice of separator ensures |V c | = O( √ n), so this computation is performed in O(nα(n)) time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Computing</head><p>Single-Source Inter-Part Distances In the previous section we showed how to compute a table B that stores the distances from r to all the boundary nodes in G. In this section we describe how to compute the distances from r to all other nodes of G. We do so by computing tables</p><formula xml:id="formula_16">d 񮽙 0 and d 񮽙 1 where d 񮽙 i [v]</formula><p>is the r-to-v distance in G for every node v of G i . Recall that we have already computed the table d i that stores the r-to-v distance in G i for every node v of G i .</p><p>The pseudocode given in <ref type="figure">Fig. 6</ref>  with the price function φ i in order to compute these from-r distances.</p><p>The following two lemmas motivate the definition of G 񮽙 i and show that it captures the true from-r distances in G. We omit the (simple) proof of Lemma 5.1.</p><p>Lemma 5.1. Let P be an r-to-v shortest path in G, where v ∈ G i . Then P can be expressed as P = P 1 P 2 , where P 1 is a (possibly empty) shortest path from r to a node u ∈ V c , and P 2 is a (possibly empty) shortest path from u to v that visits only nodes of G i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 5.2. Let G 񮽙</head><p>i be the graph obtained from G i by removing arcs entering r, and adding an arc ru of length B[u] for every boundary node u. The from-r distances in G 񮽙 i are equal to the from-r distance in G. Proof. Distances in G 񮽙 i are not shorter than in G since each arc of G 񮽙 i corresponds to some path in G. For the opposite direction, consider the r-to-v distance in G. Let P 1 , P 2 , u be as in Lemma 5.1. P 1 is a shortest path in G from r to some u ∈ V c . By definition of G 񮽙 i , the length of the new arc ru in G 񮽙 i is equal to the length of P 1 in G. Furthermore, P 2 is a path in G 񮽙 i since it only consists of arcs in G i . Since the shortest r-to-v path is simple, non of these arcs enters r, and therefore all of them are in G 񮽙 i . Hence the length of the path in G 񮽙 i that consists of the new arc ru followed by P 2 equals the length of P in G.  <ref type="figure">Figure 6</ref>: Pseudocode for the single-source intra-part distances stage for computing the shortest path distances from r to all nodes.</p><p>Since G 񮽙 i contains arcs not in G i , we cannot use the from-r distances in d i as a feasible price function. We slightly modify them to ensure non-negativity as shown by the following lemma. Proof. Let uv be an arc of</p><formula xml:id="formula_17">G 񮽙 i . If uv is an arc of G i , then d i [v] ≤ d i [u] + 񮽙[uv], so 񮽙 φi [uv] ≥ 0. Otherwise, u = r and 񮽙 φi [rv] = φ i [r] + B[v] − φ i [v] = p i + B[v] − d i [u]</formula><p>by definition of φ i ≥ 0 by definition of p i</p><p>Computing the auxiliary graphs G 񮽙 i and the price functions φ i can be easily done in linear time. Therefore, the time required for this stage is dominated by the O(n log n) running time of Dijkstra's algorithm. We note that one may use the algorithm of Henzinger et al. <ref type="bibr" target="#b8">[9]</ref> instead of Dijkstra to obtain a linear running time for this stage. This however does not change the overall running time of our algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Correctness and Analysis</head><p>We will show that at each stage of our algorithm, the necessary information has been correctly computed and stored. The recursive call in Line 4 computes and stores the from-r distances in G i . The conditions for applying Klein's algorithm in Line 5 hold since all boundary nodes lie on the boundary of a single face of G i and since the from-r distances in G i constitute a feasible price function for G i . The correctness of the single-source inter-part boundary distances stage in Line 6 and of the single-source inter-part distances stage in Line 7 was proved in Sections 4 and 5. Thus, the r-to-v distances in G for all nodes v of G are stored in</p><formula xml:id="formula_18">d 񮽙 0 for v ∈ G 0 and in d 񮽙 1 for v ∈ G 1 . Note that d 񮽙 0 and d 񮽙 1</formula><p>agree on distances from r to boundary nodes. Therefore, the price function φ defined in Line 8 is feasible for G, so the conditions to run Dijkstra's algorithm in Line 9 hold, and the from-s distances in G are correctly computed. We have thus established the correctness of our algorithm.</p><p>To bound the running time of the algorithm we bound the time it takes to complete one recursive call to shortest-paths. Let |G| denote the number of nodes in the input graph G, and let |G i | denote the number of nodes in each of its subgraphs. Computing the intra-subgraph boundary-to-boundary distances using Klein's algorithm takes O(|G i | log |G i |) for each of the two subgraphs, which is in O(|G| log |G|). Computing the single-source distances in G to the boundary nodes is done in O(|G|α(|G|)), as we explain in Section 4. The extension to all nodes of G is again done in O(|G i | log |G i |) for each subgraph. Distances from the given source are computed in an additional O(|G| log |G|) time. Thus the total running time of one invocation is O(|G| log |G|). Therefore the running time of the entire algorithm is given by</p><formula xml:id="formula_19">T (|G|) = T (|G 0 |) + T (|G 1 |) + O(|G| log |G|) = O(|G| log 2 |G|).</formula><p>Here we used the properties of the separator, namely that |G i | ≤ 2|G|/3 for i = 0, 1, and that |G 0 | +</p><formula xml:id="formula_20">|G 1 | = |G| + O( 񮽙 |G|).</formula><p>We omit the formal proof of this recurrence. Thus, the total running time of our algorithm is O(n log 2 n). We turn to the space bound. The space required for one invocation is O(|G|). Each of the two recursive calls can use the same memory locations one after the other, so the space is given by</p><formula xml:id="formula_21">S(|G|) = max{S(|G 0 |), S(|G 1 |} + O(|G|) = O(|G|) because max{|G 0 |, |G 1 |} ≤ 2|G|/3</formula><p>We have proved Theorem 1.1. Paths of type Q 2 (dashed black) do not cross P . Two LL paths (i.e., leaving and entering P from the left) are shown. For i &lt; i 񮽙 &lt; j &lt; j 񮽙 , the ij path and the i 񮽙 j 񮽙 path must cross at some node z.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">The Replacement-Paths Problem</head><p>In this section we show how to modify the algorithm of Emek et al. <ref type="bibr" target="#b3">[4]</ref> to obtain an O(n log 2 n) running time for the replacement-paths problem. This is another example of using a Monge property for finding row minima of a matrix. Similarly to Section 4, we deal with a matrix whose upper triangle satisfies a Monge property. However, the minima search problem is restricted to rectangular portions of that upper triangle. Hence, each such rectangular portion is entirely Monge (rather than falling staircase) so the SMAWK algorithm of Aggarwal et al. <ref type="bibr" target="#b1">[2]</ref> can be used (rather than Klawe and Kleitman's algorithm <ref type="bibr" target="#b12">[13]</ref>).</p><p>The O(n log 3 n) time-complexity of Emek et al. arises from the recursive calls to the District procedure. Given some 1 ≤ a &lt; b ≤ n, District(a, b) computes the row and column minima of the rectangular portion of a matrix 񮽙 len d,d 񮽙 defined by rows a to (a+ b)/2 and columns (a + b)/2 to b. Initially, District is called with a = 1 and b = the length of the shortest path from s to t. Then, District(a, (a + b)/2) and District((a + b)/2, b) are called recursively. <ref type="bibr">Emek et al.</ref> show how to use a Monge property (which they refer to as the noncrossing property) to compute District(a, b) using a divide and conquer technique in O((b−a) log(b−a) log n) time, leading to a total of O(n log 3 n) time for all calls to District. Our contribution is in showing that instead of divide-and-conquer one can use SMAWK to compute District(a, b) in O((b − a) log n) time, which leads to a total of O(n log 2 n) time. We next describe in more de- Paths of type Q 2 (dashed black) do not cross P . Two LR paths (i.e., leaving P from the left and entering P from the right) are shown. For i &lt; i 񮽙 &lt; j &lt; j 񮽙 , the ij 񮽙 path and the i 񮽙 j path must cross at some node z. tail the matrix 񮽙 len d,d 񮽙 and the procedure District(a, b). Let P = (u 0 , u 1 , . . . , u p+1 ) be the shortest path from s = u 0 to t = u p+1 in the graph G. Consider the replacement s-to-t path Q that avoids the arc e in P . Q can be decomposed as Q 1 Q 2 Q 3 where Q 1 is a prefix of P , Q 3 is a suffix of P , and Q 2 is a subpath from some u i to some u j that avoids any other vertex in P . The first arc of Q 2 can be left or right of P and the last arc of Q 2 can be left or right of P (see <ref type="bibr" target="#b3">[4]</ref> for a common formal definition of the left-of and right-of relations). In all four cases Q 2 never crosses P (see <ref type="figure" target="#fig_6">Fig. 7</ref> and <ref type="figure" target="#fig_7">Fig. 8</ref>).</p><p>For nodes x, y, the x-to-y distance is denoted by δ G (x, y). The distances δ G (s, u i ) and δ G (u i , t) for i = 0, . . . , p + 1 are computed from P in O(p) time, and stored in a Proof. Note that adding δ G (s, u i ) to all of the elements in the i th row or δ G (u j , t) to all elements in the j th column preserves Monge properties. Therefore, it suffices to show that the upper triangle of PAD-query G,d,d 񮽙 satisfies a Monge property.</p><p>When d = d 񮽙 , the proof is essentially the same as that of Lemma 4.3 because the Q 2 paths have the same crossing property as the paths in Lemma 4.3. This is illustrated in <ref type="figure" target="#fig_6">Fig. 7</ref>. We thus establish that the convex Monge property holds.</p><p>When d 񮽙 = d 񮽙 , Lemma 4.3 applies but with the convex Monge property replaced with the concave Monge property. To see this, consider the crossing paths in <ref type="figure" target="#fig_7">Fig. 8</ref>. In contrast to <ref type="figure" target="#fig_6">Fig. 7</ref>, this time the crossing paths are i-to-j 񮽙 and i 񮽙 -to-j.  <ref type="figure">a)</ref> log n) time. In the case of the concave Monge property, we cannot directly apply SMAWK. By negating all the elements we get a convex Monge matrix but we are now looking for its row and column maxima. As discussed in Section 2.3, SMAWK can be used to find row and column maxima of a convex Monge matrix.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The solid blue path is an r-to-v shortest path in G. It can be decomposed into four subpaths. The subpaths P 1 and P 3 (P 2 and P 4 ) are shortest paths in G 1 (G 0 ) between boundary nodes. The r-to-v shortest paths in G 0 and G 1 are shown in gray in the background.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>procedure shortest-paths(G,</head><label></label><figDesc>s) input: a directed embedded planar graph G with arc-lengths, and a node s of G output: a table d giving distances in G from s to all nodes of G 0 ifG has ≤ 2 nodes, the problem is trivial; return the result 1 find a Jordan separator C of G with O( √ n) boundary nodes 2 letG 0 ,G 1 be the external and internal parts of G with respect to C 3 letr be a boundary node Recursive call 4 fori = 0, 1: let d i = shortest-paths(G i , r) intra-part 5 fori = 0, 1: use d i as input to the multiple-source shortest-path algorithm boundary to compute a</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Figure 3: The shortest-path algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Lemma 4.4. A single iteration of the dynamic program can be computed in O(|V c |α(|V c |)) time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Lemma 5 .</head><label>5</label><figDesc>3. φ i defined in Line 3 of Fig. 6 is a feasible price function for G 񮽙 i .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: The s-t shortest path P is shown in solid blue. Paths of type Q 2 (dashed black) do not cross P . Two LL paths (i.e., leaving and entering P from the left) are shown. For i &lt; i 񮽙 &lt; j &lt; j 񮽙 , the ij path and the i 񮽙 j 񮽙 path must cross at some node z.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: The s-t shortest path P is shown in solid blue. Paths of type Q 2 (dashed black) do not cross P . Two LR paths (i.e., leaving P from the left and entering P from the right) are shown. For i &lt; i 񮽙 &lt; j &lt; j 񮽙 , the ij 񮽙 path and the i 񮽙 j path must cross at some node z.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Lemma 7 . 2 .</head><label>72</label><figDesc>Procedure District(a, b) can be computed in O((b − a) log n) time. Proof. Recall that, for every pair d, d 񮽙 , District(a, b) computes the row and column minima of the rectangular submatrix of 񮽙 len d,d 񮽙 defined by rows a to (a + b)/2 and columns (a + b)/2 to b. By Lemma 7.1, this entire submatrix has a Monge property. In the case of the convex Monge propery, we can use SMAWK to find all row and column minima of the submatrix by querying only O(b − a) entries each in O(log n) time for a total of O((b −</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>table δ i such that δ i [u, v] is the u-to-v distance in G i for distances every pair u, v of boundary nodes single-source inter-part 6 use δ 0 and δ 1 to compute a table B such that boundary B[v] is the r-to-v distance in G for every boundary node v</head><label>δ</label><figDesc></figDesc><table>distances 

single-source 

7 
fori = 0, 1: use table B and Dijkstra's algorithm to compute a table d 񮽙 

i 

inter-part 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>0 and G 1 be the external and internal parts of G with respect to C. Let δ 0 and δ 1 be the all-pairs distances between nodes in V c in G 0 and in G 1 respectively.2 α(|V c |)) time and O(|V c |) space. 1: e 0 [v] = ∞ for all v ∈ V c 2: e 0 [r] = 0 3: for j = 1, 2, 3, . . . , |V c | 4:</head><label></label><figDesc></figDesc><table>Theorem 4.1. Let G be a directed graph with arbitrary 
arc-lengths. Let C be a separator in G and let G Let r ∈ V c 
be an arbitrary node on the boundary. There exists an 
algorithm that computes the from-r distances in G to all 
nodes in V c in O(|V c | </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>iteration of Line 4 in O(|V c |α(|V c |)) time. Let i = j mod 2, so this iteration uses distances in G i . Since all boundary nodes lie on the boundary of a single face of G i , there is a natural cyclic clockwise order v 1 , v 2 , . . . , v |Vc| on the nodes in V c . Define a |V c | × |V c | matrix A with elements A kk</head><label></label><figDesc>Lemma 4.1 and Lemma 4.2, it immediately follows that the table e |Vc| stores the from-r shortest path distances in G, so the assignment in Line 5 is justified, and the table B also stores these distances. We now show how to perform all the minimizations in the j th</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>. The idea is to use d i and B in order to construct a modified version of G i , denoted G 񮽙 i , so that the from-r distances in G 񮽙 i are the same as the from- r distances in G. We then construct a feasible price function φ i for G 񮽙 i and use Dijkstra's algorithm on G 񮽙 i</head><label></label><figDesc></figDesc><table>describes how to 
compute d 񮽙 
i </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>1 : let G 񮽙 i be the graph obtained from G i by removing arcs entering r, and adding an arc ru of length B[u] for every boundary node u 2: let p i = max{B[u] − d i [u] : u a boundary node} 3: define a price function φ i for G 񮽙 i : φ i [v] = 񮽙 p i if v = r d i [v] otherwise 4: use Dijkstra's algorithm with price function φ i to compute a table d 񮽙 i such that d 񮽙 i [v] is the r-to-v distance in G 񮽙 i for every node v of G 񮽙 i</head><label>1</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>table . The p × p matrix 񮽙 len d,d 񮽙 is defined in [4] as follows: 񮽙 len d,d 񮽙 (i, j) is the length of the shortest s-to-t path of the form Q 1 Q 2 Q 3 described above where Q 2 starts at u i via a left-going arc if d = L or a right-going arc if d = R, and Q 2 ends at u j via a left-going arc if d 񮽙 = L and a right-going arc if d 񮽙 = R. The length of Q 2 is denoted PAD-query G,d,d 񮽙 (i, j). It can be computed in O(log n) time by a single query to a data structure that(i, j) = δ G (s, u i )+PAD-query G,d,d 񮽙 (i, j)+δ G (u j , t), and query any entry of 񮽙 len d,d 񮽙 in O(log n) time.</head><label>.</label><figDesc></figDesc><table>Emek et 
al. call PADO (Path Avoiding Distance Oracle). Thus, 
we can write 
񮽙 
len d,d 񮽙 Lemma 7.1. The upper triangle of 񮽙 
len d,d 񮽙 satisfies a 
Monge property. 

</table></figure>

			<note place="foot" n="2"> This stage can actually be implemented in O(n) using the algorithm of Henzinger et al. [9]. This however does not change the overall running time of the algorithm.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Applications of generalized matrix searching to geometric algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aggarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Klawe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="3" to="23" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Geometric applications of a matrixsearching algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aggarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Klawe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Moran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Wilber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="195" to="208" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Ratio regions: A technique for image segmentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Conference on Pattern Recognition</title>
		<imprint>
			<biblScope unit="volume">02</biblScope>
			<biblScope unit="page">557</biblScope>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A near-linear time algorithm for computing replacement paths in planar directed graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Emek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Peleg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Roditty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA &apos;08: Proceedings of the Nineteenth Annual ACM-SIAM symposium on Discrete Algorithms</title>
		<meeting><address><addrLine>Philadelphia, PA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="428" to="435" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Planar graphs, negative weight edges, shortest paths, and near linear time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Fakcharoenphol</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">72</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="868" to="889" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Fibonacci heaps and their uses in improved network optimization algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">L</forename><surname>Fredman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="596" to="615" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Faster scaling algorithms for network problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">N</forename><surname>Gabow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1013" to="1036" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Scaling algorithms for the shortest paths problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">V</forename><surname>Goldberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="494" to="504" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Faster shortest-path algorithms for planar graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">N</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Subramanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="23" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Region extraction from multiple images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Ishikawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Jermyn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th IEEE International Conference on Computer Vision</title>
		<meeting><address><addrLine>Los Alamitos, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="509" to="516" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Globally optimal regions and boundaries as minimum ratio weight cycles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">H</forename><surname>Jermyn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Ishikawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Pattern Anal. Mach. Intell</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1075" to="1088" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Efficient algorithms for shortest paths in sparse graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">B</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="1" to="13" />
			<date type="published" when="1977" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An almost linear time algorithm for generalized matrix searching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Klawe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Kleitman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal On Discrete Math</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="81" to="97" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Multiple-source shortest paths in planar graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">N</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th Annual ACM-SIAM Symposium on Discrete Algorithms</title>
		<meeting>the 16th Annual ACM-SIAM Symposium on Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="146" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Generalized nested dissection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Lipton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Rose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Numerical Analysis</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="346" to="358" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A separator theorem for planar graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Lipton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="177" to="189" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Finding small simple cycle separators for 2-connected planar graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="265" to="279" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Flow in planar graphs with multiple sources and sinks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1002" to="1017" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Mémoire sur la théorie des déblais et ramblais</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Monge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mém. Math. Phys. Acad. Roy. Sci</title>
		<imprint>
			<biblScope unit="page" from="666" to="704" />
			<date type="published" when="1781" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Stereo correspondence with compact windows via minimum ratio cycle</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Veksler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Pattern Anal. Mach. Intell</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1654" to="1660" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
