<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:51+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Verifying Safety of a Token Coherence Implementation by Parametric Compositional Refinement 񮽙</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Burckhardt</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajeev</forename><surname>Alur</surname></persName>
							<email>alur@cis.upenn.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milo</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
							<email>milom@cis.upenn.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Verifying Safety of a Token Coherence Implementation by Parametric Compositional Refinement 񮽙</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>130</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We combine compositional reasoning and reachability analysis to formally verify the safety of a recent cache coherence protocol. The protocol is a detailed implementation of token coherence, an approach that decouples correctness and performance. First, we present a formal and abstract specification that captures the safety substrate of token coherence , and highlights the symmetry in states of the cache controllers and contents of the messages they exchange. Then, we prove that this abstract specification is coherent, and check whether the implementation proposed by the protocol designers is a refinement of the abstract specification. Our refinement proof is parametric in the number of cache controllers, and is compositional as it reduces the refinement checks to individual controllers using a specialized form of assume-guarantee reasoning. The individual refinement obligations are discharged using refinement maps and reachability analysis. While the formal proof justifies the intuitive claim by the designers about the ease of verifiability of token coherence, we report on several bugs in the implementation, and accompanying modifications, that were missed by extensive prior simulations.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Shared memory multiprocessors have become the most important architecture used for commercial and scientific workloads. Such systems use hardware cache coherence protocols to create the illusion of a single, shared memory without caches. These protocols are important factors of the overall system performance, and numerous optimizations contribute to their complexity. Since hard-to-cover race conditions elude simulations of the protocols, formal methods are often employed to verify their correctness.</p><p>Token Coherence is a new approach to cache coherence protocols that decouples correctness requirements from performance choices, claiming to improve both performance and verifiability <ref type="bibr" target="#b21">[22]</ref>. Separate correctness mechanisms ensure safety and liveness. Safety is achieved by token counting: per memory location, 1. We present a formal specification of the safety substrate of token coherence.</p><p>This abstract protocol is based on rewrite rules and multisets, and expresses the symmetry between components and messages. It applies to arbitrary network topologies, cache numbers, and even cache hierarchies. 2. We prove manually that the abstract protocol is safe (i.e. coherent). The verification problem is thus reduced to checking that the implementation correctly refines the abstract protocol. 3. We prove that the refinement can be verified for each component individually, by replacing its context with an abstraction. We prove that this decomposition into local refinement obligations is sound, using a variant of assume-guarantee reasoning based on contextual refinement, and performing an induction on the number of caches. 4. We discharge the local refinement obligations with the conventional model checker Murϕ <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b10">11]</ref>. To obtain the models, we manually translate, abstract and annotate the implementation code. This procedure reduces the refinement checking to a reachability problem, which Murϕ solves by enumerative state space search.</p><p>Even though the protocol implementation had been extensively simulated prior to this work, we discovered a few bugs, and were able to fix them quickly with the help of counterexamples produced by the model checker. The compositional refinement method proved to be effective in avoiding the state space explosion problem <ref type="bibr" target="#b15">[16]</ref> which is commonly encountered in system-level models <ref type="bibr" target="#b27">[28]</ref>.</p><p>Because of the page limit, we had to omit most proofs. A more complete version of this article can be found online <ref type="bibr" target="#b6">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related Work</head><p>Prior work on formal verification of cache coherence varies in (1) the protocol complexity and level of detail (2) the coverage achieved (safety, liveness, parametric systems) (3) the underlying tools (enumerative or symbolic model checkers, decision procedures, theorem provers), (4) reduction techniques (symmetry, abstraction, compositional verification), and (5) degree of automation.</p><p>We refer to Pong and Dubois <ref type="bibr" target="#b27">[28]</ref> for a general survey, and to various illustrative efforts <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b2">3]</ref>.</p><p>Our proof methodology modifies and combines a variety of ideas in the formal verification literature. These include assume-guarantee reasoning for compositional verification (c.f. <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b24">25]</ref>), structural induction for proving properties for arbitrary number of processes (c.f. <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b3">4]</ref>), data abstraction (c.f. <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b16">17]</ref>), use of term rewrite systems for hardware verification <ref type="bibr" target="#b4">[5]</ref>, and proving refinement using reachability analysis (c.f. <ref type="bibr" target="#b17">[18]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Process Model</head><p>In this section, we define the process model and introduce our assume-guarantee proof rules. We chose to define the process model from scratch, so to keep it concise and self-contained, and to obtain the desired combination of features. Except for the specialized definition of contextual refinement, all concepts (traces, composition, refinement) are standard and appear in many variations and combinations in the process algebra literature <ref type="bibr" target="#b28">[29]</ref>.</p><p>A process is defined as the set of its traces, which are finite words over an alphabet Σ of events. Σ is considered fixed and common to all processes. We further partition Σ = Σ e ∪Σ c into disjoint subclasses: Σ e contains events that are visible to external observers of the system only, while Σ c describes synchronous communication events. Matching events in Σ c (e.g. sending and receiving of a message) are denoted σ and σ. Definition 2.1. A process P over Σ is a non-empty prefix-closed language; i.e. P ⊂ Σ * , P 񮽙 = ∅ and for all u, v ∈ Σ * : uv ∈ P ⇒ u ∈ P . A process P refines a process Q, written P 񮽙 Q, iff P ⊂ Q. A process P is closed if P ⊂ Σ * e .</p><p>The refinement relation 񮽙 is a complete partial order on the processes. The bottom (silent) process {񮽙} has but one trace: the empty string. The top (universal) process Σ * includes all possible traces.</p><p>When composing processes, we merge their traces by interleaving their events and hiding mutual communication.</p><p>Definition 2.2. Let u, v, w ∈ Σ * be traces. We define the relation u | v 񮽙 w (speak: u, v can combine to form w) by the following inference rules:</p><formula xml:id="formula_0">񮽙 | 񮽙 񮽙 񮽙 (epsilon) u | v 񮽙 w σ ∈ Σ c uσ | vσ 񮽙 w (communication) u | v 񮽙 w σ ∈ Σ uσ | v 񮽙 wσ (l-event) u | v 񮽙 w σ ∈ Σ u | vσ 񮽙 wσ (r-event)</formula><p>Example 2.3. Let Σ e = {a, b, c, d} and Σ c = {e, e}. Then we have</p><formula xml:id="formula_1">ab | cd 񮽙 acbd ab | cd 񮽙 abcd ae | eb 񮽙 ab ae | eb 񮽙 aeeb but not ae | eb 񮽙 ba. Definition 2.4. Let P , Q be processes. Then P | Q . = {w ∈ Σ * | ∃u ∈ P : ∃v ∈ Q : u | v 񮽙 w}.</formula><p>Composition is commutative and associative. Composition does not restrict its components: for processes P, Q we always have P 񮽙 P | Q. This same style of communication is used by CCS <ref type="bibr" target="#b25">[26]</ref>.</p><p>Refinement is preserved by composition: if P 񮽙 񮽙 P , then P 񮽙 | Q 񮽙 P | Q. We can use this fact to prove that a system implementation refines its specification</p><formula xml:id="formula_2">P 񮽙 | Q 񮽙 񮽙 P | Q<label>(1)</label></formula><p>from the simpler, local refinement conditions</p><formula xml:id="formula_3">P 񮽙 񮽙 P and Q 񮽙 񮽙 Q .<label>(2)</label></formula><p>However, this method is not very powerful, because the refinements (2) do often not hold because of implicit assumptions on the context. Assume-guarantee reasoning remedies this shortcoming. We provide the context as an explicit subscript to the refinement relation, enabling us to conclude (1) from</p><formula xml:id="formula_4">P 񮽙 񮽙 Q P and Q 񮽙 񮽙 P Q .<label>(3)</label></formula><p>Most process models used for compositional refinement of hardware <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b23">24]</ref> can express the contextual refinement P 񮽙 񮽙 Q P directly as P 񮽙 񮽙 Q 񮽙 P (using synchronous parallel composition). The same does not work in our context (as exemplified by the observation 5 below), so we use a direct definition instead.</p><p>Definition 2.5 (Contextual refinement). Let P, P 񮽙 , C be processes. Then P 񮽙 is said to refine P in context C, written P 񮽙 񮽙 C P , iff for all traces u ∈ P 񮽙 the following condition holds: if there is a trace v ∈ C such that u ↑ Σ c = v ↑ Σ c (i.e. the communication events in u, v match up), then u ∈ P .</p><p>Intuitively, we require that all behaviors of P 񮽙 that are actually possible within an environment that adheres to C are allowed by P .</p><p>The following observations provide insight about contextual refinement.</p><p>1. For any process C, 񮽙 C is a pre-order on processes.</p><p>2. If P 񮽙 񮽙 C P , and C 񮽙 񮽙 C, then P 񮽙 񮽙 C 񮽙 P . 3. Refinement in a universal context corresponds to regular refinement:</p><formula xml:id="formula_5">P 񮽙 񮽙 Σ * P ⇔ P 񮽙 񮽙 P . 4</formula><p>. Refinement in a silent context corresponds to refinement of closed processes:</p><formula xml:id="formula_6">P 񮽙 񮽙 {񮽙} P ⇔ (P 񮽙 ∩ Σ * e ) 񮽙 (P ∩ Σ * e ) 5. The refinement P 񮽙 | C 񮽙 {񮽙} P | C does not imply P 񮽙 񮽙 C P , because the traces of P 񮽙 | C do not indicate what mutual communication takes place.</formula><p>However, the converse always holds.</p><p>To avoid circularity in the assume-guarantee reasoning, we conservatively require that the specification processes can always engage in a subset of communication events Σ r ⊂ Σ c that is sufficiently large, i.e. Σ r ∪ Σ r = Σ c ; in our case, we will take care of this requirement by having specification processes accept any message at any time 1 . We use the following definition to formalize this property of processes. Definition 2.6. Let P be a process over Σ, and Σ r ⊂ Σ be an event subset. P is called Σ r -enabled iff ∀u ∈ P : ∀σ ∈ Σ r : uσ ∈ P .</p><p>We now give the two proof rules for compositional refinement. The first rule is simpler, but restricted to two components. The second rule is a generalization suited for induction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2.7. Let P, P 񮽙 , Q, Q 񮽙 , C be processes over</head><formula xml:id="formula_7">Σ = Σ e ∪ Σ c . Let Σ r ⊂ Σ c such that Σ r ∪ Σ r = Σ c .</formula><p>Then the following proof rules are sound:</p><formula xml:id="formula_8">P 񮽙 񮽙 Q P P,Qare Σ r -enabled Q 񮽙 񮽙 P Q P 񮽙 | Q 񮽙 񮽙 {񮽙} P | Q P 񮽙 񮽙 Q|C P P,Qare Σ r -enabled Q 񮽙 񮽙 P |C Q P 񮽙 | Q 񮽙 񮽙 C P | Q</formula><p>For example, consider again the local refinement obligations (3). Suppose that the specification processes P, Q can receive messages at any time. We can then apply the first proof rule to conclude that P 񮽙 | Q 񮽙 refines P | Q, if there is no external communication, i.e., there are no other components in the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Token Coherence</head><p>In this section, we introduce a formal specification of the safety substrate of token coherence. This abstract protocol is a generalization of the MOESI token counting rules in Martin's dissertation <ref type="bibr" target="#b19">[20]</ref>. We then justify it's use as a specification, by proving that it is coherent, and with it any implementation that refines it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Background: Cache Coherence</head><p>Cache coherence describes the contract between the memory system and the processor in a shared-memory multiprocessor. It is typically established at the granularity of a cache block. A memory system is cache coherent if for each block, writes are serialized, and reads get the value of the last write.</p><p>Definition 3.1. Let V be the set of values of a fixed cache block, and v 0 ∈ V the initial value. Let Σ rw = {rd(v), wr(v) | v ∈ V } be the alphabet of events, describing accesses to the block by some processor. Then the coherent traces of the system are given by the following regular language over Σ rw :</p><formula xml:id="formula_9">Coh = rd(v 0 ) * 񮽙 񮽙 v∈V wr(v) rd(v) * 񮽙 *</formula><p>Token coherence, like many contemporary coherence protocols such as the popular MOESI protocol family <ref type="bibr" target="#b30">[31]</ref>, provides this strong form of coherence by enforcing a "single writer, multiple reader" policy 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Abstract Protocol</head><p>In our abstract protocol, system components and messages are of the same type and treated completely symmetrically: both are represented by token bags. Token bags are finite multisets (or bags) over some set T of tokens, and may be required to satisfy some additional constraints (well-formedness). The tokens in the bag constitute the state of the component, or the contents of the message.</p><p>The state of the entire system is represented as yet another bag that encloses the token bags of the individual components and messages. The sending of a message is modeled as a division, where a bag separates into two bags, dividing its tokens. The receipt of a message, symmetrically, is modeled as a fusion of token bags. Change is expressed by local reactions: tokens within a bag can be consumed, produced or modified according to rewrite rules.</p><p>We give two preliminary definitions before proceeding to the definition of the abstract protocol. For example, for any t 1 , t 2 ∈ T , all of the following denote the same T -bag:</p><formula xml:id="formula_10">[ t 2 1 t 2 ] = [ t 1 t 1 t 2 ] = {t 1 t 1 t 2 , t 1 t 2 t 1 , t 2 t 1 t 1 }.</formula><p>The exponent is a convenient notation for repeated symbols, and often used with regular languages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.3 (Token Transition System). A TTS is a tuple</head><formula xml:id="formula_11">(T, B, I, Σ e , W )</formula><p>where T is a set of tokens, B ⊂ M(T ) defines the set of well-formed Tbags, I ∈ M(B) is the initial configuration, Σ e is a set of local events, and</p><formula xml:id="formula_12">W ⊂ Σ e × M(T ) × 2 T × M(T ) is a set of rewrite rules.</formula><p>A rewrite rule (a, x, H, y) ∈ W is denoted a: x =⇒ H y. It describes a reaction labeled a that can occur whenever all the tokens in x are together in a bag, and <ref type="bibr" target="#b1">2</ref> We are considering only the interface between the memory system and the processor here. Independently, the contract between the processor and the programmer may use weaker forms of coherence that involve temporal reordering of events, as specified by the memory model. the bag does not contain any of the inhibiting tokens listed in H. When the reaction fires, the tokens x are replaced by the tokens y. If H is empty, we omit it from the notation.</p><p>A TTS defines a process over the alphabet</p><formula xml:id="formula_13">Σ = Σ e ∪ Σ c , with Σ c = {snd(b), rcv(b) | b ∈ B}, with the traces {u ∈ Σ * | ∃C ∈ M(B) : I u − → C},</formula><p>where we define the transition relation C u − → C 񮽙 with the inference rules 3 below.</p><formula xml:id="formula_14">C 񮽙 − → C (stutter) C u − → C 񮽙 C 񮽙 v − → C 񮽙񮽙 C uv −→ C 񮽙񮽙 (trans) x 񮽙 y ∈ B [ C x y ] 񮽙 − → [ C x񮽙 y ] (fusion) [ C x񮽙 y ] 񮽙 − → [ C x y ] (division) a: x =⇒ H y |z| ∩ H = ∅ y 񮽙 z ∈ B [ C x񮽙 z ] a − → [ C y 񮽙 z ] (reaction) [ C x ] snd(x) − −−− → [ C ] (send) [ C ] rcv(x) − −−− → [ C x ]<label>(receive)</label></formula><p>Token transition systems have a feel of concurrency much like a biological system where reactive substances are contained in cells that can undergo fusion and division. Chemical abstract machines <ref type="bibr" target="#b5">[6]</ref> capture the same idea (with molecules, membranes, and solutions instead of tokens, bags, and configurations), but are also different in many ways (for example, they do not have fusion or division). R is a regular token as used by token coherence. O(s) is a owner token in one of two states s ∈ {C, D} (clean or dirty). D(v) is an instance of the data, with value v ∈ V . M (v) is a memory cell containing the value v ∈ V . -B is defined by imposing two conditions on a token bag x ∈ M(T ):</p><p>• if x contains data D(v), then it must contain at least one regular token R or an owner token O(s).</p><formula xml:id="formula_15">• if x contains a dirty owner token O(D), then it must contain data D(v). -I . = [ [ R m−1 O(C) M (v 0 ) ] ]. -Σ e .</formula><p>= {rd(v), wr(v), memread, memwrite, copy, drop | v ∈ V }. -W consists of the rewrite rules shown in <ref type="figure">Fig. 1</ref>. <ref type="figure" target="#fig_0">Fig. 2</ref> shows an example trajectory of the abstract protocol. Next, we explain the reaction rules and their interaction in some more detail. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>rd(v):</head><p>[</p><formula xml:id="formula_16">D(v) ] =⇒ [ D(v) ]</formula><p>wr(w): </p><formula xml:id="formula_17">[ R m−1 O(s) D(v) ] =⇒ {D(v)} [ R m−1 O(D) D(w) ] memread: [ M (v) O(C) ] =⇒ [ M (v) O(C) D(v) ] memwrite: [ M (v) O(D) D(w) ] =⇒ [ M (w) O(C) D(w) ] copy: [ D(v) ] =⇒ [ D(v) D(v) ] drop: [ D(v) ] =⇒ [ ]</formula><formula xml:id="formula_18">memread − −−−− → [ [ M (v0) D(v0) O(C) R m−1 ]D [ ]C 1 [ ]C 2 ] -send data w/ tokens 񮽙 − → [ [ M (v0) ]D [ D(v0) O(C) R m−1 ] [ ]C 1 [ ]C 2 ] C1 receives response 񮽙 − → [ [ M (v0) ]D [ D(v0) O(C) R m−1 ]C 1 [ ]C 2 ]</formula><p>C1 writes value v1</p><formula xml:id="formula_19">wr(v 1 ) − −−− → [ [ M (v0) ]D [ D(v1) O(D) R m−1 ]C 1 [ ]C 2 ]</formula><p>C2 requests S (requests are abstracted away)</p><formula xml:id="formula_20">C1 responds -copy data copy −−→ [ [ M (v0) ]D [ D(v1) D(v1) O(D) R m−1 ]C 1 [ ]C 2 ] -send data w/ token 񮽙 − → [ [ M (v0) ]D [ D(v1) O(D) R m−2 ]C 1 [ D(v1) R ] [ ]C 2 ]</formula><p>rd(v) reads a value from a data instance (it can be applied at any time, and does not modify the state). wr(w) modifies a data token, and can only be applied if all m tokens (one owner token and m − 1 regular tokens) are present, and no other data copies are in the same bag (which guarantees that the data token being modified is the only one in the system).</p><p>To guarantee proper writebacks of modified data, a special owner token is used. The owner token records the clean/dirty state, i.e. whether the memory value is stale. When modifying data, the owner token is set to dirty. When the memory writes back the data (memwrite), the owner token is cleaned. memread loads data from the memory only if there is a clean owner token, and thereby avoids reading stale data.</p><p>The rules copy and drop imply that data instances D(v) can be freely copied or destroyed, subject only to the restriction enforced by B that all bags are wellformed -for example, whoever has the dirty owner token must keep at least one data instance.</p><p>We can now prove that the abstract protocol is coherent.</p><p>Theorem 3.5. The closed system T m ∩ Σ * e is coherent:</p><formula xml:id="formula_21">(T m ∩ Σ * e ) ↑ Σ rw ⊂ Coh</formula><p>To prove this, verify that (1) all of the following invariants hold in the initial state I and <ref type="formula" target="#formula_3">(2)</ref> prove (by induction on derivations) that if the invariants hold for a state C, they hold for any state</p><formula xml:id="formula_22">C 񮽙 such that C u − → C 񮽙 for some u ∈ Σ * e .</formula><p>1. Together, these invariants guarantee that all data instances D(v) are always up-to-date; therefore, reads get the correct value which implies coherence. All state is modeled by tokens, and there is no distinction between components and messages. This symmetry points out interesting design directions. For example, we consider the memory cell M (v) to be stationary. However, the formal token rules do not impose this restriction and and could be used as an implementation guideline for a system with home migration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Implementation</head><p>In this section, we describe how we verified the safety of a detailed implementation of token coherence for an arbitrary number of caches. We describe how we used compositional verification to deal with the parametric character, and how we employed abstraction to handle the fine level of detail. We conclude with a list of discovered bugs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Protocol Implementation</head><p>The protocol implementation was developed by Martin et al. for architecture research on token coherence <ref type="bibr" target="#b19">[20]</ref>, and was extensively simulated prior to this work. It consists of finite state machines (FSM) for the cache and memory controllers, augmented with message passing capabilities. The FSMs are specified using the domain-specific language SLICC (Specification Language for Implementing Cache Coherence) developed by Martin et al. The FSMs include all necessary transient states that arise due to the asynchronous nature of the protocol. The memory and cache controller amount to 600 and 1800 lines of SLICC code, respectively, a scale on which purely manual analysis methods are impractical, in particular because these low-level specifications are usually changed over time.</p><p>The SLICC compiler generates (1) executables for the simulation environment and (2) summary tables containing the control states, events and transitions in a human-readable table format 4 . <ref type="figure">Fig. 1</ref> shows the summary table for the memory controller, with its 3 states and 11 events. Note that some parts of the state, such as the number of tokens, or the actual data values, are stored in variables that are not visible in the summary table.</p><p>Due to lack of space, we can not reproduce the summary table for the cache controller (17 states and 20 events), and we can not explain further the meaning of the states and events. The complete SLICC code and interactive HTMLtables are online <ref type="bibr" target="#b20">[21]</ref>, along with implementations of three other cache coherence protocols.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Parametric Compositional Refinement Proof</head><p>Consider the system S 񮽙 n consisting of n caches C 񮽙 , a directory controller D 񮽙 (which is attached to the memory, and sometimes called memory controller), and a interconnection network N 񮽙 . We consistently use primes for implementation processes to distinguish them from specification processes:</p><formula xml:id="formula_23">S 񮽙 n . = C 񮽙 | C 񮽙 | · · · | C 񮽙 񮽙 񮽙񮽙 񮽙 n | N 񮽙 | D 񮽙<label>(4)</label></formula><p>In the beginning, the memory holds all tokens. We define local specification processes as token transition systems:</p><formula xml:id="formula_24">D . = T m = (T, B, I, Σ e , W ) C . = (T, B, [ [ ] ], Σ e , W ) N . = (T, B, [ [ ] ], Σ e , W )</formula><p>Since a token transition system already models all possible distributions of the state, no new behavior arises when it is composed:</p><formula xml:id="formula_25">C | D = D C | C = C</formula><p>We now state the central result which (together with Theorem 3.5) allows us to verify the implementation components D 񮽙 , C 񮽙 and N 񮽙 individually, each within an abstracted context rather than a fully instantiated system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4.1. If the implementation processes satisfy the local refinement obligations</head><formula xml:id="formula_26">D 񮽙 񮽙 C D C 񮽙 񮽙 D C N 񮽙 񮽙 D C</formula><p>then for all n ∈ N, we have S 񮽙 n 񮽙 {񮽙} T m , i.e., the system refines the formal token coherence protocol.</p><p>The proof uses induction and the proof rules (Theorem 2.7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Discharging the Obligations</head><p>To discharge the remaining obligations, we used manual translation, abstraction, and annotation, and the explicit model checker Murϕ <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b10">11]</ref>. The following steps give an overview of the method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Obtain models D 񮽙 , C 񮽙 for the memory and cache controller implementations.</head><p>This step involves translating the SLICC code to Murϕ, instrumenting it with the read/write events relevant for coherence, and abstracting both the state space and the message format. <ref type="figure" target="#fig_0">Fig. 2</ref> shows snippets of translated code. The SLICC instructions that fell prey to the abstraction are in slanted face. For example, only a single cache block is modeled, therefore the code dealing with addresses is abstracted away. Also, message source and destination fields are irrelevant due to the deep symmetry of formal token coherence. Furthermore, two data values are sufficient 5 .</p><p>2. Obtain good encodings for the specification/environment processes D, C. We can take advantage (1) of the global system invariants established earlier and (2) of the fact that fusion and division are not observable. For example, the flattening map</p><formula xml:id="formula_27">[ b 1 b 2 . . . b k ] 񮽙 → b 1 񮽙 b 2 .</formula><p>. . 񮽙 b k provides a canonical representative state. This means that a single T -bag, rather than a multiset of T -bags, is sufficient to model the context. The models we obtain this way are compact and contribute much to the state-space economy of our approach. 3. Annotate the transitions of the implementation with matching specification transitions, and provide refinement maps. For each transition of the implementation process, the annotations specify a sequence of transitions of the specification process. <ref type="figure" target="#fig_0">Fig. 2</ref>  </p><formula xml:id="formula_28">− → q 1 v2 − → . . . v k −→ q k such that q 0 = q, q k = q 񮽙 and v 1 v 2 . . . v k = v (where v 1 v 2 . . . v k = 񮽙 for k = 0).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 4.3. Let I, S and C be processes defined by the trace sets of the labeled transition systems</head><formula xml:id="formula_29">L i . = (Q i , q0 i , Σ ∪ {񮽙}, δ i ) with i ∈ {I, S, C}. Let φ : Q I → Q S be a function (the refinement map). If R ⊂ Q I × Q C is a relation with the properties (R1)-(R4) listed below, then I 񮽙 C S. (R1) (q0 I , q0 C ) ∈ R, and φ(q0 I ) = q0 S (R2) If (q I , q C ) ∈ R and q C u − → q 񮽙 C for some u ∈ Σ e ∪ {񮽙}, then (q I , q 񮽙 C ) ∈ R. (R3) If (q I , q C ) ∈ R and q I u − → q 񮽙 I for some u ∈ Σ e ∪ {񮽙}, then (q 񮽙 I , q C ) ∈ R and φ(q I ) u =⇒ φ(q 񮽙 I ). (R4) If (q I , q C ) ∈ R and q I σ − → q 񮽙 I and q C σ − → q 񮽙 C for some σ ∈ Σ c , then (q 񮽙 I , q 񮽙 C ) ∈ R and φ(q I ) σ =⇒ φ(q 񮽙 I ).</formula><p>The full Murϕ code is available online <ref type="bibr" target="#b6">[7]</ref>.</p><p>6 Theorem 4.1 lists three obligations, but we skip N 񮽙 񮽙D C because it reduces to checking the reliablity of the network, which is trivial at the given abstraction level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Results</head><p>The translation required about two days of work. This estimate assumes familiarity with token coherence, and some knowledge of the implementation. We found several bugs of varying severity, all of which were missed by prior random simulation tests similar to those described by Wood et. al. <ref type="bibr" target="#b32">[33]</ref>. Seven changes were needed to eliminate all failures (not counting mistakes in the verification model):</p><p>1. The implementation included assertions that do not hold in the general system. Although they were mostly accompanied by a disclaimer like "remove this for general implementation", the latter was missing in one case. 2. The implementation was incorrect for the case where a node has only one token remaining and answers a Request-Shared. This situation was not encountered by simulation, probably because the number of tokens always exceeded the number of simulated nodes. We fixed the implementation, which involved adding another state to the finite state control. 3. Persistent-Request-Shared messages (which are issued if the regular RequestShared is not answered within a timeout period) suffered from the same problem, and we applied the same fix. 4. The implementation copied the dirty bit from incoming messages even if they did not contain the owner token. Although this does not compromise coherence, it can lead to suboptimal performance due to superfluous writebacks. This performance bug would have gone undetected had we only checked for coherence, rather than for refinement of the abstract protocol. 5. After fixing bug 4, a previously masked bug surfaced: the dirty bit was no longer being updated if a node with data received a dirty owner token. 6. Two shaded boxes (i.e. transitions that are specified to be unreachable) were actually reachable. This turned out to be yet another instance of the same kind of problem as in bug 2. 7. Finally, another (last) instance of bug 2 was found and fixed.</p><p>As expected, the compositional approach heavily reduced the number of searched states. This kept computational requirements low, in particular considering that the results are valid for an arbitrary number of caches. The measurements in <ref type="figure" target="#fig_2">Fig. 3</ref> were carried out on a 300MHz Pentium III ThinkPad.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions and Future Work</head><p>We make three main contributions. First, we formally verified the safety of a system-level implementation of token coherence, for an arbitrary number of  caches. Second, we developed a general and formal specification of the safety substrate of token coherence, and prove its correctness. Third, we demonstrated that token coherence's "design for verification" approach indeed facilitates the verification as claimed.</p><p>Future work may address the following open issues. First, the methodology does not currently address liveness. Second, other protocols or concurrent computations may benefit from the high-level abstraction expressed by token transition systems, and offer opportunities for compositional refinement along the same lines. Third, much room for automation remains: for example, we could attempt to integrate theorem provers with the SLICC compiler.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Definition 3. 2 (</head><label>2</label><figDesc>Multisets). Let T be a set. Two words u, v ∈ T * are equiva- lent if one is a permutation of the other. The induced equivalence classes {[u] | u ∈ T * } are called finite multisets over T , or T -bags. Multiset union is defined as concatenation [u] 񮽙 [v] . = [uv]. The set of all T -bags is denoted M(T ). For x ∈ M(T ), let |x| denote the set of elements of T that occur in x.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 3. 4 (The abstract protocol).</head><label>4</label><figDesc>The safety substrate T m (where m is the number of tokens, a fixed parameter) is a TTS (T, B, I, Σ e , W ) where -T contains the following tokens:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Computational requirements for the model checking.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>Table 1 . The reaction rules of the abstract protocol.</head><label>1</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><head>Table 2 . A short example trajectory of the abstract protocol, representing a system with a memory D and two caches C1 and C2. For clarification, token bags carry sub- scripts indicating the component that they represent. Those subscripts are not part of the abstract protocol.</head><label>2</label><figDesc></figDesc><table>Description 
System trajectory 

initial state 
[ [ M (v0) O(C) R m−1 ]D [ ]C 1 [ ]C 2 ] 

C1 requests M 
(requests are abstracted away) 

D responds 

-read memory data 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>The number of regular tokens R in the system is m − 1</head><label></label><figDesc></figDesc><table>. 
2. There is always exactly one owner token O(s). 
3. There is always exactly one memory cell M (v). 
4. All data instances D(v) have the same values. 
5. If the owner token is clean, any data instances present have the same value 
as the memory cell. 
6. If there is a data token, it contains the value of the last write. Otherwise, 
the memory does. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Run the model checker Murϕ separately for the two relevant obligations 6 D 񮽙 񮽙 C D and C 񮽙 񮽙 D C. Proposition 4.3 listed below describes how the contextual refinement is dis- charged. The state enumeration performed by the model checker effectively constructs and verifies the relation R, which describes the reachable states of the implementation process I within the abstract context C. The annota</head><label></label><figDesc></figDesc><table>shows such annotations in uppercase. The re-
finement maps are functions that map a controller state to its corresponding 
token bag. 
4. -
tions provided by the user eliminate the need for existential quantification. 
The model checker also validates the assertions present in the implementa-
tion code. 

Definition 4.2. For a labeled transition system (Q, q0, Σ∪{񮽙}, δ), states q 1 , q 2 ∈ 
Q and a word v ∈ Σ  *  we define: q 

v 

=⇒ q 񮽙 iff there exists a k ≥ 0 and a sequence of 
transitions q 0 

v1 

</table></figure>

			<note place="foot" n="1"> If this is not true by default, we could extend the specification to generate a special error event if it receives an unexpected message.</note>

			<note place="foot" n="3"> The variables in the rule templates range over the following domains: u, v, w ∈ Σ * , x, y, z ∈ B, and C, C 񮽙 , C 񮽙񮽙 ∈ M(B). Furthermore, as a syntactic shortcut, we allow C, C 񮽙 , C 񮽙񮽙 to match several positions in a multiset of token bags: for example, [ C z ] can match [ x y z ] by setting C = [ x y ].</note>

			<note place="foot" n="4"> More about the table format can be found in Sorin et al. [30].</note>

			<note place="foot" n="5"> Restricting the set of values is justified by the data-independence [32], which implies that we can freely substitute values in the traces.</note>
		</body>
		<back>
			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Conjoining specifications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="507" to="535" />
			<date type="published" when="1995-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Reactive modules</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th Annual IEEE Symposium on Logic in Computer Science</title>
		<meeting>the 11th Annual IEEE Symposium on Logic in Computer Science</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page">207</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Verifying network protocol implementations by symbolic refinement checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Conference on Computer-Aided Verification</title>
		<meeting>the 13th International Conference on Computer-Aided Verification</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Parameterized verification with automatically computed inductive assertions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Arons</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ruah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">D</forename><surname>Zuck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="221" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Using term rewriting systems to design and verify processors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arvind</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><forename type="middle">W</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="36" to="46" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The chemical abstract machine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Boudol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="217" to="248" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Verifying safety of a token coherence implementation by parametric compositional refinement: Extended version</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Burckhardt</surname></persName>
		</author>
		<ptr target="http://www.seas.upenn.edu/~sburckha/token/" />
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Parallel program design: a foundation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">M</forename><surname>Chandy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Misra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
			<publisher>AddisonWesley Longman Publishing Co., Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Verifying parameterized networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="726" to="750" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Automatic verification of parameterized cache coherence protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Delzanno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="53" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The murphi verification system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Conference on Computer Aided Verification</title>
		<meeting>the 8th International Conference on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="390" to="393" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Protocol verification as a hardware design aid</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Drexler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Design</title>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="522" to="525" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Reducing model checking of the many to the few</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kahlon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Automated Deduction</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="236" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Formal design of cache memory protocols in IBM. Formal Methods in System Design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">M</forename><surname>German</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="133" to="141" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Reasoning about systems with many processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">M</forename><surname>German</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">P</forename><surname>Sistla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="675" to="735" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Algorithms for automated protocol verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AT&amp;T Tech. J</title>
		<imprint>
			<date type="published" when="1990-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Control and data abstraction: The cornerstones of practical formal verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kesten</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal on Software Tools for Technology Transfer</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="328" to="342" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">P</forename><surname>Kurshan</surname></persName>
		</author>
		<title level="m">Computer-aided verification of coordinating processes: the automata-theoretic approach</title>
		<imprint>
			<publisher>Princeton University Press</publisher>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A structural induction theorem for processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">P</forename><surname>Kurshan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighth Annual ACM Symposium on Principles of Distributed Computing</title>
		<meeting>the Eighth Annual ACM Symposium on Principles of Distributed Computing</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1989" />
			<biblScope unit="page" from="239" to="247" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Token Coherence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
		<respStmt>
			<orgName>University of Wisconsin-Madison</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Protocol specifications and tables for four comparable MOESI coherence protocols: Token coherence, directory, snooping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
		<ptr target="http://www.cs.wisc.edu/multifacet/theses/milo_martin_phd/" />
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Token coherence: decoupling performance and correctness</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th Annual International Symposium on Computer Architecture</title>
		<meeting>the 30th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="182" to="193" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Formal verification of the Encore Gigamax cache consistency protocol</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Schwalbe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Shared Memory Multiprocessing</title>
		<meeting>the International Symposium on Shared Memory Multiprocessing<address><addrLine>Tokyo, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="242" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A compositional rule for hardware design refinement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th International Conference on Computer-Aided Verification</title>
		<meeting>the 9th International Conference on Computer-Aided Verification</meeting>
		<imprint>
			<date type="published" when="1997-06" />
			<biblScope unit="page" from="24" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Verification of an implementation of tomasulo&apos;s algorithm by compositional model checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification</title>
		<editor>A. J. Hu and M. Y. Vardi</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998" />
			<biblScope unit="volume">1427</biblScope>
			<biblScope unit="page" from="110" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Communicating and Mobile Systems: the π-Calculus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Verification of FLASH cache coherence protocol by aggregation of distributed transactions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighth Annual ACM Symposium on Parallel Algorithms and Architectures</title>
		<meeting>the Eighth Annual ACM Symposium on Parallel Algorithms and Architectures</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="288" to="296" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Verification techniques for cache coherence protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Pong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dubois</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="82" to="126" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Handbook of Process Algebra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ponse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">A</forename><surname>Smolka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Bergstra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
			<publisher>Elsevier Science Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Specifying and verifying a broadcast and a multicast snooping cache coherence protocol</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Sorin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Plakal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Condon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="556" to="578" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A class of compatible cache consistency protocols and their support by the IEEE futurebus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sweazey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th Annual International Symposium on Computer Architecture</title>
		<meeting>the 13th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1986" />
			<biblScope unit="page" from="414" to="423" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Expressing interesting properties of programs in propositional temporal logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Wolper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages</title>
		<meeting>the 13th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1986" />
			<biblScope unit="page" from="184" to="193" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Verifying a multiprocessor cache controller using random test generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">A</forename><surname>Gibson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Design &amp; Test</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="13" to="25" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
