<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:33+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Provably good global buffering by multiterminal multicommodity flow approximation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Feodor</forename><forename type="middle">F</forename><surname>Dragan</surname></persName>
							<email>dragan@mcs.kent.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">UCSD CSE and ECE Departments</orgName>
								<address>
									<addrLine>La Jolla</addrLine>
									<postCode>92093-0114</postCode>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Ion M˘ andoiu †</roleName><forename type="first">Sudhakar</forename><surname>Muddu</surname></persName>
							<email>muddu@sanera.net</email>
							<affiliation key="aff2">
								<orgName type="department">College of Computing</orgName>
								<orgName type="institution">Georgia Institute of Technology</orgName>
								<address>
									<postCode>30332-0280</postCode>
									<settlement>Atlanta</settlement>
									<region>GA</region>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">Sanera Systems, Inc</orgName>
								<address>
									<settlement>Santa Clara</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Zelikovsky</surname></persName>
							<affiliation key="aff4">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Georgia State University</orgName>
								<address>
									<postCode>30303</postCode>
									<settlement>Atlanta</settlement>
									<region>GA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">Kent State University</orgName>
								<address>
									<postCode>44242</postCode>
									<settlement>Kent</settlement>
									<region>OH</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Provably good global buffering by multiterminal multicommodity flow approximation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>To implement high-performance global interconnect without impacting the placement and performance of existing blocks, the use of buffer blocks is becoming increasingly popular in structured-custom and block-based ASIC methodologies. Recent works by Cong, Kong and Pan [5] and Tang and Wong [18] give algorithms to solve the buffer block planning problem. In this paper, we address the problem of how to perform buffering of global multiterminal nets given an existing buffer block plan. We give a provably good algorithm based on a recent approach of Garg and Könemann [8] and Fleischer [7] (see also Albrecht [1] and Dragan et al. [6]). Our method routes connections using available buffer blocks, such that required upper and lower bounds on buffer intervals-as well as wirelength upper bounds per connection-are satisfied. In addition, our algorithm allows more than one buffer to be inserted into any given connection and observes buffer parity constraints. Most importantly , and unlike previous works on the problem [5, 18, 6], we take into account multiterminal nets. Our algorithm outperforms existing algorithms for the problem [5, 6], which are based on 2-pin decompositions of the nets. The algorithm has been validated on top-level layouts extracted from a recent high-end microprocessor design.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Process scaling leads to an increasingly dominant effect of interconnect on high-end chip performance. Each top-level global net must undergo repeater insertion (among other optimizations; see <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b13">14]</ref>) to maintain signal integrity and reasonable signal delay. <ref type="bibr" target="#b0">1</ref> Estimates of the need for repeater insertion range up to O10 6 repeaters for top-level on-chip interconnect when we reach the 50nm technology node. These repeaters are large (anywhere from 40 to 200 minimum inverter size), affect global routing congestion, can entail non-standard cell height and special power routing requirements, and can act as noise sources. In a block-or reuse-based methodology, designers seek to isolate repeaters for global interconnect from individual block implementations.</p><p>For these reasons, a buffer block methodology has become increasingly popular in structured-custom and block-based ASIC methodologies. Two recent works by Cong, Kong and Pan <ref type="bibr" target="#b4">[5]</ref> and Tang and Wong <ref type="bibr" target="#b17">[18]</ref> give algorithms to solve the buffer block planning problem. Their buffer block planning formulation is roughly stated as follows: Given a placement of circuit blocks, and a set of two-pin connections with feasible regions 2 for buffer insertion, plan the location of buffer blocks within the available free space so as to route a maximum number of connections. In another recent development, Dragan et al. <ref type="bibr" target="#b5">[6]</ref> give an algorithm for performing global buffered routing of two-pin nets under an existing buffer block plan.</p><p>In this paper, we address the problem of how to perform buffering of global multiterminal nets given an existing buffer block plan. (Hence, our work is compatible with and complements the methods in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b5">6]</ref>.) We give a provably good algorithm based on a recent approach of <ref type="bibr">Garg and Könemann [8]</ref> and Fleischer <ref type="bibr" target="#b6">[7]</ref>. Our method routes the nets using available buffer blocks, such that required upper and lower bounds on repeater intervals-as well as length upper bounds per connection-are satisfied. <ref type="bibr" target="#b2">3</ref> In addition, our algorithm observes repeater parity constraints, i.e., it will choose to use an inverter or a buffer (= co-located pair of inverters) according to source and destination signal parity. The authors of <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b5">6]</ref> assumed that global nets have been already decomposed into two-pin connections; unlike these works our model takes into account multiterminal nets.</p><p>Informally, our problem is defined as follows. Given:</p><p>񮽙 a planar region with rectangular obstacles; 񮽙 a set of nets in the region, each net has: -a single source and multiple sinks; -a non-negative importance (criticality) coefficient; 񮽙 each sink has:</p><p>-a parity requirement, which specifies the required parity of the number of buffers (inverters) on the path connecting it to the source; -a timing-driven requirement, which specifies the maximum number of buffers on the path to the source; 񮽙 a set of buffer blocks, each with given capacity; and 񮽙 an interval 񮽙L;U 񮽙 specifying lower and upper bounds on the distance between buffers.</p><p>Global Routing via Buffer Blocks (GRBB) Problem: route a subset of the given nets, with maximum total importance, such that: 񮽙 the distance between the source of a route and its first repeater, between any two consecutive repeaters, respectively between the last repeater on a route and the route's sink, are all between L and U; 񮽙 the number of trees passing through any given buffer block does not exceed the block's capacity; 񮽙 the number of buffers on each source-sink path does not exceed the given upper bound and has the required parity; to meet the parity constraint two buffers of the same block can be used.</p><p>If possible, the optimum solution to the GRBB problem simultaneously routes all the nets. Otherwise, it maximizes the sum of the importance coefficients over routed nets. The importance coefficients can be used to model various practical objectives. For example, importance coefficients of 1 for each net correspond to maximizing the number of routed nets, and importance coefficients equal the number of sinks in the net correspond to maximizing the number of connected sinks.</p><p>The GRBB problem can be formulated as a generalized version of (vertex-capacitated) integer multiterminal multicommodity flow (MTMCF). The main contribution of this paper is an MTMCF based algorithm for the GRBB problem. Prior to our work, multicommodity flow (MCF) based heuristics have been applied to VLSI global routing <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b0">1]</ref>. As noted in <ref type="bibr" target="#b11">[12]</ref>, the applicability of these algorithms has often been limited to problem instances of relatively small size by the prohibitive cost of solving exactly the fractional relaxation. Following <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b5">6]</ref>, we avoid this limitation by using an approximate MTMCF algorithm based on results in <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b6">7]</ref>. An important feature of our algorithm is that it allows for a smooth trade-off between running time and solution accuracy. Our experiments indicate that even MTMCF solutions with very low accuracy give good final solutions for the GRBB problem.</p><p>The most interesting feature of our algorithm is its ability to work with multiterminal nets. Previous work on the GRBB problem <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b5">6]</ref> has considered only the case of 2-pin nets. Experiments on top-level layouts extracted from a recent high-end microprocessor design validate our MTMCF algorithm, and indicate that it significantly outperforms existing algorithms for the problem <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>.</p><p>The rest of the paper is organized as follows. In Section 2, we reduce the Global Buffering Problem to a generalized version of integer multiterminal multicommodity flow. The fractional relaxation of this problem is a special case of packing LP, and can thus be approximated within any desired accuracy using the algorithm of <ref type="bibr">Garg and Könemann [8]</ref>. In Section 3 we present a faster approximation algorithm, obtained by extending the ideas of Fleischer <ref type="bibr" target="#b6">[7]</ref> to this special type of packing LPs. In Section 4 we describe the randomized rounding algorithm used to convert near-optimal fractional MTMCF solutions to near-optimal integral solutions. In Section 5 we describe several global buffering heuristics, some based on the MTMCF approach, and some based on less sophisticated greedy ideas. In Section 6 we give the results of an experimental comparison of these heuristics on test cases extracted from the top-level layout of a recent high-end microprocessor. Finally, we conclude in Section 7 with a list of open research directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. INTEGER PROGRAM FORMULATION OF GRBB</head><p>Given </p><formula xml:id="formula_0">T = S K k=1 T k . For each T 2 T k , k = 1; : : : ; K, define gT := g k , where g k is the importance of N k .</formula><p>The GRBB problem is then equivalent to the following integer linear program:</p><formula xml:id="formula_1">maximize ∑ T 2T gT f T subject to ∑ T 2T π T v f T cv 8v 2 V f T 2 f 0; 1g 8T 2 T .</formula><p>where f T = 1 if the tree T is used in the solution and f T = 0 otherwise, and π T v is the number of occurrences of v in T , i.e.,</p><formula xml:id="formula_2">π T v := 8 񮽙 :</formula><p>0; if v = 2 T 1; if v 2 T and loop vv is not in T 2; if v 2 T and loop vv is in T Our approach will be to solve the relaxation of the above integer program obtained by replacing the integrality constraint with f T 0 8T 2 T ; we will then use randomized rounding to obtain an integer solution. We will refer to this relaxation as the Multiterminal Multicommodity Flow Linear Program (MTMCF LP).</p><p>Although the MTMCF LP is solvable in polynomial time (using, e.g., the ellipsoid algorithm), exact algorithms are highly impractical. On the other hand, the MTMCF LP is a special case of packing LP, and can thus be efficiently approximated within any desired accuracy using the recent combinatorial algorithm of <ref type="bibr">Garg and Könemann [8]</ref>. In this paper we give a significantly faster approximation algorithm based on a speed-up idea due to Fleischer <ref type="bibr" target="#b6">[7]</ref>. Fleischer's idea, originally proposed for approximating the maximum edge-capacitated MCF, has been recently extended <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b5">6]</ref> to edge-capacitated multiterminal MCF and vertex-capacitated MCF, respectively. Here we take this approach further and show how to use it for efficient approximation of vertex-capacitated multiterminal multicommodity flow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. APPROXIMATION OF VERTEX-CAPACITATED MTMCF</head><p>Our MTMCF approximation algorithm simultaneously solves the MTMCF LP and its dual LP; the dual solution is used in proving the approximation guarantee of the algorithm. The dual of the MTMCF LP is:</p><p>minimize ∑ v2V wvcv subject to</p><formula xml:id="formula_3">1 gT ∑ v2T wv 1 8T 2 T wv 0 8v 2 V .</formula><p>The dual LP can be viewed as an assignment of non-negative weights, w, to the vertices of G such that the weight of any tree T 2 T is at least 1; the objective is to minimize the sum ∑ v2V wvcv. Here, the weight, weightT , of the tree T is the sum of the weights of vertices forming this tree (if the tree uses a loop vv then vertex v contributes twice to this sum) divided by the importance gT of this tree. Denote Dw = ∑ v2V wvcv and let αw be the weight of a minimum weight tree from T (with respect to w). The dual problem is equivalent to finding a weight function w : V ! R + such that β = Dw αw is minimized. In the following we will assume that minfg k : k = 1; : : : ; Kg = 1-this can be easily achieved by scalingand will denote by Γ the maximum g k . Our algorithm for MTMCF approximation is given in <ref type="figure">Fig. 1</ref>.</p><p>In the algorithm, f k v denotes how many times vertex v is visited by feasible Steiner trees used to connect net N k , and f denotes the total number of feasible Steiner trees used by the algorithm. The algorithm associates a weight with each vertex, and in each iteration it uses a minimum weight tree T 2 T k to connect the pins of some net N k .</p><p>When tree T is selected, the algorithm multiplies the weight of every vertex in T by 1 + ε cv for a fixed ε (if this tree uses a loop vv, then the weight of v is multiplied by 1 + 2ε cv ). Initially, every vertex v has weight δ for some constant δ. Thus, the more often is a vertex used, the larger its weight, which implies that often used vertices are less likely to be part of future minimum weight trees. According to Garg and Könemann's approximation algorithm <ref type="bibr" target="#b7">[8]</ref>, each iteration must use a lightest (with respect to current weight function w) tree from T if the weight of this tree is less than 1=Γ. The algorithm then stops after t iterations where t is the smallest number such that αw, computed with respect to vertex weights w of this iteration, is at least 1=Γ. We extend an idea due to Fleischer <ref type="bibr" target="#b6">[7]</ref> to our vertex-capacitated MTMCF problem to reduce the number of minimum weight tree computations during the algorithm. Instead of finding the lightest tree in T in each iteration (which essentially involves K shortest-path computations) we settle for some tree within a factor of (1 + 2ε) of the lightest, and show that this still leads to a similar approximation guarantee.</p><p>Let w i,1 be the weight function at the beginning of the ith iteration. We have w 0 v = δ for each v 2 V . For brevity denote αw i and Dw i by αi and Di, respectively. Following Fleischer, we cycle through the nets, sticking with a net until the lightest feasible Steiner tree for that net is above a 1 + 2ε factor times a lower bound estimate of the overall lightest tree. Let ¯ αi be a lower bound on αi. minimum weight feasible Steiner tree computations are used to update α over the course of the algorithm. <ref type="figure">Fig. 1</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1 The algorithm in</head><note type="other">is a 1 + ω-approximation algorithm for the MTMCF LP by choosing δ = 1 + 2ε1 + 2εLΓ , 1 2ε and ε</note></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof.</head><p>Our proof is an adaptation of the proof of Garg and Könemann <ref type="bibr" target="#b7">[8]</ref> (see also Fleischer <ref type="bibr" target="#b6">[7]</ref> </p><formula xml:id="formula_4">cv M 2 = δ1 + 2ε cv cv M 2cv δ1 + 2ε M 2cv :</formula><p>The last time we increased the weight of v, it was on a feasible Steiner tree of weight less than 1=Γ. Hence, the weight of v was less than 1. Since in each iteration we increase the vertex weight by factor of at most 1 + 2ε, the final weight of v is at most 1 + 2ε. Consequently,</p><formula xml:id="formula_5">δ1 + 2ε M 2cv w t v 1 + 2ε; i.e., M cv2log 1+2ε 1 + 2ε δ :</formula><p>Now we show that the ratio of the values of the dual and the primal solutions,</p><formula xml:id="formula_6">γ = β f 2log 1+2ε 1+2ε</formula><p>δ , is at most 1 + ω.</p><p>For each iteration i 1 we have For the last inequality the fact 1 + x e x for x 0 is used.</p><p>Since we stop at iteration t with αt 1=Γ, and t = f , we get Since 1 + 2ε1 , 2ε ,2 is at most 1 + 8ε, for ε 񮽙 : 07, and 1 + 8εΓ should be no more than our approximation ratio 1 + ω, we are done.</p><p>In the algorithm in <ref type="figure">Fig. 1</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. ROUNDING THE FRACTIONAL MTMCF</head><p>In the previous section we presented an algorithm for approximating the optimum multiterminal multicommodity flow (MTMCF) within any desired accuracy. The optimum MTMCF gives an upperbound on the maximum number of routable nets (connections). In this section we show how to use the approximate MTMCF to route an almost optimal number of nets (resp. connections). Our construction is based on the randomized rounding technique of Raghavan and Thomson <ref type="bibr" target="#b15">[16]</ref>, in particular, on the random-walk based algorithm for rounding multicommodity flow <ref type="bibr" target="#b14">[15]</ref> (see also <ref type="bibr" target="#b11">[12]</ref>).</p><p>The MCF rounding algorithm in <ref type="bibr" target="#b14">[15]</ref> chooses a set of source-sink pairs by including each pair s; t with a probability equal to the flow from s to t. Then, for each chosen pair, s; t, the algorithm performs a random-walk from s to t, based on probabilities given by edge-flows. In our MTMCF rounding algorithm (see <ref type="figure">Figure 2)</ref>, a net N k = s k ;t 1 k ; : : : ; t q k k is also routed with probability equal to the net's total flow, f k = ∑ T 2T k f T . Since we need to construct a tree connecting all sinks t i k to the source s k , we route the net by performing backward random walks from each sink until reaching either s k or a vertex on a path already included in the tree. Thus, if the net has only one sink, our rounding algorithm becomes identical to the algorithm in <ref type="bibr" target="#b14">[15]</ref>, except for the direction of the random walk.</p><p>Ensuring that no vertex capacities are exceeded can be accomplished in two ways. Following <ref type="bibr" target="#b11">[12]</ref>, one way is to solve the MTMCF LP with capacities scaled down by a small factor that guarantees that the rounded solution will meet the original capacities with very high probability. A simpler approach, the so-called greedy-deletion algorithm <ref type="bibr" target="#b5">[6]</ref>, is to repeatedly drop routed nets that visit over-used vertices until feasibility is achieved. We implement a modification of the second approach: instead of dropping an entire tree, we drop only the sinks which use paths through over-used vertices.</p><p>Input: Graph G with K nets N 1 ; : : : ; N K , vertex capacities cv</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Output: Set of trees T k 2 T k</head><p>For each k = 1; : : : ; K, do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>T k f s k g</head><p>For each sink t i k in N k do Using a backward BFS search, find a shortest path P from t i k to T k in G using only vertices v with cv 񮽙 0; if no such path exists let P = / 0</p><formula xml:id="formula_7">T k T k 񮽙P For each vertex v in P, cv cv ,1</formula><p>End for End for </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Greedy Routing Algorithms</head><p>We have implemented 3 greedy algorithms for the GRBB problem. The first algorithm <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref> starts by decomposing each multiterminal net into 2-terminal nets. Then, the algorithm attempts to route the 2-terminal nets one by one, using for routing a shortest available path from the net's source to its sink, if such a path exists. We will refer to this algorithm as the forward 2-terminal greedy (F-2TG) algorithm.</p><p>The second greedy algorithm, referred to as the multiterminal Greedy (MTG) algorithm, routes multiterminal nets without splitting <ref type="figure" target="#fig_0">(Fig. 3)</ref>. In this algorithm we also attempt to route the sinks of a net one by one. For a given net, the algorithm starts with a tree containing only the net's source, then iteratively adds shortest paths from each sink to the already constructed tree.</p><p>The third algorithm, the backward 2-terminal greedy (B-2TG), works as F-2TG, except for the fact that shortest paths are computed backward, from sinks toward sources and not from sources toward sinks. Notice that B-2TG becomes identical to MTG when applied to 2-terminal nets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Flow Rounding Algorithms</head><p>We have implemented two flow rounding algorithms. The first is the MCF rounding algorithm of Dragan et al. <ref type="bibr" target="#b5">[6]</ref> , which we will refer to as 2TMCF. It starts by decomposing each multiterminal net into 2-terminal nets, and then casts the GRBB problem as an integer MCF problem.</p><p>The second algorithm is based on MTMCF rounding <ref type="figure" target="#fig_1">(Fig. 4)</ref>. Our current implementation decomposes larger nets into 3-terminal nets before applying the MTMCF routing algorithm, we will refer to this implementation as 3TMCF. For 3-terminal nets we can find the optimum directed routed Steiner tree efficiently, and we do not need to resort to the approximations suggested at the end of Section III.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. IMPLEMENTATION EXPERIENCE</head><p>All experiments were conducted on a SGI Origin 2000 with 16 195MHz MIPS R10000 processors-only one of which is actually used by the sequential implementations included in our comparisonand 4 G-Bytes of internal memory, running under IRIX 6.4 IP27. Timing was performed using low-level Unix interval timers, under similar load conditions for all experiments. All algorithms were coded in C and compiled using gcc version egcs-2.91.66 with -O4 optimization.</p><p>Input: Graph G with K nets N 1 ; : : : ; N K , vertex capacities cv</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Output: Set of trees T k 2 T k</head><p>Find an approximate MTMCF using the algorithm in <ref type="figure">Fig. 1</ref> Round the approximate MTMCF using the algorithm in <ref type="figure">Fig. 2</ref> Use greedy deletion to find a feasible integer solution Use the MTG algorithm in <ref type="figure" target="#fig_0">Fig. 3</ref> on the unrouted nets to find a maximal routing The three test cases used in our experiments were extracted from the next-generation microprocessor chip at SGI. We used an optimized floorplan of the circuit blocks and also optimized the location of the source/sink pin locations based on coarse timing budgets. We used U = 4000µm, and varied L between 500µm and 2000µm. Path-length upper-bounds were computed with the formula l k = dist(s k ; t k )/1000. In all test cases considered the number of nets was large (close to 5000), and the number of buffer blocks small (50), with relatively large capacity (400 buffers per block); such values are typical for this application <ref type="bibr" target="#b5">[6]</ref>. <ref type="table" target="#tab_8">Table I</ref> gives the number of routed sinks and the running time on the three instances by each of the algorithms included in our comparison. <ref type="figure">Figure VII</ref> plots the solution quality versus the CPU time (in seconds, excluding I/O and memory allocation) for each algorithm.</p><p>The first surprising thing to notice is that B-2TG gives noticeably better results than F-2TG, despite the fact that the two algorithms are nearly identical (they both add paths of the same length until some of the vertices use up the full capacity). <ref type="bibr" target="#b3">4</ref> Perhaps not so surprising is the fact that the multiterminal greedy algorithm is better than both F-2TG and B-2TG. Notice that the running time of all three greedy algorithms is virtually the same, so MTG is the clear choice among them.</p><p>Our experiments clearly demonstrate the high quality of the solutions obtained by flow rounding methods. Significant improvement over the best of the greedy methods is possible even with a very small increase in running time, proof that even very coarse MCF/MTMCF approximations give helpful hints to the randomized rounding procedure. Since randomized rounding is very fast, faster in fact than any of the greedy algorithms, the MCF/MTMCF algorithms can be further improved by running randomized rounding with the same fractional flow a large number of times and taking the best of the rounded solutions; our current implementation does not exploit this idea.</p><p>Finally, our experiments show that even a limited use of multiterminal nets (decomposition into nets of size 3) gives improvements over the already very high-quality MCF algorithm of Dragan et al. <ref type="bibr" target="#b5">[6]</ref>. In fact, the 3TMCF algorithm outperforms the MCF algorithm in <ref type="bibr" target="#b5">[6]</ref> even when the same time budget is given to both algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSIONS AND FUTURE DIRECTIONS</head><p>In this paper, we addressed the problem of how to perform buffering of global multiterminal nets given an existing buffer block plan. We gave a provably good algorithm based on a novel approach to MTMCF approximation inspired by recent results of <ref type="bibr">Garg and Könemann [8]</ref> and Fleischer <ref type="bibr" target="#b6">[7]</ref> on edge-capacitated MCF. Our MTMCF algorithm outperforms existing algorithms for the problem  <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>, and has been validated on top-level layouts extracted from a recent high-end microprocessor design.</p><p>Ongoing work is aimed at increasing the space of methodologies to which our new techniques apply. As presented here, our work is clearly targeted to very early global wireplanning activity. In other words, the application domain is pre-synthesis chip planning: prescribed repeater intervals are driven only by coarse estimates of Miller coupling factors, repeater sizing, and source impedance or sink capacitance. The presented formulation also does not address timing criticalities or budgets except via net weighting (prioritization); this is fortunately fairly common for initial wireplanning that breaks the "chicken-egg" problem of budgeting between-block and within-block paths in pre-synthesis RTL planning with aggressive global wire optimization. <ref type="bibr" target="#b4">5</ref> We are presently extending our approach in the following ways. (1) Handling routing congestion, e.g., by introducing capacitated "virtual" nodes in the flow graph. (2) Handling timing criticality and budgets is another goal; our ideas include better use of net ordering and weighting, and post-processing of the solution to eliminate unneeded repeaters. (It is also possible to attempt to introduce layer awareness, source and sink parasitic awareness, etc., but this risks losing the flavor of early feasibility checking with available buffer block plans.) Here, maintaining provable solution quality is a key issue. (3) Finally, since accurate treatment of multiterminal nets is the key motivation for our present work, we are implementing better heuristics for net decomposition into 2-and/or 3-terminal groups; we are also implementing optimal graph Steiner solutions for up to 4-terminal nets, to assess the associated quality-runtime tradeoffs. <ref type="bibr" target="#b4">5</ref> In other words, maximal repeater insertion allows maximum timing budgets for within-block timing paths, and this permits blocks to go through synthesis, place and route with more aggressive area targets. A strategy of uniform buffering of as many global nets as possible also helps control signal integrity and delay uncertainty problems. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. The multiterminal greedy (MTG) routing algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. The MTMCF routing algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Percent of sinks connected vs. time on test case i1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>K nets N k = s k ;t 1 k ; : : : ; t q k k , k = 1; : : : ; K, and n buffer blocks fr 1 ; : : : ; r n g, let S = fs 1 ; : : : ; s K g, T = ft 1g, and R = fr 1 ; : : : ; r n g. Let also a i k 2 f even, oddg, respectively l i k , be the parity requirement, respectively the prescribed upper bound, on the number of buffers on the path between source s k and sink t i k . Let p xy be a rectilinear path connecting points x and y of a planar region and avoiding all rectangular obstacles given in the region. De- note by dx; y the length of a shortest such path. Let G = V; E be a graph with vertex set V = S 񮽙T 񮽙R. The edge set E contains all edges of type vv, v 2 R (such an edge is called a loop). Two different vertices x and y are adjacent (i.e., xy 2 E) if and only if L dx; y U. A path p = s k ; v 1 ; v 2 ; : : : ; v l ; t i k in G between source s k and sink t i k (k = 1; : : : ; K, i = 1; : : : ; q k ) is a restricted s k ; t i k -path if 񮽙 v i 2 R for each i = 1; : : : ; l, 񮽙 the parity of l is a i k , 񮽙 l l i k , 񮽙 there can be some pairs of different indices i; j 2 f 1; : : : ; lg such that v i = v j ; in this case we must have ji, jj = 1. A feasible Steiner tree for net N k is a Steiner tree T k in G connecting terminals s k ; t 1 k ; : : : ; t q k k such that, for every i = 1; : : : ; q k , the path of T k connecting s k to t i k is a restricted s k ; t i k -path as defined above. Define capacities on all vertices of G by cv := 񮽙 1; if v 2 S 񮽙T capacity of buffer block v; if v 2 R Let T k be the set of all feasible Steiner trees for net N k , and let</head><label></label><figDesc></figDesc><table>1 ; : : : ; t 

q 1 

1 ; : : : ; t 1 
K ; : : : ; t 

q K 

K </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Input : Graph G with K nets N 1 ; : : : ; N K , vertex capacities cv Output: MTMCF value, f , and flows f k v 2 񮽙0; 1񮽙, k = 1; : : : ; K, v 2 V G satisfying capacity constraints Set f = 0 Set wv = δ for all v 2 V Set f k v = 0 for all v 2 V and k = 1; : : : ; K For i = 1 to log 1+2ε 1+2ε δ do For k = 1 to K do Find a minimum weight tree T in T k . While weightT 񮽙 minf1=Γ; δ=Γ1 + 2ε i g do f = f + 1; For all v 2 T , if T uses a loop vv then set f k v = f k v + 2 and wv = wv1 + 2ε cv ; else set f k v = f k v + 1 and wv = wv1 + ε cv Find a minimum weight tree T in T k End while2 V and k = 1; : : : ; K Fig. 1. The fractional tree-routing algorithm</head><label>Input</label><figDesc></figDesc><table>End for 

End for 

Output 

f 
2 log 1+2ε 

1+2ε 
δ 

, and 

f k v 
2 log 1+2ε 

1+2ε 
δ 

for each v </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>2 T with weightT minf1=Γ; 1 + 2ε ¯g i2N .one. As long as the lightest feasible Steiner tree T for net N k has weight less than the minimum of 1 + 2ε times the current value of ¯ α and 1=Γ, this lightest tree T is used to connect the pins of the net N k . When min T 2T k weightT 1 + 2ε ¯ α, net N k+1 is consid- ered. After all K nets are considered,</head><label></label><figDesc></figDesc><table>To start, we set ¯ 
α0 = δ=Γ. As long as there is 

some T αig, we use tree 
T . When this no longer holds, we know that the weight of the lightest 
tree is at least 1 + 2ε ¯ 
αi, and so we set ¯ 
αi + 1 = 1 + 2ε ¯ 
αi. 
Thus, throughout the course of the algorithm, ¯ 
α takes on values in 

the set fδ=Γ1 + 2ε i Since α0 δ=Γ and αt , 1 񮽙 1=Γ, 

αt 񮽙 1 + 2ε=Γ. Thus, when we stop, ¯ 
αt is between 1=Γ and 
1 + 2ε=Γ. Each increase of ¯ 
α is by a 1 + 2ε factor, hence the 

number of increases of ¯ 
α is log 1+2ε 

1+2ε 

δ (and the final value of i is 

blog 1+2ε 1+2ε 
δ c). 

Between updates to ¯ 
α, the algorithm proceeds by considering each 
net one by ¯ 
α is updated. A total of at most 

K log 1+2ε 

1+2ε 
δ 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>񮽙 minf:07; 1+ω,Γ 8Γ g, where L is the number of vertices in the longest feasible Steiner tree of G connecting any net.</head><label></label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>). First we show that the val- ues f k v 2log 1+2ε 1+2ε δ (v 2 V , k = 1; : : : ; K), computed by the algorithm, arev cv and hence we do not ex- ceed the capacity of any vertex v of G. Consider an arbitrary vertex v of G and let M = ∑ K k=1 f k v denotes how many times the vertex v was used by all feasible Steiner trees found by algorithm. For every two times that the vertex v was used by feasible Steiner trees, the weight of v increased by a factor of at least 1 + 2ε cv . Since w 0 v = δ, it follows that w t v δ1 + 2ε cv M 2 . Simplifying this expression, we get w t v δ1 + 2ε</head><label></label><figDesc></figDesc><table>feasible, i.e., 

1 
2log 1+2ε 

1+2ε 
δ 

∑ K 

k=1 f k </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>Di = ∑ v2V w i vcv = ∑ v2V w i,1 vcv + ε ∑ v2T w i,1 v Di ,1 + ε1 + 2εΓαi ,1: Note that, if T used a loop vv, then v contributes to the sum ∑ v2T w i,1 v twice (since w i v = w i,1 v1 + 2ε cv ). Then, Di ,D0 ε1 + 2εΓ i ∑ j=1 α j ,1: Consider the weight function w i ,w 0 . We have αw i ,w 0 αw i ,δL, where L is the number of vertices in the longest feasible Steiner tree of G connecting any net. Consequently, if αw i ,δL 񮽙 0, then β Dw i ,w 0 αw i ,w 0 Di ,D0 αi ,δL ε1 + 2εΓ ∑ i j=1 α j ,1 αi ,δL : Thus, in any case (for the case αw i ,δL 0, it is trivial) we have αi δL + ε1 + 2εΓ β i ∑ j=1 α j ,1δLe iε1+2εΓ β :</head><label></label><figDesc></figDesc><table>1 + 

ε1 + 2εΓ 
β 


i,1 δL + 

ε1 + 2εΓ 
β 

α0 

1 + 

ε1 + 2εΓ 
β 


i,1 δL + 

ε1 + 2εΓ 
β 
δL = 

δL1 + 
ε1 + 2εΓ 
β 


i 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>1=Γ αt δLe tε1+2εΓ β</head><label></label><figDesc></figDesc><table>= δLe 

f ε1+2εΓ 
β 
: 

Hence, 
β 

f 

ε1 + 2εΓ 

lnδLΓ ,1 : 

Now, for the ratio γ we obtain 

γ = 
β 

f 
2log 1+2ε 
1 + 2ε 
δ 

2ε1 + 2εΓ log 1+2ε 

1+2ε 
δ 

lnδLΓ ,1 

= 

2ε1 + 2εΓ ln 1+2ε 

δ 

ln1 + 2ε lnδLΓ ,1 : 

Since we have chosen δ = 1 + 2ε1 + 2εLΓ 

,1 

2ε , we get 

ln 1+2ε 

δ 

lnδLΓ ,1 = 1 

1,2ε and hence, 

γ 2ε1 + 2εΓ 
1 ,2εln1+2ε 1 + 2ε1 ,2ε ,2 Γ: 
Here we used that ln1 + x x ,x 2 =2 (by Taylor series expansion of 

ln1 + x). 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>k (k = 1; : : : ; K) be a subgraph of the graph G induced by vertices fs k ; t 1 k ; : : : ; t q k k g g R (recall that each vertex v 2 R has a loop vv 2 E). Let also each vertex v of G k have a non-negative weight wv. Find a minimum weight tree T k in G k connecting s k with t 1 k ; : : : ; t q k k such that, for each i = 1; : : : ; q k , the path of T k between s k and t i k passes through even (odd, depending on a i k ) number of vertices, and that number of vertices does not exceed l i k . This path may contain a loop, in this case the weight of the vertex at which the loop is attached will contribute twice to the weight of the tree T k . Let L k = maxfl 1 k ; : : : ; l q k k g. We reduce this problem to the usual shortest directed rooted Steiner tree problem on an edge- weighted directed acyclic graph (dag) D k with V D k = fs k g g fr i; j j 1 i n, 1 j L k g g f t 1 k ; : : : ; t q k k g and ED k = E 1 񮽙 E 2 񮽙 E 3 , where E 1 = fs k ; r i;1 j 1 i n, s k ; r i 2 EGg E 2 = fr i; j ; r i 0 ; j+1 j 1 i; i 0 n, 1 j 񮽙 L k , r i ; r i 0 2 EGg E 3 = fr i; j ; t h k j 1 i n, 1 h q k , 1 j l h k , j a h k (mod 2), r i ; t h k 2 EGg If the cost of each arc x; y in D k is given by wx, it is easy to see that finding the minimum weight tree in T k reduces to finding a min- imum cost directed rooted Steiner tree (DRST) in D k . Generally, the directed rooted Steiner tree problem asks, for a given directed edge- weighted graph H = X;U, a specified root r 2 X, and a set of ter- minals Y 񮽙 X, to find the minimum cost arborescence rooted at r and spanning all the vertices in Y (in other words r should have a directed path to every vertex in Y ). Unfortunately, the fact that D k is acyclic does not help. There is a simple reduction for this problem from arbi- trary directed graphs to acyclic graphs. As far as we know, the best re- sult for the DRST problem is due to Charikar et al. [3] which says that an Olog 2 q k -approximate solution can be found in quasi-polynomial time On 3log q k . Since this is very inefficient, we need to find some Input: Multiterminal flows f k e 2 񮽙0; 1񮽙, k = 1; : : : ; K, e 2 EG Output: Set of trees T k 2 T k For each k = 1; : : : ; K, with probability f k , do T k f s k g For each sink t i k in N k do P / 0; v t i k While v = 2 T k do Pick arc u; v with probability f k u; v= f k v P P 񮽙 f u; vg; v u End while T k T k 񮽙Plengths) in the graph induced by fs k ; t 1 k ; : : : ; t q k k ; p 1 ; : : : ; p s g, where p 1 ; : : : ; p s are the.</head><label></label><figDesc>we need to solve the following problem. Let GSteiner points of the original DRST. To find a minimum spanning directed tree in directed acyclic graphs, one can use a very simple procedure: for each vertex choose a shortest incom- ing arc, then, after running this procedure, recursively delete all leaves that are not sinks of the net N k</figDesc><table>End for 

End for 

Fig. 2. Randomized MTMCF rounding algorithm 

other ways to compute such trees. One approach, used by Albrecht [1] 
for edge-capacitated MTMCF approximation, is to compute (exactly 
or approximately) a DRST once, then use in each of the following 
iterations minimum directed spanning trees (with respect to the up-

dated edge </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><head>TABLE I PERCENT OF SINKS CONNECTED (BOLDFACE) AND CPU TIME ON 3 INDUSTRIAL TEST CASES</head><label>I</label><figDesc></figDesc><table>Instance 
GREEDY 
2TMCF 
3TMCF 
ID Nets Sinks N/S F-2TG B-2TG MTG ε = 0:64 ε = 0:32 ε = 0:16 ε = 0:08 ε = 0:04 ε = 0:02 ε = 0:64 ε = 0:32 ε = 0:16 ε = 0:08 ε = 0:04 ε = 0:02 

i1 4764 6038 2.27 
89.5 
0.58 

90.6 
0.54 

93.5 
0.53 

94.8 
2.84 

95.8 
12.13 

96.5 
39.50 

96.6 
139.83 

96.8 
600.89 

96.8 
2321.67 

95.7 
16.57 

96.8 
53.62 

97.3 
203.03 

97.5 
817.59 

97.6 
3166.03 

97.6 
12736.22 

i2 4925 6296 2.28 
89.9 
0.84 

91.6 
0.58 

93.6 
0.55 

96.2 
4.35 

97.1 
11.34 

97.4 
40.55 

97.5 
156.89 

97.6 
690.31 

97.6 
2604.34 

97.0 
19.50 

98.0 
64.13 

98.4 
242.17 

98.5 
942.34 

98.6 
3721.95 

98.4 
14854.06 

i3 4938 6321 2.28 
89.8 
0.65 

91.5 
0.59 

93.3 
0.54 

96.2 
3.37 

96.9 
11.08 

97.3 
40.84 

97.3 
163.32 

97.5 
730.95 

97.5 
2638.04 

96.8 
18.99 

97.8 
66.12 

98.3 
246.29 

98.4 
956.83 

98.4 
3813.42 

98.3 
15088.50 

</table></figure>

			<note place="foot" n="3"> For example, global repeater rules for a high-end microprocessor design in 0.25µm CMOS [10] require repeater intervals of at most 4500µm. The number of buffers needed for a given connection depends strongly on the length of the connection; as noted in [10], the repeater interval is not only required for delay reduction, but also for crosstalk noise immunity and edge slewtime control.</note>

			<note place="foot" n="4"> We presume that the advantage for computing backward shortest paths, as opposed to forward shortest paths, is that the former gives a set of paths that are better spread out in the vicinity of the source of a large net. If the sinks of such a net are grouped in a small number of clusters, which is typically the case in real designs, the forward greedy algorithm is likely to use a small number of neighbors of the source for all these paths, thus leading to the faster exhaustion of the available capacity in these vertices.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Provably good global routing by a new approximation algorithm for multicommodity flow</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Albrecht</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ISPD</title>
		<meeting>ISPD</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A global router using an efficient approximate multicommodity multiterminal flow algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">C</forename><surname>Carden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-K</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="316" to="321" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Approximation algorithms for directed Steiner problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Charikar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Chekuri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Goel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Cheung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithms</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="73" to="91" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Performance optimization of VLSI interconnect layout</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-K</forename><surname>Koh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">H</forename><surname>Madden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Integration</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1" to="94" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Buffer block planning for interconnectdriven floorplanning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">Z</forename><surname>Pan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCAD</title>
		<meeting>ICCAD</meeting>
		<imprint>
			<date type="published" when="1999-11" />
			<biblScope unit="page" from="358" to="363" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Provably good global buffering using an available buffer block plan</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">F</forename><surname>Dragan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muddu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Zelikovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCAD&apos;</title>
		<meeting>ICCAD&apos;</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Approximating fractional multicommodity flow independent of the number of commodities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">K</forename><surname>Fleischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 40th Annual Symposium on Foundations of Computer Science</title>
		<meeting>40th Annual Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1999-10" />
			<biblScope unit="page" from="24" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Faster and simpler algorithms for multicommodity flow and other fractional packing problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Könemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 39th Annual Symposium on Foundations of Computer Science</title>
		<meeting>39th Annual Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1998-11" />
			<biblScope unit="page" from="300" to="309" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An efficient timingdriven global routing algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X.-L</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-K</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">S</forename><surname>Kuh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DAC</title>
		<meeting>DAC</meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="596" to="600" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Interconnect tuning strategies for high-performance ICs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">B</forename><surname>Kahng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muddu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Sarto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sharma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DATE</title>
		<meeting>DATE</meeting>
		<imprint>
			<date type="published" when="1998-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Optimal wire sizing and buffer insertion for low power and a generalized delay model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lillis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">K</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">T Y</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCAD</title>
		<meeting>ICCAD</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="138" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Randomized approximation algorithms in combinatorial optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Raghavan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Approximation algorithms for NP-hard problems</title>
		<editor>D. Hochbaum</editor>
		<meeting><address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<publisher>PWS Publishing</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="144" to="191" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Experimental results for a linear program global router</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">P</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Thomson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="229" to="242" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Buffered Steiner tree construction with wire sizing for interconnect layout optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICCAD</title>
		<meeting>ICCAD</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="44" to="49" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Provably good routing in graphs: regular arrays</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Thomson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th ACM Symp. on Theory of Computing</title>
		<meeting>7th ACM Symp. on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1985" />
			<biblScope unit="page" from="79" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Randomized rounding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Thomson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Combinatorica</title>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="365" to="374" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A global router based on a multicommodity flow model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shragowitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Keel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Integration</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="16" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Planning buffer locations by network flows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">F</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ISPD</title>
		<meeting>ISPD</meeting>
		<imprint>
			<date type="published" when="2000-04" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
