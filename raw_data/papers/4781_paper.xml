<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T17:01+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Hash, Don&apos;t Cache: Fast Packet Forwarding for Enterprise Edge Routers</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Minlan</forename><surname>Yu</surname></persName>
							<email>minlanyu@cs.princeton.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Princeton University</orgName>
								<orgName type="institution" key="instit2">Princeton University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jennifer</forename><surname>Rexford</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Princeton University</orgName>
								<orgName type="institution" key="instit2">Princeton University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Hash, Don&apos;t Cache: Fast Packet Forwarding for Enterprise Edge Routers</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C26 [Internetworking]: Routers General Terms Algorithms</term>
					<term>Design</term>
					<term>Performance Keywords Packet forwarding</term>
					<term>Enterprise edge routers</term>
					<term>Bloom filter</term>
				</keywords>
			</textClass>
			<abstract>
				<p>As forwarding tables and link speeds continue to grow, fast packet forwarding becomes increasingly challenging for enterprise edge routers. Simply building routers with ever larger amounts of ever faster memory is not appealing, since high-speed memory is both expensive and power hungry. Instead , we believe future enterprise routers should leverage a hierarchical memory architecture consisting of a small, fast memory and a large, slow memory. However, the conventional approach of caching popular forwarding-table entries in the fast memory does not perform well in practice, especially under worst-case workloads with a wide range of destination IP addresses. Instead, the small memory could be used to store one Bloom filter of the address blocks associated with each outgoing link. In this paper, we present techniques to make the use of Bloom filters practical for enterprise edge routers, including optimizing the sizes of Bloom filters with limited fast memory, handling routing changes and dynamically tuning Bloom filter sizes using counting Bloom filters in slow memory, and handling the small number of false positives. Our evaluation shows that our scheme works well with less than 1 MB of fast memory.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Fast packet forwarding is a challenge today due to the significant growth of the forwarding table and the increasing Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. link speeds. To keep up with link speed, the large forwarding table must be stored in larger and faster memory. Enterprises (especially small or mid-size enterprises) are more cost conscious than Internet service providers, making them reluctant to use expensive, power-hungry fast memory such as TCAM (Ternary Content Addressable Memory). Therefore, our design goal is to reduce memory cost and power consumption of packet forwarding by leveraging a small fast memory.</p><p>Enterprise edge routers introduce unique opportunities to optimize packet forwarding compared with core routers. First, enterprise edge routers usually have only a few outgoing links. We leverage this fact and propose a solution that maintains a small data structure for each next hop. Second, multi-homed enterprises can reach most destination prefixes through multiple upstream providers, allowing them to occasionally direct packets to a less-preferred outgoing link.</p><p>To provide fast packet forwarding using low-cost memory, we assume a hierarchical memory structure consisting of a small, fast memory and a large, slow memory. The fast memory could be embedded SRAM in the line card of hardware routers, or the processor cache in a software router. For multi-core platforms, the fast memory could be a group of caches associated with different cores, or the shared cache among cores. Fast memory is expensive, so we keep its size small, usually less than 1 MB. Slow memory is cheap and can be large enough (e.g., 10-100 MB) to store a conventional forwarding-table data structure (such as a trie) in its entirety. This can be a DRAM placed in line card or near the control plane processor in hardware routers, or the main memory in a software router.</p><p>Using the small, fast memory as a cache is a seemingly natural way to leverage the hierarchical memory architecture. The basic idea is to store the most frequently used entries of the forwarding table in the fast memory. In fact, route caching was once commonly used in routers <ref type="bibr" target="#b7">[8]</ref>. However, during cache misses, the router experiences low throughput and high packet loss. In addition, when routing changes or link failures happen, many of the cached routes are simultaneously invalidated. Malicious traffic with a wide range of destination addresses may significantly increase the cache miss rate, making route caching highly inefficient. Due to its bad performance under worst-case workloads, route caching cannot keep up with the increasing link speeds and thus is not used in most routers today.</p><p>Instead, a Bloom filter, a hash-based compact data structure to store a set of elements, is a more suitable way to capitalize on the small, fast memory. In fact, several previous studies <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b12">13]</ref> have proposed ways to leverage Bloom filters in packet forwarding. Their basic idea is to use small fast memory to assist packet address lookup by reducing the number of accesses to the slow memory. For example, in <ref type="bibr" target="#b8">[9]</ref>, the authors use Bloom filters to determine the length of the longest matching prefix for an address, and then they refer to the entire forwarding table stored in the slow large memory to determine the outgoing link. In these works, every address lookup still must access the slow memory at least once. Instead, we advocate performing the entire lookup in the fast memory. Similar to the work in resource routing <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b11">12]</ref> 1 , one Bloom filter is constructed for each next hop (i.e., outgoing link), and is used to store all the addresses that are forwarded to that next hop. T Bloom filters are constructed in the router where T is the number of next hops. This scheme works well under a wide range of workloads at the expense of a few false positives.</p><p>In this paper, we provide practical techniques to apply the basic Bloom filter idea to fast packet forwarding in enterprise edge routers:</p><p>• To make efficient use of limited fast memory, we optimize the sizes and number of hash functions of the Bloom filters. Surprisingly, we show that to reach the optimal overall false-positive rate, Bloom filters with fewer elements must have fewer false positives than those with more elements. We also prove that a small T in the enterprise edge router will lead to a small overall false-positive rate. To obtain a false-positive rate of 1%, we need only 300 KB of fast memory to store the FIB of 165K entries obtained from an edge router with 10 next hops.</p><p>• To adapt Bloom filters for routing changes, which happen on a much longer time scale than packet forwarding, we store counting Bloom filters in the large, slow memory. To reduce the false-positive rate under routing changes, we dynamically adjust the size and number of hash functions of Bloom filters in fast memory by keeping large fixed-size counting Bloom filters in slow memory.</p><p>• Since enterprise edge routers usually have multiple upstream providers, a few false positives are allowable. We also propose multiple methods to handle false positives for enterprise edge routers. The rest of the paper is organized as follows: Section 2 gives a brief introduction to Bloom filters. Section 3 describes our solution to perform the entire packet address lookup in small fast memory, and our enhancements for reducing computational overhead and false positives. Section 4 evaluates the false-positive rate of our solution under various settings. Section 5 shows how we leverage counting Bloom filters in slow memory to handle routing changes. Section 6 discusses our solutions to handle false positives. Sections 7 and 8 discuss related work and conclude the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND ON BLOOM FILTERS</head><p>In this section, we give a brief introduction to Bloom filters and counting Bloom filters, which are the basis of our address lookup solutions. A Bloom filter <ref type="bibr" target="#b3">[4]</ref> is a compact data structure to store a set of elements. A Bloom filter supports two operationsinserting an element into the set and checking whether an element is a member of the set. A Bloom filter consists of an array of bits. To insert an element into a Bloom filter, we compute k hash functions on the element, and get k values each denoting a position in the array. All the k positions are set to 1 in the array. By repeating the same procedure for all the elements in the set, the Bloom filter is constructed to represent the summary of the set of elements with constant space. It is easy to check if an element belongs to the set with Bloom filter. Given an element, we calculate the same k hash functions and check the bits in the corresponding k positions of the array. If all the bits are 1, we say that the element is in the set; otherwise it is not.</p><p>Bloom filters have no false negatives -if one of the k positions is set to 0, the element must not belong to the set. However, Bloom filters can have false positives -an element can absent from the set even if all k positions are set to 1, since each position could be set by the other elements in the set. Assume a Bloom filter with an array of m bits stores n elements. The false-positive rate of a Bloom filter is:</p><formula xml:id="formula_0">f = (1 − (1 − 1/m) kn ) k ≈ (1 − e −kn/m ) k</formula><p>To store a set of n elements in a Bloom filter, the larger m is the smaller the false-positive rate is. For a Bloom filter with fixed size m, to minimize false-positive rate, the number of hash functions k and the minimum false-positive rate f are:</p><formula xml:id="formula_1">k = m ln 2/n, f = (0.5) k</formula><p>We can add elements to standard Bloom filters, but there is no way to delete an element. A counting Bloom filter <ref type="bibr" target="#b9">[10]</ref> is an extension of the Bloom filter to allow adding and deleting elements in a set. A counting Bloom filter stores a counter rather than a bit in each slot of the array. To add an element to the counting Bloom filter, we increment the counters at the positions calculated by the hash functions; to delete an element, we decrement the counters. If the counters do not overflow, counting Bloom filters do not have any false negatives and their false-positive rates can be calculated in the same way as standard Bloom filters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">BLOOM FILTER FORWARDING</head><p>In this section, we consider a forwarding table that contains a fixed set of routes. We focus on the data plane in the router, i.e., how to perform packet lookup and forwarding. Our goal is to store the forwarding table in an M -bit fast memory. We assume the router connects to T next hops, which is typically small for enterprise edge routers. For simplicity, we assume flat addresses first, and then extend the solution to addresses with various prefix lengths.</p><p>We first give an overview of the basic idea of using one Bloom filter for each next hop. We then discuss our practical solutions of making the basic idea work for enterprise edge routers, including the sizing of the Bloom filters and the analysis of false positives for addresses with different prefix lengths.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Basic Idea of Using Bloom Filters</head><p>For simplicity, we first consider using Bloom filters to perform FIB lookups for flat addresses, such as the MAC addresses used in Ethernet. New protocols with flat address spaces (e.g., ROFL <ref type="bibr" target="#b4">[5]</ref>, AIP <ref type="bibr" target="#b0">[1]</ref>) have been proposed to facilitate the Internet's growth and configuration. Even with CIDR (variable length) prefixes, we can convert each prefix into small, fixed-length (i.e., /24) sub-prefixes that do not overlap.</p><p>We set one Bloom filter for each next hop (or outgoing link), and use it to store all the addresses that are forwarded to that next hop. For a router with T next hops, we need T Bloom filters. An address with next-hop t is stored in Bloom filter BF (t). To perform address lookup for an address p, we check which BF (t) (t ∈ [1..T ]) p is in, and get the corresponding next hop p should be forwarded to. To reduce the computational overhead of address lookup, we apply the same group of hash functions to all the T Bloom filters.</p><p>This scheme is not affected by worst-case workloads as opposed to route caching. The false positive of one address lookup does not affect the lookup of other addresses. In order to send packets that lead to false positives, attackers have to know all the hash functions used to construct Bloom filters. We can change hash functions over time to avoid such attack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Variable Size to Reduce False Positives</head><p>Since there are different numbers of addresses per next hop, we should use different sizes for the Bloom filters according to the number of addresses stored in them, in order to minimize the overall false-positive rate with the small, M-bit fast memory.</p><p>We first give the definition of the overall false-positive rate. If any one of the T Bloom filters has a false positive, an address will hit in multiple Bloom filters. In this case, we will get multiple next hops for the address and cannot decide which next hop to forward the packet to. We define the overall false-positive rate as the probability that any one of the T Bloom filters has a false positive. Let f (t) denote the false-positive rate of Bloom filter BF (t). Since Bloom filters for different next hops store independent sets of addresses, and thus are independent of each other, the overall false-positive rate of T Bloom filters is</p><formula xml:id="formula_2">F (T ) = 1 − T Y t=1 (1 − f (t)) ≈ T X t=1 f (t) (when f (t) 񮽙 1/T, ∀t = 1..T )</formula><p>From the equation, we can see that the false-positive rate is relatively low for edge routers in enterprise networks, since the number of next hops T is usually small.</p><p>The overall false-positive rate could be minimized by varying the sizes and the number of hash functions of Bloom filters. If we do not consider route changes, we are aware of the exact number of addresses to be stored in each Bloom filter. Let n(t) denote the number of addresses stored in Bloom filter BF (t). We optimize the false-positive rate F (T ) by choosing the best m(t) (the number of bits in BF (t)) and k(t) (the number of hash functions used in BF (t)), with the constraint that Bloom filters must not take more space than the size of the fast memory. The problem to minimize the overall false-positive rate is formulated as:</p><formula xml:id="formula_3">Minimize F (T ) = T X t=1 f (t) s.t. f (t) = (1 − e −k(t)n(t)/m(t) ) k(t) T X t=1 m(t) = M given M and n(t)(∀t ∈ [1..T ])</formula><p>Through calculus calculation, F(T) is minimized when we size each Bloom filter with</p><formula xml:id="formula_4">m(t) = (λ − ln n(t))n(t) ln 2 2 (1) λ = ln M ln 2 2 + P T t=1 (n(t) ln n(t)) P T t=1 n(t)</formula><p>The number of functions used in each Bloom filter is:</p><formula xml:id="formula_5">k(t) = m(t) n(t) ln 2 = λ − ln n(t) ln 2 (2)</formula><p>The optimal F (T ) is</p><formula xml:id="formula_6">F (T ) = T X t=1 ( 1 2 ) k(t)</formula><p>Now given a forwarding table and fast memory size, we are able to construct T Bloom filters that minimize the overall false-positive rate by calculating m(t) and k(t) with Equations <ref type="formula">(1)</ref> and <ref type="formula">(2)</ref>. Interestingly, the false-positive rate on each Bloom filter is not equal in the optimal solution. In fact, Bloom filters with fewer elements obtain smaller falsepositive rate. This is because we have memory size constraint, adding the same amount of memory for the Bloom filter with fewer addresses reduces its false-positive rate more than for the one with more addresses. We evaluate both equal false-positive rate solution and optimal solution in Section 4. We've discussed that T Bloom filters could share the same group of hash functions to reduce computational overhead. Though we have a different number of hash functions for each Bloom filter, the Bloom filters can still share part of the hash functions. We calculate the same group of kmax hash functions hi (i ∈ [1..kmax]) to reduce the computational overhead, where</p><formula xml:id="formula_7">kmax = T max t=1 k(t).</formula><p>To look up an address p, we use the first k(t) hash values for Bloom filter BF (t) (t ∈ [1..T ]). Similar to the single Bloom filter case, we check in Bloom filter BF (t), whether the bits in positions</p><formula xml:id="formula_8">hi(p) mod m(t), ∀i ∈ [1..k(t)]</formula><p>are all 1. If so, p is in BF (t); otherwise, it is not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">False Positive Analysis on Longest Prefix Match</head><p>To perform longest prefix match, similar to the solution in <ref type="bibr" target="#b8">[9]</ref>, we use one Bloom filter for each prefix length. We construct 32T Bloom filters with</p><formula xml:id="formula_9">BF l (t)(l ∈ [1..32], t ∈ [1..T ])</formula><p>storing the addresses with prefix length l and outgoing link t. We optimize the size of each Bloom filter m l (t) and the number of hash functions in them k l (t) to obtain minimal overall false-positive rate. Now we describe the algorithm to perform lookup for address p. Let p l denote the l bit prefix of address p. We first calculate kmax hash functions hi </p><formula xml:id="formula_10">(i ∈ [1..kmax]),</formula><formula xml:id="formula_11">(t) (∀t ∈ [1..T ], t 񮽙 = t * )</formula><p>, we are sure that t * is the correct next hop. In general, if an address p matches at least one entry in the FIB and all the matching entries 2 have the same next hop t * , the probability that the Bloom filter mechanism does not output t * (i.e., the address hits Bloom filters for different next hops due to false positives) is :</p><formula xml:id="formula_12">Prob(∃t ∈ [1..T ], t 񮽙 = t * , ∃l ∈ [1..32], p l is in BF l (t)) = 1 − Y t񮽙 =t * 32 Y l=1 (1 − f l (t)) ≈ X t񮽙 =t * 32 X l=1 f l (t)</formula><p>This property reduces false positives significantly for enterprise edge routers where T is small. Our solution is to reconstruct the FIB such that the prefixes from different entries in the FIB do not overlap. In the 2 We mean the matches of prefixes of all the lengths, not just longest prefix match. previous example, if we know that the address "15.128.0.8" hits only one entry in the FIB, when it hits multiple Bloom filters with different next hops, we are sure a false positive has happened. One way to reconstruct the FIB is to use flat addresses. We can expand the prefix into a group of non-overlapping prefixes with a fixed prefix length say /24. However, using flat addresses may increase the number of prefixes significantly. Therefore, we choose to expand the prefixes to a group of non-overlapping prefixes with various lengths. In the previous example, we use the two entries: "15.0.0.0/17 → A", "15.128.0.0/17 → B", so "15.128.0.8" only hits the second entry.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">PERFORMANCE EVALUATION</head><p>We evaluate the false-positive rate with real forwarding tables and packet traces from FUNET and Internet2, and compare them to the analytical results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Experimental Setup</head><p>We use routing table and packet traces from an edge router in the Finnish University Network (FUNET) in March 2005. <ref type="bibr" target="#b2">3</ref> The edge router is located in Helsinki University of Technology, which carries FUNET international traffic. The routing </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Evaluation of False Positives</head><p>To study our mechanism on flat addresses, we convert the prefixes in the routing tables into /24 prefixes. The new FUNET and Internet2 table have 5400K and 900K flat addresses respectively. <ref type="figure">Figure 1</ref> shows the analytical falsepositive rate (labeled as ana in <ref type="figure">Figure 1</ref>) and the experimental result (labeled as sim) with the increase of fast memory size. We test both the optimal setting based on Equations (1) and (2) (labeled as opt) and the setting that has the same false-positive rate for all the Bloom filters (labeled as eq). Compared with equal false-positive rate setting, the optimal setting of the same fast memory size reduces the overall false-positive rate by 90% in FUNET and 70% in Internet2. With optimal setting, to reach the false-positive rate of 1%, we need only 6 MB fast memory in FUNET (i.e., 9 bits/address) and 1.5 MB (i.e., 13 bits/address) in Internet2. Since FUNET edge router has fewer next hops than Internet2 router, it needs less memory space for each address.</p><p>We then study the effect of longest prefix match on false positives. We modified the original FIB by converting nested prefixes to non-overlapping prefixes with various prefix lengths. <ref type="table" target="#tab_1">The modified FUNET table has 250K entries and Internet2  table contains 15K</ref> entries. <ref type="figure" target="#fig_3">Figure 2</ref> shows the false-positive rate with both original and modified FIBs in the optimal setting. Since the modified FIB has more entries than the original one, when the memory size is small, the false-positive rate on the modified FIB is larger than the original FIB. However, with the original FIB, the false-positive rate remains around 0.8% with the increase of fast memory size. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 1: False positives with flat address</head><p>This is because we are not able to distinguish false positives and multiple valid matches on nested prefixes (the "bad effect" discussed in Section 3). With the modified FIB where prefixes are not overlapping, the false-positive rate is further reduced with the increase of fast memory size. To achieve 0.1% false-positive rate with modified FIBs, we need 400 KB fast memory in FUNET and 40 KB in Internet2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">HANDLING ROUTING CHANGES</head><p>With standard Bloom filters (BF), we cannot delete elements from the set. We use counting Bloom filters (CBF), which allow both addition and deletion operations, to handle the dynamics of routing tables. However, CBFs require more space than BFs since they store a counter rather than a bit in each spot of the array. Fortunately, since routing changes do not happen very often and thus allow more computational overhead, we can store CBFs in slow memory, and update BFs in small fast memory based on CBFs. By using both CBFs and BFs, we make an efficient use of small fast memory without losing the flexibility to support changes in the FIB.</p><p>In this section, we first describe the use of CBFs in slow memory to keep track of changes in the forwarding table. We then discuss how to update the BF from the CBF and how to change the size of the BF without reconstructing the CBF.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Maintaining CBF in Slow Memory</head><p>In a router, the control plane maintains the RIB (Routing Information Base) and updates the FIB (Forwarding Information Base) in the data plane. We implement a group of T CBFs, each containing the prefixes associated with one next hop, corresponding to the BFs described in Section 3. If the  control plane adds a route to the FIB for a new address p with next hop t, we will insert p to CBF (t). Similarly, to delete a route is we delete p in CBF (t). <ref type="bibr" target="#b3">4</ref> The insertion and deletion operations on the CBF are described in Section 2. Since CBFs are maintained in slow memory, we set the sizes of CBFs large enough, so that even with routing changes, the false-positive rates on CBFs are low.</p><p>After the CBF (t) is updated, we update the corresponding BF (t) based on the new CBF (t). If the CBF and BF are of the same size, we can easily update the BF by checking if each position in the CBF is 0 or not. However, we have to dynamically adjust the size of the BF to reduce the overall false-positive rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Adjust BF Size without Reconstructing CBF</head><p>When the forwarding table changes over time, the number of prefixes in the BF changes, so the size of the BF and the number of hash functions to achieve the optimal falsepositive rate also change (see Equations <ref type="formula">(1)</ref> and <ref type="formula">(2)</ref>). We leverage the nice property that to halve the size of a Bloom filter, we just OR the first and second halves together <ref type="bibr" target="#b3">[4]</ref>. In general, the same trick applies to reducing the size of a Bloom filter by a constant c. This works well in reducing the BF size when the number of prefixes in the BF decreases. However, when the number of prefixes increases, it is hard to expand the BF.</p><p>Fortunately, we maintain a large, fixed size CBF in the slow memory. We can dynamically increase or decrease the size of the BF by mapping multiple positions in the CBF to one position in the BF. For example in <ref type="figure" target="#fig_4">Figure 3,</ref>   To minimize the overall false-positive rate under routing changes, we monitor the number of prefixes in each CBF, and periodically reconstruct BFs to be of the optimal sizes and number of hash functions. The procedure of reconstructing a BF with an optimal size from the corresponding CBF is described in three steps:</p><p>Step 1: Calculate the optimal BF size and the number of hash functions. Using Equation <ref type="formula">(1)</ref>, we first get the optimal size of each BF and denote it by m * . Then we round m * to m 񮽙 , which is a factor of S,</p><formula xml:id="formula_13">m 񮽙 = S/c, where c = 񮽙S/m * 񮽙.</formula><p>Finally we calculate the optimal number of hash functions to minimize false positive with size m 񮽙 and the number of prefixes n in the BF: k 񮽙 = m 񮽙 ln 2/n.</p><p>Step 2: Change the number of hash functions in the CBF from k to k 񮽙 . There are two ways to change the number of functions with either more computation or more space: (i) If k 񮽙 &gt; k, we calculate the hash values with the k 񮽙 − k new hash functions on all the prefixes currently in the BF, and update the CBF by incrementing the counters in corresponding positions. If k 񮽙 &lt; k, we also calculate k − k 񮽙 hash values, and decrementing the counters in corresponding positions. (ii) Instead of doing the calculation on the fly, we can pre-calculate the values of these hash functions with all the elements and store them in the slow memory.</p><p>Step 3: Construct the BF of size m 񮽙 = S/c based on the CBF of size S. As shown in <ref type="figure" target="#fig_4">Figure 3</ref>, the value of the BF at position x (x ∈ [1..m 񮽙 ]) is updated by c positions in CBF x, 2x, ... cx. If all the counters in the c positions of CBF are 0, we set the position x in BF to 0; otherwise, we set it to 1. During routing changes, the BFs can be updated based on CBFs in the same way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">HANDLING FALSE POSITIVES</head><p>In this section, we first describe three ways to handle packets that experience false positives in the Bloom filters. Then we discuss our caching solution to avoid subsequent packets from experiencing false positives. Finally, we combine these techniques to produce a practical solution for enterprise edge routers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Handling Packets with False Positives</head><p>When a packet has a match in multiple Bloom filters, we detect that the packet is experiencing a false positive. <ref type="bibr" target="#b4">5</ref> We provide three techniques to forward the packet that experiences false positives. Redirection: If a lookup returns multiple next hops, we can redirect the packet to another place that knows the answer. For example, we can redirect the packet to another core in the multi-core system, which will do a conventional look up on the FIB. Similar to ViAggre <ref type="bibr" target="#b1">[2]</ref>, if we have a set of routers in the network each responsible for part of the address space, the packets could be redirected to the responsible router. Similar to Ethane <ref type="bibr" target="#b5">[6]</ref>, we can also have a centralized server to handle packets that experience false positives from any edge routers in the network. With packet redirection, we are guaranteed to forward the packet correctly through a slower decision path. Send duplicate packets out:</p><p>To ensure the packets experiencing false positives finally reach their destinations without any delay in forwarding, we can just send a copy of the packet out to each next hop that the packet hits. Since false positives are rare, it is highly unlikely that two Bloom filters experience false positives at the same time. Therefore in most cases, we send only two packets out knowing that one of them is sent to the correct next hop. The next-hop router may either forward the packet if it knows how to reach the destination or drop the packet if it does not. This solution also guarantees the packet will reach the destination, though with the risk of introducing extra traffic and packet loops. Send to a random next hop: An alternative way to handle false positives, which neither delays the packet nor adds extra traffic, is to randomly pick one of the Bloom filters the packet hit in, and send the packet to the corresponding next hop. Since most edge routers are multi-homed, the packets are likely to get to the destination finally through any next hop we choose. The problem of this method is that sometimes the packet gets lost. However, a few packet losses are tolerable in the Internet especially when false positives are rare.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Caching for Subsequent Packets</head><p>Although the above three methods handle the case where a few packets experience false positives, if a burst of packets to the same destination all experience false positives, the packets will either experience a performance decrease (through redirection), or cause a lot of traffic (if we send multiple copies of the packet out), or significant packet loss (if we direct the packet to just one of the next hops). Therefore, when the first packet experiences a false positive, we perform a conventional lookup and cache the result, so that the subsequent packets will hit in the cache and no longer experience false positives. Note that our caching solution differs from conventional route caching in that it is robust to malicious traffic. With conventional route caching, an at-tacker can easily send packets with a wide range of destinations resulting in a high cache-miss rate. However, since the attacker does not know the hash functions used for Bloom filters, it is hard to construct a flow of packets that makes our caching mechanism inefficient. Even if the attacker sends lots of packets, detects a few packets that experience false positives, and replay them, the replayed packets will hit in the cache and will not experience false positives.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Case Study: Enterprise Edge Routers</head><p>We apply the techniques discussed above to handle false positives for enterprise edge routers. Enterprise edge routers are connected to routers both in different ISPs and within its own network. There are only a few ISP routers, which are the next hops for most of the addresses. The routers within the enterprise network are next hops for a relatively small number of addresses. Next hops that are ISP routers:</p><p>Edge routers are usually home to multiple ISPs for load balancing and greater reliability. Since vast majority of addresses will have these ISP routers as next hops, if a packet with false positive ends up with two ISP next-hop routers, sending it to either of them would be fine in most cases. If the next-hop router we pick does not have a route to forward the packet, it will drop the packet. The end hosts have to retransmit the packet when they detect packet loss. Next hops that are within the enterprise: Different from ISP routers, if the packets that are destined in the enterprise network are sent to the wrong next hop, they may never reach the destination. Fortunately, the addresses within the enterprise may fall within one or a few address blocks, so it is quick to check whether an address should be forwarded internal or external. Since there are only a small number of destinations inside the enterprise network, we can afford to store the complete forwarding information in a hash table.</p><p>We divide the FIB of the enterprise edge router into two parts: for the destinations within the enterprise network, we construct a hash table storing their next hops; for the external destinations, we construct the Bloom filters for all the next hops from different ISPs. To perform a packet lookup on the edge router, we first check whether the address is internal or external. If it is internal, we look up the hash table with all the destinations in its sub-network for the next hop. If the address is external, we perform the lookup with the Bloom filters. If we get multiple hits in the Bloom filters, we randomly pick one next hop and send the packet out through it. At the same time, we redirect the packet to another processor to perform a conventional FIB lookup and cache the result, so the following packets that have the same destination will hit in the cache and get to the correct next hop directly without experiencing a false positive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>The idea of using small fast memory to improve packet address lookup performance has been applied in route caching. A route cache stores the most popular part of the forwarding table in a small, fast memory. However, as discussed in Section 1, traffic with a wide range of destinations may increase the cache miss rate significantly, leading to both the inefficient packet lookup and the significant CPU consumption due to cache swapping. In contrast, since the attacker does not know the hash functions, the false positive in our Bloom filters cannot be easily generated by malicious traffic.</p><p>Bloom filters have been used for longest prefix match <ref type="bibr" target="#b8">[9]</ref>. The authors use Bloom filters to determine the length of the longest matching prefix for an address, and then perform a direct lookup in a large hash table in slow memory. Different from their work, we perform the entire lookup in the fast memory at the expense of a few false positives. In <ref type="bibr" target="#b8">[9]</ref>, the goal is to reduce false positives in each Bloom filter. Thus they choose to use the size of Bloom filters proportional to the number of elements in it, and propose mini-Bloom filters to deal with various distributions of prefix lengths. In contrast, our goal is to minimize the overall false-positive rate rather than the false positive on each Bloom filter. We thus choose the optimal sizes for Bloom filters and dynamically adjust the size upon routing changes. The authors also discussed some alternative solutions to use less than 32 Bloom filters in longest prefix match, such as grouping the prefix lengths. Their techniques can be applied to our solution.</p><p>Bloom filters have also been used in resource routing <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b11">12]</ref>, which applies Bloom filters to probabilistic algorithms for locating resources. Our "one Bloom filter per next hop" is similar to their general idea of using one Bloom filter to store the list of resources that can be accessed through each neighboring node. In order to keep up with link speed in packet forwarding with strict fast memory size constraint, we dynamically tune the optimal size and the number of hash functions of Bloom filters by keeping large fixed-size counting Bloom filters in slow memory.</p><p>In general, packet address lookup can be viewed as an application of a hash table, where for each key (address), we find out the matching value (next hop). Bloomier filter <ref type="bibr" target="#b6">[7]</ref> is a generalization of Bloom filter to associate a function value (from a discrete finite set of values) with each element in a static set, which uses a group of Bloom filters to represent the values. In theory, if both the set and the function values are static, the Bloomier filter only needs linear space. Our work is similar to the Bloomier filter in that we use a group of Bloom filters, one for each value of a function that maps a prefix to a next hop. Since we focus on the forwarding table on enterprise edge routers, we provide simple, practical solutions to handle false positives and routing changes.</p><p>People have proposed to use multiple hash functions to store the matching of keys and values. With d hash functions, we need to decide which of the d positions in the array to store the value and how to handle collisions. The authors in <ref type="bibr" target="#b2">[3]</ref> design a d-left scheme for IP lookups. In this scheme, there is a bucket corresponding to each position of the array in the slow memory, and the value is stored in one of the d buckets in a load balancing way. However, to perform an IP lookup, we still need to access the slow memory at least d times. In <ref type="bibr" target="#b12">[13]</ref>, the authors use Bloom filter in the fast memory, and store the values in a linked structure in the slow memory such that the value can be accessed via one access on the slow memory most of the times. In contrast, we perform the entire packet lookup in the fast memory.</p><p>To handle routing changes, the works in <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b12">13]</ref> use the counting Bloom filter (CBF) in fast memory, which uses more memory space than the Bloom filter (BF). We leverage the fact that routing changes happen on a much longer time scale than address lookup, and thus store only the BF in fast memory, and use the CBF in slow memory to handle routing changes. Our idea of maintaining both the CBF and BF is similar to the work in <ref type="bibr" target="#b9">[10]</ref>, which uses BFs for sharing caches among Web proxies. Since cache contents change frequently, the authors suggest that caches use a CBF to track their own cache contents, and broadcast the corresponding BF to the other proxies. The CBF is used to avoid the cost of reconstructing the BF from scratch when an update is sent; the BF rather than the CBF is sent to the other proxies to reduce the size of broadcast messages. Different from their work, we dynamically adjust the size of the BF without reconstructing the corresponding CBF, which may be useful for other Bloom filter applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSION</head><p>To improve packet-forwarding performance, we leverage a hierarchy of small, fast memory and large, slow memory. Leveraging the unique properties in enterprise edge routers, we propose a Bloom filter based mechanism, which performs the entire packet address lookup in less 1 MB fast memory. Our mechanism works well under worst-case workloads such as packets with a wide range of destinations, and is also robust to route changes and malicious traffic.</p><p>We are implementing our Bloom filter mechanism as a module in Click <ref type="bibr" target="#b10">[11]</ref> modular router. We will deploy it on multi-core commodity platforms. To leverage many cores and the hierarchical cache architecture, we divide the FIB into address ranges, where each core is responsible for packet forwarding for one part of the address space. We leverage VMDq (Virtual Machine Device Queues) techniques in modern NICs to demultiplex the packets to the appropriate cores. Each core maintains a Bloom filter for each next hop, which is sized to minimize the overall false-positive rate, subject to fitting in the cache associated with each core. In the next-level cache shared amongst the cores, we store counting Bloom filters to handle routing changes and the entire FIB for forwarding packets that experience false positives. We will evaluate our mechanism across a wide range of workloads and under routing changes.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>WREN' 09 ,</head><label>09</label><figDesc>August 21, 2009, Barcelona, Spain. Copyright 2009 ACM 978-1-60558-443-0/09/08 ...$10.00.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Bad Effect:</head><label></label><figDesc>It is difficult to distinguish a false posi- tive from the case that an address matches multiple entries with different prefix lengths in the FIB. Sometimes an ad- dress may hit multiple Bloom filters, though there are not any false positives in all the 32T Bloom filters. For ex- ample, in a router's forwarding table, there are two en- tries: "15.0.0.0/16 → A", "15.128.0.0/17 → B", while A and B are two next hops belonging to different providers. We thus store "15.0.0.0/16" in Bloom filter BF 16 (A) and "15.128.0.0/17" in BF 17 (B). In this case, the address "15.128.0.8" may hit both Bloom filters. Using longest prefix match, we should send the packet to B. However, with our Bloom filter mechanism, we cannot be sure the hit in BF 17 (B) is not a false positive. Therefore, when we find multiple next hops matched in the Bloom filters, we are not able to distinguish the false positives and the many valid matches with different prefix lengths.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: False positives with longest prefix match</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Adjust BF size from m to 2m based on CBF</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>where kmax is the maximum number of hash functions in all thesuch that prefix p l belongs to BF l (t * ). If we cannot find p in any BF l (t * ), ∀l ∈ [1..32], we know that p should not be forwarded to t * . Repeating the same procedure for all t (t ∈ [1..T ]), we will finally find out the outgoing link that p should be forwarded to.(t * ) (∀l ∈ [1..32]) do not influence the overall false-positive rate. For example, when an address hits only two Bloom filters BF l 1 (t * ) and BF l 2 (t * ), even if one of the hits is false positive, we can still determine t * is</head><label></label><figDesc>the correct next hop. Therefore if there are not any false positives in the other Bloom filters BF l</figDesc><table>Bloom 
filters. 

kmax = 
max 

l∈[1..32],t∈[1..T ] 

k l (t) 

We pick a next hop t  *  , we search for the longest prefix length 
l, Using one Bloom filter per (next hop, prefix length) pair 
has both good and bad effects on the correctness of our 
decision on which next hop to output. 
Good Effect: If a packet should be forwarded to t  *  , the 
false positives of Bloom filters BF l </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>table has 165K</head><label>has</label><figDesc>entries and 10 next hops. The packet trace contains 20 million packets. For Internet 2, we use the rout- ing table from the router located in Chicago and the cor- responding netflow data for January 22, 2009. The routing table contains 12K entries and 34 next hops. The netflow trace contains 12 million packets.</figDesc><table></table></figure>

			<note place="foot" n="1"> These work design the algorithms of locating resources by using one Bloom filter to store a list of resources that can be accessed through each neighboring node.</note>

			<note place="foot" n="3"> This trace is confidential due to the sensitive nature of packets.</note>

			<note place="foot" n="4"> The control plane must make sure that p was forwarded to t. Otherwise, deleting an element not in the Bloom filter would cause errors on future queries.</note>

			<note place="foot" n="5"> Some FIBs do not have default route and assume that addresses that have no match in it should be dropped. However, in our Bloom filter based scheme, the address that has no match in the forwarding table may hit one Bloom filter because of a false positive. To detect such false positives, we can either construct a Bloom filter to store a list of destinations that should be dropped by the router, or just send the packet out which will be finally dropped by the following routers.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Accountable Internet protocol (AIP)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Andersen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Koponen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Making routers last longer with ViAggre</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Ballani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NSDI</title>
		<meeting>NSDI</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Using multiple hash functions to improve IP lookups</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Broder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE INFOCOM</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Network applications of Bloom filters: A survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Broder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Internet Mathematics</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="485" to="509" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">ROFL: Routing on flat labels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Caesar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Condie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Lakshminarayanan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Ethane: Taking control of the enterprise</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pettit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The Bloomier filter: An efficient data structure for static support lookup tables</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chazelle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rubinfeld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIAM Symposium on Discrete Algorithms (SODA)</title>
		<meeting>ACM-SIAM Symposium on Discrete Algorithms (SODA)</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">How to choose the best router switching path for your network</title>
		<imprint/>
		<respStmt>
			<orgName>Cisco Systems</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Longest prefix matching using Bloom filters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Dharmapurikar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Summary cache: A scalable wide-area web cache sharing protocol</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Almeida</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">Z</forename><surname>Broder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The Click modular router</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Jannotti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<date type="published" when="2000-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Probabilistic location and routing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">C</forename><surname>Rhea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kubiatowicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE INFOCOM</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Fast hash table lookup using extended Bloom filter: An aid to network processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Dharmapurikar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Turner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lockwood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
