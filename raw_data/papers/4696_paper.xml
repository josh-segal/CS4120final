<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:58+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient Aggregation over Objects with Extent</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donghui</forename><surname>Zhang</surname></persName>
							<email>donghui@cs.ucr.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Computer Science Department</orgName>
								<orgName type="department" key="dep2">Computer Science Department</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>92521</postCode>
									<settlement>Riverside</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vassilis</forename><forename type="middle">J</forename><surname>Tsotras</surname></persName>
							<email>tsotras@cs.ucr.edu.dg@cs.ucr.edu</email>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>92521</postCode>
									<settlement>Riverside</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dimitrios</forename><surname>Gunopulos</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>92521</postCode>
									<settlement>Riverside</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient Aggregation over Objects with Extent</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>[Extended Abstract]</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>spatial</term>
					<term>functional</term>
					<term>aggregation</term>
					<term>extents</term>
					<term>indexing *</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We examine the problem of efficiently computing sum/count/ avg aggregates over objects with non-zero extent. Recent work on computing multi-dimensional aggregates has concentrated on objects with zero extent (points) on a multi-dimensional grid, or one-dimensional intervals. However, in many spatial and/or spatio-temporal applications objects have extent in various dimensions, while they can be located anywhere in the application space. The aggregation predicate is typically described by a multi-dimensional box (box-sum aggregation). We examine two variations of the problem. In the simple case an object&apos;s value contributes to the aggregation result as a whole as long as the object intersects the query box. More complex is the functional box-sum aggregation introduced in this paper, where objects participate in the aggregation proportionally to the size of their intersection with the query box. We first show that both problems can be reduced to dominance-sum queries. Traditionally, dominance-sum queries are addressed in main memory by a static structure, the ECDF-tree. We then propose two extensions, namely, the ECDF-B-trees, that make this structure disk-based and dynamic. Finally, we introduce the BA-tree that combines the advantages from each ECDF-B-tree. We run experiments comparing the performance of the ECDF-B-trees, the BA-tree and a traditional R*-tree (which has been augmented to include aggregation information on its index nodes) over spatial datasets. Our evaluation reaffirms that the BA-tree has more robust performance. Compared against the augmented R*-tree, the BA-tree offers drastic improvement in query performance at the expense of some limited extra space.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>The general box aggregation problem is concerned with the computation of aggregation queries over objects with nonzero extents in d-dimensional space. Formally, it is defined as: "given n weighted rectangular objects and a query rectangle r in the d-dimensional space, find the cumulative weight of all the objects which intersect r". Previous work on multidimensional aggregations <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b13">14]</ref> considers only point objects (i.e., objects with zero extent in all dimensions) that fall on a fixed multi-dimensional grid. One exception is the work in <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b38">39]</ref> that examines aggregations over interval (i.e., 1-dimensional) objects. We will use the term 'box' aggregation since in recent literature, the term 'multi-dimensional' aggregation has been also used in the context of data cube and group-by computations. <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b2">3]</ref>.</p><p>In this paper we address box-sum aggregations, i.e. summation related aggregations like SUM, COUNT and AVG. What is important for these problems is the number of extensional dimensions, i.e., the dimensions over which the data objects can have extent. In most applications there are 2-3 extensional dimensions which are usually the spatial and temporal dimensions of the objects. While our solutions can be easily generalized to the case where all d dimensions are extensional, we concentrate the discussion on spatial and spatio-temporal data. For example, consider a database in an agricultural agency that keeps track of pesticide usage. Each record represents the treatment of an area over a certain time period and contains a 3-dimensional rectangle (that is, a 2-dimensional area describing the field which is sprayed and the corresponding time interval) and a value (the volume of the pesticide). An example of a boxsum query is: "find the total volume of pesticide sprayed in Orange County for March 1999 ".</p><p>We examine two variations of the box-sum aggregation problem. In its simpler form, an object's value contributes to the aggregation result as long as the object intersects the query box. That is, an object's value contributes to the query result as a whole or not at all. Objects that slightly intersect the query box participate in the result with equal importance as objects that are fully contained in the box.</p><p>There are applications where the object participation needs to be proportional to the size of the object's intersection with the query box. Furthermore, the value associated with each object can be a function rather than a single constant, which provides for more expressive queries. In the pesticide example, the value associated with each spray record may denote the volume per square yard while the aggregation query asks for the total volume sprayed over a given area. This is a novel problem, namely, the functional box-sum aggregation.</p><p>A straightforward approach to solve the box-sum queries is to index the data objects with a multi-dimensional access method like the R*-tree <ref type="bibr" target="#b6">[7]</ref> and reduce the problem to a range search. The aggregate is then computed by identifying the objects that intersect the query box and accumulating their values incrementally. Unfortunately, the performance of this approach is based on how many objects are in the query box, which can be large. Recently, <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b24">25]</ref> proposed to add aggregation summaries on the R-tree nodes (the aggregate R-tree, or aR-Tree) so as to reduce the number of R-tree nodes visited. Even with this optimization the query effort is still affected by the size of the query box.</p><p>We instead propose a different approach that uses specialized aggregate indices. Such indices incrementally maintain aggregates and offer drastic query performance over traditional, object-indexing schemes <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b38">39]</ref>. We first provide a new approach to reduce the simple box-sum problem to computing dominance-sums. This reduction is provably more efficient than previous approaches <ref type="bibr" target="#b12">[13]</ref>. Furthermore, we show that for a large collection of functions (polynomials of constant degree), the functional box-sum problem is also reduced to dominance-sums.</p><p>The best existing scheme to compute dominance-sums is the ECDF-tree <ref type="bibr" target="#b4">[5]</ref>, which however is a static, main-memory structure. We propose two extensions to it (the ECDF-Btrees) that make this structure disk-based and dynamic. In particular, the ECDF-B q -tree guarantees fast query performance while the ECDF-B u -tree has better update. Then we introduce a novel disk-based and dynamic index, the Box Aggregation Tree (BA-tree), which combines the advantages from each ECDF-B-tree. Experimental results show that the BA-tree has very good average case behavior. It is easily implementable and has more robust performance than the ECDF-B-trees. Furthermore, depending on the sizes of the query boxes we have witnessed an order of magnitude improvement in query performance of the BA-tree against the aR-tree.</p><p>We note that our solution applies also to computing rangesums over data cubes. The best known solutions for data cube range-sum appear in <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b9">10]</ref>. When applied to this problem, the BA-tree differs from <ref type="bibr" target="#b13">[14]</ref> in two ways. First, it is disk-based, while <ref type="bibr" target="#b13">[14]</ref> presents a main-memory structure. Second, the BA-tree partitions the space based on the data distribution while <ref type="bibr" target="#b13">[14]</ref> does partitioning based on a uniform grid.</p><p>To summarize, the main contributions of this paper are:</p><p>1. We provide a new approach to reduce a simple boxsum aggregation query to dominance-sum queries;</p><p>2. We introduce a novel variation, the functional box-sum problem and show how it is reduced to dominance-sum queries for a large class of value functions. To the best of our knowledge, this is the first work that addresses the functional aggregation problem;</p><p>3. To solve dominance-sum queries, we propose two approaches that transform the main-memory, static ECDFtree to external structures that can handle dynamic updates (the ECDF-B-trees);</p><p>4. We finally propose the BA-tree, which is a dynamic, easily implementable, disk-based index that combines the advantages of both ECDF-B-trees. We provide experimental results to validate the efficiency of the proposed index.</p><p>The rest of the paper is organized as follows. Sections 2 and 3 discuss the simple and (respectively) the functional box-sum aggregations and their reduction to dominance-sum queries. Section 4 summarizes the two ECDF-tree extensions, while section 5 introduces the BA-tree. Results from our experimental comparisons appear in section 6. Related work is discussed in section 7 while section 8 provides conclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">THE SIMPLE BOX-SUM PROBLEM AND ITS REDUCTION</head><p>We differentiate between two types of objects: point and box</p><formula xml:id="formula_0">objects. Given two d-dimensional points x = (x1, · · · , x d ) and y = (y 1 , · · · , y d ), we say that x dominates y if for ev- ery i ∈ {1, · · · , d}, x i ≥ y i . A d-dimensional box b</formula><p>can be described by two corner points: a low point which is dominated by all other corner points of b and a high point which dominates all other corner points of b. The d-dimensional space is itself a box whose low point and high point are represented as p min and p max , respectively. Each object has a value which is used for the aggregation. We refer to the following aggregations:</p><p>• (simple) box-sum: given a collection S b of box objects and a query box q, compute SUM{o.value|o ∈ S b and o.box intersects q};</p><p>• range-sum: given a collection Sp of point objects and a query box q, compute SUM{o.value|o ∈ Sp and o.point is contained in q};</p><p>• dominance-sum: given a collection S p of point objects and a query point p, compute SUM{ o.value|o ∈ S p and o.point is dominated by p}.</p><p>The box-sum problem is the most general since, (i) the range-sum problem is a special case of the box-sum when the box of each object reduces into a point, and, (ii) the dominance-sum problem is a special case of the range-sum problem with query box q = (p min , p). The COUNT aggregation problems (box-count, range-count and dominancecount) are special cases of the SUM aggregations, when the value of every object is 1.</p><p>[13] proposed a technique to reduce a box-sum query into a set of dominance-sum queries, as illustrated in <ref type="figure" target="#fig_0">figure 1</ref>. Since it is easy to maintain the sum of all objects, to find the sum of objects intersecting a query box, it is enough to compute the sum of objects NOT intersecting the query box. These objects must be either above, below, to the left of, or to the right of the query box. To find the sum of objects which are to the left of the query box can be done via a 1-dimensional dominance-sum query. I.e. if we maintain the higher x of all objects, the task is to find the dominancesum regarding the lower x of the query box. Similarly, we can compute the sum for objects above, below, and to the right of the query box. If we add up these results, we get a value larger than the anticipated box-sum. The reason is that any object which resides in the regions A, B, C or D is counted twice. We note that the sum in each of these areas can be answered by a 2-dimensional dominance-sum query. Hence, a 2-dimensional box-sum query is reduced to four 1-dimensional and four 2-dimensional dominance-sum queries.</p><p>Important in the reduction technique is the number of dominance-sum queries a box-sum query is reduced to. <ref type="bibr" target="#b12">[13]</ref> only discussed the 1-and 2-dimensional cases; while no analysis is presented for the general d-dimensional case. We analyze the reduction technique for the d-dimensional case and show its complexity in theorem 1. Then we propose a better reduction technique.</p><formula xml:id="formula_1">Theorem 1. The method of [13] reduces a d-dimensional box-sum query into Ω 3 d / √ d dominance-sums.</formula><p>Proof Sketch. We can generalize the scheme of <ref type="bibr" target="#b12">[13]</ref> to the d-dimensional case as follows. To compute a box-sum, we first initialize value S = 0. Next, for every (d-1)-dimensional boundary box (also called face) of q, a 1-dimensional dominancesum query is performed and its result is added to S. A 2-dimensional dominance-sum query is also performed for every (d-2)-dimensional boundary box; these query results are then subtracted from S. If d ≥ 3, a 3-dimensional dominance-sum query is performed for every (d-3)-dimensional boundary box and the query results are added to S. This process continues until the d-dimensional dominancesum queries. I.e. for every 0-dimensional boundary box (which corresponds to a corner point of q), a d-dimensional dominance-sum query is performed.</p><p>As a result, <ref type="bibr" target="#b12">[13]</ref> reduces a d-dimensional box-sum query to a collection of dominance-sum queries, where for every i ∈ [1..d], the number of i-dimensional dominance-sum queries is equal to the number of (d-i)-dimensional boundary boxes of a d-dimensional box, which is equal to 2 i C i d , where</p><formula xml:id="formula_2">C i d = d! i!(d − i)!</formula><p>Thus to prove theorem 1, it remains to prove that:</p><formula xml:id="formula_3">d i=1 2 i C i d = Ω 3 d / √ d (1) Clearly, d i=1 2 i C i d ≥ 2 2d/3 C 2d/3 d = 2 2d/3 d! (2d/3)!(d/3)!<label>(2)</label></formula><p>From Stirling's approximation we have:</p><formula xml:id="formula_4">n! = √ 2πn n e n 1 + Θ 1 n<label>(3)</label></formula><p>We can derive equation 1 from 2 and 3.</p><p>We now present a new technique which reduces a d-dimensional box-sum query to exactly 2 d dominance-sum queries. Even for small d values our reduction provides a drastic improvement over <ref type="bibr" target="#b12">[13]</ref>. For example, with d = 3 a method based on <ref type="bibr" target="#b12">[13]</ref> would need 26 queries while our technique only 8.</p><formula xml:id="formula_5">= - - + (a) (b) (c) (d) (e)</formula><p>Figure 2: A 2-dimensional box-sum query is reduced to four dominance-sum queries.</p><p>Intuitively, a d-dimensional box has 2 d corners. An index is maintained for each given corner (e.g. the upper-right corner) of all the objects. A box-sum query is then reduced to 2 d dominance-sum queries, one for each corner of the query box. As an example, consider <ref type="figure">figure 2</ref> in the 2-dimensional space. <ref type="figure">Figure 2a</ref> shows a query box (with thick border) and two objects intersecting with it. The box-sum query computes the total value of these two objects. In order for a box b to intersect the query box q, the lower left corner of b has to be dominated by the upper right corner of q. <ref type="figure">Figure 2b</ref> shows the candidate boxes. Some candidates are false hits since they are either completely to the left, or completely under, q. The false hits under q correspond to those boxes whose upper left corners are dominated by the lower right corner of q ( <ref type="figure">figure 2c</ref>). The false hits to the left of q correspond to those whose lower right corners are dominated by the upper left corner of q ( <ref type="figure">figure 2d</ref>). Note that after these false hits are subtracted from the query result, the boxes whose upper right corners are dominated by the lower left corner of q (figure 2e) are subtracted twice. So the total value of them must be added again.</p><formula xml:id="formula_6">Theorem 2. A d-dimensional box-sum query is reduced to 2 d dominance-sum queries.</formula><p>In order to prove theorem 2, we need to introduce some notations. In the rest, q denotes a query box, S the set of objects and o ∈ S corresponds to an object. We use (o.</p><formula xml:id="formula_7">l 1 , · · · , o.l d ) and (o.h 1 , · · · , o.h d )</formula><p>to represent the low point and the high point of o's rectangle, respectively. We use the same notation for q. Furthermore, for some dimension i, we define</p><formula xml:id="formula_8">A 0 i (o, q) ≡ o.li &lt; q.hi. That is, A 0 i (o, q)</formula><p>is the condition that the low point of object o is dominated by the high point of query box q in the i th dimension. Similarly, we de-</p><formula xml:id="formula_9">fine A 1 i (o, q) ≡ o.h i &lt; q.l i</formula><p>, which is the condition that the high point of object o is dominated by the low point of query box q in the i th dimension. Object o intersects query q if for every dimension i, the projections of o and q to dimension i intersect. Since the projection of a box to a dimension is an interval and two intervals i1 and i2 intersect if and only if i1.low &lt; i2.high and not(i1.high &lt; i2.low), we can define the box-sum query as:</p><formula xml:id="formula_10">boxsum(S, q) ≡ Sum{o.value|o ∈ S ∧ ∀i(A 0 i (o, q) ∧ ¬A 1 i (o, q))} (4) Lemma 1. boxsum(S, q) = ∀(s 1 ,··· ,s d ), s i ∈{0,1} (−1) d i=1 s i · Sum o.value|o ∈ S ∧ d i=1 A s i i (o, q)<label>(5)</label></formula><p>Discussion: Since each s i in equation 5 can be either 0 or 1, the set {s 1 , . . . , s d } has 2 d different choices of value assignments. For each choice, the inner summation of equation 5 corresponds to a dominance-sum query. For example, in the 2-dimensional space (figure 2), when (s 1 , s 2 ) = (1, 0), the inner summation is</p><formula xml:id="formula_11">Sum o.value|o ∈ S ∧ A 1 1 (o, q) ∧ A 0 2 (o, q) .</formula><p>The above summation computes the total value of objects that satisfy two conditions: (a) in dimension 1, the high point of the object is dominated by the low point of the query box; and (b) in dimension 2, the low point of the object is dominated by the high point of the query box. This is equivalent to the total value of objects whose lower right corner is dominated by the upper left corner of the query box ( <ref type="figure">figure 2d</ref>).</p><p>Thus, lemma 1 not only infers theorem 2, but also provides a way to compute a box-sum by combining 2 d dominancesums. To prove theorem 2, it remains to prove the lemma.</p><p>Proof of Lemma 1. For clarity, we omit the variables o, S, q from all formulae in the proof. Thus we can re-write equations 4 as:</p><formula xml:id="formula_12">boxsum ≡ Sum d i=1 A 0 i ∧ d i=1 ¬A 1 i</formula><p>and we need to prove that</p><formula xml:id="formula_13">boxsum = ∀(s 1 ,··· ,s d ), s i ∈{0,1} (−1) d i=1 s i · Sum d i=1 A s i i</formula><p>We introduce some functions:</p><formula xml:id="formula_14">B(k) ≡ k i=1 A 0 i , for 1 ≤ k ≤ d; true, for k = 0. C(k) ≡ k i=1 ¬A 1 i , for 1 ≤ k ≤ d; true, for k = 0. bs(k) ≡ ∀(s k ,··· ,s d ), s i ∈{0,1} (−1) d i=k s i · Sum d i=k A s i i ∧ B(k − 1) ∧ C(k − 1)</formula><p>Now we identify some properties:</p><p>• Property 1:</p><formula xml:id="formula_15">A 0 i ∧ A 1 i = A 1 i ;</formula><p>• Property 2:</p><formula xml:id="formula_16">B(k − 1) ∧ A 1 k = B(k) ∧ A 1 k ; • Property 3: Sum{X ∧ ¬Y } = Sum{X}− Sum{X ∧ Y }.</formula><p>To see the correctness of property 1, consider the meanings of A 0 i and A 1 i . If (in the i th dimension) the high point of o is dominated by the low point of q, then surely the low point of o is dominated by the high point of q. In other words, we have A 1 i → A 0 i and property 1 holds. We can infer property 2 from property 1, since</p><formula xml:id="formula_17">B(k) ∧ A 1 k = B(k − 1) ∧ A 0 k ∧ A 1 k = B(k − 1) ∧ A 1 k .</formula><p>Regarding property 3, note that given some condition X, Sum(X) means the sum of values of all objects satisfying X. To compute Sum(X ∧ ¬Y ), i.e. the value sum of all objects satisfying X but not Y , we can subtract from Sum(X) the value sum of all objects satisfying both conditions X and Y .</p><p>We note that bs(1) is equal to the right formula of equation 5. So to prove lemma 1, we will proceed by proving that bs(d) = boxsum and that ∀k ∈ <ref type="bibr">[1..d − 1]</ref>, bs(k + 1) = bs(k). These will infer that boxsum = bs(1), or equation 5.</p><p>First, we have:</p><formula xml:id="formula_18">bs(d) = s d ∈{0,1} (−1) s d · Sum{A s d d ∧ B(d − 1) ∧ C(d − 1)} = Sum A 0 d ∧ B(d − 1) ∧ C(d − 1) − Sum A 1 d ∧ B(d − 1) ∧ C(d − 1) = Sum {B(d) ∧ C(d − 1)} − Sum A 1 d ∧ B(d) ∧ C(d − 1) (property 2) = Sum B(d) ∧ C(d − 1) ∧ ¬A 1 d (property 3) = Sum {B(d) ∧ C(d)} = boxsum Now we prove that ∀k ∈ [1..d − 1], bs(k + 1) = bs(k). By definition, bs(k + 1) = ∀(s k+1 ,··· ,s d ), s i ∈{0,1} (−1) d i=k+1 s i · Sum d i=k+1 A s i i ∧ B(k) ∧ C(k)</formula><p>The inner summation of the above equation is equal to</p><formula xml:id="formula_19">Sum d i=k+1 A s i i ∧ B(k) ∧ C(k − 1) ∧ ¬A 1 k = Sum d i=k+1 A s i i ∧ B(k) ∧ C(k − 1) − Sum d i=k+1 A s i i ∧ B(k) ∧ C(k − 1) ∧ A 1 k = Sum d i=k+1 A s i i ∧ A 0 k ∧ B(k − 1) ∧ C(k − 1) − Sum d i=k+1 A s i i ∧ A 1 k ∧ B(k − 1) ∧ C(k − 1) = s k ∈{0,1} (−1) s k · d i=k A s i i ∧ B(k − 1) ∧ C(k − 1)</formula><p>Thus it is easy to see that bs(k + 1) = bs(k).</p><p>To summarize, we have shown that boxsum = bs(d) = bs(1) = the right formula of equation 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">THE FUNCTIONAL BOX-SUM PROBLEM AND ITS REDUCTION</head><p>In various applications, we are interested in a different kind of box-sum query which we will refer as functional box-sum. In general, the value associated with an object may be a function. While <ref type="figure" target="#fig_2">figure 3a</ref> contains objects with constant functions, an example of object with non-constant function appears in <ref type="figure" target="#fig_2">figure 3b</ref>. Here the pesticide was not sprayed evenly over the whole field. At the left border of the field (x = 5), it was sprayed 3 grams per square yard. The spray amount increases gradually as x becomes larger until the right border (x = 20) where it was sprayed 18 grams per square yard. We can capture this fact by assigning a value to this object that is a function of x (in particular, f (x, y) = x − 2). For the query box in <ref type="figure" target="#fig_2">figure 3b</ref>, the Definition. The functional box-sum problem is defined as: "given a set of objects, each having a box and a value function, and a query box q, compute the total value of all objects that intersect q, where the value contributed by an object r is the integral of the value function of r over the intersection between r and q".</p><p>Theorem 3. For value functions that are polynomials of constant degree, the d-dimensional functional box-sum query is reduced to 2 d dominance-sum queries. To solve the OIFBS problem, we need to devise an index that logically stores a value for every position in the space. This value is the OIFBS at this position. Suppose such an index exists. Let's consider the effect of inserting a new object into this index. <ref type="figure">Figure 5a</ref> illustrates an object with box p1, p4 and value function f (x, y). The effect of inserting this object in the hypothetical index contains four parts:</p><formula xml:id="formula_20">¡ ¡ ¡ ¡ ¢ ¢ £ £ ¤ ¤ ¥ ¥ ¦ ¦ § § = + - - (b) (c) (d) (e) (a)</formula><formula xml:id="formula_21">• ∀ point (x, y) in box p 1 , p 4 , add x x 1 y y 1 f (x , y )dy dx ; • ∀ point (x, y) in box p 2 , p 5 , add x 2 x 1 y y 1 f (x , y )dy dx ; • ∀ point (x, y) in box p 3 , p 6 , add x x 1 y 2 y 1 f (x , y )dy dx ;</formula><p>• ∀ point (x, y) in box p4, pmax, add</p><formula xml:id="formula_22">x 2 x 1 y 2 y 1 f (x , y )dy dx .</formula><p>The combined effect is equivalent to:</p><formula xml:id="formula_23">• ∀ point (x, y) in box b 1 = p 1 , p max , add v 1 (x, y) = x x 1 y y 1 f (x , y )dy dx ; • ∀ point (x, y) in box b2 = p2, pmax, add v2(x, y) = x 2 x 1 y y 1 f (x , y )dy dx − x x 1 y y 1 f (x , y )dy dx ; • ∀ point (x, y) in box b 3 = p 3 , p max , add v 3 (x, y) = x x 1 y 2 y 1 f (x , y )dy dx − x x 1 y y 1 f (x , y )dy dx ; • ∀ point (x, y) in box b 4 = p 4 , p max , add v 4 (x, y) = x x 1 y y 1 f (x , y )dy dx + x 2 x 1 y 2 y 1 f (x , y )dy dx − x x 1 y 2 y 1 f (x , y )dy dx − x 2 x 1 y y 1 f (x , y )dy dx .</formula><p>Let f (x, y) be a polynomial of degree at most k. I.e. there exists a constant t s.t.</p><formula xml:id="formula_24">f (x, y) = t i=1 f i (x, y), where f i (x, y) = aix p i y q i , pi ≥ 0, qi ≥ 0, and pi + qi ≤ k. It easily follows that each v j (x, y) (j ∈ [1..4]</formula><p>) is a polynomial of degree at most (k + d). For instance,</p><formula xml:id="formula_25">v 1 (x, y) = x x 1 y y 1 t i=1 a i x p i y q i dy dx = t i=1 a i (p i + 1)(q i + 1) (x p i +1 − x p i +1 1 )(y q i +1 − y q i +1 1 )</formula><p>whose degree is max{p i +1+q i +1}≤ k+2. Hence each value function can be represented in constant space as a tuple storing its coefficients. At worst there are O(k d ) coefficients, where k and d are constants (in practice this is much less since not all coefficients are present).</p><p>Adding value v j (x, y) to each point in b j is prohibitively expensive. Instead observe that all bj's share the same high point pmax. Consequently, an update regarding bj affects all those OIFBS queries specified at points which dominate p j . This implies that each such update can be implemented as a single point insertion of a value function: we actually insert the point pj together with the tuple of coefficients of the function vj(x, y). For instance, the first update regarding b1 corresponds to: "insert at point p 1 the tuple representing the value function v 1 (x, y)". An OIFBS query specified at point p is then computed by (1) finding the aggregated function over all points dominated by p, and, (2) evaluating the function at p. The value functions are stored as coefficient tuples and the value evaluation is straightforward. As a result, an OIFBS query is reduced to computing a dominance-sum, with the difference that now we store and manipulate value functions instead of single values.</p><p>As an example, consider figure 5b. To compute the OIFBS at point q 1 , we find the object corner points dominated by q1 (in this case only c1) and evaluate the value function at q1.  <ref type="figure">figure 5b</ref> is thus computed as 296 − 60 = 236, which is the same as our observation in <ref type="figure" target="#fig_2">figure 3a</ref> at the beginning of this section.</p><p>Discussion: In general, we could use functions that (i) are easily aggregated using + and − operators, (ii) can be represented in constant space, and, (iii) can be easily evaluated. While both the simple box-sum and the functional box-sum are reduced to 2 d dominance-sum queries, there are various differences between the two approaches: (i) in the functional dominance-sum problem we maintain tuples instead of single values; (ii) given an index structure that computes dominance-sums the simple box-sum problem needs to maintain 2 d such indices, while the functional box-sum only one; (iii) in the simple box-sum problem inserting a new object corresponds to one update on each of the 2 d indices, while it causes 2 d updates to the single index of the functional box-sum problem.</p><p>There is an inherent distinction between the simple and the functional box-sum problems. In the functional problem, the value (function) of an object contributes to the query proportional to the intersection size between the object and the query box. If a specialized index is used to solve the functional box-sum problem, this index cannot be used for computing simple box-sums. Conceptually, such index maintains the answer to every possible query box as a weighted sum of the objects that intersect it. The weights correspond to the object intersection sizes with the query box. However, such index does not maintain the actual objects. As a result these weights cannot be de-allocated to their respective objects, making it impossible to answer simple box-sum queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">THE ECDF-B-TREE</head><p>As with box-sums, a dominance-sum query at p can be reduced to range-reporting (i.e. "find all the points in the range from p min to p"); this again is inefficient when many points fall in the query range. <ref type="bibr" target="#b4">[5]</ref> proposed the ECDF-tree, a main-memory, static data structure to solve this problem.</p><p>The ECDF-tree is a multi-level data structure, where each level corresponds to a different dimension. At the first level (also called main branch), the d-dimensional ECDF-tree is a full binary search tree whose leaves store the data points, ordered by their position in the first dimension. Each internal node of this binary search tree stores a border (defined next) for all the points in the left sub-tree. The border is itself a (d-1)-dimensional ECDF-tree; here points are ordered by their positions in the second dimension. The collection of all these border trees forms the second level of the structure. Their respective borders are (d-2)-dimensional ECDFtrees (using the third dimension and so on). To answer a dominance-sum query for point p = (p 1 , . . . , p d ), the search starts with the root of the first level ECDF-tree. If p1 is in the left sub-tree, the search continues recursively on the left sub-tree. Otherwise, two queries are performed, one on the right sub-tree and the other on the border; the respective results are then added together.</p><p>To extend the ECDF-tree to handle dynamic updates and disk storage capabilities, we extend the binary search tree at each level into a B+-tree. We call the extended structure the ECDF-B-tree. Due to space limitations we only describe the main ideas of the ECDF-B-tree. While each internal node of the ECDF-tree has two children, an internal node of the ECDF-B-tree has between B/2 and B children. Children are divided by borders. Depending on the meaning of the borders, we have two different versions of the ECDF-B-tree. One version has more efficient update (the ECDF-B u -tree), while the other has better query time (the ECDF-B q -tree). The two approaches are illustrated in <ref type="figure" target="#fig_5">figure 6</ref>, which shows an internal node. Consider a node with children e 1 , e 2 , ...., e m and corresponding borders t 1 , t 2 , ..., t m−1 . In the ECDF-B utree each border t i maintains a structure that contains all points in subtree(ei). In contrast, the structure of a border ti in the ECDF-B q -tree contains the points from all subtrees to its left: subtree(e 1 ), ..., subtree(e i ). To insert a new point into the ECDF-B u -tree we start from the root node and follow the child e i that contains this point. This insertion also affects a single border in the root node, border ti ( <ref type="figure" target="#fig_5">figure  6a</ref>). However, a query needs to examine the subtree that contains the query point q and all borders to the left of q ( <ref type="figure" target="#fig_5">figure 6b</ref>). An insertion in the ECDF-B q -tree, on the other hand, affects multiple borders (figure 6c) while a query examines only one border (figure 6d) besides the subtree. The above differences affect the I/O performance.</p><p>The ECDF-B-trees can be bulk-loaded. The points are sorted and bulk-loaded into a B+-tree based on one dimension. Since the process of bulk-loading a B+-tree changes only the rightmost path, as each node not on the rightmost path is generated, the border information of the node can be calculated (by bulk-loading a lower-rank ECDF-B-tree, etc. ECDF-B u -tree ECDF-B q -tree <ref type="table">Table 1</ref>: ECDF-B-tree Complexity.</p><formula xml:id="formula_26">Space O n B log d−1 B n O nB d−2 log d−1 B n Bulk-loading O n B log d B n O nB d−2 log d B n Query O B d−1 log d B n O log d B n Update (amortized) O log d B n O B d−1 log d B n</formula><p>Proof. We use S u , L u , Q u and U u to represent the space, bulk-loading, query and update complexity of the ECDF-B u -tree, respectively. Similarly, we use Sq, Lq, Qq and Uq to represent the complexity of the ECDF-B q -tree. </p><formula xml:id="formula_27">Su(n, d) = n B + log B n−1 i=1 B i Su( n B i , d − 1)</formula><p>The proof uses induction. For d = 1, the space complexity holds, since it is basically a B+-tree. Suppose the complexity is correct for (d-1)-dimensional trees. Then for the d-dimensional case,</p><formula xml:id="formula_28">S u (n, d) = n B + log B n−1 i=1 B i · O n B i /B · log d−2 B n B i = O n B log d−1 B n</formula><p>Similarly, we have: So the space and bulk-loading costs of the ECDF-B q -tree are:</p><formula xml:id="formula_29">Lu(n, d) = n B log B n + log B n−1 i=1 B i Lu( n B i , d<label>−</label></formula><formula xml:id="formula_30">Sq(n, d) = n B + log B n−1 i=1 B i−1 B t=1</formula><p>Sq nt</p><formula xml:id="formula_31">B i , d − 1 L q (n, d) = n B log B n + log B n−1 i=1 B i−1 B t=1 L q nt B i , d − 1</formula><p>By induction we can prove that</p><formula xml:id="formula_32">S q = O nB d−2 log d−1 B n and L q = O nB d−2 log d B n .</formula><p>Query complexity: For both ECDF-B-trees, the query examines a single path in the main branch of the tree, which takes O(log B n) I/Os. The major concern is the complexity of querying the borders. For the ECDF-B u -tree, at every level i, there are O(B) borders to query, each of which is a (d-1)-dimensional tree with O(n/B i ) points. So we have:</p><formula xml:id="formula_33">Qu(n, d) = log B n + log B n−1 i=1 BQu n B i , d − 1 = O B d−1 log d B n</formula><p>For the ECDF-B q -tree, at every level i, there is only one border that needs to query. At level i the border is a (d-1)-dimensional tree with O(n/B i + 1) points. Thus,</p><formula xml:id="formula_34">Qq(n, d) = log B n + log B n−1 i=1</formula><p>Qq n</p><formula xml:id="formula_35">B i−1 , d − 1 = O log d B n</formula><p>Update complexity: At every level i of a ECDF-B u -tree, if the node does not split, only 1 border needs to be updated.</p><p>The border is a (d-1)-dimensional tree with O(n/B i ) points. So the update complexity is</p><formula xml:id="formula_36">Uu(n, d) = log B n + log B n−1 i=1 Uu n B i , d − 1 = O log d B n</formula><p>Note that the above complexity is acquired by assuming that nodes do not split. If a level i node splits, O(B) borders need to be generated, which is expensive. To bulk-load these borders, it takes O(n 0 log d B n 0 ) I/Os, where n 0 = n/B i . However, in the B+-tree, if a newly generated node r roots a sub-tree of n0 leaf records, on average n0 insertions need to go through r before it splits again. So the cost of bulkloading the borders due to a split can be amortized to the n 0 insertions. The overall amortized update complexity remains the same.</p><p>Similarly, assuming no splits, an update operation in the ECDF-B q -tree affects B borders at every level i. Out of the B borders, the t th is a (d-1)-dimensional tree which indexes O(nt/B i ) points. So the cost of an update is</p><formula xml:id="formula_37">U q (n, d) = log B n + log B n−1 i=1 B t=1 U q nt B i , d − 1 = O B d−1 log d B n</formula><p>The splits can also be amortized similar to the previous case.</p><p>Clearly, the ECDF-B q -tree optimizes the query time at the expense of more space and update time. The BA-tree presented next attempts to combine the query performance of the ECDF-B q -tree with the update/space complexity of the ECDF-B u -tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">THE BA-TREE</head><p>While an ECDF-B-tree is based on the B+-tree the BA-tree is based on the k-d-B-tree <ref type="bibr" target="#b27">[28]</ref>. <ref type="figure" target="#fig_9">Figure 7</ref> shows an index node of a BA-tree in the 2-dimensional space. As in the k-d-Btree, each index record is associated with a box and a child pointer. The boxes of records in a node do not intersect and their union creates the box of the node. Since a node is implemented as a page, we use these terms interchangeably. Each record r points to a sub-tree containing points which are contained in r.box.</p><p>As in the ECDF-B-tree, we augment each index record with some border information. The goal is that a dominance-sum query can be answered by following a single sub-tree (in the main branch). Suppose in <ref type="figure" target="#fig_9">figure 7a</ref>, there is a query point contained in the box of record F . The points that may affect the dominance-sum query of a query point in To compute the dominance-sum for points in the first group, a recursive traversal of subtree(F ) is performed. For points in the second group, we keep in record F a single value called subtotal, which is the total value of all these points. For computing the dominance-sum in the third group, we can keep an x-border in F which contains the x positions and values of all these points. This dominance-sum is then reduced to a 1-dimensional dominance-sum query for the border. It is then sufficient to maintain these x positions in a 1-dimensional BA-tree. Similarly, for the points in the fourth group, we keep a y-border which is a 1-dimensional BA-tree for the y positions of the group's points. To summarize, the 2-dimensional BA-tree is a k-d-B-tree where each index record is augmented with a single value subtotal and two 1-dimensional BA-trees called x-border and y-border, respectively. The computation for a dominancesum query at point p starts at the root page R. If R is an index node, it locates the record r in R whose box contains p. A 1-dimensional dominance-sum query is performed on the x-border of r regarding p.x. A 1-dimensional dominancesum query is performed on the y-border of r regarding p.y. A 2-dimensional dominance-sum query is performed recursively on page(r.child). The final query result is the sum of these three query results plus r.subtotal.</p><p>The insertion of a point p with value v starts at the root R.</p><p>For each record r where r.lowpoint dominates p, v is added to r.subtotal. For each r where p is below the x-border of r, position p.x and value v are added to the x-border. For each record r where p is to the left of the y-border of r, position p.y and value v are added to the y-border. Finally, for the record r whose box contains p, p and v are inserted in the subtree(r.child). When the insertion reaches a leaf page L, a leaf record that contains point p and value v is stored in L. Since the BA-tree aims at storing only the aggregate information, not the objects themselves, there are chances where the points inserted are not actually stored in the index, thus saving storage space. For instance, if a point to be inserted falls on some border of an index record, there is no need to insert the point into the sub-tree at all. Instead, we simply keep it in the border that it falls on. If the point to be inserted falls on the low point of an internal node, there is even no need to inserted it in the border; we simply update the subtotal value of the record.  We next discuss how the insertion algorithm handles overflows. We differentiate between two cases, whether the overflow occurs in a leaf or an index page. <ref type="figure" target="#fig_11">Figure 8a</ref> shows a leaf page pointed by record F that overflows. The pages is split into two pages F t and F b (figure 8b). Since this split is a y-split, the y-border of record F is split in two, one stored at Ft and the other at F b . The x-border of the bottom record F b remains the same as that of the previous record F . The x-border of the top record F t , however, is composed of the x-border of F plus the points in page(F b ). <ref type="figure" target="#fig_11">Figure 8c</ref> considers the case when an index page overflows. The splitting result is shown in <ref type="figure" target="#fig_11">figure 8d</ref>. Again, the y-border of F is split into two, one for each of the new records. Different from the leaf-split case, however, the x-borders of both F t and F b are the same as that of F . To verify the correctness of the split, consider a dominance-sum query where the query point p is contained in F t .box. Obviously, the points in subtree(F b ) should contribute to the query result. However, the x-border of F t was copied from F and thus does not include any point in the F b region before the split. This is not a problem since the query will recursively examine the index page pointed to by F t , where the border information contains the points in the F b region.</p><p>There are various differences between the BA-tree and the ECDF-B-trees. Since the k-d-B-tree is unbalanced, the BAtree is unbalanced, too. Thus the worst case update and query performance for the BA-tree is linear. However, the The BA-tree extends to higher dimensions in a straightforward manner: a d-dimensional BA-tree is a k-d-B-tree where each index record is augmented with one subtotal value and d borders, each of which is a (d-1)-dimensional BA-tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">PERFORMANCE</head><p>To compare the performance of the various indices we used a dataset with 6 million randomly generated spatial objects in a 2-dimensional space. Each side of an object MBR is on average 1/10,000 of the total dimension size. For solving simple box-sum aggregations, note that we need four dominance-sum indices, we implemented the following: (a) a structure of four ECDF-B u -trees (this approach is denoted as ECDF u ), (b) four ECDF-B q -trees (ECDF q ), and (c) four BA-trees (BAT ). We also implemented a plain R*-tree and the aR-tree, which is the R*-tree augmented with aggregate values in index records (denoted as aR). Our initial experiments showed that the BA-tree approach has a query time over 200 times faster than the plain R*-tree approach. So we omit the R*-tree performance and we compare our approaches only with the optimized aR-tree approach. For all indices, we used LRU buffering. For the aR-tree, besides using a LRU buffer, we also used a path buffer which buffers the most recently accessed path of node. We used 8KB page size and 10MB memory buffer. <ref type="figure">Figure 9a</ref> compares the index sizes. The aR-tree is the smallest index. This is to be expected, since the aR-tree has linear space while the BA-tree and the ECDF-B u -tree have a logarithmic space overhead. The ECDF-B q -tree occupies the most space. This is because each update changes too many borders. The BA-tree and the ECDF-B u -tree have comparable storage requirements, which are much less than the ECDF-B q -tree. <ref type="figure">Figure 9b</ref> compares the query performance. Each query reports the total number of I/Os spent over 1000 randomly generated query boxes with fixed shape and size.</p><p>The query box size (QBS) is described by the percentage of the query area in the whole space. The aR-tree does not perform well especially when the QBS is large. This is because its worst case performance is linear to the number of objects in the query box. The ECDF-B q -tree approach performs the best, with the BA-tree being very close. As expected, the ECDF-B u -tree has much larger query time since at each index page too many borders need to be checked. Clearly, with the addition of the small space overhead over the aR-tree, the BA-tree approach showed the most robust performance. Moreover, its performance was independent of the query size characteristics (which drastically affects the aR-tree).</p><p>We also compared the above indexing schemes for functional box-sum queries. Since the BA-tree was more robust than the ECDF-B-trees we report the comparison between the BA-and aR-trees. <ref type="figure">Figure 9c</ref> depicts the total execution time of 1000 randomly generated queries with QBS being 1% of the space. The execution time is the sum of CPU time (measured by the getrusage system call) and the I/O time (measured by the number of I/Os multiplied by 10ms). To observe the impact of different-degree value functions, we used two variations of the original dataset. In the first variation the value of each object was treated as a constant function over the object, i.e., a polynomial of degree zero. In the second variation, objects were assigned polynomial functions of degree two. The indices for the degree-zero (degreetwo) case use subscript d0 (respectively d2). Clearly, as the degree increases, the query performance worsens since the index becomes larger. Nevertheless, the BA-tree was still drastically faster than the aR-tree. The relative storage requirements (not shown) for the BA-tree and the aR-tree were similar to figure 9a.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>Computational Geometry. A range-reporting query reports all objects in the query box <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b1">2]</ref>. <ref type="bibr" target="#b4">[5]</ref> proposed the range-tree for the range-reporting query. The range-tree is very similar to the ECDF-tree. The best internal memory solution for the 2-dimensional range-counting problem is given in <ref type="bibr" target="#b8">[9]</ref>. For the static case (i.e. all n points are known in advance), the solution uses O(n) space and has O(log 2 n) query time. In particular, a range-tree is compressed using the functional approach technique. To extend the solution to the d-dimensional case, the multi-dimensional divideand-conquer technique of <ref type="bibr" target="#b4">[5]</ref> can be used which leads to O(n log d−1 2 n) space and O(log d−1 2 n) query time. However, note that the solution of <ref type="bibr" target="#b8">[9]</ref> applies only to range-counting and not to range-sum. Furthermore, the data structure is rather complex to implement in practice.</p><p>Note that the ECDF-tree and the range-tree are both static and internal-memory structures. To dynamize a static data structure some standard techniques can be used <ref type="bibr" target="#b11">[12]</ref>. For example, the global rebuilding <ref type="bibr" target="#b23">[24]</ref> or the logarithmic method <ref type="bibr" target="#b7">[8]</ref>. To externalize an internal-memory data structure, a widely used method is to augment it with block-access capabilities <ref type="bibr" target="#b33">[34]</ref>.</p><p>Range-Sum for Data Cubes and Point Data. The data cube range-sum problem addresses the following query: given a d-dimensional array A and a query range q, find the sum of values of all cells in A in range q. <ref type="bibr" target="#b17">[18]</ref> proposed to maintain a prefix-sum array P which is of the same size as A. The range-sum query is then transformed into 2 d array look-ups in P and their result is combined through additions and subtractions. However this approach uses O(k) update cost, where k is the number of array cells.</p><p>The dynamic data cube introduced by <ref type="bibr" target="#b13">[14]</ref> reduces the update cost to O(log d k) while it increases the query time from O(1) to O(log d k). The idea is to compute each prefix-sum needed on-the-fly. The array A is partitioned into sub-arrays which are then organized into a tree structure. To perform an update or to answer a prefix-sum query, the dynamic data cube examines a single path from the root to a leaf. Like the ECDF-tree, the dynamic data cube is a multi-level structure: within each tree node, a (d-1)-dimensional dynamic data cube is kept to speed-up the query. Recently, <ref type="bibr" target="#b9">[10]</ref> proposed the dynamic update cube which further improves the update cost to O(log ku), where ku is the number of changed array cells.</p><p>[33] proposed the aP-tree which is a specialized index for efficiently aggregating planar points. <ref type="bibr" target="#b31">[32]</ref> addresses the problem to evaluate multiple range-sums progressively.</p><p>Temporal Aggregation and Objects with Extent. The instantaneous temporal aggregation query finds the aggregate value over all records whose intervals contains a given time instant. <ref type="bibr" target="#b19">[20]</ref> provided the aggregation-tree which incrementally computes temporal aggregates. <ref type="bibr" target="#b16">[17]</ref> introduced parallel extensions, while <ref type="bibr" target="#b22">[23]</ref> presented an improvement by utilizing a red-black balanced tree. The cumulative temporal aggregation query finds the aggregate value over all records whose intervals intersect a given interval. Since a time interval can be regarded as a 1-dimensional box, the cumulative temporal aggregation query for SUM is an 1-dimensional box-sum query. <ref type="bibr" target="#b36">[37]</ref> developed efficient structures to incrementally maintain temporal aggregates. Among them, the JSB-tree computes cumulative temporal aggregates using O(log B N ) update and query time, where B is the page capacity and N the total number of updates. Later, <ref type="bibr" target="#b38">[39]</ref> introduced the MVSB-tree for computing cumulative temporal aggregates with key-range predicates. This problem is a special case of the 2-dimensional box-sum query. The query time is O(log B N ) and the update time is O(log B K), where K is the number of different keys ever inserted in the index. Recently, <ref type="bibr" target="#b39">[40]</ref> extended <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b38">39]</ref> to pre-computes temporal aggregates in a data-streaming environment. As historical data accumulate, the structure systematically aggregates older data at coarser time granularity.</p><p>To aggregate objects with extent, a straightforward way is to index the objects using a spatial access method and an aggregation query is answered by performing a range search. <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b33">34]</ref> provide good surveys on spatial access methods. Specifically, <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b24">25]</ref> proposed to augment the R*-tree by storing aggregate information at internal nodes to improve aggregation query performance. Recently, work that examines query estimation for objects with extent has appeared in <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b29">30]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSIONS</head><p>We considered the problem of computing box-sum queries over objects with extent. Such objects appear in spatial and spatio-temporal applications. We examined two variations, the simple box-sum and the novel functional boxsum problems. In the latter, object values are described by functions and an object's participation in the aggregation result is the function integral over the object's intersection with the query box. To the best of our knowledge this is the first work addressing functional aggregates. Novel reduction techniques were presented to reduce each of these problems to dominance-sum queries. We proposed a treestructured, disk-based, dynamically-updated index, the BAtree, that can efficiently answer dominance-sums. We also presented two dynamic, disk-based extensions of computational geometry solutions (the ECDF-B-trees). Experimental results with spatial datasets showed that the BA-tree has the most robust performance. We also compared the BAtree against the aR-tree, an optimized R-tree whose nodes are augmented with aggregation information. At the expense of some limited extra space, the BA-tree can offer an order of magnitude faster query time. Moreover, the BAtree query performance is independent of the query shape or size.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Existing technique reduces a box-sum query into eight dominance-sum queries.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Figure 3a shows three box objects (with values 3, 4 and 6) and a query. The result of a simple box-sum query in this case is 7, since there are two objects intersecting the query box with values 3 and 4. Consider another scenario where the value associated with each object designates the pesticide volume per square yard while the query asks "what is the total volume sprayed in the query area". In this case, the query result is 4 * 50 + 3 * 12 = 236. Here 50 and 12 are the areas of the intersection between the query box and the two objects, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The functional box-sum problem.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :Figure 5 :</head><label>45</label><figDesc>Figure 4: A 2-dimensional functional box-sum query is reduced to four OIFBS queries.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Here, c1 = (2, 10) is one of the corner points of the object with value 4. The tuple that has been in- serted at c 1 is: 4, −40, −8, 80, since its value function is: x 2 y 10 4dy dx = 4xy − 40x − 8y + 80. Evaluating this function at q1 = (5, 15) yields: 4 * 5 * 15 − 40 * 5 − 8 * 15 + 80 = 60. Similarly, query point q2 = (20, 15) dom- inates four corner points: c 1 , c 2 , c 3 , c 4 . The tuples asso- ciated at c 2 , c 3 , c 4 are −4, 40, 60, −600, 3, −12, −54, 216 and −3, 30, 54, −540, respectively. The aggregate of all four tuples is 0, 18, 52, −844 and the result of an OIFBS at q 2 is 18 * 20 + 52 * 15 − 844 = 296. Note that the OIFBS of the other two corners of the query box are both 0, since they do not dominate any object corner point. The func- tional box-sum of the query box shown in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Differences between the two ECDF-Btrees.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Space and bulk-loading complexity: The main branch of any of the ECDF-B-trees occupies O (n/B) space. The space of the borders dominates the overall space. The ECDF- B u -tree at level 1 (the root level) has O(B) borders, each of which roots a (d-1)-dimensional tree containing n/B points. In general, at level i, there are O(B i ) borders, each of which is a (d-1)-dimensional tree containing O(n/B i ) points. Thus we have:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>1) and by induction, we can prove that Lu = O n B log d B n . As for the ECDF-B q -tree, at level 1, there is 1 node which has O(B) borders. The t th border is a (d-1)-dimensional tree with O(nt/B) points. In general, at level i, there are B i−1 nodes, each of which has O(B) borders. For each node, the t th border is a (d-1)-dimensional tree with O(nt/B i ) points.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>F.box are those dominated by the upper-right point of F.box. Such points belong in four groups: (1) the points contained in F.box; (2) the points dominated by the low point of F (in the shadowed region of figure 7a); (3) the points below the lower edge of F.box (figure 7b); and (4) the points to the left of the left edge of F.box (figure 7c).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: The BA-tree is a k-d-B-tree with augmented border information.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>−borders of Ft and Fb are the same (d) it is split in two;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Split in the BA-tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>(</head><label></label><figDesc>Figure 9: Performance comparison.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head></head><label></label><figDesc>). An implementation issue is that a border may contain only a few points and thus it is wasteful to keep a separate tree for this border (which costs one I/O to retrieve). To avoid this, we can use a single disk page to keep multiple borders, preferably the borders in the same index page.</figDesc><table>Theorem 4. The space, bulk-loading, query and update cost 
of the two ECDF-B-trees are given in table 1. Here n is the 
number of indexed points, B is the page capacity in number 
of records, and d is the number of dimensions. 

</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank A. Markowetz for many helpful discussions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On the Computation of Multidimensional Aggregates</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Deshpande</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Naughton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sarawagi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of VLDB</title>
		<meeting>of VLDB</meeting>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Geometric Range Searching and Its Relatives</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Erickson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Discrete and Computational Geometry</title>
		<editor>B. Chazelle, E. Goodman and R.</editor>
		<imprint>
			<publisher>American Mathematical Society</publisher>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
	<note>Providence</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Congressional Samples for Approximate Answering of GroupBy Queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Acharya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Poosala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGMOD</title>
		<meeting>of SIGMOD</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Selectivity Estimation in Spatial Databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Acharya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Poosala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ramaswamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGMOD</title>
		<meeting>of SIGMOD</meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Multidimensional Divide-and-Conquer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Bentley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1980" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Van Kreveld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Overmars</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Schwarzkopf</surname></persName>
		</author>
		<idno>3-540-61270-X</idno>
		<title level="m">Computational Geometry: Algorithms and Applications</title>
		<meeting><address><addrLine>Berlin Heidelberg, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The R* tree: An Efficient and Robust Access Method for Points and Rectangles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Beckmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kriegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Seeger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGMOD</title>
		<meeting>of SIGMOD</meeting>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Decomposable Searching Problems I: Static-to-Dynamic Transformations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Bentley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">B</forename><surname>Saxe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Alg</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1980" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A Functional Approach to Data Structures and Its Use in Multidimensional Searching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chazelle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Dynamic Update Cube for Range-Sum Queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of VLDB</title>
		<meeting>of VLDB</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Hierarchical Cubes for Range-Sum Queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">E</forename><surname>Ioannidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of VLDB</title>
		<meeting>of VLDB</meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Dynamic Algorithms in Computational Geometry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the IEEE</title>
		<editor>G. Toussaint</editor>
		<meeting>of the IEEE</meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="volume">80</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On the Equivalence of Some Rectangle Problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Edelsbrunner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Overmars</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The Dynamic Data Cube</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Geffner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">El</forename><surname>Abbadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of EDBT</title>
		<meeting>of EDBT</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Relative Prefix Sums: An Efficient Approach for Querying Dynamic OLAP Data Cubes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Geffner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">El</forename><surname>Abbadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICDE</title>
		<meeting>of ICDE</meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Multidimensional Access Methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Gaede</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Günther</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Parallel Algorithms for Computing Temporal Aggregates</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gendrano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rodrigue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Snodgrass</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICDE</title>
		<meeting>of ICDE</meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Range Queries in OLAP Data Cubes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Megiddo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Srikant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGMOD</title>
		<meeting>of SIGMOD</meeting>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Online Aggregation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGMOD</title>
		<meeting>of SIGMOD</meeting>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Computing Temporal Aggregates</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kline</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Snodgrass</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICDE</title>
		<meeting>of ICDE</meeting>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Progressive Approximate Aggregate Queries with a Multi-Resolution Tree Structure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Lazaridis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mehrotra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGMOD</title>
		<meeting>of SIGMOD</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Geometric Range Searching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Matou˘</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Scalable Algorithms for Large Temporal Aggregation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Lopez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Immanuel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICDE</title>
		<meeting>of ICDE</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The Design of Dynamic Data Structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Overmars</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">156</biblScope>
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Efficient OLAP Operations in Spatial Data Warehouses</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Papadias</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kalnis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Tao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SSTD</title>
		<meeting>of SSTD</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">pCube: Update-Efficient Online Aggregation with Progressive Feedback and Error Bounds</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Riedewald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">El</forename><surname>Abbadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SSDBM</title>
		<meeting>of SSDBM</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Cubetree: Organization of and Bulk Incremental Updates on the Data Cube</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Roussopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kotidis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Roussopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGMOD</title>
		<meeting>of SIGMOD</meeting>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The K-D-B Tree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Robinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGMOD</title>
		<meeting>of SIGMOD</meeting>
		<imprint>
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Exploring Spatial Datasets with Histograms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">El</forename><surname>Abbadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICDE</title>
		<meeting>of ICDE</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Selectivity Estimation for Spatial Joins with Geometric Selections</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">El</forename><surname>Abbadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of EDBT</title>
		<meeting>of EDBT</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Compressed Data Cubes for OLAP Aggregate Query Approximation on Continuous Dimensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shanmugasundaram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><forename type="middle">M</forename><surname>Fayyad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">S</forename><surname>Bradley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of KDD</title>
		<meeting>of KDD</meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">How to Evaluate Multiple Range-Sum Queries Progressively</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">R</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Shahabi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of PODS</title>
		<meeting>of PODS</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Aggregate Processing of Planar Points</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Papadias</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of EDBT</title>
		<meeting>of EDBT</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">External Memory Algorithms and Data Structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Approximate Computation of Multidimensional Aggregates of Sparse Data using Wavelets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vitter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGMOD</title>
		<meeting>of SIGMOD</meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Data Cube Approximation and Histograms via Wavelets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vitter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Iyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of CIKM</title>
		<meeting>of CIKM</meeting>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Incremental Computation and Maintenance of Temporal Aggregates</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICDE</title>
		<meeting>of ICDE</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">An ArrayBased Algorithm for Simultaneous Multidimensional Aggregates</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Deshpande</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Naughton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGMOD</title>
		<meeting>of SIGMOD</meeting>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Efficient Computation of Temporal Aggregates with Range Predicates</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Markowetz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">J</forename><surname>Tsotras</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gunopulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Seeger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of PODS</title>
		<meeting>of PODS</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Temporal Aggregation over Data Streams using Multiple Granularities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gunopulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">J</forename><surname>Tsotras</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Seeger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of EDBT</title>
		<meeting>of EDBT</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
