<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2019-03-26T16:52+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Interface Abstraction for Compositional Verification</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dilian</forename><surname>Gurov</surname></persName>
							<email>dilian@imit.kth.se</email>
							<affiliation key="aff0">
								<orgName type="institution">Royal Institute of Technology Kista</orgName>
								<address>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marieke</forename><surname>Huisman</surname></persName>
							<email>marieke.huisman@inria.fr</email>
							<affiliation key="aff1">
								<orgName type="institution">INRIA Sophia Antipolis Sophia Antipolis</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Interface Abstraction for Compositional Verification</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>To support dynamic loading of applications on portable devices, one needs compositional reasoning techniques to ensure that newly loaded applications cannot break the overall security of a device. In earlier work, we developed an algorithmic verification technique for control flow based safety properties of smart card applications, which allows global system properties to be inferred from the properties of the components. Application of the technique requires knowledge of the names of all methods implemented by these components. In a truly compositional setting, however , one only knows the public interface of the new applet and does not have access to any implementation details. To compositionally verify interface properties of applets, one therefore has to combine our verification technique with an abstraction which preserves the interface behaviour and reduces the set of implemented methods to the set of public methods. In this paper, we develop such an abstraction technique: we formally define the notion of interface behaviour, and propose an inlining transformation which we prove to preserve the interface properties expressible in our specification language. In addition, we show on a concrete case study how the reduction in the number of methods resulting from the interface abstraction drastically improves the performance of the computationally most expensive step of the compositional verification technique.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>With the emergence of small and mobile personal devices, such as smart cards and mobile phones, security has become a major concern. Typically, such personal devices contain privacy-sensitive information, e.g. financial data, health care information or electronic identities. Thus, for the widespread acceptance of the use of such devices, security of private information needs to be guaranteed.</p><p>Ideally, a smart device user should have the flexibility to install new applications (usually called applets) by need. To enable this, efficient verification techniques are needed for checking, prior to loading a new applet, whether it could break the security of the device. In earlier work, we developed a control-flow based compositional verification technique supporting post-issuance loading of applets, and showed its feasibility by means of an industrial case study <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b11">12]</ref>. The technique is based on a program model suggested by Jensen and others (see <ref type="bibr" target="#b7">[8]</ref>), and addresses safety properties of inter-procedural control flow. These are either structural, i.e. properties of the control-flow graph, or behavioural, i.e. applet interaction properties describing safe sequences of method invocations. In our set-up, global properties are structural or behavioural, while local properties are structural <ref type="bibr" target="#b0">1</ref> . Following our technique, compositional verification includes the following steps:</p><p>1. Specify a global property 񮽙 that should hold of the composed system.</p><p>2. For each applet 񮽙 񮽙 , specify a structural local property 񮽙 񮽙񮽙 .</p><p>3. Verify the correctness of the property decomposition (i.e., that the local properties guarantee the global one) Notice that the approach also allows a different scenario, where a new applet comes with its own local property, and step 3 is repeated (possibly on-device) to ensure that this local property is sufficient to ensure the security of the whole system.</p><p>The maximal model construction of step 3 is the centrepiece of the technique; the remaining verification tasks are standard model checking problems for finite state machines (step 4) resp. pushdown automata (step 3). It is inspired by a similar construction due to Grumberg and Long (see <ref type="bibr" target="#b5">[6]</ref>), forming the basis of an automatic modular verification technique. Our construction takes a structural property and a set of method names, and returns an applet which satisfies the property and implements the set of methods, and which in addition is maximal, in the sense that it simulates, both structurally and behaviourally, all other such applets. Furthermore, properties are preserved by simulation, and simulation is preserved by composition. So, by composing the respective maximal models and by checking that their composition satisfies the global property, one can show that any applet implementations satisfying the respective structural properties and implementing the respective sets of methods, when put together will satisfy the given global property. Notice, however, that the maximal model construction needs the names of all methods implemented by the given applets. The correctness of a property decomposition can thus only be established for applets with a known interface. This is a limitation of the proposed technique, since in a truly compositional setting one only knows the public interface of yet unavailable applets and one does not know their implementation details. Component properties can hence only be specified at the public level. Moreover, the lack of a mechanism for abstraction from private methods causes a blowup in the size of the formulae and hence of the maximal models used for the verifications, since these are parameterized on the interface considered. For example, in the industrial case study we considered an electronic purse applet which implemented 367 methods, of which only 4 were public, all others were private.</p><p>To be able to abstract from internal, private behaviour and apply our compositional verification method to interface properties of applets, one therefore needs an abstraction technique which (i) preserves the interface behaviour of applets, while (ii) reducing their set of methods to the set of public methods. The latter requirement comes from the maximal model construction. In this paper we propose an abstraction based on inlining of private methods. We define the notion of interface behaviour, and show the abstraction to be sound with respect to public interface properties: every property that holds for the interface behaviour of the inlined applet (which coincides with its behaviour since it has no private behaviour) also holds for the interface behaviour of the original applet. Moreover, in case the concrete implementation is last-call recursive (that is, recursive calls are not followed in the control flow graph by any other method calls 2 ), the abstraction technique is also complete with respect to public interface properties: if such a property does not hold of the inlined applet it does not hold of the origi-nal applet either. Completeness, however, does not hold in general, since the abstraction transformation can introduce new observable behaviours.</p><p>Using the abstraction techniques described in this paper, our improved scenario for secure post-issuance loading becomes:</p><p>1. Identify the set of public methods Å used for interaction between applets 񮽙 ½ 񮽙 Ò .</p><p>2. Specify a public global property 񮽙 over Å that should hold of the composed system.</p><p>3. For each applet 񮽙 񮽙 , specify a structural local property 񮽙 񮽙񮽙 which only mentions (public) methods in Å. In addition, we show that specifying structural properties for an inlined applet allows some natural properties to be expressed which are not expressible as properties of the original applet. For instance, reachability properties of the call graph can only be expressed as structural properties of the inlined applet, since there are no explicit inter-method call arcs in our program model. The present paper shows that all verifications can be done efficiently. In particular, Section 7 reconsiders the case study <ref type="bibr" target="#b6">[7]</ref>.</p><p>Related work The inlining procedure as described in this paper closely resembles standard inlining procedures used in compiler optimisations, see e.g. <ref type="bibr" target="#b8">[9]</ref>. However, compiler optimisations must be behaviourally equivalent, while our verification technique only requires that all existing behaviours are preserved by inlining. We believe that our approach for proving property preservation is applicable to such compiler optimisations as well.</p><p>The approach of combining property preserving abstraction with verification is standard, see e.g. <ref type="bibr" target="#b2">[3]</ref>. Usually, the goal of applying abstraction is to obtain a smaller or simply finite model for verification. In our case, the primary purpose of applying the inlining transformation is different: to reduce the set of methods to the set of public methods while preserving the interface behaviour.</p><p>Typically, the behaviour of programs with recursion is modeled as pushdown systems, as e.g. in <ref type="bibr" target="#b4">[5]</ref>. The notion of interface behaviour presented in the present paper also defines a pushdown system, and hence inlining is generally not needed for the verification of behavioural properties. In our approach, the need for inlining comes from the requirements of the maximal model construction.</p><p>Finally, we should mention the temporal logic of calls and returns CARET <ref type="bibr" target="#b0">[1]</ref>. This logic allows to specify properties in terms of method calls and returns. A special verification strategy is defined, that is able to jump over internal computations. Our approach is in a way the opposite: we compute an abstract model, and use standard verification techniques to verify properties -expressed in a standard temporal logic -on this abstract model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Overview of the paper</head><p>The remainder of this paper is organised as follows. Sections 2 and 3 introduce the necessary background, and in particular the logic and program model that we use. Section 4 defines the behaviour of an applet w.r.t. a set of public methods. Next, Section 5 presents the inlining algorithm that forms the basis of our abstraction technique, and proves that it is property preserving. Section 6 describes formally how the abstraction techniques are used for compositional reasoning. Finally, Section 7 revisits the industrial case study, and shows the practical impact of the abstraction techniques, while Section 8 draws more general conclusions on the applicability of our method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Simulation and Logic</head><p>First, we briefly recall some definitions and results that form the basis for our compositional verification method. For a full overview, the reader is referred to <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref>. We use a subset of the modal 񮽙-calculus <ref type="bibr" target="#b9">[10]</ref> as our specification language. We exploit that formulae in this subset can be characterised by simulation, and vice versa, therefore we call this logic simulation logic. Throughout, we fix a set of labels Ä, a set of atomic propositions 񮽙, and a set of propositional variables Î .  <ref type="bibr" target="#b10">[11]</ref>.</p><p>Finally, a standard transformation from weak to strong formulae exists <ref type="bibr" target="#b12">[13]</ref>. This transformation, which we denote AE, can be characterised as follows.</p><p>Proposition 2.5. Ë 񮽙 񮽙 Û 񮽙 iff Ë 񮽙 񮽙 AE´񮽙µ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Applet Structure and Behaviour</head><p>Our program model, inspired by <ref type="bibr" target="#b7">[8]</ref>, is control-flow based and thus over-approximates actual program behaviour. It defines two different views on applets: a structural and a behavioural view. Both views are instantiations of the general notions of model and specification, allowing the results presented above to be instantiated at both levels. Notice in particular that these instantiations yield a structural and a behavioural version of simulation and simulation logic. Again, we refer to <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref> for more detail.</p><p>Applet Structure Since we abstract away from all data, applet structure is defined as a collection of call graphs for the methods the applet implements. Further, since smart cards are our primary application domain, we only consider sequential methods 3 . Let Å񮽙ØØ be a countably infinite set of method names. A method specification is an instance of the general notion of specification. Next we define the notion of applet interface. For each applet, we distinguish an implementation interface, defining all methods provided and required by the applet, and a public interface, defining all methods that are visible to and used from other applets.  where ¯ denotes the empty sequence over Î .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.2. (Applet interface) An</head><formula xml:id="formula_0">Ñ ¾ Á · Ú 񮽙 Ñ Ú ¼ Ú 񮽙 񮽙 񮽙Ö´Ú 񮽙Ö´Ú µ 񮽙´Ú 񮽙´Ú ¼ µ (call) Ñ ½ Ñ ¾ ¾ Á · Ú ½ Ñ¾ Ñ½ Ú ¼ ½ Ú ½ 񮽙 񮽙 񮽙Ö Ú ¾ 񮽙 񮽙 Ñ ¾ Ú ¾ ¾ 񮽙´Ú 񮽙´Ú ½ µ Ñ½ ÐÐ Ñ¾´Ú Ñ¾´Ú ¾ Ú ¼ ½ ¡ 񮽙µ (return) Ñ ½ Ñ ¾ ¾ Á · Ú ¾ 񮽙 񮽙 Ñ ¾ 񮽙 Ö Ú ½ 񮽙 񮽙 Ñ ½ ´Ú ¾ Ú ½ ¡ 񮽙µ Ñ¾ ÖÖØ Ñ½´Ú Ñ½´Ú ½ µ</formula><p>Note that applet behaviour defines a pushdown automaton. We exploit this by using a model checker for PDAs to verify behavioural properties (see, e.g., <ref type="bibr" target="#b1">[2]</ref> for a survey of verification techniques for infinite process structures).</p><p>Also on the behavioural level, we instantiate the definitions of simulation 񮽙 񮽙 and satisfaction 񮽙 񮽙 񮽙 . Any two applets that are related by structural simulation, are also related by behavioural simulation (Theorem 3.9 in <ref type="bibr" target="#b11">[12]</ref>), but the converse is not true (since behavioural simulation only requires reachable states to be related </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Interface Behaviour</head><p>The next section defines an inlining algorithm that transforms a concrete applet implementation into an applet that contains only method calls to public methods. We want to prove that for any closed applet, every behaviour of the concrete applet is also a behaviour of the inlined applet. However, for this to hold, we have to abstract the concrete behaviour to the level of public methods. Therefore, we intro-duce the notion of interface behaviour of an applet w.r.t. a set of public methods Å. <ref type="bibr">First</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">The Inlining Transformation</head><p>Next we define an inlining algorithm « Å that, given a set of public methods Å, transforms an applet graph by inlining all private calls. Recursive calls to private methods are not inlined, but create loops in the resulting graph. We prove that the interface behaviour of the original applet 񮽙 is simulated by the behaviour of the inlined applet « Å ´񮽙µ, thus (by Theorem 2.3) all properties 񮽙 of the latter, i.e. « Å ´񮽙µ 񮽙 񮽙 񮽙 񮽙, are also properties of the former, i.e. 񮽙 񮽙 񮽙 Å 񮽙 񮽙. Moreover, we prove that if the applet is last-call recursive, the two behaviours are weak simulation equivalent -thus both applets satisfy exactly the same observable properties at the public interface level.</p><p>Notice that the inlining algorithm does not require the applet to be closed and treats all external methods as public.</p><p>The Inlining Algorithm. The algorithm is applied to each public method and (recursively) inlines all calls to private methods. Intuitively, constructing the transformed (or inlined) graph for a public method Ñ corresponds to executing the interface behaviour of Ñ, where method calls to public methods are skipped and recursion is replaced by iteration. The nodes of the inlined applet can thus be seen as states of the (interface) behaviour of the original applet, modulo an abstraction function which replaces recursion by iteration.</p><p>During the inlining, each edge that represents internal transfer or a call to a public method is left unchanged. Each edge that represents a call to a private method is replaced by two internal edges: one from the calling point to the entry point of the method; and another from the return point of the method to the destination of the calling edge 4 . The private method is inlined recursively. Each node is replaced by a sequence denoting the fragment of the call stack from the activation of the public method up to the current node (except for the case of a recursive call). Since we keep track of the pending call stack, we can recognise recursive calls to private methods. In that case, the appropriate initial fragment of the call stack is used to decide the exact new edges.</p><p>For Example Before discussing properties of the inlining algorithm, we first show a simple example. Suppose we have an applet as depicted in the left-hand column of <ref type="figure">Figure 1</ref>.</p><p>Inlining this applet with the public method set 񮽙Ñ񮽙 results in the applet depicted in the right-hand column of <ref type="figure">Figure 1</ref>. Notice that all internal and public edges are preserved, while private method calls are replaced by two edges: to the entry and from the return point of the called method, respectively.</p><p>Properties We state several useful properties of the inlining algorithm. First of all, the inlining algorithm computes an applet having as interface the public interface of the original applet. Notice that in general we do not have behavioural simulation equivalence. The inlining construction introduces transfer edges for calls to and returns from private methods. Because of the latter, the behaviour of the inlined applet can contain a silent transition corresponding to a return from a private method (in the original applet), even when the inlined applet has not yet followed a silent transition corresponding to a call to this private method (in the original applet). The inlining thus introduces new behaviours. Notice however, that these new behaviours are only observable in applets which are not last-call recursive.</p><p>A set of methods is recursive if every method in the set contains a (reachable) call edge to some method in the set. A call edge is recursive if the calling and the called methods belong to some minimal (and thus, mutually) recursive method set. A program is called last-call recursive if from any destination node of any recursive call edge, only transfer edges are reachable. In addition, we shall assume that a return node is reachable from every such destination node.</p><p>For last-call recursive applets, we prove the reverse correspondence for observable behaviours. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Interface Abstraction and Compositional Reasoning</head><p>Using the results obtained above, we can state several verification principles that can be used to prove properties of applet interface behaviour. We first present two abstraction principles, and then show how these can be combined with our compositional verification principle from <ref type="bibr" target="#b11">[12]</ref> to support the improved scenario for secure post-issuance loading of applets on smart devices presented in the Introduction. with interface Á 񮽙 that simulates all other applets with this interface satisfying property 񮽙.</p><p>Observe that the maximal model construction can only be applied if the complete interface Á 񮽙 of applet 񮽙 is known. The correctness of a property decomposition can thus only be established for applets with a known interface, and knowledge of the public interface only is hence not sufficient. To allow compositional verification of public interface properties, we combine the above rule with the abstraction principle (abstract) to obtain the following abstract compositional verification principle (abstract-compos): Proof. Follows from the abstraction and the compositional verification principle, plus Propositions 5.3 and 5.4.</p><formula xml:id="formula_1">« Å</formula><p>The improved scenario for secure post-issuance loading of applets presented in the Introduction is based on the verification principle embodied by this rule. Notice that the interface of required methods that is used for the maximal model construction uses Á 񮽙 Á · 񮽙 . Typically, this will correspond to the public interface of 񮽙, and for each implementation of 񮽙 it should be checked whether it respects this public interface of 񮽙.</p><p>Finally, similarly as for the abstraction principle, we can state a faithful compositional verification principle (weakabstract-compos) for properties of the observable interface behaviour of applets which are last-call recursive. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Practical Impact of Inlining</head><p>As explained above, we are interested in studying the abstract behaviour of applets, because in a truly compositional setting nothing is known about the different components, except (some properties of) their interface behaviour. For a newly downloaded applet we only require that it implements the shareable interface; we do not put any restrictions on how it implements this shareable interface, except that the implementation should respect the global security requirements. Studying compositional verification at the abstract level allows to specify the local and global properties at the abstract level, without taking any implementation Å񮽙Ü´񮽙 Ä µ Å񮽙Ü´񮽙 Ä µ in <ref type="bibr" target="#b6">[7]</ref>   <ref type="table" target="#tab_2">Table 2</ref>. Size and timing for maximal model construction details into account. Moreover, when considering shareable interfaces only, the maximal models that we compute to verify the decomposition of the global property into the local ones are significantly reduced in size, making the verification much more efficient. In order to show the impact of abstraction and inlining on a realistic case study, this section revisits the electronic purse case study <ref type="bibr" target="#b6">[7]</ref>, specifying an illicit interaction between applets Purse and Loyalty. In the original case study we computed maximal applets using the implementation interfaces (containing about 300 methods per applet). This was time-consuming (25 mins. to 13 hrs.) and moreover, the size of the outcome was so large that verification was unfeasible. However, the public interfaces (i.e. the shareable interfaces) of these applets both provide only 4 methods. If we refer to the shareable interfaces as ËÁ È (methods provided by Purse for Purse and Loyalty) and ËÁ Ä (Loyalty for Purse and Loyalty), respectively, we can identify the following public interfaces: ´ËÁ È ËÁ È 񮽙 ËÁ Ä µ for Purse, and´ËÁ and´ËÁ Ä ËÁ È 񮽙 ËÁ Ä µ for Loyalty.</p><p>We use the tool set described in <ref type="bibr" target="#b6">[7]</ref>, plus an implementation of the inlining algorithm in Ocaml to redo the case study at the abstract level. For convenience we repeat the global and local specifications, but this time specified at the interface level; for further motivations we refer to <ref type="bibr" target="#b6">[7]</ref>.</p><p>The global specification 񮽙 says that a call to Loyalty.logFull does not trigger any calls to any other loyalty, including indirect communications, via the Purse. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>HasNoOutsideCalls ÈÙÖ××񮽙ØÌÖÒ×× ØØÓÒ</head><p>These specifications refer to the inlined versions of the applets. To exclude external calls from a method of an inlined applet is equivalent to excluding transitive external calls made from the public method with the same name in the original applet. Notice that such a property is not directly expressible in our logic (cf. <ref type="bibr" target="#b6">[7]</ref>).</p><p>To redo the case study at the abstract level, we take the following steps (where È and Ä denote implementations of  <ref type="bibr" target="#b3">[4]</ref>. <ref type="table" target="#tab_2">Table 2</ref> compares the outcome and timing for the maximal model construction with the corresponding step in the original case study. Checking the correctness of the decomposition took approximately 5 seconds. The inlining algorithm took 0.6 seconds on both Loyalty and Purse. Even though theoretically the worst-case blowup in the number of nodes of the inlined applets, determined by the number of normal M-frames, is exponential in the number of private methods, in practice this is not likely to happen. In our case, we even observed a reduction in size of the graphs, due to the fact that the inlining focuses on interaction with other applets, and thus any code that is executed only when the applet is selected and receives commands from the runtime environment, is left out by the inlining. Verifying the local properties of the inlined applets of Loyalty and Purse took approximately 15 and 10 seconds, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions</head><p>In this paper, we propose a notion of interface behaviour of program components which abstracts from the internal, private behaviour. Based on this notion, behavioural properties can be specified at the public interface level without requiring knowledge about the implementation. Focusing on interface behaviour is significant from a methodological, software engineering point of view. In particular, it supports compositional verification by allowing global, programwide properties to be inferred from the interface properties of the not yet available components.</p><p>We propose a program transformation based on inlining of private methods, and show that it preserves the interface behaviour. The inlining transformation reduces the number of methods of a program to the number of its public methods. This is a necessary condition for applying the maximal model construction from <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b11">12]</ref> in a truly compositional manner, and gives rise to an improved scenario for secure post-issuance loading of applets on smart devices. The reduction in the number of methods resulting from the interface abstraction drastically improves the performance of the maximal model construction which is of exponential worst-case complexity. Finally, we observe that some natural structural properties are only directly expressible as properties of the inlined applet. This concludes the proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Full Proof of Theorem</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>4 . Compute, for each applet 񮽙 񮽙 , its maximal model Å񮽙Ü´񮽙 񮽙񮽙 µ, and check that their composition satis- fies 񮽙, i.e. Å񮽙Ü´񮽙 񮽙½ µ ℄ ℄ Å񮽙Ü´񮽙 񮽙Ò µ 񮽙 񮽙 񮽙. 5. Whenever the implementation of applet 񮽙 񮽙 becomes available, compute the abstraction « Å ´񮽙 񮽙 µ, and verify that « Å ´񮽙 񮽙 µ 񮽙 񮽙 񮽙 񮽙񮽙 .</head><label>4</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Definition 2 .1. (Simulation Logic) The formulae of simu- lation logic are inductively defined by: 񮽙 񮽙񮽙񮽙 Ô 񮽙 񮽙Ô 񮽙 񮽙 񮽙 񮽙 ½ 񮽙 񮽙 ¾ 񮽙 񮽙 ½ 񮽙 񮽙 ¾ 񮽙 񮽙񮽙℄ 񮽙 񮽙 where Ô ¾ 񮽙, 񮽙 ¾ Ä and 񮽙 ¾ Î .A model is a structure Å 񮽙´ËË 񮽙´ËË ÄÄ 񮽙 µ, where Ë is a set of states, 񮽙񮽙 Ë ¢ Ä ¢ Ë a transition relation, and 񮽙񮽙 Ë 񮽙 È´񮽙µ a valuation, assign- ing to each state × the atomic propositions that hold in ×. A specification Ë is a pair´Åpair´Å µ, where Å is a model and 񮽙 񮽙 Ë is a set of states. Intuitively, one can think of 񮽙 as the set of entry states of the model. For specifications, we define the usual notions of satisfaction 񮽙 񮽙 and simulation 񮽙 (where related states sat- isfy the same atomic propositions). This simulation relation preserves (backwards) logical properties.Ë ¾ 񮽙 񮽙 񮽙 implies Ë ½ 񮽙 񮽙 񮽙labelled with the distinguished silent action 񮽙.Ë ¾ 񮽙 񮽙 Û 񮽙 implies Ë ½ 񮽙 񮽙 Û 񮽙 Proof. Immediate consequence of Theorem 5 in</head><label>2</label><figDesc></figDesc><table>Next, we define a general notion of model and specifica-
tions. 

Definition 2.2. (Model) Theorem 2.3. Ë ½ 񮽙 Ë ¾ and Proof. Corollary 2.16 in [12] 

Weak simulation and logic. In Section 4 we show how 
private method calls can be abstracted away into internal 

transitions, When abstracting in such a way from part of the concrete 
behaviour of a system, one also has to abstract from the in-
ternal behaviour, and instead consider the visible behaviour 
in terms of weak transitions. We use the standard definition 

of weak transitions × 񮽙 

µ Ø in terms of strong transitions: 

× 񮽙 

µ Ø whenever ×´񮽙×´񮽙 
µ £ Ø, and × 񮽙 
µ Ø whenever × 񮽙 
µ 񮽙 
񮽙 
µ Ø, 
for all 񮽙 񮽙 񮽙 񮽙. Weak simulation 񮽙 Û is then defined as sim-

ulation w.r.t. weak transitions. Similarly, for the weak satis-

faction relation 񮽙 񮽙 Û , we interpret the box modality over the 

weak transitions. As above, the weak simulation relation 
preserves weak satisfaction of logical properties. 

Theorem 2.4. Ë ½ 񮽙 Û Ë ¾ and </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Definition 3 .1. (Method specification) A method graph for Ñ ¾ Å񮽙ØØ over a set Å 񮽙 Å񮽙ØØ of method names is a finite model Å Ñ 񮽙´Î񮽙´Î Ñ Ä Ñ 񮽙 񮽙 Ñ Ñ Ñ µA method specification for Ñ ¾ Å񮽙ØØ over Å is a pair´Åpair´Å Ñ Ñ µ, where Å Ñ is a method graph for Ñ over Å and 񮽙 Ñ 񮽙 Î Ñ is a non-empty set of entry points of Ñ.</head><label>3</label><figDesc></figDesc><table>where Î Ñ is the set of control nodes of Ñ, Ä Ñ 񮽙 Å 񮽙񮽙, 
񮽙 Ñ 񮽙 񮽙ÑÑ Ö񮽙, and 񮽙 Ñ 񮽙 Î Ñ 񮽙 È´񮽙 Ñ µ is so that Ñ ¾ 
񮽙 Ñ ´Úµ for all Ú ¾ Î Ñ (i.e. each node is tagged with its 
method name). The nodes Ú ¾ Î Ñ with Ö ¾ 񮽙 Ñ ´Úµ are 
called return points. We write 񮽙 ÅÅØØ´ÚµÅÅØØ´Úµ to denote the function returning the 
name of the method to which Ú belongs. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>applet interface is a pair Á 񮽙´Á񮽙´Á · Á µ, where Á · Á 񮽙 Å񮽙ØØ are finite sets of names of provided and required methods, respectively.Applet) An applet 񮽙½ ℄ 񮽙 ¾ 񮽙 Á ½ 񮽙 Á ¾ if 񮽙 ½ 񮽙 Á ½ and 񮽙 ¾ 񮽙 Á ¾ . An applet is closed if Á 񮽙 Á · , i.e. it does not require any external methods. The public interface of an applet 񮽙񮽙 Á is characterised by a set of methods Å such that Å 񮽙 Á · : the set of meth- ods publicly provided by the applet is Å, while the set of publicly required methods is Á ´Á · Åµ; thus applet 񮽙񮽙 Á has public interfacéÅ Á ´Á · Åµµ. The left-</head><label></label><figDesc></figDesc><table>The composition of two interfaces Á ½ 񮽙´Á񮽙´Á · 
½ Á 
½ µ and Á ¾ 񮽙 

´Á 

· 

¾ Á 

¾ µ is defined by Á ½ 񮽙 Á ¾ 񮽙´Á񮽙´Á · 
½ 񮽙 Á · 

¾ Á 

½ 񮽙 Á 

¾ µ. 

To formally define the notion applet with implementa-
tion interface, we use the notion of disjoint union of spec-

ifications Ë ½ ℄ Ë ¾ , where each state is tagged with ½ or ¾, 

respectively, and´××and´×× µ 񮽙 

Ë½℄Ë¾´ØØË½℄Ë¾´ØØ µ, for 񮽙 ¾ 񮽙½񮽙 ¾񮽙, if and 

only if × 񮽙 

Ë񮽙 Ø. 

Definition 3.3. (with implementation 
interface Á, written 񮽙 񮽙 Á, is defined inductively by 
¯ ´Å Ñ Ñ µ 񮽙´񮽙Ñ񮽙񮽙´񮽙Ñ񮽙 Åµ if´Åif´Å Ñ Ñ µ is a method 
specification for Ñ ¾ Å񮽙ØØ over Å, and 
¯ 񮽙 hand column of Figure 1 on page 6 is an example of a closed 

applet with one public method Ñ and two private methods 
񮽙 and 񮽙. 

Simulation and satisfaction, instantiated to this particu-

lar type of models are called structural simulation 񮽙 × , and 
structural satisfaction 񮽙 񮽙 × , respectively. 

(transfer) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>Table 1 . Applet Transition RulesLet 񮽙 񮽙´Å񮽙´Å µ 񮽙 Á be a closed applet where Å 񮽙´Î񮽙´Î ÄÄ 񮽙 µ. The behaviour of 񮽙 is described by the specification 񮽙´񮽙µ 񮽙´Å񮽙´Å 񮽙 񮽙 µ, where Å 񮽙 񮽙´Ë񮽙´Ë 񮽙 Ä 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 µ is such that Ë 񮽙 񮽙 Î ¢ Î £ , i.e. states are pairs of control points and stacks, Ä 񮽙 񮽙</head><label>1</label><figDesc></figDesc><table>Applet Behaviour Next we instantiate specifications on 
the behavioural level. 

Definition 3.4. (Behaviour) 񮽙Ñ ½ 񮽙 Ñ ¾ 񮽙 񮽙 ¾ 񮽙

ÐÐ񮽙 ÖÖØ񮽙񮽙 Ñ ½ Ñ ¾ ¾ Á · 񮽙 񮽙 񮽙񮽙񮽙, 񮽙 񮽙 is 

defined by the rules of Table 1, 񮽙 񮽙 񮽙 񮽙, and 񮽙 񮽙´´Ú񮽙´´Ú µµ 񮽙 
񮽙´Úµ. 

The set of initial states 񮽙 񮽙 is defined by 񮽙 񮽙 񮽙 񮽙 ¢ 񮽙¯񮽙, 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>we define the top public method w.r.t. Å, which for a given callstack 񮽙 is the first public method to which a node in the call stack belongs.Å 񮽙 񮽙´´Ú񮽙´´Ú µ ´Ú ¼ ¼ µµ 񮽙 񮽙񮽙 ¾ ÄÄ´Ú ÄÄ´Ú µ 񮽙 񮽙´Ú񮽙´Ú ¼ ¼ µ 񮽙 񮽙 Å ´´Ú µ µ 񮽙 񮽙 񮽙 ¯ 񮽙 Å 񮽙 Å 񮽙 񮽙Ö񮽙 ¯ 񮽙 Å 񮽙´Ú񮽙´Ú µ 񮽙 񮽙 񮽙ØÓÔ Å ´Ú ¡ 񮽙µ񮽙 񮽙 񮽙񮽙´Ú ¾ Å 񮽙 Ú 񮽙 񮽙 Öµ ØØØÒ 񮽙Ö񮽙 񮽙Ð×× 񮽙 ¯ 񮽙 Å 񮽙 񮽙Ú 񮽙 Ú ¾ 񮽙 񮽙 񮽙 ÅÅØØ´ÚµÅÅØØ´Úµ ¾ Å񮽙.i.e. 񮽙 Á · ´񮽙µ 񮽙 񮽙´񮽙µ. We define behavioural interface simulation 񮽙 񮽙 Å 񮽙 񮽙 as 񮽙 Å ´񮽙µ 񮽙 񮽙 Å ´񮽙µ, and weak behavioural interface simu- lation 񮽙 񮽙 Å 񮽙񮽙Û 񮽙 as 񮽙 Å ´񮽙µ 񮽙 Û 񮽙 Å ´񮽙µ. Notice that 񮽙 and 񮽙 need not have the same interfaces -we only require Å 񮽙 Á · 񮽙 and Å 񮽙 Á · 񮽙 . Similarly, for any formula 񮽙 in sim- ulation logic over Ä Å and 񮽙 Å , we define behavioural inter- face satisfaction 񮽙 񮽙 񮽙 Å 񮽙 񮽙 as 񮽙 Å ´񮽙µ 񮽙 񮽙 񮽙, and weak be- havioural interface satisfaction 񮽙 񮽙 񮽙 Å 񮽙񮽙Û 񮽙 as 񮽙 Å ´񮽙µ 񮽙 񮽙 Û 񮽙.</head><label></label><figDesc></figDesc><table>ØÓÔ_񮽙ÒÒÒÜ Å ´񮽙µ 񮽙 

ÅÜ´񮽙񮽙 񮽙 ¼ 񮽙 񮽙 񮽙 񮽙񮽙 
񮽙 ÅÅØØ´񮽙ÅÅØØ´񮽙 񮽙 µ ¾ Å񮽙µ 

ØÓÔ Å ´񮽙µ 񮽙 

񮽙 ÅÅØØ´񮽙ÅÅØØ´񮽙 ØÓÔ_񮽙ÒÒÒÜ Å ´񮽙µ µ 

Using these definitions, we can define a relabelling 񮽙 Å 

of transition labels to the public level. Labels for calls and 
returns between public methods are left unchanged. A call 
from a private to a public method is relabelled as a call from 
the top public method in the pending call stack. A return 
from a public to a private method is relabelled as a return to 
the top public method. All other transitions get labelled as 
silent actions. 

񮽙 Å ´´Ú µ µ 񮽙 

񮽙 
񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 

񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 

񮽙 

񮽙񮽙 񮽙 񮽙 Ñ ½ 񮽙

ÐÐ񮽙ÖÖØ񮽙Ñ ¾ 񮽙 
Ñ ½ Ñ ¾ ¾ Å 
ØÓÔ Å ´Ú ¡ 񮽙µ ÐÐ Ñ ¾ 񮽙񮽙 񮽙 񮽙 Ñ ½ ÐÐ Ñ ¾ 񮽙 
Ñ ½ 񮽙 ¾ Å Ñ ¾ ¾ Å 

Ñ ½ ÖÖØ ØÓÔ Å ´񮽙µ 

񮽙񮽙 񮽙 񮽙 Ñ ½ ÖÖØ Ñ ¾ 񮽙 
Ñ ½ ¾ Å Ñ ¾ 񮽙 ¾ Å 

񮽙 

ÓØØØÖÛÛ×× 

Now we are ready to define the interface behaviour of 

applet 񮽙 w.r.t. a set of public methods Å. 
Definition 4.1. (Interface behaviour) Let 񮽙 񮽙 Á be a closed 
applet with behaviour 񮽙´񮽙µ 񮽙´´ËË񮽙´´ËË ÄÄ 񮽙 µ µ. Let 
Å 񮽙 Á · be a set of public methods. The interface be-
haviour of 񮽙 w.r.t. Å is defined as 񮽙 Å ´񮽙µ 񮽙´´ËË񮽙´´ËË Ä Å 񮽙 񮽙 Å 

Å Å µ Å µ, where 

¯ Ä Å 񮽙 񮽙񮽙񮽙 񮽙 񮽙Ñ ½ 񮽙 Ñ ¾ 񮽙 Ñ ½ Ñ ¾ ¾ Å񮽙 
񮽙 ¾ 񮽙

ÐÐ񮽙 ÖÖØ񮽙񮽙 
¯ 񮽙 The interface behaviour of an applet also defines a push-
down automaton. 

Proposition 4.2. The interface behaviour of 񮽙 w.r.t. Á · is 

identical to its behaviour, </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><head>applet) Let 񮽙 񮽙 Á be an applet, and let Å be a set of public methods, such that Å 񮽙 Á · . Let Å ¼ be the set Å 񮽙´Á񮽙´Á Á · µ. We define the inlined applet « Å ´񮽙µ 񮽙´´Î񮽙´´Î ¼ Ä ¼ 񮽙 񮽙񮽙´ÑÑ µ 񮽙 񮽙´Ú ¡ Ú ¼ ¡ 񮽙µ 񮽙´Ú񮽙´Ú Ú ¼ µ ¾ ÁÒØ´Ñµ 񮽙 ÈÙÙ Å ¼ ´Ñµ Ë 񮽙´´Ú񮽙´´Ú Ñ ¼ Ú ¼ µµ 񮽙´´Ú񮽙´´Ú Ñ ¼ Ú ¼ µµ 񮽙 񮽙´Ú ¡ ´񮽙 ¡ Ú ¼ ¡ 񮽙µµ 񮽙 񮽙 񮽙 񮽙 Ñ ¼ 񮽙 񮽙 ¾ 񮽙 񮽙´񮽙´ÖØ ¡ Ú ¼ ¡ 񮽙µ Ú ¼ ¡ 񮽙µ 񮽙 ÖØ 񮽙 񮽙´Ñ񮽙´Ñ ¼ 񮽙 Öµ 񮽙񮽙 񮽙񮽙񮽙񮽙´¼񮽙񮽙񮽙񮽙´¼ 񮽙 񮽙 񮽙 񮽙񮽙񮽙 񮽙´Ú񮽙´Ú ¼ ¡ 񮽙µ 񮽙 񮽙 񮽙 Ñ ¼ µ ØØØÒ 񮽙´Ñ ¼ Ú ¼ ¡ 񮽙µ 񮽙Ð×× 񮽙 ¯ 񮽙 ¼ 񮽙 Å 񮽙 񮽙Ö񮽙 ¯ 񮽙 ¼ 񮽙 񮽙 񮽙 񮽙 񮽙񮽙 ÅÅØØ´񮽙ÅÅØØ´񮽙 ¼ µ񮽙 񮽙 񮽙񮽙´񮽙񮽙񮽙񮽙񮽙´񮽙񮽙񮽙 񮽙 ½ 񮽙 񮽙 ¼ 񮽙 񮽙 Öµ ØØØÒ 񮽙Ö񮽙 񮽙Ð×× 񮽙 ¯ 񮽙 ¼ 񮽙 񮽙Ú ¾ 񮽙 񮽙 񮽙 ÅÅØØ´ÚµÅÅØØ´Úµ ¾ Å񮽙.</head><label></label><figDesc>The definition of the inlining algorithm uses auxiliary func- tions 񮽙 and 񮽙. The function 񮽙 considers all edges related to a method: it returns internal and public edges with renamed nodes -using the pending call stack, and calls function 񮽙 on private edges. Function 񮽙 adds edges to the entry point, and from the return point of the private method, using the pending call stack argument, and if necessary normalising the result (this uses the fact that the pending call stack is always a normalised Å-frame). Then it checks if the pri- vate call is non-recursive, in which case the private method is inlined recursively.</figDesc><table>the formal definition of the inlining algorithm, we 

need some new notions. Let 񮽙 񮽙 Á be an applet and Å 񮽙 Á · m 

a 
b 

a 
b 

a 
a 

v0 

v1 

v2 

v7 

v5 
v6 

v3 

v4 

m 

m 

v7.v3.v1 

v4.v3.v1 
v0 
v2.v1 

v1 
v3.v1 

v5.v3.v1 
v6.v3.v1 

m 

Figure 1. Example applet before and after inlining 

be a set of public methods. An Å-frame is a sequence of 
nodes 񮽙 of which only 񮽙 ÅÅØØ´񮽙ÅÅØØ´񮽙 ¼ µ is in Å. An Å-frame 

is called normal, if all nodes in the frame belong to dif-
ferent methods. We choose to represent the nodes of the 

inlined applet by normal Å-frames derived from the be-

haviour of the original applet. The abstraction function 
mentioned above (replacing recursion by iteration) is for-
malised by means of the (normalising) conditional rewrite 

rule 񮽙 ¡ Ú ¡ 񮽙 ¼ ¡ Ú ¼ ¡ 񮽙 ¼¼¸񮽙¼¼¸¼¼¸񮽙 񮽙 ¡ Ú ¡ 񮽙 ¼¼ if 񮽙 ÅÅØØ´ÚµÅÅØØ´Úµ 񮽙 񮽙 ÅÅØØ´ÚÅÅØØ´Ú ¼ µ 
and 񮽙 ¼ ¡ Ú ¼ ¡ 񮽙 ¼¼ is a normal Å-frame. Let 񮽙´񮽙µ denote the 

normal form of 񮽙 w.r.t. the rule. Note that if 񮽙 is an Å-
frame, then 񮽙´񮽙µ is a normal Å-frame. Moreover, for any 
(normal) Å-frame 񮽙 we have ØÓÔ Å ´񮽙µ 񮽙 񮽙 ÅÅØØ´񮽙ÅÅØØ´񮽙 ¼ µ. 

Further, we define ÁÒØ, ÈÙÙ and ÈÖÚ, denoting the sets 

of internal, public and private edges of a method w.r.t. a set 

of public methods Å, respectively. 

ÁÒØ´Ñµ 񮽙 񮽙´Ú Ú ¼ µ 񮽙 Ú Ñ Ú ¼ 񮽙 Ú 񮽙 񮽙 񮽙Ö񮽙 
ÈÙÙ Å ´Ñµ 񮽙 񮽙´Ú Ñ ¼ Ú ¼ µ 񮽙 Ú Ñ ¼ 
Ñ Ú ¼ 񮽙 
Ú 񮽙 񮽙 񮽙Ö 񮽙 Ñ ¼ ¾ Å񮽙 
ÈÖÚ Å ´Ñµ 񮽙 񮽙´Ú Ñ ¼ Ú ¼ µ 񮽙 Ú Ñ ¼ 
Ñ Ú ¼ 񮽙 
Ú 񮽙 񮽙 񮽙Ö 񮽙 Ñ ¼ 񮽙 ¾ Å񮽙 

Definition 5.1. (Inlined ¼ ¼ ¼ µ ¼ µ, where 
¯ Î ¼ 񮽙 񮽙Û ¾ Î · 񮽙 Û is a normal Å-frame񮽙, 
¯ Ä ¼ 񮽙 Å ¼ 񮽙 񮽙񮽙񮽙, 
¯ 񮽙 ¼ 񮽙 Ë 

Ñ¾Å 񮽙´ÑÑ ¯µ where 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head>Proposition 5 .2. Let 񮽙 񮽙 Á be an applet and Å 񮽙 Á · a set of public methods. The inlined applet « Å ´񮽙µ has interface Á «Å´񮽙µ«Å´񮽙µ 񮽙´Å񮽙´Å Á ´Á3. Let 񮽙 񮽙 Á be an applet. Then « Á · ´񮽙µ 񮽙 񮽙.Let 񮽙 񮽙 Á 񮽙 and 񮽙 񮽙 Á 񮽙 be applets, Å 񮽙 񮽙 Á · 񮽙 and Å 񮽙 񮽙 Á · 񮽙 be disjoint, and let Á5. Let 񮽙 񮽙 Á be a closed applet, and let Å 񮽙 Á · . Then 񮽙 Å ´񮽙µ 񮽙 񮽙´« Å ´񮽙µµ. Proof. We show by co-induction that « ¼</head><label>5</label><figDesc>Å maps every entry state to itself). It is easy to check that the valuations agree; for the proof that the transitions are simulated, we refer to Appendix A.</figDesc><table>· Åµµ, i.e. « Å ´񮽙µ 񮽙´Å񮽙´Å Á 
´Á · Åµµ. 

By Proposition 4.2 we thus get: 

񮽙 Å ´« Å ´񮽙µµ 񮽙 񮽙´« Å ´񮽙µµ 

Since the inlining transformation « Å only inlines methods 
not in Å, « Á · is the identity operation. 

Proposition 5.Finally, the inlining algorithm enjoys the following dis-
tributivity property. 

Proposition 5.4. 񮽙 Á · 
񮽙 񮽙 Å 񮽙 and 

Á 

񮽙 Á · 
񮽙 񮽙 Å 񮽙 . Then 
« Å񮽙񮽙Å񮽙´񮽙Å񮽙񮽙Å񮽙´񮽙 ℄ 񮽙µ 񮽙 « Å񮽙´񮽙µÅ񮽙´񮽙µ ℄ « Å񮽙´񮽙µÅ񮽙´񮽙µ 

Simulation Results. As already mentioned, the interface 
behaviour of the original applet is preserved by the inlining 
algorithm, i.e. every execution of the interface behaviour 

of 񮽙 is an execution of the behaviour of « Å ´񮽙µ. This is 

due to the close correspondence between the interface be-

haviour of 񮽙 and the structure of « Å ´񮽙µ. We provide an 

"inlining" transformation « ¼ Å on the states of 񮽙 Å ´񮽙µ by 
defining « ¼ 

Å ´Ú µ 񮽙´񮽙񮽙´­µ񮽙´񮽙񮽙´­µ ØÐ´­µµ, where ­ 񮽙 ¬ Å ´Ú ¡ 񮽙µ 

and where ¬ Å ´񮽙µ denotes the sequence of normalised Å-

frames. Notice that we always have 񮽙񮽙´񮽙񮽙´­µµ 񮽙 񮽙񮽙´Ú ¡񮽙µ. 

We show that « ¼ 

Å is a simulation relating the original inter-
face behaviour with the inlined behaviour. 

Theorem 5.Å is a simula-

tion between 񮽙 Å ´񮽙µ and 񮽙´« Å ´񮽙µµ, i.e., we show that 
(1) the valuations of´Úof´Ú µ in 񮽙 Å ´񮽙µ and « ¼ Å ´Ú µ in 
񮽙´« Å ´񮽙µµ agree, and (2) if´Úif´Ú µ Ð 

´Ú ¼ ¼ µ in 񮽙 Å ´񮽙µ, 

then « ¼ 
Å ´Ú µ Ð 

« ¼ Å ´Ú ¼ ¼ µ in 񮽙´« Å ´񮽙µµ. The result 

then follows since « ¼ 
Å maps the entry states of 񮽙 Å ´񮽙µ to 
entry states of 񮽙´« Å ´񮽙µµ (in fact, the entry states coincide, 
and « ¼ 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><head>Theorem 5 .6. Let 񮽙 񮽙 Á be a closed last-call recursive ap- plet, and let Å 񮽙 Á · . Then 񮽙´« Å ´񮽙µµ 񮽙 Û 񮽙 Å ´񮽙µ. Proof. Consider a statéÛ ­µ in 񮽙´« Å ´񮽙µµ, where 񮽙 ÅÅØØ´񮽙񮽙´ÛµµÅÅØØ´񮽙񮽙´Ûµµ 񮽙 ¾ Å and 񮽙񮽙´Ûµ 񮽙 񮽙 Ö. For last-call recursive applets, the inlining transformation « Å has the property that for any such Û, the nodes Û ¼ such that 񮽙´񮽙񮽙´Ûµ ¡Û ¼ µ 񮽙 Û but 񮽙񮽙´Ûµ ¡ Û ¼ 񮽙 񮽙 Û and which are structurally reachable from Û in « Å ´񮽙µ form (together with Û) a strongly con- nected component and are equivalent w.r.t. structural simu- lation. As a consequence, in 񮽙´« Å ´񮽙µµ, all states´Ûstates´Û ¼ ­µ for a given ­ also form a strongly connected component7. Let 񮽙 񮽙 Á be a closed last-call recursive applet, and let Å 񮽙 Á · . Then 񮽙 Å ´񮽙µ 񮽙 Û 񮽙´« Å ´񮽙µµ.</head><label>5</label><figDesc></figDesc><table>and are weak simulation equivalent. Modulo such "return" 

equivalence classes, we show by co-induction that´«that´« ¼ 
Å µ ½ 
is a weak simulation between 񮽙´« Å ´񮽙µµ and 񮽙 Å ´񮽙µ. More 
exactly, we show that (1) the valuations of « ¼ 
Å ´Ú µ and´Ú and´Ú µ agree, and (2) if « ¼ Å ´Ú µ Ð 

´Û ¼ ­ ¼ µ is a transi-

tion in 񮽙´« Å ´񮽙µµ other than a (silent) transition within a 
return equivalence class, then´Úthen´Ú µ Ð 

µ ´Ú ¼ ¼ µ in 񮽙 Å ´񮽙µ 

for some Ú ¼ and 񮽙 ¼ such that « ¼ Å ´Ú ¼ ¼ µ 񮽙´Û񮽙´Û ¼ ­ ¼ µ (in 

most cases we even show the corresponding strong transi-

tion). The result then follows since « ¼ 

Å maps entry states 

of 񮽙´« Å ´񮽙µµ to entry states of 񮽙 Å ´񮽙µ. Again, it is easy to 

check that the valuations agree; for the proof that the tran-
sitions are simulated, we refer to Appendix B. 

Since weak simulation contains simulation we have the 
following. 

Corollary 5.</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12" validated="false"><head>´񮽙µ 񮽙 񮽙 × 񮽙 Å񮽙Ü Á « Å ´񮽙µ´񮽙µ´񮽙µ´񮽙µ ℄ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 ℄ 񮽙 񮽙 񮽙 Å񮽙Á ·</head><label></label><figDesc></figDesc><table>񮽙 

񮽙 

񮽙 

񮽙 񮽙 Á 񮽙 񮽙 

Á 

񮽙 Á · 
񮽙 񮽙 Å 

Theorem 6.3. Rule (abstract-compos) is sound. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13" validated="false"><head>« Å ´񮽙µ 񮽙 񮽙 × 񮽙 ÅÅÜ Á « Å ´񮽙µ´񮽙µ´񮽙µ´񮽙µ ℄ 񮽙 񮽙 񮽙 񮽙 AE´񮽙µ 񮽙 ℄ 񮽙 񮽙 񮽙 Å񮽙Á ·</head><label>«</label><figDesc></figDesc><table>񮽙 

񮽙񮽙Û 񮽙 

񮽙 񮽙 Á 񮽙 񮽙 

Á 

񮽙 Á · 
񮽙 񮽙 Å 

Theorem 6.4. Rule (weak-abstract-compos) is sound and 
complete. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14" validated="false"><head>Å񮽙Ü´񮽙 È µ Å񮽙Ü´񮽙 È µ in [7]</head><label></label><figDesc></figDesc><table>#nodes 
8 
474 
8 
2786 
#edges 
120 
277 700 
88 
603 128 
constr. time 
0.05 s. 
25 min. 
0.05 s. 
13 hrs. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15" validated="false"><head>The specification uses several abbreviations for readability (where 񮽙 is an applet such that 񮽙 񮽙´Á񮽙´Á · Á µ and Å a set of methods). Always 񮽙 񮽙 񮽙 񮽙 񮽙Ä 񮽙 ℄񮽙 Within Ñ 񮽙 񮽙 񮽙Ñ 񮽙´Always񮽙´Always 񮽙µ CanNotCall 񮽙 Å 񮽙 Î Ñ¾Á · Î Ñ ¼ ¾Å 񮽙Ñ ÐÐ Ñ ¼ ℄ 񮽙񮽙Ð××´񮽙µ 񮽙񮽙Ð××´񮽙µ Within ÐÓÝÐØÝÐÓÓ ÙÐÐ CanNotCall ÄÓÝÐØÝ ËÁ Ä 񮽙 CanNotCall È ÙÖ×× ËÁ Ä For the Loyalty applet we exclude any external calls, ex- cept those to the methods Purse.isThereTransaction and Purse.getTransaction (񮽙 Ä µ. For the Purse applet we spec- ify that both these methods do not make any external calls (񮽙 È ). Again we use several abbreviations. Everywhere 񮽙 񮽙 񮽙 񮽙 񮽙 Á ℄񮽙 Å HasNoCallsTo Å ¼ 񮽙 Î Ñ¾Å 񮽙Ñ ¡ 񮽙 Everywhere 񮽙Å ¼ ℄ 񮽙񮽙Ð×× HasNoOutsideCalls Å 񮽙 Å HasNoCallsTóÁ Ò Åµ´񮽙 Åµ´񮽙 Ä µ ÐÓÝÝÐØÝ񮽙ÐÓÙÐÐ HasNoCallsTóËÁ HasNoCallsTóËÁ È 񮽙 ËÁ Ä µ񮽙񮽙È ÙÖ×××××Ì ÖÌ ÖÒ×× ØØÓÒ</head><label>specification</label><figDesc></figDesc><table>È ÙÖ××××ØÌ ÖÒ××
ØØÓÒ񮽙´񮽙 

ØØÓÒ񮽙´񮽙 È µ HasNoOutsideCalls ÈÙÖ××񮽙×ÌÌÌÖÌÖÒ××
ØØÓÒ 񮽙 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_16" validated="false"><head>Purse and Loyalty, respectively):</head><label></label><figDesc></figDesc><table>¯ compute 
Å񮽙Ü´ËÁÈÅ񮽙Ü´ËÁÈ ËÁÈ 񮽙ËÁÄµ´񮽙񮽙ËÁÄµ´񮽙 È µ 

and 

Å񮽙Ü´ËÁÄËÁÄ񮽙ËÁÈÅ񮽙Ü´ËÁÄËÁÄ񮽙ËÁÈ µ ´񮽙 Ä µ using the Maximal Model 

constructor [12, 7]; 

¯ model check Å񮽙Ü´ËÁÈÅ񮽙Ü´ËÁÈ ËÁÈ 񮽙ËÁÄµ´񮽙񮽙ËÁÄµ´񮽙 È µ ℄ 
Å񮽙Ü´ËÁÄËÁÄ񮽙ËÁÈÅ񮽙Ü´ËÁÄËÁÄ񮽙ËÁÈ µ ´񮽙 Ä µ 񮽙 񮽙 񮽙 AE´񮽙µ using a proto-

type implementation of a model checker for PDAs; 

¯ compute « ËÁÈ´ÈËÁÈ´È µ and « ËÁÄ´ÄµËÁÄ´Äµ using the inlining al-

gorithm; and 

¯ model check « ËÁÈ´ÈËÁÈ´È µ 񮽙 񮽙 × 񮽙 È and « ËÁÄ´ÄµËÁÄ´Äµ 񮽙 񮽙 × 񮽙 Ä 

using CWB </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_17" validated="false"><head>A.1 Theorem A.1. Let 񮽙 񮽙 Á be a closed applet, and let Å 񮽙 Á · . We have 񮽙 Å ´񮽙µ 񮽙 񮽙´« Å ´񮽙µµ. Proof. We show by co-induction that « ¼Consider a statéÛ ­µ in 񮽙´« Å ´񮽙µµ, where 񮽙 ÅÅØØ´񮽙񮽙´ÛµµÅÅØØ´񮽙񮽙´Ûµµ 񮽙 ¾ Å and 񮽙񮽙´Ûµ 񮽙 񮽙 Ö. For last-call recursive applets, the inlining transformation « Å has the property that for any such Û, the nodes Û ¼ such that 񮽙´񮽙񮽙´Ûµ ¡Û ¼ µ 񮽙 Û but 񮽙񮽙´Ûµ ¡ Û ¼ 񮽙 񮽙 Û, and which are structurally reachable񮽙 Ú ¼¼ . Then´ÚThen´Ú µ Ñ ¼ ret Ñ ¼¼´񮽙񮽙´񮽙µ ¼¼´񮽙񮽙´񮽙µ ØÐ´񮽙µµ in 񮽙´񮽙µ, and hencéÚ µ 񮽙´񮽙񮽙´񮽙µ 񮽙´񮽙񮽙´񮽙µ ØÐ´񮽙µµ in 񮽙 Å ´񮽙µ. By tdefinition of « ¼ Å , « ¼ Å ´񮽙񮽙´񮽙µ ØÐ´񮽙µµ 񮽙´Û񮽙´Û ¼ ­µ. ¯ 񮽙񮽙´񮽙µ 񮽙 񮽙 Ú ¼¼ and Û 񮽙 Ú ¡ Û ¼ . Then we are dealing with a return from a recursive call in 񮽙´񮽙µ, and there must be a decomposition 񮽙 ¼ ¡ Ú ¼¼ ¡ 񮽙 ¼¼ of 񮽙 such that 񮽙 ÅÅØØ´񮽙ÅÅØØ´񮽙 ¼ µ 񮽙 Ñ ¼ and no node of 񮽙 ¼ is in Å. Since 񮽙 is last-call recursive, all nodes in 񮽙 ¼ are either re-</head><label></label><figDesc>µ 񮽙´Û񮽙´Û ­µ. Note that 񮽙񮽙´Ûµ 񮽙 Ú, and that 񮽙 is invoked with arguments 񮽙 ÅÅØØ´񮽙񮽙´ÛµµÅÅØØ´񮽙񮽙´Ûµµ and ØÐ´Ûµ in the construction of « Å ´񮽙µ. It is easy to check that the valu- ations agree, so we focus on the transitions. We consider the different cases leading to transitions from configuration´Û configuration´Û ­µ in 񮽙´« Å ´񮽙µµ, as induced by the transition rules for</figDesc><table>Å is a simula-

tion between 񮽙 Å ´񮽙µ and 񮽙´« Å ´񮽙µµ, i.e., we show that 
(1) the valuations of´Úof´Ú µ in 񮽙 Å ´񮽙µ and « ¼ 
Å ´Ú µ in 
񮽙´« Å ´񮽙µµ agree, and (2) if´Úif´Ú µ Ð 

´Ú ¼ ¼ µ in 񮽙 Å ´񮽙µ, 

then « ¼ Å ´Ú µ Ð 

« ¼ Å ´Ú ¼ ¼ µ in 񮽙´« Å ´񮽙µµ. The result 

then follows since « ¼ Å maps the entry states of 񮽙 Å ´񮽙µ to 
entry states of 񮽙´« Å ´񮽙µµ (in fact, the entry states coincide, 
and « ¼ 

Å maps every entry state to itself). 

Let´ÚLet´Ú µ be a configuration of 񮽙 Å ´񮽙µ, and hence also 
of 񮽙´񮽙µ. Let « ¼ 
Å ´Ú µ 񮽙´Û񮽙´Û ­µ; Û is a normal Å-frame 

of 񮽙, and thus a node of « Å ´񮽙µ. Note that 񮽙񮽙´Ûµ 񮽙 Ú. It 

is easy to check that valuations on´Úon´Ú µ and´Ûand´Û ­µ agree, 

so we focus on the second goal. We consider the differ-

ent cases leading to transitions from configuration´Úconfiguration´Ú µ in 
񮽙´񮽙µ, as induced by the transition rules for closed applets 
given in Table 1. Notice that in the construction of « Å ´񮽙µ 
the auxiliary function 񮽙 initially is invoked with arguments 
Û ¼ and ¯, and that eventually this results in a recursive call 
of 񮽙 with arguments 񮽙񮽙´Ûµ and ØÐ´Ûµ. 

(transfer) Let Ú 񮽙 Ñ Ú ¼ and Ú 񮽙 񮽙 񮽙Ö. Then´Ú 

Then´Ú µ 񮽙´Ú 

񮽙´Ú ¼ µ in 񮽙´񮽙µ, and hence also in 񮽙 Å ´񮽙µ. 
Then, by definition of « Å (edge in set ÁÒØ Å ´Ñµ) and 
Proof. from Û in « Å ´񮽙µ form (together with Û) a strongly con-

nected component and are equivalent w.r.t. structural simu-

lation. As a consequence, in 񮽙´« Å ´񮽙µµ, all states´Ûstates´Û ¼ ­µ 
for a given ­ also form a strongly connected component 

and are weak simulation equivalent. Modulo such "return" 

equivalence classes, we show by co-induction that´«that´« ¼ 
Å µ ½ 
is a weak simulation between 񮽙´« Å ´񮽙µµ and 񮽙 Å ´񮽙µ. More 
exactly, we show that (1) the valuations of « ¼ 
Å ´Ú µ and´Ú and´Ú µ agree, and (2) if « ¼ Å ´Ú µ Ð 

´Û ¼ ­ ¼ µ is a transi-

tion in 񮽙´« Å ´񮽙µµ other than a (silent) transition within a 
return equivalence class, then´Úthen´Ú µ Ð 

µ ´Ú ¼ ¼ µ in 񮽙 Å ´񮽙µ 

for some Ú ¼ and 񮽙 ¼ such that « ¼ Å ´Ú ¼ ¼ µ 񮽙´Û񮽙´Û ¼ ­ ¼ µ (in 

most cases we even show the corresponding strong transi-

tion). The result then follows since « ¼ Å maps entry states of 
񮽙´« Å ´񮽙µµ to entry states of 񮽙 Å ´񮽙µ. 
Let´ÚLet´Ú µ be a configuration of 񮽙 Å ´񮽙µ, and let 
« ¼ 
Å ´Ú closed applets given in Table 1. 

(transfer) Let Ñ ¾ Å, Û 񮽙 Ñ Û ¼ and Û 񮽙 񮽙 񮽙Ö. Then´Û 

Then´Û ­µ 񮽙´Û 

񮽙´Û ¼ ­µ in 񮽙´« Å ´񮽙µµ. By definition of « Å , 

there are three possible cases for the transfer edge 

Û 񮽙 Ñ Û ¼ to appear in « Å ´񮽙µ, which we consider 

in turn. 

1. Û ¼ 񮽙 Ú ¼ ¡ ØÐ´Ûµ and Ú 񮽙 Ñ ¼ Ú ¼ for some Ú ¼ and 
Ñ ¼ 񮽙 񮽙 ÅÅØØ´ÚµÅÅØØ´Úµ 񮽙 񮽙 ÅÅØØ´ÚÅÅØØ´Ú ¼ µ, and Ú 񮽙 񮽙 񮽙Ö. Then´Ú 

Then´Ú µ 񮽙´Ú 

񮽙´Ú ¼ µ in 񮽙´񮽙µ, and hence also in 񮽙 Å ´񮽙µ. By 

the definition of « ¼ 
Å , « ¼ 
Å ´Ú ¼ µ 񮽙´Û񮽙´Û ¼ ­µ. 

2. (internal call) Û ¼ 񮽙 񮽙´񮽙¡Ú ¼ ¡ØÐ´Ûµµ, 񮽙 񮽙 񮽙 Ñ ¼ and 񮽙 ¾ 񮽙, 

Ñ ¼ 񮽙 

¾ Å, there is a call edge Ú Ñ ¼ 
Ñ ¼¼ Ú ¼ in 񮽙 for 

some Ñ ¼¼ , Ú 񮽙 񮽙 񮽙Ö. Then´ÚThen´Ú µ Ñ ¼¼ call Ñ ¼ 
´ Ú ¼ ¡ 񮽙µ 

in 񮽙´񮽙µ, and hencéÚ µ 񮽙´Ú 

񮽙´񮽙´Ú ¼ ¡ 񮽙µ in 񮽙 Å ´񮽙µ. By 

definition of « ¼ 
Å , « ¼ 

Å ´ Ú ¼ ¡ 񮽙µ 񮽙´Û񮽙´Û ¼ ­µ. 
3. (internal return) Û 񮽙 񮽙´Ú ¡ Û ¼ µ, Ú 񮽙 񮽙 Ñ ¼ 񮽙 Ö, Ñ ¼ 񮽙 
¾ Å 

and there is a call edge Ú ¼ Ñ ¼ 

Ñ ¼¼ Ú ¼¼ in 񮽙 for Ú ¼¼ 񮽙 
񮽙񮽙´Û ¼ µ and some Ñ ¼¼ and Ú ¼ such that Ú ¼ 񮽙 񮽙 񮽙Ö. We 

consider three sub-cases. 

¯ 񮽙񮽙´񮽙µ turn nodes or nodes leading to return nodes via trans-

fer paths only. ThereforéÚ µ 񮽙 

µ ´Ú ¼¼ ¼¼ µ in 񮽙 Å ´񮽙µ. 

By the definition of « ¼ 
Å , « ¼ 
Å ´Ú ¼¼ ¼¼ µ 񮽙´Û񮽙´Û ¼ ­µ. 

¯ 񮽙񮽙´񮽙µ 񮽙 񮽙 Ú ¼¼ and Û 񮽙 񮽙 Ú ¡ Û ¼ . Then´ÛThen´Û ­µ and´Ûand´Û ¼ ­µ 

are in the same return equivalence class (see above), so 
we do not have to consider this case. 

(call) Let Ñ ½ Ñ ¾ ¾ Å, Û Ñ¾ 
Ñ½ Û ¼ , Û 񮽙 񮽙 񮽙Ö, Û ¼¼ 񮽙 񮽙 Ñ ¾ 
and Û ¼¼ ¾ 񮽙. Then´ÛThen´Û ­µ Ñ½ call Ñ¾´Û Ñ¾´Û ¼¼ Û ¼ ¡ ­µ in 

񮽙´« Å ´񮽙µµ. By definition of « Å , we must have Û ¼ 񮽙 

Ú ¼ ¡ ØÐ´Ûµ for some Ú ¼ such that, in 񮽙, Ú Ñ¾ 
Ñ Ú ¼ and 
Ú 񮽙 񮽙 񮽙Ö for some private method Ñ of Ñ ½ . By defini-

tion of « ¼ 

Å , Û ¼¼ 񮽙 Ú ¼¼ for some Ú ¼¼ such that Ú ¼¼ 񮽙 񮽙 Ñ ¾ 
and Ú ¼¼ ¾ 񮽙. Then´ÚThen´Ú µ Ñ call Ñ¾´Ú Ñ¾´Ú ¼¼ Ú ¼ ¡ 񮽙µ in 
񮽙´񮽙µ, and since by definition of « ¼ Å , ØÓÔ Å ´Ú ¡ 񮽙µ 񮽙 

Ñ ½ , we havéÚ µ Ñ½ call Ñ¾´Ú 

Ñ¾´Ú ¼¼ Ú ¼ ¡ 񮽙µ in 񮽙 Å ´񮽙µ. 
By definition of « ¼ Å , « ¼ Å ´Ú ¼¼ Ú ¼ ¡ 񮽙µ 񮽙´Û񮽙´Û ¼¼ Û ¼ ¡ ­µ. 
(return) Let Ñ ½ Ñ ¾ ¾ Å, Û 񮽙 񮽙 Ñ ¾ 񮽙 Ö, ­ 񮽙 񮽙 ¯ and 
񮽙񮽙´­µ 񮽙 񮽙 Ñ ½ . Then´ÛThen´Û ­µ Ñ¾ ret Ñ½´񮽙񮽙´­µ Ñ½´񮽙񮽙´­µ ØÐ´­µµ 

in 񮽙 Å ´« Å ´񮽙µµ. By definition of « Å and « ¼ Å , we 

must have Û 񮽙 Ú and Ú 񮽙 񮽙 Ñ ¾ 񮽙 Ö. Also, 񮽙 񮽙 񮽙 ¯ 

and hencéÚ µ Ñ¾ ret Ñ 

´񮽙񮽙´񮽙µ ØÐ´񮽙µµ in 񮽙´񮽙µ for 

Ñ 񮽙 񮽙 ÅÅØØ´񮽙񮽙´񮽙µµÅÅØØ´񮽙񮽙´񮽙µµ. By definition of « ¼ Å , ØÓÔ Å ´񮽙µ 񮽙 
Ñ ½ and hencéÚ µ Ñ¾ ret Ñ½´񮽙񮽙´񮽙µ 

Ñ½´񮽙񮽙´񮽙µ ØÐ´񮽙µµ in 

񮽙 Å ´񮽙µ. By definition of « ¼ 
Å , « ¼ 
Å ´񮽙񮽙´񮽙µ ØÐ´񮽙µµ 񮽙´񮽙񮽙´­µ 񮽙´񮽙񮽙´­µ ØÐ´­µµ. 

</table></figure>

			<note place="foot" n="1"> Dealing with local behavioural properties would require restricting the logic and a non-standard maximal model construction.</note>

			<note place="foot" n="2"> This notion is a generalization of the notion of tail recursivity, where recursive calls are the last statements of their methods.</note>

			<note place="foot" n="3"> With the possible emergence of multi-threaded smart card platforms the techniques presented here will have to be generalized accordingly.</note>

			<note place="foot" n="4"> If a method has several entry or return points, several internal edges are created.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We would like to thank Gennady Chugunov for helping us redoing the verifications, and Christoph Sprenger for numerous suggestions for improvement on an earlier draft.</p></div>
			</div>

			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A temporal logic for nested calls and returns</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Etessami</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools and Algorithms for the Analysis and Construction of Software, TACAS 04, number 2998 in LNCS</title>
		<editor>K. Jensen and A. Podelski</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="467" to="481" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Verification on infinite structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Burkart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Caucal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Moller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Steffen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Process Algebra</title>
		<editor>J.A. Bergstra, A. Ponse, and S.A. Smolka</editor>
		<imprint>
			<publisher>North Holland</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="545" to="623" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Model checking and abstraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Long</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1512" to="1542" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A semantics based verification tool for finite state systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Cleaveland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Parrow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Steffen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 9th IFIP Symp. Protocol Specification, Verification and Testing</title>
		<meeting>9th IFIP Symp. Protocol Specification, Verification and Testing</meeting>
		<imprint>
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Efficient algorithms for model checking pushdown systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Esparza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Hansel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Rossmanith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Schwoon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification (CAV &apos;00)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="232" to="247" />
		</imprint>
	</monogr>
	<note>number 1855 in LNCS</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Model checking and modular verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Long</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Prog. Lang. &amp; Syst</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="843" to="871" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Checking absence of illicit applet interactions: a case study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Huisman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gurov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sprenger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Chugunov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fundamental Approaches to Software Engineering, FASE 2004, number 2984 in LNCS</title>
		<editor>M. Wermelinger and T. Margaria</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="84" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Verification of control flow based security policies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">Le</forename><surname>Métayer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Thorn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Research in Security and Privacy</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="89" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Evaluating inlining techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Kaser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Languages (JCL)</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="55" to="72" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Results on the propositional 񮽙-calculus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kozen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TCS</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="333" to="354" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Simulation logic, applets and compositional verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sprenger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gurov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Huisman</surname></persName>
		</author>
		<idno>RR-4890</idno>
	</analytic>
	<monogr>
		<title level="j">INRIA</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Compositional verification for secure loading of smart card applets. In Formal Methods and Models for Co-Design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sprenger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gurov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Huisman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<publisher>IEEE</publisher>
			<biblScope unit="page" from="211" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Modal and Temporal Logics of Processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stirling</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
