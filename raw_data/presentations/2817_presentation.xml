<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Model-agnostic and efficient exploration of numerical state space of real-world TCP</p>
    <p>congestion control implementations</p>
    <p>Wei Sun (UNL) Lisong Xu (UNL)</p>
    <p>Sebastian Elbuam (Virginia) Di Zhao (UNL)</p>
  </div>
  <div class="page">
    <p>create a network with a single link  speed = 1Kbps to 1Gbps  loss = 0.00001% to 10%</p>
    <p>Impractical to check each of 1012 possible combinations  Propose automated state space exploration in order to</p>
    <p>efficiently solve this type of TCP testing problems</p>
    <p>test CUBIC in the created network, and keep track of CUBIC state variables  cwnd : congestion window size  target : expected cwnd after one RTT</p>
    <p>check whether target &gt; 2*cwnd  If so, too aggressive (more</p>
    <p>aggressive than slow start)</p>
    <p>Example: check whether CUBIC is sometimes too aggressive</p>
  </div>
  <div class="page">
    <p>Concepts of parameter space P and state space S</p>
    <p>check whether target &gt; 2*cwnd  If so, too aggressive (more</p>
    <p>aggressive than slow start)</p>
    <p>network environment parameter space P = { (speed, loss) } for this example</p>
    <p>congestion control state space S = { (cwnd, target) } for this exampletest CUBIC in the created network, and</p>
    <p>keep track of CUBIC state variables  cwnd : congestion window size  target : expected cwnd after one RTT</p>
    <p>create a network with a single link  speed = 1Kbps to 1Gbps  loss = 0.00001% to 10%</p>
  </div>
  <div class="page">
    <p>Parameter space P and state space S</p>
    <p>Each network environment in P leads CUBIC to visit a sequence of states in S. (the sequence of states are for illustration purpose only)</p>
    <p>init state</p>
    <p>P S</p>
    <p>s1</p>
    <p>s2</p>
    <p>p1</p>
    <p>p2</p>
    <p>a network environment</p>
    <p>p</p>
    <p>speed</p>
    <p>loss</p>
    <p>cwnd</p>
    <p>target</p>
  </div>
  <div class="page">
    <p>Parameter space P and state space S</p>
    <p>As we choose more network environments in P, more states in S will be visited.</p>
    <p>speed</p>
    <p>loss</p>
    <p>cwnd</p>
    <p>target P S</p>
    <p>s1</p>
    <p>s2</p>
    <p>p1</p>
    <p>p2</p>
  </div>
  <div class="page">
    <p>In order to solve this type of testing problems, we can just find all possible regions of S that can be visited by a congestion control algorithm.</p>
    <p>Red region (target&gt;2*cwnd) is the region where CUBIC is too aggressive. If the red region can be visited by CUBIC, then CUBIC is sometimes too aggressive.6</p>
    <p>speed</p>
    <p>loss</p>
    <p>cwnd</p>
    <p>target P S</p>
    <p>s1</p>
    <p>s2</p>
    <p>p1</p>
    <p>p2</p>
    <p>Example: check whether CUBIC is sometimes too aggressive</p>
  </div>
  <div class="page">
    <p>Automated state space exploration</p>
    <p>What is automated state space exploration?  Given</p>
    <p>a parameter space P for a testing script  a state space S for a congestion control algorithm,</p>
    <p>how to automatically choose network environments in P in order to explore as many different regions of S as possible?</p>
    <p>Why it is useful?  It can be used to test whether a congestion control algorithm has wrong or</p>
    <p>inappropriate behaviors by just checking whether the corresponding regions of S can be visited.</p>
  </div>
  <div class="page">
    <p>Our method: Automated Congestion control Testing (ACT)</p>
    <p>Goal: Explore as many different regions of S as possible, instead of concentrating on some regions</p>
    <p>Feedback-guided random testing  Scalable to large P: ACT randomly selects network environments in P  Efficiently explore S: The random selection is guided by the feedback  Model-agnostic: Feedback is obtained from previous state coverage information,</p>
    <p>and does not require abstract models of P and S</p>
    <p>ACT steps   Random testing   Parameter estimation   Parameter concatenation</p>
  </div>
  <div class="page">
    <p>ACT  Random testing, Parameter estimation, Parameter concatenation</p>
    <p>Uniformly randomly select network environments in P to have an initial coverage of S</p>
    <p>P S</p>
    <p>s1</p>
    <p>s2</p>
    <p>p1</p>
    <p>p2</p>
  </div>
  <div class="page">
    <p>Uniform selection in P  uniform coverage of S, due to non-linear mapping  Use parameter estimation to explore the unvisited gaps and corners.</p>
    <p>P S</p>
    <p>s1</p>
    <p>s2</p>
    <p>p1</p>
    <p>p2 P S</p>
    <p>s1</p>
    <p>s2</p>
    <p>p1</p>
    <p>p2</p>
    <p>ACT  Random testing, Parameter estimation, Parameter concatenation</p>
  </div>
  <div class="page">
    <p>Use random interpolation to visit the gap between two visited regions</p>
    <p>P S</p>
    <p>s1</p>
    <p>s2</p>
    <p>p1</p>
    <p>p2</p>
    <p>pbp*pa</p>
    <p>sa s* sb</p>
    <p>ACT  Random testing, Parameter estimation, Parameter concatenation</p>
  </div>
  <div class="page">
    <p>Use random extrapolation to visit an unvisited corner or side of S  The directions are estimated using the results of step .</p>
    <p>P S</p>
    <p>s1</p>
    <p>s2</p>
    <p>p1</p>
    <p>p2</p>
    <p>directions to decrease s 2 sc</p>
    <p>p* s*</p>
    <p>pc</p>
    <p>ACT  Random testing, Parameter estimation, Parameter concatenation</p>
  </div>
  <div class="page">
    <p>Some regions are still not visited, if state variables are correlated (e.g., cwnd and ssthresh)</p>
    <p>P S</p>
    <p>s1</p>
    <p>s2</p>
    <p>p1</p>
    <p>p2</p>
    <p>regions visited by steps and</p>
    <p>ACT  Random testing, Parameter estimation, Parameter concatenation</p>
  </div>
  <div class="page">
    <p>If s1 and s2 are positively correlated, estimated by extrapolation will lead the algorithm to visit that has smaller s2 and smaller s1.</p>
    <p>P S</p>
    <p>s1</p>
    <p>directions to decrease s 2</p>
    <p>s2</p>
    <p>p1</p>
    <p>p2</p>
    <p>init state</p>
    <p>sd</p>
    <p>p* s*</p>
    <p>pd</p>
    <p>s+</p>
    <p>p* s+</p>
    <p>ACT  Random testing, Parameter estimation, Parameter concatenation</p>
  </div>
  <div class="page">
    <p>Parameter concatenation uses both and . That is, we change the network environment in the middle of an experiment.</p>
    <p>The algorithm will follow a different path to state , more likely to visit unvisited regions. 15</p>
    <p>p*pd</p>
    <p>ACT  Random testing, Parameter estimation, Parameter concatenation</p>
    <p>P S</p>
    <p>s1</p>
    <p>s2</p>
    <p>p1</p>
    <p>p2</p>
    <p>init state</p>
    <p>sd</p>
    <p>p* s*</p>
    <p>pd</p>
    <p>s+</p>
    <p>s+</p>
  </div>
  <div class="page">
    <p>Experiment setup</p>
    <p>Real-world TCP congestion control in Linux 3.10:  CUBIC, AIMD, HTCP, HSTCP, VENO</p>
    <p>Parameter space P  a testing script with a single-link network  (loss, speed, propagation delay, random queueing delay, application rate)</p>
    <p>State space S  (cwnd, ssthresh, rtt, rttvar, ca_state, )  plus protocol-specific state variables</p>
    <p>Two types of experiments  state space coverage  bug detection</p>
  </div>
  <div class="page">
    <p>State space coverage experiments</p>
    <p>Measuring state space coverage by four different testing methods  ACT  RAN: Undirected random testing  MAN: Manually choose popular network environments used in</p>
    <p>previous studies  SYM: Symbolic execution based testing where packet delays are</p>
    <p>represented as symbolic variables</p>
  </div>
  <div class="page">
    <p>Measuring state space coverage</p>
    <p>Divide S into equal-sized regions of size k.  Measure the percentage of regions</p>
    <p>covered by each testing method  Example: 3 out of 4 regions are visited,</p>
    <p>thus coverage is 75% with region size k.</p>
    <p>S</p>
    <p>s1</p>
    <p>s2</p>
    <p>k</p>
    <p>k</p>
  </div>
  <div class="page">
    <p>State space coverage of CUBIC</p>
  </div>
  <div class="page">
    <p>Two-dimensional projection of S: Coverage by ACT</p>
    <p>cwnd</p>
  </div>
  <div class="page">
    <p>Two-dimensional projection of S: Coverage by ACT</p>
    <p>cwnd</p>
    <p>random testing</p>
  </div>
  <div class="page">
    <p>Two-dimensional projection of S: Coverage by ACT</p>
    <p>cwnd</p>
    <p>random testing  parameter estimation</p>
  </div>
  <div class="page">
    <p>Two-dimensional projection of S: Coverage by ACT</p>
    <p>cwnd</p>
    <p>random testing  parameter estimation  parameter concatenation</p>
  </div>
  <div class="page">
    <p>Bug detection experiments</p>
    <p>Check three types of behaviors 1. Generic behavior 2. Window increase behavior 3. Window decrease behavior</p>
  </div>
  <div class="page">
    <p>Generic behavior: Check whether cwnd &gt; 107 packets</p>
    <p>Bug: Sometimes AIMD, HTCP, HSTCP, VENO set cwnd to 4,294,967,294 packets  Reported to Linux kernel developers, were told that just fixed 25</p>
  </div>
  <div class="page">
    <p>Window increase behavior: Check whether target &gt; 2*cwnd</p>
    <p>One bug: In the application rate limited periods, CUBIC does not increase cwnd, but it still increases target. 26</p>
  </div>
  <div class="page">
    <p>Window decrease behavior: Check whether cwnd reduces after fast recovery</p>
    <p>One bug: Sometimes AIMD and HTCP increase cwnd after undoed recovery  Reported it to Linux kernel developers, and now it has been fixed 27</p>
    <p>dup ACKs</p>
    <p>fast recovery</p>
    <p>undo recovery</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Proposed ACT as a simple, efficient, and effective tool for automated TCP congestion control correctness testing.</p>
    <p>Found several Linux TCP bugs using ACT.</p>
  </div>
</Presentation>
