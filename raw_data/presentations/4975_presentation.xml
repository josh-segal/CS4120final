<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Asymmetric Interactions in Symmetric Multicore Systems:</p>
    <p>Analysis, Enhancements, and Evaluation Tom Scogland*</p>
    <p>P. Balaji+</p>
    <p>W. Feng*</p>
    <p>G. Narayanaswamy*</p>
    <p>Virginia Tech* Argonne National Laboratory+</p>
  </div>
  <div class="page">
    <p>Background</p>
    <p>We are entering the era of multicore and manycore  4 cores are common  Multicore isnt as simple as it seems</p>
    <p>Homogeneous chips are still hierarchical in design</p>
    <p>Manycore will be even more difficult - Future: 80+ cores per chip</p>
    <p>Core 0Core 0 Core 1Core 1</p>
    <p>L1 CacheL1 Cache L1 CacheL1 Cache</p>
    <p>L2 CacheL2 Cache</p>
    <p>Core 2Core 2 Core 3Core 3</p>
    <p>L1 CacheL1 Cache L1 CacheL1 Cache</p>
    <p>L2 CacheL2 Cache</p>
  </div>
  <div class="page">
    <p>Assumptions</p>
    <p>Cores have equal computation and communication ability</p>
    <p>A program running on Core #1 will behave the same as on Core #2</p>
    <p>Caveat: maybe different cache effects, but overall the same</p>
    <p>We assume that symmetric multicore has symmetric capabilities per core</p>
  </div>
  <div class="page">
    <p>Reality</p>
    <p>Cores have unequal computation and communication capabilities</p>
    <p>A program running on Core #1 will behave differently than on Core #2  Physical hardware can affect the capability  The OS can have an affect as well  The OS maps processes to cores without</p>
    <p>considering their capabilities</p>
    <p>Cores do not have symmetric capabilities</p>
  </div>
  <div class="page">
    <p>System level effects have performance consequences</p>
    <p>We must understand &amp; mitigate these effects</p>
    <p>Motivation Example</p>
    <p>P e rf</p>
    <p>o rm</p>
    <p>a n</p>
    <p>c e</p>
    <p>or here</p>
    <p>You could be here</p>
  </div>
  <div class="page">
    <p>Solution</p>
    <p>Dynamically map processes to optimal cores</p>
    <p>Result  80% improvement in micro-benchmarks  10% improvement in real-world unmodified</p>
    <p>applications</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation &amp; Problem Overview  Preliminary Work  SyMMer: Systems Mapping Manager</p>
    <p>Overview  Design  Symptom Mitigation</p>
    <p>Results  Micro-benchmarks  Applications</p>
    <p>Summary and Future Work</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>Auto-tuning (Williams et. al. SciDAC 08)  Automatically tunes programs for multicore  Works at the source level before compilation rather than</p>
    <p>runtime  Leaves scheduling up to the operating system</p>
    <p>Processor Affinity  OS schedulers attempt to efficiently schedule processes on</p>
    <p>cores  Schedulers do not take enough factors into account</p>
  </div>
  <div class="page">
    <p>Prior Work</p>
    <p>An Analysis of 10-Gigabit Ethernet Protocol Stacks in Multicore Environments (HotI 08) - Maps specific processes to specific cores</p>
    <p>- i.e., process-to-core mapping - Performs a brute force search for best static</p>
    <p>mapping - Result:</p>
    <p>- Identified symptoms of program behavior which correlate with low performance</p>
    <p>- Necessitates search of entire space to find best mapping</p>
  </div>
  <div class="page">
    <p>Static or Dynamic</p>
    <p>Small office cluster  2 nodes X 4 cores</p>
    <p>(4!)^2 = 576 combos</p>
    <p>Ranger at TACC  3,936 nodes X 16</p>
    <p>cores  (16!)^3,936</p>
    <p>combinations</p>
    <p>576 is tractable, (16!)^3,936 is not!</p>
  </div>
  <div class="page">
    <p>Dynamic Mapping</p>
    <p>Q: How can (16!)^3,936 become tractable?  A: Dont compute all the combinations!</p>
    <p>Course of action  Higher level symptoms are easier to detect  Work back from the symptom to the cause, and treat it  Multi node symptoms can occur, requiring communication</p>
    <p>Monitoring  Symptom detection requires application information  System information also required</p>
    <p>We need something that can do this for us</p>
  </div>
  <div class="page">
    <p>Requirements</p>
    <p>Dynamic process mapping at runtime</p>
    <p>Internal process information to make correct decisions</p>
    <p>Ability to make multi core or multi node decisions</p>
    <p>Low overhead</p>
    <p>ApplicationApplication</p>
    <p>LibrariesLibraries</p>
    <p>KernelKernel</p>
    <p>HardwareHardware</p>
    <p>Where?</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation &amp; Problem Overview  Preliminary Work  SyMMer: Systems Mapping Manager</p>
    <p>Overview  Design  Symptom Mitigation</p>
    <p>Results  Micro-benchmarks  Applications</p>
    <p>Summary and Future Work</p>
  </div>
  <div class="page">
    <p>SyMMer: Systems Mapping Manager</p>
    <p>Complete process-to-core mapping system  Monitors all relevant sources  Uses distributed decision algorithms to detect and</p>
    <p>respond to symptoms  Changes process-to-core mapping</p>
    <p>dynamically  Exhibits Low overhead  Simply link in to use, no source modification</p>
    <p>necessary beyond use of MPI</p>
  </div>
  <div class="page">
    <p>SyMMer: Conceptual Design</p>
    <p>MPICH2</p>
    <p>Linux</p>
  </div>
  <div class="page">
    <p>Symptoms</p>
    <p>Communication Idleness  Out-of-Sync Communication  Cache Locality</p>
  </div>
  <div class="page">
    <p>Communication Idleness</p>
    <p>Processes spend more time than necessary waiting on communication</p>
    <p>Applications should be spending time computing or communicating, not waiting</p>
    <p>Causes  Slow link  Imbalance between processes</p>
  </div>
  <div class="page">
    <p>Communication Idleness: Symptom</p>
    <p>Processes waiting due to capability mismatch  Compute process on slow compute core  Communication process on slow communication core  All local to a single node</p>
  </div>
  <div class="page">
    <p>Communication Idleness: Solution</p>
    <p>Swap the high communication and computation processes</p>
    <p>Process computation time Process communication time</p>
    <p>Low computation core Low communication core</p>
  </div>
  <div class="page">
    <p>Out-of-Sync Communication</p>
    <p>Communication stalls when communicating processes get out of sync</p>
    <p>A sender decides that the receiver isnt taking more data, and decides to continue alone</p>
    <p>The receiver stalls until the sender finally finishes the message</p>
  </div>
  <div class="page">
    <p>Out-of-Sync Communication: Symptom</p>
    <p>Process waiting due to distributed core mismatch  Mismatched cores for processes which are communicating</p>
    <p>with one another across nodes  One lagging behind causes the other to stall</p>
    <p>At least two processes notice the issue</p>
    <p>Execution FlowSystem Mappings</p>
  </div>
  <div class="page">
    <p>Out-of-Sync Communication: Solution</p>
    <p>Remap two processes on one node  Process</p>
    <p>Elect a leader  Leader determines which processes on which node to swap  Swap processes</p>
    <p>Execution FlowSystem Mappings</p>
  </div>
  <div class="page">
    <p>Cache Locality</p>
    <p>The number of hops between cores determines the cost of transfers between them</p>
    <p>The hierarchy of multi-processor multi-core design in full force</p>
    <p>Communication over the network has to transfer the same way, just to an OS controlled core</p>
    <p>Core 0 to Core 1, very efficient, Core 2 to 0 far worse</p>
    <p>Core 0Core 0 Core 1Core 1</p>
    <p>L1 CacheL1 Cache L1 CacheL1 Cache</p>
    <p>L2 CacheL2 Cache</p>
    <p>Core 2Core 2 Core 3Core 3</p>
    <p>L1 CacheL1 Cache L1 CacheL1 Cache</p>
    <p>L2 CacheL2 Cache</p>
  </div>
  <div class="page">
    <p>Cache Locality: Symptom</p>
    <p>Higher than necessary L2 cache misses due to intercore communication</p>
    <p>PAPI with perfctr used to measure L2 cache misses  Frequently caused by network communication from</p>
    <p>distant cores</p>
    <p>Cache 1 Cache 2</p>
  </div>
  <div class="page">
    <p>Cache Locality: Solution</p>
    <p>Map communicating processes onto cores where they share a cache  At least to the same die  With the interrupted core if possible</p>
    <p>Cache 1 Cache 2</p>
  </div>
  <div class="page">
    <p>Symptom Mitigation Recap</p>
    <p>Communication Idleness  Problem: Local imbalance between processes and</p>
    <p>cores  Solution: Swap processes to better matched cores</p>
    <p>Out-of-Sync Communication  Problem: Distributed capability mismatch, resulting</p>
    <p>in a stall in communications  Solution: Swap one end of the mismatched</p>
    <p>communicating pair  Cache Locality</p>
    <p>Problem: Local communication across caches  Solution: Swap processes to nearer cores</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation &amp; Problem Overview  Preliminary Work  SyMMer: Systems Mapping Manager</p>
    <p>Overview  Design  Symptom Mitigation</p>
    <p>Results  Micro-benchmarks  Applications</p>
    <p>Summary and Future Work</p>
  </div>
  <div class="page">
    <p>Results</p>
    <p>Experimental Setup  Micro-benchmarks</p>
    <p>Communication Idleness  Out-of-sync Communication  Cache Locality</p>
    <p>Applications  GROMACS  LAMMPS  FFTW</p>
  </div>
  <div class="page">
    <p>Experimental Setup</p>
    <p>2 Dell PowerEdge 2950 servers  2 dual-core Intel Xeon 2.66GHz processors</p>
    <p>4MB shared L2 cache  4GB 667MHz DDR2 SDRAM  NetEffect NE010 10-Gigabit Ethernet Adapter</p>
    <p>Connected back-to-back  Fedora Core 6 with Linux kernel 2.6.18  MPICH2 v1.1.0a1 with SyMMer patches</p>
  </div>
  <div class="page">
    <p>Micro-Benchmark: Communication Idleness</p>
    <p>Idleness ratio</p>
    <p>T im</p>
    <p>e (</p>
    <p>s e c o</p>
    <p>n d</p>
    <p>s ) 32% improvement</p>
  </div>
  <div class="page">
    <p>Analysis: Communication Idleness</p>
    <p>Computation Wait Communication</p>
    <p>Rank</p>
    <p>Vanilla</p>
    <p>Rank</p>
    <p>SyMMerUnequal Equal</p>
  </div>
  <div class="page">
    <p>Micro-Benchmark: Out-of-Sync Communication</p>
    <p>Message Size</p>
    <p>T im</p>
    <p>e (</p>
    <p>S e c o</p>
    <p>n d</p>
    <p>s )</p>
  </div>
  <div class="page">
    <p>Analysis: Out-of-Sync Communication</p>
    <p>C o</p>
    <p>m m</p>
    <p>u n</p>
    <p>ic a ti</p>
    <p>o n</p>
    <p>S ta</p>
    <p>ll s p</p>
    <p>e r</p>
    <p>ru n</p>
  </div>
  <div class="page">
    <p>Micro-Benchmark: Cache Locality</p>
    <p>Computational load factor</p>
    <p>T im</p>
    <p>e (</p>
    <p>S e c o</p>
    <p>n d</p>
    <p>s )</p>
  </div>
  <div class="page">
    <p>Analysis: Cache Locality</p>
    <p>Inter-node Intra-node 0</p>
    <p>Vanilla SyMMer</p>
    <p>L 2</p>
    <p>C a</p>
    <p>c h</p>
    <p>e M</p>
    <p>is s</p>
    <p>e s</p>
    <p>( T</p>
    <p>h o</p>
    <p>u s</p>
    <p>a n</p>
    <p>d s</p>
    <p>)</p>
  </div>
  <div class="page">
    <p>Applications</p>
    <p>GROMACS  LAMMPS  FFTW</p>
  </div>
  <div class="page">
    <p>Application: GROMACS GROningen MAchine for Chemical Simulations</p>
    <p>simulate[s] the Newtonian equations of motion for systems with hundreds to millions of particles.</p>
    <p>Exhibits the symptom of communication idleness _x0008__x0007_GROMACS</p>
    <p>n s /d</p>
    <p>a y 10%</p>
  </div>
  <div class="page">
    <p>Application: LAMMPS Large-scale Atomic/Molecular Massively Parallel Simulator</p>
    <p>A classical molecular dynamics code  from Sandia National</p>
    <p>Laboratory  Version 21 released in</p>
    <p>May 2008</p>
    <p>Exhibits the out-of-sync communication symptom</p>
    <p>_x0006_LAMMPS 0</p>
    <p>C o</p>
    <p>m m</p>
    <p>u n</p>
    <p>ic a ti</p>
    <p>o n</p>
    <p>t im</p>
    <p>e</p>
  </div>
  <div class="page">
    <p>Application: FFTW Fastest Fourier Transfrom in the West</p>
    <p>library for computing the discrete Fourier transform (DFT)</p>
    <p>Mainly cache misses</p>
    <p>Sometimes out-ofsync communication</p>
    <p>Vanilla SyMMer</p>
    <p>T im</p>
    <p>e</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Build a performance model which predicts the best placement for processes</p>
    <p>Investigate implementation of SyMMer in other communications libraries or standalone  OpenMPI  OpenMP  Standalone library</p>
    <p>Add NUMA awareness and support for greater process migration flexibility</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Efficient and correct mapping of processes matters</p>
    <p>A dynamic system is necessary  SyMMer makes mapping a tractable problem</p>
    <p>for large machines  For some real world applications up to a 10%</p>
    <p>performance improvement has been observed, 80% for microbenchmarks</p>
    <p>Performance improvement over optimized code with no modification!</p>
  </div>
  <div class="page">
    <p>Thank You</p>
    <p>Funding  SYNERGY lab at Virginia Tech  CHREC: Center for High-Performance</p>
    <p>Reconfigurable Computing  ANL: Argonne National Laboratory</p>
    <p>More info  web: http://synergy.cs.vt.edu  email: tscogland@vt.edu</p>
  </div>
  <div class="page">
    <p>Overhead / False Positives</p>
    <p>Sub-Optimal</p>
    <p>Sub-Optimal (dynamic)</p>
    <p>Process-core combinations</p>
    <p>n s /d</p>
    <p>a y</p>
    <p>Optimal</p>
    <p>Optimal (dynamic)</p>
    <p>Process-core combinations</p>
    <p>n s /d</p>
    <p>a y</p>
  </div>
</Presentation>
