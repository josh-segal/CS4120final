<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Swaminathan Sundararaman, Sriram Subramanian, Abhishek Rajimwale, Andrea C. ArpaciDusseau,</p>
    <p>Remzi H. ArpaciDusseau, Michael M. Swift</p>
    <p>File System</p>
    <p>K er ne</p>
    <p>l</p>
    <p>Membrane is a layer of material which serves as a selective barrier between two phases and remains impermeable to specific particles, molecules, or substances when exposed to the action of a driving force.</p>
    <p>Membrane Bug</p>
  </div>
  <div class="page">
    <p>Bugs are common in any large software  File systems contain 1,000  100,000 loc</p>
    <p>Recent work has uncovered 100s of bugs [Engler OSDI 00, Musuvathi OSDI 02, Prabhakaran SOSP 03, Yang OSDI 04, Gunawi FAST 08, Rubio-Gonzales PLDI 09]</p>
    <p>Error handling code, recovery code, etc.</p>
    <p>File systems are part of core kernel  A single bug could make the kernel unusable</p>
  </div>
  <div class="page">
    <p>FS developers are good at detecting bugs  Paranoid about failures</p>
    <p>Lots of checks all over the file system code!</p>
    <p>File System</p>
    <p>assert() BUG() panic()</p>
    <p>xfs 2119 18 43</p>
    <p>ubifs 369 36 2</p>
    <p>ocfs2 261 531 8</p>
    <p>gfs2 156 60 0</p>
    <p>afs 106 38 0</p>
    <p>ext4 42 182 12</p>
    <p>reiserfs 1 109 93</p>
    <p>ntfs 0 288 2</p>
    <p>Number of calls to assert, BUG, and panic in Linux 2.6.27</p>
    <p>Detection is easy but recovery is hard</p>
  </div>
  <div class="page">
    <p>VFS</p>
    <p>File System</p>
    <p>App App App</p>
    <p>Processes could potentially use corrupt inmemory filesystem objects</p>
    <p>Crash</p>
    <p>File System</p>
    <p>App</p>
    <p>VFS</p>
    <p>No fault isolation Inconsistent kernel state</p>
    <p>Hard to free FS objects</p>
    <p>Common solution: crash file system and hope problem goes away after OS reboot</p>
    <p>In o d e i_count 0x00002</p>
    <p>Address mapping</p>
    <p>File systems manage their own inmemory objects Process killed on crash</p>
  </div>
  <div class="page">
    <p>To develop perfect file systems  Tools do not uncover all file system bugs  Bugs still are fixed manually  Code constantly modified due to new features</p>
    <p>Make file systems handle all error cases  Interacts with many external components  VFS, memory mgmt., network, page cache, and I/O</p>
    <p>Cope with bugs than hope to avoid them</p>
  </div>
  <div class="page">
    <p>Membrane: OS framework to support lightweight, stateful recovery from FS crashes</p>
    <p>Upon failure transparently restart FS  Restore state and allow pending application requests to be serviced</p>
    <p>Applications oblivious to crashes</p>
    <p>A generic solution to handle all FS crashes  Last resort before file systems decide to give up</p>
  </div>
  <div class="page">
    <p>Implemented Membrane in Linux 2.6.15  Evaluated with ext2, VFAT, and ext3</p>
    <p>Evaluation  Transparency: hide failures (~50 faults) from appl.  Performance: &lt; 3% for micro &amp; macro benchmarks  Recovery time: &lt; 30 milliseconds to restart FS  Generality: &lt; 5 lines of code for each FS</p>
  </div>
  <div class="page">
    <p>Motivation  Restartable file systems  Evaluation  Conclusions</p>
  </div>
  <div class="page">
    <p>Fault Detection  Helps detect faults quickly</p>
    <p>Fault Anticipation  Records filesystem state</p>
    <p>Fault Recovery  Executes recovery protocol to cleanup and restart the failed file system</p>
    <p>Membrane</p>
    <p>Fault Anticipation</p>
    <p>Fault Detection</p>
    <p>Fault Recovery</p>
  </div>
  <div class="page">
    <p>Correct recovery requires early detection  Membrane best handles failstop failures</p>
    <p>Both hardware and softwarebased detection  H/W: null pointer, general protection error, ...  S/W: asserts(), BUG(), BUG_ON(), panic()</p>
    <p>Assume transient faults during recovery  Nontransient faults: return error to that process</p>
  </div>
  <div class="page">
    <p>Membrane</p>
    <p>Fault Anticipation</p>
    <p>Fault Detection</p>
    <p>Fault Recovery</p>
  </div>
  <div class="page">
    <p>Additional work done in anticipation of a failure</p>
    <p>Issue: where to restart the file system from?  File systems constantly updated by applications</p>
    <p>Possible solutions:  Make each operation atomic  Leverage inbuilt crash consistency mechanism</p>
    <p>Not all FS have crash consistency mechanism</p>
    <p>Generic mechanism to checkpoint FS state</p>
  </div>
  <div class="page">
    <p>VFS</p>
    <p>File System</p>
    <p>Page Cache</p>
    <p>Disk</p>
    <p>App App App</p>
    <p>File systems write to disk through page cache</p>
    <p>All requests enter via VFS layer</p>
    <p>ext3 VFAT Control requests to FS &amp;</p>
    <p>dirty pages to disk</p>
    <p>Checkpoint: consistent state of the file system that can be safely rolled back to in the event of a crash</p>
  </div>
  <div class="page">
    <p>VFS</p>
    <p>File System</p>
    <p>Page Cache</p>
    <p>Disk</p>
    <p>App</p>
    <p>VFS</p>
    <p>File System</p>
    <p>Page Cache</p>
    <p>App</p>
    <p>Disk</p>
    <p>Regular During Checkpoint After Checkpoint</p>
    <p>VFS</p>
    <p>File System</p>
    <p>Page Cache</p>
    <p>App</p>
    <p>Disk</p>
    <p>STOP STOP</p>
    <p>Membrane</p>
    <p>STOP</p>
    <p>C on</p>
    <p>si st en</p>
    <p>t im</p>
    <p>ag e</p>
    <p>CopyonWrite</p>
    <p>Can be written back to disk</p>
    <p>Disk Disk Disk</p>
    <p>Consistent Image #1</p>
    <p>Consistent Image #2</p>
    <p>On crash roll back to last consistent Image</p>
    <p>Consistent Image #3</p>
  </div>
  <div class="page">
    <p>After Recovery</p>
    <p>On crash: flush dirty pages of last checkpoint</p>
    <p>Throw away the inmemory state</p>
    <p>Remount from the last checkpoint  Consistent filesystem image on disk</p>
    <p>Issue: state after checkpoint would be lost  Operations completed after checkpoint returned</p>
    <p>back to applications</p>
    <p>VFS</p>
    <p>File System</p>
    <p>Page Cache</p>
    <p>App</p>
    <p>Disk</p>
    <p>Crash</p>
    <p>STOP</p>
    <p>On Crash Need to recreate state after checkpoint</p>
  </div>
  <div class="page">
    <p>Log operations along with their return value  Replay completed operations after checkpoint</p>
    <p>Operations are logged at the VFS layer  Filesystem independent approach</p>
    <p>Logs are maintained inmemory and not on disk</p>
    <p>How long should we keep the log records?  Log thrown away at checkpoint completion</p>
  </div>
  <div class="page">
    <p>Membrane</p>
    <p>Fault Anticipation</p>
    <p>Fault Detection</p>
    <p>Fault Recovery</p>
  </div>
  <div class="page">
    <p>Important steps in recovery:</p>
  </div>
  <div class="page">
    <p>File System</p>
    <p>VFS</p>
    <p>File System</p>
    <p>App App App</p>
    <p>VFS</p>
    <p>File System</p>
    <p>App</p>
    <p>Page Cache</p>
    <p>K er ne</p>
    <p>l U se r</p>
    <p>FS code should not be trusted after crash</p>
    <p>Multiple threads inside file system</p>
    <p>Crash</p>
    <p>Intertwined execution</p>
    <p>Processes cannot be killed after crash Application threads killed?  application state will be lost</p>
    <p>Clean way to undo incomplete operations</p>
  </div>
  <div class="page">
    <p>Skip: filesystem code Trust: kernel code (VFS, memory mgmt., )</p>
    <p>Cleanup state on error from file systems</p>
    <p>How to prevent execution of FS code?  Control capture mechanism: marks filesystem code pages as nonexecutable</p>
    <p>Unwind Stack: stores return address (of last kernel function) along with expected error value</p>
  </div>
  <div class="page">
    <p>E.g., create code path in ext2</p>
    <p>sys_open() do_sys_open()</p>
    <p>filp_open() open_namei()</p>
    <p>ext2_create()</p>
    <p>Unwind Stack</p>
    <p>block_prepare_write() ext2_prepare_write() ext2_addlink()</p>
    <p>ext2_get_block()</p>
    <p>vfs_create</p>
    <p>regs</p>
    <p>rval</p>
    <p>fn</p>
    <p>ENOMEM</p>
    <p>rax rbp rsi rdi rbx rcx rdx r8</p>
    <p>blk..._write</p>
    <p>regs</p>
    <p>rval</p>
    <p>fn</p>
    <p>EIO</p>
    <p>rax rbp rsi rdi rbx rcx rdx r8</p>
    <p>Clear buffer Zero page</p>
    <p>Mark not dirty</p>
    <p>namei data</p>
    <p>vfs_create()</p>
    <p>fault membrane</p>
    <p>fault membrane</p>
    <p>Crash</p>
    <p>Nonexecutable</p>
    <p>ext2_create()</p>
    <p>ext2_get_block()</p>
    <p>EIO</p>
    <p>ENOMEM</p>
    <p>Kernel File system Kernel is restored to a consistent state</p>
  </div>
  <div class="page">
    <p>Membrane</p>
    <p>Fault Anticipation</p>
    <p>Fault Detection</p>
    <p>Fault Recovery</p>
  </div>
  <div class="page">
    <p>VFS</p>
    <p>File System</p>
    <p>Application</p>
    <p>T0 T1</p>
    <p>time</p>
    <p>ch e ck</p>
    <p>p o in</p>
    <p>t Open (file) write() read()</p>
    <p>Completed In-progress Legend: Crash</p>
    <p>write()</p>
    <p>Periodically create checkpoints</p>
    <p>Move to recent checkpoint</p>
    <p>Replay completed operations</p>
    <p>Unwind inflight processes</p>
    <p>File System Crash 2</p>
    <p>Reexecute unwound process</p>
    <p>link() Close()</p>
    <p>T2</p>
  </div>
  <div class="page">
    <p>Motivation  Restartable file systems  Evaluation  Conclusions</p>
  </div>
  <div class="page">
    <p>Questions that we want to answer:  Can membrane hide failures from applications?  What is the overhead during user workloads?  Portability of existing FS to work with Membrane?  How much time does it take to recover the FS?</p>
    <p>Setup:  2.2 GHz Opteron processor &amp; 2 GB RAM  Two 80 GB western digital disk  Linux 2.6.15 64bit kernel, 5.5K LOC were added  File systems: ext2, VFAT, ext3</p>
  </div>
  <div class="page">
    <p>Ext3_Function Fault</p>
    <p>Ext3 + Native</p>
    <p>Ext3 + Membrane</p>
    <p>D e t e c t e d ?</p>
    <p>A p p li c a ti o n ?</p>
    <p>FS C o ns</p>
    <p>is te nt ?</p>
    <p>F S U s a b le</p>
    <p>?</p>
    <p>D e t e c t e d ?</p>
    <p>A p p li c a ti o n ?</p>
    <p>FS C o ns</p>
    <p>is te nt ?</p>
    <p>F S U s a b le</p>
    <p>?</p>
    <p>create nullpointer o    d</p>
    <p>get_blk_handle bh_result o    d</p>
    <p>follow_link nd_set_link o    d</p>
    <p>mkdir d_instantiate o    d</p>
    <p>free_inode clear_inode o    d</p>
    <p>read_blk_bmap sb_bread o    d</p>
    <p>readdir nullpointer o    d</p>
    <p>file_write file_aio_write G    d</p>
    <p>Legend: O  oops, G prot. fault, d  detected, o  cannot unmount,   no,  yes Membrane successfully hides faults</p>
  </div>
  <div class="page">
    <p>T im</p>
    <p>e in S ec</p>
    <p>on d s</p>
    <p>Workload: Copy, untar, make of OpenSSH 4.51</p>
  </div>
  <div class="page">
    <p>T im</p>
    <p>e in S ec</p>
    <p>on d s</p>
    <p>Workload: Copy, untar, make of OpenSSH 4.51</p>
    <p>Reliability almost comes for free</p>
  </div>
  <div class="page">
    <p>File System Added Modified Deleted Ext2 4 0 0</p>
    <p>VFAT 5 0 0</p>
    <p>Ext3 1 0 0</p>
    <p>JBD 4 0 0</p>
    <p>Individual file system changes</p>
    <p>Minimal changes to port existing FS to Membrane</p>
    <p>Existing code remains unchanged</p>
    <p>Additions: track allocations and write super block</p>
    <p>No crashconsistency</p>
    <p>crashconsistency</p>
  </div>
  <div class="page">
    <p>Motivation  Restartable file systems  Evaluation  Conclusions</p>
  </div>
  <div class="page">
    <p>Failures are inevitable in file systems  Learn to cope and not hope to avoid them</p>
    <p>Membrane: Generic recovery mechanism  Users: Build trust in new file systems (e.g., btrfs)  Developers: Quickfix bug patching</p>
    <p>Encourage more integrity checks in FS code  Detection is easy but recovery is hard</p>
  </div>
  <div class="page">
    <p>Questions?</p>
    <p>Advanced Systems Lab (ADSL) University of WisconsinMadison h&lt;p://www.cs.wisc.edu/adsl</p>
  </div>
  <div class="page">
    <p>Files may be recreated during recovery  Inode numbers could change after restart</p>
    <p>Solution: make create() part of a checkpoint 3/2/10 Membrane: Operating System Support for Restartable File Systems (FAST '10) 33</p>
    <p>VFS</p>
    <p>File System</p>
    <p>Application</p>
    <p>Epoch 0 After Crash Recovery Before Crash</p>
    <p>Epoch 0</p>
    <p>create (file1) stat (file1) write (file1, 4k)</p>
    <p>File : file1 Inode# : 15</p>
    <p>create (file1) stat (file1) write (file1, 4k)</p>
    <p>File1: inode# 12 File1: inode# 15 Inode# Mismatch</p>
    <p>File : file1 Inode# : 12</p>
  </div>
  <div class="page">
    <p>T im</p>
    <p>e in S ec</p>
    <p>on d s</p>
    <p>3000 files (sizes 4K to 4MB), 60K transactions</p>
  </div>
  <div class="page">
    <p>Data (Mb)</p>
    <p>Recovery Time (ms)</p>
    <p>Open Sessions</p>
    <p>Recovery Time (ms)</p>
    <p>Log Records</p>
    <p>Recovery Time (ms)</p>
    <p>Recovery time is a function of:  Dirty blocks, open sessions, and log records</p>
    <p>We varied each of them individually</p>
    <p>Recovery time is in the order of a few milliseconds 3/2/10 Membrane: Operating System Support for Restartable File Systems (FAST '10)</p>
  </div>
  <div class="page">
    <p>Restart ext2 during randomread benchmark</p>
  </div>
  <div class="page">
    <p>File System</p>
    <p>Added Modified</p>
    <p>Ext2 4 0</p>
    <p>VFAT 5 0</p>
    <p>Ext3 1 0</p>
    <p>JBD 4 0</p>
    <p>Components No Checkpoint With Checkpoint</p>
    <p>Added Modified Added Modified</p>
    <p>FS 1929 30 2979 64</p>
    <p>MM 779 5 867 15</p>
    <p>Arch 0 0 733 4</p>
    <p>Headers 522 6 552 6</p>
    <p>Module 238 0 238 0</p>
    <p>Total 3468 41 5369 89</p>
    <p>Individual file system changes Kernel changes</p>
  </div>
  <div class="page">
    <p>Have builtin crash consistency mechanism  Journaling or Snapshotting</p>
    <p>Seamlessly integrate with these mechanism  Need FSes to indicate beginning and end of an transaction</p>
    <p>Works for data and ordered journaling mode  Need to combine writeback mode with COW</p>
  </div>
  <div class="page">
    <p>Goal: Reduce the overhead of logging writes  Soln: Grab data from page cache during recovery</p>
    <p>VFS</p>
    <p>File System</p>
    <p>Page Cache</p>
    <p>VFS</p>
    <p>File System</p>
    <p>Page Cache</p>
    <p>Before Crash During Recovery</p>
    <p>VFS</p>
    <p>File System</p>
    <p>Page Cache</p>
    <p>After Recovery</p>
    <p>Write (fd, buf, offset, count)</p>
  </div>
  <div class="page">
    <p>During log replay could data be written in different order?  Log entries need not represent actual order</p>
    <p>Not a problem for metadata updates  Only one of them succeed and is recorded in log</p>
    <p>Deterministic datablock updates with page stealing mechanism  Latest version of the page is used during replay</p>
  </div>
  <div class="page">
    <p>FS need: stateful &amp; lightweight recovery</p>
    <p>Heavyweight Lightweight</p>
    <p>S ta te le ss</p>
    <p>S ta te fu l</p>
    <p>Nooks/Shadow Xen, Minix L4, Nexus</p>
    <p>SafeDrive Singularity</p>
    <p>CuriOS EROS</p>
  </div>
</Presentation>
