<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Layout-Aware Exhaustive Search</p>
    <p>Aravindan Raghuveer, David H.C. Du</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Exhaustive Search  Examine all objects in a storage system.  Expensive Operation</p>
    <p>Why Exhaustive Search ?  Fuzzy Queries:</p>
    <p>Semantic gap in image, video  hard to annotate  Content-based (Query-by-Example)  Demonstrated in the Diamond project at Intel/CMU</p>
    <p>Index Creation:  Not effective: Curse of dimensionality  Too expensive  Not always possible: Fuzzy queries</p>
    <p>A necessary evil feature on all filesystems.</p>
  </div>
  <div class="page">
    <p>Technology Trends and Exhaustive Search  Bits per unit area increasing rapidly</p>
    <p>I/O Bandwidth lagging behind</p>
    <p>Effect on exhaustive search:  1 day to sequentially read 10TB*</p>
    <p>5 months with 8KB chunk random access !!</p>
    <p>Filesystem level exhaustive search: Recursive exploration of directories.</p>
    <p>With aged, fragmented filesystems:  At the disk: an Exhaustive search will look more like</p>
    <p>random access than sequential.</p>
    <p>* Dr. Jim Grays keynote from FAST05:</p>
  </div>
  <div class="page">
    <p>Filesystem Applications and Exhaustive Search</p>
    <p>Exhaustive Search : Long running, I/O intensive task.</p>
    <p>Other filesystem applications running concurrently.</p>
    <p>Concurrent execution of both:  Performance Isolation:</p>
    <p>Impact on response time of other applications should be minimal.</p>
    <p>Impact on efficiency of exhaustive search should be as low as possible.</p>
  </div>
  <div class="page">
    <p>What this work is about ?</p>
    <p>A fresh look at Exhaustive Search</p>
    <p>As a first class service provided by the storage system.</p>
    <p>Close-to-sequential performance always</p>
    <p>Concurrent execution with other filesystem apps.  Without compromising extensively on response</p>
    <p>time and efficiency</p>
  </div>
  <div class="page">
    <p>An Overview of proposed approach  Layout aware:</p>
    <p>Search order not based on logical filesystem view but physical on-disk organization.</p>
    <p>As close to sequential performance as possible.</p>
    <p>Suspend-and-resume  On a real-time request to disk:</p>
    <p>Suspend exhaustive search.  Service real-time request.  Resume exhaustive search.</p>
    <p>Modify search order based on current disk head position.</p>
  </div>
  <div class="page">
    <p>Ingredients in the Solution</p>
    <p>Architecture:  Where to embed functionality: filesystem or smart object</p>
    <p>based disk ?</p>
    <p>Layout-Aware Search:  Planning the search ?  Metadata handling and placement?</p>
    <p>Where are object extents located  List of objects already scanned</p>
    <p>Suspend-Resume:  Maintaining search progress metadata to avoid</p>
    <p>re-scanning [suspend]  Computing new search plan [resume]</p>
  </div>
  <div class="page">
    <p>Current Status</p>
    <p>Layout-Awareness:  2 modes of layout-aware search.  Pre-planned and adhoc.</p>
    <p>Pre-planned used when the disk stores a small number of objects.</p>
    <p>Adhoc mode used when the disk is almost full.  Pre-planned and adhoc can be used at finer</p>
    <p>granularities (example: different modes on different areas of the disk)</p>
    <p>Suspend-Resume:  Suspend: Search Metadata is distributed over the disk, close</p>
    <p>to the data.  Resume: Based on the remaining number of objects we either</p>
    <p>shift to the pre-planned or adhoc mode.</p>
  </div>
</Presentation>
