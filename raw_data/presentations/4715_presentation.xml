<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Matrix-Vector Multiplication in Sub-Quadratic Time</p>
    <p>(Some Preprocessing Required)</p>
    <p>Ryan Williams</p>
    <p>Carnegie Mellon University</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Matrix-Vector Multiplication: Fundamental Operation in Scientific Computing</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Matrix-Vector Multiplication: Fundamental Operation in Scientific Computing</p>
    <p>How fast can n  n matrix-vector multiplication be?</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Matrix-Vector Multiplication: Fundamental Operation in Scientific Computing</p>
    <p>How fast can n  n matrix-vector multiplication be?</p>
    <p>(n2) steps just to read the matrix!</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Matrix-Vector Multiplication: Fundamental Operation in Scientific Computing</p>
    <p>How fast can n  n matrix-vector multiplication be?</p>
    <p>(n2) steps just to read the matrix!</p>
    <p>Main Result: If we allow O(n2+) preprocessing, then matrix-vector</p>
    <p>multiplication over any finite semiring can be done in O(n2/( log n)2).</p>
  </div>
  <div class="page">
    <p>Better Algorithms for Matrix Multiplication</p>
    <p>Three of the major developments:</p>
  </div>
  <div class="page">
    <p>Better Algorithms for Matrix Multiplication</p>
    <p>Three of the major developments:</p>
    <p>Arlazarov et al., a.k.a. Four Russians (1960s): O(n3/ log n) operations</p>
    <p>Uses table lookups</p>
    <p>Good for hardware with short vector operations as primitives</p>
  </div>
  <div class="page">
    <p>Better Algorithms for Matrix Multiplication</p>
    <p>Three of the major developments:</p>
    <p>Arlazarov et al., a.k.a. Four Russians (1960s): O(n3/ log n) operations</p>
    <p>Uses table lookups</p>
    <p>Good for hardware with short vector operations as primitives</p>
    <p>Strassen (1969): n log 7</p>
    <p>log 2 = O(n2.81) operations</p>
    <p>Asymptotically fast, but overhead in the big-O</p>
    <p>Experiments in practice are inconclusive about Strassen vs. Four</p>
    <p>Russians for Boolean matrix multiplication (Bard, 2006)</p>
  </div>
  <div class="page">
    <p>Better Algorithms for Matrix Multiplication</p>
    <p>Three of the major developments:</p>
    <p>Arlazarov et al., a.k.a. Four Russians (1960s): O(n3/ log n) operations</p>
    <p>Uses table lookups</p>
    <p>Good for hardware with short vector operations as primitives</p>
    <p>Strassen (1969): n log 7</p>
    <p>log 2 = O(n2.81) operations</p>
    <p>Asymptotically fast, but overhead in the big-O</p>
    <p>Experiments in practice are inconclusive about Strassen vs. Four</p>
    <p>Russians for Boolean matrix multiplication (Bard, 2006)</p>
    <p>Coppersmith and Winograd (1990): O(n2.376) operations</p>
    <p>Not yet practical</p>
  </div>
  <div class="page">
    <p>Focus: Combinatorial Matrix Multiplication Algorithms</p>
  </div>
  <div class="page">
    <p>Focus: Combinatorial Matrix Multiplication Algorithms</p>
    <p>Also called non-algebraic; lets call them non-subtractive</p>
    <p>E.g. Four-Russians is combinatorial, Strassen isnt</p>
  </div>
  <div class="page">
    <p>Focus: Combinatorial Matrix Multiplication Algorithms</p>
    <p>Also called non-algebraic; lets call them non-subtractive</p>
    <p>E.g. Four-Russians is combinatorial, Strassen isnt</p>
    <p>More Non-Subtractive Boolean Matrix Mult. Algorithms:</p>
    <p>Atkinson and Santoro: O(n3/ log3/2 n) on a (log n)-word RAM</p>
    <p>Rytter and Basch-Khanna-Motwani: O(n3/ log2 n) on a RAM</p>
    <p>Chan: Four Russians can be implemented on O(n3/ log2 n) on a pointer</p>
    <p>machine</p>
  </div>
  <div class="page">
    <p>Main Result</p>
    <p>The O(n3/ log2 n) matrix multiplication algorithm can be de-amortized</p>
  </div>
  <div class="page">
    <p>Main Result</p>
    <p>The O(n3/ log2 n) matrix multiplication algorithm can be de-amortized</p>
    <p>More precisely, we can:</p>
    <p>Preprocess an n  n matrix A over a finite semiring in O(n2+)</p>
    <p>Such that vector multiplications with A can be done in O(n2/( log n)2)</p>
  </div>
  <div class="page">
    <p>Main Result</p>
    <p>The O(n3/ log2 n) matrix multiplication algorithm can be de-amortized</p>
    <p>More precisely, we can:</p>
    <p>Preprocess an n  n matrix A over a finite semiring in O(n2+)</p>
    <p>Such that vector multiplications with A can be done in O(n2/( log n)2)</p>
    <p>Allows for non-subtractive matrix multiplication to be done on-line</p>
  </div>
  <div class="page">
    <p>Main Result</p>
    <p>The O(n3/ log2 n) matrix multiplication algorithm can be de-amortized</p>
    <p>More precisely, we can:</p>
    <p>Preprocess an n  n matrix A over a finite semiring in O(n2+)</p>
    <p>Such that vector multiplications with A can be done in O(n2/( log n)2)</p>
    <p>Allows for non-subtractive matrix multiplication to be done on-line</p>
    <p>Can be implemented on a pointer machine</p>
  </div>
  <div class="page">
    <p>Main Result</p>
    <p>The O(n3/ log2 n) matrix multiplication algorithm can be de-amortized</p>
    <p>More precisely, we can:</p>
    <p>Preprocess an n  n matrix A over a finite semiring in O(n2+)</p>
    <p>Such that vector multiplications with A can be done in O(n2/( log n)2)</p>
    <p>Allows for non-subtractive matrix multiplication to be done on-line</p>
    <p>Can be implemented on a pointer machine</p>
    <p>This Talk: The Boolean case</p>
  </div>
  <div class="page">
    <p>Preprocessing Phase: The Boolean Case</p>
    <p>Partition the input matrix A into blocks of  log n   log n size:</p>
    <p>A1,1</p>
    <p>A2,1</p>
    <p>A n  log n</p>
    <p>,1</p>
    <p>A1,2 A1, n  log n</p>
    <p>A n  log n</p>
    <p>, n</p>
    <p>log n</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>Ai,j</p>
    <p>log n</p>
    <p>log n</p>
    <p>A =</p>
  </div>
  <div class="page">
    <p>Preprocessing Phase: The Boolean Case</p>
    <p>Build a graph G with parts P1, . . . , Pn/( log n), Q1, . . . , Qn/( log n)</p>
    <p>P2</p>
    <p>...</p>
    <p>...</p>
    <p>...</p>
    <p>...</p>
    <p>P n  log n</p>
    <p>P1 2  log n</p>
    <p>Q1</p>
    <p>Q2</p>
    <p>Q n  log n</p>
    <p>Each part has 2 log n</p>
    <p>vertices, one for each</p>
    <p>possible  log n vector</p>
  </div>
  <div class="page">
    <p>Preprocessing Phase: The Boolean Case</p>
    <p>Edges of G: Each vertex v in each Pi has exactly one edge into each Qj</p>
    <p>log n Qj</p>
    <p>v</p>
    <p>Aj,iv</p>
  </div>
  <div class="page">
    <p>Preprocessing Phase: The Boolean Case</p>
    <p>Edges of G: Each vertex v in each Pi has exactly one edge into each Qj</p>
    <p>log n Qj</p>
    <p>v</p>
    <p>Aj,iv</p>
    <p>Time to build the graph:</p>
    <p>n</p>
    <p>log n</p>
    <p>n</p>
    <p>log n  2 log n  ( log n)2 = O(n2+)</p>
    <p>number</p>
    <p>of Qj</p>
    <p>number</p>
    <p>of Pi</p>
    <p>number</p>
    <p>of nodes</p>
    <p>in Pi</p>
    <p>matrix-vector mult</p>
    <p>of Aj,i and v</p>
  </div>
  <div class="page">
    <p>How to Do Fast Vector Multiplications</p>
    <p>Let v be a column vector. Want: A  v.</p>
  </div>
  <div class="page">
    <p>How to Do Fast Vector Multiplications</p>
    <p>Let v be a column vector. Want: A  v.</p>
    <p>(1) Break up v into  log n sized chunks:</p>
    <p>v =</p>
    <p>v1</p>
    <p>v2 ...</p>
    <p>v n  log n</p>
  </div>
  <div class="page">
    <p>How to Do Fast Vector Multiplications</p>
    <p>(2) For each i = 1, . . . , n/( log n), look up vi in Pi.</p>
  </div>
  <div class="page">
    <p>How to Do Fast Vector Multiplications</p>
    <p>(2) For each i = 1, . . . , n/( log n), look up vi in Pi. 2 log n</p>
    <p>P2</p>
    <p>...</p>
    <p>...</p>
    <p>...</p>
    <p>...</p>
    <p>P n  log n</p>
    <p>P1 2  log n</p>
    <p>Q1</p>
    <p>Q2</p>
    <p>Q n  log n</p>
    <p>v1</p>
    <p>v2</p>
    <p>vn/( log n)</p>
    <p>Takes O(n) time. 9-a</p>
  </div>
  <div class="page">
    <p>How to Do Fast Vector Multiplications</p>
    <p>(2) For each i = 1, . . . , n/( log n), look up vi in Pi. 2 log n</p>
    <p>P2</p>
    <p>...</p>
    <p>...</p>
    <p>...</p>
    <p>...</p>
    <p>P n  log n</p>
    <p>P1 2  log n</p>
    <p>Q1</p>
    <p>Q2</p>
    <p>Q n  log n</p>
    <p>v1</p>
    <p>v2</p>
    <p>vn/( log n)</p>
    <p>Takes O(n) time. 10</p>
  </div>
  <div class="page">
    <p>How to Do Fast Vector Multiplications</p>
    <p>(3) Look up the neighbors of vi, mark each neighbor found.</p>
  </div>
  <div class="page">
    <p>How to Do Fast Vector Multiplications</p>
    <p>(3) Look up the neighbors of vi, mark each neighbor found. 2 log n</p>
    <p>P2</p>
    <p>...</p>
    <p>...</p>
    <p>...</p>
    <p>...</p>
    <p>P n  log n</p>
    <p>P1 2  log n</p>
    <p>Q1</p>
    <p>Q2</p>
    <p>Q n  log n</p>
    <p>v1</p>
    <p>v2</p>
    <p>vn/( log n)</p>
    <p>A1,1  v1</p>
    <p>A2,1  v1</p>
    <p>A n  log n,1</p>
    <p>v1</p>
  </div>
  <div class="page">
    <p>How to Do Fast Vector Multiplications</p>
    <p>(3) Look up the neighbors of vi, mark each neighbor found. 2 log n</p>
    <p>P2</p>
    <p>...</p>
    <p>...</p>
    <p>...</p>
    <p>...</p>
    <p>P n  log n</p>
    <p>P1 2  log n</p>
    <p>Q1</p>
    <p>Q2</p>
    <p>Q n  log n</p>
    <p>v1</p>
    <p>v2</p>
    <p>vn/( log n)</p>
    <p>A1,2  v2</p>
    <p>A2,2  v2</p>
    <p>A n  log n,2</p>
    <p>v2</p>
  </div>
  <div class="page">
    <p>How to Do Fast Vector Multiplications</p>
    <p>(3) Look up the neighbors of vi, mark each neighbor found. 2 log n</p>
    <p>P2</p>
    <p>...</p>
    <p>...</p>
    <p>...</p>
    <p>...</p>
    <p>P n  log n</p>
    <p>P1 2  log n</p>
    <p>Q1</p>
    <p>Q2</p>
    <p>Q n  log n</p>
    <p>v1</p>
    <p>v2</p>
    <p>vn/( log n)</p>
    <p>A1, n log n  vn/( log n)</p>
    <p>A2, n log n  vn/( log n)</p>
    <p>A n  log n,</p>
    <p>n  log n</p>
    <p>vn/( log n) Takes O</p>
    <p>(</p>
    <p>(</p>
    <p>n  log n</p>
    <p>)2 )</p>
  </div>
  <div class="page">
    <p>How to Do Fast Vector Multiplications</p>
    <p>(4) For each Qj , define vj as the OR of all marked vectors in Qj 2 log n</p>
    <p>P2</p>
    <p>...</p>
    <p>...</p>
    <p>...</p>
    <p>...</p>
    <p>P n  log n</p>
    <p>P1 2  log n</p>
    <p>Q1</p>
    <p>Q2</p>
    <p>Q n  log n</p>
    <p>v1</p>
    <p>v2</p>
    <p>vn/( log n)</p>
    <p>v1</p>
    <p>v2</p>
    <p>vn/( log n)</p>
    <p>Takes O(n1+) time 14</p>
  </div>
  <div class="page">
    <p>How to Do Fast Vector Multiplications</p>
    <p>(4) For each Qj , define vj as the OR of all marked vectors in Qj 2 log n</p>
    <p>P2</p>
    <p>...</p>
    <p>...</p>
    <p>...</p>
    <p>...</p>
    <p>P n  log n</p>
    <p>P1 2  log n</p>
    <p>Q1</p>
    <p>Q2</p>
    <p>Q n  log n</p>
    <p>v1</p>
    <p>v2</p>
    <p>vn/( log n)</p>
    <p>v1</p>
    <p>v2</p>
    <p>vn/( log n)</p>
    <p>Takes O(n1+) time 15</p>
  </div>
  <div class="page">
    <p>How to Do Fast Vector Multiplications</p>
    <p>(5) Output v :=</p>
    <p>v1</p>
    <p>v2 ...</p>
    <p>v n  log n</p>
    <p>. Claim: v = A  v.</p>
  </div>
  <div class="page">
    <p>How to Do Fast Vector Multiplications</p>
    <p>(5) Output v :=</p>
    <p>v1</p>
    <p>v2 ...</p>
    <p>v n  log n</p>
    <p>. Claim: v = A  v.</p>
    <p>Proof: By definition, vj = n/( log n)</p>
    <p>i=1 Aj,i  vi.</p>
  </div>
  <div class="page">
    <p>How to Do Fast Vector Multiplications</p>
    <p>(5) Output v :=</p>
    <p>v1</p>
    <p>v2 ...</p>
    <p>v n  log n</p>
    <p>. Claim: v = A  v.</p>
    <p>Proof: By definition, vj = n/( log n)</p>
    <p>i=1 Aj,i  vi.</p>
    <p>Av =</p>
    <p>A1,1    A1,n/( log n) ...</p>
    <p>. . . ...</p>
    <p>An/( log n),1    An/( log n),n/( log n)</p>
    <p>v1 ...</p>
    <p>v n  log n</p>
  </div>
  <div class="page">
    <p>How to Do Fast Vector Multiplications</p>
    <p>(5) Output v :=</p>
    <p>v1</p>
    <p>v2 ...</p>
    <p>v n  log n</p>
    <p>. Claim: v = A  v.</p>
    <p>Proof: By definition, vj = n/( log n)</p>
    <p>i=1 Aj,i  vi.</p>
    <p>Av =</p>
    <p>A1,1    A1,n/( log n) ...</p>
    <p>. . . ...</p>
    <p>An/( log n),1    An/( log n),n/( log n)</p>
    <p>v1 ...</p>
    <p>v n  log n</p>
    <p>= ( n/( log n)</p>
    <p>i=1 A1,i  vi, . . . , n/( log n)</p>
    <p>i=1 A1,n/( log n)  vi) = v .</p>
  </div>
  <div class="page">
    <p>Some Applications</p>
    <p>Can quickly compute the neighbors of arbitrary vertex subsets</p>
    <p>Let A be the adjacency matrix of G = (V, E).</p>
    <p>Let vS be the indicator vector for a S  V .</p>
  </div>
  <div class="page">
    <p>Some Applications</p>
    <p>Can quickly compute the neighbors of arbitrary vertex subsets</p>
    <p>Let A be the adjacency matrix of G = (V, E).</p>
    <p>Let vS be the indicator vector for a S  V .</p>
    <p>Proposition: A  vS is the indicator vector for N (S), the neighborhood of S.</p>
  </div>
  <div class="page">
    <p>Some Applications</p>
    <p>Can quickly compute the neighbors of arbitrary vertex subsets</p>
    <p>Let A be the adjacency matrix of G = (V, E).</p>
    <p>Let vS be the indicator vector for a S  V .</p>
    <p>Proposition: A  vS is the indicator vector for N (S), the neighborhood of S.</p>
    <p>Corollary: After O(n2+) preprocessing, can determine the neighborhood of</p>
    <p>any vertex subset in O(n2/( log n)2) time.</p>
    <p>(One level of BFS in o(n2) time)</p>
  </div>
  <div class="page">
    <p>Graph Queries</p>
    <p>Corollary: After O(n2+) preprocessing, can determine if a given vertex</p>
    <p>subset is an independent set, a vertex cover, or a dominating set, all in</p>
    <p>O(n2/( log n)2) time.</p>
  </div>
  <div class="page">
    <p>Graph Queries</p>
    <p>Corollary: After O(n2+) preprocessing, can determine if a given vertex</p>
    <p>subset is an independent set, a vertex cover, or a dominating set, all in</p>
    <p>O(n2/( log n)2) time.</p>
    <p>Proof: Let S  V .</p>
  </div>
  <div class="page">
    <p>Graph Queries</p>
    <p>Corollary: After O(n2+) preprocessing, can determine if a given vertex</p>
    <p>subset is an independent set, a vertex cover, or a dominating set, all in</p>
    <p>O(n2/( log n)2) time.</p>
    <p>Proof: Let S  V .</p>
    <p>S is dominating  S  N (S) = V .</p>
  </div>
  <div class="page">
    <p>Graph Queries</p>
    <p>Corollary: After O(n2+) preprocessing, can determine if a given vertex</p>
    <p>subset is an independent set, a vertex cover, or a dominating set, all in</p>
    <p>O(n2/( log n)2) time.</p>
    <p>Proof: Let S  V .</p>
    <p>S is dominating  S  N (S) = V .</p>
    <p>S is independent  S  N (S) = .</p>
  </div>
  <div class="page">
    <p>Graph Queries</p>
    <p>Corollary: After O(n2+) preprocessing, can determine if a given vertex</p>
    <p>subset is an independent set, a vertex cover, or a dominating set, all in</p>
    <p>O(n2/( log n)2) time.</p>
    <p>Proof: Let S  V .</p>
    <p>S is dominating  S  N (S) = V .</p>
    <p>S is independent  S  N (S) = .</p>
    <p>S is a vertex cover  V  S is independent.</p>
  </div>
  <div class="page">
    <p>Graph Queries</p>
    <p>Corollary: After O(n2+) preprocessing, can determine if a given vertex</p>
    <p>subset is an independent set, a vertex cover, or a dominating set, all in</p>
    <p>O(n2/( log n)2) time.</p>
    <p>Proof: Let S  V .</p>
    <p>S is dominating  S  N (S) = V .</p>
    <p>S is independent  S  N (S) = .</p>
    <p>S is a vertex cover  V  S is independent.</p>
    <p>Each can be quickly determined from knowing S and N (S).</p>
  </div>
  <div class="page">
    <p>Triangle Detection</p>
  </div>
  <div class="page">
    <p>Triangle Detection</p>
    <p>Problem: Triangle Detection</p>
    <p>Given: Graph G and vertex i.</p>
    <p>Question: Does i participate in a 3-cycle, a.k.a. triangle?</p>
  </div>
  <div class="page">
    <p>Triangle Detection</p>
    <p>Problem: Triangle Detection</p>
    <p>Given: Graph G and vertex i.</p>
    <p>Question: Does i participate in a 3-cycle, a.k.a. triangle?</p>
    <p>Worst Case: Can take (n2) time to check all pairs of neighbors of i</p>
  </div>
  <div class="page">
    <p>Triangle Detection</p>
    <p>Problem: Triangle Detection</p>
    <p>Given: Graph G and vertex i.</p>
    <p>Question: Does i participate in a 3-cycle, a.k.a. triangle?</p>
    <p>Worst Case: Can take (n2) time to check all pairs of neighbors of i</p>
    <p>Corollary: After O(n2+) preprocessing on G, can solve triangle detection</p>
    <p>for arbitrary vertices in O(n2/( log n)2) time.</p>
  </div>
  <div class="page">
    <p>Triangle Detection</p>
    <p>Problem: Triangle Detection</p>
    <p>Given: Graph G and vertex i.</p>
    <p>Question: Does i participate in a 3-cycle, a.k.a. triangle?</p>
    <p>Worst Case: Can take (n2) time to check all pairs of neighbors of i</p>
    <p>Corollary: After O(n2+) preprocessing on G, can solve triangle detection</p>
    <p>for arbitrary vertices in O(n2/( log n)2) time.</p>
    <p>Proof: Given vertex i, let S be its set of neighbors (gotten in O(n) time).</p>
    <p>S is not independent  i participates in a triangle.</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>A preprocessing/multiplication algorithm for matrix-vector multiplication that</p>
    <p>builds on lookup table techniques</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>A preprocessing/multiplication algorithm for matrix-vector multiplication that</p>
    <p>builds on lookup table techniques</p>
    <p>Is there a preprocessing/multiplication algorithm for sparse matrices? Can</p>
    <p>we do multiplication in e.g. O(m/poly(log n) + n),</p>
    <p>where m = number of nonzeroes?</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>A preprocessing/multiplication algorithm for matrix-vector multiplication that</p>
    <p>builds on lookup table techniques</p>
    <p>Is there a preprocessing/multiplication algorithm for sparse matrices? Can</p>
    <p>we do multiplication in e.g. O(m/poly(log n) + n),</p>
    <p>where m = number of nonzeroes?</p>
    <p>Can the algebraic matrix multiplication algorithms (Strassen, etc.) be</p>
    <p>applied to this problem?</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>A preprocessing/multiplication algorithm for matrix-vector multiplication that</p>
    <p>builds on lookup table techniques</p>
    <p>Is there a preprocessing/multiplication algorithm for sparse matrices? Can</p>
    <p>we do multiplication in e.g. O(m/poly(log n) + n),</p>
    <p>where m = number of nonzeroes?</p>
    <p>Can the algebraic matrix multiplication algorithms (Strassen, etc.) be</p>
    <p>applied to this problem?</p>
    <p>Can our ideas be extended to achieve non-subtractive Boolean matrix</p>
    <p>multiplication in o(n3/ log2 n)?</p>
  </div>
  <div class="page">
    <p>Thank you!</p>
  </div>
</Presentation>
