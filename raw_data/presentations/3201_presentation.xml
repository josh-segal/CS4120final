<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>DSCRETE</p>
    <p>Brendan Saltaformaggio, Zhongshu Gu, Xiangyu Zhang, and Dongyan Xu</p>
    <p>Purdue University</p>
    <p>Automatic Rendering of Forensic Information from Memory Images via</p>
    <p>Application Logic Reuse</p>
  </div>
  <div class="page">
    <p>A Cyber-Crime</p>
  </div>
  <div class="page">
    <p>State of the Art</p>
    <p>Finds raw data structure instances in memory image</p>
    <p>Still cannot understand the content of the data structure!</p>
    <p>E.g., images, passwords, formatted/encoded data</p>
    <p>but Limited</p>
  </div>
  <div class="page">
    <p>Content Reverse Engineering</p>
    <p>Observation: Application that defined the data structure contains printing/rendering logic for it too!</p>
    <p>Lets call this logic the P function</p>
    <p>Transforms data structure to formatted application output</p>
  </div>
  <div class="page">
    <p>Content Reverse Engineering Program Code</p>
    <p>struct pdf* my_pdf;</p>
    <p>my_pdf = load_pdf_file();</p>
    <p>main_loop(my_pdf); // User edits PDF</p>
    <p>save_pdf_file(my_pdf);</p>
    <p>exit(0);</p>
    <p>save_pdf_file(struct pdf* ptr)</p>
    <p>{</p>
    <p>char* buf = format(ptr);</p>
    <p>fwrite(buf, );</p>
    <p>}</p>
    <p>Input: Data Structure Instance</p>
    <p>Output: Formatted Content</p>
    <p>P Function save_pdf_file(struct pdf* ptr)</p>
    <p>{</p>
    <p>char* buf = format_pdf(ptr);</p>
    <p>fwrite(buf, );</p>
    <p>}</p>
    <p>Scanner+Renderer</p>
    <p>DSCRETE reuses P to build a scanner+renderer tool P Function</p>
  </div>
  <div class="page">
    <p>P Function save_pdf_file(struct pdf* ptr)</p>
    <p>{</p>
    <p>char* buf = format_pdf(ptr);</p>
    <p>fwrite(buf, );</p>
    <p>}</p>
    <p>Scanner+Renderer</p>
    <p>Intuition: Invalid input will crash P</p>
  </div>
  <div class="page">
    <p>P Function save_pdf_file(struct pdf* ptr)</p>
    <p>{</p>
    <p>char* buf = format_pdf(ptr);</p>
    <p>fwrite(buf, );</p>
    <p>}</p>
    <p>Scanner+Renderer</p>
    <p>Present every offset of a memory image to P</p>
    <p>Valid output is reported</p>
  </div>
  <div class="page">
    <p>Binary to Scanner+Renderer</p>
    <p>In the Forensics Lab, investigators recover the binary from the suspects computer</p>
    <p>Based on dynamic binary analysis, DSCRETE then builds a scanner+renderer tool in 2 steps</p>
    <p>The resulting scanner+renderer tool can be reused in all future investigations of that application</p>
  </div>
  <div class="page">
    <p>Step 1: Find the P Function</p>
    <p>Execute the binary from the suspects computer</p>
    <p>Slicing techniques find printing/rendering component Select which output functions emit the evidence</p>
    <p>E.g. fwrite(  ) that saved PDF file</p>
    <p>DSCRETE saves a memory snapshot during output function(s)</p>
  </div>
  <div class="page">
    <p>Step 2: Isolate Ps Entry Point</p>
    <p>DSCRETE finds candidates for the entry point</p>
    <p>Candidates must: 1. Take a heap pointer as input 2. All selected output/rendering functions must depend on it</p>
    <p>Execute the binary again &amp;</p>
    <p>Use Cross-State Execution to find correct candidates</p>
  </div>
  <div class="page">
    <p>Identified Candidate</p>
    <p>Cross-State Execution Program Code</p>
    <p>struct pdf* my_pdf;</p>
    <p>my_pdf = load_pdf_file();</p>
    <p>main_loop(my_pdf); // User edits PDF</p>
    <p>save_pdf_file(my_pdf);</p>
    <p>exit(0);</p>
    <p>save_pdf_file(struct pdf* ptr)</p>
    <p>{</p>
    <p>char* buf = format(ptr);</p>
    <p>fwrite(buf, );</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Cross-State Execution Program Code</p>
    <p>struct pdf* my_pdf;</p>
    <p>my_pdf = load_pdf_file();</p>
    <p>main_loop(my_pdf); // User edits PDF</p>
    <p>save_pdf_file(my_pdf);</p>
    <p>exit(0);</p>
    <p>save_pdf_file(struct pdf* ptr)</p>
    <p>{</p>
    <p>char* buf = format(ptr);</p>
    <p>fwrite(buf, );</p>
    <p>}</p>
    <p>Apps Memory</p>
  </div>
  <div class="page">
    <p>Cross-State Execution Program Code</p>
    <p>struct pdf* my_pdf;</p>
    <p>my_pdf = load_pdf_file();</p>
    <p>main_loop(my_pdf); // User edits PDF</p>
    <p>save_pdf_file(my_pdf);</p>
    <p>exit(0);</p>
    <p>save_pdf_file(struct pdf* ptr)</p>
    <p>{</p>
    <p>char* buf = format(ptr);</p>
    <p>fwrite(buf, );</p>
    <p>}</p>
    <p>Apps Memory</p>
  </div>
  <div class="page">
    <p>Cross-State Execution Program Code</p>
    <p>struct pdf* my_pdf;</p>
    <p>my_pdf = load_pdf_file();</p>
    <p>main_loop(my_pdf); // User edits PDF</p>
    <p>save_pdf_file(my_pdf);</p>
    <p>exit(0);</p>
    <p>save_pdf_file(struct pdf* ptr)</p>
    <p>{</p>
    <p>char* buf = format(ptr);</p>
    <p>fwrite(buf, );</p>
    <p>}</p>
    <p>Apps Memory</p>
    <p>Begin Cross-State Execution!</p>
    <p>Memory Snapshot (from Step 1)</p>
  </div>
  <div class="page">
    <p>Cross-State Execution Program Code</p>
    <p>struct pdf* my_pdf;</p>
    <p>my_pdf = load_pdf_file();</p>
    <p>main_loop(my_pdf); // User edits PDF</p>
    <p>save_pdf_file(my_pdf);</p>
    <p>exit(0);</p>
    <p>save_pdf_file(struct pdf* ptr)</p>
    <p>{</p>
    <p>char* buf = format(ptr);</p>
    <p>fwrite(buf, );</p>
    <p>}</p>
    <p>Apps Memory</p>
    <p>Memory Snapshot (from Step 1)</p>
  </div>
  <div class="page">
    <p>Cross-State Execution Program Code</p>
    <p>struct pdf* my_pdf;</p>
    <p>my_pdf = load_pdf_file();</p>
    <p>main_loop(my_pdf); // User edits PDF</p>
    <p>save_pdf_file(my_pdf);</p>
    <p>exit(0);</p>
    <p>save_pdf_file(struct pdf* ptr)</p>
    <p>{</p>
    <p>char* buf = format(ptr);</p>
    <p>fwrite(buf, );</p>
    <p>}</p>
    <p>Apps Memory</p>
    <p>Memory Snapshot (from Step 1)</p>
    <p>Key Observation: A Correct Candidate will</p>
    <p>output the PDF from Step 1</p>
  </div>
  <div class="page">
    <p>Reused Application Logic</p>
    <p>Correct candidate is packed into scanner+renderer tool</p>
    <p>Presents each offset in suspects memory image to P Reports natural application output as evidence</p>
    <p>This tool can be used in all future investigations of this app.</p>
  </div>
  <div class="page">
    <p>Lets catch that criminal</p>
  </div>
  <div class="page">
    <p>Evaluation App. Data Truth Found FP FP% FN FN%</p>
    <p>convert Image 1 1 0 0% 0 0%</p>
    <p>gnome-paint Image 51 51 0 0% 0 0%</p>
    <p>gThumb Image 382 381 0 0% 1 0.4%</p>
    <p>Filename 63 63 0 0% 0 0%</p>
    <p>gnome-screenshot Screenshot Image 1 1 0 0% 0 0%</p>
    <p>Nginx Request log 6 6 0 0% 0 0%</p>
    <p>PDFedit PDF 1 1 0 0% 0 0%</p>
    <p>top Process data 382 382 0 0% 0 0%</p>
    <p>Xfig Figure 1 1 0 0% 0 0%</p>
    <p>CenterIM Username &amp; Password 1 1 0 0% 0 0%</p>
    <p>darktable SQL query 1 1 0 0% 0 0%</p>
    <p>Firefox SQL query 1 1 0 0% 0 0%</p>
    <p>SQL log 788 1384 502 40% 35 4%</p>
  </div>
  <div class="page">
    <p>Conclusion Identified the Content Reverse Engineering problem in forensics</p>
    <p>DSCRETE leverages binary logic reuse to automatically locate data structures in memory images and reverse engineer content</p>
    <p>Highly effective at recovering many forms of digital evidence</p>
    <p>Lots of opportunities to improve and apply DSCRETE, and many future research directions!</p>
  </div>
  <div class="page">
    <p>Thank you!</p>
    <p>Questions? Brendan Saltaformaggio bsaltafo@cs.purdue.edu</p>
  </div>
</Presentation>
