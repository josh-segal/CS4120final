<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Automated Concurrency-Bug Fixing</p>
    <p>Guoliang Jin, Wei Zhang, Dongdong Deng, Ben Liblit, and Shan Lu. University of WisconsinMadison</p>
    <p>CFix</p>
  </div>
  <div class="page">
    <p>Bugs Need to be Fixed</p>
    <p>Buggy software is an unfortunate fact;  There are many bugs</p>
    <p>to be fixed.</p>
    <p>Software quality does not improve until bugs are fixed;  Human patches are</p>
    <p>often buggy.</p>
    <p>Automated fixing is desired</p>
  </div>
  <div class="page">
    <p>What is the correct behavior?  Usually requires developers knowledge.</p>
    <p>How to get the correct behavior?  Change program states under bug-triggering inputs;  No change to program states under other inputs.</p>
    <p>Automated Fixing is Difficult</p>
  </div>
  <div class="page">
    <p>Synchronization mistakes in multi-threaded programs.</p>
    <p>They are severe:  Caused real-world problems: Facebook IPO, etc;  Increasingly an issue in this multi-core era.</p>
    <p>They are difficult to reason about and fix manually:  Concurrency-bug fixing is time consuming[LuASPLOS08];  Concurrency-bug patches are the most error-prone[YinFSE11].</p>
    <p>Concurrency Bugs</p>
  </div>
  <div class="page">
    <p>What is the correct behavior?  The program state is already correct as long as the buggy interleaving does not occur.</p>
    <p>How to get the correct behavior?  Only need to disable failure-inducing interleavings;  Can leverage well-defined synchronization operations.</p>
    <p>Concurrency Bugs are Easier to Fix Automatically</p>
  </div>
  <div class="page">
    <p>How to handle the huge variety of bugs?</p>
    <p>How to know the root cause of a bug?</p>
    <p>How to ensure correctness?  How to maintain performance?  How to achieve patch simplicity?</p>
    <p>How to effectively test the patches?</p>
    <p>Challenges</p>
  </div>
  <div class="page">
    <p>. . .</p>
    <p>. . .</p>
    <p>CFix Overview</p>
    <p>Patched binary</p>
    <p>Patched binary</p>
    <p>Patched binary</p>
    <p>Patched binary</p>
    <p>Merged binary</p>
    <p>Bug Understanding</p>
    <p>Run-time Support</p>
    <p>Fix-Strategy Design</p>
    <p>Synchronization Enforcement</p>
    <p>Patch Merging</p>
    <p>Patch Testing &amp; Selection</p>
    <p>Buggy binary + Input</p>
    <p>. . .</p>
    <p>. . . Selected binary Selected binary</p>
    <p>Atomicity Problem</p>
    <p>Order Problem</p>
    <p>Atomicity Problem</p>
    <p>Order Problem</p>
    <p>Bug report Bug report</p>
    <p>Final patched binary</p>
  </div>
  <div class="page">
    <p>A technique that enforces order relationship: OFix;</p>
    <p>A framework that assembles a set of techniques to automate the whole bugfixing process: CFix.</p>
    <p>Contributions</p>
    <p>Bug Understanding</p>
    <p>Run-time Support</p>
    <p>Fix-Strategy Design</p>
    <p>Synchronization Enforcement</p>
    <p>Patch Merging</p>
    <p>Patch Testing &amp; Selection</p>
  </div>
  <div class="page">
    <p>CFix: Automated Concurrency-Bug Fixing</p>
    <p>Bug Understanding</p>
    <p>Fix-Strategy Design</p>
    <p>Patch Testing &amp; Selection</p>
    <p>Synchronization Enforcement</p>
    <p>Patch Merging Run-time Support</p>
    <p>Challenge:  Concurrency bugs are</p>
    <p>difficult to reason about. Solution:  Leverage existing bug</p>
    <p>detectors.</p>
  </div>
  <div class="page">
    <p>Use four types of different detectors:</p>
    <p>Bug Understanding</p>
    <p>atomicity violation detectors ParkASPLOS09, FlanaganPOPL04, LuASPLOS06, ChewEuroSys10</p>
    <p>order violation detectors ZhangASPLOS10, LuciaMICRO09, YuISCA09, GaoASPLOS11</p>
    <p>data race detectors SenPLDI08, SavageTOCS97, YuSOSP05, EricksonOSDI10, KasikciASPLOS10</p>
    <p>abnormal data flow detectors ZhangASPLOS11, ShiOOPSLA10</p>
    <p>p r c</p>
    <p>A B</p>
    <p>Wb R Wg</p>
    <p>I1 I2</p>
    <p>Bug report could be imperfect.</p>
  </div>
  <div class="page">
    <p>CFix: Automated Concurrency-Bug Fixing</p>
    <p>Bug Understanding</p>
    <p>Fix-Strategy Design</p>
    <p>Patch Testing &amp; Selection</p>
    <p>Synchronization Enforcement</p>
    <p>Patch Merging Run-time Support</p>
    <p>Challenges:  Huge variety of bugs;  Inaccurate root cause. Solution:  Design a set of fix strategies</p>
    <p>using a combination of mutual exclusion enforcement; order relationship enforcement.</p>
  </div>
  <div class="page">
    <p>Fix-Strategy for Atomicity-Violation Detectors Example 1</p>
    <p>Thread 1</p>
    <p>if (ptr != NULL) { ptr-&gt;field = 1; }</p>
    <p>ptr = NULL;</p>
    <p>Thread 2</p>
  </div>
  <div class="page">
    <p>Fix-Strategy for Atomicity-Violation Detectors Example 2</p>
    <p>Thread 1</p>
    <p>ptr-&gt;field = 1; ptr-&gt;field = 1;</p>
    <p>ptr = NULL;</p>
    <p>Thread 2</p>
  </div>
  <div class="page">
    <p>Fix-Strategies</p>
    <p>p r c</p>
    <p>Wb R Wg</p>
    <p>OV Detector</p>
    <p>AV Detector</p>
    <p>Race Detector</p>
    <p>DU Detector</p>
    <p>I1 I2</p>
    <p>A B</p>
  </div>
  <div class="page">
    <p>CFix: Automated Concurrency-Bug Fixing</p>
    <p>Bug Understanding</p>
    <p>Fix-Strategy Design</p>
    <p>Patch Testing &amp; Selection</p>
    <p>Synchronization Enforcement</p>
    <p>Patch Merging Run-time Support</p>
    <p>Challenges:  Correctness, performance,</p>
    <p>simplicity. Solution:  Mutual exclusion</p>
    <p>enforcement: AFix [JinPLDI11]  Order relationship</p>
    <p>enforcement: OFix.</p>
  </div>
  <div class="page">
    <p>use read</p>
    <p>initialization</p>
    <p>destroy</p>
    <p>Order Relationship Enforcement: OFix</p>
    <p>Ai</p>
    <p>A B Aj</p>
    <p>?</p>
    <p>firstA-B</p>
    <p>allA-B</p>
    <p>A1</p>
    <p>B</p>
    <p>An</p>
    <p>A1</p>
    <p>B</p>
    <p>An</p>
  </div>
  <div class="page">
    <p>signal in A-threads:  A-thread signals when it will not execute more A;  Each A-thread signals only once;  Each A-thread signals as soon as possible.</p>
    <p>wait before B:  B Proceeds when each A-thread has signaled.</p>
    <p>OFix allA-B Enforcement: Principles</p>
  </div>
  <div class="page">
    <p>OFix allA-B Enforcement: A side How to identify the last A instance in one thread</p>
    <p>A</p>
    <p>. . .; for (. . .) . . . ; // A . . .;</p>
    <p>Each thread that execute A:  exactly once as soon as it can execute no more A.</p>
  </div>
  <div class="page">
    <p>OFix allA-B Enforcement: A side How to identify the last thread that executes A</p>
    <p>void main() { for (. . .) thread_create(thr_main); . . .; } void ofix_signal() {</p>
    <p>mutex_lock(L); --; if ( == 0) cond_broadcast(con); mutex_unlock(L); }</p>
    <p>void thr_main() { for (. . .) . . . ; // A . . .; }</p>
    <p>counter for signal threads</p>
    <p>=1</p>
    <p>++</p>
    <p>thread _create A</p>
  </div>
  <div class="page">
    <p>Safe to execute only when is 0.</p>
    <p>Give up if OFix knows that it introduces new deadlock.  Timed wait-operation to mask potential deadlocks.</p>
    <p>OFix allA-B Enforcement: B side</p>
    <p>B</p>
    <p>void ofix_wait() { mutex_lock(L); if ( != 0) cond_timedwait(con, L, t); mutex_unlock(L); }</p>
  </div>
  <div class="page">
    <p>is not needed if B does not execute in the same run as .</p>
    <p>Significantly improve patch simplicity.</p>
    <p>OFix allA-B Enforcement: Simplification</p>
    <p>void main() { if (. . .) { OFixSignal; exit(1); } thread_create(thr_main, . . .); // A . . .; // B }</p>
  </div>
  <div class="page">
    <p>Basic enforcement</p>
    <p>When A may not execute:  Add a safety-net of signal</p>
    <p>with allA-B algorithm.</p>
    <p>OFix firstA-B</p>
    <p>B</p>
    <p>void ofix_wait_b() { mutex_lock(L); if (flag != true) cond_timedwait(con, L, t); mutex_unlock(L); }</p>
    <p>void ofix_signal_b() { if (flag != true) { flag = true; mutex_lock(L); cond_broadcast(con); mutex_unlock(L); } }</p>
    <p>A</p>
  </div>
  <div class="page">
    <p>CFix: Automated Concurrency-Bug Fixing</p>
    <p>Bug Understanding</p>
    <p>Fix-Strategy Design</p>
    <p>Patch Testing &amp; Selection</p>
    <p>Synchronization Enforcement</p>
    <p>Patch Merging Run-time Support</p>
    <p>Challenge:  Effective multi-thread</p>
    <p>software testing Solution:  CFix-patch oriented testing</p>
  </div>
  <div class="page">
    <p>Patch Testing Principles</p>
    <p>Prune incorrect patches:  Patches causing failures due to incorrect root causes, etc.</p>
    <p>Prune slow patches  Prune complicated patches</p>
    <p>Not exhaustive testing, but patch oriented testing.</p>
  </div>
  <div class="page">
    <p>Run Once without External Perturbation</p>
    <p>Reject if there is a time-out or failure.  Patches fixing wrong root cause:  Make software to fail deterministically.</p>
    <p>Thread 1</p>
    <p>ptr-&gt;field = 1; ptr-&gt;field = 1;</p>
    <p>Thread 2</p>
    <p>ptr = NULL;</p>
  </div>
  <div class="page">
    <p>Implicit Bad Patch</p>
    <p>A failure in patch_b implies a failure in patch_a:  If patch_a is less restrictive than patch_b.</p>
    <p>Helpful to prune patch_a:  Traditional testing may not find the failure in patch_a.</p>
    <p>a Mutual Exclusion</p>
    <p>b c Order Relationships</p>
  </div>
  <div class="page">
    <p>Bug Understanding</p>
    <p>Fix-Strategy Design</p>
    <p>Patch Testing &amp; Selection</p>
    <p>Synchronization Enforcement</p>
    <p>Patch Merging Run-time Support</p>
    <p>One programming mistake usually leads to multiple bugs.</p>
    <p>Heuristics to merge patches for related bugs.</p>
    <p>CFix: Automated Concurrency-Bug Fixing</p>
  </div>
  <div class="page">
    <p>Bug Understanding</p>
    <p>Fix-Strategy Design</p>
    <p>Patch Testing &amp; Selection</p>
    <p>Synchronization Enforcement</p>
    <p>Patch Merging</p>
    <p>Run-time Support</p>
    <p>To understand whether there is a deadlock underlying time-out.</p>
    <p>Low-overhead, and suitable for production runs.</p>
    <p>CFix: Automated Concurrency-Bug Fixing</p>
  </div>
  <div class="page">
    <p>Methodology</p>
    <p>APP. PBZIP2</p>
    <p>x264 FFT</p>
    <p>HTTrack Mozilla - 1</p>
    <p>transmission ZSNES Apache</p>
    <p>MySQL - 1 MySQL - 2 Mozilla - 2 Cherokee Mozilla - 3</p>
    <p>AV Detector OV Detector RA Detector DU Detector</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>APP. PBZIP2</p>
    <p>x264 FFT</p>
    <p>HTTrack Mozilla - 1</p>
    <p>transmission ZSNES Apache</p>
    <p>MySQL - 1 MySQL - 2 Mozilla - 2 Cherokee Mozilla - 3</p>
    <p>AV Detector OV Detector RA Detector DU Detector</p>
    <p># of Ops 5 7 5 2 2 2 3 3 5 9 3 2 5</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>CFix uses some heuristics, with good results in practice:  Fixing root cause without requiring detectors to report it;  Small overhead;  Good simplicity.</p>
    <p>Concurrency bugs are feasible to be fixed automatically:  By removing bad interleavings;  Must be careful in the details.</p>
  </div>
  <div class="page">
    <p>Questions on CFix?</p>
    <p>Bug Understanding</p>
    <p>Fix-Strategy Design</p>
    <p>Patch Testing &amp; Selection</p>
    <p>Synchronization Enforcement</p>
    <p>Patch Merging Run-time Support</p>
    <p>Its 2012. Is this the end of my world?</p>
  </div>
</Presentation>
