<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Control-Flow Integrity For COTS Binaries</p>
    <p>Mingwei Zhang and R. Sekar Stony Brook University USENIX Security 2013</p>
    <p>Work supported in part by grants from AFOSR, NSF and ONR</p>
  </div>
  <div class="page">
    <p>Talk Outline</p>
    <p>Motivation</p>
    <p>Static analysis</p>
    <p>Binary instrumentation</p>
    <p>CFI properties and metric</p>
    <p>Evaluation</p>
    <p>Summary</p>
  </div>
  <div class="page">
    <p>Background</p>
    <p>What is Control-Flow Integrity?</p>
    <p>Program execution follows a statically</p>
    <p>constructed control-flow graph (CFG)</p>
    <p>Why CFI?</p>
    <p>a foundation for other low-level code defenses,</p>
    <p>e.g., SFI, sandboxing untrusted code,</p>
    <p>defeats low level attacks on binaries</p>
    <p>Code injection, ROP, JOP,</p>
    <p>deterministic, not probabilistic defense</p>
  </div>
  <div class="page">
    <p>Motivation for this work</p>
    <p>Many previous works closely related to CFI</p>
    <p>CFI [Abadi et al 05, Abadi et al 2009, Zhang et al 2013]  Instruction bundling [MaCamant et al 2008, Yee et al 2009]  Indexed Hooks [ 2011], Control-flow locking [Bletsch et al 2011]  MoCFI [Davi et al 2012], Reins [Wartell et al 2012]</p>
    <p>Require compiler support, or binaries that</p>
    <p>contain relocation, symbol, or debug info</p>
    <p>Do not provide complete protection</p>
    <p>Leave out executable, libraries, or the loader</p>
    <p>Have a difficult time balancing strength of</p>
    <p>protection and compatibility with large binaries</p>
  </div>
  <div class="page">
    <p>Preview of Results</p>
    <p>Robust on large and low-level binaries</p>
    <p>glibc, gimp-2.6, adobe reader 9, firefox 5</p>
    <p>executables as well as libraries</p>
    <p>Compatible yet strong policy</p>
    <p>93% of ROP/JOP gadgets</p>
    <p>Good performance</p>
    <p>~10% on CPU-intensive C/C++ benchmark (SPEC 2006),</p>
    <p>(~4% if restricted to C-programs)</p>
    <p>Limitations</p>
    <p>Does not support obfuscated binaries or malware</p>
    <p>No runtime code generation or JIT (yet)</p>
    <p>Implemented for 32-bit Linux, tested with gcc and LLVM</p>
  </div>
  <div class="page">
    <p>Key Challenges</p>
    <p>Disassembly and Static analysis of COTS binaries</p>
    <p>Robust static binary instrumentation</p>
    <p>Without breaking low-level code</p>
    <p>Transparency for position-independent code, C++</p>
    <p>exceptions, etc.</p>
    <p>Modular instrumentation</p>
    <p>Applied to executables and libraries</p>
    <p>Enables sharing library code across many processes</p>
    <p>Assess compatibility/strength tradeoff</p>
  </div>
  <div class="page">
    <p>Disassembly Errors</p>
    <p>Disassembly of non-code</p>
    <p>Tolerate these errors by leaving original code in place</p>
    <p>Incorrect disassembly of legitimate code</p>
    <p>Instruction decoding errors (not a real challenge)</p>
    <p>Instruction boundary errors</p>
    <p>Harmful  our technique geared to find and repair them</p>
    <p>Failure to disassemble (we avoid this)</p>
  </div>
  <div class="page">
    <p>Disassembly Algorithm</p>
    <p>invalid opcode</p>
    <p>direct jump/call outside module address</p>
    <p>direct control into insn</p>
    <p>Identify gap: data/padding disassembled as code</p>
    <p>Scan backward to preceding unconditional jump</p>
    <p>Scan forward to next direct or indirect target</p>
    <p>Indirect targets obtained from static analysis</p>
  </div>
  <div class="page">
    <p>Static Analysis</p>
    <p>Code pointers are needed:</p>
    <p>to correct disassembly errors</p>
    <p>to constrain indirect control flow (ICF) targets</p>
    <p>We classify code pointers into categories:</p>
    <p>Code Pointer Constants (CK)</p>
    <p>Computed Code Pointers (CC)</p>
    <p>Exception handlers (EH)</p>
    <p>Exported symbols (ES)</p>
    <p>Return addresses (RA)</p>
  </div>
  <div class="page">
    <p>Static Analysis</p>
    <p>Code pointer constants</p>
    <p>Scan for constants :</p>
    <p>at any bye offset within code and data segments</p>
    <p>fall within the current module</p>
    <p>point to a valid instruction boundary</p>
    <p>Computed code pointers</p>
    <p>Does not support arbitrary arithmetic, but targets</p>
    <p>jump tables</p>
    <p>Uses static analysis of code within a fixed-size window</p>
    <p>preceding indirect jump</p>
  </div>
  <div class="page">
    <p>Talk Outline</p>
    <p>Motivation</p>
    <p>Static analysis</p>
    <p>Binary instrumentation</p>
    <p>CFI properties and metric</p>
    <p>Evaluation</p>
    <p>Summary</p>
  </div>
  <div class="page">
    <p>Instrumented Module</p>
    <p>Translating function pointers</p>
    <p>Appear as constants in code, but cant statically translate</p>
    <p>Solution (from DBT ): Runtime address translation</p>
    <p>Full transparency: all code pointers, incl. dynamically generated ones, target original code [Bruening 2004]</p>
    <p>Important for supporting unusual uses of code pointers</p>
    <p>To compute data addresses (PIC-code , data embedded in</p>
    <p>code)</p>
    <p>C++ exception handling</p>
    <p>ELF header</p>
    <p>phdr</p>
    <p>Original code</p>
    <p>metadata,</p>
    <p>.rodata</p>
    <p>Original data</p>
    <p>..bss</p>
    <p>New code</p>
    <p>New data</p>
  </div>
  <div class="page">
    <p>Static Instrumentation for CFI</p>
    <p>Goal: constrain branch targets to those</p>
    <p>determined by static analysis</p>
    <p>Direct branches: nothing to be done</p>
    <p>Indirect branches: check against a table of (statically</p>
    <p>computed) valid targets</p>
    <p>Key observation</p>
    <p>CFI enforcement can be combined with address translation!</p>
  </div>
  <div class="page">
    <p>Modularity</p>
    <p>Intra-module control transfer: MTT</p>
    <p>...</p>
    <p>.new_text: func_entry:  #ret jmp retjmp_lkup</p>
    <p>push L_next jmp call_lkup ...</p>
    <p>call_lkup:  .data MTT1</p>
    <p>retjmp_lkup:  .data MTT2</p>
    <p>executable</p>
    <p>What if the target is out side of the module ?</p>
  </div>
  <div class="page">
    <p>Modularity</p>
    <p>Inter-module control transfer: GTT</p>
    <p>...</p>
    <p>.new_text:</p>
    <p>#call to libfunc push L_next jmp call_lkup</p>
    <p>call_lkup_glbl</p>
    <p>retjmp_lkup_glbl</p>
    <p>...</p>
    <p>.new_text:</p>
    <p>... libfunc: ... ... #return jmp retjmp_lkup</p>
    <p>call_lkup:  .data MTT1</p>
    <p>retjmp_lkup:  .data MTT2</p>
    <p>call_lkup:  .data MTT1</p>
    <p>retjmp_lkup:  .data MTT2</p>
    <p>libc.so.6executable</p>
    <p>Global Table GTT</p>
    <p>(initialized by ld.so)</p>
    <p>exe mtt2mtt1</p>
    <p>libc mtt2mtt1</p>
    <p>update of GTT is done in ld.so</p>
  </div>
  <div class="page">
    <p>Modularity</p>
    <p>Code injection: null GTT entry</p>
    <p>...</p>
    <p>.new_text:</p>
    <p>#call to libfunc push L_next jmp call_lkup</p>
    <p>call_lkup_glbl</p>
    <p>retjmp_lkup_glbl</p>
    <p>...</p>
    <p>.new_text:</p>
    <p>... libfunc: ... ... #return jmp retjmp_lkup</p>
    <p>call_lkup:  .data MTT1</p>
    <p>retjmp_lkup:  .data MTT2</p>
    <p>call_lkup:  .data MTT1</p>
    <p>retjmp_lkup:  .data MTT2</p>
    <p>libc.so.6executable</p>
    <p>Global Table GTT</p>
    <p>(initialized by ld.so)</p>
    <p>exe mtt2mtt1</p>
    <p>libc mtt2mtt1</p>
    <p>GTT only maps code !</p>
  </div>
  <div class="page">
    <p>Talk Outline</p>
    <p>Motivation</p>
    <p>Static analysis</p>
    <p>Binary instrumentation</p>
    <p>CFI properties and metric</p>
    <p>Evaluation</p>
    <p>Summary</p>
  </div>
  <div class="page">
    <p>Basic version of CFI</p>
    <p>return: target next of call  call/jmp: target any function whose address is taken</p>
    <p>Obtainable from relocation info (reloc-CFI)  matches implementation described in [Abadi et al 2005]</p>
    <p>How to cope with missing relocation info?</p>
    <p>Use static analysis to over-approximate function addresses taken</p>
    <p>Strict-CFI</p>
  </div>
  <div class="page">
    <p>CFI Real-World Exceptions</p>
    <p>special returns</p>
    <p>a. as indirect jumps (lazy binding in ld.so)</p>
    <p>b. going to function entries (setcontext(2))</p>
    <p>c. not going just after call (C++ exception)</p>
    <p>calls used to get PC address</p>
    <p>jump as a replacement of return</p>
  </div>
  <div class="page">
    <p>binCFI Policy</p>
    <p>bin-CFI Returns (RET), Indirect Jumps (IJ)</p>
    <p>Indirect Calls (IC), PLT jumps (PLT)</p>
    <p>Return addresses (RA)</p>
    <p>Y</p>
    <p>Exception handling addresses (EH)</p>
    <p>Y (C++)</p>
    <p>Exported symbol addresses (ES)</p>
    <p>Y</p>
    <p>Code pointer constants (CK)</p>
    <p>Y (C++, Context switch)</p>
    <p>Y (GNU_IFUNC)</p>
    <p>Computed code addresses (CC)</p>
    <p>Y (return as jump)</p>
    <p>Y (GNU_IFUNC)</p>
    <p>Well, is this policy too weak ?</p>
  </div>
  <div class="page">
    <p>Measuring Protection Strength</p>
    <p>Average Indirect target Reduction (AIR)</p>
    <p>a. T j</p>
    <p>: number of possible targets of jth ICF branch</p>
    <p>b. S: all possible target addresses (size of binary)</p>
    <p>AIR is a general metric that can be applied to other control-flow containment approaches</p>
  </div>
  <div class="page">
    <p>Coarser versions of CFI</p>
    <p>bundle-CFI:</p>
    <p>all ICF targets aligned on 2n-byte boundary, n = 4 (PittSFIeld) or 5 (Native Client)</p>
    <p>instr-CFI: the most basic CFI  all ICFTs target instruction boundaries</p>
  </div>
  <div class="page">
    <p>AIR metric (single module)</p>
    <p>Name Reloc CFI</p>
    <p>Strict CFI</p>
    <p>Bin CFI</p>
    <p>Bundle CFI</p>
    <p>Instr CFI</p>
    <p>perlbench 98.49% 98.44% 97.89% 95.41% 67.33%</p>
    <p>bzip2 99.55% 99.49% 99.37% 95.65% 78.59%</p>
    <p>gcc 98.73% 98.71% 98.34% 95.86% 80.63%</p>
    <p>gobmk 99.40% 99.40% 99.20% 97.75% 89.08%</p>
    <p>... ... ... ... ... ...</p>
    <p>average 99.13% 99.08% 98.86% 96.04% 79.27%</p>
    <p>Loss due to use of static analysis is negligible  Loss due to binCFI relaxation is very small</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Disassembly testing</p>
    <p>Real world program testing</p>
    <p>Gadget elimination</p>
  </div>
  <div class="page">
    <p>Disassembly Testing</p>
    <p>Module Package Size Instruction# errors</p>
    <p>libxul.so firefox-5.0 26M 4.3M 0</p>
    <p>gimp-console-2.6 gimp-2.6.5 7.7M 385K 0</p>
    <p>libc.so glibc-2.13 8.1M 301K 0</p>
    <p>libnss3.so firefox-5.0 4.1M 235K 0</p>
    <p>... ... ... ... ...</p>
    <p>Total 58M 5.84M 0</p>
    <p>diff compiler generated assembly and our disassembly</p>
  </div>
  <div class="page">
    <p>Real world program testing</p>
    <p>Application Name Experiment</p>
    <p>firefox 5 (no JIT) open web pages</p>
    <p>acroread9 open 20 pdf files; scroll;print;zoom in/out</p>
    <p>gimp-2.6 load jpg picture, crop, blur, sharpen, etc.</p>
    <p>Wireshark v1.6.2 capture packets on LAN for 20 minutes</p>
    <p>lyx v2.0.0 open a large report; edit; convert to pdf/dvi/ps</p>
    <p>mplayer 4.6.1 play an mp3 file</p>
    <p>... .........</p>
    <p>Total: 12 real world programs</p>
  </div>
  <div class="page">
    <p>Gadget Elimination</p>
  </div>
  <div class="page">
    <p>Optimizations</p>
    <p>Branch prediction: Optimized translation of calls and returns, avoiding indirect jumps</p>
    <p>Jump table: Avoid runtime address translation in jump tables</p>
    <p>Transparency optimization: Avoid address translation for returns (but check validity)</p>
    <p>Dynamic optimization for returns: Fast check for most frequent target</p>
  </div>
  <div class="page">
    <p>Effect of Optimizations</p>
  </div>
  <div class="page">
    <p>Questions?</p>
  </div>
</Presentation>
