<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>A Performance Evaluation of Open Source Erasure Codes</p>
    <p>for Storage Applications</p>
    <p>James S. Plank Catherine D. Schuman</p>
    <p>(Tennessee)</p>
    <p>Usenix FAST February 27, 2009</p>
    <p>Jianqiang Luo Lihao Xu</p>
    <p>(Wayne State)</p>
    <p>Zooko Wilcox-O'Hearn</p>
  </div>
  <div class="page">
    <p>My Perspective on Storage</p>
    <p>Coding Theorist</p>
    <p>A code C over FFbq is FFq-linear if C is a vector</p>
    <p>space over FFq...</p>
    <p>Storage System Programmers</p>
    <p>Woof?</p>
  </div>
  <div class="page">
    <p>My Perspective on Storage</p>
    <p>Storage System Programmers</p>
    <p>Open Source Libraries</p>
    <p>Here's your</p>
    <p>starting point!</p>
    <p>wag</p>
    <p>wag</p>
    <p>wag</p>
    <p>wag</p>
    <p>wag</p>
    <p>wag</p>
    <p>wag</p>
    <p>wag</p>
    <p>wag</p>
    <p>wag</p>
    <p>wag</p>
    <p>wag</p>
  </div>
  <div class="page">
    <p>The Point of This Talk</p>
    <p>To inform you of the current state of</p>
    <p>open-source erasure code libraries.</p>
    <p>To compare how various codes and implementations</p>
    <p>perform.</p>
    <p>To understand some of the implications of</p>
    <p>various design decisions.</p>
    <p>When you go home, you can converse</p>
    <p>about erasure codes with your</p>
    <p>friends &amp; families.</p>
  </div>
  <div class="page">
    <p>Erasure Coding Basics/Nomenclature</p>
    <p>You start with n disks:</p>
    <p>n</p>
  </div>
  <div class="page">
    <p>Erasure Coding Basics/Nomenclature</p>
    <p>Partition them into k data and m coding disks.</p>
    <p>n</p>
    <p>k m</p>
    <p>Call it what you want: k of n.</p>
    <p>k and m, [k,m].</p>
    <p>But please use k, m and n.</p>
  </div>
  <div class="page">
    <p>Encoding</p>
    <p>Erasure Coding Basics/Nomenclature</p>
    <p>n</p>
    <p>k m</p>
    <p>You encode by calculating the m coding disks from the data.</p>
  </div>
  <div class="page">
    <p>Erasure Coding Basics/Nomenclature</p>
    <p>n</p>
    <p>k m</p>
    <p>You decode by recalculating lost data from the survivors.</p>
    <p>Decoder</p>
    <p>An MDS code will tolerate any m failures.</p>
  </div>
  <div class="page">
    <p>Erasure Coding Basics/Nomenclature</p>
    <p>Disks are composed of blocks, stripes, and strips.</p>
    <p>Blocks</p>
  </div>
  <div class="page">
    <p>Erasure Coding Basics/Nomenclature</p>
    <p>Disks are composed of blocks, stripes, and strips.</p>
    <p>Stripe</p>
    <p>Blocks</p>
  </div>
  <div class="page">
    <p>Erasure Coding Basics/Nomenclature</p>
    <p>Disks are composed of blocks, stripes, and strips.</p>
    <p>Stripe</p>
    <p>Blocks</p>
    <p>Strips</p>
  </div>
  <div class="page">
    <p>Reed-Solomon Codes</p>
    <p>Strips are w-bit words, where n  2 w .</p>
    <p>Stripe = Codeword</p>
    <p>k</p>
    <p>m</p>
    <p>When w = 8, strips equal bytes.</p>
  </div>
  <div class="page">
    <p>Reed-Solomon Codes</p>
    <p>Coding is described by a matrix-vector product.</p>
    <p>Generator Matrix GT.</p>
    <p>k</p>
    <p>m</p>
    <p>* =</p>
    <p>Arithmetic is special and expensive.</p>
    <p>Data</p>
    <p>Stripe = Codeword</p>
    <p>k</p>
    <p>m</p>
    <p>This is all that matters.</p>
  </div>
  <div class="page">
    <p>Bit Matrix Codes</p>
    <p>Strips are each w individual bits. Arithmetic is binary: Addition = XOR, Multiplication = AND</p>
    <p>Stripe = Codeword</p>
    <p>kw</p>
    <p>mw</p>
    <p>Generator Matrix GT.</p>
    <p>kw</p>
    <p>mw</p>
    <p>=</p>
    <p>Data</p>
    <p>* *</p>
    <p>w</p>
  </div>
  <div class="page">
    <p>Bit Matrix Codes</p>
    <p>Thus, coding bits are XOR sums of various data bits:</p>
    <p>Stripe = Codeword</p>
    <p>k</p>
    <p>m</p>
    <p>Generator Matrix GT.</p>
    <p>kw</p>
    <p>mw</p>
    <p>=</p>
    <p>Data</p>
    <p>* * XOR</p>
    <p>Performance is clearly proportional</p>
    <p>to the number of ones in the Generator Matrix.</p>
  </div>
  <div class="page">
    <p>Bit Matrix Codes</p>
    <p>For good performance, strips are composed of packets rather than bits.</p>
    <p>Codeword Packets</p>
    <p>Generator Matrix GT.</p>
    <p>kw</p>
    <p>mw</p>
    <p>=</p>
    <p>Data Packets</p>
    <p>* * XOR</p>
  </div>
  <div class="page">
    <p>Bit Matrix Codes</p>
    <p>Cauchy Reed Solomon (CRS) Codes [Blomer95]</p>
    <p>Bit Matrix derived from Reed-Solomon code.</p>
    <p>Same constraints: All good as long as n  2w.</p>
    <p>[Plank&amp;Xu06]: Optimization to reduce ones.</p>
    <p>Further optimization [Plank07].</p>
  </div>
  <div class="page">
    <p>The Special Case of RAID-6</p>
    <p>Two coding disks: P &amp; Q.</p>
    <p>P drive is parity (superset of RAID-4/RAID-5).</p>
    <p>Last row (or last w rows) of Generator Matrix all that matter.</p>
    <p>*</p>
    <p>? ? ? ?</p>
    <p>?</p>
    <p>?</p>
    <p>?</p>
    <p>? P Q</p>
    <p>P</p>
    <p>Q</p>
  </div>
  <div class="page">
    <p>The Special Case of RAID-6</p>
    <p>Reed-Solomon Coding Optimization [Anvin07]:</p>
    <p>Multiplication by two can be implemented faster than general multiplication in GF(2w).</p>
    <p>Arrange the Q row to take advantage of this.</p>
    <p>P Q</p>
    <p>Improves encoding but not decoding.</p>
  </div>
  <div class="page">
    <p>Optimized Cauchy Reed-Solomon Codes [Plank07]:</p>
    <p>For all w, enumerate best values for the Q row.</p>
    <p>Different w have different properties based on the underlying Galois Field arithmetic.</p>
    <p>The Special Case of RAID-6</p>
    <p>*</p>
    <p>P</p>
    <p>Q</p>
    <p>E.g: k = 14: Average ones per row:</p>
    <p>w = 7 w = 8 w = 9</p>
  </div>
  <div class="page">
    <p>Minimal Density RAID-6 Codes (k  w):</p>
    <p>Provably minimal number of ones.</p>
    <p>(w+1) is prime: Blaum-Roth codes [1999]</p>
    <p>w is prime: Liberation codes [Plank08]</p>
    <p>w = 8: Liber8tion code [Plank08]</p>
    <p>Performance improves when w increases.</p>
    <p>Requires a scheduling technique [Hafner05] for good decoding.</p>
    <p>The Special Case of RAID-6</p>
  </div>
  <div class="page">
    <p>EVENODD [Blaum94] &amp; RDP [Corbett04]:</p>
    <p>(w+1) prime, k  w.  Scheduled non-minimal bit matrices.  Perform better when w is smaller.  When w = k or k+1, RDP is provably optimal.  Patented.</p>
    <p>The Special Case of RAID-6</p>
  </div>
  <div class="page">
    <p>Luby: Original CRS code.  (1990  C)</p>
    <p>Zfec: Reed-Solomon coding, w = 8.  (2007 - C, based on Rizzo 1997)</p>
    <p>Jerasure: All of the codes described above.  (2007  C)</p>
    <p>Cleversafe: CRS from cleversafe.org, w = 8.  (2008  Java, based on Luby)</p>
    <p>RDP/EVENODD: Added to Jerasure.</p>
    <p>Open Source Libraries</p>
  </div>
  <div class="page">
    <p>Open Source Tests - Encoding</p>
    <p>Big File Data</p>
    <p>Buffer 1. Read</p>
    <p>Coding Buffer</p>
    <p>Block D0</p>
    <p>Block D1</p>
    <p>Block Dk-1</p>
    <p>Block D2</p>
    <p>...</p>
    <p>Block C0</p>
    <p>Block Cm-1</p>
    <p>...</p>
    <p>File D0</p>
    <p>File D1</p>
    <p>File Dk-1</p>
    <p>File D2</p>
    <p>File C0</p>
    <p>File Cm-1</p>
    <p>...</p>
    <p>...</p>
    <p>Disk</p>
  </div>
  <div class="page">
    <p>Open Source Tests - Encoding</p>
    <p>DS0,0 DS0,1</p>
    <p>DS0,s-1</p>
    <p>...</p>
    <p>DS1,0 DS1,1</p>
    <p>DS1,s-1</p>
    <p>...</p>
    <p>DSk-1,0 DSk-1,1</p>
    <p>DSk-1,s-1</p>
    <p>...</p>
    <p>...</p>
    <p>Data Buffer</p>
    <p>CS0,0 CS0,1</p>
    <p>CS0,s-1</p>
    <p>...</p>
    <p>CSm-1,0 CSm-1,1</p>
    <p>CSm-1,s-1</p>
    <p>...</p>
    <p>...</p>
    <p>Coding Buffer</p>
    <p>Encoding Stripe 0...</p>
    <p>...</p>
    <p>Block D0</p>
    <p>Block D1</p>
    <p>Block Dk-1</p>
    <p>Block C0</p>
    <p>Block Cm-1</p>
  </div>
  <div class="page">
    <p>Open Source Tests - Encoding</p>
    <p>DS0,0 DS0,1</p>
    <p>DS0,s-1</p>
    <p>...</p>
    <p>DS1,0 DS1,1</p>
    <p>DS1,s-1</p>
    <p>...</p>
    <p>DSk-1,0 DSk-1,1</p>
    <p>DSk-1,s-1</p>
    <p>...</p>
    <p>...</p>
    <p>Data Buffer</p>
    <p>CS0,0 CS0,1</p>
    <p>CS0,s-1</p>
    <p>...</p>
    <p>CSm-1,0 CSm-1,1</p>
    <p>CSm-1,s-1</p>
    <p>...</p>
    <p>...</p>
    <p>Coding Buffer</p>
    <p>Encoding Stripe 1</p>
    <p>Block D0</p>
    <p>Block D1</p>
    <p>Block Dk-1</p>
    <p>Block C0</p>
    <p>Block Cm-1</p>
  </div>
  <div class="page">
    <p>Open Source Tests - Encoding</p>
    <p>DS0,0 DS0,1</p>
    <p>DS0,s-1</p>
    <p>...</p>
    <p>DS1,0 DS1,1</p>
    <p>DS1,s-1</p>
    <p>...</p>
    <p>DSk-1,0 DSk-1,1</p>
    <p>DSk-1,s-1</p>
    <p>...</p>
    <p>...</p>
    <p>Data Buffer</p>
    <p>CS0,0 CS0,1</p>
    <p>CS0,s-1</p>
    <p>...</p>
    <p>CSm-1,0 CSm-1,1</p>
    <p>CSm-1,s-1</p>
    <p>...</p>
    <p>...</p>
    <p>Coding Buffer</p>
    <p>Encoding Stripe s-1</p>
    <p>Block D0</p>
    <p>Block D1</p>
    <p>Block Dk-1</p>
    <p>Block C0</p>
    <p>Block Cm-1</p>
  </div>
  <div class="page">
    <p>Blowing up further.</p>
    <p>DS0,0</p>
    <p>DS0,1</p>
    <p>DS0,s-1</p>
    <p>... Block D0</p>
    <p>DS0,0</p>
    <p>DS0,1</p>
    <p>DS0,s-1</p>
    <p>w packets each of size P.</p>
    <p>Each strip is of size wP.</p>
    <p>Each block is of size swP.</p>
    <p>Data buffer is of size kswP.</p>
  </div>
  <div class="page">
    <p>1GB Video File, ~100 MB data buffer.</p>
    <p>Four configurations: [6,2][14,2][12,4][10,6]</p>
    <p>All implemented codes.</p>
    <p>All legal values of w  32.</p>
    <p>Parameter Space Explored</p>
  </div>
  <div class="page">
    <p>#1: MacBook (32-bit)  2 GHz Intel Core Duo (only one used).</p>
    <p>1 GB RAM, 32KB L1 Cache, 2MB L2 Cache.</p>
    <p>memcpy(): 6.13 GB/s, XOR: 2.43 GB/s.</p>
    <p>#2: Dell (32-bit)  1.5 GHz Intel Pentium 4 .</p>
    <p>1 GB RAM, 8KB L1 Cache, 256KB L2 Cache</p>
    <p>memcpy(): 2.92 GB/s, XOR: 1.53 GB/s.</p>
    <p>Machines</p>
  </div>
  <div class="page">
    <p>Strip out the disk I/O.  You are only seeing encoding/decoding times.</p>
    <p>Averages of 10+ runs, 0.5% variance.</p>
    <p>Show raw speed and normalized.</p>
    <p>The Measurements that You'll See</p>
  </div>
  <div class="page">
    <p>Cache Effects: The packet size.</p>
    <p>RDP - [6,2]. w = 6 on MacBook.</p>
    <p>Observation #1 This is not a nice</p>
    <p>smooth curve with a clear maximum.</p>
    <p>READ THE PAPER</p>
  </div>
  <div class="page">
    <p>Encoding Performance: [6,2]</p>
  </div>
  <div class="page">
    <p>Observation #1 Special purpose codes rock.</p>
    <p>Observation #2 XOR count roughly matters.</p>
    <p>But so does the cache.</p>
  </div>
  <div class="page">
    <p>Observation #3. While RDP is a clear winner, others are very close behind.</p>
  </div>
  <div class="page">
    <p>Observation #4. In Cauchy Reed-Solomon Coding, the matrix makes a big difference, as does w.</p>
  </div>
  <div class="page">
    <p>Observation #4. In Cauchy Reed-Solomon Coding, the matrix makes a big difference, as does w.</p>
    <p>w = 8 w = 16</p>
    <p>w = 32</p>
    <p>w = 8 w = 16</p>
    <p>w = 32</p>
  </div>
  <div class="page">
    <p>Observation #5. Anvin's optimization is a winner for Reed-Solomon Coding. Zfec has the best performance</p>
    <p>of the standard Reed-Solomon encoders.</p>
  </div>
  <div class="page">
    <p>Encoding Performance: [14,2]</p>
  </div>
  <div class="page">
    <p>Encoding Performance: [12,4]</p>
  </div>
  <div class="page">
    <p>Encoding Performance: [12,4]Observation #1: The matrix matters still.</p>
  </div>
  <div class="page">
    <p>Encoding Performance: [12,4]Observation #2: Smaller w are better.</p>
  </div>
  <div class="page">
    <p>Decoding Performance: [6,2]</p>
  </div>
  <div class="page">
    <p>Conclusions from the study</p>
    <p>Open source erasure code implementations can easily keep</p>
    <p>up with disks, even on slow CPUs.</p>
    <p>Special purpose RAID-6 codes are much better than</p>
    <p>general-purpose alternatives.</p>
    <p>Cauchy Reed-Solomon coding is the better</p>
    <p>general purpose code.</p>
    <p>With Cauchy Reed-Solomon coding, the matrix matters.</p>
    <p>With all codes, attention must be paid to w and to memory/cache.</p>
    <p>Biggest impact of further research: Beat Reed-Solomon</p>
    <p>coding beyond RAID-6.</p>
  </div>
  <div class="page">
    <p>Anticipating Some Questions: Your machines suck.  Why no multicore?</p>
    <p>HP DC7600, Pentium D820, 64-Bit, 2.8 GHz.</p>
    <p>Why didn't you use better ones? Why no use of SSE?</p>
  </div>
  <div class="page">
    <p>Anticipating Some Questions:</p>
    <p>My friend has an implementation of Reed-Solomon that blows all of your codes away.</p>
    <p>Cool. Post it.</p>
    <p>Why didn't you test the Reed-Solomon codec in the Linux kernel?</p>
    <p>My bad. We should have.</p>
    <p>What do you have to say about that?</p>
  </div>
  <div class="page">
    <p>A Performance Evaluation of Open Source Erasure Codes</p>
    <p>for Storage Applications</p>
    <p>Usenix FAST February 27, 2009</p>
    <p>Zooko Wilcox-O'Hearn</p>
    <p>James S. Plank Catherine D. Schuman</p>
    <p>(Tennessee)</p>
    <p>Jianqiang Luo Lihao Xu</p>
    <p>(Wayne State)</p>
  </div>
  <div class="page">
    <p>Cache Effects: The packet size.</p>
    <p>RDP - [6,2]. w = 6 on MacBook.</p>
    <p>Observation #1 This is not a nice</p>
    <p>smooth curve with a clear maximum.</p>
  </div>
  <div class="page">
    <p>Cache Effects: The packet size.</p>
    <p>RDP - [6,2]. w = 6 on MacBook.</p>
    <p>Observation #2 Adjacent values can</p>
    <p>differ radically.</p>
    <p>P = 3272, Speed = 997</p>
    <p>P = 3268, Speed = 1266</p>
  </div>
  <div class="page">
    <p>Cache Effects: The packet size.</p>
    <p>Result</p>
    <p>A heuristic search algorithm to find the best</p>
    <p>packet size.</p>
    <p>Remaining graphs always show</p>
    <p>performance of the best</p>
    <p>packet size.</p>
  </div>
</Presentation>
