<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Comet: An Active</p>
    <p>Distributed Key-Value Store</p>
    <p>Roxana Geambasu</p>
    <p>Amit Levy</p>
    <p>Yoshi Kohno</p>
    <p>Arvind Krishnamurthy</p>
    <p>Hank Levy</p>
    <p>University of Washington</p>
  </div>
  <div class="page">
    <p>Distributed Key/Value Stores</p>
    <p>A simple put/get interface</p>
    <p>Great properties: scalability, availability, reliability</p>
    <p>Increasingly popular both within data centers and in P2P</p>
    <p>Data center P2P</p>
    <p>Dynamo</p>
    <p>amazon.com</p>
  </div>
  <div class="page">
    <p>Distributed Key/Value Stores</p>
    <p>A simple put/get interface</p>
    <p>Great properties: scalability, availability, reliability</p>
    <p>Increasingly popular both within data centers and in P2P</p>
    <p>Data center P2P</p>
    <p>Dynamo</p>
    <p>amazon.com</p>
    <p>Voldemort</p>
    <p>LinkedIn</p>
  </div>
  <div class="page">
    <p>Distributed Key/Value Stores</p>
    <p>A simple put/get interface</p>
    <p>Great properties: scalability, availability, reliability</p>
    <p>Increasingly popular both within data centers and in P2P</p>
    <p>Data center P2P</p>
    <p>Dynamo</p>
    <p>amazon.com</p>
    <p>Voldemort</p>
    <p>LinkedIn</p>
    <p>Cassandra</p>
    <p>Facebook</p>
  </div>
  <div class="page">
    <p>Distributed Key/Value Stores</p>
    <p>A simple put/get interface</p>
    <p>Great properties: scalability, availability, reliability</p>
    <p>Increasingly popular both within data centers and in P2P</p>
    <p>Data center P2P</p>
    <p>Dynamo</p>
    <p>amazon.com</p>
    <p>Voldemort</p>
    <p>LinkedIn</p>
    <p>Cassandra</p>
    <p>Facebook</p>
    <p>Vuze DHT</p>
    <p>Vuze</p>
  </div>
  <div class="page">
    <p>Distributed Key/Value Stores</p>
    <p>A simple put/get interface</p>
    <p>Great properties: scalability, availability, reliability</p>
    <p>Increasingly popular both within data centers and in P2P</p>
    <p>Data center P2P</p>
    <p>Dynamo</p>
    <p>amazon.com</p>
    <p>Voldemort</p>
    <p>LinkedIn</p>
    <p>Cassandra</p>
    <p>Facebook</p>
    <p>Vuze DHT</p>
    <p>Vuze</p>
    <p>uTorrent DHT</p>
    <p>uTorrent</p>
  </div>
  <div class="page">
    <p>Increasingly, key/value stores are shared by many apps</p>
    <p>Avoids per-app storage system deployment</p>
    <p>However, building apps atop todays stores is challenging</p>
    <p>Distributed Key/Value Storage Services</p>
    <p>Data center P2P</p>
    <p>Amazon S3</p>
    <p>Altexa Photo</p>
    <p>Bucket</p>
    <p>Jungle</p>
    <p>Disk Vuze</p>
    <p>App</p>
    <p>One</p>
    <p>Swarm Vanish</p>
    <p>Vuze DHT</p>
  </div>
  <div class="page">
    <p>Challenge: Inflexible Key/Value Stores</p>
    <p>Applications have different (even conflicting) needs:</p>
    <p>Availability, security, performance, functionality</p>
    <p>But todays key/value stores are one-size-fits-all</p>
    <p>Motivating example: our Vanish experience</p>
    <p>App 1 App 2 App 3</p>
    <p>Key/value</p>
    <p>store</p>
  </div>
  <div class="page">
    <p>Vanish is a self-destructing data system built on Vuze</p>
    <p>Vuze problems for Vanish:</p>
    <p>Fixed 8-hour data timeout</p>
    <p>Overly aggressive replication, which hurts security</p>
    <p>Changes were simple, but deploying them was difficult:</p>
    <p>Need Vuze engineer</p>
    <p>Long deployment cycle</p>
    <p>Hard to evaluate before</p>
    <p>deployment</p>
    <p>Motivating Example: Vanish [USENIX Security 09]</p>
    <p>Vuze</p>
    <p>App Vanish</p>
    <p>Vuze DHT</p>
    <p>Vuze</p>
    <p>App Vanish</p>
    <p>Vuze DHT</p>
    <p>Vuze Vanish</p>
    <p>Vuze DHT</p>
    <p>Vuze Vanish</p>
    <p>Vuze DHT</p>
    <p>Vuze Vanish</p>
    <p>Vuze DHT</p>
    <p>Vuze Vanish</p>
    <p>Vuze DHT</p>
    <p>Future</p>
    <p>app</p>
    <p>Vuze</p>
    <p>App Vanish</p>
    <p>Future</p>
    <p>app</p>
    <p>Vuze DHT</p>
  </div>
  <div class="page">
    <p>Vanish is a self-destructing data system built on Vuze</p>
    <p>Vuze problems for Vanish:</p>
    <p>Fixed 8-hour data timeout</p>
    <p>Overly aggressive replication, which hurts security</p>
    <p>Changes were simple, but deploying them was difficult:</p>
    <p>Need Vuze engineer</p>
    <p>Long deployment cycle</p>
    <p>Hard to evaluate before</p>
    <p>deployment</p>
    <p>Motivating Example: Vanish [USENIX Security 09]</p>
    <p>Vuze</p>
    <p>App Vanish</p>
    <p>Vuze DHT</p>
    <p>Vuze</p>
    <p>App Vanish</p>
    <p>Vuze DHT</p>
    <p>Vuze Vanish</p>
    <p>Vuze DHT</p>
    <p>Vuze Vanish</p>
    <p>Vuze DHT</p>
    <p>Vuze Vanish</p>
    <p>Vuze DHT</p>
    <p>Vuze Vanish</p>
    <p>Vuze DHT</p>
    <p>Future</p>
    <p>app</p>
    <p>Vuze</p>
    <p>App Vanish</p>
    <p>Future</p>
    <p>app</p>
    <p>Vuze DHT</p>
    <p>Question:</p>
    <p>How can a key/value store support many</p>
    <p>applications with different needs?</p>
  </div>
  <div class="page">
    <p>Extensible Key/Value Stores</p>
    <p>Allow apps to customize stores functions</p>
    <p>Different data lifetimes</p>
    <p>Different numbers of replicas</p>
    <p>Different replication intervals</p>
    <p>Allow apps to define new functions</p>
    <p>Tracking popularity: data item counts the number of reads</p>
    <p>Access logging: data item logs readers IPs</p>
    <p>Adapting to context: data item returns different values to</p>
    <p>different requestors</p>
  </div>
  <div class="page">
    <p>Design Philosophy</p>
    <p>We want an extensible key/value store</p>
    <p>But we want to keep it simple!</p>
    <p>Allow apps to inject tiny code fragments (10s of lines of code)</p>
    <p>Adding even a tiny amount of programmability into key/value</p>
    <p>stores can be extremely powerful</p>
    <p>This paper shows how to build extensible P2P DHTs</p>
    <p>We leverage our DHT experience to drive our design</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation</p>
    <p>Architecture</p>
    <p>Applications</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Comet</p>
    <p>DHT that supports application-specific customizations</p>
    <p>Applications store active objects instead of passive values</p>
    <p>Active objects contain small code snippets that control their</p>
    <p>behavior in the DHT</p>
    <p>App 1 App 2 App 3</p>
    <p>Comet</p>
    <p>Active object Comet node</p>
  </div>
  <div class="page">
    <p>Comets Goals</p>
    <p>Flexibility</p>
    <p>Support a wide variety of small, lightweight customizations</p>
    <p>Isolation and safety</p>
    <p>Limited knowledge, resource consumption, communication</p>
    <p>Lightweight</p>
    <p>Low overhead for hosting nodes</p>
  </div>
  <div class="page">
    <p>Active Storage Objects (ASOs)</p>
    <p>The ASO consists of data and code</p>
    <p>The data is the value</p>
    <p>The code is a set of handlers that are called on put/get</p>
    <p>App 1 App 2 App 3</p>
    <p>Comet</p>
    <p>ASO</p>
    <p>data</p>
    <p>code</p>
    <p>function onGet()</p>
    <p>[]</p>
    <p>end</p>
  </div>
  <div class="page">
    <p>Each replica keeps track of number of gets on an object</p>
    <p>The effect is powerful:</p>
    <p>Difficult to track object popularity in todays DHTs</p>
    <p>Trivial to do so in Comet without DHT modifications</p>
    <p>Simple ASO Example</p>
    <p>ASO</p>
    <p>data</p>
    <p>code</p>
    <p>aso.value = Hello world!</p>
    <p>aso.getCount = 0</p>
    <p>function onGet()</p>
    <p>self.getCount = self.getCount + 1</p>
    <p>return {self.value, self.getCount}</p>
    <p>end</p>
  </div>
  <div class="page">
    <p>Local Store</p>
    <p>Comet Architecture</p>
    <p>K1 ASO1 ASO2K2</p>
    <p>DHT Node</p>
    <p>T ra</p>
    <p>d it io</p>
    <p>n a</p>
    <p>l</p>
    <p>D H</p>
    <p>T C</p>
    <p>o m</p>
    <p>e t</p>
    <p>Active Runtime</p>
    <p>External</p>
    <p>Interaction</p>
    <p>Handler</p>
    <p>Invocation</p>
    <p>Sandbox</p>
    <p>Policies</p>
    <p>ASO1 data code</p>
    <p>ASO Extension API</p>
  </div>
  <div class="page">
    <p>The ASO Extension API</p>
    <p>Applications Customizations</p>
    <p>Vanish</p>
    <p>Replication</p>
    <p>Timeout</p>
    <p>One-time values</p>
    <p>Adeona Password access</p>
    <p>Access logging</p>
    <p>P2P File Sharing Smart tracker</p>
    <p>Recursive gets</p>
    <p>P2P Twitter Publish / subscribe</p>
    <p>Hierarchical pub/sub</p>
    <p>Measurement Node lifetimes</p>
    <p>Replica monitoring</p>
  </div>
  <div class="page">
    <p>The ASO Extension API</p>
    <p>Small yet powerful API for a wide variety of applications</p>
    <p>We built over a dozen application customizations</p>
    <p>We have explicitly chosen not to support:</p>
    <p>Sending arbitrary messages on the Internet</p>
    <p>Doing I/O operations</p>
    <p>Customizing routing  20</p>
    <p>Intercept</p>
    <p>accesses</p>
    <p>Periodic</p>
    <p>Tasks</p>
    <p>Host</p>
    <p>Interaction</p>
    <p>DHT</p>
    <p>Interaction</p>
    <p>onPut(caller) onTimer() getSystemTime() get(key, nodes)</p>
    <p>onGet(caller) getNodeIP() put(key, data, nodes)</p>
    <p>onUpdate(caller) getNodeID() lookup(key)</p>
    <p>getASOKey()</p>
    <p>deleteSelf()</p>
  </div>
  <div class="page">
    <p>The ASO Sandbox</p>
    <p>Use a standard language-based sandbox</p>
    <p>Make the sandbox as small as possible (&lt;5,000 LOC)</p>
    <p>Start with tiny Lua language and remove unneeded functions</p>
    <p>Limit per-handler bytecode instructions and memory</p>
    <p>Rate-limit incoming and outgoing ASO requests</p>
    <p>Prevent traffic amplification and DDoS attacks</p>
    <p>ASOs can talk only to their neighbors, no recursive requests</p>
  </div>
  <div class="page">
    <p>Comet Prototype</p>
    <p>We built Comet on top of Vuze and Lua</p>
    <p>We deployed experimental nodes on PlanetLab</p>
    <p>In the future, we hope to deploy at a large scale</p>
    <p>Vuze engineer is particularly interested in Comet for</p>
    <p>debugging and experimentation purposes</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation</p>
    <p>Architecture</p>
    <p>Applications</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Applications Customization Lines of Code</p>
    <p>Vanish</p>
    <p>Security-enhanced replication 41</p>
    <p>Flexible timeout 15</p>
    <p>One-time values 15</p>
    <p>Adeona Password-based access 11</p>
    <p>Access logging 22</p>
    <p>P2P File Sharing Smart Bittorrent tracker 43</p>
    <p>Recursive gets* 9</p>
    <p>Publish/subscribe 14 P2P Twitter</p>
    <p>Hierarchical pub/sub* 20</p>
    <p>Measurement DHT-internal node lifetimes 41</p>
    <p>Replica monitoring 21</p>
    <p>Comet Applications</p>
    <p>* Require signed ASOs (see paper)</p>
  </div>
  <div class="page">
    <p>Three Examples</p>
  </div>
  <div class="page">
    <p>Example: customize the replication scheme</p>
    <p>We have implemented the Vanish-specific replication</p>
    <p>Code is 41 lines in Lua</p>
    <p>function aso:selectReplicas(neighbors)</p>
    <p>[...]</p>
    <p>end</p>
    <p>function aso:onTimer()</p>
    <p>neighbors = comet.lookup()</p>
    <p>replicas = self.selectReplicas(neighbors)</p>
    <p>comet.put(self, replicas)</p>
    <p>end</p>
  </div>
  <div class="page">
    <p>Traditional distributed trackers return a randomized</p>
    <p>subset of the nodes</p>
    <p>Comet: a proximity-based distributed tracker</p>
    <p>Peers put their IPs and Vivaldi coordinates at torrentID</p>
    <p>On get, the ASO computes and returns the set of</p>
    <p>closest peers to the requestor</p>
    <p>ASO has 37 lines of Lua code</p>
  </div>
  <div class="page">
    <p>Proximity-Based Distributed Tracker</p>
    <p>Comet tracker</p>
    <p>Random tracker</p>
  </div>
  <div class="page">
    <p>Example: monitor a remote nodes neighbors</p>
    <p>Put a monitoring ASO that pings its neighbors periodically</p>
    <p>Useful for internal measurements of DHTs</p>
    <p>Provides additional visibility over external measurement</p>
    <p>(e.g., NAT/firewall traversal)</p>
    <p>aso.neighbors = {}</p>
    <p>function aso:onTimer()</p>
    <p>neighbors = comet.lookup()</p>
    <p>self.neighbors[comet.systemTime()] = neighbors</p>
    <p>end</p>
  </div>
  <div class="page">
    <p>Example Measurement: Vuze Node Lifetimes</p>
    <p>Vuze Node Lifetime (hours)</p>
    <p>External measurement</p>
    <p>Comet Internal measurement</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation</p>
    <p>Architecture</p>
    <p>Evaluation</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>Extensibility allows a shared storage system to support</p>
    <p>applications with different needs</p>
    <p>Comet is an extensible DHT that allows per-application</p>
    <p>customizations</p>
    <p>Limited interfaces, language sandboxing, and resource and</p>
    <p>communication limits</p>
    <p>Opens DHTs to a new set of stronger applications</p>
    <p>Extensibility is likely useful in data centers (e.g., S3):</p>
    <p>Assured delete</p>
    <p>Logging and forensics</p>
    <p>Storage location awareness</p>
    <p>Popularity</p>
  </div>
</Presentation>
