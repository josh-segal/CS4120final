<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Monadic Datalog Containment</p>
    <p>Michael Benedikt Pierre Bourhis Pierre Senellart</p>
    <p>University of Oxford and Tlcom ParisTech</p>
    <p>ICALP 2012, 13 July</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 1/16</p>
  </div>
  <div class="page">
    <p>Datalog</p>
    <p>Basic query language with recursion.</p>
    <p>ReachGood()  Start(x), Reach(x, y), Good(y) Reach(x, y)  Reach(x, z), Reach(z, y) Reach(x, y)  E(x, y)</p>
    <p>I Rules consisting of Horn clauses. I Heads of rules are intensional predicates I Other predicates are extensional (input) predicates I Distinguished goal predicate</p>
    <p>Evaluation over an instance : least fix point semantics</p>
    <p>Monadic Datalog (MDL) : all intensional predicates are unary.</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 2/16</p>
  </div>
  <div class="page">
    <p>Datalog</p>
    <p>Basic query language with recursion.</p>
    <p>ReachGood()  Start(x), Reach(x, y), Good(y) Reach(x, y)  Reach(x, z), Reach(z, y) Reach(x, y)  E(x, y)</p>
    <p>I Rules consisting of Horn clauses. I Heads of rules are intensional predicates I Other predicates are extensional (input) predicates I Distinguished goal predicate</p>
    <p>Evaluation over an instance : least fix point semantics</p>
    <p>Monadic Datalog (MDL) : all intensional predicates are unary.</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 2/16</p>
  </div>
  <div class="page">
    <p>Containment of Datalog</p>
    <p>Q  Q iff for every input instance D, Q(D)  Q(D)</p>
    <p>Bad news [Shmueli, 1987] Datalog containment and equivalence are undecidable</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 3/16</p>
  </div>
  <div class="page">
    <p>Containment of Datalog</p>
    <p>Q  Q iff for every input instance D, Q(D)  Q(D)</p>
    <p>Bad news [Shmueli, 1987] Datalog containment and equivalence are undecidable</p>
    <p>Decidable fragments</p>
    <p>[Cosmadakis et al., 1988] Decidability of the containment of a MDL program in a MDL program is 2EXPTIME and EXPTIME-hard</p>
    <p>[Chaudhuri and Vardi, 1992] Decidability of the containment of a DL program in an union of conjunctive queries (UCQ) is 2EXPTIME-complete</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 3/16</p>
  </div>
  <div class="page">
    <p>Containment of Datalog</p>
    <p>Q  Q iff for every input instance D, Q(D)  Q(D)</p>
    <p>(formerly) Open Question Tight bound on MDL into MDL/UCQ containment</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 3/16</p>
  </div>
  <div class="page">
    <p>Application : Querying with limited access</p>
    <p>Limited access : Data accessible through Forms and Web Services I Can not give a general query to the data, can only do lookups on</p>
    <p>particular fields I Values used in lookups must either be known beforehand, or result</p>
    <p>from other lookups</p>
    <p>Method ApartmentFind : Region, Area, NumBeds  Address, Price, Description, Link</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 4/16</p>
  </div>
  <div class="page">
    <p>Accessible data</p>
    <p>I Schema = Relations + Access methods I Access method m to a relation : set of input attributes input(m)</p>
    <p>requiring known values I An access to method mi is a binding of the input positions of mi. It</p>
    <p>returns a set of tuples. I A valid access sequence : binding values appear in the previous</p>
    <p>outputs or are constants. I Accessible data of D, Acc(D) : data of D extractable from valid</p>
    <p>access sequences</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 5/16</p>
  </div>
  <div class="page">
    <p>Containment under limited access</p>
    <p>Q is included in Q under limited access iff for any D, Q(Acc(D))  Q(Acc(D))</p>
    <p>(formerly) Open Question What is the complexity of query equivalence, containment under access patterns ?</p>
    <p>I Single access method per relation I No initial seed values</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 6/16</p>
  </div>
  <div class="page">
    <p>Containment under limited access</p>
    <p>Q is included in Q under limited access iff for any D, Q(Acc(D))  Q(Acc(D))</p>
    <p>Reduction to containment of MDL in UCQs (i) Computation of the accessible values by a MDL program</p>
    <p>Accessible(xj)  (R(~x)</p>
    <p>iinput(m) Accessible(xi))</p>
    <p>Accessible(c)</p>
    <p>(ii) Restriction of Q to the accessible data : QAcc  MDL. (iii) Containment of Q in Q under limited access iff QAcc is contained</p>
    <p>in Q. .</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 6/16</p>
  </div>
  <div class="page">
    <p>(Formerly) Open Questions and Results</p>
    <p>I What about containment under limited access patterns ? I Containment UCQs under limited access : 2EXPTIME-complete I Containment with a single method per relation :</p>
    <p>NEXPTIME-complete I Containment with a single method per relation and without seed</p>
    <p>values : EXPTIME-complete</p>
    <p>I Is the 2EXPTIME bound on MDL/UCQ containment tight ? Containment of MDL/UCQ : 2-EXPTIME-Hard</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 7/16</p>
  </div>
  <div class="page">
    <p>(Formerly) Open Questions and Results</p>
    <p>I What about containment under limited access patterns ? I Containment UCQs under limited access : 2EXPTIME-complete I Containment with a single method per relation :</p>
    <p>NEXPTIME-complete I Containment with a single method per relation and without seed</p>
    <p>values : EXPTIME-complete</p>
    <p>I Is the 2EXPTIME bound on MDL/UCQ containment tight ? Containment of MDL/UCQ : 2-EXPTIME-Hard</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 7/16</p>
  </div>
  <div class="page">
    <p>MDL Containment in UCQs</p>
    <p>[Chaudhuri and Vardi, 1992] (M)DL containment in UCQs is in 2EXPTIME ;</p>
    <p>New Proof</p>
    <p>I Q is not contained in Q iff there is a witness instance in which Q holds and Q does not hold.</p>
    <p>I The witness instance can be taken to be tree-like  of tree-width at most |Q|.</p>
    <p>I Tree like instances of Q represented by a tree automaton TQ exponential in |Q|.</p>
    <p>I Tree-like instances not satisfying Q can be described by a tree automaton TQ double exponential in |Q| and in |Q|</p>
    <p>Containment of Q in Q iff TQ TQ is empty</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 8/16</p>
  </div>
  <div class="page">
    <p>MDL Containment in UCQs</p>
    <p>[Chaudhuri and Vardi, 1992] (M)DL containment in UCQs is in 2EXPTIME ;</p>
    <p>New Proof</p>
    <p>I Q is not contained in Q iff there is a witness instance in which Q holds and Q does not hold.</p>
    <p>I The witness instance can be taken to be tree-like  of tree-width at most |Q|.</p>
    <p>I Tree like instances of Q represented by a tree automaton TQ exponential in |Q|.</p>
    <p>I Tree-like instances not satisfying Q can be described by a tree automaton TQ double exponential in |Q| and in |Q|</p>
    <p>Containment of Q in Q iff TQ TQ is empty</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 8/16</p>
  </div>
  <div class="page">
    <p>In more detail</p>
    <p>Instance I is k-very tree-like : I Tree decomposition of tree width k I Only at most one value shared between nodes I Two nodes sharing a value are parent/child</p>
    <p>Lemma Q is not contained in Q iff there exists a |Q|-very-tree-like instance satisfying Q and not Q</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 9/16</p>
  </div>
  <div class="page">
    <p>In more detail</p>
    <p>How to build TQ I Types of tree-like nodes n : The set of maximal connected subqueries</p>
    <p>of Q satisfied by the atoms in the bags of the subtree rooted at n I State of a node in TQ = Type of the node</p>
    <p>I The type of a node is determined by the types of its children and the facts of the node</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 9/16</p>
  </div>
  <div class="page">
    <p>In more detail</p>
    <p>How to build TQ I Types of tree-like nodes n : The set of maximal connected subqueries</p>
    <p>of Q satisfied by the atoms in the bags of the subtree rooted at n I State of a node in TQ = Type of the node</p>
    <p>I The type of a node is determined by the types of its children and the facts of the node</p>
    <p>Lemma The set of k very-tree-like instances not satisfying Q is represented by a tree automaton polynomial in the number of types and exponential in k</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 9/16</p>
  </div>
  <div class="page">
    <p>How to improve the bound on the number of types ?</p>
    <p>Unique Mapping Condition (UMC) of I for any conjunctive query Q, any atom A, any node n of I there exists at most one maximal connected subquery Q of Q mapping into the subtree of n such that A maps into a fact of n.</p>
    <p>Theorem If a regular class C of tree-like instances satisfies the UMC, then there is an EXPTIME function taking a (U)CQ Q to a tree automaton that accepts the instances of C not satisfying Q. Thus containment of a tree automaton in UCQ over trees in a such class is EXPTIME</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 10/16</p>
  </div>
  <div class="page">
    <p>How to improve the bound on the number of types ?</p>
    <p>Unique Mapping Condition (UMC) of I for any conjunctive query Q, any atom A, any node n of I there exists at most one maximal connected subquery Q of Q mapping into the subtree of n such that A maps into a fact of n.</p>
    <p>Theorem If a regular class C of tree-like instances satisfies the UMC, then there is an EXPTIME function taking a (U)CQ Q to a tree automaton that accepts the instances of C not satisfying Q. Thus containment of a tree automaton in UCQ over trees in a such class is EXPTIME</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 10/16</p>
  </div>
  <div class="page">
    <p>Tree decompositions with UMC</p>
    <p>A diversified tree-like instance is a very tree-like instance in which : (i) for each node n other than the root, there are not two facts in n</p>
    <p>having the same relation name (ii) a value shared by two nodes cannot appear in the same position in</p>
    <p>two facts having the same relation name.</p>
    <p>Key Lemmas (i) The class of diversified tree-like instances satisfies the UMC. (ii) The following containment problems always have diversified tree-like counter-examples</p>
    <p>I Containment of UCQ with limited access with a single access per relation</p>
    <p>I Containment of Monadic datalog where a relation symbol appears in at most one rule in UCQ</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 11/16</p>
  </div>
  <div class="page">
    <p>Putting it all together</p>
    <p>I Counterexamples to containment for limited-access schemas with a single access per relation can be taken to be diversified tree-like.</p>
    <p>I Diversified instances satisfy the UMC, so they have unique maximal subqueries.</p>
    <p>I We can construct a tree automaton that captures all diversified tree-like counterexamples, whose types are the vectors of maximal queries.</p>
    <p>I Creating this automaton and checking non-emptiness can be done in EXPTIME.</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 12/16</p>
  </div>
  <div class="page">
    <p>Other Upper Bounds</p>
    <p>Upper bounds : use analysis of tree-like models. Also can be used to show :</p>
    <p>I Results in the presence of constants  still have exponential sized counterexample models, but complexity moves to NEXPTIME from EXPTIME</p>
    <p>I New results over trees  tree automata containment in a tree pattern with only child axis is EXPTIME</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 13/16</p>
  </div>
  <div class="page">
    <p>Why MDL/UCQ Containment is 2EXPTIME-hard ?</p>
    <p>Idea : Reduction from the problem for validity of tree automaton over conjunctive queries with descendant relations [Bjrklund et al., 2008].</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 14/16</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Containment of MDL in UCQs I 2EXPTIME-hardness I Decidability of containment hinges on sufficiency of tree-like models. I Complexity related to fine structure of tree-like models, which can</p>
    <p>be related to syntactic restrictions on the MDL query.</p>
    <p>Current and Future Work I Containment of MDL with constraints or over particular structures</p>
    <p>(words, trees).</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 15/16</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Containment of MDL in UCQs I 2EXPTIME-hardness I Decidability of containment hinges on sufficiency of tree-like models. I Complexity related to fine structure of tree-like models, which can</p>
    <p>be related to syntactic restrictions on the MDL query.</p>
    <p>Current and Future Work I Containment of MDL with constraints or over particular structures</p>
    <p>(words, trees).</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 15/16</p>
  </div>
  <div class="page">
    <p>Henrik Bjrklund, Wim Martens, and Thomas Schwentick. Optimizing conjunctive queries over trees using schema information. In MFCS, 2008.</p>
    <p>Surajit Chaudhuri and Moshe Y. Vardi. On the equivalence of recursive and nonrecursive Datalog programs. In PODS, 1992.</p>
    <p>Stavros Cosmadakis, Haim Gaifman, Paris Kanellakis, and Moshe Vardi. Decidable Optimization Problems for Database Logic Programs. In Proceedings of the 20th Annual ACM Symposium on Theory of Computing, pages 477490, 1988.</p>
    <p>Oded Shmueli. Decidability and Expressiveness Aspects of Logic Queries. In Proceedings of the 6th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS87), pages 237249, 1987.</p>
    <p>M. Benedikt, P. Bourhis, P.Senellart, MDL Containment 16/16</p>
  </div>
</Presentation>
