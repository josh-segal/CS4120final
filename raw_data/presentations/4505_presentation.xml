<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>MICRO-06 :: Dec 12, 2006</p>
    <p>NoSQ: Store-Load Communication without a Store Queue</p>
    <p>Tingting Sha, Milo M.K. Martin, Amir Roth University of Pennsylvania</p>
    <p>{shatingt, milom, amir}@cis.upenn.edu http://www.cis.upenn.edu/acg</p>
    <p>addr (CAM)</p>
    <p>addr</p>
    <p>data (RAM)</p>
    <p>data</p>
    <p>addr predictor</p>
    <p>addr (RAM)</p>
    <p>==</p>
    <p>predictor</p>
  </div>
  <div class="page">
    <p>[ 2 ]</p>
    <p>Store-Load Forwarding: Conventional</p>
    <p>Associatively-searched store queue (SQ)  Complex  On load execution path  Doesnt scale well  Exists for benefit of 10% of loads</p>
    <p>Pentium III (1999)</p>
  </div>
  <div class="page">
    <p>[ 3 ]</p>
    <p>Store-Load Forwarding: Proposals</p>
    <p>Reduce range and frequency of search  Bloom-filtered SQ [Sethumadhavan+03]  Pipelined/chained SQ [Park+03]  Hierarchical/filtered SQ [Srinivasan+04, Ghandi+05, Torres+05]  Decomposed SQ [Roth05; Baugh+04]</p>
    <p>Replace full associativity with set associativity  Address-indexed forwarding cache [Stone+05]</p>
    <p>Replace search with speculative indexed access  Speculative indexed SQ [Sha+05], Fire-and-Forget [Subramaniam+06]</p>
    <p>Some forwarding structure still there in the middle of the datapath</p>
  </div>
  <div class="page">
    <p>[ 4 ]</p>
    <p>Store-Load Forwarding: Hmmm</p>
    <p>Observe I: can predict the exact forwarding store accurately  Memory dependence prediction [Moshovos+97, Chrysos+98, ]  No need to search SQ to find it</p>
    <p>Observe II: store data already exists in register file  No need to copy store input register  SQ  load output register</p>
    <p>Should be able to eliminate SQ if   Can connect stores input data register to loads consumers  Can verify in some way that doesnt require SQ</p>
    <p>we have the technology  Speculative memory bypassing (SMB) [Moshovos+97]  Filtered in-order load re-execution [Cain+04, Roth05]</p>
  </div>
  <div class="page">
    <p>[ 5 ]</p>
    <p>Store-Load Forwarding: NoSQ</p>
    <p>Predictor distinguishes bypassing/non-bypassing loads  Non-bypassing loads just access the data cache  Bypassing loads skip out-of-order execution (SMB)</p>
    <p>Store vulnerability window (SVW) verifies and trains</p>
    <p>Stores skip out-of-order execution too  Dont participate in forwarding anymore</p>
    <p>Commit pipeline extended to execute stores</p>
    <p>No Store Queue (or any forwarding structure)! No Load Queue!</p>
  </div>
  <div class="page">
    <p>[ 6 ]</p>
    <p>Road Map</p>
    <p>Overview</p>
    <p>The road to NoSQ (prior work)  Conventional store-load forwarding  Load verification with filtered load re-execution  Speculative memory bypassing</p>
    <p>NoSQ  Eliminating out-of-order stores and the store queue  Eliminating the load queue  Store-load bypassing predictor</p>
    <p>Evaluation</p>
  </div>
  <div class="page">
    <p>[ 7 ]</p>
    <p>Conventional Design</p>
    <p>Loads  Execute: search SQ, write address into LQ</p>
    <p>Map Table</p>
    <p>store</p>
    <p>D$SQ</p>
    <p>load</p>
    <p>free list</p>
    <p>LQ</p>
    <p>+</p>
    <p>Scheduling Predictor</p>
    <p>+</p>
    <p>flush?</p>
    <p>Reg File</p>
    <p>Issue Queue</p>
    <p>out-of-order core</p>
  </div>
  <div class="page">
    <p>[ 8 ]</p>
    <p>Conventional Design</p>
    <p>Loads  Execute: search SQ, write address into LQ</p>
    <p>Stores  Execute: write address/data to SQ, search LQ for early loads</p>
    <p>Map Table</p>
    <p>store</p>
    <p>D$SQ</p>
    <p>load</p>
    <p>free list</p>
    <p>LQ</p>
    <p>+</p>
    <p>Scheduling Predictor</p>
    <p>+</p>
    <p>flush?</p>
    <p>Reg File</p>
    <p>Issue Queue</p>
    <p>out-of-order core</p>
  </div>
  <div class="page">
    <p>[ 9 ]</p>
    <p>Conventional Design</p>
    <p>Loads  Execute: search SQ, write address into LQ</p>
    <p>Stores  Execute: write address/data to SQ, search LQ for early loads  Commit: use data/address from SQ to write D$</p>
    <p>Map Table</p>
    <p>store</p>
    <p>D$SQ</p>
    <p>load</p>
    <p>free list</p>
    <p>LQ</p>
    <p>+</p>
    <p>flush?</p>
    <p>Scheduling Predictor</p>
    <p>+</p>
    <p>Reg File</p>
    <p>Issue Queue</p>
    <p>out-of-order core</p>
  </div>
  <div class="page">
    <p>[ 10 ]</p>
    <p>+ In-Order Load Re-Execution [Cain+04]</p>
    <p>Scheduling Predictor</p>
    <p>Map Table</p>
    <p>store</p>
    <p>D$SQ</p>
    <p>load</p>
    <p>free list</p>
    <p>+</p>
    <p>LQ</p>
    <p>+</p>
    <p>flush?</p>
    <p>Reg File</p>
    <p>Issue Queue</p>
    <p>out-of-order core</p>
  </div>
  <div class="page">
    <p>[ 11 ]</p>
    <p>+ In-Order Load Re-Execution [Cain+04]</p>
    <p>Replace LQ search with load re-execution prior to commit  Squash if in-order value != out-of-order value + Moves load queue out of core datapath + Can verify any form of load speculation  Consumes a lot of cache bandwidth if all loads are speculative</p>
    <p>Scheduling Predictor</p>
    <p>Map Table</p>
    <p>store</p>
    <p>D$SQ</p>
    <p>load</p>
    <p>free list</p>
    <p>+</p>
    <p>LQ</p>
    <p>+</p>
    <p>flush ? =</p>
    <p>flush?</p>
    <p>Reg File</p>
    <p>Issue Queue</p>
    <p>out-of-order core</p>
  </div>
  <div class="page">
    <p>[ 12 ]</p>
    <p>+ Store Vulnerability Window (SVW) [Roth05]</p>
    <p>Scheduling Predictor</p>
    <p>Map Table</p>
    <p>store</p>
    <p>D$SQ</p>
    <p>load</p>
    <p>free list</p>
    <p>+</p>
    <p>LQ</p>
    <p>Dont re-execute if no store to loads address in long time  Store Sequence Numbers (SSNs): formalize time  SSN Bloom Filter (SSBF): SSN of youngest store to address  Store commit: update SSBF  Load commit: read SSBF, skip re-execution if entry is older than</p>
    <p>Forwarding? forwarding store  Non-forwarding? youngest committed store at time of execute</p>
    <p>+</p>
    <p>flush? =</p>
    <p>SS BF</p>
    <p>Reg File</p>
    <p>Issue Queue</p>
    <p>out-of-order core</p>
    <p>re-exec?</p>
  </div>
  <div class="page">
    <p>[ 13 ]</p>
    <p>Speculative Memory Bypassing [Moshovos+97]</p>
    <p>add R1, 4  R2</p>
    <p>store R2  A</p>
    <p>load A  R3</p>
    <p>sub R3, 4  R4</p>
    <p>Raw insns:</p>
    <p>sub P3, 4  P4</p>
    <p>add P1, 4  P2</p>
    <p>store P2  A</p>
    <p>load A  P3</p>
    <p>Renamed insns:</p>
    <p>sub P2, 4  P4</p>
    <p>store P2  A</p>
    <p>load A  P2</p>
    <p>add P1, 4  P2</p>
    <p>SMB renamed insns:</p>
    <p>Convert DEF-store-load-USE to DEF-USE  Extend register renaming</p>
    <p>Map-table[store.input] := Map-table[DEF.output]  Predict store-load dependence  Map-table[load.output] := Map-table[store.input]</p>
    <p>+ Store-load removed from dataflow graph</p>
  </div>
  <div class="page">
    <p>[ 14 ]</p>
    <p>+ Speculative Memory Bypassing</p>
    <p>SRQ (store register queue): maps store to input data register</p>
    <p>Originally: verify bypassing loads by executing out-of-order Modification: verify using SVW-filtered re-execution [Petric+05]</p>
    <p>+ Bypassing loads skip out-of-order execution + Bypassing loads (~10%) never access data cache</p>
    <p>Map Table</p>
    <p>store</p>
    <p>Reg File D$SQ</p>
    <p>load</p>
    <p>free list</p>
    <p>+</p>
    <p>LQ</p>
    <p>+</p>
    <p>flush? =</p>
    <p>SS BF</p>
    <p>SRQ Bypassing Predictor</p>
    <p>Issue Queue</p>
    <p>re-exec?</p>
    <p>out-of-order core</p>
  </div>
  <div class="page">
    <p>[ 15 ]</p>
    <p>NoSQ: A New Use of SMB</p>
    <p>Load re-execution / SVW filtering: target design simplification  Eliminate associative load queue search</p>
    <p>Traditional SMB: targets performance improvement  SMB as opportunistic complement to store queue  Only 10% of loads forward  only 4% gains  Not worth the effort [Loh+02]</p>
    <p>NoSQ SMB: targets design simplification  SMB as exclusive replacement for store queue</p>
  </div>
  <div class="page">
    <p>[ 16 ]</p>
    <p>NoSQ 1: Remove Store Queue from Load Path</p>
    <p>Map Table</p>
    <p>store</p>
    <p>Reg File D$SQ</p>
    <p>load</p>
    <p>free list</p>
    <p>+</p>
    <p>LQ</p>
    <p>+</p>
    <p>flush? =</p>
    <p>SS BF</p>
    <p>SRQ Bypassing Predictor</p>
    <p>Issue Queue</p>
    <p>re-exec?</p>
    <p>Loads dont need to access store queue during execution  Bypassing loads: skip out-of-order execution (SMB)  Non-bypassing loads: get values from the data cache</p>
    <p>out-of-order core</p>
  </div>
  <div class="page">
    <p>[ 17 ]</p>
    <p>NoSQ 1: Remove Store Queue from Load Path</p>
    <p>Loads dont need to access store queue during execution  Bypassing loads: skip out-of-order execution (SMB)  Non-bypassing loads: get values from the data cache</p>
    <p>Remove store queue from the the load path</p>
    <p>Map Table</p>
    <p>store</p>
    <p>Reg File D$SQ</p>
    <p>load</p>
    <p>free list</p>
    <p>+</p>
    <p>LQ</p>
    <p>+</p>
    <p>flush? =</p>
    <p>SS BF</p>
    <p>SRQ Bypassing Predictor</p>
    <p>Issue Queue</p>
    <p>re-exec?</p>
    <p>out-of-order core</p>
  </div>
  <div class="page">
    <p>[ 18 ]</p>
    <p>NoSQ 2: Remove Store Queue</p>
    <p>Map Table</p>
    <p>store</p>
    <p>Reg File D$</p>
    <p>load</p>
    <p>free list</p>
    <p>+</p>
    <p>LQ</p>
    <p>flush? =</p>
    <p>SS BF</p>
    <p>SRQ SQ</p>
    <p>+</p>
    <p>Bypassing Predictor</p>
    <p>Issue Queue</p>
    <p>re-exec?</p>
    <p>out-of-order core</p>
  </div>
  <div class="page">
    <p>[ 19 ]</p>
    <p>NoSQ 2: Remove Store Queue</p>
    <p>Move store execution from out-of-order to commit  Extend ROB to remember store registers, offsets and data sizes  Elongate commit pipeline to read register file, calculate address + No additional regfile ports, adders: out-of-order ports  in-order ports</p>
    <p>Dont dispatch stores to out-of-order core</p>
    <p>Eliminate store queue</p>
    <p>Bypassing Predictor</p>
    <p>Map Table</p>
    <p>store</p>
    <p>Reg File D$</p>
    <p>load</p>
    <p>free list</p>
    <p>+</p>
    <p>LQ</p>
    <p>flush? =</p>
    <p>SS BF</p>
    <p>SRQ SQ</p>
    <p>Issue Queue</p>
    <p>re-exec?</p>
    <p>+</p>
    <p>out-of-order core</p>
  </div>
  <div class="page">
    <p>[ 20 ]</p>
    <p>NoSQ 3: Remove Load Queue</p>
    <p>Map Table</p>
    <p>store</p>
    <p>Reg File D$</p>
    <p>load</p>
    <p>free list</p>
    <p>+ +</p>
    <p>flush? =</p>
    <p>SRQ LQ</p>
    <p>SS BF</p>
    <p>Bypassing Predictor</p>
    <p>Issue Queue</p>
    <p>re-exec?</p>
    <p>out-of-order core</p>
  </div>
  <div class="page">
    <p>[ 21 ]</p>
    <p>NoSQ 3: Remove Load Queue</p>
    <p>Map Table</p>
    <p>store</p>
    <p>Reg File D$</p>
    <p>load</p>
    <p>free list</p>
    <p>+ +</p>
    <p>flush? =</p>
    <p>SRQ LQ</p>
    <p>Generate addresses for bypassed loads at commit (to verify)  ROB is already extended, pipeline already elongated</p>
    <p>SS BF</p>
    <p>Bypassing Predictor</p>
    <p>Issue Queue</p>
    <p>re-exec?</p>
    <p>out-of-order core</p>
  </div>
  <div class="page">
    <p>[ 22 ]</p>
    <p>NoSQ 3: Remove Load Queue</p>
    <p>Generate addresses for bypassed loads at commit (to verify)  ROB is already extended, pipeline already elongated</p>
    <p>Re-generate addresses for non-bypassed loads at commit  May need additional register read port</p>
    <p>Map Table</p>
    <p>store</p>
    <p>Reg File D$</p>
    <p>load</p>
    <p>free list</p>
    <p>+ +</p>
    <p>flush? =</p>
    <p>SS BF</p>
    <p>SRQ LQ</p>
    <p>Bypassing Predictor</p>
    <p>Issue Queue</p>
    <p>re-exec?</p>
    <p>out-of-order core</p>
  </div>
  <div class="page">
    <p>[ 23 ]</p>
    <p>NoSQ 3: Remove Load Queue</p>
    <p>Generate addresses for bypassed loads at commit (to verify)  ROB is already extended, pipeline already elongated</p>
    <p>Re-generate addresses for non-bypassed loads at commit  May need additional register read port</p>
    <p>Eliminate load queue</p>
    <p>Map Table</p>
    <p>store</p>
    <p>Reg File D$</p>
    <p>load</p>
    <p>free list</p>
    <p>+ +</p>
    <p>flush? =</p>
    <p>SS BF</p>
    <p>SRQ LQ</p>
    <p>Bypassing Predictor</p>
    <p>Issue Queue</p>
    <p>re-exec?</p>
    <p>out-of-order core</p>
  </div>
  <div class="page">
    <p>[ 24 ]</p>
    <p>Once Again: Conventional Design</p>
    <p>Map Table</p>
    <p>store</p>
    <p>D$SQ</p>
    <p>load</p>
    <p>free list</p>
    <p>LQ</p>
    <p>+</p>
    <p>flush?</p>
    <p>Scheduling Predictor</p>
    <p>+</p>
    <p>Reg File</p>
    <p>Issue Queue</p>
    <p>out-of-order core</p>
  </div>
  <div class="page">
    <p>[ 25 ]</p>
    <p>NoSQ</p>
    <p>Map Table</p>
    <p>store</p>
    <p>Reg File D$</p>
    <p>load</p>
    <p>free list</p>
    <p>+ +</p>
    <p>flush? =</p>
    <p>SS BF</p>
    <p>SRQ Bypassing Predictor</p>
    <p>Issue Queue</p>
    <p>re-exec?</p>
    <p>out-of-order core</p>
  </div>
  <div class="page">
    <p>[ 26 ]</p>
    <p>Road Map</p>
    <p>Overview</p>
    <p>From conventional to NoSQ  Conventional store-load forwarding  Load verification with filtered load re-execution  Speculative memory bypassing</p>
    <p>NoSQ  Eliminating out-of-order stores and the store queue  Eliminating the load queue  NoSQs store-load bypassing predictor</p>
    <p>Evaluation</p>
  </div>
  <div class="page">
    <p>[ 27 ]</p>
    <p>NoSQs Store-Load Bypassing Prediction</p>
    <p>Similar to previous store-load prediction, but more difficult</p>
    <p>Load scheduling prediction: [Chrysos+98,]  Can predict store conservatively, predicts only violating loads</p>
    <p>Speculative forwarding prediction [Sha+05,]  Must predict all loads, but benefits from store-load address check</p>
    <p>Traditional bypassing prediction [Moshovos+97,]  No address check, but can decline to predict difficult loads</p>
    <p>NoSQs bypassing prediction  Must predict all loads, precise store, no address check</p>
  </div>
  <div class="page">
    <p>[ 28 ]</p>
    <p>Distance-Based Dependence Prediction</p>
    <p>Predictor interface: load PC  dynamic store</p>
    <p>Load PC  store PC(s)  dynamic store  E.g., Store Sets [Chrysos+98], Speculative indexed SQ [Sha+05]  Store PC  dynamic store requires table  Can only (easily) represent most recent instance of each store PC</p>
    <p>Load PC  distance (in stores) to store  dynamic store  E.g., [Lipasti+97, Yoaz+98] + Can represent any store instance + Dovetails with SVW: just compare/subtract distances/SSNs</p>
    <p>Predict: load.SSNbypass = SSNrename  load.distancebypass  Verify: load.SSNbypass == SSBF[load.address]  Train: load.distancebypass = SSNcommit  SSBF[load.address]</p>
  </div>
  <div class="page">
    <p>[ 29 ]</p>
    <p>Predictor Design</p>
    <p>Each entry includes tag, store distance</p>
    <p>Explicitly path-sensitive design  Two tables: path-insensitive + path-sensitive</p>
    <p>Both set-associative  Predict: prefer path-sensitive prediction  Train: update both tables on every load commit</p>
    <p>load PC</p>
    <p>xor</p>
    <p>branch+call history</p>
    <p>disttag</p>
    <p>disttag</p>
    <p>distance to forwarding store</p>
  </div>
  <div class="page">
    <p>[ 30 ]</p>
    <p>Evaluation</p>
    <p>Goal  No store queue or load queue  Same (or better) IPC as conventional design</p>
    <p>Bypassing mis-predictions  Deeper commit pipeline + Latency benefit of SMB + Reduced consumption of issue bandwidth and queue slots</p>
    <p>Simulation environment  SPECint2000, SPECfp2000, Mediabench (only show 9)</p>
    <p>Dynamically scheduled 4-way superscalar  128-ROB, 40-entry issue queue, 11-stage front-end/core  Base: 24/48-entry SQ/LQ, 2K-entry Store Sets, 6 stage commit  NoSQ: No SQ/LQ, 2K-entry predictor, 8 stage commit</p>
  </div>
  <div class="page">
    <p>[ 31 ]</p>
    <p>mesa.t pegwit.d gcc perl.s applu apsi swim g721.e vpr.p Gmean</p>
    <p>R e</p>
    <p>la tiv</p>
    <p>e e</p>
    <p>xe c u</p>
    <p>tio n</p>
    <p>t im</p>
    <p>e NoSQ Performance</p>
    <p>+ On average: slightly outperforms conventional design + Prediction accuracy is ~99.8% (15 mis-predictions per 10,000 loads)</p>
    <p>In a few cases: slowdowns  10 of 47 benchmarks &gt;1% slowdown (worst case 7%)</p>
    <p>NoSQ</p>
  </div>
  <div class="page">
    <p>[ 32 ]</p>
    <p>Avoid Bypass Mis-Predictions with Delay</p>
    <p>Two kinds of bypassing mis-predictions  Difficult to predict</p>
    <p>Long signature, data dependent, predictor conflicts, etc.  Simply cannot be bypassed</p>
    <p>Narrow-store to wide-load  NoSQ can do wide-store/narrow-load and narrow-store/narrow-load</p>
    <p>See paper</p>
    <p>Catch-all: convert bypassing to delayed non-bypassing load  Inject it to the out-of-order core  But delay it until the predicted bypassing store commits  Load gets value from data cache  Attach a confidence counter to each predictor entry</p>
  </div>
  <div class="page">
    <p>[ 33 ]</p>
    <p>mesa.t pegwit.d gcc perl.s applu apsi swim g721.e vpr.p Gmean</p>
    <p>R e</p>
    <p>la tiv</p>
    <p>e e</p>
    <p>xe c u</p>
    <p>tio n</p>
    <p>t im</p>
    <p>e NoSQ with Delay</p>
    <p>+ Robust performance: only 1 of 47 benchmarks &gt; 1%  Overdelay hurts sometimes, but not too bad</p>
    <p>+ As fast or faster than conventional in almost all cases</p>
    <p>NoSQ NoSQ + delay</p>
  </div>
  <div class="page">
    <p>[ 34 ]</p>
    <p>NoSQ with Perfect Predictor</p>
    <p>+ Only 2% between realistic and perfect predictor</p>
    <p>See paper for  Predictor scalability, data cache accesses, etc.</p>
    <p>mesa.t pegwit.d gcc perl.s applu apsi swim g721.e vpr.p Gmean</p>
    <p>R e</p>
    <p>la tiv</p>
    <p>e e</p>
    <p>xe c u</p>
    <p>tio n</p>
    <p>t im</p>
    <p>e NoSQ NoSQ + delay NoSQ + perfect predictor</p>
  </div>
  <div class="page">
    <p>[ 35 ]</p>
    <p>Conclusions</p>
    <p>Conventional store queue / load queue  Complex, non scalable  Exist for the benefit of 10% forwarding loads</p>
    <p>NoSQ  Exploits synergy of previously proposed mechanisms</p>
    <p>Re-execution with SVW filter, speculative memory bypassing  New highly-accurate bypassing predictor + Simple, clean data path with no store queue/load queue</p>
    <p>More scalable out-of-order core  Fits well with distributed, partitioned cores (e.g., SMT)</p>
    <p>+ Outperforms conventional design</p>
    <p>Store-Load Forwarding: Just Say NoSQ!</p>
  </div>
  <div class="page">
    <p>Thank you.</p>
    <p>Tingting Sha, Milo M.K. Martin, Amir Roth University of Pennsylvania</p>
    <p>{shatingt, milom, amir}@cis.upenn.edu http://www.cis.upenn.edu/acg</p>
  </div>
  <div class="page">
    <p>[ 37 ]</p>
  </div>
</Presentation>
