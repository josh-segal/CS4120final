<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Capturing and Enhancing In Situ System Observability for</p>
    <p>Failure Detection Ryan Huang</p>
    <p>Chuanxiong Guo, Jacob R. Lorch, Lidong Zhou, Yingnong Dang+</p>
    <p>+ByteDance Inc. Microsoft Research MicrosoftJohns Hopkins University</p>
  </div>
  <div class="page">
    <p>Faults Are Common in Large Systems</p>
    <p>Hardware Faults Software Bugs Misconfiguration</p>
    <p>2</p>
    <p>int len = in.readInt(); if (len == -1) return null; byte arr[] = new byte[len]; in.readFully(arr); return arr;</p>
  </div>
  <div class="page">
    <p>Detecting Failure Is Crucial</p>
    <p>Availability  MTBF</p>
    <p>MTBF + MTTR Improve reliability</p>
    <p>Speed up recovery[1]</p>
    <p>FD is a fundamental building block for fault-tolerant systems</p>
    <p>[1] Recovery Oriented Computing (ROC): Motivation, Definition, Techniques, and Case Studies 3</p>
  </div>
  <div class="page">
    <p>Detecting Failure Is Crucial</p>
    <p>Availability  MTBF</p>
    <p>MTBF + MTTR Improve reliability</p>
    <p>Speed up recovery[1]</p>
    <p>FD is a fundamental building block for fault-tolerant systems</p>
    <p>[1] Recovery Oriented Computing (ROC): Motivation, Definition, Techniques, and Case Studies</p>
    <p>But only if failure can be detected reliably and rapidly first</p>
    <p>3</p>
  </div>
  <div class="page">
    <p>Failure Detection is Hard</p>
    <p>4</p>
    <p>Extensively studied for several decades</p>
    <p>Focus on detection of fail-stop failures in asynchronous systems</p>
    <p>Difficult to reliably determine whether a process has crashed or is merely &quot;very slow&quot;</p>
  </div>
  <div class="page">
    <p>Production Failures Beyond Fail-Stop</p>
    <p>A component status can be between UP and DOWN: gray failure</p>
    <p>E.g., fail-slow hardware, random packet loss, limp lock, ...</p>
    <p>Failure symptoms are very subtle</p>
    <p>Common in production cloud systems</p>
    <p>Pose new challenges for failure detection</p>
    <p>5</p>
  </div>
  <div class="page">
    <p>An Example Production Gray Failure</p>
    <p>6</p>
    <p>Follower Follower Follower FollowerLeader</p>
    <p>Propose</p>
    <p>Ack</p>
    <p>Commit</p>
    <p>Propose</p>
    <p>Ack</p>
    <p>Commit</p>
    <p>Client</p>
    <p>ZooKeeper</p>
  </div>
  <div class="page">
    <p>An Example Production Gray Failure</p>
    <p>6</p>
    <p>Follower Follower Follower FollowerLeader</p>
    <p>Propose</p>
    <p>Ack</p>
    <p>Commit</p>
    <p>Propose</p>
    <p>Ack</p>
    <p>Commit</p>
    <p>Client</p>
    <p>CREATE</p>
    <p>CREATE</p>
    <p>WRITE</p>
    <p>READ</p>
    <p>ZooKeeper</p>
  </div>
  <div class="page">
    <p>An Example Production Gray Failure</p>
    <p>6</p>
    <p>Follower Follower Follower FollowerLeader</p>
    <p>Heartbeat Heartbeat</p>
    <p>Propose</p>
    <p>Ack</p>
    <p>Commit</p>
    <p>Propose</p>
    <p>Ack</p>
    <p>Commit</p>
    <p>Client</p>
    <p>CREATE</p>
    <p>CREATE</p>
    <p>WRITE</p>
    <p>READ</p>
    <p>ZooKeeper</p>
  </div>
  <div class="page">
    <p>An Example Production Gray Failure</p>
    <p>6</p>
    <p>Follower Follower Follower FollowerLeader</p>
    <p>Heartbeat Heartbeat</p>
    <p>Propose</p>
    <p>Ack</p>
    <p>Commit</p>
    <p>Propose</p>
    <p>Ack</p>
    <p>Commit</p>
    <p>Client</p>
    <p>CREATE</p>
    <p>CREATE</p>
    <p>WRITE</p>
    <p>READ</p>
    <p>ZooKeeper</p>
  </div>
  <div class="page">
    <p>An Example Production Gray Failure</p>
    <p>6</p>
    <p>Follower Follower Follower FollowerLeader</p>
    <p>Heartbeat Heartbeat</p>
    <p>Propose</p>
    <p>Ack</p>
    <p>Commit</p>
    <p>Propose</p>
    <p>Ack</p>
    <p>Commit</p>
    <p>Client</p>
    <p>CREATE</p>
    <p>CREATE</p>
    <p>WRITE</p>
    <p>READ</p>
    <p>&quot;RUOK&quot;</p>
    <p>ZooKeeper</p>
  </div>
  <div class="page">
    <p>An Example Production Gray Failure</p>
    <p>6</p>
    <p>Follower Follower Follower FollowerLeader</p>
    <p>Heartbeat Heartbeat</p>
    <p>Propose</p>
    <p>Ack</p>
    <p>Commit</p>
    <p>Propose</p>
    <p>Ack</p>
    <p>Commit</p>
    <p>Client</p>
    <p>CREATE</p>
    <p>CREATE</p>
    <p>WRITE</p>
    <p>READ</p>
    <p>&quot;RUOK&quot; &quot;IMOK&quot;</p>
    <p>ZooKeeper</p>
  </div>
  <div class="page">
    <p>7</p>
    <p>Root Cause of the Gray Failure</p>
    <p>Leader</p>
    <p>Client</p>
    <p>Request Processor</p>
    <p>Serialize Heartbeat</p>
    <p>Stuck due to transient network issue synchronized (node) { output.writeString(path, &quot;path&quot;); output.writeRecord(node, &quot;node&quot;); }</p>
  </div>
  <div class="page">
    <p>Provider</p>
    <p>Manager</p>
    <p>Failure Detector</p>
    <p>Requester</p>
    <p>Control Path Data Path</p>
    <p>Insight: we should detect what the requesters see</p>
    <p>8</p>
    <p>Requester</p>
    <p>Requester</p>
    <p>Monitoring Service</p>
    <p>he art</p>
    <p>be at</p>
    <p>process_id</p>
    <p>CPU usa</p>
    <p>ge</p>
    <p>Mem Usa</p>
    <p>ge</p>
    <p>Max Lat</p>
    <p>enc y</p>
  </div>
  <div class="page">
    <p>Insight 1: Critical Gray Failures Are Observable</p>
    <p>9Leader</p>
    <p>Request Processor</p>
    <p>Serialize Heartbeat</p>
  </div>
  <div class="page">
    <p>Insight 1: Critical Gray Failures Are Observable</p>
    <p>9Leader</p>
    <p>Request Processor</p>
    <p>Serialize Heartbeat</p>
    <p>Cassandra Lock</p>
    <p>Lock timeout Unhandled requests accumulating</p>
  </div>
  <div class="page">
    <p>Insight 1: Critical Gray Failures Are Observable</p>
    <p>9Leader</p>
    <p>Request Processor</p>
    <p>Serialize Heartbeat</p>
    <p>Follower</p>
    <p>GetSnapshot Socket I/O exception</p>
    <p>Cassandra Lock</p>
    <p>Lock timeout Unhandled requests accumulating</p>
  </div>
  <div class="page">
    <p>Insight 2: From Error Handling to Error Reporting</p>
    <p>10</p>
    <p>void syncWithLeader(long newLeaderZxid) { try { deserializeSnapshot(leaderIs); String sig = leaderIs.read(&quot;signature&quot;); if (!sig.equals(&quot;BenWasHere&quot;)) throw new IOException(&quot;Bad signature&quot;); } else { LOG.error(&quot;Unexpected leader packet.&quot;); System.exit(13); } catch (IOException e) { LOG.warn(&quot;Exception sync with leader&quot;, e); sock.close(); } }</p>
  </div>
  <div class="page">
    <p>Insight 2: From Error Handling to Error Reporting</p>
    <p>10</p>
    <p>void syncWithLeader(long newLeaderZxid) { try { deserializeSnapshot(leaderIs); String sig = leaderIs.read(&quot;signature&quot;); if (!sig.equals(&quot;BenWasHere&quot;)) throw new IOException(&quot;Bad signature&quot;); } else { LOG.error(&quot;Unexpected leader packet.&quot;); System.exit(13); } catch (IOException e) { LOG.warn(&quot;Exception sync with leader&quot;, e); sock.close(); } }</p>
    <p>CATS : ALL YOUR ERROR HANDLER ARE BELONG TO US.</p>
  </div>
  <div class="page">
    <p>Our Solution: Panorama</p>
    <p>11</p>
    <p>Master A</p>
    <p>Cache A</p>
    <p>RegionServer A</p>
    <p>Panorama Instance</p>
    <p>FrontEnd A</p>
    <p>Panorama Instance</p>
    <p>Panorama Instance</p>
    <p>Panorama Instance</p>
    <p>DataNode B</p>
    <p>Panorama Instance</p>
    <p>Thread A</p>
    <p>Thread B</p>
    <p>Thread C</p>
    <p>DataNode A</p>
    <p>Panorama Instance</p>
    <p>Software In-situ</p>
    <p>Observer</p>
    <p>A tool to turn a software into an observer</p>
    <p>Uniform observation abstractions</p>
    <p>A generic failure detection service for any component to participate</p>
  </div>
  <div class="page">
    <p>Overview of Panorama - Analysis</p>
    <p>12</p>
    <p>...</p>
    <p>void func() { try { sync(t); } catch (RemoteError e) { LOG.error(e); retry(); } }</p>
    <p>...</p>
    <p>Original Software Instrumented Software</p>
    <p>...</p>
    <p>void func() { try { sync(t); } catch (RemoteError e) { + report_observation(t, e); LOG.error(e); retry(); } }</p>
    <p>...</p>
    <p>Offline static analysis</p>
    <p>Instrumentation</p>
    <p>+</p>
    <p>+</p>
    <p>observability hooks+</p>
    <p>Automatically convert a software component into an in-situ observer</p>
  </div>
  <div class="page">
    <p>Overview of Panorama - Runtime</p>
    <p>13</p>
    <p>Instrumented Software</p>
    <p>...</p>
    <p>void func() { try { sync(t); } catch (RemoteError e) { + report_observation(t, e); LOG.error(e); retry(); } }</p>
    <p>... +</p>
    <p>+</p>
    <p>Component A</p>
    <p>Panorama Instance</p>
    <p>EndPoint</p>
    <p>observability hooks+</p>
  </div>
  <div class="page">
    <p>Overview of Panorama - Runtime</p>
    <p>13</p>
    <p>Instrumented Software</p>
    <p>...</p>
    <p>void func() { try { sync(t); } catch (RemoteError e) { + report_observation(t, e); LOG.error(e); retry(); } }</p>
    <p>... +</p>
    <p>+</p>
    <p>Component A</p>
    <p>Panorama Instance</p>
    <p>EndPoint</p>
    <p>observability hooks+</p>
    <p>Component B</p>
  </div>
  <div class="page">
    <p>Overview of Panorama - Runtime</p>
    <p>13</p>
    <p>Instrumented Software</p>
    <p>...</p>
    <p>void func() { try { sync(t); } catch (RemoteError e) { + report_observation(t, e); LOG.error(e); retry(); } }</p>
    <p>... +</p>
    <p>+</p>
    <p>Component A</p>
    <p>Panorama Instance</p>
    <p>EndPoint</p>
    <p>observability hooks+</p>
    <p>Component B</p>
    <p>Observer</p>
  </div>
  <div class="page">
    <p>Overview of Panorama - Runtime</p>
    <p>13</p>
    <p>Instrumented Software</p>
    <p>...</p>
    <p>void func() { try { sync(t); } catch (RemoteError e) { + report_observation(t, e); LOG.error(e); retry(); } }</p>
    <p>... +</p>
    <p>+</p>
    <p>Component A</p>
    <p>Panorama Instance</p>
    <p>EndPoint</p>
    <p>observability hooks+</p>
    <p>Component B</p>
    <p>Subject Observer</p>
  </div>
  <div class="page">
    <p>Overview of Panorama - Runtime</p>
    <p>13</p>
    <p>Instrumented Software</p>
    <p>...</p>
    <p>void func() { try { sync(t); } catch (RemoteError e) { + report_observation(t, e); LOG.error(e); retry(); } }</p>
    <p>... +</p>
    <p>+</p>
    <p>Component A</p>
    <p>Panorama Instance</p>
    <p>EndPoint</p>
    <p>observability hooks+</p>
    <p>Component B</p>
    <p>Subject Observer</p>
    <p>Context</p>
  </div>
  <div class="page">
    <p>Overview of Panorama - Runtime</p>
    <p>13</p>
    <p>Instrumented Software</p>
    <p>...</p>
    <p>void func() { try { sync(t); } catch (RemoteError e) { + report_observation(t, e); LOG.error(e); retry(); } }</p>
    <p>... +</p>
    <p>+</p>
    <p>Component A</p>
    <p>Panorama Instance</p>
    <p>EndPoint</p>
    <p>Local RPCSubmitReport(subject, observation, context)</p>
    <p>observability hooks+</p>
    <p>Component B</p>
    <p>Subject Observer</p>
    <p>Context</p>
    <p>Local Observation Store (LOS)</p>
  </div>
  <div class="page">
    <p>Overview of Panorama - Runtime</p>
    <p>13</p>
    <p>Instrumented Software</p>
    <p>...</p>
    <p>void func() { try { sync(t); } catch (RemoteError e) { + report_observation(t, e); LOG.error(e); retry(); } }</p>
    <p>... +</p>
    <p>+</p>
    <p>Component A</p>
    <p>Panorama Instance</p>
    <p>EndPoint</p>
    <p>Local RPCSubmitReport(subject, observation, context)</p>
    <p>Propagate(report)</p>
    <p>observability hooks+</p>
    <p>Component B</p>
    <p>Subject Observer</p>
    <p>Context</p>
    <p>Local Observation Store (LOS)</p>
  </div>
  <div class="page">
    <p>Overview of Panorama - Runtime</p>
    <p>13</p>
    <p>Instrumented Software</p>
    <p>...</p>
    <p>void func() { try { sync(t); } catch (RemoteError e) { + report_observation(t, e); LOG.error(e); retry(); } }</p>
    <p>... +</p>
    <p>+</p>
    <p>Component A</p>
    <p>Panorama Instance</p>
    <p>EndPoint</p>
    <p>Local RPCSubmitReport(subject, observation, context)</p>
    <p>Propagate(report)Learn(report)</p>
    <p>observability hooks+</p>
    <p>Component B</p>
    <p>Subject Observer</p>
    <p>Context</p>
    <p>Local Observation Store (LOS)</p>
  </div>
  <div class="page">
    <p>Overview of Panorama - Runtime</p>
    <p>13</p>
    <p>Instrumented Software</p>
    <p>...</p>
    <p>void func() { try { sync(t); } catch (RemoteError e) { + report_observation(t, e); LOG.error(e); retry(); } }</p>
    <p>... +</p>
    <p>+</p>
    <p>Component A</p>
    <p>Panorama Instance</p>
    <p>EndPoint</p>
    <p>Local RPCSubmitReport(subject, observation, context)</p>
    <p>Propagate(report)Learn(report)</p>
    <p>Judge (subject)</p>
    <p>observability hooks+</p>
    <p>Component B</p>
    <p>Subject Observer</p>
    <p>Context</p>
    <p>Verdict</p>
    <p>Local Observation Store (LOS)</p>
  </div>
  <div class="page">
    <p>Overview of Panorama - Runtime</p>
    <p>13</p>
    <p>Instrumented Software</p>
    <p>...</p>
    <p>void func() { try { sync(t); } catch (RemoteError e) { + report_observation(t, e); LOG.error(e); retry(); } }</p>
    <p>... +</p>
    <p>+</p>
    <p>Component A</p>
    <p>Panorama Instance</p>
    <p>EndPoint</p>
    <p>Local RPCSubmitReport(subject, observation, context)</p>
    <p>Propagate(report)Learn(report)</p>
    <p>Judge (subject)</p>
    <p>observability hooks+</p>
    <p>Component B</p>
    <p>Subject Observer</p>
    <p>Context</p>
    <p>Verdict</p>
    <p>Local Observation Store (LOS)</p>
    <p>This talk focuses on the analysis stage; see paper for details of the runtime service</p>
  </div>
  <div class="page">
    <p>Design Challenges</p>
    <p>Observations dispersed in softwares source code</p>
    <p>Observation collection may slow down observers normal service</p>
    <p>Diverse programming paradigms affect observability</p>
    <p>14</p>
  </div>
  <div class="page">
    <p>Observability Analysis</p>
    <p>Step : locate domain-crossing invocations (ob-boundary)</p>
    <p>Step : identify observer and observed</p>
    <p>Step : extract observation (ob-point)</p>
    <p>15</p>
  </div>
  <div class="page">
    <p>Example of Observability Analysis</p>
    <p>16</p>
    <p>void deserialize(DataTree dt, InputArchive ia) { DataNode node = ia.readRecord(&quot;node&quot;); if (node.parent == null) { LOG.error(&quot;Missing parent.&quot;); throw new IOException(&quot;Invalid Datatree&quot;); } dt.add(node); } void snapshot() { InputArchive ia = BinaryInputArchive.getArchive(sock.getInputStream()); try { deserialize(getDataTree(), ia); } catch (IOException e) { sock.close(); } }</p>
  </div>
  <div class="page">
    <p>Example of Observability Analysis</p>
    <p>16</p>
    <p>void deserialize(DataTree dt, InputArchive ia) { DataNode node = ia.readRecord(&quot;node&quot;); if (node.parent == null) { LOG.error(&quot;Missing parent.&quot;); throw new IOException(&quot;Invalid Datatree&quot;); } dt.add(node); } void snapshot() { InputArchive ia = BinaryInputArchive.getArchive(sock.getInputStream()); try { deserialize(getDataTree(), ia); } catch (IOException e) { sock.close(); } }</p>
    <p>locate ob-boundary1</p>
  </div>
  <div class="page">
    <p>Example of Observability Analysis</p>
    <p>16</p>
    <p>void deserialize(DataTree dt, InputArchive ia) { DataNode node = ia.readRecord(&quot;node&quot;); if (node.parent == null) { LOG.error(&quot;Missing parent.&quot;); throw new IOException(&quot;Invalid Datatree&quot;); } dt.add(node); } void snapshot() { InputArchive ia = BinaryInputArchive.getArchive(sock.getInputStream()); try { deserialize(getDataTree(), ia); } catch (IOException e) { sock.close(); } }</p>
    <p>locate ob-boundary1</p>
  </div>
  <div class="page">
    <p>Example of Observability Analysis</p>
    <p>16</p>
    <p>void deserialize(DataTree dt, InputArchive ia) { DataNode node = ia.readRecord(&quot;node&quot;); if (node.parent == null) { LOG.error(&quot;Missing parent.&quot;); throw new IOException(&quot;Invalid Datatree&quot;); } dt.add(node); } void snapshot() { InputArchive ia = BinaryInputArchive.getArchive(sock.getInputStream()); try { deserialize(getDataTree(), ia); } catch (IOException e) { sock.close(); } }</p>
    <p>locate ob-boundary1</p>
  </div>
  <div class="page">
    <p>Example of Observability Analysis</p>
    <p>16</p>
    <p>void deserialize(DataTree dt, InputArchive ia) { DataNode node = ia.readRecord(&quot;node&quot;); if (node.parent == null) { LOG.error(&quot;Missing parent.&quot;); throw new IOException(&quot;Invalid Datatree&quot;); } dt.add(node); } void snapshot() { InputArchive ia = BinaryInputArchive.getArchive(sock.getInputStream()); try { deserialize(getDataTree(), ia); } catch (IOException e) { sock.close(); } }</p>
    <p>locate ob-boundary</p>
    <p>extract observation (ob-point)</p>
    <p>(invalid reply)</p>
  </div>
  <div class="page">
    <p>Example of Observability Analysis</p>
    <p>16</p>
    <p>void deserialize(DataTree dt, InputArchive ia) { DataNode node = ia.readRecord(&quot;node&quot;); if (node.parent == null) { LOG.error(&quot;Missing parent.&quot;); throw new IOException(&quot;Invalid Datatree&quot;); } dt.add(node); } void snapshot() { InputArchive ia = BinaryInputArchive.getArchive(sock.getInputStream()); try { deserialize(getDataTree(), ia); } catch (IOException e) { sock.close(); } }</p>
    <p>locate ob-boundary</p>
    <p>extract observation (ob-point)</p>
    <p>(invalid reply)</p>
  </div>
  <div class="page">
    <p>Example of Observability Analysis</p>
    <p>16</p>
    <p>void deserialize(DataTree dt, InputArchive ia) { DataNode node = ia.readRecord(&quot;node&quot;); if (node.parent == null) { LOG.error(&quot;Missing parent.&quot;); throw new IOException(&quot;Invalid Datatree&quot;); } dt.add(node); } void snapshot() { InputArchive ia = BinaryInputArchive.getArchive(sock.getInputStream()); try { deserialize(getDataTree(), ia); } catch (IOException e) { sock.close(); } }</p>
    <p>locate ob-boundary</p>
    <p>extract observation (ob-point)</p>
    <p>extract observation (ob-point)</p>
    <p>(invalid reply)</p>
    <p>(no reply)</p>
  </div>
  <div class="page">
    <p>Locate Observation Boundary</p>
    <p>Function innovations that cross different components</p>
    <p>socket I/O, RPCs, messaging, etc.</p>
    <p>- java.io.DataOutput.write*()</p>
    <p>- org.apache.hadoop.hbase.ipc.RpcCall.sendResponseIfReady()</p>
    <p>- protobuf.RegionServerStatusService.*()</p>
    <p>17</p>
  </div>
  <div class="page">
    <p>Identify Observer</p>
    <p>Observer identity is global and tracks the source of observations</p>
    <p>The id/name the process uses in the distributed system</p>
    <p>- e.g., QuorumServer.id (value from myid file in ZooKeeper service config)</p>
    <p>One-time registration with Panorama instance when the process starts</p>
    <p>Panorama builds a map between identity and endpoint address for reverse lookup</p>
    <p>18</p>
  </div>
  <div class="page">
    <p>Identify Observed (Subject)  Information is in the argument or object of ob-boundary</p>
    <p>Sometimes the information is provided by a proxy</p>
    <p>19</p>
    <p>public int sendRR(MessageOut message, InetAddress to, IAsyncCallback cb)</p>
    <p>lookup subject identity from address</p>
    <p>public NNCommand NNProtocolTranslatorPB.startCheckpoint(Registration registration)</p>
    <p>private NNProtocolPB rpcProxy;</p>
    <p>rpc HRegionServer.RegionServerStatusService.*(*)</p>
    <p>masterAddressTracker.getMasterAddress(false); // get master address from ZooKeeper</p>
    <p>subject identity in the field</p>
    <p>subject identity from ZooKeeper</p>
  </div>
  <div class="page">
    <p>Extract Negative Evidence  Errors/exceptions that originate from the ob-boundary</p>
    <p>instrument exception handlers</p>
    <p>needs to distinguish generic exceptions (e.g., IOException)</p>
    <p>Unexpected reply content</p>
    <p>intra-procedural analysis to look for errors that have control-dependency on the reply</p>
    <p>20</p>
    <p>if (!reply.sig.equals(&quot;BenWasHere&quot;)) error(&quot;Bad signature&quot;);</p>
  </div>
  <div class="page">
    <p>Successful invocation from ob-boundary</p>
    <p>it's OK to submit a positive observation immediately and later find errors in reply content</p>
    <p>If domain-crossing occurs frequently, positive observations are excessive</p>
    <p>coalesce similar positive ob-points that are located close together</p>
    <p>library buffers frequent observations and sends them as one aggregate observation</p>
    <p>21</p>
    <p>Extract Positive Evidence3</p>
  </div>
  <div class="page">
    <p>Design Challenges</p>
    <p>Observations dispersed in softwares source code</p>
    <p>Observation collection may slow down observers normal functionality</p>
    <p>Diverse programming paradigms affect observability</p>
    <p>22</p>
  </div>
  <div class="page">
    <p>Learning from a Subtle Case</p>
    <p>23Leader</p>
    <p>Client</p>
    <p>HeartbeatPrepRequest Processor</p>
    <p>ProposalRequest Processor</p>
    <p>FinalRequest Processor</p>
    <p>NIOServer CnxnFactory</p>
    <p>OutOfMemoryError due to corrupt packet</p>
  </div>
  <div class="page">
    <p>Learning from a Subtle Case</p>
    <p>23Leader</p>
    <p>Client</p>
    <p>Heartbeat</p>
    <p>try { firstProcessor.processRequest(si); } catch (RequestProcessorException e) { + report_observation(&quot;PrepRequestProcessor&quot;, UNHEALTHY); LOG.error(&quot;Unable to process request: &quot; + e); }</p>
    <p>PrepRequest Processor</p>
    <p>ProposalRequest Processor</p>
    <p>FinalRequest Processor</p>
    <p>NIOServer CnxnFactory</p>
    <p>OutOfMemoryError due to corrupt packet</p>
  </div>
  <div class="page">
    <p>Learning from a Subtle Case</p>
    <p>23Leader</p>
    <p>Client</p>
    <p>Heartbeat</p>
    <p>try { firstProcessor.processRequest(si); } catch (RequestProcessorException e) { + report_observation(&quot;PrepRequestProcessor&quot;, UNHEALTHY); LOG.error(&quot;Unable to process request: &quot; + e); }</p>
    <p>PrepRequest Processor</p>
    <p>ProposalRequest Processor</p>
    <p>FinalRequest Processor</p>
    <p>NIOServer CnxnFactory</p>
    <p>OutOfMemoryError due to corrupt packet</p>
    <p>PrepRequest Processor</p>
  </div>
  <div class="page">
    <p>Learning from a Subtle Case</p>
    <p>24Leader</p>
    <p>Client</p>
    <p>Heartbeat</p>
    <p>try { firstProcessor.processRequest(si); } catch (RequestProcessorException e) { + report_observation(&quot;PrepRequestProcessor&quot;, UNHEALTHY); LOG.error(&quot;Unable to process request: &quot; + e); }</p>
    <p>PrepRequest Processor</p>
    <p>ProposalRequest Processor</p>
    <p>FinalRequest Processor</p>
    <p>NIOServer CnxnFactory</p>
    <p>OutOfMemoryError due to corrupt packet</p>
    <p>PrepRequest Processor</p>
    <p>public class PrepRequestProcessor extends Thread { BlockingQueue&lt;Request&gt; requests = new ... void run() { while (true) { Request r = requests.take(); pRequest(r); // the OOM occurred inside } } public void processRequest(Request request) throws RequestProcessorException { requests.add(request); } }</p>
  </div>
  <div class="page">
    <p>Learning from a Subtle Case</p>
    <p>Indirection can reduce failure observability</p>
    <p>Evidence is made about the indirection layer instead of actual component</p>
    <p>25</p>
  </div>
  <div class="page">
    <p>Observability Design Patterns</p>
    <p>26</p>
    <p>C1 C2</p>
    <p>Request</p>
    <p>Reply</p>
    <p>C2's failure is observable to C1</p>
    <p>C1's failure is observable to C2</p>
    <p>Interaction of two components C1 and C2</p>
  </div>
  <div class="page">
    <p>Observability Design Patterns</p>
    <p>27</p>
    <p>C2's failure is unobservable to C1</p>
    <p>C1's failure is observable to C2 C1 C2</p>
    <p>Request</p>
    <p>Reply</p>
    <p>C1 C2</p>
    <p>Request</p>
    <p>Reply No indirection</p>
    <p>Interaction of two components C1 and C2</p>
  </div>
  <div class="page">
    <p>Observability Design Patterns</p>
    <p>27</p>
    <p>C2's failure is unobservable to C1</p>
    <p>C1's failure is observable to C2 C1 C2</p>
    <p>Request</p>
    <p>Reply</p>
    <p>C1 C2</p>
    <p>Request</p>
    <p>Reply No indirection</p>
    <p>Interaction of two components C1 and C2</p>
  </div>
  <div class="page">
    <p>Observability Design Patterns</p>
    <p>28</p>
    <p>Interaction of two components C1 and C2</p>
    <p>C1 C2</p>
    <p>Reply</p>
    <p>C1 C2</p>
    <p>Request</p>
    <p>Reply</p>
    <p>Request indirection</p>
    <p>Request</p>
    <p>No indirection</p>
  </div>
  <div class="page">
    <p>Observability Design Patterns</p>
    <p>28</p>
    <p>Interaction of two components C1 and C2</p>
    <p>C1 C2</p>
    <p>Reply</p>
    <p>C1 C2</p>
    <p>Request</p>
    <p>Reply</p>
    <p>Request indirection Reply indirection</p>
    <p>Request</p>
    <p>C1 C2</p>
    <p>Request</p>
    <p>Reply</p>
    <p>No indirection</p>
  </div>
  <div class="page">
    <p>Observability Design Patterns</p>
    <p>28</p>
    <p>Interaction of two components C1 and C2</p>
    <p>C1 C2</p>
    <p>Reply</p>
    <p>C1 C2</p>
    <p>Request</p>
    <p>Reply</p>
    <p>Request indirection Reply indirection</p>
    <p>Request</p>
    <p>C1 C2</p>
    <p>Request</p>
    <p>Reply</p>
    <p>No indirection Full indirection</p>
    <p>C1 C2</p>
    <p>Reply</p>
    <p>Request</p>
  </div>
  <div class="page">
    <p>Capture Observation w/ Indirection</p>
    <p>Fundamental issue is that an observation becomes split</p>
    <p>We call them ob-origin and ob-sink</p>
    <p>29</p>
    <p>positive, but temporary and weak evidence</p>
    <p>complete and strong evidence</p>
  </div>
  <div class="page">
    <p>Identify Ob-Origin and Ob-Sink</p>
    <p>Ob-origin is ob-boundary in asynchronous method</p>
    <p>Submit a PENDING observation after ob-origin</p>
    <p>Ob-sink lies in notification mechanism</p>
    <p>(1) callback set invocation; (2) blocking wait callback get; (3) checking a completion flag</p>
    <p>Submit a HEALTHY/UNHEALTHY observation before ob-sink (1) or after ob-sink (2), (3)</p>
    <p>30</p>
  </div>
  <div class="page">
    <p>Match Ob-Origin and Ob-Sink</p>
    <p>Match based on &lt;subject, context, [request_id]&gt;</p>
    <p>A later HEALTHY observation merges a past PENDING observation</p>
    <p>the positive observation is now complete</p>
    <p>A later UNHEALTHY observation overrides a past PENDING observation</p>
    <p>If PENDING observations outstanding for too long, degrade to UNHEALTHY</p>
    <p>31</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Panorama system implemented in Go + gRPC</p>
    <p>Easy to plug-in with different clients</p>
    <p>A thin library provides async reporting, buffering, etc.</p>
    <p>Most reporting does not directly trigger local RPCs</p>
    <p>Panorama analyzer implemented with Soot and AspectJ</p>
    <p>32</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>33</p>
    <p>Integration with real-world systems</p>
    <p>Catching crash and</p>
    <p>gray failures</p>
    <p>Reacting to transient failures Cost for observers</p>
    <p>Analysis Detection Service</p>
  </div>
  <div class="page">
    <p>Integration with Real-world Systems</p>
    <p>34 An</p>
    <p>al ys</p>
    <p>is T</p>
    <p>im e</p>
    <p>(s )</p>
    <p>ZooKeeper Cassandra HDFS HBase</p>
    <p>An no</p>
    <p>ta tio</p>
    <p>ns</p>
    <p>ZooKeeper Cassandra HDFS HBase</p>
    <p>Information about custom interfaces and async mechanisms. Most of them are reusable across different versions. Analysis and instrumentation are fast.</p>
  </div>
  <div class="page">
    <p>Detect Injected Crash Failures</p>
    <p>35</p>
    <p>D et</p>
    <p>ec tio</p>
    <p>n tim</p>
    <p>e (m</p>
    <p>s)</p>
    <p>Leader Follower</p>
    <p>Built-in Panorama</p>
    <p>ZooKeeper</p>
    <p>D et</p>
    <p>ec tio</p>
    <p>n tim</p>
    <p>e (s</p>
    <p>)</p>
    <p>Seed Datanode</p>
    <p>Built-in Panorama</p>
    <p>Cassandra</p>
    <p>D et</p>
    <p>ec tio</p>
    <p>n tim</p>
    <p>e (m</p>
    <p>s)</p>
    <p>Namenode Datanode</p>
    <p>Built-in Panorama</p>
    <p>HDFS</p>
    <p>Built-in crash failure detectors have to be conservative to deal with asynchrony.</p>
  </div>
  <div class="page">
    <p>Real-World Gray Failures</p>
    <p>36</p>
    <p>ID System Fault Synopsis f1 ZooKeeper faulty disk in leader causes cluster lock-up f2 ZooKeeper transient network partition leads to pro-longed failures in serving</p>
    <p>requestsf3 ZooKeeper corrupted packet in de-serialization f4 ZooKeeper transaction thread exception f5 ZooKeeper leader fails to write transaction log f6 Cassandra response drop blocks repair operations f7 Cassandra stale data in leads to wrong node states f8 Cassandra streaming silently fail on unexpected error f9 Cassandra commitlog executor exit causes GC storm f10 HDFS thread pool exhaustion in master f11 HDFS failed pipeline creation prevents recovery f12 HDFS short circuit reads blocked due to death of domain socket</p>
    <p>watcherf13 HDFS blockpool fails to initialize but continues f14 HBase dead root drive on region server f15 HBase replication stalls with empty WAL files</p>
  </div>
  <div class="page">
    <p>Real-World Gray Failures</p>
    <p>36</p>
    <p>ID System Fault Synopsis f1 ZooKeeper faulty disk in leader causes cluster lock-up f2 ZooKeeper transient network partition leads to pro-longed failures in serving</p>
    <p>requestsf3 ZooKeeper corrupted packet in de-serialization f4 ZooKeeper transaction thread exception f5 ZooKeeper leader fails to write transaction log f6 Cassandra response drop blocks repair operations f7 Cassandra stale data in leads to wrong node states f8 Cassandra streaming silently fail on unexpected error f9 Cassandra commitlog executor exit causes GC storm f10 HDFS thread pool exhaustion in master f11 HDFS failed pipeline creation prevents recovery f12 HDFS short circuit reads blocked due to death of domain socket</p>
    <p>watcherf13 HDFS blockpool fails to initialize but continues f14 HBase dead root drive on region server f15 HBase replication stalls with empty WAL files</p>
    <p>In all cases, severe service disruption occurred (e.g., create requests failed) while the failing component was perceived to be healthy.</p>
  </div>
  <div class="page">
    <p>Detection Time of Gray Failures</p>
    <p>37</p>
    <p>D et</p>
    <p>ec tio</p>
    <p>n tim</p>
    <p>e (s</p>
    <p>)</p>
    <p>Failure Case Id f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15</p>
    <p>Built-in Panorama Falcon</p>
    <p>Panorama detects all 15 failures in under 7 seconds; Built-in detectors only detect one case within 300 seconds.</p>
  </div>
  <div class="page">
    <p>Detection Time of Gray Failures</p>
    <p>37</p>
    <p>D et</p>
    <p>ec tio</p>
    <p>n tim</p>
    <p>e (s</p>
    <p>)</p>
    <p>Failure Case Id f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15</p>
    <p>Built-in Panorama Falcon</p>
    <p>Panorama detects all 15 failures in under 7 seconds; Built-in detectors only detect one case within 300 seconds.</p>
  </div>
  <div class="page">
    <p>Timeline in Detecting Gray Failure f1</p>
    <p>38</p>
    <p>Fa ilu</p>
    <p>re re</p>
    <p>po rts</p>
    <p>Panorama Observer</p>
    <p>Fault occurs Fault clears</p>
  </div>
  <div class="page">
    <p>Timeline in Detecting Gray Failure f1</p>
    <p>38</p>
    <p>C lie</p>
    <p>nt</p>
    <p>Er ro</p>
    <p>r</p>
    <p>Timeout Success</p>
    <p>C lie</p>
    <p>nt</p>
    <p>La te</p>
    <p>nc y</p>
    <p>(m s)</p>
    <p>Fa ilu</p>
    <p>re re</p>
    <p>po rts</p>
    <p>Panorama Observer</p>
    <p>Fault occurs Fault clears</p>
    <p>Client executing mixed workloads</p>
  </div>
  <div class="page">
    <p>Transient Failures</p>
    <p>39</p>
    <p>HEALTHY</p>
    <p>UNHEALTHY</p>
    <p>:40</p>
    <p>:30</p>
    <p>:21</p>
    <p>:11</p>
    <p>:02</p>
    <p>:52</p>
    <p>:43</p>
    <p>:33</p>
    <p>:24</p>
    <p>:14</p>
    <p>:05</p>
    <p>context1:all context2:Learner context3:RecvWorker context4:QuorumPacket context5:start context6:FinalRequestProcessor context7:QuorumCtxnManager</p>
  </div>
  <div class="page">
    <p>Latency Overhead to Observers</p>
    <p>40</p>
    <p>La te</p>
    <p>nc y</p>
    <p>(u s)</p>
    <p>Read Write</p>
    <p>ZK ZK+</p>
    <p>La te</p>
    <p>nc y</p>
    <p>(u s)</p>
    <p>Read Write</p>
    <p>Cassandra Cassandra+</p>
    <p>La te</p>
    <p>nc y</p>
    <p>(s )</p>
    <p>Read Write</p>
    <p>HDFS HDFS+</p>
    <p>Less than 3% latency and throughput (not shown) overhead</p>
    <p>System instrumented with Panorama reporting hooks</p>
  </div>
  <div class="page">
    <p>Limitations &amp; Future Work  Panorama relies on dependencies and interactions in large systems</p>
    <p>if observability is inherently low, have to improve the built-in FDs.</p>
    <p>Panorama currently focuses on failure detection</p>
    <p>need to integrate detection results to the subject to take actions</p>
    <p>Panorama currently does not identify root cause of observations</p>
    <p>useful for localizing failing component in cascading failures</p>
    <p>41</p>
  </div>
  <div class="page">
    <p>Related Work  Failure Detection</p>
    <p>Gossip [Middleware '98],  [SRDS '04], Falcon [SOSP '11], Pigeon [NSDI '13]</p>
    <p>Monitoring and Tracing</p>
    <p>Magpie [OSDI '04], X-Trace [NSDI '07], Dapper [Google TR '10], Pivot Tracing [SOSP '15]</p>
    <p>Accountability</p>
    <p>PeerReview [SOSP '07]</p>
    <p>Gray Failures</p>
    <p>Fail-Stutter [HotOS '01], Limplock [SoCC '13], Fail-Slow Hardware [FAST '18], Gray Failure [HotOS '17]</p>
    <p>42</p>
    <p>Panorama's major contribution: a new way of constructing failure detectors for gray failures</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>43</p>
    <p>Detect what the requesters see</p>
    <p>https://github.com/ryanphuang/panorama</p>
    <p>Failures that matter are observable to requesters</p>
    <p>Turn error handlers into error reporters</p>
    <p>But must deal with design patterns that reduce observability</p>
    <p>Panorama enables construction of in-situ observers  Detects 8 crash failure and 15 gray failures in 4 real-world systems faster</p>
  </div>
  <div class="page">
    <p>Backup Slides</p>
    <p>44</p>
  </div>
  <div class="page">
    <p>Performance of Panorama Core API</p>
    <p>45</p>
    <p>Report ReportAsync Judge Propagate</p>
    <p>Main overhead perceived by the in-situ observers</p>
    <p>{Local RPC { RPC{Library Call</p>
  </div>
  <div class="page">
    <p>Scalability</p>
    <p>46</p>
    <p>O bs</p>
    <p>er va</p>
    <p>tio n</p>
    <p>Pr op</p>
    <p>ag at</p>
    <p>io n</p>
    <p>La te</p>
    <p>nc y</p>
    <p>( s)</p>
    <p>Number of nodes 0 13 25 38 50</p>
    <p>unicast multicast</p>
    <p>Exchange an observation with a single Panorama instance</p>
    <p>Exchange an observation with a clique of Panorama instance</p>
  </div>
  <div class="page">
    <p>Network Bandwidth Usage</p>
    <p>47</p>
    <p>Co-located Panorama</p>
    <p>B an</p>
    <p>dw id</p>
    <p>th</p>
    <p>U sa</p>
    <p>ge (K</p>
    <p>B /s</p>
    <p>)</p>
    <p>Time 0 32 64 96 128 160 192 224 256 288 320</p>
    <p>panorama_sent panorama_recv</p>
    <p>ZooKeeper Leader</p>
    <p>B an</p>
    <p>dw id</p>
    <p>th U</p>
    <p>sa ge</p>
    <p>(K</p>
    <p>B /s</p>
    <p>)</p>
    <p>Time 0 32 64 96 128 160 192 224 256 288 320</p>
    <p>leader_sent leader_recv</p>
  </div>
  <div class="page">
    <p>Challenge: Polymorphism and Interface  May not distinguish ob-boundary and normal invocations</p>
    <p>e.g., could be local write or remote write</p>
    <p>48</p>
    <p>void java.io.OutputStream.write(byte[] b)</p>
    <p>if (strm instanceof BufferedOutputStream) { ??? }</p>
    <p>public OutputStream Socket.getOutputStream()</p>
    <p>OutputStream</p>
    <p>BufferedOutputStream</p>
    <p>FilterOutputStream</p>
    <p>DataOutputStream</p>
    <p>ByteArrayOutputStream  Socket</p>
  </div>
  <div class="page">
    <p>May not distinguish ob-boundary and normal invocations</p>
    <p>Interface does not contain enough information (lack of fields)</p>
    <p>49</p>
    <p>/** * A BlockReader is responsible for reading a single block from a single datanode. */ public interface BlockReader { int read(byte[] buf, int off, int len) throws IOException; long skip(long n) throws IOException; int available() throws IOException; }</p>
    <p>Challenge: Polymorphism and Interface</p>
  </div>
  <div class="page">
    <p>Solution  Change the constructors of subclasses for the abstract type</p>
    <p>return a compatible wrapper with additional subject identity field</p>
    <p>set the field for remote types (e.g., java.net.Socket.getOutputStream())</p>
    <p>check this field at runtime to distinguish ob-boundary from normal types</p>
    <p>Extend the interface with additional subject related methods</p>
    <p>call setter in the implementors (e.g., BlockReaderFactory)</p>
    <p>50</p>
  </div>
  <div class="page">
    <p>Design Challenges</p>
    <p>Observations dispersed in softwares source code</p>
    <p>Observation collection may slow down observers normal functionality</p>
    <p>Diverse real-world programming paradigms affect system observability</p>
    <p>Observations may have biases</p>
    <p>51</p>
  </div>
  <div class="page">
    <p>Reach Verdict from Observations</p>
    <p>52</p>
    <p>O1, {sync: HEALTH}</p>
    <p>O2, {snap: UNHEALTH}</p>
    <p>O2, {sync: HEALTH}</p>
    <p>O1, {recv: HEALTH}</p>
    <p>time 0 T</p>
    <p>O4, {snap: UNHEALTH}</p>
    <p>O4, {snap: HEALTH}</p>
    <p>O3, {sync: UNHEALTH}</p>
    <p>O4, {sync: HEALTH}</p>
    <p>O3, {sync: UNHEALTH}</p>
  </div>
  <div class="page">
    <p>Reach Verdict from Observations</p>
    <p>52</p>
    <p>O1, {sync: HEALTH}</p>
    <p>O2, {snap: UNHEALTH}</p>
    <p>O2, {sync: HEALTH}</p>
    <p>O1, {recv: HEALTH}</p>
    <p>time 0 T</p>
    <p>O4, {snap: UNHEALTH}</p>
    <p>O4, {snap: HEALTH}</p>
    <p>O3, {sync: UNHEALTH}</p>
    <p>O4, {sync: HEALTH}</p>
    <p>Verdict policy #1: latest observation is the verdict</p>
    <p>Miss intermittent failure</p>
    <p>O3, {sync: UNHEALTH}</p>
  </div>
  <div class="page">
    <p>Reach Verdict from Observations</p>
    <p>52</p>
    <p>O1, {sync: HEALTH}</p>
    <p>O2, {snap: UNHEALTH}</p>
    <p>O2, {sync: HEALTH}</p>
    <p>O1, {recv: HEALTH}</p>
    <p>time 0 T</p>
    <p>O4, {snap: UNHEALTH}</p>
    <p>O4, {snap: HEALTH}</p>
    <p>O3, {sync: UNHEALTH}</p>
    <p>O4, {sync: HEALTH}</p>
    <p>Verdict policy #1: latest observation is the verdict</p>
    <p>Miss intermittent failure</p>
    <p>O3, {sync: UNHEALTH}</p>
    <p>Verdict policy #2: unhealthy if any recent observation is unhealthy</p>
    <p>One biased observer mislead others</p>
  </div>
  <div class="page">
    <p>Reach Verdict from Observations</p>
    <p>52</p>
    <p>O1, {sync: HEALTH}</p>
    <p>O2, {snap: UNHEALTH}</p>
    <p>O2, {sync: HEALTH}</p>
    <p>O1, {recv: HEALTH}</p>
    <p>time 0 T</p>
    <p>O4, {snap: UNHEALTH}</p>
    <p>O4, {snap: HEALTH}</p>
    <p>O3, {sync: UNHEALTH}</p>
    <p>O4, {sync: HEALTH}</p>
    <p>Verdict policy #1: latest observation is the verdict</p>
    <p>Miss intermittent failure</p>
    <p>O3, {sync: UNHEALTH}</p>
    <p>Verdict policy #2: unhealthy if any recent observation is unhealthy</p>
    <p>Our solution: a simple bounded look-back majority algorithm</p>
    <p>One biased observer mislead others</p>
    <p>Group by context and observer, summarize and vote; see paper for more detail</p>
  </div>
</Presentation>
