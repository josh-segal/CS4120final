<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Realizing the fault-tolerance promise of cloud storage using locks with intent</p>
    <p>Srinath Setty, Chunzhi Su,* Jacob R. Lorch, Lidong Zhou,</p>
    <p>Hao Chen, Parveen Patel, and Jinglei Ren</p>
    <p>Microsoft Research *The University of Texas at Austin</p>
    <p>Shanghai Jiao Tong University</p>
  </div>
  <div class="page">
    <p>Cloud application atop cloud storage is a recent model of distributed systems</p>
    <p>Simple APIs that hide cloud storages distributed machinery</p>
    <p>Applications</p>
    <p>computation is</p>
    <p>distributed</p>
    <p>Applications</p>
    <p>state is in</p>
    <p>reliable cloud</p>
    <p>storage</p>
  </div>
  <div class="page">
    <p>Cloud application atop cloud storage is a recent model of distributed systems</p>
    <p>Simple APIs that hide cloud storages distributed machinery</p>
    <p>No distributed coordination among VMs</p>
    <p>Applications</p>
    <p>computation is</p>
    <p>distributed</p>
    <p>Applications</p>
    <p>state is in</p>
    <p>reliable cloud</p>
    <p>storage</p>
  </div>
  <div class="page">
    <p>This architecture poses an interesting problem</p>
    <p>Reliable cloud storage systems (Amazon DynamoDB, Azure table store, )</p>
    <p>Simple APIs that hide distributed machinery</p>
  </div>
  <div class="page">
    <p>This architecture poses an interesting problem</p>
    <p>Reliable cloud storage systems (Amazon DynamoDB, Azure table store, )</p>
    <p>Simple APIs that hide distributed machinery</p>
    <p>Application processes or VMs can fail</p>
  </div>
  <div class="page">
    <p>This architecture poses an interesting problem</p>
    <p>Reliable cloud storage systems (Amazon DynamoDB, Azure table store, )</p>
    <p>Simple APIs that hide distributed machinery</p>
    <p>Application processes or VMs can fail</p>
    <p>Network can drop/reorder messages</p>
  </div>
  <div class="page">
    <p>This architecture poses an interesting problem</p>
    <p>Reliable cloud storage systems (Amazon DynamoDB, Azure table store, )</p>
    <p>Simple APIs that hide distributed machinery</p>
    <p>Application processes or VMs can fail</p>
    <p>Network can drop/reorder messages</p>
    <p>Such failures can introduce inconsistencies to applications state</p>
  </div>
  <div class="page">
    <p>Applications have to maintain invariants over their state</p>
    <p>Example: Consistency between applications data and indexes</p>
  </div>
  <div class="page">
    <p>Applications have to maintain invariants over their state</p>
    <p>Example: Consistency between applications data and indexes</p>
    <p>Invariants should hold even with:</p>
  </div>
  <div class="page">
    <p>Applications have to maintain invariants over their state</p>
    <p>Example: Consistency between applications data and indexes</p>
    <p>Invariants should hold even with:</p>
    <p>Concurrent</p>
    <p>operations</p>
    <p>on cloud</p>
    <p>storage state</p>
    <p>Failures of</p>
    <p>VMs running</p>
    <p>the application</p>
  </div>
  <div class="page">
    <p>Applications have to maintain invariants over their state</p>
    <p>Example: Consistency between applications data and indexes</p>
    <p>Invariants should hold even with:</p>
    <p>A significant burden</p>
    <p>on application</p>
    <p>developers</p>
    <p>Concurrent</p>
    <p>operations</p>
    <p>on cloud</p>
    <p>storage state</p>
    <p>Failures of</p>
    <p>VMs running</p>
    <p>the application</p>
  </div>
  <div class="page">
    <p>Applications have to maintain invariants over their state</p>
    <p>Example: Consistency between applications data and indexes</p>
    <p>Invariants should hold even with:</p>
    <p>Worse: APIs of cloud storage offer little support for this</p>
    <p>A significant burden</p>
    <p>on application</p>
    <p>developers</p>
    <p>Concurrent</p>
    <p>operations</p>
    <p>on cloud</p>
    <p>storage state</p>
    <p>Failures of</p>
    <p>VMs running</p>
    <p>the application</p>
  </div>
  <div class="page">
    <p>Applications have to maintain invariants over their state</p>
    <p>Example: Consistency between applications data and indexes</p>
    <p>Invariants should hold even with:</p>
    <p>Worse: APIs of cloud storage offer little support for this Target systems: Azure table storage, Amazon DynamoDB, etc.</p>
    <p>A significant burden</p>
    <p>on application</p>
    <p>developers</p>
    <p>Concurrent</p>
    <p>operations</p>
    <p>on cloud</p>
    <p>storage state</p>
    <p>Failures of</p>
    <p>VMs running</p>
    <p>the application</p>
  </div>
  <div class="page">
    <p>Applications have to maintain invariants over their state</p>
    <p>Example: Consistency between applications data and indexes</p>
    <p>Invariants should hold even with:</p>
    <p>Worse: APIs of cloud storage offer little support for this Target systems: Azure table storage, Amazon DynamoDB, etc.</p>
    <p>Note: Other cloud storage systems (e.g., Aurora, Azure SQL) offer support for failure handling, but they have different scaling, or monetary cost profiles</p>
    <p>A significant burden</p>
    <p>on application</p>
    <p>developers</p>
    <p>Concurrent</p>
    <p>operations</p>
    <p>on cloud</p>
    <p>storage state</p>
    <p>Failures of</p>
    <p>VMs running</p>
    <p>the application</p>
  </div>
  <div class="page">
    <p>A text book solution</p>
    <p>Reliable cloud storage systems (Amazon DynamoDB, Azure table store, )</p>
    <p>Simple APIs that hide distributed machinery</p>
    <p>Replicate each VM using Paxos</p>
  </div>
  <div class="page">
    <p>A text book solution</p>
    <p>Reliable cloud storage systems (Amazon DynamoDB, Azure table store, )</p>
    <p>Simple APIs that hide distributed machinery</p>
    <p>Replicate each VM using Paxos</p>
    <p>Seems wasteful: storage uses replication for fault tolerance</p>
  </div>
  <div class="page">
    <p>A text book solution</p>
    <p>Reliable cloud storage systems (Amazon DynamoDB, Azure table store, )</p>
    <p>Simple APIs that hide distributed machinery</p>
    <p>Replicate each VM using Paxos</p>
    <p>Seems wasteful: storage uses replication for fault tolerance</p>
    <p>Can we leverage the reliability from the storage</p>
    <p>service to make applications tolerate failures?</p>
  </div>
  <div class="page">
    <p>Highlights of our system Olive</p>
    <p>Powerful new primitives: intents and locks with intent  Exactly-once execution semantics</p>
    <p>Mutual exclusion; locked objects associated with intents</p>
    <p>Eventual progress</p>
  </div>
  <div class="page">
    <p>Highlights of our system Olive</p>
    <p>Powerful new primitives: intents and locks with intent  Exactly-once execution semantics</p>
    <p>Mutual exclusion; locked objects associated with intents</p>
    <p>Eventual progress</p>
    <p>Arbitrary snippet of</p>
    <p>code, with calls to</p>
    <p>cloud storage</p>
    <p>Intent</p>
  </div>
  <div class="page">
    <p>Highlights of our system Olive</p>
    <p>Powerful new primitives: intents and locks with intent  Exactly-once execution semantics</p>
    <p>Mutual exclusion; locked objects associated with intents</p>
    <p>Eventual progress</p>
    <p>k2</p>
    <p>k3</p>
    <p>Cloud table</p>
    <p>Arbitrary snippet of</p>
    <p>code, with calls to</p>
    <p>cloud storage</p>
    <p>Intent</p>
  </div>
  <div class="page">
    <p>Highlights of our system Olive</p>
    <p>Powerful new primitives: intents and locks with intent  Exactly-once execution semantics</p>
    <p>Mutual exclusion; locked objects associated with intents</p>
    <p>Eventual progress</p>
    <p>k2</p>
    <p>k3</p>
    <p>Cloud table</p>
    <p>Arbitrary snippet of</p>
    <p>code, with calls to</p>
    <p>cloud storage</p>
    <p>Intent</p>
    <p>Object locked</p>
    <p>with intent</p>
  </div>
  <div class="page">
    <p>Highlights of our system Olive</p>
    <p>Powerful new primitives: intents and locks with intent  Exactly-once execution semantics</p>
    <p>Mutual exclusion; locked objects associated with intents</p>
    <p>Eventual progress</p>
    <p>k2</p>
    <p>k3</p>
    <p>Cloud table</p>
    <p>Arbitrary snippet of</p>
    <p>code, with calls to</p>
    <p>cloud storage</p>
    <p>Intent</p>
    <p>Object locked</p>
    <p>with intent</p>
    <p>Automatic failure</p>
    <p>handling and simplify</p>
    <p>concurrency</p>
  </div>
  <div class="page">
    <p>Highlights of our system Olive</p>
    <p>Powerful new primitives: intents and locks with intent  Exactly-once execution semantics</p>
    <p>Mutual exclusion; locked objects associated with intents</p>
    <p>Eventual progress</p>
    <p>New mechanisms to implement this abstraction  Distributed atomic affinity logging (DAAL)</p>
    <p>Intent collector</p>
    <p>Automatic failure</p>
    <p>handling and simplify</p>
    <p>concurrency</p>
  </div>
  <div class="page">
    <p>Highlights of our system Olive</p>
    <p>Powerful new primitives: intents and locks with intent  Exactly-once execution semantics</p>
    <p>Mutual exclusion; locked objects associated with intents</p>
    <p>Eventual progress</p>
    <p>New mechanisms to implement this abstraction  Distributed atomic affinity logging (DAAL)</p>
    <p>Intent collector</p>
    <p>Automatic failure</p>
    <p>handling and simplify</p>
    <p>concurrency</p>
    <p>Require no</p>
    <p>modifications to</p>
    <p>storage; applies</p>
    <p>generally</p>
  </div>
  <div class="page">
    <p>Highlights of our system Olive</p>
    <p>Powerful new primitives: intents and locks with intent  Exactly-once execution semantics</p>
    <p>Mutual exclusion; locked objects associated with intents</p>
    <p>Eventual progress</p>
    <p>New mechanisms to implement this abstraction  Distributed atomic affinity logging (DAAL)</p>
    <p>Intent collector</p>
    <p>Built several real-world, fault-tolerant cloud services</p>
    <p>Live re-partitioning of tables</p>
    <p>Snapshotting service</p>
    <p>ACID transactions</p>
    <p>Automatic failure</p>
    <p>handling and simplify</p>
    <p>concurrency</p>
    <p>Require no</p>
    <p>modifications to</p>
    <p>storage; applies</p>
    <p>generally</p>
  </div>
  <div class="page">
    <p>Highlights of our system Olive</p>
    <p>Powerful new primitives: intents and locks with intent  Exactly-once execution semantics</p>
    <p>Mutual exclusion; locked objects associated with intents</p>
    <p>Eventual progress</p>
    <p>New mechanisms to implement this abstraction  Distributed atomic affinity logging (DAAL)</p>
    <p>Intent collector</p>
    <p>Built several real-world, fault-tolerant cloud services</p>
    <p>Live re-partitioning of tables</p>
    <p>Snapshotting service</p>
    <p>ACID transactions</p>
    <p>Automatic failure</p>
    <p>handling and simplify</p>
    <p>concurrency</p>
    <p>Require no</p>
    <p>modifications to</p>
    <p>storage; applies</p>
    <p>generally</p>
    <p>building directly on</p>
    <p>cloud storage APIs</p>
  </div>
  <div class="page">
    <p>Rest of this talk</p>
    <p>Olives abstractions and mechanisms</p>
    <p>Evaluation of Olive</p>
  </div>
  <div class="page">
    <p>Exactly-once</p>
    <p>protocol</p>
    <p>Intent</p>
    <p>collector</p>
    <p>Lock</p>
    <p>primitive</p>
    <p>Storage model: Create, Read, Update, Delete,</p>
    <p>UpdateIfUnchanged, AtomicBatchUpdate, Scan</p>
    <p>Intents</p>
    <p>Application code</p>
    <p>Unmodified</p>
    <p>storageCloud storage systems (Amazon DynamoDB, Azure table store, )</p>
    <p>Simple APIs that hide distributed machinery</p>
    <p>Unreliable</p>
    <p>network</p>
    <p>Locks with intents</p>
  </div>
  <div class="page">
    <p>Exactly-once</p>
    <p>protocol</p>
    <p>Intent</p>
    <p>collector</p>
    <p>Lock</p>
    <p>primitive</p>
    <p>Storage model: Create, Read, Update, Delete,</p>
    <p>UpdateIfUnchanged, AtomicBatchUpdate, Scan</p>
    <p>Intents</p>
    <p>Application code</p>
    <p>Unmodified</p>
    <p>storageCloud storage systems (Amazon DynamoDB, Azure table store, )</p>
    <p>Simple APIs that hide distributed machinery</p>
    <p>Unreliable</p>
    <p>network</p>
    <p>Locks with intents</p>
    <p>Olive client</p>
    <p>library</p>
  </div>
  <div class="page">
    <p>Intent =An arbitrary snippet of code:  Cloud storage operations</p>
    <p>Local computation (loops, recursion,</p>
    <p>control flow, ...)</p>
  </div>
  <div class="page">
    <p>Intent =An arbitrary snippet of code:  Cloud storage operations</p>
    <p>Local computation (loops, recursion,</p>
    <p>control flow, ...)</p>
    <p>Goal of exactly-once execution</p>
    <p>Code should run as if it is executed by a</p>
    <p>single, failure-free client</p>
  </div>
  <div class="page">
    <p>Challenges for exactly-once execution</p>
    <p>Intent =An arbitrary snippet of code:  Cloud storage operations</p>
    <p>Local computation (loops, recursion,</p>
    <p>control flow, ...)</p>
    <p>Clients can fail partway</p>
    <p>Imperfect failure detection  multiple,</p>
    <p>concurrent intent executions</p>
    <p>Goal of exactly-once execution</p>
    <p>Code should run as if it is executed by a</p>
    <p>single, failure-free client</p>
  </div>
  <div class="page">
    <p>Olive records in reliable cloud storage whenever a step of an intent is executed</p>
    <p>step 0 objectsRead,</p>
    <p>step 1 objectsRead,</p>
    <p>Olive</p>
    <p>toolkit</p>
    <p>Cloud table: executionLog</p>
    <p>(append only)</p>
    <p>RunIntent(code)</p>
  </div>
  <div class="page">
    <p>Olive records in reliable cloud storage whenever a step of an intent is executed</p>
    <p>To execute read:</p>
    <p>step 0 objectsRead,</p>
    <p>step 1 objectsRead,</p>
    <p>Olive</p>
    <p>toolkit</p>
    <p>Cloud table: executionLog</p>
    <p>(append only)</p>
    <p>RunIntent(code)</p>
  </div>
  <div class="page">
    <p>Olive records in reliable cloud storage whenever a step of an intent is executed</p>
    <p>To execute read:</p>
    <p>step 0 objectsRead,</p>
    <p>step 1 objectsRead,</p>
    <p>Olive</p>
    <p>toolkit</p>
    <p>Cloud table: executionLog</p>
    <p>(append only)</p>
    <p>RunIntent(code)</p>
  </div>
  <div class="page">
    <p>Olive records in reliable cloud storage whenever a step of an intent is executed</p>
    <p>To execute read:</p>
    <p>step 0 objectsRead,</p>
    <p>step 1 objectsRead,</p>
    <p>Olive</p>
    <p>toolkit</p>
    <p>Cloud table: executionLog</p>
    <p>(append only)</p>
    <p>RunIntent(code)</p>
  </div>
  <div class="page">
    <p>Olive records in reliable cloud storage whenever a step of an intent is executed</p>
    <p>To execute read:</p>
    <p>step 0 objectsRead,</p>
    <p>step 1 objectsRead,</p>
    <p>Olive</p>
    <p>toolkit</p>
    <p>Cloud table: executionLog</p>
    <p>(append only)</p>
    <p>RunIntent(code)</p>
    <p>This will not work for executing an update</p>
    <p>inside an intent</p>
  </div>
  <div class="page">
    <p>Executing an update and recording it in executionLog must be atomic</p>
    <p>Step 0 objectsRead</p>
    <p>Step 1 objectsRead</p>
    <p>Olive</p>
    <p>toolkit Insert(step, value = {})</p>
    <p>Cloud table: executionLogRunIntent(intentId)</p>
    <p>k2</p>
    <p>k3</p>
    <p>Cloud table: appTable</p>
    <p>failure</p>
  </div>
  <div class="page">
    <p>Executing an update and recording it in executionLog must be atomic</p>
    <p>Step 0 objectsRead</p>
    <p>Step 1 objectsRead</p>
    <p>Olive</p>
    <p>toolkit Insert(step, value = {})</p>
    <p>Cloud table: executionLogRunIntent(intentId)</p>
    <p>k2</p>
    <p>k3</p>
    <p>Cloud table: appTable</p>
    <p>Failure to record after executing  violation of exactly-once</p>
    <p>failure</p>
  </div>
  <div class="page">
    <p>Executing an update and recording it in executionLog must be atomic</p>
    <p>Step 0 objectsRead</p>
    <p>Step 1 objectsRead</p>
    <p>Olive</p>
    <p>toolkit Insert(step, value = {})</p>
    <p>Cloud table: executionLogRunIntent(intentId)</p>
    <p>k2</p>
    <p>k3</p>
    <p>Cloud table: appTable</p>
    <p>Failure to record after executing  violation of exactly-once</p>
    <p>Storage systems we target do not support cross-table atomic updates</p>
    <p>failure</p>
  </div>
  <div class="page">
    <p>Executing an update and recording it in executionLog must be atomic</p>
    <p>Step 0 objectsRead</p>
    <p>Step 1 objectsRead</p>
    <p>Olive</p>
    <p>toolkit Insert(step, value = {})</p>
    <p>Cloud table: executionLogRunIntent(intentId)</p>
    <p>k2</p>
    <p>k3</p>
    <p>Cloud table: appTable</p>
    <p>Failure to record after executing  violation of exactly-once</p>
    <p>Storage systems we target do not support cross-table atomic updates</p>
    <p>failure</p>
    <p>Observe: executionLog need not be a single table</p>
  </div>
  <div class="page">
    <p>Olive introduces: Distributed atomic affinity logging (DAAL)</p>
  </div>
  <div class="page">
    <p>Olive introduces: Distributed atomic affinity logging (DAAL)</p>
    <p>Leverage AtomicBatchUpdate for objects in the same shard or partition.</p>
  </div>
  <div class="page">
    <p>Olive introduces: Distributed atomic affinity logging (DAAL)</p>
    <p>Leverage AtomicBatchUpdate for objects in the same shard or partition.</p>
    <p>Azure table storage, Amazon DynamoDB, MongoDB, Cassandra, etc.</p>
  </div>
  <div class="page">
    <p>Olive introduces: Distributed atomic affinity logging (DAAL)</p>
    <p>Leverage AtomicBatchUpdate for objects in the same shard or partition.</p>
    <p>Azure table storage, Amazon DynamoDB, MongoDB, Cassandra, etc.</p>
    <p>Olive</p>
    <p>toolkit</p>
    <p>RunIntent(intentId)</p>
    <p>k2</p>
    <p>Step x log Update(k2, .)</p>
    <p>Cloud table: appTable</p>
    <p>DAAL entry</p>
  </div>
  <div class="page">
    <p>Olive introduces: Distributed atomic affinity logging (DAAL)</p>
    <p>Leverage AtomicBatchUpdate for objects in the same shard or partition.</p>
    <p>Azure table storage, Amazon DynamoDB, MongoDB, Cassandra, etc.</p>
    <p>Olive</p>
    <p>toolkit</p>
    <p>RunIntent(intentId)</p>
    <p>k2</p>
    <p>Step x log Update(k2, .)</p>
    <p>Cloud table: appTable</p>
    <p>DAAL entry</p>
    <p>executionLog is not a single, global table:</p>
    <p>A global cloud table for recording read operations, and</p>
    <p>DAAL entries spread throughout</p>
  </div>
  <div class="page">
    <p>Benefits of Olive</p>
  </div>
  <div class="page">
    <p>Benefits of Olive</p>
    <p>An Intent executes in entirety</p>
  </div>
  <div class="page">
    <p>Benefits of Olive</p>
    <p>Without intents: Does failing at line i violate</p>
    <p>any invariant?</p>
    <p>An Intent executes in entirety</p>
  </div>
  <div class="page">
    <p>Benefits of Olive</p>
    <p>Without intents: Does failing at line i violate</p>
    <p>any invariant?</p>
    <p>An Intent executes in entirety</p>
  </div>
  <div class="page">
    <p>Benefits of Olive</p>
    <p>Without intents: Does failing at line i violate</p>
    <p>any invariant?</p>
    <p>An Intent executes in entirety</p>
  </div>
  <div class="page">
    <p>Benefits of Olive</p>
    <p>Without intents: Does failing at line i violate</p>
    <p>any invariant?</p>
    <p>An Intent executes in entirety</p>
  </div>
  <div class="page">
    <p>Benefits of Olive</p>
    <p>Without intents: Does failing at line i violate</p>
    <p>any invariant?</p>
    <p>An Intent executes in entirety</p>
  </div>
  <div class="page">
    <p>Benefits of Olive</p>
    <p>Without intents: Does failing at line i violate</p>
    <p>any invariant?</p>
    <p>An Intent executes in entirety</p>
    <p>Still, the developer must reason about</p>
    <p>concurrent executions of intents</p>
  </div>
  <div class="page">
    <p>Locks are well-studied concurrency control primitive</p>
    <p>CloudTable.Lock(k)</p>
    <p>CloudTable.Update(k, )</p>
    <p>CloudTable.Unlock(k)</p>
    <p>Client 1</p>
    <p>Client 2</p>
    <p>CloudTable.Lock(k)</p>
    <p>CloudTable.Update(k, )</p>
    <p>CloudTable.Unlock(k)</p>
  </div>
  <div class="page">
    <p>Locks are well-studied concurrency control primitive</p>
    <p>CloudTable.Lock(k)</p>
    <p>CloudTable.Update(k, )</p>
    <p>CloudTable.Unlock(k)</p>
    <p>Client 1</p>
    <p>Client 2</p>
    <p>CloudTable.Lock(k)</p>
    <p>CloudTable.Update(k, )</p>
    <p>CloudTable.Unlock(k)</p>
    <p>Executions will</p>
    <p>be serialized, no</p>
    <p>interleavings</p>
  </div>
  <div class="page">
    <p>Locks are well-studied concurrency control primitive</p>
    <p>CloudTable.Lock(k)</p>
    <p>CloudTable.Update(k, )</p>
    <p>CloudTable.Unlock(k)</p>
    <p>Client 1</p>
    <p>Client 2</p>
    <p>CloudTable.Lock(k)</p>
    <p>CloudTable.Update(k, )</p>
    <p>CloudTable.Unlock(k)</p>
    <p>Executions will</p>
    <p>be serialized, no</p>
    <p>interleavings</p>
    <p>Locks are dangerous,</p>
    <p>since clients can fail</p>
    <p>after acquiring a lock</p>
  </div>
  <div class="page">
    <p>Olive composes locks with intents</p>
  </div>
  <div class="page">
    <p>Olive composes locks with intents</p>
    <p>Locks are owned by intents, not client VMs  any client can</p>
    <p>unlock an object by executing the associated intent</p>
  </div>
  <div class="page">
    <p>Olive composes locks with intents</p>
    <p>Traditional lock Locks with intent</p>
    <p>Mutual exclusion Yes Yes</p>
    <p>Survives client failures No Yes</p>
    <p>Locks are owned by intents, not client VMs  any client can</p>
    <p>unlock an object by executing the associated intent</p>
  </div>
  <div class="page">
    <p>Olive composes locks with intents</p>
    <p>Traditional lock Locks with intent</p>
    <p>Mutual exclusion Yes Yes</p>
    <p>Survives client failures No Yes</p>
    <p>Overall benefit: simplifies reasoning about concurrency in</p>
    <p>the presence of failures (see our paper)</p>
    <p>Locks are owned by intents, not client VMs  any client can</p>
    <p>unlock an object by executing the associated intent</p>
  </div>
  <div class="page">
    <p>Exactly-once</p>
    <p>protocol</p>
    <p>Intent</p>
    <p>collector</p>
    <p>Lock</p>
    <p>primitive</p>
    <p>Storage model: Create, Read, Update, Delete,</p>
    <p>UpdateIfUnchanged, AtomicBatchUpdate, Scan</p>
    <p>Intents</p>
    <p>Application code</p>
    <p>Unmodified</p>
    <p>storageCloud storage systems (Amazon DynamoDB, Azure table store, )</p>
    <p>Simple APIs that hide distributed machinery</p>
    <p>Unreliable</p>
    <p>network</p>
    <p>Locks with intents</p>
    <p>Olive client</p>
    <p>library</p>
  </div>
  <div class="page">
    <p>Implementation of Olive</p>
    <p>Implemented 2,000 lines of C#</p>
    <p>Abstracts the underlying storage system with a C# interface  We write code to map that interface to different storage systems: 38 lines of</p>
    <p>code for Azure table store, 107 lines of code for Amazon DynamoDB</p>
    <p>Can be extended easily to Cassandra, MongoDB, Azure DocumentDB, other cloud storage services, etc.</p>
  </div>
  <div class="page">
    <p>Olives abstractions and mechanisms</p>
    <p>Evaluation of Olive</p>
  </div>
  <div class="page">
    <p>Evaluation questions</p>
    <p>Do Olives abstractions simplify building fault-tolerant applications?</p>
    <p>How do Olive-based artifacts perform relative to alternatives?</p>
  </div>
  <div class="page">
    <p>Does Olives locks with intent simplify building faulttolerant applications?</p>
    <p>Metric: lines of code, with and without Olive</p>
  </div>
  <div class="page">
    <p>Does Olives locks with intent simplify building faulttolerant applications?</p>
    <p>Service Without Olive With Olive</p>
    <p>Snapshots 987 665</p>
    <p>OCC-transactions 2,201 408</p>
    <p>Live table re-partitioning 2,116 474</p>
    <p>Metric: lines of code, with and without Olive</p>
  </div>
  <div class="page">
    <p>Does Olives locks with intent simplify building faulttolerant applications?</p>
    <p>Service Without Olive With Olive</p>
    <p>Snapshots 987 665</p>
    <p>OCC-transactions 2,201 408</p>
    <p>Live table re-partitioning 2,116 474</p>
    <p>Metric: lines of code, with and without Olive</p>
    <p>Note: Olives library is 2,000 lines of code</p>
  </div>
  <div class="page">
    <p>Does Olives locks with intent simplify building faulttolerant applications?</p>
    <p>Key takeaway: Olive reduces lines of code by 3080%</p>
    <p>Service Without Olive With Olive</p>
    <p>Snapshots 987 665</p>
    <p>OCC-transactions 2,201 408</p>
    <p>Live table re-partitioning 2,116 474</p>
    <p>Metric: lines of code, with and without Olive</p>
    <p>Note: Olives library is 2,000 lines of code</p>
  </div>
  <div class="page">
    <p>Does Olives locks with intent simplify building faulttolerant applications?</p>
    <p>Key takeaway: Olive reduces lines of code by 3080%</p>
    <p>Our paper discusses how Olive simplifies reasoning about correctness</p>
    <p>Service Without Olive With Olive</p>
    <p>Snapshots 987 665</p>
    <p>OCC-transactions 2,201 408</p>
    <p>Live table re-partitioning 2,116 474</p>
    <p>Metric: lines of code, with and without Olive</p>
    <p>Note: Olives library is 2,000 lines of code</p>
  </div>
  <div class="page">
    <p>How do Olive-based artifacts perform relative to alternatives?</p>
  </div>
  <div class="page">
    <p>How do Olive-based artifacts perform relative to alternatives?</p>
    <p>Consider snapshotting service</p>
  </div>
  <div class="page">
    <p>How do Olive-based artifacts perform relative to alternatives?</p>
    <p>Consider snapshotting service</p>
    <p>Baseline: database service in the cloud (Azure SQL)</p>
  </div>
  <div class="page">
    <p>How do Olive-based artifacts perform relative to alternatives?</p>
    <p>Consider snapshotting service</p>
    <p>Baseline: database service in the cloud (Azure SQL)</p>
    <p>Metric: latency of cloud storage operations (Create, Read, Update)</p>
  </div>
  <div class="page">
    <p>How do Olive-based artifacts perform relative to alternatives?</p>
    <p>Consider snapshotting service</p>
    <p>Baseline: database service in the cloud (Azure SQL)</p>
    <p>Metric: latency of cloud storage operations (Create, Read, Update)</p>
    <p>Olives artifact: uses lazy copy-on-write technique</p>
  </div>
  <div class="page">
    <p>How do Olive-based artifacts perform relative to alternatives?</p>
    <p>Consider snapshotting service</p>
    <p>Baseline: database service in the cloud (Azure SQL)</p>
    <p>Metric: latency of cloud storage operations (Create, Read, Update)</p>
    <p>Olives artifact: uses lazy copy-on-write technique</p>
    <p>Olives underlying storage service: Azure table store (US-West)</p>
  </div>
  <div class="page">
    <p>Performance of Olive-based snapshotting service</p>
    <p>Create Read Update Create Read Update</p>
    <p>Baseline</p>
    <p>Olive</p>
    <p>First operation after a snapshot</p>
    <p>ms</p>
  </div>
  <div class="page">
    <p>Performance of Olive-based snapshotting service</p>
    <p>Olive is competitive with the baseline for most operations</p>
    <p>Create Read Update Create Read Update</p>
    <p>Baseline</p>
    <p>Olive</p>
    <p>First operation after a snapshot</p>
    <p>ms</p>
  </div>
  <div class="page">
    <p>Performance of Olive-based snapshotting service</p>
    <p>Baseline incurs 2X</p>
    <p>higher latency</p>
    <p>Olive is competitive with the baseline for most operations</p>
    <p>Create Read Update Create Read Update</p>
    <p>Baseline</p>
    <p>Olive</p>
    <p>First operation after a snapshot</p>
    <p>ms</p>
  </div>
  <div class="page">
    <p>Performance of Olive-based snapshotting service</p>
    <p>Baseline incurs 2X</p>
    <p>higher latency</p>
    <p>Olive incurs 5X</p>
    <p>higher latency</p>
    <p>Olive is competitive with the baseline for most operations</p>
    <p>Create Read Update Create Read Update</p>
    <p>Baseline</p>
    <p>Olive</p>
    <p>First operation after a snapshot</p>
    <p>ms</p>
  </div>
  <div class="page">
    <p>Olive relates to many works</p>
    <p>State machine replication [Schneider CSUR90, Lamport TOCS98, .]</p>
    <p>Failure recovery [Chandy &amp; Ramamoorthy IEEE72, Lowell et al. OSDI00], Microreboot</p>
    <p>[Candea et al. OSDI04]</p>
    <p>Leases [Gray SOSP89], distributed locks with lease-like expiration [Burrows OSDI06],</p>
    <p>revocable locks [Harris &amp; Fraser PPoPP05]</p>
    <p>Write-ahead logging [Astrahan TODS76, Mohan et al. TODS92, Olson et al. ATC99, ...]</p>
    <p>Database and distributed transactions [Liskov CACM 88, Adya et al. ICDE00,</p>
    <p>Balakrishnan SOSP13, Aguilera et al. SOSP15, ]</p>
    <p>Systems that provide exactly-once semantics [Frolund PODC00, Huang &amp; Garcia ICDE01,</p>
    <p>Helland CACM12, Ramalingam &amp; Vaswani POPL13, Lee et al. SOSP15]</p>
  </div>
  <div class="page">
    <p>Distributed ACID transactions vs. locks with intent</p>
    <p>Transactions are simpler to program with, but offer less flexibility</p>
  </div>
  <div class="page">
    <p>Distributed ACID transactions vs. locks with intent</p>
    <p>Transactions are simpler to program with, but offer less flexibility</p>
    <p>By decoupling atomicity from isolation, locks with intent:</p>
    <p>Enable consistency levels from weak eventual to strong transactional</p>
  </div>
  <div class="page">
    <p>Distributed ACID transactions vs. locks with intent</p>
    <p>Transactions are simpler to program with, but offer less flexibility</p>
    <p>By decoupling atomicity from isolation, locks with intent:</p>
    <p>Enable consistency levels from weak eventual to strong transactional</p>
    <p>Avoid full isolation when not needed</p>
  </div>
  <div class="page">
    <p>Distributed ACID transactions vs. locks with intent</p>
    <p>Transactions are simpler to program with, but offer less flexibility</p>
    <p>By decoupling atomicity from isolation, locks with intent:</p>
    <p>Enable consistency levels from weak eventual to strong transactional</p>
    <p>Avoid full isolation when not needed</p>
    <p>We provide an intents-based transactional library if they prefer the simplicity of transactions (see our paper for examples)</p>
  </div>
  <div class="page">
    <p>Distributed ACID transactions vs. locks with intent</p>
    <p>Transactions are simpler to program with, but offer less flexibility</p>
    <p>By decoupling atomicity from isolation, locks with intent:</p>
    <p>Enable consistency levels from weak eventual to strong transactional</p>
    <p>Avoid full isolation when not needed</p>
    <p>We provide an intents-based transactional library if they prefer the simplicity of transactions (see our paper for examples)</p>
    <p>If the cloud storage service provided a general transactional interface, locks with intent can leverage it for exactly-once semantics, liveness, etc.</p>
  </div>
  <div class="page">
    <p>Olives key takeaways</p>
    <p>Cloud applications atop cloud storage pose a new problem: what is the right primitive for making such applications fault tolerant?</p>
  </div>
  <div class="page">
    <p>Olives key takeaways</p>
    <p>Cloud applications atop cloud storage pose a new problem: what is the right primitive for making such applications fault tolerant?</p>
    <p>We propose two new primitives: Intents and locks with intent, which guarantee exactly-once semantics, mutual exclusion, and eventual progress</p>
  </div>
  <div class="page">
    <p>Olives key takeaways</p>
    <p>Cloud applications atop cloud storage pose a new problem: what is the right primitive for making such applications fault tolerant?</p>
    <p>We propose two new primitives: Intents and locks with intent, which guarantee exactly-once semantics, mutual exclusion, and eventual progress</p>
    <p>We propose new mechanisms: DAAL and an intent collector</p>
  </div>
  <div class="page">
    <p>Olives key takeaways</p>
    <p>Cloud applications atop cloud storage pose a new problem: what is the right primitive for making such applications fault tolerant?</p>
    <p>We propose two new primitives: Intents and locks with intent, which guarantee exactly-once semantics, mutual exclusion, and eventual progress</p>
    <p>We propose new mechanisms: DAAL and an intent collector</p>
    <p>We apply these primitives to build practical, fault-tolerant services  Snapshots, live table re-partitioning, ACID transactions,</p>
  </div>
</Presentation>
