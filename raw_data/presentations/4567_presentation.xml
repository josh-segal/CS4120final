<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Multiple Preprocessing for Systematic SAT Solvers</p>
    <p>Anbulagan and John Slaney</p>
    <p>Logic and Computation Program, National ICT Australia (NICTA)</p>
    <p>CSL, RSISE, The Australian National University</p>
    <p>Canberra, Australia</p>
    <p>Presented at IWIL-6, as part of LPAR-2006, Phnom Penh, Cambodia, 12 November 2006</p>
  </div>
  <div class="page">
    <p>SAT Problem</p>
    <p>Input: A formula F in Conjunctive Normal Form (CNF)</p>
    <p>Output: F is satisfiable by a consistent assignment of truth value to variables or F is unsatisfiable.</p>
    <p>Example: F = (x1 x2 x3)(x4 x5)(x2 x6 x7)</p>
    <p>The first NP-Complete problem [Cook, 1971]</p>
    <p>A central problem in mathematical logic, AI, and other fields of computer science and engineering.</p>
  </div>
  <div class="page">
    <p>Related Works</p>
    <p>The interaction between simplification and search in propositional satisfiability [Lynce and Marques-Silva, 2001]  Evaluate the impact of some preprocessors</p>
    <p>Boosting SLS performance by incorporating resolution-based preprocessor [Anbulagan et al., LSCS-2006]  Propose multiple preprocessing and preprocessor ordering</p>
  </div>
  <div class="page">
    <p>SLS Solvers: RTDs on Structured Problems</p>
  </div>
  <div class="page">
    <p>Multiple Preprocessing and Preprocessor Ordering</p>
    <p>Using RSAPS (SLS solver)</p>
  </div>
  <div class="page">
    <p>Resolution-based Preprocessors</p>
    <p>3-Resolution [Li and Anbulagan, CP-1997]: computes resolvents for all pairs of clauses of length  3</p>
    <p>2-SIMPLIFY [Brafman, IJCAI-2001]: constructs an implication graph from all binary clauses of a problem instance and uses a restricted variant of hyper-resolution.</p>
    <p>HyPre [Bacchus and Winter, SAT-2003]: reasons with binary clauses and do full hyper-resolution.</p>
    <p>NiVER [Subbarayan and Pradhan, SAT-2004]: Non increasing Variable Elimination Resolution.</p>
    <p>SatELite [En and Biere, SAT-2005]: improved NiVER with a variable elimination by substitution rule.</p>
  </div>
  <div class="page">
    <p>Preprocessor for Symmetry Detection</p>
    <p>Shatter [Aloul et al., DAC-2003]: detects symmetries and adds symmetry-breaking clauses. It increases the size of the formula.</p>
  </div>
  <div class="page">
    <p>Systematic SAT Solvers - Dew_Satz</p>
    <p>Based on Satz [Li and Anbulagan, IJCAI-1997]  A DPLL Procedure</p>
    <p>Using Unit Propagation Look-Ahead (UPLA) based branching rule</p>
    <p>Some extensions:  Lookahead Saturation (LAS)</p>
    <p>Neighbourhood Variable Ordering (NVO)</p>
    <p>Dynamic Equality Weighting (DEW) during UPLA</p>
  </div>
  <div class="page">
    <p>Systematic SAT Solvers - MiniSat</p>
    <p>Conflict-driven clause learning (CDCL)</p>
    <p>Restart mechanism</p>
  </div>
  <div class="page">
    <p>Hard Structured Problems</p>
    <p>32-bit Parity: one of ten challenges for SAT testing [Selman et al., IJCAI-1997]</p>
    <p>Ferry Planning: industrial problem at SAT2005 competition</p>
    <p>Bounded Model Checking (BMC)  BMC-IBM</p>
    <p>BMC-galileo</p>
    <p>BMC-alpha</p>
    <p>IBM-FV-01</p>
    <p>IBM-FV-26</p>
    <p>FPGA routing</p>
    <p>Original problem instance size  The smallest (FPGA-homer19) contains 330 variables and 2340 clauses</p>
    <p>The largest (BMC-alpha-4408) contains 1,080,015 variables and 3,054,591 clauses</p>
  </div>
  <div class="page">
    <p>Empirical Study</p>
    <p>Time limit for each problem instance is 15000 seconds (4 hour and 10 minutes).</p>
    <p>On 16 AMD Athlon 64 processors running at 2.00GHz CPU with 2GB RAM.</p>
  </div>
  <div class="page">
    <p>Empirical Results on Parity and Planning</p>
    <p>n/a&gt;1500018,230,74612,8620.26848/5154/18565Sat+2Sim n/a&gt;150007,744,9863,5630.38849/5333/19052Sat+3Res n/a&gt;150007,744,9863,5520.35850/5286/189583Res+Sat n/a&gt;1500025,092,75614,0030.101290/5297/154813Res+Niv n/a&gt;1500010,036,1546,0990.341333/5810/16503Niv+3Res n/a&gt;1500010,036,1465,7410.111331/5567/160263Res+Hyp n/a&gt;1500017,712,9979,0010.361331/6055/16999Hyp+3Res n/a&gt;1500018,230,74612,8200.21849/5160/18581Sat n/a&gt;1500010,036,15410,4250.082385/7433/197623Res n/a&gt;15000n/a&gt;15000n/a3176/10313/27645Origpar32-4</p>
    <p>#ConflictStime#BackTStime MiniSatDew_SatzPtime#Var/#Cls/#LitsPrep.Instance</p>
  </div>
  <div class="page">
    <p>Empirical Results on BMC</p>
    <p>MiniSatDew_SatzPtime#Var/#Cls/#LitsPrep.Instance</p>
  </div>
  <div class="page">
    <p>Empirical Results on IBM-FV</p>
    <p>IBM-FV-26-k90</p>
    <p>#ConflictStime#BackTStime MiniSatDew_SatzPtime#Var/#Cls/#LitsPrep.Instance</p>
  </div>
  <div class="page">
    <p>Empirical Results on FPGA Routing</p>
    <p>bart (21 SAT)</p>
    <p>#Solved</p>
    <p>#BackT</p>
    <p>homer (15 UNSAT) 143,719,16622,1832,66215</p>
    <p>#ConflictStimeStime#Solved</p>
    <p>MiniSatDew_SatzInstance</p>
    <p>n/a&gt;15,000200.050.411764/8349/26138Sha+Hyp 7,676,4592,45810.040.461764/7702/24400Sha+3Res</p>
    <p>#ConflictStime#BackTStime</p>
    <p>MiniSatDew_SatzPtime#Var/#Cls/#LitsPrep.Instance</p>
  </div>
  <div class="page">
    <p>Multiple Preprocessing and Preprocessor Ordering</p>
    <p>#BackT</p>
    <p>n/a&gt;15,0000.081518/27554/565652Sim+Nivferry10_ks99a</p>
    <p>n/a&gt;15,0000.431518/32206/658062Sim+Niv+Hyp+3Resferry10_ks99a</p>
    <p>n/a&gt;15,00058.3811107/99673/2694053Res+Niv+Hyp</p>
    <p>n/a&gt;15,00089.5610038/82632/2218903Res+Hyp+Niv</p>
    <p>n/a&gt;15,00096.1110805/83643/204679Hyp+3Res+NivBMC-IBM-12</p>
    <p>StimePtime#Var/#Cls/#LitsPrep.Instance</p>
    <p>Using Dew_Satz</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>High-performance SAT solvers benefit greatly from preprocessing.</p>
    <p>Improvements of four orders of magnitude in runtime are not uncommon.</p>
    <p>Multiple preprocessing can boost further the performance of SAT solvers.</p>
  </div>
</Presentation>
