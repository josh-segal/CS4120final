<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>SmartVerif: Push the Limit of Automation Capability of Verifying Security Protocols by Dynamic Strategies</p>
    <p>Yan Xiong, Cheng Su, Wenchao Huang*, Fuyou Miao, Wansen Wang, Hengyi Ouyang</p>
    <p>University of Science and Technology of China</p>
    <p>Reporter: Cheng Su</p>
  </div>
  <div class="page">
    <p>Background</p>
    <p>The design of security protocols is error-prone  4G (Shaik et al, NDSS, 2016)  TLS (Cremers et al, CCS, 2017)  5G (Basin et al, CCS, 2018)</p>
  </div>
  <div class="page">
    <p>Verifying security protocols has become a key issue in security  Current related approaches</p>
    <p>Motivation: achieve full automation in formal methods</p>
    <p>Formal Methods Other Approaches</p>
    <p>(e.g. fuzzing)</p>
    <p>Pros Formal security guarantee Full automation Cons Partial automation False positive &amp; False negative</p>
    <p>Background 3</p>
  </div>
  <div class="page">
    <p>State-of-the-art formal method tools</p>
    <p>Observation 4</p>
    <p>Use static strategies</p>
    <p>Achieve automated verification for some protocols</p>
    <p>Cannot verify complicated protocols (e.g. Yubikey)</p>
    <p>ProVerif, StatVerif, Set-pi,</p>
    <p>Loose automation capability</p>
    <p>Require human guidance  Tamarin Prover, GSVerif,</p>
  </div>
  <div class="page">
    <p>We implement SmartVerif  Push the limit of automation capability of verifying security protocols  Full automation: no human guidance</p>
    <p>Generality: 100% success rate in verifying 24 studied protocols (including Yubikey)</p>
    <p>Achieved by designing a novel dynamic strategy  Replacing the original strategies in Tamarin Prover</p>
    <p>Our Work 5</p>
  </div>
  <div class="page">
    <p>Verification process in our work  Verification tree</p>
    <p>Problem Definition 6</p>
  </div>
  <div class="page">
    <p>Each node in the tree represents a proof state  Rule: a proposition  Step: the proof step number  ID: the hash of the proposition</p>
    <p>Problem Definition 7</p>
  </div>
  <div class="page">
    <p>The root node represents the security property</p>
    <p>Problem Definition 8</p>
  </div>
  <div class="page">
    <p>Verification process in our work  The proof state in the child can</p>
    <p>be used to prove the proof state in its parent</p>
    <p>E.g.</p>
    <p>Problem Definition 9</p>
  </div>
  <div class="page">
    <p>Goal: finding a correct proof path in the tree  Correct path  The path starts from the root node and</p>
    <p>ends with a leaf node  The leaf node contains an axiom</p>
    <p>Problem Definition 10</p>
  </div>
  <div class="page">
    <p>Problem Definition 11</p>
    <p>Supporting lemma  If a node is on a correct path, the proposition</p>
    <p>it contains is a supporting lemma</p>
  </div>
  <div class="page">
    <p>Our dynamic strategy  Finding the correct proof path by optimizing itself according to</p>
    <p>historical incorrect paths</p>
    <p>Selecting a path</p>
    <p>Estimating the</p>
    <p>correctness of the path</p>
    <p>Termination</p>
    <p>Optimizing the selection</p>
    <p>policy</p>
    <p>Correct</p>
    <p>Incorrect</p>
    <p>Strategy Design 12</p>
  </div>
  <div class="page">
    <p>Formal  Proven in Appendix.A</p>
    <p>Informal  When [A0,A1,,An-1,An] is estimated as an</p>
    <p>incorrect path  The probabilities of A1,,An-1 being supporting</p>
    <p>lemmata decrease exponentially</p>
    <p>The node representing a supporting lemma is on the incorrect path with lower probability, when a random strategy is given.</p>
    <p>Insight</p>
  </div>
  <div class="page">
    <p>We apply our insight by introducing Deep Q Network (DQN)  DQN: a reinforcement learning agent  Computes a Q value for each node  Tends to select nodes with higher Q values  Adjusts Q values by optimizing itself Q(A) Q(B) Q(C)</p>
    <p>Our Method 14</p>
  </div>
  <div class="page">
    <p>We use the DQN to select the path and optimize the DQN in our dynamic strategy</p>
    <p>Our Method 15</p>
    <p>Selecting a path</p>
    <p>Estimating the</p>
    <p>correctness of the path</p>
    <p>Termination</p>
    <p>Optimizing the selection</p>
    <p>policy</p>
    <p>Correct</p>
    <p>Incorrect</p>
  </div>
  <div class="page">
    <p>Yubikey Protocol  The most important case in our experiment  Widely studied  Knnemann et al., LNCS, 2013  Kremer et al., IEEE S&amp;P, 2014  Bruni et al., IEEE CSF, 2015  Cheval et al., IEEE CSF, 2018</p>
    <p>Still cannot be automatically verified by all the state-of-the-art tools</p>
    <p>An Example</p>
  </div>
  <div class="page">
    <p>Part of the verification tree</p>
    <p>Correct Path</p>
    <p>An Example 17</p>
    <p>A, C, D, E represent unsupporting lemmata</p>
  </div>
  <div class="page">
    <p>Tamarin Prover</p>
    <p>An Example 18</p>
    <p>Selected A in Step #8  Lead to a loop in verification</p>
    <p>Correct Path</p>
  </div>
  <div class="page">
    <p>SmartVerif  Initial epoch</p>
    <p>An Example 19</p>
    <p>Q=0 Q=0Q=0Q=0Q=0</p>
  </div>
  <div class="page">
    <p>Epoch 20 Q=0.3 Q=0.3</p>
    <p>Q=0.3 Q=0.3</p>
    <p>Q=0.2 Q=0.2</p>
    <p>Q=0.2 Q=0.2</p>
    <p>Q=0.4 Q=0.4</p>
    <p>An Example 20</p>
  </div>
  <div class="page">
    <p>An Example</p>
    <p>Epoch 40 Q=0.4 Q=0.1</p>
    <p>Q=0.6 Q=0.3</p>
    <p>Q=0.5 Q=0.3</p>
    <p>Q=0.6 Q=0.4</p>
    <p>Q=1.1 Q=0.7</p>
  </div>
  <div class="page">
    <p>Epoch 79  Finds the correct</p>
    <p>proof path</p>
    <p>An Example</p>
    <p>Q=1.2 Q=0.8</p>
    <p>Q=1.1 Q=0.5</p>
    <p>Q=1.3 Q=0.8</p>
    <p>Q=1.1 Q=0.5</p>
    <p>Q=1.7 Q=0.6</p>
  </div>
  <div class="page">
    <p>We solve several technical problems  Constructing verification tree  Estimating correctness of the path  Designing rewards for DQN</p>
    <p>Implementation 23</p>
  </div>
  <div class="page">
    <p>Constructing the verification tree  The tree is generated and expanded</p>
    <p>gradually  In each round, only one of the endpoint</p>
    <p>nodes in the current tree is expanded  The selection of the endpoint node is</p>
    <p>guided by the DQN</p>
    <p>Implementation 24</p>
  </div>
  <div class="page">
    <p>Implementation 25</p>
    <p>Estimating the correctness of the path  Loop Detection Algorithm  Counting the number of similar elements</p>
    <p>on the path</p>
  </div>
  <div class="page">
    <p>Designing rewards for DQN  When [A0,A1,,An-1,An] is estimated as an</p>
    <p>incorrect path  Gives a negative reward for all the nodes on</p>
    <p>the path</p>
    <p>Implementation 26</p>
    <p>R(A1)=-10</p>
    <p>R(An-2)=-10</p>
    <p>R(An-1)=-10</p>
    <p>R(An)=-10</p>
    <p>R(A0)=-10</p>
  </div>
  <div class="page">
    <p>Experiments 27</p>
    <p>Chosen tools</p>
    <p>StatVerif, Set-pi and GSVerif  Tamarin Prover with different</p>
    <p>heuristics(s, c, p)  SmartVerif</p>
    <p>Chosen protocols</p>
    <p>All the protocols that have been evaluated in papers of the compared tools</p>
    <p>Five protocols with observation equivalence properties</p>
  </div>
  <div class="page">
    <p>The success rate of automatically verifying 24 protocols with unbounded sessions</p>
    <p>SmartVerif can fully automatically verify all the protocols</p>
    <p>Stat Verif</p>
    <p>Set-pi GSVerif Tamarin</p>
    <p>(s) Tamarin</p>
    <p>(c) Tamarin</p>
    <p>(p) Smart Verif</p>
    <p>Success Rate</p>
    <p>Experiments 28</p>
  </div>
  <div class="page">
    <p>Except 24 protocol cases, there are many practical protocols  TLS 1.3  5G AKA  Smart contract  Blockchain protocol</p>
    <p>Cannot be automatically verified by state-of-the-art tools  SmartVerif can fully automatically verify these protocols</p>
    <p>Experiments 29</p>
  </div>
  <div class="page">
    <p>Efficiency and overhead of SmartVerif  Two metrics  Running time  Training epochs</p>
    <p>SmartVerif verifies protocols in a very efficient way  For most protocols, epochs &lt; 25, time &lt; 0.5 hour  The worst case (PKCS #11): 175 epochs, 83 minutes</p>
    <p>Experiments 30</p>
  </div>
  <div class="page">
    <p>Problem: automatically verify security protocols  Method: a dynamic strategy  Contributions  We present, to the best of our knowledge, the</p>
    <p>first framework that automatically verifies security protocols by dynamic strategies</p>
    <p>We achieve our dynamic strategy by using the DQN and designing the rewards and the algorithm that estimate the correctness of paths</p>
    <p>Our work achieve generality in designing heuristics and full automation in verification</p>
    <p>Conclusion 31</p>
    <p>Deep Q Network</p>
    <p>Dynamic strategy</p>
    <p>Generality &amp; full automation</p>
  </div>
  <div class="page">
    <p>Using an optimized static strategy as the initial strategy in SmartVerif</p>
    <p>Applying our dynamic strategy to other problems, e.g. automated formal verification of software or systems</p>
    <p>Optimizing the efficiency of SmartVerif</p>
    <p>Future Work 32</p>
  </div>
  <div class="page">
    <p>T h a n k s !</p>
    <p>Reporter: Cheng Su gotzeus@mail.ustc.edu.cn</p>
    <p>Q &amp; A 33</p>
  </div>
</Presentation>
