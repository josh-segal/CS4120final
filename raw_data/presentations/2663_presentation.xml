<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Paving the Way for NFV: Simplifying Middlebox Modifications with StateAlyzr</p>
    <p>Junaid Khalid, Aaron Gember-Jacobson,</p>
    <p>Roney Michael, Archie Abhashkumar, Aditya Akella</p>
  </div>
  <div class="page">
    <p>Middleboxes</p>
  </div>
  <div class="page">
    <p>Middleboxes</p>
    <p>Perform sophisticated operations on network traffic</p>
  </div>
  <div class="page">
    <p>Middleboxes</p>
    <p>Perform sophisticated operations on network traffic</p>
    <p>Firewall</p>
  </div>
  <div class="page">
    <p>Middleboxes</p>
    <p>Perform sophisticated operations on network traffic</p>
    <p>Firewall</p>
    <p>Intrusion detection</p>
    <p>system (IDS)</p>
  </div>
  <div class="page">
    <p>Middleboxes</p>
    <p>Perform sophisticated operations on network traffic</p>
    <p>Firewall Caching</p>
    <p>proxy</p>
    <p>Intrusion detection</p>
    <p>system (IDS)</p>
  </div>
  <div class="page">
    <p>Middleboxes</p>
    <p>Perform sophisticated operations on network traffic</p>
    <p>Firewall Caching</p>
    <p>proxy</p>
    <p>Intrusion detection</p>
    <p>system (IDS)</p>
    <p>Maintain state about connections and hosts</p>
  </div>
  <div class="page">
    <p>Network Function Virtualization (NFV)</p>
  </div>
  <div class="page">
    <p>Network Function Virtualization (NFV)</p>
    <p>NFV enables elastic scaling and high availability</p>
  </div>
  <div class="page">
    <p>Network Function Virtualization (NFV)</p>
    <p>NFV enables elastic scaling and high availability</p>
  </div>
  <div class="page">
    <p>Network Function Virtualization (NFV)</p>
    <p>NFV enables elastic scaling and high availability</p>
  </div>
  <div class="page">
    <p>Network Function Virtualization (NFV)</p>
    <p>NFV enables elastic scaling and high availability</p>
  </div>
  <div class="page">
    <p>Network Function Virtualization (NFV)</p>
    <p>Reroute new connections</p>
    <p>NFV enables elastic scaling and high availability</p>
  </div>
  <div class="page">
    <p>Network Function Virtualization (NFV)</p>
    <p>Reroute new connections</p>
    <p>state</p>
    <p>NFV enables elastic scaling and high availability</p>
  </div>
  <div class="page">
    <p>Network Function Virtualization (NFV)</p>
    <p>Reroute new connections existing</p>
    <p>NFV enables elastic scaling and high availability</p>
  </div>
  <div class="page">
    <p>State created or updated by a middlebox applies to either a single connection or a set of connections</p>
    <p>State taxonomy</p>
  </div>
  <div class="page">
    <p>State created or updated by a middlebox applies to either a single connection or a set of connections</p>
    <p>State taxonomy</p>
  </div>
  <div class="page">
    <p>State created or updated by a middlebox applies to either a single connection or a set of connections</p>
    <p>Connection</p>
    <p>Connection</p>
    <p>TcpAnalyzer</p>
    <p>HttpAnalyzer</p>
    <p>TcpAnalyzer</p>
    <p>HttpAnalyzer</p>
    <p>Per-conn state</p>
    <p>State taxonomy</p>
  </div>
  <div class="page">
    <p>State created or updated by a middlebox applies to either a single connection or a set of connections</p>
    <p>Connection</p>
    <p>Connection</p>
    <p>TcpAnalyzer</p>
    <p>HttpAnalyzer</p>
    <p>TcpAnalyzer</p>
    <p>HttpAnalyzer</p>
    <p>Per-conn state</p>
    <p>ConnCount</p>
    <p>Cross-conn state</p>
    <p>State taxonomy</p>
  </div>
  <div class="page">
    <p>State created or updated by a middlebox applies to either a single connection or a set of connections</p>
    <p>Connection</p>
    <p>Connection</p>
    <p>TcpAnalyzer</p>
    <p>HttpAnalyzer</p>
    <p>TcpAnalyzer</p>
    <p>HttpAnalyzer</p>
    <p>Per-conn state</p>
    <p>ConnCount</p>
    <p>Cross-conn state</p>
    <p>All-conns state Statistics</p>
    <p>State taxonomy</p>
  </div>
  <div class="page">
    <p>State created or updated by a middlebox applies to either a single connection or a set of connections</p>
    <p>Connection</p>
    <p>Connection</p>
    <p>TcpAnalyzer</p>
    <p>HttpAnalyzer</p>
    <p>TcpAnalyzer</p>
    <p>HttpAnalyzer</p>
    <p>Per-conn state</p>
    <p>ConnCount</p>
    <p>Cross-conn state</p>
    <p>All-conns state Statistics</p>
    <p>Input state Config + Sig</p>
    <p>State taxonomy</p>
  </div>
  <div class="page">
    <p>NFV state management -&gt; middlebox modification</p>
  </div>
  <div class="page">
    <p>NFV state management -&gt; middlebox modification</p>
    <p>Frameworks for transferring, or sharing live middlebox state</p>
  </div>
  <div class="page">
    <p>NFV state management -&gt; middlebox modification</p>
    <p>Frameworks for transferring, or sharing live middlebox state  Require modifications or annotation to middlebox code</p>
  </div>
  <div class="page">
    <p>NFV state management -&gt; middlebox modification</p>
    <p>Pre-flow state</p>
    <p>Cross-flow state</p>
    <p>Init state</p>
    <p>Frameworks for transferring, or sharing live middlebox state  Require modifications or annotation to middlebox code</p>
    <p>Split/Merge [NSDI 2013]</p>
  </div>
  <div class="page">
    <p>NFV state management -&gt; middlebox modification</p>
    <p>S h</p>
    <p>a re</p>
    <p>d L</p>
    <p>ib ra</p>
    <p>ry</p>
    <p>S h</p>
    <p>a re</p>
    <p>d L</p>
    <p>ib ra</p>
    <p>ry</p>
    <p>Frameworks for transferring, or sharing live middlebox state  Require modifications or annotation to middlebox code</p>
    <p>Split/Merge [NSDI 2013]</p>
  </div>
  <div class="page">
    <p>NFV state management -&gt; middlebox modification</p>
    <p>S h</p>
    <p>a re</p>
    <p>d L</p>
    <p>ib ra</p>
    <p>ry</p>
    <p>S h</p>
    <p>a re</p>
    <p>d L</p>
    <p>ib ra</p>
    <p>ry</p>
    <p>Frameworks for transferring, or sharing live middlebox state  Require modifications or annotation to middlebox code</p>
    <p>Split/Merge [NSDI 2013]</p>
  </div>
  <div class="page">
    <p>NFV state management -&gt; middlebox modification</p>
    <p>S h</p>
    <p>a re</p>
    <p>d L</p>
    <p>ib ra</p>
    <p>ry</p>
    <p>S h</p>
    <p>a re</p>
    <p>d L</p>
    <p>ib ra</p>
    <p>ry</p>
    <p>Frameworks for transferring, or sharing live middlebox state  Require modifications or annotation to middlebox code</p>
    <p>Split/Merge [NSDI 2013]</p>
  </div>
  <div class="page">
    <p>Framework</p>
    <p>Split/Merge [NSDI 2013]</p>
    <p>NFV state management -&gt; middlebox modification</p>
    <p>Frameworks for transferring, or sharing live middlebox state  Require modifications or annotation to middlebox code</p>
  </div>
  <div class="page">
    <p>Framework</p>
    <p>Split/Merge [NSDI 2013]</p>
    <p>OpenNF [SIGCOMM 2014]</p>
    <p>NFV state management -&gt; middlebox modification</p>
    <p>Frameworks for transferring, or sharing live middlebox state  Require modifications or annotation to middlebox code</p>
  </div>
  <div class="page">
    <p>Framework</p>
    <p>Split/Merge [NSDI 2013]</p>
    <p>OpenNF [SIGCOMM 2014]</p>
    <p>FTMB [SIGCOMM 2015]</p>
    <p>NFV state management -&gt; middlebox modification</p>
    <p>Frameworks for transferring, or sharing live middlebox state  Require modifications or annotation to middlebox code</p>
  </div>
  <div class="page">
    <p>Framework</p>
    <p>Split/Merge [NSDI 2013]</p>
    <p>OpenNF [SIGCOMM 2014]</p>
    <p>FTMB [SIGCOMM 2015]</p>
    <p>Pico Rep. [SoCC 2013]</p>
    <p>NFV state management -&gt; middlebox modification</p>
    <p>Frameworks for transferring, or sharing live middlebox state  Require modifications or annotation to middlebox code</p>
  </div>
  <div class="page">
    <p>Framework</p>
    <p>Split/Merge [NSDI 2013]</p>
    <p>OpenNF [SIGCOMM 2014]</p>
    <p>FTMB [SIGCOMM 2015]</p>
    <p>Pico Rep. [SoCC 2013]</p>
    <p>Stateless NF [HotMiddlebox 2015]</p>
    <p>NFV state management -&gt; middlebox modification</p>
    <p>Frameworks for transferring, or sharing live middlebox state  Require modifications or annotation to middlebox code</p>
  </div>
  <div class="page">
    <p>Why is modifying a middlebox hard?</p>
  </div>
  <div class="page">
    <p>Why is modifying a middlebox hard?</p>
    <p>MB LOC (C/C++)</p>
    <p>Classes/ Structs</p>
    <p>Level of pointers</p>
    <p>Number of Procedures</p>
    <p>PRADS 10K 40 4 297</p>
    <p>OpenVPN 62K 194 2 2023</p>
    <p>HAProxy 63K 191 8 2560</p>
    <p>Bro IDS 97K 1798 - 3034</p>
    <p>Squid 166K 875 - 2133</p>
    <p>Snort IDS 275K 898 10 4617</p>
    <p>Middleboxes are complex</p>
  </div>
  <div class="page">
    <p>Why is modifying a middlebox hard?</p>
    <p>MB LOC (C/C++)</p>
    <p>Classes/ Structs</p>
    <p>Level of pointers</p>
    <p>Number of Procedures</p>
    <p>PRADS 10K 40 4 297</p>
    <p>OpenVPN 62K 194 2 2023</p>
    <p>HAProxy 63K 191 8 2560</p>
    <p>Bro IDS 97K 1798 - 3034</p>
    <p>Squid 166K 875 - 2133</p>
    <p>Snort IDS 275K 898 10 4617</p>
    <p>Middleboxes are complex</p>
  </div>
  <div class="page">
    <p>Why is modifying a middlebox hard?</p>
    <p>MB LOC (C/C++)</p>
    <p>Classes/ Structs</p>
    <p>Level of pointers</p>
    <p>Number of Procedures</p>
    <p>PRADS 10K 40 4 297</p>
    <p>OpenVPN 62K 194 2 2023</p>
    <p>HAProxy 63K 191 8 2560</p>
    <p>Bro IDS 97K 1798 - 3034</p>
    <p>Squid 166K 875 - 2133</p>
    <p>Snort IDS 275K 898 10 4617</p>
    <p>Middleboxes are complex</p>
  </div>
  <div class="page">
    <p>Why is modifying a middlebox hard?</p>
    <p>MB LOC (C/C++)</p>
    <p>Classes/ Structs</p>
    <p>Level of pointers</p>
    <p>Number of Procedures</p>
    <p>PRADS 10K 40 4 297</p>
    <p>OpenVPN 62K 194 2 2023</p>
    <p>HAProxy 63K 191 8 2560</p>
    <p>Bro IDS 97K 1798 - 3034</p>
    <p>Squid 166K 875 - 2133</p>
    <p>Snort IDS 275K 898 10 4617</p>
    <p>Middleboxes are complex , diverse and have a variety of state</p>
  </div>
  <div class="page">
    <p>Why is modifying a middlebox hard?</p>
    <p>MB LOC (C/C++)</p>
    <p>Classes/ Structs</p>
    <p>Level of pointers</p>
    <p>Number of Procedures</p>
    <p>PRADS 10K 40 4 297</p>
    <p>OpenVPN 62K 194 2 2023</p>
    <p>HAProxy 63K 191 8 2560</p>
    <p>Bro IDS 97K 1798 - 3034</p>
    <p>Squid 166K 875 - 2133</p>
    <p>Snort IDS 275K 898 10 4617</p>
    <p>Middleboxes are complex , diverse and have a variety of state</p>
  </div>
  <div class="page">
    <p>Why is modifying a middlebox hard?</p>
    <p>MB LOC (C/C++)</p>
    <p>Classes/ Structs</p>
    <p>Level of pointers</p>
    <p>Number of Procedures</p>
    <p>PRADS 10K 40 4 297</p>
    <p>OpenVPN 62K 194 2 2023</p>
    <p>HAProxy 63K 191 8 2560</p>
    <p>Bro IDS 97K 1798 - 3034</p>
    <p>Squid 166K 875 - 2133</p>
    <p>Snort IDS 275K 898 10 4617</p>
    <p>Middleboxes are complex , diverse and have a variety of state</p>
    <p>Missing a change to some structure, class or function, may violate output equivalence.</p>
  </div>
  <div class="page">
    <p>Why is modifying a middlebox hard?</p>
    <p>MB LOC (C/C++)</p>
    <p>Classes/ Structs</p>
    <p>Level of pointers</p>
    <p>Number of Procedures</p>
    <p>PRADS 10K 40 4 297</p>
    <p>OpenVPN 62K 194 2 2023</p>
    <p>HAProxy 63K 191 8 2560</p>
    <p>Bro IDS 97K 1798 - 3034</p>
    <p>Squid 166K 875 - 2133</p>
    <p>Snort IDS 275K 898 10 4617</p>
    <p>Middleboxes are complex , diverse and have a variety of state</p>
    <p>Missing a change to some structure, class or function, may violate output equivalence.</p>
    <p>Output equivalence: for any input the aggregate output of a dynamic set of instances should be equivalent to the output produced by single instance.</p>
  </div>
  <div class="page">
    <p>Why is modifying a middlebox hard?</p>
    <p>MB LOC (C/C++)</p>
    <p>Classes/ Structs</p>
    <p>Level of pointers</p>
    <p>Number of Procedures</p>
    <p>PRADS 10K 40 4 297</p>
    <p>OpenVPN 62K 194 2 2023</p>
    <p>HAProxy 63K 191 8 2560</p>
    <p>Bro IDS 97K 1798 - 3034</p>
    <p>Squid 166K 875 - 2133</p>
    <p>Snort IDS 275K 898 10 4617</p>
    <p>Middleboxes are complex , diverse and have a variety of state</p>
    <p>Missing a change to some structure, class or function, may violate output equivalence.</p>
    <p>Output equivalence: for any input the aggregate output of a dynamic set of instances should be equivalent to the output produced by single instance.</p>
  </div>
  <div class="page">
    <p>Why is modifying a middlebox hard?</p>
    <p>MB LOC (C/C++)</p>
    <p>Classes/ Structs</p>
    <p>Level of pointers</p>
    <p>Number of Procedures</p>
    <p>PRADS 10K 40 4 297</p>
    <p>OpenVPN 62K 194 2 2023</p>
    <p>HAProxy 63K 191 8 2560</p>
    <p>Bro IDS 97K 1798 - 3034</p>
    <p>Squid 166K 875 - 2133</p>
    <p>Snort IDS 275K 898 10 4617</p>
    <p>Middleboxes are complex , diverse and have a variety of state</p>
    <p>Missing a change to some structure, class or function, may violate output equivalence.</p>
    <p>Output equivalence: for any input the aggregate output of a dynamic set of instances should be equivalent to the output produced by single instance.</p>
  </div>
  <div class="page">
    <p>StateAlyzr: program analysis to the rescue</p>
  </div>
  <div class="page">
    <p>StateAlyzr</p>
    <p>source code</p>
    <p>annotated code</p>
    <p>StateAlyzr: program analysis to the rescue</p>
    <p>A system that relies on data and control-flow analysis to automatically identify state objects that need explicit</p>
    <p>handling</p>
  </div>
  <div class="page">
    <p>StateAlyzr</p>
    <p>source code</p>
    <p>annotated code</p>
    <p>StateAlyzr: program analysis to the rescue</p>
    <p>A system that relies on data and control-flow analysis to automatically identify state objects that need explicit</p>
    <p>handling</p>
    <p>Leverage middlebox code structure to improve precision without compromising soundness</p>
  </div>
  <div class="page">
    <p>StateAlyzr</p>
    <p>source code</p>
    <p>annotated code</p>
    <p>StateAlyzr: program analysis to the rescue</p>
    <p>A system that relies on data and control-flow analysis to automatically identify state objects that need explicit</p>
    <p>handling</p>
    <p>Leverage middlebox code structure to improve precision without compromising soundness</p>
    <p>Soundness means that the system must not miss any critical types, storage locations, allocations, or uses of</p>
    <p>state</p>
  </div>
  <div class="page">
    <p>StateAlyzr</p>
    <p>source code</p>
    <p>annotated code</p>
    <p>StateAlyzr: program analysis to the rescue</p>
    <p>A system that relies on data and control-flow analysis to automatically identify state objects that need explicit</p>
    <p>handling</p>
    <p>Leverage middlebox code structure to improve precision without compromising soundness</p>
    <p>Soundness means that the system must not miss any critical types, storage locations, allocations, or uses of</p>
    <p>state</p>
    <p>Precision means that the system identifies the minimal set of state that requires special handling.</p>
  </div>
  <div class="page">
    <p>StateAlyzr</p>
    <p>source code</p>
    <p>annotated code</p>
    <p>StateAlyzr: program analysis to the rescue</p>
    <p>A system that relies on data and control-flow analysis to automatically identify state objects that need explicit</p>
    <p>handling</p>
    <p>Leverage middlebox code structure to improve precision without compromising soundness</p>
    <p>Soundness means that the system must not miss any critical types, storage locations, allocations, or uses of</p>
    <p>state</p>
    <p>Precision means that the system identifies the minimal set of state that requires special handling.</p>
    <p>required for output equivalence</p>
  </div>
  <div class="page">
    <p>StateAlyzr</p>
    <p>source code</p>
    <p>annotated code</p>
    <p>StateAlyzr: program analysis to the rescue</p>
    <p>A system that relies on data and control-flow analysis to automatically identify state objects that need explicit</p>
    <p>handling</p>
    <p>Leverage middlebox code structure to improve precision without compromising soundness</p>
    <p>Soundness means that the system must not miss any critical types, storage locations, allocations, or uses of</p>
    <p>state</p>
    <p>Precision means that the system identifies the minimal set of state that requires special handling.</p>
    <p>required for output equivalence</p>
    <p>required for performant state transfers</p>
  </div>
  <div class="page">
    <p>Fault tolerance IDS</p>
  </div>
  <div class="page">
    <p>Fault tolerance IDS</p>
    <p>Primary Hot standby</p>
  </div>
  <div class="page">
    <p>Fault tolerance IDS</p>
    <p>Config state</p>
    <p>Primary Hot standby</p>
  </div>
  <div class="page">
    <p>Fault tolerance IDS</p>
    <p>Per flow state</p>
    <p>Multi flow state</p>
    <p>All state</p>
    <p>Config state</p>
    <p>Primary Hot standby</p>
  </div>
  <div class="page">
    <p>Fault tolerance IDS</p>
    <p>Per flow state</p>
    <p>Multi flow state</p>
    <p>All state</p>
    <p>Config state</p>
    <p>The primary sends a copy of the state to the hot standby after each packet</p>
    <p>^</p>
    <p>updated</p>
    <p>Primary Hot standby</p>
  </div>
  <div class="page">
    <p>Fault tolerance IDS</p>
    <p>Per flow state</p>
    <p>Multi flow state</p>
    <p>All state</p>
    <p>Config state</p>
    <p>The primary sends a copy of the state to the hot standby after each packet</p>
    <p>^</p>
    <p>updated</p>
    <p>Primary Hot standby</p>
  </div>
  <div class="page">
    <p>StateAlyzr</p>
  </div>
  <div class="page">
    <p>StateAlyzr</p>
    <p>All State</p>
  </div>
  <div class="page">
    <p>StateAlyzr</p>
    <p>All State</p>
    <p>Per-/CrossFlow State</p>
  </div>
  <div class="page">
    <p>StateAlyzr</p>
    <p>All State</p>
    <p>Per-/CrossFlow State</p>
    <p>OutputImpacting</p>
    <p>State</p>
  </div>
  <div class="page">
    <p>StateAlyzr</p>
    <p>All State</p>
    <p>Per-/CrossFlow State</p>
    <p>OutputImpacting</p>
    <p>State</p>
    <p>Updateable State</p>
  </div>
  <div class="page">
    <p>Logical structure of middlebox code</p>
  </div>
  <div class="page">
    <p>Main</p>
    <p>init()</p>
    <p>Logical structure of middlebox code</p>
  </div>
  <div class="page">
    <p>Main</p>
    <p>loopProcedure() init()</p>
    <p>Logical structure of middlebox code</p>
  </div>
  <div class="page">
    <p>while (!done)</p>
    <p>packet = receive()</p>
    <p>send(packet) write(log)</p>
    <p>Packet processing loop</p>
    <p>Packet processing procedures</p>
    <p>foo() process(packet)</p>
    <p>process(packet)</p>
    <p>Main</p>
    <p>loopProcedure() init()</p>
    <p>raiseEvent()</p>
    <p>Logical structure of middlebox code</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Variables corresponding to per-/cross-flow state must be persistent</p>
  </div>
  <div class="page">
    <p>Variables corresponding to per-/cross-flow state must be persistent</p>
    <p>Persistent state can be stored in 1. Global variables</p>
  </div>
  <div class="page">
    <p>Variables corresponding to per-/cross-flow state must be persistent</p>
    <p>Persistent state can be stored in 1. Global variables 2. Static variables</p>
  </div>
  <div class="page">
    <p>Variables corresponding to per-/cross-flow state must be persistent</p>
    <p>Persistent state can be stored in 1. Global variables 2. Static variables 3. Local variables declared in loop proc.</p>
    <p>int loopProcedure(int *threshold) {</p>
    <p>int count = 0;</p>
    <p>while(1) {</p>
    <p>struct pcap_pkthdr pcapHdr;</p>
    <p>char *pkt = pcap_next(extPcap, &amp;pcapHdr);</p>
    <p>. .</p>
  </div>
  <div class="page">
    <p>Variables corresponding to per-/cross-flow state must be persistent</p>
    <p>Persistent state can be stored in 1. Global variables 2. Static variables 3. Local variables declared in loop proc. 4. Formal Params of loop proc.</p>
    <p>int loopProcedure(int *threshold) {</p>
    <p>int count = 0;</p>
    <p>while(1) {</p>
    <p>struct pcap_pkthdr pcapHdr;</p>
    <p>char *pkt = pcap_next(extPcap, &amp;pcapHdr);</p>
    <p>. .</p>
  </div>
  <div class="page">
    <p>Variables corresponding to per-/cross-flow state must be persistent</p>
    <p>Persistent state can be stored in 1. Global variables 2. Static variables 3. Local variables declared in loop proc. 4. Formal Params of loop proc.</p>
    <p>int loopProcedure(int *threshold) {</p>
    <p>int count = 0;</p>
    <p>while(1) {</p>
    <p>struct pcap_pkthdr pcapHdr;</p>
    <p>char *pkt = pcap_next(extPcap, &amp;pcapHdr);</p>
    <p>. .</p>
    <p>x</p>
    <p>x</p>
    <p>x</p>
    <p>a b</p>
    <p>a b</p>
    <p>a b</p>
    <p>Stack frame of main</p>
    <p>parameters</p>
    <p>return address</p>
    <p>local variables</p>
    <p>parameters</p>
    <p>return address</p>
    <p>local variables</p>
    <p>parameters</p>
    <p>return address</p>
    <p>local variables</p>
    <p>Stack frame of foo</p>
    <p>Stack frame of loopProcedure</p>
    <p>Stack origin</p>
  </div>
  <div class="page">
    <p>Variables corresponding to per-/cross-flow state must be persistent</p>
    <p>Persistent state can be stored in 1. Global variables 2. Static variables 3. Local variables declared in loop proc. 4. Formal Params of loop proc.</p>
    <p>int loopProcedure(int *threshold) {</p>
    <p>int count = 0;</p>
    <p>while(1) {</p>
    <p>struct pcap_pkthdr pcapHdr;</p>
    <p>char *pkt = pcap_next(extPcap, &amp;pcapHdr);</p>
    <p>. .</p>
    <p>x</p>
    <p>x</p>
    <p>x</p>
    <p>a b</p>
    <p>a b</p>
    <p>a b</p>
    <p>Stack frame of main</p>
    <p>parameters</p>
    <p>return address</p>
    <p>local variables</p>
    <p>parameters</p>
    <p>return address</p>
    <p>local variables</p>
    <p>parameters</p>
    <p>return address</p>
    <p>local variables</p>
    <p>Stack frame of foo</p>
    <p>Stack frame of loopProcedure</p>
    <p>Stack origin</p>
  </div>
  <div class="page">
    <p>Variables corresponding to per-/cross-flow state must be persistent</p>
    <p>Persistent state can be stored in 1. Global variables 2. Static variables 3. Local variables declared in loop proc. 4. Formal Params of loop proc.</p>
    <p>int loopProcedure(int *threshold) {</p>
    <p>int count = 0;</p>
    <p>while(1) {</p>
    <p>struct pcap_pkthdr pcapHdr;</p>
    <p>char *pkt = pcap_next(extPcap, &amp;pcapHdr);</p>
    <p>. .</p>
    <p>x</p>
    <p>x</p>
    <p>x</p>
    <p>a b</p>
    <p>a b</p>
    <p>a b</p>
    <p>Stack frame of main</p>
    <p>parameters</p>
    <p>return address</p>
    <p>local variables</p>
    <p>parameters</p>
    <p>return address</p>
    <p>local variables</p>
    <p>parameters</p>
    <p>return address</p>
    <p>local variables</p>
    <p>Stack frame of foo</p>
    <p>Stack frame of loopProcedure</p>
    <p>Stack origin</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Conf</p>
    <p>Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Init</p>
  </div>
  <div class="page">
    <p>Conf</p>
    <p>Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Init Initialization</p>
  </div>
  <div class="page">
    <p>Improve precision by considering variables which are used in packet processing code</p>
    <p>Conf</p>
    <p>Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Init Initialization</p>
  </div>
  <div class="page">
    <p>Improve precision by considering variables which are used in packet processing code</p>
    <p>Conf</p>
    <p>Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Init Initialization</p>
    <p>How to identify packet processing code?</p>
  </div>
  <div class="page">
    <p>while (!done)</p>
    <p>packet = receive()</p>
    <p>send(packet) write(log)</p>
    <p>Packet processing loop</p>
    <p>Packet processing procedures</p>
    <p>foo() process(packet)</p>
    <p>process(packet)</p>
    <p>Main</p>
    <p>loopProcedure() init()</p>
    <p>How to identify packet processing code?</p>
  </div>
  <div class="page">
    <p>while (!done)</p>
    <p>packet = receive()</p>
    <p>send(packet) write(log)</p>
    <p>Packet processing loop</p>
    <p>Packet processing procedures</p>
    <p>foo() process(packet)</p>
    <p>process(packet)</p>
    <p>Main</p>
    <p>loopProcedure() init()</p>
    <p>How to identify packet processing code?</p>
  </div>
  <div class="page">
    <p>while (!done)</p>
    <p>packet = receive()</p>
    <p>send(packet) write(log)</p>
    <p>Packet processing loop</p>
    <p>while (event = dequeue())</p>
    <p>Event thread</p>
    <p>Packet processing procedures</p>
    <p>foo()</p>
    <p>processIndirect(event)</p>
    <p>processIndirect(event)</p>
    <p>process(packet)</p>
    <p>process(packet)</p>
    <p>Main</p>
    <p>loopProcedure() init()</p>
    <p>raiseEvent()</p>
    <p>Indirect call</p>
    <p>How to identify packet processing code?</p>
  </div>
  <div class="page">
    <p>while (!done)</p>
    <p>packet = receive()</p>
    <p>send(packet) write(log)</p>
    <p>Packet processing loop</p>
    <p>while (event = dequeue())</p>
    <p>Event thread</p>
    <p>Packet processing procedures</p>
    <p>foo()</p>
    <p>processIndirect(event)</p>
    <p>processIndirect(event)</p>
    <p>process(packet)</p>
    <p>process(packet)</p>
    <p>Main</p>
    <p>loopProcedure() init()</p>
    <p>raiseEvent()</p>
    <p>struct pktHdr *pkt = recv(extPcap);</p>
    <p>src_ip = pkt-&gt;ip_src_addr;</p>
    <p>packet_count ++;</p>
    <p>index = src_ip + offset</p>
    <p>Indirect call</p>
    <p>How to identify packet processing code?</p>
  </div>
  <div class="page">
    <p>while (!done)</p>
    <p>packet = receive()</p>
    <p>send(packet) write(log)</p>
    <p>Packet processing loop</p>
    <p>while (event = dequeue())</p>
    <p>Event thread</p>
    <p>Packet processing procedures</p>
    <p>foo()</p>
    <p>processIndirect(event)</p>
    <p>processIndirect(event)</p>
    <p>process(packet)</p>
    <p>process(packet)</p>
    <p>Main</p>
    <p>loopProcedure() init()</p>
    <p>raiseEvent()</p>
    <p>struct pktHdr *pkt = recv(extPcap);</p>
    <p>src_ip = pkt-&gt;ip_src_addr;</p>
    <p>packet_count ++;</p>
    <p>index = src_ip + offset</p>
    <p>Indirect call</p>
    <p>How to identify packet processing code?</p>
  </div>
  <div class="page">
    <p>while (!done)</p>
    <p>packet = receive()</p>
    <p>send(packet) write(log)</p>
    <p>Packet processing loop</p>
    <p>while (event = dequeue())</p>
    <p>Event thread</p>
    <p>Packet processing procedures</p>
    <p>foo()</p>
    <p>processIndirect(event)</p>
    <p>processIndirect(event)</p>
    <p>process(packet)</p>
    <p>process(packet)</p>
    <p>Main</p>
    <p>loopProcedure() init()</p>
    <p>raiseEvent()</p>
    <p>struct pktHdr *pkt = recv(extPcap);</p>
    <p>src_ip = pkt-&gt;ip_src_addr;</p>
    <p>packet_count ++;</p>
    <p>index = src_ip + offset</p>
    <p>Indirect call</p>
    <p>How to identify packet processing code?</p>
  </div>
  <div class="page">
    <p>while (!done)</p>
    <p>packet = receive()</p>
    <p>send(packet) write(log)</p>
    <p>Packet processing loop</p>
    <p>while (event = dequeue())</p>
    <p>Event thread</p>
    <p>Packet processing procedures</p>
    <p>foo()</p>
    <p>processIndirect(event)</p>
    <p>processIndirect(event)</p>
    <p>process(packet)</p>
    <p>process(packet)</p>
    <p>Main</p>
    <p>loopProcedure() init()</p>
    <p>raiseEvent()</p>
    <p>Computes a forward slice from packet recv function. Any procedure appearing in the slice is considered as packet processing procedure.</p>
    <p>Indirect call</p>
    <p>How to identify packet processing code?</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Conf</p>
    <p>State</p>
    <p>Per</p>
    <p>Multi</p>
    <p>All</p>
  </div>
  <div class="page">
    <p>Conf</p>
    <p>Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Read-only Updateable</p>
  </div>
  <div class="page">
    <p>Whether the state is updated while processing the packet ?</p>
    <p>Conf Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Read-only Updateable</p>
  </div>
  <div class="page">
    <p>Whether the state is updated while processing the packet ?</p>
    <p>Strawman approach  Identify top-level variable on the left-hand-side(LHS)</p>
    <p>of assignment statement</p>
    <p>Conf Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Read-only Updateable</p>
    <p>in_port = pkt.src_port;</p>
    <p>per-/cross-flow var</p>
  </div>
  <div class="page">
    <p>Whether the state is updated while processing the packet ?</p>
    <p>Strawman approach  Identify top-level variable on the left-hand-side(LHS)</p>
    <p>of assignment statement</p>
    <p>Falls short due to aliasing</p>
    <p>Conf Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Read-only Updateable</p>
  </div>
  <div class="page">
    <p>Whether the state is updated while processing the packet ?</p>
    <p>Strawman approach  Identify top-level variable on the left-hand-side(LHS)</p>
    <p>of assignment statement</p>
    <p>Falls short due to aliasing</p>
    <p>int *index = &amp;tail; *index = (*index + 1)%100;</p>
    <p>per-/cross-flow var</p>
    <p>Conf Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Read-only Updateable</p>
  </div>
  <div class="page">
    <p>Whether the state is updated while processing the packet ?</p>
    <p>Strawman approach  Identify top-level variable on the left-hand-side(LHS)</p>
    <p>of assignment statement</p>
    <p>Conf Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Read-only Updateable</p>
    <p>StateAlyzr employs flow-, context-, and fieldinsensitive pointer analysis to identify updateable variables</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Conf</p>
    <p>State</p>
    <p>Per</p>
    <p>Multi</p>
    <p>All</p>
  </div>
  <div class="page">
    <p>Conf</p>
    <p>Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Read-only</p>
    <p>Updateable</p>
  </div>
  <div class="page">
    <p>Identify a set of packet header fields that delineate the subset of traffic that relates to the state</p>
    <p>Per</p>
    <p>Multi</p>
    <p>Updateable</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
  </div>
  <div class="page">
    <p>Identify a set of packet header fields that delineate the subset of traffic that relates to the state</p>
    <p>Common access patterns</p>
    <p>Per</p>
    <p>Multi</p>
    <p>Updateable</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
  </div>
  <div class="page">
    <p>Identify a set of packet header fields that delineate the subset of traffic that relates to the state</p>
    <p>Common access patterns key</p>
    <p>value</p>
    <p>Hashtable</p>
    <p>Per</p>
    <p>Multi</p>
    <p>Updateable</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
  </div>
  <div class="page">
    <p>Identify a set of packet header fields that delineate the subset of traffic that relates to the state</p>
    <p>Common access patterns key</p>
    <p>value</p>
    <p>Hashtable</p>
    <p>Per</p>
    <p>Multi</p>
    <p>Updateable</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
  </div>
  <div class="page">
    <p>Identify a set of packet header fields that delineate the subset of traffic that relates to the state</p>
    <p>Common access patterns key</p>
    <p>value</p>
    <p>Hashtable</p>
    <p>Per</p>
    <p>Multi</p>
    <p>Updateable</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
  </div>
  <div class="page">
    <p>Identify a set of packet header fields that delineate the subset of traffic that relates to the state</p>
    <p>Common access patterns key</p>
    <p>value</p>
    <p>Hashtable</p>
    <p>Per</p>
    <p>Multi</p>
    <p>Updateable</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
  </div>
  <div class="page">
    <p>Identify a set of packet header fields that delineate the subset of traffic that relates to the state</p>
    <p>Common access patterns</p>
    <p>Per</p>
    <p>Multi</p>
    <p>Updateable</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
  </div>
  <div class="page">
    <p>Identify a set of packet header fields that delineate the subset of traffic that relates to the state</p>
    <p>Common access patterns</p>
    <p>Per</p>
    <p>Multi</p>
    <p>Updateable</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
  </div>
  <div class="page">
    <p>Identify a set of packet header fields that delineate the subset of traffic that relates to the state</p>
    <p>Common access patterns</p>
    <p>key &amp; value</p>
    <p>struct host *lookup(uint ip) { struct host *curr = hosts; while (curr != NULL) { if (curr-&gt;ip == ip) return curr; curr = curr-&gt;next; } }</p>
    <p>Linked List</p>
    <p>Per</p>
    <p>Multi</p>
    <p>Updateable</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
  </div>
  <div class="page">
    <p>Identify a set of packet header fields that delineate the subset of traffic that relates to the state</p>
    <p>Per</p>
    <p>Multi</p>
    <p>Updateable</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
    <p>entry = host_map[index]</p>
  </div>
  <div class="page">
    <p>Identify a set of packet header fields that delineate the subset of traffic that relates to the state</p>
    <p>Per</p>
    <p>Multi</p>
    <p>Updateable</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
    <p>Program chopping to determine relevant header fields</p>
    <p>struct pktHdr *pkt = recv(extPcap);</p>
    <p>entry = host_map[index]</p>
  </div>
  <div class="page">
    <p>Identify a set of packet header fields that delineate the subset of traffic that relates to the state</p>
    <p>Per</p>
    <p>Multi</p>
    <p>Updateable</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
    <p>Program chopping to determine relevant header fields</p>
    <p>struct pktHdr *pkt = recv(extPcap);</p>
    <p>src_ip = pkt-&gt;ip_src_addr;</p>
    <p>packet_count ++;</p>
    <p>index = src_ip + offset</p>
    <p>entry = host_map[index]</p>
  </div>
  <div class="page">
    <p>Identify a set of packet header fields that delineate the subset of traffic that relates to the state</p>
    <p>Per</p>
    <p>Multi</p>
    <p>Updateable</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
    <p>Program chopping to determine relevant header fields</p>
    <p>struct pktHdr *pkt = recv(extPcap);</p>
    <p>src_ip = pkt-&gt;ip_src_addr;</p>
    <p>packet_count ++;</p>
    <p>index = src_ip + offset</p>
    <p>entry = host_map[index]</p>
  </div>
  <div class="page">
    <p>Identify a set of packet header fields that delineate the subset of traffic that relates to the state</p>
    <p>Per</p>
    <p>Multi</p>
    <p>Updateable</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
    <p>Program chopping to determine relevant header fields</p>
  </div>
  <div class="page">
    <p>StateAlyzr steps</p>
  </div>
  <div class="page">
    <p>StateAlyzr steps</p>
  </div>
  <div class="page">
    <p>StateAlyzr steps</p>
    <p>Conf</p>
    <p>State</p>
    <p>Per Multi All</p>
  </div>
  <div class="page">
    <p>StateAlyzr steps</p>
    <p>Conf</p>
    <p>State</p>
    <p>Per Multi All</p>
    <p>Read-only Updateable</p>
  </div>
  <div class="page">
    <p>StateAlyzr steps</p>
    <p>Conf</p>
    <p>State</p>
    <p>Per Multi All</p>
    <p>Read-only Updateable</p>
    <p>Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Conf</p>
  </div>
  <div class="page">
    <p>StateAlyzr steps</p>
    <p>Conf</p>
    <p>State</p>
    <p>Per Multi All</p>
    <p>Read-only Updateable</p>
    <p>Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Conf</p>
    <p>Per</p>
    <p>Multi</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
    <p>Flowspace</p>
  </div>
  <div class="page">
    <p>StateAlyzr steps</p>
    <p>Conf</p>
    <p>State</p>
    <p>Per Multi All</p>
    <p>Read-only Updateable</p>
    <p>Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Conf</p>
    <p>Per</p>
    <p>Multi</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
    <p>Flowspace</p>
  </div>
  <div class="page">
    <p>StateAlyzr steps</p>
    <p>Identify the type of output (log or packet) that updateable state affects</p>
    <p>Conf</p>
    <p>State</p>
    <p>Per Multi All</p>
    <p>Read-only Updateable</p>
    <p>Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Conf</p>
    <p>Per</p>
    <p>Multi</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
    <p>Multi</p>
    <p>Per Flowspace</p>
  </div>
  <div class="page">
    <p>StateAlyzr steps</p>
    <p>Identify the type of output (log or packet) that updateable state affects</p>
    <p>Conf</p>
    <p>State</p>
    <p>Per Multi All</p>
    <p>Read-only Updateable</p>
    <p>Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Conf</p>
    <p>Per Multi</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
    <p>Per</p>
    <p>Multi</p>
    <p>Per Flowspace</p>
  </div>
  <div class="page">
    <p>StateAlyzr steps</p>
    <p>Identify the type of output (log or packet) that updateable state affects</p>
    <p>Conf</p>
    <p>State</p>
    <p>Per Multi All</p>
    <p>Read-only Updateable</p>
    <p>Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Conf</p>
    <p>Per Multi</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
    <p>Per</p>
    <p>Multi</p>
    <p>Per Flowspace</p>
  </div>
  <div class="page">
    <p>StateAlyzr steps</p>
    <p>Identify the type of output (log or packet) that updateable state affects</p>
    <p>to track whether a variable is updated</p>
    <p>Conf</p>
    <p>State</p>
    <p>Per Multi All</p>
    <p>Read-only Updateable</p>
    <p>Per</p>
    <p>Multi</p>
    <p>All</p>
    <p>Conf</p>
    <p>Per Multi</p>
    <p>[Src IP, Dst IP, Src Port, Dst_Port, proto]</p>
    <p>[Src IP, Dst IP]</p>
    <p>Per</p>
    <p>Multi</p>
    <p>Per Flowspace</p>
  </div>
  <div class="page">
    <p>Implementation</p>
  </div>
  <div class="page">
    <p>Used CodeSurfer to implement StateAlyzr</p>
    <p>Implementation</p>
  </div>
  <div class="page">
    <p>Used CodeSurfer to implement StateAlyzr  CodeSurfer has built-in support for</p>
    <p>Implementation</p>
  </div>
  <div class="page">
    <p>Used CodeSurfer to implement StateAlyzr  CodeSurfer has built-in support for</p>
    <p>Control flow graph construction</p>
    <p>Implementation</p>
  </div>
  <div class="page">
    <p>Used CodeSurfer to implement StateAlyzr  CodeSurfer has built-in support for</p>
    <p>Control flow graph construction</p>
    <p>Flow and context-insensitive pointer analysis</p>
    <p>Implementation</p>
  </div>
  <div class="page">
    <p>Used CodeSurfer to implement StateAlyzr  CodeSurfer has built-in support for</p>
    <p>Control flow graph construction</p>
    <p>Flow and context-insensitive pointer analysis</p>
    <p>Forward/backward slice and chop computation</p>
    <p>Implementation</p>
  </div>
  <div class="page">
    <p>Used CodeSurfer to implement StateAlyzr  CodeSurfer has built-in support for</p>
    <p>Control flow graph construction</p>
    <p>Flow and context-insensitive pointer analysis</p>
    <p>Forward/backward slice and chop computation</p>
    <p>Analyzed four open-source middleboxes</p>
    <p>Implementation</p>
  </div>
  <div class="page">
    <p>Used CodeSurfer to implement StateAlyzr  CodeSurfer has built-in support for</p>
    <p>Control flow graph construction</p>
    <p>Flow and context-insensitive pointer analysis</p>
    <p>Forward/backward slice and chop computation</p>
    <p>Analyzed four open-source middleboxes 1. PRADS  a monitoring middlebox</p>
    <p>Implementation</p>
  </div>
  <div class="page">
    <p>Used CodeSurfer to implement StateAlyzr  CodeSurfer has built-in support for</p>
    <p>Control flow graph construction</p>
    <p>Flow and context-insensitive pointer analysis</p>
    <p>Forward/backward slice and chop computation</p>
    <p>Analyzed four open-source middleboxes 1. PRADS  a monitoring middlebox</p>
    <p>Implementation</p>
  </div>
  <div class="page">
    <p>Used CodeSurfer to implement StateAlyzr  CodeSurfer has built-in support for</p>
    <p>Control flow graph construction</p>
    <p>Flow and context-insensitive pointer analysis</p>
    <p>Forward/backward slice and chop computation</p>
    <p>Analyzed four open-source middleboxes 1. PRADS  a monitoring middlebox</p>
    <p>Implementation</p>
  </div>
  <div class="page">
    <p>Used CodeSurfer to implement StateAlyzr  CodeSurfer has built-in support for</p>
    <p>Control flow graph construction</p>
    <p>Flow and context-insensitive pointer analysis</p>
    <p>Forward/backward slice and chop computation</p>
    <p>Analyzed four open-source middleboxes 1. PRADS  a monitoring middlebox</p>
    <p>Implementation</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
  </div>
  <div class="page">
    <p>Precision</p>
    <p>Evaluation</p>
  </div>
  <div class="page">
    <p>Precision</p>
    <p>Performance benefits at run time</p>
    <p>Evaluation</p>
  </div>
  <div class="page">
    <p>Evaluation: effectiveness</p>
    <p>MB All variables</p>
    <p>Persistent variables</p>
    <p>per-/crossflow variables</p>
    <p>Updateable variables</p>
    <p>PRADS 1529 61 29 10</p>
    <p>Snort IDS 18393 507 333 148</p>
    <p>HAproxy 7876 272 176 115</p>
    <p>OpenVPN 8704 156 131 106</p>
    <p>Step 0 Step 1 Step 2</p>
  </div>
  <div class="page">
    <p>Evaluation: effectiveness</p>
    <p>MB All variables</p>
    <p>Persistent variables</p>
    <p>per-/crossflow variables</p>
    <p>Updateable variables</p>
    <p>PRADS 1529 61 29 10</p>
    <p>Snort IDS 18393 507 333 148</p>
    <p>HAproxy 7876 272 176 115</p>
    <p>OpenVPN 8704 156 131 106</p>
    <p>Step 0 Step 1 Step 2</p>
  </div>
  <div class="page">
    <p>Evaluation: effectiveness</p>
    <p>MB All variables</p>
    <p>Persistent variables</p>
    <p>per-/crossflow variables</p>
    <p>Updateable variables</p>
    <p>PRADS 1529 61 29 10</p>
    <p>Snort IDS 18393 507 333 148</p>
    <p>HAproxy 7876 272 176 115</p>
    <p>OpenVPN 8704 156 131 106</p>
    <p>Step 0 Step 1 Step 2</p>
    <p>StateAlyzr offers useful improvements in precision</p>
  </div>
  <div class="page">
    <p>Evaluation: effectiveness</p>
    <p>MB All variables</p>
    <p>Persistent variables</p>
    <p>per-/crossflow variables</p>
    <p>Updateable variables</p>
    <p>PRADS 1529 61 29 10</p>
    <p>Snort IDS 18393 507 333 148</p>
    <p>HAproxy 7876 272 176 115</p>
    <p>OpenVPN 8704 156 131 106</p>
    <p>Step 0 Step 1 Step 2</p>
    <p>StateAlyzr offers useful improvements in precision</p>
    <p>Theoretically proved the soundness of our algorithms</p>
  </div>
  <div class="page">
    <p>Highly available PRADS</p>
  </div>
  <div class="page">
    <p>Highly available PRADS</p>
    <p>Primary Hot standby</p>
  </div>
  <div class="page">
    <p>Highly available PRADS</p>
    <p>Primary Hot standby</p>
    <p>State transfer after each packet</p>
  </div>
  <div class="page">
    <p>Highly available PRADS</p>
    <p>Primary Hot standby</p>
    <p>State transfer after each packet</p>
    <p>p e</p>
    <p>r p</p>
    <p>k t</p>
    <p>st a</p>
    <p>te t</p>
    <p>ra n</p>
    <p>sf e</p>
    <p>r (K</p>
    <p>B )</p>
    <p>packet number</p>
    <p>All persistant state</p>
    <p>All updatable state</p>
    <p>Flowspace</p>
  </div>
  <div class="page">
    <p>Highly available PRADS</p>
    <p>Primary Hot standby</p>
    <p>State transfer after each packet</p>
    <p>p e</p>
    <p>r p</p>
    <p>k t</p>
    <p>st a</p>
    <p>te t</p>
    <p>ra n</p>
    <p>sf e</p>
    <p>r (K</p>
    <p>B )</p>
    <p>packet number</p>
    <p>All persistant state</p>
    <p>All updatable state</p>
    <p>Flowspace</p>
  </div>
  <div class="page">
    <p>Highly available PRADS</p>
    <p>Primary Hot standby</p>
    <p>State transfer after each packet</p>
    <p>p e</p>
    <p>r p</p>
    <p>k t</p>
    <p>st a</p>
    <p>te t</p>
    <p>ra n</p>
    <p>sf e</p>
    <p>r (K</p>
    <p>B )</p>
    <p>packet number</p>
    <p>All persistant state</p>
    <p>All updatable state</p>
    <p>Flowspace</p>
  </div>
  <div class="page">
    <p>Highly available PRADS</p>
    <p>Reduction in the state transfer by 305x</p>
    <p>Primary Hot standby</p>
    <p>State transfer after each packet</p>
    <p>p e</p>
    <p>r p</p>
    <p>k t</p>
    <p>st a</p>
    <p>te t</p>
    <p>ra n</p>
    <p>sf e</p>
    <p>r (K</p>
    <p>B )</p>
    <p>packet number</p>
    <p>All persistant state</p>
    <p>All updatable state</p>
    <p>Flowspace</p>
  </div>
  <div class="page">
    <p>Highly available PRADS</p>
    <p>Reduction in the state transfer by 305x</p>
    <p>Primary Hot standby</p>
    <p>State transfer after each packet</p>
    <p>p e</p>
    <p>r p</p>
    <p>k t</p>
    <p>st a</p>
    <p>te t</p>
    <p>ra n</p>
    <p>sf e</p>
    <p>r (K</p>
    <p>B )</p>
    <p>packet number</p>
    <p>All persistant state</p>
    <p>All updatable state</p>
    <p>Flowspace</p>
  </div>
  <div class="page">
    <p>Highly available PRADS</p>
    <p>Reduction in the state transfer by 305x</p>
    <p>Primary Hot standby</p>
    <p>State transfer after each packet</p>
    <p>p e</p>
    <p>r p</p>
    <p>k t</p>
    <p>st a</p>
    <p>te t</p>
    <p>ra n</p>
    <p>sf e</p>
    <p>r (K</p>
    <p>B )</p>
    <p>packet number</p>
    <p>All persistant state</p>
    <p>All updatable state</p>
    <p>Flowspace</p>
    <p>StateAlyzr reduced the manual effort of modifying PRADS from 120hrs to 6 hrs</p>
  </div>
  <div class="page">
    <p>Highly available PRADS</p>
    <p>Reduction in the state transfer by 305x</p>
    <p>Primary Hot standby</p>
    <p>State transfer after each packet</p>
    <p>p e</p>
    <p>r p</p>
    <p>k t</p>
    <p>st a</p>
    <p>te t</p>
    <p>ra n</p>
    <p>sf e</p>
    <p>r (K</p>
    <p>B )</p>
    <p>packet number</p>
    <p>All persistant state</p>
    <p>All updatable state</p>
    <p>Flowspace</p>
    <p>StateAlyzr reduced the manual effort of modifying PRADS from 120hrs to 6 hrs</p>
    <p>StateAlyzr found a compound variable which we missed in our prior modification.</p>
  </div>
  <div class="page">
    <p>Summary</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Goal is to aid middlebox developers to identify state objects that need explicit handling</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Goal is to aid middlebox developers to identify state objects that need explicit handling</p>
    <p>Novel state characterization algorithms that adapt standard program analysis tools</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Goal is to aid middlebox developers to identify state objects that need explicit handling</p>
    <p>Novel state characterization algorithms that adapt standard program analysis tools</p>
    <p>Ensure soundness and high precision</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Goal is to aid middlebox developers to identify state objects that need explicit handling</p>
    <p>Novel state characterization algorithms that adapt standard program analysis tools</p>
    <p>Ensure soundness and high precision</p>
    <p>Ultimate goal is to fully automate the process</p>
  </div>
</Presentation>
