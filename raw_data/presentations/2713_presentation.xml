<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Stateless Network Functions: Breaking the Tight Coupling of State and Processing</p>
    <p>Murad Kablan, Azzam Alsudais, Eric Keller, Franck Le University of Colorado IBM</p>
  </div>
  <div class="page">
    <p>Networks Need Network Functions</p>
    <p>Firewall</p>
    <p>NAT Intrusion Prevention</p>
    <p>Load balancer</p>
    <p>To protect and manage the network traffic</p>
  </div>
  <div class="page">
    <p>Networks Need *Agile* Network Functions</p>
    <p>To match the agility of todays (cloud) compute infrastructure</p>
    <p>Data Center Infrastructure Compute</p>
    <p>NetworkStorage</p>
  </div>
  <div class="page">
    <p>Network Agility -&gt; Easy and Quickly to Use</p>
    <p>Seamless Scalability</p>
    <p>Failure Resiliency</p>
    <p>Instant Deployment</p>
    <p>Without Sacrificing Performance</p>
  </div>
  <div class="page">
    <p>Virtual Network Functions to the Rescue ?</p>
    <p>Hardware Network Functions Software Network Functions</p>
    <p>(Virtual Machines)</p>
  </div>
  <div class="page">
    <p>Same core architecture, same fundamental limit in agility</p>
  </div>
  <div class="page">
    <p>The Challenge is with The State</p>
    <p>Firewall : connection tracking information</p>
    <p>Load balancer: mapping to back end server</p>
    <p>Intrusion Prevention: automata state</p>
    <p>NAT: mapping of internal to external addresses</p>
  </div>
  <div class="page">
    <p>Example Problem 1: Failure</p>
    <p>Flow1</p>
    <p>P3 P2</p>
    <p>State</p>
    <p>State Redirect Traffic</p>
    <p>P1</p>
    <p>Lookup fails!!!</p>
  </div>
  <div class="page">
    <p>Example Problem 2: Scaling In and Out</p>
    <p>Flow1</p>
    <p>State</p>
    <p>State Merge/Split</p>
    <p>Traffic</p>
    <p>Flow2</p>
    <p>Flow3</p>
    <p>Flow2 Flow2</p>
    <p>Flow1</p>
  </div>
  <div class="page">
    <p>Example Problem 3: Asymmetric / Multi-path</p>
    <p>P1 syn</p>
    <p>State</p>
    <p>State P2 synack</p>
    <p>Lookup fails!!!</p>
    <p>Flow1Flow1 (syn)</p>
  </div>
  <div class="page">
    <p>Other Solutions</p>
  </div>
  <div class="page">
    <p>Industry Approaches to Deal with State</p>
    <p>HA Pairs</p>
    <p>Doubles cost, limited scalability, unreliable [Jain2009]</p>
    <p>Dont use state</p>
    <p>e.g., Google Maglev  (hash 5-tuple to select backend).</p>
    <p>Limited applications</p>
    <p>BackupActive</p>
  </div>
  <div class="page">
    <p>Dealing with State: State Migration (for scaling)</p>
    <p>Router Grafting [NSDI 2010],</p>
    <p>Split Merge [NSDI 2013],</p>
    <p>OpenNF [SIGCOMM 2014]</p>
    <p>When needed, migrate the relevant state</p>
    <p>Only handles pre-planned events</p>
    <p>High overhead to migrate state (e.g., 100 ms)</p>
    <p>Relies on flow affinity</p>
    <p>Flow1</p>
    <p>State</p>
    <p>State</p>
    <p>Flow2</p>
  </div>
  <div class="page">
    <p>Dealing with State: Check Pointing (for failure)</p>
    <p>Pico Replication [SoCC 2013]</p>
    <p>Periodically checkpoint state (only diffs, and only network state)</p>
    <p>Limitations:</p>
    <p>Quick recovery from failure</p>
    <p>High packet latency (cant release packets until state check pointed)</p>
    <p>Flow1</p>
    <p>State</p>
    <p>Backup State</p>
    <p>Flow2</p>
    <p>Backup State</p>
  </div>
  <div class="page">
    <p>Dealing with State: Deterministic Replay (for failure)</p>
    <p>FTMB [SIGCOMM 2015]</p>
    <p>Log events so that upon failure we can re-play those events to rebuild the state</p>
    <p>Use periodic check pointing to limit the replay time</p>
    <p>Improves packet latency</p>
    <p>Limitation:</p>
    <p>Long recovery time (time since last check point)</p>
    <p>Flow1</p>
    <p>State</p>
    <p>Log of events</p>
    <p>Flow2</p>
  </div>
  <div class="page">
    <p>What is the root of the problem?</p>
  </div>
  <div class="page">
    <p>Appliance mentality</p>
    <p>Maintaining the Tight Coupling between State and Processing PROCESS</p>
    <p>STATE</p>
    <p>PROCESS</p>
    <p>STATE</p>
  </div>
  <div class="page">
    <p>Stateless Network Functions</p>
    <p>Re-designed as a distributed system from the ground up.</p>
    <p>Decoupling the state from the processing</p>
    <p>PROCESS</p>
    <p>STATE</p>
    <p>PROCESS PROCESS</p>
  </div>
  <div class="page">
    <p>Benefits of Decoupling State from Processing</p>
    <p>Traditional Network Function</p>
    <p>e.g., Firewall</p>
    <p>- Seamless elasticity - No disruption in failure - Doesnt rely on flow affinity - Centralized state (simpler to manage)</p>
    <p>- High overhead to manage state - Relies on flow affinity - Hard to achieve both resiliency</p>
    <p>and elasticity</p>
    <p>Stateless Network Function</p>
    <p>e.g., Stateless Firewall</p>
    <p>PROCESS</p>
    <p>STATE</p>
    <p>PROCESS PROCESS</p>
    <p>PROCESS</p>
    <p>STATE</p>
    <p>PROCESS</p>
    <p>STATE</p>
  </div>
  <div class="page">
    <p>Is this even possible?</p>
    <p>We need to handle millions of packets per second</p>
  </div>
  <div class="page">
    <p>A Counter-Intuitive Proposal But it is possible</p>
    <p>Why we can do this:</p>
    <p>Common packet processing pipeline has a lookup stage (so, per packet request to data store, but not lots of back and forth)</p>
    <p>Requests to data store are much smaller than packets (so, scaling traffic rates does not result in same scaling of data store)</p>
    <p>Advances in low-latency technologies (data stores, network I/O, etc.)</p>
  </div>
  <div class="page">
    <p>How State is Accessed</p>
    <p>Example for Load balancer</p>
    <p>Available Backend Servers</p>
    <p>Assigned Backend Server</p>
    <p>Cluster ID IP List</p>
    <p>Every other Packet of flow (look up assigned server)  1 Read from Assigned table</p>
  </div>
  <div class="page">
    <p>System Architecture StatelessNF</p>
  </div>
  <div class="page">
    <p>Network Function Host</p>
    <p>StatelessNF Architecture</p>
    <p>State</p>
    <p>Network Function</p>
    <p>Network Function</p>
    <p>Network Function Network Function</p>
    <p>Network Function Host</p>
    <p>Monitor/ Manage</p>
    <p>Data Store</p>
    <p>Controller</p>
    <p>SDN Switch</p>
    <p>Traffic to network functions</p>
    <p>OF Rules</p>
    <p>Visualize/ Modify</p>
    <p>Timeout Manager</p>
  </div>
  <div class="page">
    <p>Data Store</p>
    <p>State</p>
    <p>Data Store (RAMCloud)</p>
    <p>Timeout Manager</p>
    <p>Low latency, etc.</p>
    <p>Also needs (or could use) support for timers, atomic updates, queues</p>
  </div>
  <div class="page">
    <p>Network Function Instances</p>
    <p>Network Function Host</p>
    <p>Network Function</p>
    <p>Network Function</p>
    <p>Network Function Network Function</p>
    <p>Network Function Host</p>
  </div>
  <div class="page">
    <p>High-Performance Network I/O</p>
    <p>e.g., DPDK, netmap</p>
    <p>RX</p>
    <p>Input Output</p>
    <p>NIC 1 Thread 1</p>
    <p>NIC 1</p>
    <p>To remote data store</p>
    <p>TX</p>
  </div>
  <div class="page">
    <p>Deployable Packet Processing Container</p>
    <p>e.g., Docker</p>
    <p>Pull</p>
    <p>Input</p>
    <p>Parse, Lookup, and Process</p>
    <p>Output</p>
    <p>NIC 1 Thread 1 Queue 1 Thread 2</p>
    <p>NIC 1 Pipe 1</p>
    <p>Pull Parse, Lookup, and ProcessNIC 2 Thread 3 Queue 2 Thread 4</p>
    <p>NIC 2 Pipe 2</p>
    <p>Pull Parse, Lookup, and ProcessNIC N Thread Nx2-1 Queue N Thread Nx2</p>
    <p>NIC N Pipe N</p>
    <p>To remote data store</p>
  </div>
  <div class="page">
    <p>Optimized Data Store Client Interface</p>
    <p>e.g., Batching, Buffer Alloc</p>
    <p>Buffer Pool Data Store Client Interface</p>
    <p>Pull</p>
    <p>Input</p>
    <p>Parse, Lookup, and Process</p>
    <p>Output</p>
    <p>NIC 1</p>
    <p>Request Batching</p>
    <p>Thread 1 Queue 1 Thread 2 NIC 1</p>
    <p>Pipe 1</p>
    <p>Pull Parse, Lookup, and ProcessNIC 2 Thread 3 Queue 2 Thread 4</p>
    <p>NIC 2 Pipe 2</p>
    <p>Pull Parse, Lookup, and ProcessNIC N Thread Nx2-1 Queue N Thread Nx2</p>
    <p>NIC N Pipe N</p>
    <p>NIC</p>
    <p>To remote data store</p>
  </div>
  <div class="page">
    <p>Orchestration</p>
    <p>Failure handling  speculative failure detection (much faster reactivity)</p>
    <p>Scaling in and out  no need to worry about state when balancing traffic</p>
    <p>Monitor/ Manage Controller</p>
    <p>OF Rules</p>
    <p>Network Function Host</p>
    <p>Network Function</p>
    <p>Network Function</p>
    <p>Network Function Network Function</p>
    <p>Network Function Host</p>
    <p>SDN Switch</p>
    <p>Traffic to network functions</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Network Functions (NAT, Firewall, Load balancer)  DPDK  SR-IOV  Docker  Infiniband to Data store (DPDK since paper)</p>
    <p>Data store  RAMCloud (Redis since paper)  Extending with timer</p>
    <p>Controller  Extended FloodLight, basic policies for handling scaling and failure.</p>
  </div>
  <div class="page">
    <p>StatelessNF System Evaluation</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Goal: in this extreme case architecture, can we get similar throughput and latency as other software</p>
    <p>solutions,</p>
    <p>but with better handling of resilience and failure?</p>
  </div>
  <div class="page">
    <p>Experiment Setup</p>
    <p>Tests:</p>
    <p>Raw throughput, latency</p>
    <p>Handling failure</p>
    <p>Handling scaling in-out</p>
    <p>Traffic generation</p>
    <p>Traffic sink</p>
    <p>Network Function</p>
    <p>Network Function</p>
    <p>Network Function Network Function</p>
    <p>Network Function Host</p>
    <p>Network Function</p>
    <p>Network Function</p>
    <p>Network Function Network Function</p>
    <p>Network Function Host</p>
    <p>Network Functions:</p>
    <p>Baseline Network Functions (state and processing are coupled)</p>
    <p>Stateless Network Functions (state and processing are decoupled)</p>
  </div>
  <div class="page">
    <p>Throughput</p>
    <p>Enterprise Trace  Stateless Roughly matches Baseline</p>
    <p>Note: similar to systems which have added support for scaling or failure</p>
    <p>Raw packets per second  lower until about 256 byte packets</p>
  </div>
  <div class="page">
    <p>Latency</p>
    <p>NAT (Firewall and Load balancer has slight less latencies)</p>
  </div>
  <div class="page">
    <p>Scaling In and Out</p>
  </div>
  <div class="page">
    <p>Handling Failure</p>
  </div>
  <div class="page">
    <p>Discussion and Future Work</p>
  </div>
  <div class="page">
    <p>Discussion</p>
    <p>Date store scalability  Replace RAMCloud with other systems that report better</p>
    <p>throughput and lower latency (e.g., FARM, Algo-Logic)</p>
    <p>Reducing interactions with a remote data store  Integrate a set membership structure (e.g., a bloom filter) to</p>
    <p>reduce the penalty of read misses</p>
    <p>Explore placement of data store instances (e.g., co-locating with network function instances)</p>
  </div>
  <div class="page">
    <p>Conclusions and Future Work</p>
    <p>Networks need agile network functions  Seamless scalability, failure resiliency, without sacrificing performance</p>
    <p>StatelessNF is a design from the ground up  Zero loss scaling, zero loss fail-over</p>
    <p>Main potential drawback performance, but in this extreme point:  Throughput similar to other solutions  100-300us added latency (similar to other solutions)</p>
    <p>Future work: Evolve data store design for network functions</p>
  </div>
  <div class="page">
    <p>Thanks!</p>
  </div>
</Presentation>
