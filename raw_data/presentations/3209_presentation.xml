<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>USENIX Security, 2014</p>
    <p>a bayesian approach to privacy enforcement in smartphones</p>
    <p>Omer Tripp! ! IBM Research, NY! ! Julia Rubin! ! IBM Research, Haifa</p>
  </div>
  <div class="page">
    <p>motivation</p>
    <p>* http://www.theguardian.com/world/2014/jan/27/nsa-gchq-smartphone-app-angry-birds-personal-data</p>
    <p>* http://hackread.com/android-malware-steals-credit-card-information/</p>
  </div>
  <div class="page">
    <p>motivation</p>
    <p>* http://blackdiamondsolutions.com/wp-content/uploads/2013/04/state-of-software-security-report-volume5.pdf</p>
  </div>
  <div class="page">
    <p>illustrative example Address address = getFromLocation(getLocation()); // source!</p>
    <p>String country = address.getCountry();!</p>
    <p>String mImsi = ; // source!</p>
    <p>// 6 digits &lt;= IMSI (MCC+MNC+MSIN) &lt;= 15 (usually 15)!</p>
    <p>if (mImsi != null &amp;&amp; (mImsi.length()&lt;6 || mImsi.length()&gt;15)) { !</p>
    <p>! ! loge(invalid IMSI  + mImsi); mImsi = null; } // sink!</p>
    <p>log(! IMSI:  + mImsi.substring(0,6) + !</p>
    <p>! ! xxxxxxxxx +  , country:  + country); // sink!</p>
    <p>! (slightly revised from: com.android.internal.telephony.cdma.RuniRecords)</p>
  </div>
  <div class="page">
    <p>illustrative example mImsi = 4046855056012340!</p>
    <p>!</p>
    <p>loge(invalid IMSI 4046855056012340)!</p>
    <p>versus! mImsi = 4046855056012340!</p>
    <p>address = { 1101 Kitchawan Rd, Yorktown, US,  } !</p>
    <p>!</p>
    <p>log(IMSI 404685xxxxxxxxx , country = US)!</p>
  </div>
  <div class="page">
    <p>illustrative example mImsi = 40468550560123400!</p>
    <p>!</p>
    <p>loge(invalid IMSI 40468550560123400)!</p>
    <p>versus! mImsi = 4046855056012340!</p>
    <p>address = { 1101 Kitchawan Rd, Yorktown, US,  } !</p>
    <p>!</p>
    <p>log(IMSI 404685xxxxxxxxx , country = US)!</p>
  </div>
  <div class="page">
    <p>illustrative example mImsi = 40468550560123400!</p>
    <p>!</p>
    <p>loge(invalid IMSI 40468550560123400)!</p>
    <p>!</p>
    <p>mImsi = 4046855056012340!</p>
    <p>address = { 1101 Kitchawan Rd, Yorktown, US,  } !</p>
    <p>!</p>
    <p>log(IMSI 404685xxxxxxxxx , country = US)!</p>
    <p>runtime enforcement</p>
  </div>
  <div class="page">
    <p>threat model</p>
    <p>advertising</p>
    <p>analytics</p>
    <p>social computing</p>
    <p>cross-app profiling</p>
    <p>mobile app</p>
    <p>standard transformations (if any): Base64, MD5, plain, .</p>
    <p>un au</p>
    <p>th or</p>
    <p>iz ed</p>
  </div>
  <div class="page">
    <p>a bayesian perspective</p>
    <p>Pr(X | Y) = !! !</p>
    <p>Pr(Y | X) Pr(X)!</p>
    <p>Pr(Y)</p>
  </div>
  <div class="page">
    <p>a bayesian perspective</p>
    <p>Pr(log(s) is illegitimate | [X=x , Y=y , Z=z , ])!</p>
    <p>versus!</p>
    <p>Pr(log(s) is legitimate | [X=x , Y=y , Z=z , ])!</p>
    <p>where !</p>
    <p>s=IMSI 404685xxxxxxxxx , country = US</p>
  </div>
  <div class="page">
    <p>bayes / taint</p>
    <p>Pr#(log(s) is illegitimate | s is tainted) = 1!</p>
    <p>versus!</p>
    <p>Pr#(log(s) is legitimate | s is tainted) = 0!</p>
    <p>where !</p>
    <p>s=IMSI 404685xxxxxxxxx , country = US</p>
  </div>
  <div class="page">
    <p>bayes / taint</p>
    <p>Pr#(log(s) is illegitimate | s is tainted) = 1!</p>
    <p>versus!</p>
    <p>Pr#(log(s) is legitimate | s is tainted) = 0!</p>
    <p>where !</p>
    <p>s=IMSI 404685xxxxxxxxx , country = US</p>
    <p>too conservative 12</p>
  </div>
  <div class="page">
    <p>bayes / value-based features</p>
    <p>Pr#(log(s) is illegitimate | IMSIs=r1,Addrs=r2)!</p>
    <p>versus!</p>
    <p>Pr#(log(s) is legitimate | IMSIs=r1,Addrs=r2) !</p>
    <p>where !</p>
    <p>s = invalid IMSI 404685xxxxxxxxx , country = US!</p>
    <p>Addrs = distance(s, {1101 Kitchawan Rd,Yorktown,US, })!</p>
    <p>IMSIs = distance(s, 4046855056012340)</p>
  </div>
  <div class="page">
    <p>bayes / value-based features</p>
    <p>Pr#(log(s) is illegitimate | IMSIs=r1,Addrs=r2)!</p>
    <p>versus!</p>
    <p>Pr#(log(s) is legitimate | IMSIs=r1,Addrs=r2) !</p>
    <p>where !</p>
    <p>s = invalid IMSI 404685xxxxxxxxx , country = US!</p>
    <p>Addrs = distance(s, {1101 Kitchawan Rd,Yorktown,US, })!</p>
    <p>IMSIs = distance(s, 4046855056012340)</p>
  </div>
  <div class="page">
    <p>bayes / value-based features</p>
    <p>Pr#(log(s) is illegitimate | IMSIs=r1,Addrs=r2)!</p>
    <p>versus!</p>
    <p>Pr#(log(s) is legitimate | IMSIs=r1,Addrs=r2) !</p>
    <p>where !</p>
    <p>s = invalid IMSI 404685xxxxxxxxx , country = US!</p>
    <p>Addrs = distance(s, {1101 Kitchawan Rd,Yorktown,US, })!</p>
    <p>IMSIs = distance(s, 4046855056012340)</p>
  </div>
  <div class="page">
    <p>bayes / value-based features</p>
    <p>Pr#(log(s) is illegitimate | IMSIs=r1,Addrs=r2)!</p>
    <p>versus!</p>
    <p>Pr#(log(s) is legitimate | IMSIs=r1,Addrs=r2) !</p>
    <p>where !</p>
    <p>s = invalid IMSI 404685xxxxxxxxx , country = US!</p>
    <p>Addrs = distance(s, {1101 Kitchawan Rd,Yorktown,US, })!</p>
    <p>IMSIs = distance(s, 4046855056012340)</p>
    <p>s is tainted</p>
    <p>s is tainted</p>
  </div>
  <div class="page">
    <p>bayes / value-based features</p>
    <p>Pr#(log(s) is illegitimate | IMSIs=r1,Addrs=r2)!</p>
    <p>versus!</p>
    <p>Pr#(log(s) is legitimate | IMSIs=r1,Addrs=r2) !</p>
    <p>where !</p>
    <p>s = invalid IMSI 404685xxxxxxxxx , country = US!</p>
    <p>Addrs = distance(s, {1101 Kitchawan Rd,Yorktown,US, })!</p>
    <p>IMSIs = distance(s, 4046855056012340)</p>
  </div>
  <div class="page">
    <p>value-based features  why?</p>
    <p>precision: capture inherent fuzziness of privacy domain!  e.g.: 404685xxxxxxxxx vs 4046855056xxxxx vs 404685505610234!</p>
    <p>robustness: can we do without taint tracking?!  e.g.: Pr#( | IMSIs=r1, Addrs=r2) vs Pr#( | IMSIs=r1, Addrs=r2, s is tainted)</p>
  </div>
  <div class="page">
    <p>value-based features  how?</p>
  </div>
  <div class="page">
    <p>value-based features  how?  assumption I: distance metric bounded by arguments !</p>
    <p>d(x,y) &lt;= max(x,y)</p>
  </div>
  <div class="page">
    <p>value-based features  how?  assumption I: distance metric bounded by arguments !</p>
    <p>d(x,y) &lt;= max(x,y)!</p>
    <p>assumption II: feature values bounded from above!</p>
    <p>for all features f in F. exists c. |[f]| &lt; c</p>
  </div>
  <div class="page">
    <p>value-based features  how?  assumption I: distance metric bounded by arguments !</p>
    <p>d(x,y) &lt;= max(x,y)!</p>
    <p>assumption II: feature values bounded from above!</p>
    <p>for all features f in F. exists c. |[f]| &lt; c!</p>
    <p>assumption III: comparisons bounded by feature value!</p>
    <p>in all comparisons d(f,y). |y| &lt;= |[f]|</p>
  </div>
  <div class="page">
    <p>value-based features  how?</p>
    <p>hama,b(|a|,|b|) = !#D{ 0 &lt;= i &lt;= |a| : ai != bj }!</p>
    <p>Hamming distance: min # of substitutions to transform a into b</p>
  </div>
  <div class="page">
    <p>value-based features  how?</p>
    <p>! ! ! ! ! ! max(i,j)! ! ! ! ! ! ! ! if min(i,j)=0!</p>
    <p>! ! ! ! ! ! ! ! lev(i-1,j)+1!</p>
    <p>leva,b(|a|,|b|) = min! lev(i,j-1)+1 ! ! ! ! ! o/w!</p>
    <p>! ! ! ! ! ! ! ! lev(i-1,j-1) + [ai != bj]! ! !</p>
    <p>Levenshtein distance: min # of char edits to transform a into b</p>
  </div>
  <div class="page">
    <p>value-based features  when?</p>
    <p>Pr#(log(s) leg/illeg|IMSIs=r1,Addrs=r2) = !</p>
    <p>Pr#(IMSIs=r1,Addrs=r2|log(s) leg/illeg) Pr#(log(s) leg/illeg)!</p>
    <p>Pr#(IMSIs=r1,Addrs=r2)</p>
  </div>
  <div class="page">
    <p>value-based features  when?</p>
    <p>Pr#(log(s) leg/illeg|IMSIs=r1,Addrs=r2) = !</p>
    <p>Pr#(IMSIs=r1,Addrs=r2|log(s) leg/illeg) Pr#(log(s) leg/illeg)!</p>
    <p>Pr#(IMSIs=r1,Addrs=r2)</p>
    <p>never: same denominator in both leg and illeg expression</p>
  </div>
  <div class="page">
    <p>value-based features  when?</p>
    <p>Pr#(log(s) leg/illeg|IMSIs=r1,Addrs=r2) = !</p>
    <p>Pr#(IMSIs=r1,Addrs=r2|log(s) leg/illeg) Pr#(log(s) leg/illeg)!</p>
    <p>Pr#(IMSIs=r1,Addrs=r2)</p>
    <p>offline: based on existing studies (e.g.: Hornyack et al. &amp; Enck et al.)</p>
  </div>
  <div class="page">
    <p>value-based features  when?</p>
    <p>Pr#(log(s) leg/illeg|IMSIs=r1,Addrs=r2) = !</p>
    <p>Pr#(IMSIs=r1,Addrs=r2|log(s) leg/illeg) Pr#(log(s) leg/illeg)!</p>
    <p>Pr#(IMSIs=r1,Addrs=r2)</p>
    <p>offline: manual analysis of 35 apps (#D{Xi=xij &amp; Y=yk} / #D{Y=yk})</p>
  </div>
  <div class="page">
    <p>the BAYESDROID algorithm onSrcStmt r=src [p]: !</p>
    <p>! f := getFeature src!</p>
    <p>! attach tag f to r!</p>
    <p>onNormalStmt r=nrm [p]:!</p>
    <p>! propagate feature tags according to data flow!</p>
    <p>onSinkStmt r=snk [p]:!</p>
    <p>! F={f &gt; [pf]} := extractTags [p] ; v := { }!</p>
    <p>! for all f &gt; [pf] in F. { u := ref f ; v[f] := d*(u,[pf]) }!</p>
    <p>! alarm if Pr#(r snk [p] illeg | v) &gt; Pr#(r snk [p] leg | v)</p>
    <p>map source API to feature (e.g.: getDeviceId() &gt; IMEI)</p>
    <p>taint seed</p>
    <p>taint propagation</p>
    <p>tag-based feature/values extraction</p>
    <p>similarity checking</p>
    <p>bayesian judgment</p>
  </div>
  <div class="page">
    <p>BAYESDROID: beyond plain text onSrcStmt r=src [p]: !</p>
    <p>! f := getFeature src!</p>
    <p>! attach tag f to r!</p>
    <p>onNormalStmt r=nrm [p]:!</p>
    <p>! propagate feature tags according to data flow!</p>
    <p>onSinkStmt r=snk [p]:!</p>
    <p>! F={f &gt; [pf]} := extractTags [p] ; v := { }!</p>
    <p>! for all f &gt; [pf] in F, t in T. { u := t (ref f) ; v[f] := d*(u,[pf]) }!</p>
    <p>! alarm if Pr#(r snk [p] illeg | v) &gt; Pr#(r snk [p] leg | v)</p>
    <p>T: a set of std. transformations</p>
  </div>
  <div class="page">
    <p>BAYESDROID: unbounded values onSrcStmt r=src [p]: !</p>
    <p>! f := getFeature src!</p>
    <p>! attach tag f to r!</p>
    <p>onNormalStmt r=nrm [p]:!</p>
    <p>! propagate feature tags according to data flow!</p>
    <p>onSinkStmt r=snk [p]:!</p>
    <p>! F={f &gt; [pf]} := extractTags [p] ; v := { }!</p>
    <p>! for all f &gt; [pf] in F, t in T. { u := t (ref f) { v[f] := min { d*(u,[pf], cf }) }!</p>
    <p>! alarm if Pr#(r snk [p] illeg | v) &gt; Pr#(r snk [p] leg | v)</p>
    <p>cf: per-feat bound</p>
  </div>
  <div class="page">
    <p>BAYESDROID: taint-free tracking onSrcStmt r=src [p]: !</p>
    <p>! f := getFeature src!</p>
    <p>! attach tag f to r!</p>
    <p>onNormalStmt r=nrm [p]:!</p>
    <p>! propagate feature tags according to data flow!</p>
    <p>onSinkStmt r=snk [p]:!</p>
    <p>! F={f &gt; [pf]} := mapAllValsUpToDepthK ([p],k) ; v := { }!</p>
    <p>! for all f &gt; [pf] in F, t in T. { u := t (ref f) { v[f] := min { d*(u,[pf], cf }) }!</p>
    <p>! alarm if Pr#(r snk [p] illeg | v) &gt; Pr#(r snk [p] leg | v)</p>
    <p>comp. w all vals of depth &lt;= k</p>
  </div>
  <div class="page">
    <p>H1: accuracy</p>
    <p>bayesian reasoning about data leakage, accounting explicitly for value similarity, is significantly more accurate than taint tracking</p>
  </div>
  <div class="page">
    <p>H1: methodology</p>
    <p>DroidBench: independent and publicly available privacy suite consisting of 50 test cases!</p>
    <p>excluded 8 benchmarks that crash at startup and 5 that leak data via unreachable callbacks (e.g.: onLowMemory())!</p>
    <p>compared with the TaintDroid enforcement system</p>
  </div>
  <div class="page">
    <p>H1: results Benchmark BayesDroid TaintDroid</p>
    <p>TPs FPs FNs acc TPs FPs FNs acc</p>
    <p>ActivityCommunication1 1 0 0 1.0 1 0 0 1.0</p>
    <p>ActivityLifecycle1</p>
    <p>AnonymousClass1 0 0 0 1.0 0 1 0 0.0</p>
  </div>
  <div class="page">
    <p>H1: results Benchmark BayesDroid TaintDroid</p>
    <p>TPs FPs FNs acc TPs FPs FNs acc</p>
    <p>ActivityCommunication1 1 0 0 1.0 1 0 0 1.0</p>
    <p>ActivityLifecycle1</p>
    <p>AnonymousClass1 0 0 0 1.0 0 1 0 0.0</p>
  </div>
  <div class="page">
    <p>H1: results Benchmark BayesDroid TaintDroid</p>
    <p>TPs FPs FNs acc TPs FPs FNs acc</p>
    <p>ActivityCommunication1 1 0 0 1.0 1 0 0 1.0</p>
    <p>ActivityLifecycle1</p>
    <p>AnonymousClass1 0 0 0 1.0 0 1 0 0.0</p>
    <p>Integer[] numbers = new Integer[] {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,}; char[] imeiAsChar = imei.toCharArray(); char[] newOldIMEI = new char[imeiAsChar.length]; for(int i = 0; i &lt; imeiAsChar.length; i++) { newOldIMEI[i] = Character.forDigit(numbers[(int)imeiAsChar[i]], 10); }</p>
  </div>
  <div class="page">
    <p>H2: relaxation</p>
    <p>relaxed detection of relevant values is effective: few false positives are introduced, and applicability to real-world apps improves</p>
  </div>
  <div class="page">
    <p>H2: methodology  two variants: !</p>
    <p>T-BD  relevant values detected via tag propagation!</p>
    <p>H-BD  exhaustive consideration of all values in heap graph up to a fixed bound of k=3!</p>
    <p>benchmarks: 54 of the Google Play apps!</p>
    <p>subset of 65/100 apps not sampled out for training!</p>
    <p>excluded 8 apps w/o permission to access sensitive data and 3 that failed to install properly</p>
  </div>
  <div class="page">
    <p>H2: results Benchmark domain H-BD T-BD</p>
    <p>no. dev. ID</p>
    <p>loc. no. dev. ID</p>
    <p>loc.</p>
    <p>atsoft.games.smgame arcade</p>
    <p>com.antivirus communication</p>
    <p>com.appershopper.ios7lockscreen! personalization</p>
  </div>
  <div class="page">
    <p>conclusion</p>
    <p>bayesian generalization of taint-based privacy enforcement toward better precision!</p>
    <p>value-based similarity features capture fuzziness usefully!</p>
    <p>lower overhead and greater robustness by relaxing taint tracking</p>
  </div>
  <div class="page">
    <p>thank you / questions?</p>
    <p>Pr(decent answer | question) =!</p>
    <p>Pr(decent answer |covered by (backup) slides)!</p>
    <p>+!</p>
    <p>Pr(decent answer | ! ! ! is a decent answer)</p>
  </div>
  <div class="page">
    <p>backup</p>
  </div>
  <div class="page">
    <p>overhead</p>
    <p>O ve</p>
    <p>ra ll</p>
    <p>O ve</p>
    <p>rh ea</p>
    <p>d (%</p>
    <p>)</p>
    <p>Propagation Steps</p>
    <p>Tag Propagation Overhead Bayesian Analysis Overhead</p>
  </div>
  <div class="page">
    <p>false negatives</p>
    <p>public class ImplicitFlow1 extends Activity { protected void onCreate(Bundle savedInstanceState) { TelephonyManager telephonyManager = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE); String imei = telephonyManager.getDeviceId(); //source String obfuscatedIMEI = obfuscateIMEI(imei); writeToLog(obfuscatedIMEI); obfuscatedIMEI = reallyHardObfuscatedIMEI(imei); writeToLog(obfuscatedIMEI); } private String obfuscateIMEI(String imei){ String result = &quot;&quot;; for(char c : imei.toCharArray()){ switch(c){ case '0' : result += 'a'; break; case '1' : result += 'b'; break; case '2' : result += 'c'; break;  default : System.err.println(&quot;Problem in obfuscateIMEI for character: &quot; + c); } } return result; } private String reallyHardObfuscatedIMEI(String imei){ //ASCII values for integer: 48-57 Integer[] numbers = new Integer[]{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,}; char[] imeiAsChar = imei.toCharArray(); char[] newOldIMEI = new char[imeiAsChar.length]; for(int i = 0; i &lt; imeiAsChar.length; i++){ newOldIMEI[i] = Character.forDigit(numbers[(int)imeiAsChar[i]], 10);} return newOldIMEI.toString(); } private void writeToLog(String message){ SmsManager sms = SmsManager.getDefault(); sms.sendTextMessage(&quot;+49 1234&quot;, null, message, null, null); //sink leak } }</p>
  </div>
</Presentation>
