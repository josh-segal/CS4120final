<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>ERIK JONSSON SCHOOL OF ENGINEERING AND COMPUTER SCIENCE Cybersecurity Research and Education Institute</p>
    <p>Compiler-instrumented, Dynamic Secret-Redaction of Legacy Processes for Attacker Deception</p>
    <p>Frederico Araujo and Kevin Hamlen The University of Texas at Dallas</p>
  </div>
  <div class="page">
    <p>Problem: Live Process Image Secret-Redaction</p>
    <p>Goal:</p>
    <p>Remove or replace secrets in address spaces of running programs, yielding processes that CONTINUE RUNNING (but with no secrets)</p>
    <p>Potential Applications:</p>
    <p>Debugging: Safely disclose redacted crash dumps to developers</p>
    <p>Intrusion Response: Dynamic secret redaction without loss of service</p>
    <p>Cyber Deception: Runtime replacement of secrets with honey-data</p>
    <p>Honey-patching [CCS14]</p>
  </div>
  <div class="page">
    <p>Problem: Live Process Image Secret-Redaction</p>
    <p>Goal:</p>
    <p>Remove or replace secrets in address spaces of running programs, yielding processes that CONTINUE RUNNING (but with no secrets)</p>
    <p>Potential Applications:</p>
    <p>Debugging: Safely disclose redacted crash dumps to developers</p>
    <p>Intrusion Response: Dynamic secret redaction without loss of service</p>
    <p>Cyber Deception: Runtime replacement of secrets with honey-data</p>
    <p>Honey-patching [CCS14]</p>
  </div>
  <div class="page">
    <p>SESSIONID=33F4094F68826284D18AA6D7ED1D SESSIONID=2321CFA5DA771A284D13DD67798A</p>
    <p>Runtime Secret Redaction</p>
    <p>...............................L......</p>
    <p>.@..</p>
    <p>en_US xyz-198 8229788/6160/11/........</p>
    <p>.Accept-Encoding: gzip,deflate,sdch...</p>
    <p>...Accept-Language: en-US,en;q=0.8....</p>
    <p>;................*.......</p>
    <p>..6D7ED1D554E.........*..?.e.b....L...</p>
    <p>..........*......</p>
    <p>Accept:text/html,application/xhtml+xml</p>
    <p>,application/xml;q=0.9,*/*;q=0.8......</p>
    <p>............*.........................</p>
    <p>Linux x86_64; rv:32.0) Gecko/20100101</p>
    <p>Firefox/32.0...............@..........</p>
    <p>......... .......*.....</p>
    <p>.GET / HTTP/1.1.......................</p>
    <p>GET / HTTP/1.1 /browse/plan.html</p>
    <p>Cookie: app.token= CDEF-0C0G-BSN7-VOZ1</p>
    <p>|3d6d84686dc0</p>
    <p>Cookie: app.token= BACC-76GF-ABS3-ZOV2</p>
    <p>GET / HTTP/1.1 /browse/doc1.html</p>
    <p>App.token= BACC-65CH</p>
    <p>container pool</p>
    <p>target</p>
    <p>web server honey-patched</p>
    <p>decoy</p>
    <p>web server unpatched clone</p>
    <p>reverse proxy</p>
    <p>controller</p>
    <p>user 1</p>
    <p>user 2</p>
    <p>attacker</p>
  </div>
  <div class="page">
    <p>Dynamic Taint Tracking</p>
    <p>Program vulnerability detection</p>
    <p>TaintCheck, LIFT, Mimemu, Argos,</p>
    <p>Information leak detection</p>
    <p>TaintDroid, TaintEraser, AndroidLeaks, Spandex, D2Taint,</p>
    <p>Study of sensitive data lifetime</p>
    <p>TaintBochs</p>
    <p>Analysis of spyware behavior</p>
    <p>Panorama, Hookfinder, PHP Aspis,</p>
    <p>Test set generation</p>
    <p>Memsherlock, ConfAid,</p>
    <p>Main idea: Instrument programs with operations that track (explicit) dataflows of secrets.</p>
  </div>
  <div class="page">
    <p>Dynamic Taint Tracking</p>
    <p>/* first colon delimits username:password */ s1 = memchr(hostinfo, ':', s - hostinfo); if (s1) { uptr-&gt;user = memdup(hostinfo, s1 - hostinfo); ++s1; uptr-&gt;password = memdup(s1, s - s1); }</p>
    <p>void safe_free(char *s) { if (s is a secret) // how to test whether s is secret? slow_secure_free(s); else free(s); }</p>
  </div>
  <div class="page">
    <p>Dynamic Taint Tracking</p>
    <p>/* first colon delimits username:password */ s1 = memchr(hostinfo, ':', s - hostinfo); if (s1) { uptr-&gt;user = memdup(hostinfo, s1 - hostinfo); ++s1; uptr-&gt;password = memdup(s1, s - s1); dfsan_set_label(SECRET, uptr-&gt;password, sizeof(s - s1)) }</p>
    <p>Taint Introduction:</p>
    <p>void safe_free(char *s) { if (s is a secret) // how to test whether s is secret? slow_secure_free(s); else free(s); }</p>
  </div>
  <div class="page">
    <p>Dynamic Taint Tracking</p>
    <p>/* first colon delimits username:password */ s1 = memchr(hostinfo, ':', s - hostinfo); if (s1) { uptr-&gt;user = memdup(hostinfo, s1 - hostinfo); ++s1; uptr-&gt;password = memdup(s1, s - s1); dfsan_set_label(SECRET, uptr-&gt;password, sizeof(s - s1)) }</p>
    <p>void safe_free(char *s) { if (dfsan_get_label(s) == SECRET) slow_secure_free(s); else free(s); }</p>
    <p>Taint Introduction:</p>
    <p>Taint Check:</p>
  </div>
  <div class="page">
    <p>Retrofitting Headaches</p>
    <p>/* first colon delimits username:password */ s1 = memchr(hostinfo, ':', s - hostinfo); if (s1) { uptr-&gt;user = memdup(hostinfo, s1 - hostinfo); ++s1; uptr-&gt;password = memdup(s1, s - s1); dfsan_set_label(SECRET, uptr-&gt;password, sizeof(s - s1)) }</p>
    <p>Taint Introduction:</p>
  </div>
  <div class="page">
    <p>Retrofitting Headaches</p>
    <p>p = &amp;(uptr-&gt;password); *p = malloc();  /* first colon delimits username:password */ s1 = memchr(hostinfo, ':', s - hostinfo); if (s1) { uptr-&gt;user = memdup(hostinfo, s1 - hostinfo); ++s1; *p = memdup(s1, s - s1); dfsan_set_label(SECRET, *p, sizeof(s - s1)) }</p>
    <p>Taint Introduction:</p>
    <p>Apache is 2.2M SLOC!</p>
  </div>
  <div class="page">
    <p>Our Solution: Declarative Secret Annotations for C</p>
    <p>Declarative vs. Operational Secret Annotations  Fewer declarations than operations for user to annotate  Compiler infers and implements operations from declarations  Compiler optimizes operational implementation</p>
    <p>SECRET = struct contains secrets</p>
    <p>SECRET_STR = field is a pointer to a null-terminated sequence of secret chars</p>
    <p>NONSECRET = field is a non-secret within a SECRET struct</p>
    <p>struct apr_uri_t { NONSECRET char *user; SECRET_STR char *password;  } SECRET;</p>
    <p>type qualifiers!</p>
  </div>
  <div class="page">
    <p>Clang/LLVM</p>
    <p>SignaC: Secret Information Graph iNstrumentation for Annotated C</p>
    <p>rewriting Clang preprocessor</p>
    <p>source code</p>
    <p>instrumentation LLVM pass</p>
    <p>taint-tracking binary</p>
    <p>type annotations</p>
    <p>SECRET,</p>
    <p>sources</p>
    <p>PC2S</p>
  </div>
  <div class="page">
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Taint Propagation</p>
    <p>p = &amp;(uptr-&gt;password); *p = malloc();  /* first colon delimits username:password */ s1 = memchr(hostinfo, ':', s - hostinfo); if (s1) { uptr-&gt;user = memdup(hostinfo, s1 - hostinfo); ++s1; memcpy(*p, s1, s - s1); }</p>
    <p>Need taint propagation semantics for</p>
    <p>field access operator (-&gt;)</p>
    <p>address-of (&amp;) operator</p>
    <p>assignments (=)</p>
    <p>dereferencing assignments (*p = )</p>
    <p>dynamic memory allocations (malloc)</p>
  </div>
  <div class="page">
    <p>Pointer Combine Semantics (PCS)</p>
    <p>Two standard answers:  No-Combine Semantics: label of *p is just USER2</p>
    <p>Rationale: v was copied; its ownership didnt change.</p>
    <p>Combine Semantics: label of *p is USER1  USER2 (joint ownership)  Rationale: Failing to redact value at *p now possibly divulges value of pointer p.</p>
    <p>Conclusion: Value *p is now one of USER1s secrets (as well as continuing to be one of USER2s secrets).</p>
    <p>p</p>
    <p>p</p>
    <p>v</p>
    <p>v</p>
    <p>p v *p</p>
    <p>p v *p</p>
    <p>*p=v</p>
    <p>mytype *p = ; mytype v = ; dfsan_set_label(USER1, p, sizeof(p)); dfsan_set_label(USER2, v, sizeof(v)); *p = v;</p>
    <p>What should be the resulting label of *p ? ???</p>
    <p>??? USER1</p>
    <p>USER2</p>
  </div>
  <div class="page">
    <p>Pointer Combine Semantics (PCS)</p>
    <p>uptr-&gt;password</p>
    <p>uptr-&gt;user = v1;</p>
    <p>uptr-&gt;password = v2;</p>
    <p>s1</p>
    <p>uptr-&gt;user</p>
    <p>uptr-&gt;password</p>
    <p>struct apr_uri_t { NONSECRET char *user; SECRET_STR char *password;  } SECRET;</p>
    <p>p</p>
    <p>p</p>
    <p>v</p>
    <p>v</p>
    <p>p v *p</p>
    <p>p v *p</p>
    <p>*p=v</p>
    <p>p p</p>
    <p>p v x=*p</p>
    <p>v</p>
    <p>*p p = &amp;(uptr-&gt;password); *p = malloc(); *p[i] = v (for all i) x = *p[i] (for all i)</p>
    <p>propagation semantics:</p>
    <p>revisiting our initial example</p>
  </div>
  <div class="page">
    <p>node2-&gt;secret_int</p>
    <p>l-&gt;next</p>
    <p>l-&gt;secret_int</p>
    <p>PCS Problems: Overtainting &amp; Label Creep</p>
    <p>while (freelist != NULL) { node = freelist; freelist = node-&gt;next; free(node); }</p>
    <p>while (prev) { prev-&gt;eos_sent = 1; prev = prev-&gt;prev; }</p>
    <p>l-&gt;next</p>
    <p>l-&gt;secret_int = 1234</p>
    <p>l-&gt;next = node2</p>
    <p>node2-&gt;secret_int node2-&gt;secret_int</p>
    <p>l-&gt;secret_int</p>
    <p>l-&gt;secret_int = 1234; l-&gt;next = node2; node2-&gt;secret_int;</p>
    <p>very common</p>
    <p>but</p>
  </div>
  <div class="page">
    <p>Our Solution: Pointer Conditional-Combine Semantics (PC2S)</p>
    <p>A New Third Answer:</p>
    <p>Conditional-Combine Semantics: label of *p depends upon the static type of v!</p>
    <p>if v has pointer type, then use No-Combine Semantics (USER2).</p>
    <p>if v has non-pointer type, then use Combine Semantics (USER1  USER2).</p>
    <p>p</p>
    <p>p</p>
    <p>v</p>
    <p>v</p>
    <p>p v *p</p>
    <p>p v *p</p>
    <p>*p=v</p>
    <p>mytype *p = ; mytype v = ; dfsan_set_label(USER1, p, sizeof(p)); dfsan_set_label(USER2, v, sizeof(v)); *p = v;</p>
    <p>What should be the resulting label of *p ? ???</p>
    <p>??? USER1</p>
    <p>USER2</p>
  </div>
  <div class="page">
    <p>l-&gt;secret_int</p>
    <p>Our Solution: Pointer Conditional-Combine Semantics (PC2S)</p>
    <p>l-&gt;next</p>
    <p>l-&gt;secret_int = 1234</p>
    <p>l-&gt;next = node2</p>
    <p>node2-&gt;secret_int node2-&gt;secret_int</p>
    <p>l-&gt;secret_int</p>
    <p>p</p>
    <p>p</p>
    <p>v</p>
    <p>v</p>
    <p>p v *p</p>
    <p>p v *p</p>
    <p>*p=v</p>
    <p>val ue-to-pointe r store</p>
    <p>p</p>
    <p>p</p>
    <p>p'</p>
    <p>p'</p>
    <p>p'</p>
    <p>*p</p>
    <p>p'</p>
    <p>*p</p>
    <p>*p=p'</p>
    <p>pointe r-to-pointe r store</p>
    <p>taint policy: do not combine when pointee has pointer type</p>
    <p>propagation semantics:</p>
    <p>l-&gt;secret_int = 1234; l-&gt;next = node2; node2-&gt;secret_int;</p>
    <p>lets try again</p>
  </div>
  <div class="page">
    <p>Outline</p>
  </div>
  <div class="page">
    <p>SignaC: Type Attributes</p>
    <p>|-RecordDecl 0x8943a40 &lt;line:15:9, line:19:1&gt; line:15:16 struct request_rec definition | |-AnnotateAttr 0x8943d60 &lt;line:3:31, col:48&gt; &quot;secret&quot; | |-FieldDecl 0x8943c20 &lt;line:16:5, col:29&gt; col:29 referenced pool 'apr_pool_t *  | ` -FieldDecl 0x8943ca0 &lt;line:17:5, col:15&gt; col:15 parsed_uri 'apr_uri_t':'struct apr_uri_t'</p>
    <p>clang -Xclang -ast-dump</p>
    <p>struct request_rec { NONSECRET ... *pool; apr_uri_t parsed_uri; ... } SECRET;</p>
    <p>Annotated Types</p>
    <p>clang transformation</p>
    <p>Rewriting</p>
    <p>new = (request_rec *) apr_pcalloc(r-&gt;pool, );</p>
    <p>new = (request_rec *) signac_alloc(apr_pcalloc, r-&gt;pool, );</p>
    <p>Instrume ntation</p>
    <p>clang/LLVM -dfsan -pc</p>
    <p>instrumented binary</p>
    <p>libsignaC</p>
    <p>#define SECRET __attribute__((annotate(&quot;secret&quot;)))</p>
  </div>
  <div class="page">
    <p>SignaC: Type Attributes</p>
    <p>%3 = load %struct.apr_pool_t** %pool, align 8 %4 = load %struct.request_rec** %rec, align 8 %pool2 = getelementptr inbounds %struct.request_rec* %4, i32 0, i32 0 store %struct.apr_pool_t* %3, %struct.apr_pool_t** %pool2, align 8, !tyann !1  !1 = !{!&quot;nonsecret&quot;, i8 0}</p>
    <p>clang -S -emit-llvm</p>
    <p>rec-&gt;pool = pool;</p>
    <p>#define NONSECRET __attribute__((type_annotate(&quot;nonsecret&quot;))) #define SECRET_STR __attribute__((type_annotate(&quot;secret_str&quot;)))</p>
    <p>Quala type qualifiers</p>
    <p>struct request_rec { NONSECRET ... *pool; apr_uri_t parsed_uri; ... } SECRET;</p>
    <p>Annotated Types</p>
    <p>clang transformation</p>
    <p>Rewriting</p>
    <p>new = (request_rec *) apr_pcalloc(r-&gt;pool, );</p>
    <p>new = (request_rec *) signac_alloc(apr_pcalloc, r-&gt;pool, );</p>
    <p>Instrume ntation</p>
    <p>clang/LLVM -dfsan -pc</p>
    <p>instrumented binary</p>
    <p>libsignaC</p>
  </div>
  <div class="page">
    <p>SignaC: Type Attribute Rewriting</p>
    <p>Clang tooling API: AST Matchers + Rewriting API  Allocators list: {malloc, calloc, apr_palloc, apr_pcalloc, }</p>
    <p>rewritten source code</p>
    <p>allocators</p>
    <p>struct request_rec { NONSECRET ... *pool; apr_uri_t parsed_uri; ... } SECRET;</p>
    <p>Annotated Types</p>
    <p>clang transformation</p>
    <p>Rewriting</p>
    <p>new = (request_rec *) apr_pcalloc(r-&gt;pool, );</p>
    <p>new = (request_rec *) signac_alloc(apr_pcalloc, r-&gt;pool, );</p>
    <p>Instrume ntation</p>
    <p>clang/LLVM -dfsan -pc</p>
    <p>instrumented binary</p>
    <p>libsignaC</p>
    <p>struct s {  } SECRET;</p>
    <p>union u {  } SECRET;</p>
    <p>typedef s S; typedef u U;</p>
    <p>struct S { S ns;  };</p>
    <p>union S { S ns;  };</p>
    <p>#define signac_alloc(alloc, args...) ({ \ void * __p = alloc ( args ); \ signac_taint(&amp;__p, sizeof(void*)); \ __p; })</p>
  </div>
  <div class="page">
    <p>struct request_rec { NONSECRET ... *pool; apr_uri_t parsed_uri; ... } SECRET;</p>
    <p>Annotated Types</p>
    <p>clang transformation</p>
    <p>Rewriting</p>
    <p>new = (request_rec *) apr_pcalloc(r-&gt;pool, );</p>
    <p>new = (request_rec *) signac_alloc(apr_pcalloc, r-&gt;pool, );</p>
    <p>Instrume ntation</p>
    <p>clang/LLVM -dfsan -pc</p>
    <p>instrumented binary</p>
    <p>libsignaC</p>
    <p>SignaC: PC2S Instrumentation</p>
    <p>implemented as an extension to DFSan  low-overhead representation of labels: 16-bit integers allocated sequentially  maps without reserving the lower 32TB of the process address space for shadow memory  union labels organized as a dynamically growing binary (DAG)  the union table</p>
    <p>Start End Memory Region</p>
    <p>example: Z  X  Y</p>
    <p>Z</p>
  </div>
  <div class="page">
    <p>SignaC: PC2S Instrumentation</p>
    <p>label propagation across external library interfaces expressed as an ABI list  DFSan predefines an ABI list that covers glibc</p>
    <p>fun:malloc=custom fun:realloc=discard fun:free=discard  fun:isalpha=functional fun:isdigit=functional  fun:memcpy=custom fun:memset=custom fun:strcpy=custom</p>
    <p>discard     functional</p>
    <p>custom custom-defined label propagation wrapper</p>
    <p>other libraries mapped to the ABI: OpenSSL, PCRE, APR,   memory transfer functions (e.g., strcpy, strdup) and input</p>
    <p>functions (e.g., read, pread) ABI extensions for PC2S</p>
    <p>struct request_rec { NONSECRET ... *pool; apr_uri_t parsed_uri; ... } SECRET;</p>
    <p>Annotated Types</p>
    <p>clang transformation</p>
    <p>Rewriting</p>
    <p>new = (request_rec *) apr_pcalloc(r-&gt;pool, );</p>
    <p>new = (request_rec *) signac_alloc(apr_pcalloc, r-&gt;pool, );</p>
    <p>Instrume ntation</p>
    <p>clang/LLVM -dfsan -pc</p>
    <p>instrumented binary</p>
    <p>libsignaC</p>
  </div>
  <div class="page">
    <p>SignaC: PC2S Instrumentation</p>
    <p>instrumentation operates on LLVM IR, inserting label propagation code  propagation policy parametrized at the compilers front-end: pc2s-on-store, pc2s-on-load</p>
    <p>special handling of SECRET_STR annotated types</p>
    <p>example: store instruction</p>
    <p>check for NON_SECRET annotated pointers</p>
    <p>struct request_rec { NONSECRET ... *pool; apr_uri_t parsed_uri; ... } SECRET;</p>
    <p>Annotated Types</p>
    <p>clang transformation</p>
    <p>Rewriting</p>
    <p>new = (request_rec *) apr_pcalloc(r-&gt;pool, );</p>
    <p>new = (request_rec *) signac_alloc(apr_pcalloc, r-&gt;pool, );</p>
    <p>Instrume ntation</p>
    <p>clang/LLVM -dfsan -pc</p>
    <p>instrumented binary</p>
    <p>libsignaC</p>
    <p>ptr  SI.getPointerOperand() value  SI.getValueOperand() shadow  getShadow(value)</p>
    <p>ptrshadow  getShadow(ptr) shadow combine(shadow, ptrshadow)</p>
    <p>!isPtr(value) || !isExemptPtr(&amp;SI)</p>
    <p>str createBitCast(value) createCall(labelStr, str, shadow)</p>
    <p>isSecretStr(&amp;SI)</p>
    <p>IR</p>
    <p>IRstoreShadow(ptr, ..., shadow, &amp;SI)</p>
    <p>IR</p>
    <p>IR</p>
  </div>
  <div class="page">
    <p>SignaC: Runtime Library</p>
    <p>libsignaC : tiny C library that encapsulates runtime support for the type annotation mechanism</p>
    <p>signac_init(pl) initialize a tainting context with a fresh label instantiation pl for the current principal.</p>
    <p>signac_taint(addr, size) taint each address in interval [addr; addr+size) with pl.</p>
    <p>signac_alloc(alloc, ...) wrap allocator alloc and taint the address of its returned pointer with pl.</p>
    <p>struct request_rec { NONSECRET ... *pool; apr_uri_t parsed_uri; ... } SECRET;</p>
    <p>Annotated Types</p>
    <p>clang transformation</p>
    <p>Rewriting</p>
    <p>new = (request_rec *) apr_pcalloc(r-&gt;pool, );</p>
    <p>new = (request_rec *) signac_alloc(apr_pcalloc, r-&gt;pool, );</p>
    <p>Instrume ntation</p>
    <p>clang/LLVM -dfsan -pc</p>
    <p>instrumented binary</p>
    <p>libsignaC</p>
  </div>
  <div class="page">
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Label Creep</p>
  </div>
  <div class="page">
    <p>Taint Spread</p>
    <p>&lt; 3 (redaction)</p>
  </div>
  <div class="page">
    <p>Instrumentation Overhead</p>
    <p>Benchmark C=1 C=10 C=50 C=100</p>
    <p>Static 2.50 2.34 2.56 2.32</p>
    <p>CGI Bash 1.29 0.98 1.00 0.97</p>
    <p>PHP 0.41 0.37 0.30 0.31</p>
    <p>Table 2: Average overhead of instrumentation</p>
  </div>
  <div class="page">
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Secret Redaction</p>
    <p>decoytarget</p>
    <p>attack detected</p>
    <p>fork and detach</p>
    <p>redact memory</p>
    <p>clone resume</p>
    <p>execution</p>
    <p>attacker process</p>
    <p>checkpoint restore</p>
    <p>low high R</p>
    <p>ED A</p>
    <p>C T</p>
    <p>E D</p>
    <p>R ED</p>
    <p>A C</p>
    <p>T E</p>
    <p>D</p>
    <p>R ED</p>
    <p>A C</p>
    <p>T E</p>
    <p>D</p>
    <p>low high</p>
    <p>user 1</p>
    <p>user 2</p>
    <p>attacker</p>
  </div>
  <div class="page">
    <p>Secret Redaction Performance</p>
  </div>
  <div class="page">
    <p>Deception and Performance</p>
    <p>Deception Strategy: Artificially delay non-forking responses to match the forking delay.</p>
  </div>
  <div class="page">
    <p>Validation Tests</p>
    <p>Software Version CVE-ID Description</p>
    <p>Apache 2.2.21 CVE-2011-3368 Improper URL Validation</p>
    <p>OpenSSL 1.0.1f CVE-2014-0160 Buffer over-read in heartbeat extension</p>
    <p>Bash 4.3 CVE-2014-6271 Improper parsing of environment variables</p>
    <p>Table 1: Honey-patched security vulnerabilities</p>
  </div>
  <div class="page">
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>Declarative annotation of secrets</p>
    <p>New pointer tainting methodology</p>
    <p>Reduced secret annotation burden</p>
    <p>New taint propagation semantics</p>
    <p>Accurate while containing taint spread and label creep</p>
    <p>Implemented in LLVM</p>
    <p>Implemented a memory redactor for secure honey-patching</p>
    <p>Tested on three production web servers</p>
  </div>
  <div class="page">
    <p>The End</p>
    <p>Thank you!</p>
    <p>Questions?</p>
    <p>Frederico Araujo</p>
    <p>(frederico.araujo@utdallas.edu)</p>
  </div>
  <div class="page">
    <p>Operational Semantics</p>
  </div>
  <div class="page">
    <p>Operational Semantics</p>
  </div>
</Presentation>
