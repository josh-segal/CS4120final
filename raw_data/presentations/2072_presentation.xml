<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>P A R A L L E L C O M P U T I N G L A B O R A T O R Y</p>
    <p>EECS Electrical Engineering and</p>
    <p>Computer Sciences Berkeley Parlab</p>
    <p>CONCURRIT: Tes&amp;ng Concurrent Programs with Programmable State-Space Explora&amp;on</p>
    <p>(A DSL for Wri&amp;ng Concurrent Tests)</p>
    <p>Jacob Burnim, Tayfun Elmas*! George Necula, Koushik Sen!</p>
    <p>University of California, Berkeley!</p>
    <p>HotPar 2012!</p>
  </div>
  <div class="page">
    <p>Consider:  Mozilla SpiderMonkey JavaScript Engine</p>
    <p>Used in Firefox browser  121K lines of code</p>
    <p>Want to test JS_NewContext, JS_DestroyContext!  Contain 2K &lt; lines of code</p>
    <p>How to write an xUnit-like test for a concurrent program?</p>
  </div>
  <div class="page">
    <p>Fix inputs  Determinis&amp;c test  If there is a bug, every run manifests it!</p>
    <p>How to write an xUnit-like test for a sequen&amp;al program?</p>
    <p>// check if any assertion fails! test_Context() { ! ...! JSContext *cx = JS_NewContext(rt, 0x1000);! if (cx) {! ...! JS_DestroyContext(cx);! }! }!</p>
  </div>
  <div class="page">
    <p>Nondeterminism due to thread schedules  Hard to specify and control schedule!</p>
    <p>How to write an xUnit-like test for a concurrent program?</p>
    <p>// check if any assertion fails! test_Context() {! ! ... // create 10 threads to run testfunc! ! }! ! testfunc() {! JSContext *cx = JS_NewContext(rt, 0x1000);! if (cx) {! ...! JS_DestroyContext(cx);! }! }!</p>
  </div>
  <div class="page">
    <p>Approaches to tesEng concurrent programs</p>
    <p>// check if any assertion fails! test_Context() {! Loop 1000 times {! ... // create 100 threads to run testfunc! }! }! ! testfunc() {! JSContext *cx = JS_NewContext(rt, 0x1000);! if (cx) {! ...! JS_DestroyContext(cx);! }! }!</p>
  </div>
  <div class="page">
    <p>Not scalable for large programs!</p>
    <p>Approaches to tesEng concurrent programs</p>
    <p>Missing: Programmer has no direct control on thread schedule  Key to effec&amp;ve and efficient tes&amp;ng</p>
  </div>
  <div class="page">
    <p>Programmers have oQen insights/ideas about which schedules to look at</p>
    <p>DO NOT READ!</p>
  </div>
  <div class="page">
    <p>Programmers have oQen insights/ideas about which schedules to look at</p>
    <p>JS_BeginRequest are called; when they're returned JS_EndRequest and JS_ClearContextThread are called.</p>
    <p>The crashes consistently occurs inside js_GC in the following code block:</p>
    <p>while ((acx = js_ContextIterator(rt, JS_FALSE, &amp;iter)) != NULL) { if (!acx-&gt;thread || acx-&gt;thread == cx-&gt;thread) continue; memset(acx-&gt;thread-&gt;gcFreeLists, 0, sizeof acx-&gt;thread-&gt;gcFreeLists); GSN_CACHE_CLEAR(&amp;acx-&gt;thread-&gt;gsnCache); }</p>
    <p>acx always appears to be valid but acx-&gt;thread == NULL when the application crashes (which may be in the memset or GSN_CACHE_CLEAR line). This shouldn't occur as these lines should be skipped if (!acx-&gt;thread)..</p>
    <p>What I suspect is happening is that one thread is calling JS_GC while a second is calling JS_EndRequest and JS_ClearContextThread (in returning a context to the pool). The call to JS_GC will block until JS_EndRequest finishes.. JS_GC then resumes.. but while JS_GC is running JS_ClearContextThread also runs (no locking is done in this?), modifying the value of acx-&gt;thread as the code above runs. acx-&gt;thread becomes NULL just before it gets dereferenced and the application exits.</p>
    <p>Reproducible: Always</p>
    <p>Steps to Reproduce: I've tried to put together the smallest bit of code to replicate the problem (and hope I haven't missed anything trimming it down). main() sets up an environment pretty much following the example in the User Guide then sits endlessly calling JS_GC. Before the loop it spawns one or more threads that create a new JSContext each and sit in their own loops beginning and ending requests for those contexts.</p>
    <p>If the child threads just call: JS_BeginRequest JS_EndRequest then the program runs and runs without any problems, as expected.</p>
    <p>If the child threads call: JS_SetContextThread JS_BeginRequest JS_EndRequest JS_ClearContextThread then the program crashes after a few seconds for me.</p>
    <p>If the child threads call: JS_SetContextThread JS_ClearContextThread the crashes happen almost instantly.</p>
    <p>#include &lt;pthread.h&gt; #include &lt;stdlib.h&gt;</p>
    <p>#define XP_UNIX #define JS_THREADSAFE #include &quot;jsapi.h&quot;</p>
    <p>#define THREADS 1</p>
    <p>static JSClass global_class = { &quot;global&quot;, JSCLASS_GLOBAL_FLAGS, JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, JS_FinalizeStub, JSCLASS_NO_OPTIONAL_MEMBERS</p>
    <p>/DVW&amp;RPPHQW</p>
    <p>Save Changes</p>
    <p>EFODU\#EFODU\FRP EHQWPR]LOOD#JPDLOFRP EUHQGDQ#PR]LOODRUJ KLJKPLQG#JPDLOFRP LJRU#PLURUJ MRUHQGRUII#PR]LOODFRP 0LNH0#5HWHN6ROXWLRQVFRP VDPXHOVLGOHUROG#JPDLOFRP VD\UHU#JPDLOFRP</p>
    <p>&gt;UHSO\@&gt;@&gt;UHSO\@&gt;@'HVFULSWLRQ</p>
    <p>)LUVW/DVW3UHY1H[W1RVHDUFKUHVXOWVDYDLODEOH</p>
    <p>%XJ-6B*&amp;FDQGHUHIHUHQFHD18//SRLQWHULQDPXOWL WKUHDGHGDSSXVLQJ-6B&amp;OHDU&amp;RQWH[W7KUHDG</p>
    <p>,PSRUWDQFH QRUPDOYRWH 7DUJHW0LOHVWRQH  $VVLJQHG7R ,JRU%XNDQRY 4$&amp;RQWDFW JHQHUDO#VSLGHUPRQNH\EXJV</p>
    <p>'HSHQGVRQ %ORFNV MVVUF</p>
    <p>6KRZGHSHQGHQF\WUHH JUDSK</p>
    <p>&amp;&amp;/LVW $GGPHWR&amp;&amp;OLVW XVHUVHGLW</p>
    <p>)ODJV</p>
    <p>VD\UHU EORFNLQJ +</p>
    <p>ZDQWHGIHQQHF</p>
    <p>EFODU\ LQWHVWVXLWH -</p>
    <p>EFODU\ LQOLWPXV -</p>
    <p>EORFNLQJ IHQQHF</p>
    <p>EORFNLQJ</p>
    <p>VWDWXV</p>
    <p>EORFNLQJ</p>
    <p>VWDWXV</p>
    <p>EORFNLQJ</p>
    <p>VWDWXV</p>
    <p>$WWDFKPHQWV</p>
    <p>EDFNSRUWWRY.%SDWFK 3'7,JRU%XNDQRY</p>
    <p>VDPXHOVLGOHUROGDSSURYDO 'HWDLOV_'LII</p>
    <p>$GGDQDWWDFKPHQWSURSRVHGSDWFKWHVWFDVHHWF</p>
    <p>SDXOEDUQHWWD#VP[FRQ] 367</p>
    <p>User-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.5) Gecko/2009010509 Gentoo Firefox/3.0.5 Build Identifier: SpiderMonkey 1.7.0</p>
    <p>See http://groups.google.com/group/mozilla.dev.tech.jsengine/browse_thread/thread/b1bf3460297f01e3 for the initial discussion about this.</p>
    <p>I have a multi-threaded application that periodically crashes. I maintain a pool of JSContexts: as they're requested from the pool JS_SetContextThread and JS_BeginRequest are called; when they're returned JS_EndRequest and</p>
    <p>&amp;ROODSVH $OO &amp;RPPHQWV ([SDQG$OO &amp;RPPHQWV</p>
    <p>/DVW&amp;RPPHQW</p>
    <p>Save Changes</p>
    <p>EFODU\#EFODU\FRP EHQWPR]LOOD#JPDLOFRP EUHQGDQ#PR]LOODRUJ KLJKPLQG#JPDLOFRP LJRU#PLURUJ MRUHQGRUII#PR]LOODFRP 0LNH0#5HWHN6ROXWLRQVFRP VDPXHOVLGOHUROG#JPDLOFRP VD\UHU#JPDLOFRP</p>
    <p>&gt;UHSO\@&gt;@&gt;UHSO\@&gt;@'HVFULSWLRQ</p>
    <p>)LUVW/DVW3UHY1H[W1RVHDUFKUHVXOWVDYDLODEOH</p>
    <p>%XJ-6B*&amp;FDQGHUHIHUHQFHD18//SRLQWHULQDPXOWL WKUHDGHGDSSXVLQJ-6B&amp;OHDU&amp;RQWH[W7KUHDG</p>
    <p>,PSRUWDQFH QRUPDOYRWH 7DUJHW0LOHVWRQH  $VVLJQHG7R ,JRU%XNDQRY 4$&amp;RQWDFW JHQHUDO#VSLGHUPRQNH\EXJV</p>
    <p>'HSHQGVRQ %ORFNV MVVUF</p>
    <p>6KRZGHSHQGHQF\WUHH JUDSK</p>
    <p>&amp;&amp;/LVW $GGPHWR&amp;&amp;OLVW XVHUVHGLW</p>
    <p>)ODJV</p>
    <p>VD\UHU EORFNLQJ +</p>
    <p>ZDQWHGIHQQHF</p>
    <p>EFODU\ LQWHVWVXLWH -</p>
    <p>EFODU\ LQOLWPXV -</p>
    <p>EORFNLQJ IHQQHF</p>
    <p>EORFNLQJ</p>
    <p>VWDWXV</p>
    <p>EORFNLQJ</p>
    <p>VWDWXV</p>
    <p>EORFNLQJ</p>
    <p>VWDWXV</p>
    <p>$WWDFKPHQWV</p>
    <p>EDFNSRUWWRY.%SDWFK 3'7,JRU%XNDQRY</p>
    <p>VDPXHOVLGOHUROGDSSURYDO 'HWDLOV_'LII</p>
    <p>$GGDQDWWDFKPHQWSURSRVHGSDWFKWHVWFDVHHWF</p>
    <p>SDXOEDUQHWWD#VP[FRQ] 367</p>
    <p>User-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.5) Gecko/2009010509 Gentoo Firefox/3.0.5 Build Identifier: SpiderMonkey 1.7.0</p>
    <p>See http://groups.google.com/group/mozilla.dev.tech.jsengine/browse_thread/thread/b1bf3460297f01e3 for the initial discussion about this.</p>
    <p>I have a multi-threaded application that periodically crashes. I maintain a pool of JSContexts: as they're requested from the pool JS_SetContextThread and JS_BeginRequest are called; when they're returned JS_EndRequest and</p>
    <p>&amp;ROODSVH $OO &amp;RPPHQWV ([SDQG$OO &amp;RPPHQWV</p>
    <p>DO NOT READ!</p>
  </div>
  <div class="page">
    <p>Programmers have oQen insights/ideas about which schedules to look at</p>
    <p>[reply] [-] [reply] [-]Comment 5</p>
    <p>[reply] [-] [reply] [-]Comment 6</p>
    <p>&quot;../jsgc.cpp&quot;, ln=2682) at ../jsutil.cpp:68 #1 0x00299e26 in JS_CallTracer (trc=0xb0bace84, thing=0x39088, kind=2) at ../jsgc.cpp:2682 #2 0x00264aca in js_pinned_atom_tracer (table=0x34be4, hdr=0x80fe00, number=0, arg=0xb0bace84) at ../jsatom.cpp:551 #3 0x00274548 in JS_DHashTableEnumerate (table=0x34be4, etor=0x264a12 &lt;js_pinned_atom_tracer&gt;, arg=0xb0bace84) at ../jsdhash.cpp:742 #4 0x00264b52 in js_TraceAtomState (trc=0xb0bace84, allAtoms=0) at ../jsatom.cpp:566 #5 0x0029ba23 in js_TraceRuntime (trc=0xb0bace84, allAtoms=0) at ../jsgc.cpp:3147 #6 0x0029c259 in js_GC (cx=0x50e6c0, gckind=GC_NORMAL) at ../jsgc.cpp:3562 #7 0x00266e77 in js_DestroyContext (cx=0x50e6c0, mode=JSDCM_FORCE_GC) at ../jscntxt.cpp:541 #8 0x002506db in JS_DestroyContext (cx=0x50e6c0) at ../jsapi.cpp:1089 #9 0x00001eb2 in testfunc (ignored=0x0) at /Users/jason/dev/moz/spidermonkey-1.8/testapp.cpp:16 #10 0x9169b6f5 in _pthread_start () #11 0x9169b5b2 in thread_start ()</p>
    <p>Igor Bukanov 2009-03-09 17:47:12 PDT</p>
    <p>At least one problem that I can see from the code is that js_GC does the check:</p>
    <p>if (rt-&gt;state != JSRTS_UP &amp;&amp; gckind != GC_LAST_CONTEXT) return;</p>
    <p>outside the GC lock. Now suppose there are 3 threads, A, B, C. Threads A and B calls js_DestroyContext and thread C calls js_NewContext.</p>
    <p>First thread A removes its context from the runtime list. That context is not the last one so thread does not touch rt-&gt;state and eventually calls js_GC. The latter skips the above check and tries to to take the GC lock.</p>
    <p>Before this moment the thread B takes the lock, removes its context from the runtime list, discovers that it is the last, sets rt-&gt;state to LANDING, runs the-last-context-cleanup, runs the GC and then sets rt-&gt;state to DOWN.</p>
    <p>At this stage the thread A gets the GC lock, setup itself as the thread that runs the GC and releases the GC lock to proceed with the GC when rt-&gt;state is DOWN.</p>
    <p>Now the thread C enters the picture. It discovers under the GC lock in js_NewContext that the newly allocated context is the first one. Since rt-&gt;state is DOWN, it releases the GC lock and starts the first context initialization procedure. That procedure includes the allocation of the initial atoms and it will happen when the thread A runs the GC. This may lead precisely to the first stack trace from the comment 4.</p>
    <p>Igor Bukanov 2009-03-10 07:55:37 PDT</p>
    <p>With the test program on 64-bit Linux I could not reproduce the bug from the comment 4 but I do see assert from the comment 0 after bumping the number of threads to 1000. The assert is indeed rare, about 2-3% of all runs and I could not reproduce it under GDB. On the other hand, good old printfs have shown what was going on. The problem comes from the following code in js_NewContext:</p>
    <p>JS_LOCK_GC(rt); for (;;) { first = (rt-&gt;contextList.next == &amp;rt-&gt;contextList); if (rt-&gt;state == JSRTS_UP) { JS_ASSERT(!first);</p>
    <p>/* Ensure that it is safe to update rt-&gt;contextList below. */ js_WaitForGC(rt); break; } ... JS_WAIT_CONDVAR(rt-&gt;stateChange, JS_NO_TIMEOUT); } JS_APPEND_LINK(&amp;cx-&gt;link, &amp;rt-&gt;contextList);</p>
    <p>DO NOT READ!</p>
    <p>Fixed, known schedule for threads A and B</p>
    <p>Unknown schedule for A and C</p>
  </div>
  <div class="page">
    <p>InserEng sleeps to enforce a schedule</p>
    <p>DO NOT READ!</p>
    <p>Sleeps:  Lightweight and convenient tool for programmer  BUT: Ad hoc, not reliable for long, complex schedules.</p>
    <p>Need: Formal and robust way to describe schedules!</p>
  </div>
  <div class="page">
    <p>Build Identifier: Current tip</p>
    <p>I have a multi-threaded application that periodically crashes, giving the following assertion error:</p>
    <p>$ ./a.out Assertion failure: rt-&gt;state == JSRTS_UP || rt-&gt;state == JSRTS_LAUNCHING, at jscntxt.cpp:465</p>
    <p>I've attached a test program which demonstrates this (see below). The program spawns many threads, each of which create and then destroy a context before exiting. I'd expect the number of contexts active at any time to range between [0..THREADS], possibly transitioning between 0 and non-zero values many times and showing a race condition in the code?</p>
    <p>Reproducible: Always</p>
    <p>Steps to Reproduce: Below is a simple application that exhibits the problem 90+% of the time (for me) when run directly from the command line:</p>
    <p>#include &lt;stdlib.h&gt; #include &lt;pthread.h&gt;</p>
    <p>#include &quot;jsapi.h&quot;</p>
    <p>static JSRuntime *rt;</p>
    <p>#define THREADS 100</p>
    <p>static void * testfunc(void *ignored) {</p>
    <p>JSContext *cx = JS_NewContext(rt, 0x1000); if (cx) { JS_BeginRequest(cx); JS_DestroyContext(cx); }</p>
    <p>return NULL; }</p>
    <p>int main(void) {</p>
    <p>rt = JS_NewRuntime(0x100000); if (rt == NULL) return 1;</p>
    <p>/* Uncommenting this to guarantee there's always at least * one context in the runtime prevents this problem. */ // JSContext *cx = JS_NewContext(rt, 0x1000);</p>
    <p>int i; pthread_t thread[THREADS]; for (i = 0; i &lt; THREADS; i++) { pthread_create(&amp;thread[i], NULL, testfunc, NULL); }</p>
    <p>for (i = 0; i &lt; THREADS; i++) { pthread_join(thread[i], NULL); }</p>
    <p>return 0; }</p>
    <p>It seems to be very sensitive to timings as I have trouble reproducing the issue in gdb. For me to trigger it there I just need create/destroy more contexts per thread, but YMMV.</p>
    <p>In RADBench [Jalbert, Sen, HotPar10]</p>
    <p>Case study: A bug in SpiderMonkey (1.8rc1)</p>
    <p>Page 2 of 12file:///Users/elmas/Repository/Research/ParLab/Benchmarks/C-CPP/RCH/nick_02_23_2011.radbench/Benchmarks/bug3/docs/bug-478336.html</p>
    <p>Show Obsolete (2) View All</p>
    <p>[reply] [-] [reply] [-]Description</p>
    <p>backport to 1.9.0 (for SpiderMonkey 1.8 source release) v2 (901 bytes, patch) 2009-03-11 14:14 PDT, Jason Orendorff</p>
    <p>dveditz: approval1.9.0.11+ Details | Diff</p>
    <p>Add an attachment (proposed patch, testcase, etc.)</p>
    <p>paul.barnetta@smx.co.nz 2009-02-12 19:33:48 PST</p>
    <p>User-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.5) Gecko/2009010509 Gentoo Firefox/3.0.5 Build Identifier: Current tip</p>
    <p>I have a multi-threaded application that periodically crashes, giving the following assertion error:</p>
    <p>$ ./a.out Assertion failure: rt-&gt;state == JSRTS_UP || rt-&gt;state == JSRTS_LAUNCHING, at jscntxt.cpp:465</p>
    <p>I've attached a test program which demonstrates this (see below). The program spawns many threads, each of which create and then destroy a context before exiting. I'd expect the number of contexts active at any time to range between [0..THREADS], possibly transitioning between 0 and non-zero values many times and showing a race condition in the code?</p>
    <p>Reproducible: Always</p>
    <p>Steps to Reproduce: Below is a simple application that exhibits the problem 90+% of the time (for me) when run directly from the command line:</p>
    <p>#include &lt;stdlib.h&gt; #include &lt;pthread.h&gt;</p>
    <p>#include &quot;jsapi.h&quot;</p>
    <p>static JSRuntime *rt;</p>
    <p>#define THREADS 100</p>
    <p>static void * testfunc(void *ignored) {</p>
    <p>JSContext *cx = JS_NewContext(rt, 0x1000); if (cx) { JS_BeginRequest(cx); JS_DestroyContext(cx); }</p>
    <p>return NULL; }</p>
    <p>int main(void) {</p>
    <p>rt = JS_NewRuntime(0x100000); if (rt == NULL) return 1;</p>
    <p>/* Uncommenting this to guarantee there's always at least * one context in the runtime prevents this problem. */ // JSContext *cx = JS_NewContext(rt, 0x1000);</p>
    <p>Collapse All Comments Expand All Comments</p>
    <p>Page 2 of 12file:///Users/elmas/Repository/Research/ParLab/Benchmarks/C-CPP/RCH/nick_02_23_2011.radbench/Benchmarks/bug3/docs/bug-478336.html</p>
    <p>Show Obsolete (2) View All</p>
    <p>[reply] [-] [reply] [-]Description</p>
    <p>backport to 1.9.0 (for SpiderMonkey 1.8 source release) v2 (901 bytes, patch) 2009-03-11 14:14 PDT, Jason Orendorff</p>
    <p>dveditz: approval1.9.0.11+ Details | Diff</p>
    <p>Add an attachment (proposed patch, testcase, etc.)</p>
    <p>paul.barnetta@smx.co.nz 2009-02-12 19:33:48 PST</p>
    <p>User-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.5) Gecko/2009010509 Gentoo Firefox/3.0.5 Build Identifier: Current tip</p>
    <p>I have a multi-threaded application that periodically crashes, giving the following assertion error:</p>
    <p>$ ./a.out Assertion failure: rt-&gt;state == JSRTS_UP || rt-&gt;state == JSRTS_LAUNCHING, at jscntxt.cpp:465</p>
    <p>I've attached a test program which demonstrates this (see below). The program spawns many threads, each of which create and then destroy a context before exiting. I'd expect the number of contexts active at any time to range between [0..THREADS], possibly transitioning between 0 and non-zero values many times and showing a race condition in the code?</p>
    <p>Reproducible: Always</p>
    <p>Steps to Reproduce: Below is a simple application that exhibits the problem 90+% of the time (for me) when run directly from the command line:</p>
    <p>#include &lt;stdlib.h&gt; #include &lt;pthread.h&gt;</p>
    <p>#include &quot;jsapi.h&quot;</p>
    <p>static JSRuntime *rt;</p>
    <p>#define THREADS 100</p>
    <p>static void * testfunc(void *ignored) {</p>
    <p>JSContext *cx = JS_NewContext(rt, 0x1000); if (cx) { JS_BeginRequest(cx); JS_DestroyContext(cx); }</p>
    <p>return NULL; }</p>
    <p>int main(void) {</p>
    <p>rt = JS_NewRuntime(0x100000); if (rt == NULL) return 1;</p>
    <p>/* Uncommenting this to guarantee there's always at least * one context in the runtime prevents this problem. */ // JSContext *cx = JS_NewContext(rt, 0x1000);</p>
    <p>Collapse All Comments Expand All Comments</p>
    <p>DO NOT READ!</p>
  </div>
  <div class="page">
    <p>[reply] [-] [reply] [-]Comment 5</p>
    <p>[reply] [-] [reply] [-]Comment 6</p>
    <p>&quot;../jsgc.cpp&quot;, ln=2682) at ../jsutil.cpp:68 #1 0x00299e26 in JS_CallTracer (trc=0xb0bace84, thing=0x39088, kind=2) at ../jsgc.cpp:2682 #2 0x00264aca in js_pinned_atom_tracer (table=0x34be4, hdr=0x80fe00, number=0, arg=0xb0bace84) at ../jsatom.cpp:551 #3 0x00274548 in JS_DHashTableEnumerate (table=0x34be4, etor=0x264a12 &lt;js_pinned_atom_tracer&gt;, arg=0xb0bace84) at ../jsdhash.cpp:742 #4 0x00264b52 in js_TraceAtomState (trc=0xb0bace84, allAtoms=0) at ../jsatom.cpp:566 #5 0x0029ba23 in js_TraceRuntime (trc=0xb0bace84, allAtoms=0) at ../jsgc.cpp:3147 #6 0x0029c259 in js_GC (cx=0x50e6c0, gckind=GC_NORMAL) at ../jsgc.cpp:3562 #7 0x00266e77 in js_DestroyContext (cx=0x50e6c0, mode=JSDCM_FORCE_GC) at ../jscntxt.cpp:541 #8 0x002506db in JS_DestroyContext (cx=0x50e6c0) at ../jsapi.cpp:1089 #9 0x00001eb2 in testfunc (ignored=0x0) at /Users/jason/dev/moz/spidermonkey-1.8/testapp.cpp:16 #10 0x9169b6f5 in _pthread_start () #11 0x9169b5b2 in thread_start ()</p>
    <p>Igor Bukanov 2009-03-09 17:47:12 PDT</p>
    <p>At least one problem that I can see from the code is that js_GC does the check:</p>
    <p>if (rt-&gt;state != JSRTS_UP &amp;&amp; gckind != GC_LAST_CONTEXT) return;</p>
    <p>outside the GC lock. Now suppose there are 3 threads, A, B, C. Threads A and B calls js_DestroyContext and thread C calls js_NewContext.</p>
    <p>First thread A removes its context from the runtime list. That context is not the last one so thread does not touch rt-&gt;state and eventually calls js_GC. The latter skips the above check and tries to to take the GC lock.</p>
    <p>Before this moment the thread B takes the lock, removes its context from the runtime list, discovers that it is the last, sets rt-&gt;state to LANDING, runs the-last-context-cleanup, runs the GC and then sets rt-&gt;state to DOWN.</p>
    <p>At this stage the thread A gets the GC lock, setup itself as the thread that runs the GC and releases the GC lock to proceed with the GC when rt-&gt;state is DOWN.</p>
    <p>Now the thread C enters the picture. It discovers under the GC lock in js_NewContext that the newly allocated context is the first one. Since rt-&gt;state is DOWN, it releases the GC lock and starts the first context initialization procedure. That procedure includes the allocation of the initial atoms and it will happen when the thread A runs the GC. This may lead precisely to the first stack trace from the comment 4.</p>
    <p>Igor Bukanov 2009-03-10 07:55:37 PDT</p>
    <p>With the test program on 64-bit Linux I could not reproduce the bug from the comment 4 but I do see assert from the comment 0 after bumping the number of threads to 1000. The assert is indeed rare, about 2-3% of all runs and I could not reproduce it under GDB. On the other hand, good old printfs have shown what was going on. The problem comes from the following code in js_NewContext:</p>
    <p>JS_LOCK_GC(rt); for (;;) { first = (rt-&gt;contextList.next == &amp;rt-&gt;contextList); if (rt-&gt;state == JSRTS_UP) { JS_ASSERT(!first);</p>
    <p>/* Ensure that it is safe to update rt-&gt;contextList below. */ js_WaitForGC(rt); break; } ... JS_WAIT_CONDVAR(rt-&gt;stateChange, JS_NO_TIMEOUT); } JS_APPEND_LINK(&amp;cx-&gt;link, &amp;rt-&gt;contextList);</p>
    <p>Possible buggy schedule from bug report DO NOT READ!</p>
    <p>Fixed, known schedule for threads A and B</p>
    <p>Unknown schedule for A and C</p>
  </div>
  <div class="page">
    <p>Concurrit: A DSL for writing concurrent tests</p>
    <p>Systema&amp;cally explore</p>
    <p>all-and-only thread schedules specified by DSL</p>
    <p>+ Test in !</p>
    <p>Concurrit DSL!</p>
    <p>Specify a set of schedules in formal, concise, and convenient way</p>
    <p>[reply] [-] [reply] [-]Comment 5</p>
    <p>[reply] [-] [reply] [-]Comment 6</p>
    <p>&quot;../jsgc.cpp&quot;, ln=2682) at ../jsutil.cpp:68 #1 0x00299e26 in JS_CallTracer (trc=0xb0bace84, thing=0x39088, kind=2) at ../jsgc.cpp:2682 #2 0x00264aca in js_pinned_atom_tracer (table=0x34be4, hdr=0x80fe00, number=0, arg=0xb0bace84) at ../jsatom.cpp:551 #3 0x00274548 in JS_DHashTableEnumerate (table=0x34be4, etor=0x264a12 &lt;js_pinned_atom_tracer&gt;, arg=0xb0bace84) at ../jsdhash.cpp:742 #4 0x00264b52 in js_TraceAtomState (trc=0xb0bace84, allAtoms=0) at ../jsatom.cpp:566 #5 0x0029ba23 in js_TraceRuntime (trc=0xb0bace84, allAtoms=0) at ../jsgc.cpp:3147 #6 0x0029c259 in js_GC (cx=0x50e6c0, gckind=GC_NORMAL) at ../jsgc.cpp:3562 #7 0x00266e77 in js_DestroyContext (cx=0x50e6c0, mode=JSDCM_FORCE_GC) at ../jscntxt.cpp:541 #8 0x002506db in JS_DestroyContext (cx=0x50e6c0) at ../jsapi.cpp:1089 #9 0x00001eb2 in testfunc (ignored=0x0) at /Users/jason/dev/moz/spidermonkey-1.8/testapp.cpp:16 #10 0x9169b6f5 in _pthread_start () #11 0x9169b5b2 in thread_start ()</p>
    <p>Igor Bukanov 2009-03-09 17:47:12 PDT</p>
    <p>At least one problem that I can see from the code is that js_GC does the check:</p>
    <p>if (rt-&gt;state != JSRTS_UP &amp;&amp; gckind != GC_LAST_CONTEXT) return;</p>
    <p>outside the GC lock. Now suppose there are 3 threads, A, B, C. Threads A and B calls js_DestroyContext and thread C calls js_NewContext.</p>
    <p>First thread A removes its context from the runtime list. That context is not the last one so thread does not touch rt-&gt;state and eventually calls js_GC. The latter skips the above check and tries to to take the GC lock.</p>
    <p>Before this moment the thread B takes the lock, removes its context from the runtime list, discovers that it is the last, sets rt-&gt;state to LANDING, runs the-last-context-cleanup, runs the GC and then sets rt-&gt;state to DOWN.</p>
    <p>At this stage the thread A gets the GC lock, setup itself as the thread that runs the GC and releases the GC lock to proceed with the GC when rt-&gt;state is DOWN.</p>
    <p>Now the thread C enters the picture. It discovers under the GC lock in js_NewContext that the newly allocated context is the first one. Since rt-&gt;state is DOWN, it releases the GC lock and starts the first context initialization procedure. That procedure includes the allocation of the initial atoms and it will happen when the thread A runs the GC. This may lead precisely to the first stack trace from the comment 4.</p>
    <p>Igor Bukanov 2009-03-10 07:55:37 PDT</p>
    <p>With the test program on 64-bit Linux I could not reproduce the bug from the comment 4 but I do see assert from the comment 0 after bumping the number of threads to 1000. The assert is indeed rare, about 2-3% of all runs and I could not reproduce it under GDB. On the other hand, good old printfs have shown what was going on. The problem comes from the following code in js_NewContext:</p>
    <p>JS_LOCK_GC(rt); for (;;) { first = (rt-&gt;contextList.next == &amp;rt-&gt;contextList); if (rt-&gt;state == JSRTS_UP) { JS_ASSERT(!first);</p>
    <p>/* Ensure that it is safe to update rt-&gt;contextList below. */ js_WaitForGC(rt); break; } ... JS_WAIT_CONDVAR(rt-&gt;stateChange, JS_NO_TIMEOUT); } JS_APPEND_LINK(&amp;cx-&gt;link, &amp;rt-&gt;contextList);</p>
    <p>Page 2 of 12file:///Users/elmas/Repository/Research/ParLab/Benchmarks/C-CPP/RCH/nick_02_23_2011.radbench/Benchmarks/bug3/docs/bug-478336.html</p>
    <p>Show Obsolete (2) View All</p>
    <p>[reply] [-] [reply] [-]Description</p>
    <p>backport to 1.9.0 (for SpiderMonkey 1.8 source release) v2 (901 bytes, patch) 2009-03-11 14:14 PDT, Jason Orendorff</p>
    <p>dveditz: approval1.9.0.11+ Details | Diff</p>
    <p>Add an attachment (proposed patch, testcase, etc.)</p>
    <p>paul.barnetta@smx.co.nz 2009-02-12 19:33:48 PST</p>
    <p>User-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.5) Gecko/2009010509 Gentoo Firefox/3.0.5 Build Identifier: Current tip</p>
    <p>I have a multi-threaded application that periodically crashes, giving the following assertion error:</p>
    <p>$ ./a.out Assertion failure: rt-&gt;state == JSRTS_UP || rt-&gt;state == JSRTS_LAUNCHING, at jscntxt.cpp:465</p>
    <p>I've attached a test program which demonstrates this (see below). The program spawns many threads, each of which create and then destroy a context before exiting. I'd expect the number of contexts active at any time to range between [0..THREADS], possibly transitioning between 0 and non-zero values many times and showing a race condition in the code?</p>
    <p>Reproducible: Always</p>
    <p>Steps to Reproduce: Below is a simple application that exhibits the problem 90+% of the time (for me) when run directly from the command line:</p>
    <p>#include &lt;stdlib.h&gt; #include &lt;pthread.h&gt;</p>
    <p>#include &quot;jsapi.h&quot;</p>
    <p>static JSRuntime *rt;</p>
    <p>#define THREADS 100</p>
    <p>static void * testfunc(void *ignored) {</p>
    <p>JSContext *cx = JS_NewContext(rt, 0x1000); if (cx) { JS_BeginRequest(cx); JS_DestroyContext(cx); }</p>
    <p>return NULL; }</p>
    <p>int main(void) {</p>
    <p>rt = JS_NewRuntime(0x100000); if (rt == NULL) return 1;</p>
    <p>/* Uncommenting this to guarantee there's always at least * one context in the runtime prevents this problem. */ // JSContext *cx = JS_NewContext(rt, 0x1000);</p>
    <p>Collapse All Comments Expand All Comments</p>
    <p>Software Under Test!</p>
    <p>Insights/ideas about thread schedules</p>
  </div>
  <div class="page">
    <p>Unit-tesEng programs with Concurrit (What about integraEon tests?: Wait for conclusion)</p>
    <p>SoQware Under Test (SUT) Test in Concurrit DSL Runs concurrently with SUT</p>
    <p>! ..........! ! ..........! ! ..........! ! ..........! ! ..........! ! ..........!</p>
    <p>Thread A!</p>
    <p>Thread B! !</p>
    <p>Thread C! ! testfunc() {! JSContext *cx = JS_NewContext(rt, 0x1000);! if (cx) {! JS_BeginRequest(cx);! JS_DestroyContext(cx);! }! }! ! Unblock thread</p>
    <p>Send event and block</p>
    <p>Instrumented to control</p>
    <p>Kinds of events: Memory read/write, func&amp;on enter/return, func&amp;on call, end of thread, at par&amp;cular source line, user-defined</p>
  </div>
  <div class="page">
    <p>Unit-tesEng programs with Concurrit (What about integraEon tests?: Wait for conclusion)</p>
    <p>SoQware Under Test (SUT) Concurrit monitor Runs concurrently with SUT</p>
    <p>// Test in Concurrit DSL! ! ..........! ! ..........! ! ..........!</p>
    <p>Thread A!</p>
    <p>Kinds of events: Memory read/write, func&amp;on enter/return, func&amp;on call, end of thread, at par&amp;cular source line, user-defined</p>
    <p>Thread B! !</p>
    <p>Thread C! ! testfunc() {! JSContext *cx = JS_NewContext(rt, 0x1000);! if (cx) {! JS_BeginRequest(cx);! JS_DestroyContext(cx);! }! }! ! Unblock thread</p>
    <p>Send event and block</p>
    <p>Instrumented to control</p>
  </div>
  <div class="page">
    <p>Bug report for Mozilla SpiderMonkey  Write tests in Concurrit DSL to generate buggy schedule</p>
    <p>Simple schedules:  Few schedules BUT not manifes&amp;ng bug</p>
    <p>All schedules:  Manifests bug BUT too many schedules</p>
    <p>Target buggy schedule in bug report  Few schedules AND manifests bug</p>
    <p>Outline</p>
  </div>
  <div class="page">
    <p>[reply] [-] [reply] [-]Comment 5</p>
    <p>[reply] [-] [reply] [-]Comment 6</p>
    <p>&quot;../jsgc.cpp&quot;, ln=2682) at ../jsutil.cpp:68 #1 0x00299e26 in JS_CallTracer (trc=0xb0bace84, thing=0x39088, kind=2) at ../jsgc.cpp:2682 #2 0x00264aca in js_pinned_atom_tracer (table=0x34be4, hdr=0x80fe00, number=0, arg=0xb0bace84) at ../jsatom.cpp:551 #3 0x00274548 in JS_DHashTableEnumerate (table=0x34be4, etor=0x264a12 &lt;js_pinned_atom_tracer&gt;, arg=0xb0bace84) at ../jsdhash.cpp:742 #4 0x00264b52 in js_TraceAtomState (trc=0xb0bace84, allAtoms=0) at ../jsatom.cpp:566 #5 0x0029ba23 in js_TraceRuntime (trc=0xb0bace84, allAtoms=0) at ../jsgc.cpp:3147 #6 0x0029c259 in js_GC (cx=0x50e6c0, gckind=GC_NORMAL) at ../jsgc.cpp:3562 #7 0x00266e77 in js_DestroyContext (cx=0x50e6c0, mode=JSDCM_FORCE_GC) at ../jscntxt.cpp:541 #8 0x002506db in JS_DestroyContext (cx=0x50e6c0) at ../jsapi.cpp:1089 #9 0x00001eb2 in testfunc (ignored=0x0) at /Users/jason/dev/moz/spidermonkey-1.8/testapp.cpp:16 #10 0x9169b6f5 in _pthread_start () #11 0x9169b5b2 in thread_start ()</p>
    <p>Igor Bukanov 2009-03-09 17:47:12 PDT</p>
    <p>At least one problem that I can see from the code is that js_GC does the check:</p>
    <p>if (rt-&gt;state != JSRTS_UP &amp;&amp; gckind != GC_LAST_CONTEXT) return;</p>
    <p>outside the GC lock. Now suppose there are 3 threads, A, B, C. Threads A and B calls js_DestroyContext and thread C calls js_NewContext.</p>
    <p>First thread A removes its context from the runtime list. That context is not the last one so thread does not touch rt-&gt;state and eventually calls js_GC. The latter skips the above check and tries to to take the GC lock.</p>
    <p>Before this moment the thread B takes the lock, removes its context from the runtime list, discovers that it is the last, sets rt-&gt;state to LANDING, runs the-last-context-cleanup, runs the GC and then sets rt-&gt;state to DOWN.</p>
    <p>At this stage the thread A gets the GC lock, setup itself as the thread that runs the GC and releases the GC lock to proceed with the GC when rt-&gt;state is DOWN.</p>
    <p>Now the thread C enters the picture. It discovers under the GC lock in js_NewContext that the newly allocated context is the first one. Since rt-&gt;state is DOWN, it releases the GC lock and starts the first context initialization procedure. That procedure includes the allocation of the initial atoms and it will happen when the thread A runs the GC. This may lead precisely to the first stack trace from the comment 4.</p>
    <p>Igor Bukanov 2009-03-10 07:55:37 PDT</p>
    <p>With the test program on 64-bit Linux I could not reproduce the bug from the comment 4 but I do see assert from the comment 0 after bumping the number of threads to 1000. The assert is indeed rare, about 2-3% of all runs and I could not reproduce it under GDB. On the other hand, good old printfs have shown what was going on. The problem comes from the following code in js_NewContext:</p>
    <p>JS_LOCK_GC(rt); for (;;) { first = (rt-&gt;contextList.next == &amp;rt-&gt;contextList); if (rt-&gt;state == JSRTS_UP) { JS_ASSERT(!first);</p>
    <p>/* Ensure that it is safe to update rt-&gt;contextList below. */ js_WaitForGC(rt); break; } ... JS_WAIT_CONDVAR(rt-&gt;stateChange, JS_NO_TIMEOUT); } JS_APPEND_LINK(&amp;cx-&gt;link, &amp;rt-&gt;contextList);</p>
    <p>Possible buggy schedule from bug report</p>
  </div>
  <div class="page">
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
  </div>
  <div class="page">
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>Wait un&amp;l 3 dis&amp;nct threads sending events</p>
    <p>TA! TB! TC!</p>
  </div>
  <div class="page">
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>Loop un&amp;l all 3 threads complete</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
    <p>TA! TB! TC!</p>
  </div>
  <div class="page">
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
    <p>Pick one of the threads</p>
    <p>TA! TB! TC!</p>
    <p>Backtrack/choice point TA!</p>
  </div>
  <div class="page">
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
    <p>Run selected thread un&amp;l it completes</p>
    <p>TA! TB! TC!</p>
    <p>Backtrack/choice point</p>
    <p>Thread completes</p>
    <p>TA!</p>
  </div>
  <div class="page">
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
    <p>TA! TB! TC!</p>
    <p>Backtrack/choice point</p>
    <p>Pick one of the threads</p>
    <p>Thread completes</p>
    <p>TA!</p>
    <p>TC!</p>
  </div>
  <div class="page">
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
    <p>Run selected thread un&amp;l it completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>TA!</p>
    <p>TC!</p>
  </div>
  <div class="page">
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
    <p>TA! TB! TC!</p>
    <p>Backtrack/choice point</p>
    <p>Pick one of the threads</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>TA!</p>
    <p>TC!</p>
    <p>TB!</p>
  </div>
  <div class="page">
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
    <p>TA! TB! TC!</p>
    <p>Backtrack/choice point</p>
    <p>Run selected thread un&amp;l it completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>TA!</p>
    <p>TC!</p>
    <p>TB!</p>
  </div>
  <div class="page">
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: BACKTRACK HERE WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
    <p>TA! TB! TC!</p>
    <p>Backtrack/choice point</p>
    <p>Pick a different thread when backtracked</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>TA!</p>
    <p>TC!</p>
    <p>TB!</p>
    <p>Thread completes</p>
  </div>
  <div class="page">
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: BACKTRACK HERE WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
    <p>TA! TB! TC!</p>
    <p>Backtrack/choice point</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>TA!</p>
    <p>TC!</p>
    <p>TB!</p>
    <p>TB!</p>
    <p>Thread completes</p>
    <p>Pick a different thread when backtracked</p>
  </div>
  <div class="page">
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: BACKTRACK HERE WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
    <p>TA! TB! TC!</p>
    <p>Backtrack/choice point</p>
    <p>Run selected thread un&amp;l it completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>TA!</p>
    <p>TC!</p>
    <p>TB!</p>
    <p>Thread completes</p>
    <p>TB!</p>
    <p>Thread completes</p>
  </div>
  <div class="page">
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: BACKTRACK HERE WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
    <p>TA! TB! TC!</p>
    <p>Backtrack/choice point</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>TA!</p>
    <p>TC!</p>
    <p>TB!</p>
    <p>Thread completes</p>
    <p>TB!</p>
    <p>TC!</p>
    <p>Pick a different thread when backtracked</p>
  </div>
  <div class="page">
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: BACKTRACK HERE WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
    <p>TA! TB! TC!</p>
    <p>Backtrack/choice point</p>
    <p>Run selected thread un&amp;l it completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>TA!</p>
    <p>TC!</p>
    <p>TB!</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>TB!</p>
    <p>TC!</p>
  </div>
  <div class="page">
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: BACKTRACK HERE WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
    <p>TA! TB! TC!</p>
    <p>Backtrack/choice point</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>TA!</p>
    <p>TC!</p>
    <p>TB!</p>
    <p>Thread completes</p>
    <p>TB!</p>
    <p>TC!</p>
    <p>TA!</p>
    <p>Thread completes</p>
    <p>Pick a different thread when backtracked</p>
  </div>
  <div class="page">
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: BACKTRACK HERE WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
    <p>TA! TB! TC!</p>
    <p>Backtrack/choice point</p>
    <p>Run selected thread un&amp;l it completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>TA!</p>
    <p>TC!</p>
    <p>TB!</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>TB!</p>
    <p>TC!</p>
    <p>Thread completes</p>
    <p>TA!</p>
  </div>
  <div class="page">
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>Result: 6 schedules No asser&amp;on failure!</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>Thread completes</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: BACKTRACK HERE WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
    <p>TA! TB! TC!</p>
    <p>Backtrack/choice point</p>
    <p>Thread completes</p>
  </div>
  <div class="page">
    <p>Second test: Run each thread sequenEally unEl it returns from funcEon</p>
    <p>Result: &lt; 50 schedules No asser&amp;on failure!</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: BACKTRACK HERE WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL RETURNS FROM JS_NewContext,! JS_BeginRequest, OR JS_DestroyContext! }!</p>
    <p>TA! TB! TC!</p>
    <p>Backtrack/choice point</p>
    <p>FuncReturn FuncReturn</p>
    <p>FuncReturn</p>
    <p>FuncReturn</p>
    <p>FuncReturn</p>
    <p>FuncReturn</p>
    <p>FuncReturn ... ...</p>
    <p>FuncReturn FuncReturn</p>
    <p>FuncReturn ...</p>
    <p>...</p>
    <p>...</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>... ...</p>
  </div>
  <div class="page">
    <p>Bug report for Mozilla SpiderMonkey  Write tests in Concurrit DSL to generate buggy schedule</p>
    <p>Simple schedules  Few schedules BUT not manifes&amp;ng bug</p>
    <p>All schedules  Manifests bug BUT too many schedules</p>
    <p>Target buggy schedule in bug report  Few schedules AND manifests bug</p>
    <p>Outline</p>
  </div>
  <div class="page">
    <p>First test: Run each thread sequenEally unEl compleEon (No interleaving)</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: BACKTRACK HERE WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL COMPLETES! }!</p>
  </div>
  <div class="page">
    <p>Generate all thread schedules Result: &gt; 100,000 schedules Asser&amp;on failure ader a night!</p>
    <p>// Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: BACKTRACK HERE WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL NEXT EVENT! }!</p>
    <p>TA! TB! TC!</p>
    <p>Backtrack/choice point</p>
    <p>... ...</p>
    <p>...</p>
    <p>... ...</p>
    <p>... ... ...</p>
    <p>... ... ... ... ...</p>
  </div>
  <div class="page">
    <p>To par&amp;cular func&amp;ons, opera&amp;ons, states, ... BUT: Can express tradi&amp;onal model checking algorithms</p>
    <p>If every opera&amp;on can be controlled  Feasible for small programs, data structures, ... 39</p>
    <p>What is different from (tradiEonal) model checking?</p>
  </div>
  <div class="page">
    <p>Bug report for Mozilla SpiderMonkey  Write tests in Concurrit DSL to generate buggy schedule</p>
    <p>Simple schedules  Few schedules BUT not manifes&amp;ng bug</p>
    <p>All schedules  Manifests bug BUT too many schedules</p>
    <p>Target buggy schedule in bug report  Few schedules AND manifests bug</p>
    <p>Outline</p>
  </div>
  <div class="page">
    <p>[reply] [-] [reply] [-]Comment 5</p>
    <p>[reply] [-] [reply] [-]Comment 6</p>
    <p>&quot;../jsgc.cpp&quot;, ln=2682) at ../jsutil.cpp:68 #1 0x00299e26 in JS_CallTracer (trc=0xb0bace84, thing=0x39088, kind=2) at ../jsgc.cpp:2682 #2 0x00264aca in js_pinned_atom_tracer (table=0x34be4, hdr=0x80fe00, number=0, arg=0xb0bace84) at ../jsatom.cpp:551 #3 0x00274548 in JS_DHashTableEnumerate (table=0x34be4, etor=0x264a12 &lt;js_pinned_atom_tracer&gt;, arg=0xb0bace84) at ../jsdhash.cpp:742 #4 0x00264b52 in js_TraceAtomState (trc=0xb0bace84, allAtoms=0) at ../jsatom.cpp:566 #5 0x0029ba23 in js_TraceRuntime (trc=0xb0bace84, allAtoms=0) at ../jsgc.cpp:3147 #6 0x0029c259 in js_GC (cx=0x50e6c0, gckind=GC_NORMAL) at ../jsgc.cpp:3562 #7 0x00266e77 in js_DestroyContext (cx=0x50e6c0, mode=JSDCM_FORCE_GC) at ../jscntxt.cpp:541 #8 0x002506db in JS_DestroyContext (cx=0x50e6c0) at ../jsapi.cpp:1089 #9 0x00001eb2 in testfunc (ignored=0x0) at /Users/jason/dev/moz/spidermonkey-1.8/testapp.cpp:16 #10 0x9169b6f5 in _pthread_start () #11 0x9169b5b2 in thread_start ()</p>
    <p>Igor Bukanov 2009-03-09 17:47:12 PDT</p>
    <p>At least one problem that I can see from the code is that js_GC does the check:</p>
    <p>if (rt-&gt;state != JSRTS_UP &amp;&amp; gckind != GC_LAST_CONTEXT) return;</p>
    <p>outside the GC lock. Now suppose there are 3 threads, A, B, C. Threads A and B calls js_DestroyContext and thread C calls js_NewContext.</p>
    <p>First thread A removes its context from the runtime list. That context is not the last one so thread does not touch rt-&gt;state and eventually calls js_GC. The latter skips the above check and tries to to take the GC lock.</p>
    <p>Before this moment the thread B takes the lock, removes its context from the runtime list, discovers that it is the last, sets rt-&gt;state to LANDING, runs the-last-context-cleanup, runs the GC and then sets rt-&gt;state to DOWN.</p>
    <p>At this stage the thread A gets the GC lock, setup itself as the thread that runs the GC and releases the GC lock to proceed with the GC when rt-&gt;state is DOWN.</p>
    <p>Now the thread C enters the picture. It discovers under the GC lock in js_NewContext that the newly allocated context is the first one. Since rt-&gt;state is DOWN, it releases the GC lock and starts the first context initialization procedure. That procedure includes the allocation of the initial atoms and it will happen when the thread A runs the GC. This may lead precisely to the first stack trace from the comment 4.</p>
    <p>Igor Bukanov 2009-03-10 07:55:37 PDT</p>
    <p>With the test program on 64-bit Linux I could not reproduce the bug from the comment 4 but I do see assert from the comment 0 after bumping the number of threads to 1000. The assert is indeed rare, about 2-3% of all runs and I could not reproduce it under GDB. On the other hand, good old printfs have shown what was going on. The problem comes from the following code in js_NewContext:</p>
    <p>JS_LOCK_GC(rt); for (;;) { first = (rt-&gt;contextList.next == &amp;rt-&gt;contextList); if (rt-&gt;state == JSRTS_UP) { JS_ASSERT(!first);</p>
    <p>/* Ensure that it is safe to update rt-&gt;contextList below. */ js_WaitForGC(rt); break; } ... JS_WAIT_CONDVAR(rt-&gt;stateChange, JS_NO_TIMEOUT); } JS_APPEND_LINK(&amp;cx-&gt;link, &amp;rt-&gt;contextList);</p>
    <p>Possible buggy schedule from bug report</p>
    <p>Build Identifier: Current tip</p>
    <p>I have a multi-threaded application that periodically crashes, giving the following assertion error:</p>
    <p>$ ./a.out Assertion failure: rt-&gt;state == JSRTS_UP || rt-&gt;state == JSRTS_LAUNCHING, at jscntxt.cpp:465</p>
    <p>I've attached a test program which demonstrates this (see below). The program spawns many threads, each of which create and then destroy a context before exiting. I'd expect the number of contexts active at any time to range between [0..THREADS], possibly transitioning between 0 and non-zero values many times and showing a race condition in the code?</p>
    <p>Reproducible: Always</p>
    <p>Steps to Reproduce: Below is a simple application that exhibits the problem 90+% of the time (for me) when run directly from the command line:</p>
    <p>#include &lt;stdlib.h&gt; #include &lt;pthread.h&gt;</p>
    <p>#include &quot;jsapi.h&quot;</p>
    <p>static JSRuntime *rt;</p>
    <p>#define THREADS 100</p>
    <p>static void * testfunc(void *ignored) {</p>
    <p>JSContext *cx = JS_NewContext(rt, 0x1000); if (cx) { JS_BeginRequest(cx); JS_DestroyContext(cx); }</p>
    <p>return NULL; }</p>
    <p>int main(void) {</p>
    <p>rt = JS_NewRuntime(0x100000); if (rt == NULL) return 1;</p>
    <p>/* Uncommenting this to guarantee there's always at least * one context in the runtime prevents this problem. */ // JSContext *cx = JS_NewContext(rt, 0x1000);</p>
    <p>int i; pthread_t thread[THREADS]; for (i = 0; i &lt; THREADS; i++) { pthread_create(&amp;thread[i], NULL, testfunc, NULL); }</p>
    <p>for (i = 0; i &lt; THREADS; i++) { pthread_join(thread[i], NULL); }</p>
    <p>return 0; }</p>
    <p>It seems to be very sensitive to timings as I have trouble reproducing the issue in gdb. For me to trigger it there I just need create/destroy more contexts per thread, but YMMV.</p>
    <p>Threads A, B!</p>
    <p>Thread C!</p>
  </div>
  <div class="page">
    <p>Generate all thread schedules // Test in Concurrit DSL! ! 1: TA, TB, TC = WAIT_FOR_DISTINCT_THREADS()! ! 2: LOOP UNTIL TA, TB, TC COMPLETE {! ! 3: BACKTRACK HERE WITH T IN [TA, TB, TC]! ! 4: RUN T UNTIL NEXT EVENT! }!</p>
  </div>
  <div class="page">
    <p>ExploiEng programmers insights about bug // Test in Concurrit DSL! ! 1: TC = WAIT_FOR_THREAD(ENTERS JS_NewContext)! ! 2: TA = WAIT_FOR_DISTINCT_THREAD(ENTERS JS_DestroyContext)! ! 3: TB = WAIT_FOR_DISTINCT_THREAD(ENTERS JS_DestroyContext)! ! 4: LOOP UNTIL TA, TB, TC COMPLETE {! ! 5: BACKTRACK HERE WITH T IN [TA, TB, TC]! ! 6: RUN T UNTIL NEXT EVENT! }!</p>
    <p>Enter JS_DestroyContext</p>
    <p>Enter JS_DestroyContext</p>
    <p>... ...</p>
    <p>...</p>
    <p>... ...</p>
    <p>... ... ...</p>
    <p>... ... ... ... ...</p>
    <p>Enter JS_NewContext TC!</p>
    <p>TA!</p>
    <p>TB!</p>
    <p>Result: &lt; 50,000 schedules Asser&amp;on failure ader a few hours!</p>
  </div>
  <div class="page">
    <p>To par&amp;cular func&amp;ons, opera&amp;ons, states, ... BUT: Can express tradi&amp;onal model checking algorithms</p>
    <p>If every opera&amp;on can be controlled  Feasible for small programs, data structures, ... 44</p>
    <p>What is different from (tradiEonal) model checking?</p>
  </div>
  <div class="page">
    <p>[reply] [-] [reply] [-]Comment 5</p>
    <p>[reply] [-] [reply] [-]Comment 6</p>
    <p>&quot;../jsgc.cpp&quot;, ln=2682) at ../jsutil.cpp:68 #1 0x00299e26 in JS_CallTracer (trc=0xb0bace84, thing=0x39088, kind=2) at ../jsgc.cpp:2682 #2 0x00264aca in js_pinned_atom_tracer (table=0x34be4, hdr=0x80fe00, number=0, arg=0xb0bace84) at ../jsatom.cpp:551 #3 0x00274548 in JS_DHashTableEnumerate (table=0x34be4, etor=0x264a12 &lt;js_pinned_atom_tracer&gt;, arg=0xb0bace84) at ../jsdhash.cpp:742 #4 0x00264b52 in js_TraceAtomState (trc=0xb0bace84, allAtoms=0) at ../jsatom.cpp:566 #5 0x0029ba23 in js_TraceRuntime (trc=0xb0bace84, allAtoms=0) at ../jsgc.cpp:3147 #6 0x0029c259 in js_GC (cx=0x50e6c0, gckind=GC_NORMAL) at ../jsgc.cpp:3562 #7 0x00266e77 in js_DestroyContext (cx=0x50e6c0, mode=JSDCM_FORCE_GC) at ../jscntxt.cpp:541 #8 0x002506db in JS_DestroyContext (cx=0x50e6c0) at ../jsapi.cpp:1089 #9 0x00001eb2 in testfunc (ignored=0x0) at /Users/jason/dev/moz/spidermonkey-1.8/testapp.cpp:16 #10 0x9169b6f5 in _pthread_start () #11 0x9169b5b2 in thread_start ()</p>
    <p>Igor Bukanov 2009-03-09 17:47:12 PDT</p>
    <p>At least one problem that I can see from the code is that js_GC does the check:</p>
    <p>if (rt-&gt;state != JSRTS_UP &amp;&amp; gckind != GC_LAST_CONTEXT) return;</p>
    <p>outside the GC lock. Now suppose there are 3 threads, A, B, C. Threads A and B calls js_DestroyContext and thread C calls js_NewContext.</p>
    <p>First thread A removes its context from the runtime list. That context is not the last one so thread does not touch rt-&gt;state and eventually calls js_GC. The latter skips the above check and tries to to take the GC lock.</p>
    <p>Before this moment the thread B takes the lock, removes its context from the runtime list, discovers that it is the last, sets rt-&gt;state to LANDING, runs the-last-context-cleanup, runs the GC and then sets rt-&gt;state to DOWN.</p>
    <p>At this stage the thread A gets the GC lock, setup itself as the thread that runs the GC and releases the GC lock to proceed with the GC when rt-&gt;state is DOWN.</p>
    <p>Now the thread C enters the picture. It discovers under the GC lock in js_NewContext that the newly allocated context is the first one. Since rt-&gt;state is DOWN, it releases the GC lock and starts the first context initialization procedure. That procedure includes the allocation of the initial atoms and it will happen when the thread A runs the GC. This may lead precisely to the first stack trace from the comment 4.</p>
    <p>Igor Bukanov 2009-03-10 07:55:37 PDT</p>
    <p>With the test program on 64-bit Linux I could not reproduce the bug from the comment 4 but I do see assert from the comment 0 after bumping the number of threads to 1000. The assert is indeed rare, about 2-3% of all runs and I could not reproduce it under GDB. On the other hand, good old printfs have shown what was going on. The problem comes from the following code in js_NewContext:</p>
    <p>JS_LOCK_GC(rt); for (;;) { first = (rt-&gt;contextList.next == &amp;rt-&gt;contextList); if (rt-&gt;state == JSRTS_UP) { JS_ASSERT(!first);</p>
    <p>/* Ensure that it is safe to update rt-&gt;contextList below. */ js_WaitForGC(rt); break; } ... JS_WAIT_CONDVAR(rt-&gt;stateChange, JS_NO_TIMEOUT); } JS_APPEND_LINK(&amp;cx-&gt;link, &amp;rt-&gt;contextList);</p>
    <p>Possible buggy schedule from bug report  Shared variables involved in the bug:</p>
    <p>rt-&gt;state, rt-&gt;gcLock, rt-&gt;gcThread  Reschedule threads when accessing them.</p>
  </div>
  <div class="page">
    <p>ExploiEng programmers insights about bug // Test in Concurrit DSL! ! 1: TC = WAIT_FOR_THREAD(ENTERS JS_NewContext)! ! 2: TA = WAIT_FOR_DISTINCT_THREAD(ENTERS JS_DestroyContext)! ! 3: TB = WAIT_FOR_DISTINCT_THREAD(ENTERS JS_DestroyContext)! ! 4: LOOP UNTIL TA, TB, TC COMPLETE {! ! 5: BACKTRACK HERE WITH T IN [TA, TB, TC]! ! 6: RUN T UNTIL NEXT EVENT! }!</p>
  </div>
  <div class="page">
    <p>ExploiEng programmers insights about bug // Test in Concurrit DSL! ! 1: TC = WAIT_FOR_THREAD(ENTERS JS_NewContext)! ! 2: TA = WAIT_FOR_DISTINCT_THREAD(ENTERS JS_DestroyContext)! ! 3: TB = WAIT_FOR_DISTINCT_THREAD(ENTERS JS_DestroyContext)! ! 4: LOOP UNTIL TA, TB, TC COMPLETE {! ! 5: BACKTRACK HERE WITH T IN [TA, TB, TC]! ! 6: RUN T UNTIL READS OR WRITES &amp;rt-&gt;state, &amp;rt-&gt;gcLock, ! OR &amp;rt-&gt;gcThread! }!</p>
    <p>... ...</p>
    <p>...</p>
    <p>... ...</p>
    <p>... ... ... ... ...</p>
    <p>Read rt-&gt;state</p>
    <p>Write rt-&gt;gcThread</p>
    <p>Read rt-&gt;gcLock</p>
    <p>Read rt-&gt;gcThread</p>
    <p>Write rt-&gt;state</p>
    <p>Read rt-&gt;gcLock</p>
    <p>Write rt-&gt;state</p>
    <p>Write rt-&gt;state ...</p>
    <p>... ...</p>
    <p>Enter JS_DestroyContext</p>
    <p>Enter JS_DestroyContext</p>
    <p>Enter JS_NewContext TC!</p>
    <p>TA!</p>
    <p>TB!</p>
    <p>Result: ~ 2000 schedules Asser&amp;on failure ader 2 hours!</p>
  </div>
  <div class="page">
    <p>Possible buggy schedule from bug report [reply] [-] [reply] [-]Comment 5</p>
    <p>[reply] [-] [reply] [-]Comment 6</p>
    <p>&quot;../jsgc.cpp&quot;, ln=2682) at ../jsutil.cpp:68 #1 0x00299e26 in JS_CallTracer (trc=0xb0bace84, thing=0x39088, kind=2) at ../jsgc.cpp:2682 #2 0x00264aca in js_pinned_atom_tracer (table=0x34be4, hdr=0x80fe00, number=0, arg=0xb0bace84) at ../jsatom.cpp:551 #3 0x00274548 in JS_DHashTableEnumerate (table=0x34be4, etor=0x264a12 &lt;js_pinned_atom_tracer&gt;, arg=0xb0bace84) at ../jsdhash.cpp:742 #4 0x00264b52 in js_TraceAtomState (trc=0xb0bace84, allAtoms=0) at ../jsatom.cpp:566 #5 0x0029ba23 in js_TraceRuntime (trc=0xb0bace84, allAtoms=0) at ../jsgc.cpp:3147 #6 0x0029c259 in js_GC (cx=0x50e6c0, gckind=GC_NORMAL) at ../jsgc.cpp:3562 #7 0x00266e77 in js_DestroyContext (cx=0x50e6c0, mode=JSDCM_FORCE_GC) at ../jscntxt.cpp:541 #8 0x002506db in JS_DestroyContext (cx=0x50e6c0) at ../jsapi.cpp:1089 #9 0x00001eb2 in testfunc (ignored=0x0) at /Users/jason/dev/moz/spidermonkey-1.8/testapp.cpp:16 #10 0x9169b6f5 in _pthread_start () #11 0x9169b5b2 in thread_start ()</p>
    <p>Igor Bukanov 2009-03-09 17:47:12 PDT</p>
    <p>At least one problem that I can see from the code is that js_GC does the check:</p>
    <p>if (rt-&gt;state != JSRTS_UP &amp;&amp; gckind != GC_LAST_CONTEXT) return;</p>
    <p>outside the GC lock. Now suppose there are 3 threads, A, B, C. Threads A and B calls js_DestroyContext and thread C calls js_NewContext.</p>
    <p>First thread A removes its context from the runtime list. That context is not the last one so thread does not touch rt-&gt;state and eventually calls js_GC. The latter skips the above check and tries to to take the GC lock.</p>
    <p>Before this moment the thread B takes the lock, removes its context from the runtime list, discovers that it is the last, sets rt-&gt;state to LANDING, runs the-last-context-cleanup, runs the GC and then sets rt-&gt;state to DOWN.</p>
    <p>At this stage the thread A gets the GC lock, setup itself as the thread that runs the GC and releases the GC lock to proceed with the GC when rt-&gt;state is DOWN.</p>
    <p>Now the thread C enters the picture. It discovers under the GC lock in js_NewContext that the newly allocated context is the first one. Since rt-&gt;state is DOWN, it releases the GC lock and starts the first context initialization procedure. That procedure includes the allocation of the initial atoms and it will happen when the thread A runs the GC. This may lead precisely to the first stack trace from the comment 4.</p>
    <p>Igor Bukanov 2009-03-10 07:55:37 PDT</p>
    <p>With the test program on 64-bit Linux I could not reproduce the bug from the comment 4 but I do see assert from the comment 0 after bumping the number of threads to 1000. The assert is indeed rare, about 2-3% of all runs and I could not reproduce it under GDB. On the other hand, good old printfs have shown what was going on. The problem comes from the following code in js_NewContext:</p>
    <p>JS_LOCK_GC(rt); for (;;) { first = (rt-&gt;contextList.next == &amp;rt-&gt;contextList); if (rt-&gt;state == JSRTS_UP) { JS_ASSERT(!first);</p>
    <p>/* Ensure that it is safe to update rt-&gt;contextList below. */ js_WaitForGC(rt); break; } ... JS_WAIT_CONDVAR(rt-&gt;stateChange, JS_NO_TIMEOUT); } JS_APPEND_LINK(&amp;cx-&gt;link, &amp;rt-&gt;contextList);</p>
    <p>Fixed, known schedule for threads A and B</p>
    <p>Unknown schedule for A and C</p>
    <p>Setup</p>
  </div>
  <div class="page">
    <p>Final test // Test in Concurrit DSL! ! TC = WAIT_FOR_THREAD(! ENTERS JS_NewContext)! ! TA = WAIT_FOR_DISTINCT_THREAD(! ENTERS JS_DestroyContext)! ! TB = WAIT_FOR_DISTINCT_THREAD(! ENTERS JS_DestroyContext)! ! RUN TA UNTIL READS &amp;rt-&gt;state IN js_GC! ! RUN TB UNTIL COMPLETES! ! RUN TA UNTIL WRITES &amp;rt-&gt;gcThread IN js_GC! ! LOOP UNTIL TA, TC COMPLETE {! ! BACKTRACK HERE WITH T IN [TA, TC]! ! RUN T UNTIL READS OR WRITES MEMORY! }!</p>
    <p>[reply] [-] [reply] [-]Comment 5</p>
    <p>[reply] [-] [reply] [-]Comment 6</p>
    <p>&quot;../jsgc.cpp&quot;, ln=2682) at ../jsutil.cpp:68 #1 0x00299e26 in JS_CallTracer (trc=0xb0bace84, thing=0x39088, kind=2) at ../jsgc.cpp:2682 #2 0x00264aca in js_pinned_atom_tracer (table=0x34be4, hdr=0x80fe00, number=0, arg=0xb0bace84) at ../jsatom.cpp:551 #3 0x00274548 in JS_DHashTableEnumerate (table=0x34be4, etor=0x264a12 &lt;js_pinned_atom_tracer&gt;, arg=0xb0bace84) at ../jsdhash.cpp:742 #4 0x00264b52 in js_TraceAtomState (trc=0xb0bace84, allAtoms=0) at ../jsatom.cpp:566 #5 0x0029ba23 in js_TraceRuntime (trc=0xb0bace84, allAtoms=0) at ../jsgc.cpp:3147 #6 0x0029c259 in js_GC (cx=0x50e6c0, gckind=GC_NORMAL) at ../jsgc.cpp:3562 #7 0x00266e77 in js_DestroyContext (cx=0x50e6c0, mode=JSDCM_FORCE_GC) at ../jscntxt.cpp:541 #8 0x002506db in JS_DestroyContext (cx=0x50e6c0) at ../jsapi.cpp:1089 #9 0x00001eb2 in testfunc (ignored=0x0) at /Users/jason/dev/moz/spidermonkey-1.8/testapp.cpp:16 #10 0x9169b6f5 in _pthread_start () #11 0x9169b5b2 in thread_start ()</p>
    <p>Igor Bukanov 2009-03-09 17:47:12 PDT</p>
    <p>At least one problem that I can see from the code is that js_GC does the check:</p>
    <p>if (rt-&gt;state != JSRTS_UP &amp;&amp; gckind != GC_LAST_CONTEXT) return;</p>
    <p>outside the GC lock. Now suppose there are 3 threads, A, B, C. Threads A and B calls js_DestroyContext and thread C calls js_NewContext.</p>
    <p>First thread A removes its context from the runtime list. That context is not the last one so thread does not touch rt-&gt;state and eventually calls js_GC. The latter skips the above check and tries to to take the GC lock.</p>
    <p>Before this moment the thread B takes the lock, removes its context from the runtime list, discovers that it is the last, sets rt-&gt;state to LANDING, runs the-last-context-cleanup, runs the GC and then sets rt-&gt;state to DOWN.</p>
    <p>At this stage the thread A gets the GC lock, setup itself as the thread that runs the GC and releases the GC lock to proceed with the GC when rt-&gt;state is DOWN.</p>
    <p>Now the thread C enters the picture. It discovers under the GC lock in js_NewContext that the newly allocated context is the first one. Since rt-&gt;state is DOWN, it releases the GC lock and starts the first context initialization procedure. That procedure includes the allocation of the initial atoms and it will happen when the thread A runs the GC. This may lead precisely to the first stack trace from the comment 4.</p>
    <p>Igor Bukanov 2009-03-10 07:55:37 PDT</p>
    <p>With the test program on 64-bit Linux I could not reproduce the bug from the comment 4 but I do see assert from the comment 0 after bumping the number of threads to 1000. The assert is indeed rare, about 2-3% of all runs and I could not reproduce it under GDB. On the other hand, good old printfs have shown what was going on. The problem comes from the following code in js_NewContext:</p>
    <p>JS_LOCK_GC(rt); for (;;) { first = (rt-&gt;contextList.next == &amp;rt-&gt;contextList); if (rt-&gt;state == JSRTS_UP) { JS_ASSERT(!first);</p>
    <p>/* Ensure that it is safe to update rt-&gt;contextList below. */ js_WaitForGC(rt); break; } ... JS_WAIT_CONDVAR(rt-&gt;stateChange, JS_NO_TIMEOUT); } JS_APPEND_LINK(&amp;cx-&gt;link, &amp;rt-&gt;contextList);</p>
    <p>Fixed, known schedule for threads A and B</p>
    <p>Unknown schedule for A and C</p>
    <p>Setup</p>
  </div>
  <div class="page">
    <p>Final test</p>
    <p>Triggers asser&amp;on failure in &lt; 30 thread schedules +</p>
    <p>[reply] [-] [reply] [-]Comment 5</p>
    <p>[reply] [-] [reply] [-]Comment 6</p>
    <p>&quot;../jsgc.cpp&quot;, ln=2682) at ../jsutil.cpp:68 #1 0x00299e26 in JS_CallTracer (trc=0xb0bace84, thing=0x39088, kind=2) at ../jsgc.cpp:2682 #2 0x00264aca in js_pinned_atom_tracer (table=0x34be4, hdr=0x80fe00, number=0, arg=0xb0bace84) at ../jsatom.cpp:551 #3 0x00274548 in JS_DHashTableEnumerate (table=0x34be4, etor=0x264a12 &lt;js_pinned_atom_tracer&gt;, arg=0xb0bace84) at ../jsdhash.cpp:742 #4 0x00264b52 in js_TraceAtomState (trc=0xb0bace84, allAtoms=0) at ../jsatom.cpp:566 #5 0x0029ba23 in js_TraceRuntime (trc=0xb0bace84, allAtoms=0) at ../jsgc.cpp:3147 #6 0x0029c259 in js_GC (cx=0x50e6c0, gckind=GC_NORMAL) at ../jsgc.cpp:3562 #7 0x00266e77 in js_DestroyContext (cx=0x50e6c0, mode=JSDCM_FORCE_GC) at ../jscntxt.cpp:541 #8 0x002506db in JS_DestroyContext (cx=0x50e6c0) at ../jsapi.cpp:1089 #9 0x00001eb2 in testfunc (ignored=0x0) at /Users/jason/dev/moz/spidermonkey-1.8/testapp.cpp:16 #10 0x9169b6f5 in _pthread_start () #11 0x9169b5b2 in thread_start ()</p>
    <p>Igor Bukanov 2009-03-09 17:47:12 PDT</p>
    <p>At least one problem that I can see from the code is that js_GC does the check:</p>
    <p>if (rt-&gt;state != JSRTS_UP &amp;&amp; gckind != GC_LAST_CONTEXT) return;</p>
    <p>outside the GC lock. Now suppose there are 3 threads, A, B, C. Threads A and B calls js_DestroyContext and thread C calls js_NewContext.</p>
    <p>First thread A removes its context from the runtime list. That context is not the last one so thread does not touch rt-&gt;state and eventually calls js_GC. The latter skips the above check and tries to to take the GC lock.</p>
    <p>Before this moment the thread B takes the lock, removes its context from the runtime list, discovers that it is the last, sets rt-&gt;state to LANDING, runs the-last-context-cleanup, runs the GC and then sets rt-&gt;state to DOWN.</p>
    <p>At this stage the thread A gets the GC lock, setup itself as the thread that runs the GC and releases the GC lock to proceed with the GC when rt-&gt;state is DOWN.</p>
    <p>Now the thread C enters the picture. It discovers under the GC lock in js_NewContext that the newly allocated context is the first one. Since rt-&gt;state is DOWN, it releases the GC lock and starts the first context initialization procedure. That procedure includes the allocation of the initial atoms and it will happen when the thread A runs the GC. This may lead precisely to the first stack trace from the comment 4.</p>
    <p>Igor Bukanov 2009-03-10 07:55:37 PDT</p>
    <p>With the test program on 64-bit Linux I could not reproduce the bug from the comment 4 but I do see assert from the comment 0 after bumping the number of threads to 1000. The assert is indeed rare, about 2-3% of all runs and I could not reproduce it under GDB. On the other hand, good old printfs have shown what was going on. The problem comes from the following code in js_NewContext:</p>
    <p>JS_LOCK_GC(rt); for (;;) { first = (rt-&gt;contextList.next == &amp;rt-&gt;contextList); if (rt-&gt;state == JSRTS_UP) { JS_ASSERT(!first);</p>
    <p>/* Ensure that it is safe to update rt-&gt;contextList below. */ js_WaitForGC(rt); break; } ... JS_WAIT_CONDVAR(rt-&gt;stateChange, JS_NO_TIMEOUT); } JS_APPEND_LINK(&amp;cx-&gt;link, &amp;rt-&gt;contextList);</p>
    <p>// Test in Concurrit DSL! ! TC = WAIT_FOR_THREAD(! ENTERS JS_NewContext)! ! TA = WAIT_FOR_DISTINCT_THREAD(! ENTERS JS_DestroyContext)! ! TB = WAIT_FOR_DISTINCT_THREAD(! ENTERS JS_DestroyContext)! ! RUN TA UNTIL READS &amp;rt-&gt;state IN js_GC! ! RUN TB UNTIL COMPLETES! ! RUN TA UNTIL WRITES &amp;rt-&gt;gcThread IN js_GC! ! LOOP UNTIL TA, TC COMPLETE {! ! BACKTRACK HERE WITH T IN [TA, TC]! ! RUN T UNTIL READS OR WRITES MEMORY! }!</p>
    <p>Software Under Test! ......! ......!</p>
    <p>(Add to regression test suit)</p>
  </div>
  <div class="page">
    <p>ImplementaEon: DSL embedded in C++  Prototype: h+p://code.google.com/p/concurrit/</p>
    <p>Wrote concise tests for (real/manually-inserted) bugs in well-known benchmarks  Reproducing bugs</p>
    <p>using &lt; 20 lines of DSL code, ader &lt; 30 schedules  Inspect: bbuf, bzip2, pbzip2, pfscan  PARSEC: dedup, streamcluster  RADBench: SpiderMonkey 1/2, Mozilla NSPR 1/2/3</p>
    <p>Ongoing: Apache hgpd, Chromium, Memcached  Can write various model checking algorithms (next slide)</p>
    <p>ImplementaEon/EvaluaEon</p>
  </div>
  <div class="page">
    <p>Default search policies</p>
    <p>EXPLORE_THREADS_UNTIL_COMPLETION(THREADS) {! LOOP UNTIL ALL THREADS COMPLETE {! BACKTRACK HERE WITH T IN THREADS! RUN T UNTIL COMPLETION! }! }</p>
    <p>EXPLORE_ALL_SCHEDULES(THREADS) {! LOOP UNTIL ALL THREADS COMPLETE {! BACKTRACK HERE WITH T IN THREADS! RUN T UNTIL NEXT EVENT! }! }</p>
    <p>EXPLORE_TWO_CONTEXT_BOUNDED_SCHEDULES(THREADS) {! BACKTRACK HERE WITH T1 IN THREADS! BACKTRACK HERE LOOP NONDETERMINISTICALLY {! RUN T1 UNTIL NEXT EVENT! }! ! BACKTRACK HERE WITH T2 IN [THREADS EXCEPT T1]! BACKTRACK HERE LOOP NONDETERMINISTICALLY {! RUN T2 UNTIL NEXT EVENT! }! ! EXPLORE_THREADS_UNTIL_COMPLETION(THREADS)! }</p>
  </div>
  <div class="page">
    <p>PosiEoning Concurrit: Usage scenarios</p>
    <p>Insert sleeps: Explore one schedule</p>
    <p>Model checking: Explore all schedules</p>
    <p>Concurrit</p>
    <p>Control user-defined events  Portable, tes&amp;ng library  Manual instrumenta&amp;on  Generate exact/perfect schedule</p>
    <p>Control all operaEons  Exhaus&amp;ve tes&amp;ng tool  Automated instrumenta&amp;on</p>
    <p>Generate all schedules</p>
  </div>
  <div class="page">
    <p>Unit-tesEng programs with Concurrit</p>
    <p>SoQware Under Test (SUT) Test in Concurrit DSL Runs concurrently with SUT</p>
    <p>! ..........! ! ..........! ! ..........! ! ..........! ! ..........! ! ..........!</p>
    <p>Thread A!</p>
    <p>Thread B! !</p>
    <p>Thread C! ! testfunc() {! JSContext *cx = JS_NewContext(rt, 0x1000);! if (cx) {! JS_BeginRequest(cx);! JS_DestroyContext(cx);! }! }! ! Unblock thread</p>
    <p>Send event and block</p>
    <p>Instrumented to control</p>
  </div>
  <div class="page">
    <p>Ongoing work: IntegraEon tesEng Controlling mulE-process/distributed applicaEons</p>
    <p>Concurrit monitor process // Test in Concurrit DSL! ! ..........! !</p>
    <p>Apache web server // Server threads! // handling requests! ! ..........! !</p>
    <p>Request process 1 // Threads sending ! // requests to server! ! ..........! !</p>
    <p>Request process 2 // Threads sending ! // requests to server! ! ..........! !</p>
    <p>Events</p>
    <p>Events</p>
    <p>Events</p>
  </div>
  <div class="page">
    <p>Approaches to controlling thread schedules Test run: A set of execu&amp;ons of the test driver. Success: At least one execu&amp;on in the run hits the bug.</p>
    <p>% Rate of success (Robustness)</p>
    <p>Exhaust. model check</p>
    <p>Run 1000X &amp;mes</p>
    <p>(no control)</p>
    <p>Run once Ideal Test</p>
    <p>Run 100X &amp;mes with manual control (sleeps)</p>
    <p>N um</p>
    <p>be r of e xe cu &amp;o</p>
    <p>ns in e ac h te st r un</p>
    <p>Our target Explore &lt; 1000 execs.</p>
    <p>and robust</p>
  </div>
</Presentation>
