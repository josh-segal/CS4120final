<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Ahmed El-Hassany Petar Tsankov Laurent Vanbever Martin Vechev</p>
    <p>NetComplete: Practical Network-Wide</p>
    <p>Configuration Synthesis with Autocompletion</p>
  </div>
  <div class="page">
    <p>Ahmed El-Hassany</p>
    <p>I shouldnt be the one giving this talk</p>
    <p>Third year PhD student @ETH Zrich</p>
    <p>Papers at NSDI, SIGCOMM, PLDI, CAV, SOSR,</p>
    <p>Check him out at hassany.ps</p>
  </div>
  <div class="page">
    <p>Ahmed El-Hassany Petar Tsankov Laurent Vanbever Martin Vechev</p>
    <p>NetComplete: Practical Network-Wide</p>
    <p>Configuration Synthesis with Autocompletion</p>
  </div>
  <div class="page"/>
  <div class="page"/>
  <div class="page"/>
  <div class="page">
    <p>Yes. The Internet seems to be better off during week-ends</p>
  </div>
  <div class="page">
    <p>Yes. The Internet seems to be better off during week-ends</p>
  </div>
  <div class="page">
    <p>Human factors are responsible</p>
    <p>for 50% to 80% of network outages</p>
    <p>Juniper Networks, Whats Behind Network Downtime?, 2008</p>
  </div>
  <div class="page">
    <p>https://www.theregister.co.uk/2017/08/27/google_routing_blunder_sent_japans_internet_dark/</p>
  </div>
  <div class="page">
    <p>Someone in Google fat-thumbed a</p>
    <p>Border Gateway Protocol (BGP) advertisement</p>
    <p>and sent Japanese Internet traffic into a black hole.</p>
    <p>In August 2017</p>
  </div>
  <div class="page">
    <p>Someone in Google fat-thumbed a</p>
    <p>Border Gateway Protocol (BGP) advertisement</p>
    <p>and sent Japanese Internet traffic into a black hole.</p>
    <p>Traffic from Japanese giants like NTT and KDDI was sent to Google on the expectation</p>
    <p>it would be treated as transit.</p>
    <p>[]</p>
    <p>In August 2017</p>
  </div>
  <div class="page">
    <p>Someone in Google fat-thumbed a</p>
    <p>Border Gateway Protocol (BGP) advertisement</p>
    <p>and sent Japanese Internet traffic into a black hole.</p>
    <p>The outage in Japan only lasted a couple of hours</p>
    <p>but was so severe that [] the country's</p>
    <p>Internal Affairs and Communications ministries</p>
    <p>want carriers to report on what went wrong.</p>
    <p>[] Traffic from Japanese giants like NTT and KDDI was sent to Google on the expectation</p>
    <p>it would be treated as transit.</p>
    <p>In August 2017</p>
  </div>
  <div class="page">
    <p>Configuration synthesis addresses this problem by deriving low-level configurations from high-level requirements</p>
  </div>
  <div class="page">
    <p>! ip multicast-routing ! interface Loopback0 ip address 120.1.7.7 255.255.255.255 ip ospf 1 area 0 ! ! interface Ethernet0/0 no ip address ! interface Ethernet0/0.17 encapsulation dot1Q 17 ip address 125.1.17.7 255.255.255.0 ip pim bsr-border ip pim sparse-mode ! !</p>
    <p>! ip multicast-routing ! interface Loopback0 ip address 120.1.7.7 255.255.255.255 ip ospf 1 area 0 ! ! interface Ethernet0/0 no ip address ! interface Ethernet0/0.17 encapsulation dot1Q 17 ip address 125.1.17.7 255.255.255.0 ip pim bsr-border ip pim sparse-mode</p>
    <p>router ospf 1 router-id 120.1.7.7 redistribute bgp 700 subnets</p>
    <p>Network model</p>
    <p>Physical topology</p>
    <p>High-level requirements</p>
    <p>! ! ! ! router ospf 1 router-id 120.1.7.7 redistribute bgp 700 subnets ! router bgp 700 neighbor 125.1.17.1 remote-as 100 ! address-family ipv4 redistribute ospf 1 match internal external 1 external 2 neighbor 125.1.17.1 activate ! address-family ipv4 multicast network 125.1.79.0 mask 255.255.255.0 redistribute ospf 1 match internal external 1 external 2 neighbor 125.1.17.1 activate !</p>
    <p>Inputs Outputs</p>
    <p>Synthesizer</p>
    <p>Configuration synthesis addresses this problem by deriving low-level configurations from high-level requirements</p>
    <p>given by the operator</p>
  </div>
  <div class="page">
    <p>Configuration synthesis:</p>
    <p>a booming research area!</p>
    <p>Propane [SIGCOMM16]</p>
    <p>PropaneAT [PLDI17]</p>
    <p>SyNET [CAV17]</p>
    <p>Genesis [POPL17] forwarding rules</p>
    <p>BGP configurations</p>
    <p>OSPF + BGP configurations</p>
    <p>Out of high-level requirements,</p>
    <p>automatically derive</p>
    <p>Zeppelin [SIGMETRICS18]</p>
  </div>
  <div class="page">
    <p>Synthesizing configuration is great, but comes with</p>
    <p>challenges preventing a wide adoption</p>
  </div>
  <div class="page">
    <p>Existing synthesizers</p>
  </div>
  <div class="page">
    <p>Problem #1 interpretability</p>
    <p>can produce configurations that widely differ from humanly-generated ones</p>
    <p>Existing synthesizers</p>
  </div>
  <div class="page">
    <p>Problem #1 interpretability</p>
    <p>can produce configurations that widely differ from humanly-generated ones</p>
    <p>Problem #2</p>
    <p>continuity</p>
    <p>can produce widely different configurations given slightly different requirements</p>
    <p>Existing synthesizers</p>
  </div>
  <div class="page">
    <p>Problem #1 interpretability</p>
    <p>can produce configurations that widely differ from humanly-generated ones</p>
    <p>Problem #2</p>
    <p>continuity</p>
    <p>can produce widely different configurations given slightly different requirements</p>
    <p>Problem #3</p>
    <p>deployability</p>
    <p>cannot flexibly adapt to operational requirements,</p>
    <p>requiring configuration heterogeneity</p>
    <p>Existing synthesizers</p>
  </div>
  <div class="page">
    <p>A key issue is that synthesizers do not provide operators</p>
    <p>with a fine-grained control over the synthesized configurations</p>
  </div>
  <div class="page">
    <p>Introducing</p>
    <p>NetComplete</p>
  </div>
  <div class="page">
    <p>A configuration with holes</p>
    <p>NetComplete allows network operators to flexibly express</p>
    <p>their intents through configuration sketches</p>
  </div>
  <div class="page">
    <p>route-map imp-p1 permit 10 ?</p>
    <p>route-map exp-p1 ? 10 match community C2 route-map exp-p2 ? 20 match community C1 ...</p>
    <p>interface TenGigabitEthernet1/1/1 ip address ? ? ip ospf cost 10 &lt; ? &lt; 100</p>
    <p>router ospf 100 ? ...</p>
    <p>router bgp 6500 ...</p>
    <p>neighbor AS200 import route-map imp-p1 neighbor AS200 export route-map exp-p1 ...</p>
    <p>ip community-list C1 permit ? ip community-list C2 permit ?</p>
  </div>
  <div class="page">
    <p>interface TenGigabitEthernet1/1/1 ip address ? ? ip ospf cost 10 &lt; ? &lt; 100</p>
    <p>router ospf 100 ? ...</p>
    <p>router bgp 6500 ...</p>
    <p>neighbor AS200 import route-map imp-p1 neighbor AS200 export route-map exp-p1 ...</p>
    <p>ip community-list C1 permit ? ip community-list C2 permit ?</p>
    <p>Holes can identify</p>
    <p>specific attributes such as:</p>
    <p>IP addresses</p>
    <p>link costs</p>
    <p>BGP local preferences</p>
  </div>
  <div class="page">
    <p>interface TenGigabitEthernet1/1/1 ip address ? ? ip ospf cost 10 &lt; ? &lt; 100</p>
    <p>router ospf 100 ? ...</p>
    <p>router bgp 6500 ...</p>
    <p>neighbor AS200 import route-map imp-p1 neighbor AS200 export route-map exp-p1 ...</p>
    <p>ip community-list C1 permit ? ip community-list C2 permit ?</p>
    <p>Holes can also identify</p>
    <p>entire pieces of the configuration</p>
    <p>route-map imp-p1 permit 10 ?</p>
    <p>route-map exp-p1 ? 10 match community C2 route-map exp-p2 ? 20 match community C1 ...</p>
  </div>
  <div class="page">
    <p>NetComplete autocompletes the holes such that</p>
    <p>the output configuration complies with the requirements</p>
  </div>
  <div class="page">
    <p>route-map imp-p1 permit 10 ?</p>
    <p>route-map exp-p1 ? 10 match community C2 route-map exp-p2 ? 20 match community C1 ...</p>
    <p>interface TenGigabitEthernet1/1/1 ip address ? ? ip ospf cost 10 &lt; ? &lt; 100</p>
    <p>router ospf 100 ? ...</p>
    <p>router bgp 6500 ...</p>
    <p>neighbor AS200 import route-map imp-p1 neighbor AS200 export route-map exp-p1 ...</p>
    <p>ip community-list C1 permit ? ip community-list C2 permit ?</p>
  </div>
  <div class="page">
    <p>route-map imp-p1 permit 10 set community 6500:1 set local-pref 50 route-map exp-p1 permit 10 match community C2 route-map exp-p2 deny 20 match community C1 ...</p>
    <p>interface TenGigabitEthernet1/1/1 ip address 10.0.0.1 255.255.255.254 ip ospf cost 15</p>
    <p>router ospf 100 network 10.0.0.1 0.0.0.1 area 0.0.0.0</p>
    <p>router bgp 6500 ...</p>
    <p>neighbor AS200 import route-map imp-p1 neighbor AS200 export route-map exp-p1 ...</p>
    <p>ip community-list C1 permit 6500:1 ip community-list C2 permit 6500:2</p>
  </div>
  <div class="page">
    <p>NetComplete reduces the autocompletion problem</p>
    <p>to a constraint satisfaction problem</p>
  </div>
  <div class="page">
    <p>Encode the as a logical formula (in SMT)</p>
    <p>protocol semantics</p>
    <p>high-level requirements</p>
    <p>partial configurations</p>
    <p>First</p>
  </div>
  <div class="page">
    <p>Use a solver (Z3) to find an assignment for the undefined</p>
    <p>configuration variables s.t. the formula evaluates to True</p>
    <p>Then</p>
    <p>Encode the as a logical formula (in SMT)</p>
    <p>protocol semantics</p>
    <p>high-level requirements</p>
    <p>partial configurations</p>
    <p>First</p>
  </div>
  <div class="page">
    <p>Main challenge:</p>
    <p>Scalability</p>
    <p>network-specific</p>
    <p>heuristics</p>
    <p>Insight #1 Insight #2</p>
    <p>partial evaluation</p>
    <p>search space navigation search space reduction</p>
  </div>
  <div class="page">
    <p>optimized encoding BGP synthesis1</p>
    <p>OSPF synthesis counter-examples-based</p>
    <p>Evaluation flexible, yet scalable</p>
    <p>NetComplete: Practical Network-Wide</p>
    <p>Configuration Synthesis with Autocompletion</p>
    <p>?</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>optimized encoding BGP synthesis1</p>
    <p>OSPF synthesis counter-examples-based</p>
    <p>Evaluation flexible, yet scalable</p>
    <p>NetComplete: Practical Network-Wide</p>
    <p>Configuration Synthesis with Autocompletion</p>
    <p>?</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>NetComplete autocompletes router-level BGP policies by</p>
    <p>encoding the desired BGP behavior as a logical formula</p>
  </div>
  <div class="page">
    <p>M  Reqs  BGPprotocol  Policies</p>
  </div>
  <div class="page">
    <p>M  Reqs  BGPprotocol  Policies</p>
    <p>how should the network forward traffic</p>
    <p>concrete, part of the input</p>
  </div>
  <div class="page">
    <p>M  Reqs  BGPprotocol  Policies</p>
    <p>R1.BGPselect(A1,A2)</p>
    <p>R1.BGPselect(A2,A3)</p>
  </div>
  <div class="page">
    <p>M  Reqs  BGPprotocol  Policies</p>
    <p>how do BGP routers select routes</p>
    <p>concrete, protocol semantic</p>
  </div>
  <div class="page">
    <p>M  Reqs  BGPprotocol  Policies</p>
    <p>BGPselect(X,Y)  (X.LocalPref &gt; Y.LocalPref)</p>
  </div>
  <div class="page">
    <p>how routes should be modified</p>
    <p>symbolic, to be found</p>
    <p>M  Reqs  BGPprotocol  Policies</p>
  </div>
  <div class="page">
    <p>M  Reqs  BGPprotocol  Policies</p>
    <p>R1.SetLocalPref(A1) = VarX</p>
    <p>R1.SetLocalPref(A2) = 200</p>
  </div>
  <div class="page">
    <p>M  Reqs  BGPprotocol  Policies</p>
    <p>R1.SetLocalPref(A1) = VarX</p>
    <p>R1.SetLocalPref(A2) = 200</p>
    <p>R1.BGPselect(A1,A2)</p>
    <p>R1.BGPselect(A2,A3)</p>
    <p>BGPselect(X,Y)  (X.LocalPref &gt; Y.LocalPref)</p>
    <p>Solving this logical formula consists in assigning</p>
    <p>each symbolic variable with a concrete value</p>
  </div>
  <div class="page">
    <p>M  Reqs  BGPprotocol  Policies</p>
    <p>R1.SetLocalPref(A1) = VarX</p>
    <p>R1.SetLocalPref(A2) = 200</p>
    <p>R1.BGPselect(A1,A2)</p>
    <p>R1.BGPselect(A2,A3)</p>
    <p>BGPselect(X,Y)  (X.LocalPref &gt; Y.LocalPref)</p>
  </div>
  <div class="page">
    <p>VarX := 250 M  Reqs  BGPprotocol  Policies</p>
    <p>R1.SetLocalPref(A1) = VarX</p>
    <p>R1.SetLocalPref(A2) = 200</p>
    <p>R1.BGPselect(A1,A2)</p>
    <p>R1.BGPselect(A2,A3)</p>
    <p>BGPselect(X,Y)  (X.LocalPref &gt; Y.LocalPref)</p>
  </div>
  <div class="page">
    <p>Naive encodings lead to complex constraints</p>
    <p>that cannot be solved in a reasonable time</p>
  </div>
  <div class="page">
    <p>Naive encodings lead to complex constraints</p>
    <p>that cannot be solved in a reasonable time</p>
    <p>M  Reqs  BGPprotocol  Policies</p>
    <p>BGP x OSPF huge search spacechallenges</p>
  </div>
  <div class="page">
    <p>Naive encodings lead to complex constraints</p>
    <p>that cannot be solved in a reasonable time</p>
    <p>M  Reqs  BGPprotocol  Policies</p>
    <p>BGP x OSPF huge search space</p>
    <p>partial evaluationiterative synthesis</p>
    <p>challenges</p>
    <p>solutions</p>
  </div>
  <div class="page">
    <p>Naive encodings lead to complex constraints</p>
    <p>that cannot be solved in a reasonable time</p>
    <p>M  Reqs  BGPprotocol  Policies</p>
    <p>BGP x OSPF huge search space</p>
    <p>partial evaluationiterative synthesis</p>
    <p>challenges</p>
    <p>solutions</p>
  </div>
  <div class="page">
    <p>NetComplete encodes reduced policies by relying</p>
    <p>on the requirements and the sketches</p>
  </div>
  <div class="page">
    <p>Capture how announcements should propagate</p>
    <p>using the requirements</p>
    <p>Step 1</p>
    <p>Output BGP propagation graph</p>
    <p>NetComplete encodes reduced policies by relying</p>
    <p>on the requirements and the sketches</p>
  </div>
  <div class="page">
    <p>Capture how announcements should propagate</p>
    <p>Combine the graph with constraints imposed by sketches</p>
    <p>using the requirements</p>
    <p>via symbolic execution</p>
    <p>Step 1</p>
    <p>Step 2</p>
    <p>Output BGP propagation graph</p>
    <p>Output partially evaluated formulas</p>
    <p>NetComplete encodes reduced policies by relying</p>
    <p>on the requirements and the sketches</p>
  </div>
  <div class="page">
    <p>NetComplete relies on the requirements to figure out</p>
    <p>where BGP announcements should (not) propagate</p>
  </div>
  <div class="page">
    <p>Requirement</p>
    <p>Only customers should be able to</p>
    <p>send traffic to Provider #2</p>
    <p>Provider 2Provider 1</p>
    <p>Provider 3</p>
    <p>Customer</p>
    <p>NetComplete relies on the requirements to figure out</p>
    <p>where BGP announcements should (not) propagate</p>
  </div>
  <div class="page">
    <p>Requirement</p>
    <p>Only customers should be able to</p>
    <p>send traffic to Provider #2</p>
    <p>Provider 2Provider 1</p>
    <p>Provider 3</p>
    <p>Customer</p>
    <p>NetComplete relies on the requirements to figure out</p>
    <p>where BGP announcements should (not) propagate</p>
  </div>
  <div class="page">
    <p>B C</p>
    <p>A D</p>
    <p>P1 P2</p>
    <p>P3</p>
    <p>Cust</p>
    <p>blocked</p>
    <p>blocked</p>
    <p>NetComplete computes one BGP propagation graph</p>
    <p>per equivalence class</p>
    <p>Provider 2Provider 1</p>
    <p>Provider 3</p>
    <p>Customer</p>
  </div>
  <div class="page">
    <p>B C</p>
    <p>A D</p>
    <p>P1 P2</p>
    <p>P3</p>
    <p>Cust</p>
    <p>Encode BGP policies as SMT formulas</p>
    <p>Result is a partially evaluated formula</p>
    <p>permitted = True local_pref = ? communities = ?</p>
    <p>Inject symbolic announcement</p>
    <p>For all ann in Announcements: ann.communities = [External, Var1] ann.local_pref = 100</p>
    <p>permitted = True local_pref = 100 communities = [External, Var1]</p>
    <p>NetComplete concretizes symbolic announcements</p>
    <p>by propagating them through the graph and sketches</p>
  </div>
  <div class="page">
    <p>optimized encoding BGP synthesis</p>
    <p>OSPF synthesis counter-examples-based</p>
    <p>Evaluation flexible, yet scalable</p>
    <p>NetComplete: Practical Network-Wide</p>
    <p>Configuration Synthesis with Autocompletion</p>
    <p>?</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>As for BGP, Netcomplete phrases the problem of finding weights</p>
    <p>as a constraint satisfaction problem</p>
  </div>
  <div class="page">
    <p>A D</p>
    <p>CB</p>
    <p>Consider this initial configuration in which</p>
    <p>the (A,C) traffic is forwarded along the direct link</p>
  </div>
  <div class="page">
    <p>For performance reasons,</p>
    <p>the operators want to enable load-balancing</p>
    <p>A D</p>
    <p>CB</p>
  </div>
  <div class="page">
    <p>What should be the weights for this to happen?</p>
    <p>A D</p>
    <p>CB</p>
  </div>
  <div class="page">
    <p>input requirements</p>
    <p>DA</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>input requirements synthesis procedure</p>
    <p>DA</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>X  Paths(A,C)\Reqs</p>
    <p>input requirements</p>
    <p>Cost(AC) = Cost(ADC) &lt; Cost(X)</p>
    <p>synthesis procedure</p>
    <p>DA</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>X  Paths(A,C)\Reqs</p>
    <p>Cost(AC) = Cost(ADC) &lt; Cost(X)</p>
    <p>Solve</p>
    <p>synthesis procedureinput requirements</p>
    <p>DA</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>X  Paths(A,C)\Reqs</p>
    <p>Cost(AC) = Cost(ADC) &lt; Cost(X)</p>
    <p>Solve</p>
    <p>synthesis procedureinput requirements</p>
    <p>DA</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>X  Paths(A,C)\Reqs</p>
    <p>input requirements</p>
    <p>Cost(AC) = Cost(ADC) &lt; Cost(X)</p>
    <p>Solve</p>
    <p>synthesis procedure</p>
    <p>Synthesized weights</p>
    <p>DA</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>This was easy, but</p>
    <p>it does not scale</p>
    <p>X  Paths(A,C)\Reqs</p>
    <p>Cost(AC) = Cost(ADC) &lt; Cost(X)</p>
    <p>Solve</p>
  </div>
  <div class="page">
    <p>Cost(AC) = Cost(ADC) &lt; Cost(X)</p>
    <p>Solve</p>
    <p>X  Paths(A,C)\Reqs</p>
    <p>There can be an exponential number of paths between A and C</p>
  </div>
  <div class="page">
    <p>An contemporary approach to synthesis where</p>
    <p>a solution is iteratively learned from counter-examples</p>
    <p>To scale, NetComplete leverages</p>
    <p>Counter-Example Guided Inductive Synthesis (CEGIS)</p>
  </div>
  <div class="page">
    <p>While enumerating all paths is hard,</p>
    <p>computing shortest paths given weights is easy!</p>
  </div>
  <div class="page">
    <p>D</p>
    <p>input requirements</p>
    <p>A</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>input requirements synthesis procedure</p>
    <p>DA</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>X  SamplePaths(A,C)\Reqs</p>
    <p>input requirements synthesis procedure</p>
    <p>DA</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>X  SamplePaths(A,C)\Reqs</p>
    <p>input requirements synthesis procedure</p>
    <p>Sample: { [A,B,D,C] }</p>
    <p>DA</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>X  SamplePaths(A,C)\Reqs</p>
    <p>input requirements</p>
    <p>Cost(AC) = Cost(ADC) &lt; Cost(X)</p>
    <p>synthesis procedure</p>
    <p>DA</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>X  SamplePaths(A,C)\Reqs</p>
    <p>Cost(AC) = Cost(ADC) &lt; Cost(X)</p>
    <p>Solve</p>
    <p>synthesis procedureinput requirements</p>
    <p>DA</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>X  SamplePaths(A,C)\Reqs</p>
    <p>Cost(AC) = Cost(ADC) &lt; Cost(X)</p>
    <p>Solve</p>
    <p>synthesis procedureinput requirements</p>
    <p>DA</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>X  SamplePaths(A,C)\Reqs</p>
    <p>input requirements</p>
    <p>Cost(AC) = Cost(ADC) &lt; Cost(X)</p>
    <p>Solve</p>
    <p>synthesis procedure</p>
    <p>Synthesized weights</p>
    <p>DA</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>X  SamplePaths(A,C)\Reqs</p>
    <p>Cost(AC) = Cost(ADC) &lt; Cost(X)</p>
    <p>Solve</p>
    <p>DA</p>
    <p>B C</p>
    <p>The synthesized weights are incorrect:</p>
    <p>cost(A  B  C]) = 250 &lt; cost(A  C) = 300</p>
    <p>actual path</p>
  </div>
  <div class="page">
    <p>X  SamplePaths(A,C)\Reqs</p>
    <p>Sample: { [A,B,D,C] } U { [A,B,C] }</p>
    <p>DA</p>
    <p>B C</p>
    <p>We simply add the counter example to SamplePaths and repeat the procedure</p>
  </div>
  <div class="page">
    <p>The entire procedure usually converges in few iterations</p>
    <p>making it very fast in practice</p>
  </div>
  <div class="page">
    <p>optimized encoding BGP synthesis</p>
    <p>OSPF synthesis counter-examples-based</p>
    <p>Evaluation flexible, yet scalable</p>
    <p>NetComplete: Practical Network-Wide</p>
    <p>Configuration Synthesis with Autocompletion</p>
    <p>?</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>Can NetComplete synthesize large-scale configurations?</p>
    <p>How does the concreteness of the sketch influence the running time?</p>
    <p>Question #1</p>
    <p>Question #2</p>
  </div>
  <div class="page">
    <p>Code ~10K lines of Python</p>
    <p>SMT-LIB v2 and Z3</p>
    <p>Input OSPF, BGP, static routes</p>
    <p>Output Cisco-compatible configurations</p>
    <p>as partial and concrete configs</p>
    <p>validated with actual Cisco routers</p>
    <p>We fully implemented NetComplete</p>
    <p>and showed its practicality</p>
  </div>
  <div class="page">
    <p>Methodology</p>
    <p>small, medium, and large</p>
    <p>Simple, Any, ECMP, and ordered (random)</p>
    <p>Built from a fully concrete configuration</p>
    <p>using OSPF/BGP</p>
    <p>from which we made a % of the variables symbolic</p>
    <p>Topology</p>
    <p>Requirement</p>
    <p>Sketch</p>
  </div>
  <div class="page">
    <p>NetComplete synthesizes configurations</p>
    <p>for large networks in few minutes</p>
  </div>
  <div class="page">
    <p>Network size</p>
    <p>Reqs.</p>
    <p>type</p>
    <p>Synthesis</p>
    <p>time</p>
    <p>OSPF synthesis time (sec)</p>
    <p>NetComplete synthesizes configurations</p>
    <p>for large networks in few minutes</p>
    <p>CEGIS enabled</p>
    <p>settings</p>
    <p>Large Simple</p>
    <p>ECMP</p>
    <p>Ordered</p>
    <p>~150 nodes</p>
  </div>
  <div class="page">
    <p>Without CEGIS, OSPF synthesis is</p>
    <p>&gt;100x slower and often timeouts</p>
  </div>
  <div class="page">
    <p>Percentage of symbolic edge costs</p>
    <p>T im</p>
    <p>e [s</p>
    <p>]</p>
    <p>% of nodes changing next-hop 0 20 60 10040</p>
    <p>% of weights left symbolic in the sketch 60</p>
    <p>OSPF synthesis time (sec)</p>
    <p>NetComplete synthesis time increases</p>
    <p>as the sketch becomes more symbolic</p>
    <p>large topos.</p>
    <p>settings</p>
  </div>
  <div class="page">
    <p>Percentage of symbolic edge costs</p>
    <p>T im</p>
    <p>e [s</p>
    <p>]</p>
    <p>% of nodes changing next-hop 0 20 60 10040 60</p>
    <p>NetComplete synthesis time increases</p>
    <p>as the sketch becomes more symbolic</p>
    <p>% of weights left symbolic in the sketch</p>
    <p>OSPF synthesis time (sec)</p>
    <p>large topos.</p>
    <p>settings</p>
  </div>
  <div class="page">
    <p>optimized encoding BGP synthesis</p>
    <p>OSPF synthesis counter-examples-based</p>
    <p>Evaluation flexible, yet scalable</p>
    <p>?</p>
    <p>?</p>
    <p>NetComplete: Practical Network-Wide</p>
    <p>Configuration Synthesis with Autocompletion</p>
  </div>
  <div class="page">
    <p>Autocompletes configurations with holes</p>
    <p>synthesizes configurations for large network in minutes</p>
    <p>Phrases the problem as constraints satisfaction</p>
    <p>Scales to realistic network size</p>
    <p>leaving the concrete parts intact</p>
    <p>scales using network-specific heuristics &amp; partial evaluation</p>
    <p>NetComplete: Practical Network-Wide</p>
    <p>Configuration Synthesis with Autocompletion</p>
  </div>
  <div class="page">
    <p>Ahmed El-Hassany Petar Tsankov Laurent Vanbever Martin Vechev</p>
    <p>NetComplete: Practical Network-Wide</p>
    <p>Configuration Synthesis with Autocompletion</p>
  </div>
</Presentation>
