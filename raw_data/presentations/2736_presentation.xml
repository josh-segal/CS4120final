<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>JPure: a Modular Purity System for Java</p>
    <p>David J. Pearce Victoria University of Wellington</p>
    <p>New Zealand</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>int sum(int[] items) {</p>
    <p>int r = 0;</p>
    <p>for(int v : items) { r += v; }</p>
    <p>return r;</p>
    <p>}</p>
    <p>Definition: A method is considered pure if it does not assign (directly of indirectly) to any field or array cell that existed before it was called.</p>
    <p>boolean isSorted(List&lt;Integer&gt; items) {</p>
    <p>int last = Integer.MIN_VALUE;</p>
    <p>for(Integer v : items) {</p>
    <p>if(last &gt; v) { return false; }</p>
    <p>last = v;</p>
    <p>}</p>
    <p>return true;</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Typical Previous Purity Systems</p>
    <p>Pointer Analysis feeds Purity Inference</p>
    <p>Pointer Analysis typically whole-program</p>
    <p>Inferred annotations cannot be checked easily  i.e. without regeneration pointer information</p>
    <p>Pointer Analysis</p>
    <p>?</p>
    <p>Java Source Annotated Source</p>
    <p>Annotated Bytecode</p>
    <p>Purity Inference</p>
  </div>
  <div class="page">
    <p>Modular Purity System</p>
    <p>Purity Inference:</p>
    <p>Generates annotations via interprocedural analysis</p>
    <p>Generated annotations are modularly checkable</p>
    <p>Purity Checker:</p>
    <p>Verifies annotations via intraprocedural analysis</p>
    <p>Integrates easily with Java Bytecode Verification</p>
    <p>Purity Inference</p>
    <p>Purity Checker</p>
    <p>Java Source Annotated Source</p>
    <p>Annotated Bytecode</p>
    <p>Java Compiler</p>
  </div>
  <div class="page">
    <p>Simple (Modular) Approach</p>
    <p>Pure Methods:</p>
    <p>Cannot contain field assignments</p>
    <p>Can only call methods marked @Pure</p>
    <p>Only pure methods can override pure methods</p>
    <p>Parent</p>
    <p>private int afield;</p>
    <p>@Pure void method() { }</p>
    <p>Child</p>
    <p>@Pure void method() { }</p>
    <p>Client</p>
    <p>@Pure void f(Parent p) {</p>
    <p>p.method();</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Simple (Modular) Approach</p>
    <p>Pure Methods:</p>
    <p>Cannot contain field assignments</p>
    <p>Can only call methods marked @Pure</p>
    <p>Only pure methods can override pure methods</p>
    <p>Parent</p>
    <p>private int afield;</p>
    <p>@Pure void method() { }</p>
    <p>Child</p>
    <p>@Pure void method() { }</p>
    <p>Client</p>
    <p>@Pure void f(Parent p) {</p>
    <p>p.method();</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Simple (Modular) Approach</p>
    <p>Pure Methods:</p>
    <p>Cannot contain field assignments</p>
    <p>Can only call methods marked @Pure</p>
    <p>Only pure methods can override pure methods</p>
    <p>Parent</p>
    <p>private int f;</p>
    <p>@Pure void method(){f=1;}</p>
    <p>Child</p>
    <p>@Pure void method() { }</p>
    <p>Client</p>
    <p>@Pure void f(Parent p) {</p>
    <p>p.method();</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Simple (Modular) Approach</p>
    <p>Pure Methods:</p>
    <p>Cannot contain field assignments</p>
    <p>Can only call methods marked @Pure</p>
    <p>Only pure methods can override pure methods</p>
    <p>Child</p>
    <p>@Pure void method() { }</p>
    <p>Client</p>
    <p>@Pure void f(Parent p) {</p>
    <p>p.method();</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Simple (Modular) Approach</p>
    <p>Pure Methods:</p>
    <p>Cannot contain field assignments</p>
    <p>Can only call methods marked @Pure</p>
    <p>Only pure methods can override pure methods</p>
    <p>Parent</p>
    <p>private int afield;</p>
    <p>@Pure void method() { }</p>
    <p>Client</p>
    <p>@Pure void f(Parent p) {</p>
    <p>p.method();</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Problems</p>
    <p>public class AbstractStringBuilder {</p>
    <p>private char[] data;</p>
    <p>private int count; // number of items used</p>
    <p>public AbstractStringBuilder append(String s) {</p>
    <p>s.getChars(0, s.length(), data, count);</p>
    <p>}}</p>
    <p>@Pure String f(String x) { return x + hello; }</p>
    <p>public class Test {</p>
    <p>private List&lt;String&gt; items;</p>
    <p>@Pure boolean has(String s) {</p>
    <p>for(String i : items) {</p>
    <p>if(s == i) { return true; }</p>
    <p>}</p>
    <p>return false;</p>
    <p>} }</p>
  </div>
  <div class="page">
    <p>Problems</p>
    <p>public class AbstractStringBuilder {</p>
    <p>private char[] data;</p>
    <p>private int count; // number of items used</p>
    <p>public AbstractStringBuilder append(String s) {</p>
    <p>s.getChars(0, s.length(), data, count);</p>
    <p>}}</p>
    <p>@Pure String f(String x) { return x + hello; }</p>
    <p>public class Test {</p>
    <p>private List&lt;String&gt; items;</p>
    <p>@Pure boolean has(String s) {</p>
    <p>for(String i : items) {</p>
    <p>if(s == i) { return true; }</p>
    <p>}</p>
    <p>return false;</p>
    <p>} }</p>
  </div>
  <div class="page">
    <p>Problems</p>
    <p>public class AbstractStringBuilder {</p>
    <p>private char[] data;</p>
    <p>private int count; // number of items used</p>
    <p>public AbstractStringBuilder append(String s) {</p>
    <p>s.getChars(0, s.length(), data, count);</p>
    <p>}}</p>
    <p>@Pure String f(String x) { return x + hello; }</p>
    <p>public class Test {</p>
    <p>private List&lt;String&gt; items;</p>
    <p>@Pure boolean has(String s) {</p>
    <p>for(String i : items) {</p>
    <p>if(s == i) { return true; }</p>
    <p>}</p>
    <p>return false;</p>
    <p>} }</p>
  </div>
  <div class="page">
    <p>Problems</p>
    <p>public class AbstractStringBuilder {</p>
    <p>private char[] data;</p>
    <p>private int count; // number of items used</p>
    <p>public AbstractStringBuilder append(String s) {</p>
    <p>s.getChars(0, s.length(), data, count);</p>
    <p>}}</p>
    <p>@Pure String f(String x) { return x + hello; }</p>
    <p>public class Test {</p>
    <p>private List&lt;String&gt; items;</p>
    <p>@Pure boolean has(String s) {</p>
    <p>for(String i : items) {</p>
    <p>if(s == i) { return true; }</p>
    <p>}</p>
    <p>return false;</p>
    <p>} }</p>
  </div>
  <div class="page">
    <p>interface Collection {</p>
    <p>@Fresh Object iterator();</p>
    <p>}</p>
    <p>interface Iterator {</p>
    <p>@Pure boolean hasNext();</p>
    <p>@Local Object next();</p>
    <p>}</p>
    <p>class Test {</p>
    <p>List&lt;String&gt; items;</p>
    <p>@Pure boolean has(String s){</p>
    <p>for(String i : items) {</p>
    <p>if(s == i) return true;</p>
    <p>}</p>
    <p>return false;</p>
    <p>} }</p>
    <p>Introducing JPure!</p>
  </div>
  <div class="page">
    <p>interface Collection {</p>
    <p>@Fresh Object iterator();</p>
    <p>}</p>
    <p>interface Iterator {</p>
    <p>@Pure boolean hasNext();</p>
    <p>@Local Object next();</p>
    <p>}</p>
    <p>class Test {</p>
    <p>List&lt;String&gt; items;</p>
    <p>@Pure boolean has(String s){</p>
    <p>for(String i : items) {</p>
    <p>if(s == i) return true;</p>
    <p>}</p>
    <p>return false;</p>
    <p>} }</p>
    <p>Introducing JPure! Indicates iterator() returns fresh object</p>
  </div>
  <div class="page">
    <p>interface Collection {</p>
    <p>@Fresh Object iterator();</p>
    <p>}</p>
    <p>interface Iterator {</p>
    <p>@Pure boolean hasNext();</p>
    <p>@Local Object next();</p>
    <p>}</p>
    <p>class Test {</p>
    <p>List&lt;String&gt; items;</p>
    <p>@Pure boolean has(String s){</p>
    <p>for(String i : items) {</p>
    <p>if(s == i) return true;</p>
    <p>}</p>
    <p>return false;</p>
    <p>} }</p>
    <p>Introducing JPure! Indicates iterator() returns fresh object</p>
    <p>Indicates next() only modifies local state</p>
  </div>
  <div class="page">
    <p>interface Collection {</p>
    <p>@Fresh Object iterator();</p>
    <p>}</p>
    <p>interface Iterator {</p>
    <p>@Pure boolean hasNext();</p>
    <p>@Local Object next();</p>
    <p>}</p>
    <p>class Test {</p>
    <p>List&lt;String&gt; items;</p>
    <p>@Pure boolean has(String s){</p>
    <p>for(String i : items) {</p>
    <p>if(s == i) return true;</p>
    <p>}</p>
    <p>return false;</p>
    <p>} }</p>
    <p>Introducing JPure! Indicates iterator() returns fresh object</p>
    <p>Indicates next() only modifies local state</p>
  </div>
  <div class="page">
    <p>interface Collection {</p>
    <p>@Fresh Object iterator();</p>
    <p>}</p>
    <p>interface Iterator {</p>
    <p>@Pure boolean hasNext();</p>
    <p>@Local Object next();</p>
    <p>}</p>
    <p>class Test {</p>
    <p>List&lt;String&gt; items;</p>
    <p>@Pure boolean has(String s){</p>
    <p>for(String i : items) {</p>
    <p>if(s == i) return true;</p>
    <p>}</p>
    <p>return false;</p>
    <p>} }</p>
    <p>Introducing JPure!</p>
    <p>@Pure boolean has(String s) {</p>
    <p>Iterator tmp;</p>
    <p>tmp = items.iterator();</p>
    <p>while(tmp.hasNext()) {</p>
    <p>i = tmp.next();</p>
    <p>if(s == i) return true;</p>
    <p>}</p>
    <p>return false;</p>
    <p>}</p>
    <p>Indicates iterator() returns fresh object</p>
    <p>Indicates next() only modifies local state</p>
  </div>
  <div class="page">
    <p>interface Collection {</p>
    <p>@Fresh Object iterator();</p>
    <p>}</p>
    <p>interface Iterator {</p>
    <p>@Pure boolean hasNext();</p>
    <p>@Local Object next();</p>
    <p>}</p>
    <p>class Test {</p>
    <p>List&lt;String&gt; items;</p>
    <p>@Pure boolean has(String s){</p>
    <p>for(String i : items) {</p>
    <p>if(s == i) return true;</p>
    <p>}</p>
    <p>return false;</p>
    <p>} }</p>
    <p>Introducing JPure!</p>
    <p>@Pure boolean has(String s) {</p>
    <p>Iterator tmp;</p>
    <p>tmp = items.iterator();</p>
    <p>while(tmp.hasNext()) {</p>
    <p>i = tmp.next();</p>
    <p>if(s == i) return true;</p>
    <p>}</p>
    <p>return false;</p>
    <p>}</p>
    <p>Indicates iterator() returns fresh object</p>
    <p>Indicates next() only modifies local state</p>
  </div>
  <div class="page">
    <p>Methods annotated @Fresh  Must return new objects  Or, values returned by methods marked @Fresh</p>
    <p>Methods annotated @Local  May update local state   But otherwise must remain pure</p>
    <p>class ArrayList implements Collection{</p>
    <p>@Fresh Object iterator() { return new Iterator(data); }</p>
    <p>static class Iterator {</p>
    <p>Object[] data; int idx = 0;</p>
    <p>@Pure boolean hasNext() { return idx &lt; data.size(); }</p>
    <p>@Local Object next() { return data[idx++]; }</p>
    <p>}}</p>
  </div>
  <div class="page">
    <p>Iterator Implementation</p>
    <p>Methods annotated @Fresh  Must return new objects  Or, values returned by methods marked @Fresh</p>
    <p>Methods annotated @Local  May update local state   But otherwise must remain pure</p>
    <p>class ArrayList implements Collection{</p>
    <p>@Fresh Object iterator() { return new Iterator(data); }</p>
    <p>static class Iterator {</p>
    <p>Object[] data; int idx = 0;</p>
    <p>@Pure boolean hasNext() { return idx &lt; data.size(); }</p>
    <p>@Local Object next() { return data[idx++]; }</p>
    <p>}}</p>
  </div>
  <div class="page">
    <p>Locality Invariant 2 (Preservation). When the locality of a fresh object is modified, its locality must remain fresh.</p>
    <p>Locality Invariant 1 (Construction). When a new object is constructed its locality is always fresh.</p>
    <p>class TList {</p>
    <p>private int length;</p>
    <p>private @Local Object[] data;</p>
    <p>private Type type;</p>
    <p>@Local public TList(Type t, int m) {</p>
    <p>length = 0;</p>
    <p>data = new Object[m];</p>
    <p>type = t;</p>
    <p>}</p>
    <p>@Local public void copy(TList dst) {</p>
    <p>length = dst.length;</p>
    <p>type = dst.type;</p>
    <p>data = new Object[dst.length];</p>
    <p>for(int i=0;i!=length;++i) { data[i] = dst.data[i]; }</p>
    <p>}}</p>
    <p>TList data</p>
    <p>length,type</p>
  </div>
  <div class="page">
    <p>Locality Invariant 2 (Preservation). When the locality of a fresh object is modified, its locality must remain fresh.</p>
    <p>Locality Invariant 1 (Construction). When a new object is constructed its locality is always fresh.</p>
    <p>class TList {</p>
    <p>private int length;</p>
    <p>private @Local Object[] data;</p>
    <p>private Type type;</p>
    <p>@Local public TList(Type t, int m) {</p>
    <p>length = 0;</p>
    <p>data = new Object[m];</p>
    <p>type = t;</p>
    <p>}</p>
    <p>@Local public void copy(TList dst) {</p>
    <p>length = dst.length;</p>
    <p>type = dst.type;</p>
    <p>data = new Object[dst.length];</p>
    <p>for(int i=0;i!=length;++i) { data[i] = dst.data[i]; }</p>
    <p>}}</p>
    <p>TList data</p>
    <p>length,type</p>
    <p>Required for Invariant 1</p>
  </div>
  <div class="page">
    <p>Locality Invariant 2 (Preservation). When the locality of a fresh object is modified, its locality must remain fresh.</p>
    <p>Locality Invariant 1 (Construction). When a new object is constructed its locality is always fresh.</p>
    <p>class TList {</p>
    <p>private int length;</p>
    <p>private @Local Object[] data;</p>
    <p>private Type type;</p>
    <p>@Local public TList(Type t, int m) {</p>
    <p>length = 0;</p>
    <p>data = new Object[m];</p>
    <p>type = t;</p>
    <p>}</p>
    <p>@Local public void copy(TList dst) {</p>
    <p>length = dst.length;</p>
    <p>type = dst.type;</p>
    <p>data = new Object[dst.length];</p>
    <p>for(int i=0;i!=length;++i) { data[i] = dst.data[i]; }</p>
    <p>}}</p>
    <p>TList data</p>
    <p>length,type</p>
    <p>Required for Invariant 1</p>
    <p>Safe under Invariant 2</p>
  </div>
  <div class="page">
    <p>Detailed Example @Local public void copy(TList dst) {</p>
    <p>var tmp = dst.length;</p>
    <p>this.length = tmp;</p>
    <p>tmp = dst.type;</p>
    <p>this.type = tmp;</p>
    <p>tmp = new Object[dst.length];</p>
    <p>this.data = tmp;</p>
    <p>for(int i=0;i!=length;++i) {</p>
    <p>tmp = dst.data[i];</p>
    <p>this.data[i] = tmp;</p>
    <p>} }</p>
    <p>LTHIS LDST ?</p>
    <p>tmpdstthis</p>
  </div>
  <div class="page">
    <p>Detailed Example @Local public void copy(TList dst) {</p>
    <p>var tmp = dst.length;</p>
    <p>this.length = tmp;</p>
    <p>tmp = dst.type;</p>
    <p>this.type = tmp;</p>
    <p>tmp = new Object[dst.length];</p>
    <p>this.data = tmp;</p>
    <p>for(int i=0;i!=length;++i) {</p>
    <p>tmp = dst.data[i];</p>
    <p>this.data[i] = tmp;</p>
    <p>} }</p>
    <p>LTHIS LDST ?</p>
    <p>tmpdstthis</p>
    <p>LTHIS LDST</p>
  </div>
  <div class="page">
    <p>Detailed Example @Local public void copy(TList dst) {</p>
    <p>var tmp = dst.length;</p>
    <p>this.length = tmp;</p>
    <p>tmp = dst.type;</p>
    <p>this.type = tmp;</p>
    <p>tmp = new Object[dst.length];</p>
    <p>this.data = tmp;</p>
    <p>for(int i=0;i!=length;++i) {</p>
    <p>tmp = dst.data[i];</p>
    <p>this.data[i] = tmp;</p>
    <p>} }</p>
    <p>LTHIS LDST ?</p>
    <p>tmpdstthis</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
  </div>
  <div class="page">
    <p>Detailed Example @Local public void copy(TList dst) {</p>
    <p>var tmp = dst.length;</p>
    <p>this.length = tmp;</p>
    <p>tmp = dst.type;</p>
    <p>this.type = tmp;</p>
    <p>tmp = new Object[dst.length];</p>
    <p>this.data = tmp;</p>
    <p>for(int i=0;i!=length;++i) {</p>
    <p>tmp = dst.data[i];</p>
    <p>this.data[i] = tmp;</p>
    <p>} }</p>
    <p>LTHIS LDST ?</p>
    <p>tmpdstthis</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST ?</p>
  </div>
  <div class="page">
    <p>Detailed Example @Local public void copy(TList dst) {</p>
    <p>var tmp = dst.length;</p>
    <p>this.length = tmp;</p>
    <p>tmp = dst.type;</p>
    <p>this.type = tmp;</p>
    <p>tmp = new Object[dst.length];</p>
    <p>this.data = tmp;</p>
    <p>for(int i=0;i!=length;++i) {</p>
    <p>tmp = dst.data[i];</p>
    <p>this.data[i] = tmp;</p>
    <p>} }</p>
    <p>LTHIS LDST ?</p>
    <p>tmpdstthis</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST ?</p>
    <p>LTHIS LDST ?</p>
  </div>
  <div class="page">
    <p>Detailed Example @Local public void copy(TList dst) {</p>
    <p>var tmp = dst.length;</p>
    <p>this.length = tmp;</p>
    <p>tmp = dst.type;</p>
    <p>this.type = tmp;</p>
    <p>tmp = new Object[dst.length];</p>
    <p>this.data = tmp;</p>
    <p>for(int i=0;i!=length;++i) {</p>
    <p>tmp = dst.data[i];</p>
    <p>this.data[i] = tmp;</p>
    <p>} }</p>
    <p>LTHIS LDST ?</p>
    <p>tmpdstthis</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST ?</p>
    <p>LTHIS LDST ?</p>
    <p>LTHIS LDST</p>
  </div>
  <div class="page">
    <p>Detailed Example @Local public void copy(TList dst) {</p>
    <p>var tmp = dst.length;</p>
    <p>this.length = tmp;</p>
    <p>tmp = dst.type;</p>
    <p>this.type = tmp;</p>
    <p>tmp = new Object[dst.length];</p>
    <p>this.data = tmp;</p>
    <p>for(int i=0;i!=length;++i) {</p>
    <p>tmp = dst.data[i];</p>
    <p>this.data[i] = tmp;</p>
    <p>} }</p>
    <p>LTHIS LDST ?</p>
    <p>tmpdstthis</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST ?</p>
    <p>LTHIS LDST ?</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
  </div>
  <div class="page">
    <p>Detailed Example @Local public void copy(TList dst) {</p>
    <p>var tmp = dst.length;</p>
    <p>this.length = tmp;</p>
    <p>tmp = dst.type;</p>
    <p>this.type = tmp;</p>
    <p>tmp = new Object[dst.length];</p>
    <p>this.data = tmp;</p>
    <p>for(int i=0;i!=length;++i) {</p>
    <p>tmp = dst.data[i];</p>
    <p>this.data[i] = tmp;</p>
    <p>} }</p>
    <p>LTHIS LDST ?</p>
    <p>tmpdstthis</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST ?</p>
    <p>LTHIS LDST ?</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
  </div>
  <div class="page">
    <p>Detailed Example @Local public void copy(TList dst) {</p>
    <p>var tmp = dst.length;</p>
    <p>this.length = tmp;</p>
    <p>tmp = dst.type;</p>
    <p>this.type = tmp;</p>
    <p>tmp = new Object[dst.length];</p>
    <p>this.data = tmp;</p>
    <p>for(int i=0;i!=length;++i) {</p>
    <p>tmp = dst.data[i];</p>
    <p>this.data[i] = tmp;</p>
    <p>} }</p>
    <p>LTHIS LDST ?</p>
    <p>tmpdstthis</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST ?</p>
    <p>LTHIS LDST ?</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST LDST</p>
  </div>
  <div class="page">
    <p>Detailed Example @Local public void copy(TList dst) {</p>
    <p>var tmp = dst.length;</p>
    <p>this.length = tmp;</p>
    <p>tmp = dst.type;</p>
    <p>this.type = tmp;</p>
    <p>tmp = new Object[dst.length];</p>
    <p>this.data = tmp;</p>
    <p>for(int i=0;i!=length;++i) {</p>
    <p>tmp = dst.data[i];</p>
    <p>this.data[i] = tmp;</p>
    <p>} }</p>
    <p>LTHIS LDST ?</p>
    <p>tmpdstthis</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST ?</p>
    <p>LTHIS LDST ?</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LDST</p>
    <p>LDST</p>
  </div>
  <div class="page">
    <p>Detailed Example @Local public void copy(TList dst) {</p>
    <p>var tmp = dst.length;</p>
    <p>this.length = tmp;</p>
    <p>tmp = dst.type;</p>
    <p>this.type = tmp;</p>
    <p>tmp = new Object[dst.length];</p>
    <p>this.data = tmp;</p>
    <p>for(int i=0;i!=length;++i) {</p>
    <p>tmp = dst.data[i];</p>
    <p>this.data[i] = tmp;</p>
    <p>} }</p>
    <p>LTHIS LDST ?</p>
    <p>tmpdstthis</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST ?</p>
    <p>LTHIS LDST ?</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LTHIS LDST</p>
    <p>LDST</p>
    <p>LDST</p>
    <p>LDST</p>
  </div>
  <div class="page">
    <p>Checking vs Inference</p>
    <p>Purity Checker:</p>
    <p>Intraprocedural dataflow analysis</p>
    <p>Uses static information about called methods</p>
    <p>Checks fresh objects flow to @Fresh returns</p>
    <p>Checks assignments to @Local fields are fresh</p>
    <p>Checks assignments to other fields are in locality</p>
    <p>Checks annotations overridden correctly</p>
    <p>Purity Inference:</p>
    <p>Interprocedural dataflow analysis</p>
    <p>Uses static call graph</p>
    <p>Essentially works in opposite direction to checker</p>
    <p>E.g. if all returned values fresh -&gt; method annotated @Fresh</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Limitations</p>
    <p>Disappointment!  Object.equals() not inferred @Pure  Object.hashCode() not inferred @Pure</p>
    <p>class Test {</p>
    <p>private int hashCode;</p>
    <p>public boolean equals(Object o) {</p>
    <p>if(hashCode() == o.hashCode()) {  }</p>
    <p>return false;</p>
    <p>}</p>
    <p>public int hashCode() {</p>
    <p>if(hashCode == -1) { hashCode = ; }</p>
    <p>return hashCode;</p>
    <p>}}</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>The JPure System</p>
    <p>Built around Modularly Checkable Annotations</p>
    <p>Interprocedural analysis infers annotations</p>
    <p>Intraprocedural analysis checks annotations  Could be incorporated in Java Bytecode Verifier</p>
    <p>Locality &amp; freshness help uncover more purity  41% on average for benchmarks (vs 25% for simple)</p>
    <p>See http://www.ecs.vuw.ac.nz/~djp/jpure</p>
  </div>
  <div class="page">
    <p>Law of Locality</p>
    <p>Example:</p>
    <p>What if other aliased with this?</p>
    <p>Applying Law of Locality seems counter-intuitive</p>
    <p>class Test {</p>
    <p>private int field;</p>
    <p>@Local void f(Test other){</p>
    <p>this.field = 1;</p>
    <p>}}</p>
    <p>Law of Locality. When checking @Local annotations, one can safely assume parameters are not aliased (!)</p>
  </div>
</Presentation>
