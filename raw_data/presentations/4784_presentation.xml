<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Efficient Memory Integrity Verification and Encryption for Secure Processors</p>
    <p>G. Edward Suh, Dwaine Clarke, Blaise Gassend, Marten van Dijk, Srinivas Devadas</p>
    <p>Massachusetts Institute of Technology</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>New Security Challenges</p>
    <p>Current computer systems have a large Trusted Computing Base (TCB)  Trusted hardware: processor, memory, etc.  Trusted operating systems, device drivers</p>
    <p>Future computers should have a much smaller TCB  Untrusted OS  Physical attacks Without additional protection, components</p>
    <p>cannot be trusted</p>
    <p>Why smaller TCB?  Easier to verify and trust  Enables new applications</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Applications</p>
    <p>Emerging applications require TCBs that are secure even from an owner</p>
    <p>Distributed computation on Internet/Grid computing  SETI@home, distributed.net, and more  Interact with a random computer on the net how can we</p>
    <p>trust the result?  Software licensing</p>
    <p>The owner of a system is an attacker  Mobile agents</p>
    <p>Software agents on Internet perform a task on behalf of you  Perform sensitive transactions on a remote (untrusted) host</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Single-Chip AEGIS Secure Processors</p>
    <p>Trusted Environment</p>
    <p>Memory</p>
    <p>I/O</p>
    <p>Check Integrity, Encrypt</p>
    <p>Only trust a single chip: tamper-resistant  Off-chip memory: verify the integrity and encrypt  Untrusted OS: identify a core part or protect against OS attacks</p>
    <p>Cheap, Flexible, High Performance</p>
    <p>Identify or Protect against</p>
    <p>Untrusted OS</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Secure Execution Environments</p>
    <p>Tamper-Evident (TE) environment  Guarantees a valid execution and the identity of a program; no</p>
    <p>privacy  Any software or physical tampering to alter the program</p>
    <p>behavior should be detected Integrity verification</p>
    <p>Private Tamper-Resistant (PTR) environment  TE environment + privacy  Assume programs do not leak information via memory access</p>
    <p>patterns Encryption + Integrity verification</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Other Trusted Computing Platforms</p>
    <p>IBM 4758 cryptographic coprocessor  Entire system (processor, memory, and trusted software) in a</p>
    <p>tamper-proof package  Expensive, requires continuous power</p>
    <p>XOM (eXecution Only Memory): David Lie et al  Stated goal: Protect integrity and privacy of code and data  Memory integrity checking does not prevent replay attacks  Always encrypt off-chip memory</p>
    <p>Palladium/NGSCB: Microsoft  Stated goal: Protect from software attacks  Memory integrity and privacy are assumed (only software attacks)</p>
  </div>
  <div class="page">
    <p>Memory Encryption</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Memory Encryption</p>
    <p>Untrusted RAM</p>
    <p>L2 Cache</p>
    <p>Processor</p>
    <p>ENCRYPT</p>
    <p>DECRYPT</p>
    <p>write</p>
    <p>read</p>
    <p>Encrypt on an L2 cache block granularity  Use symmetric key algorithms (AES, 16 Byte chunks)  Should be randomized to prevent comparing two blocks  Adds decryption latency to each memory access</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Direct Encryption (CBC mode): encrypt</p>
    <p>Processor</p>
    <p>Memory</p>
    <p>L2 Block</p>
    <p>B[1]</p>
    <p>B[2]</p>
    <p>B[3]</p>
    <p>B[4]</p>
    <p>RV</p>
    <p>Random #</p>
    <p>AESK</p>
    <p>AESK</p>
    <p>AESK</p>
    <p>AESK</p>
    <p>EB[1] EB[2] EB[3] EB[4]RV</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Direct Encryption (CBC mode): decrypt</p>
    <p>Processor</p>
    <p>Memory EB[1]EB[2]EB[3]EB[4] RV</p>
    <p>B[1]</p>
    <p>B[2]</p>
    <p>B[3]</p>
    <p>B[4]</p>
    <p>AESK-1</p>
    <p>AESK-1</p>
    <p>AESK-1</p>
    <p>AESK-1</p>
    <p>L2 Miss!!</p>
    <p>Memory Request</p>
    <p>Read</p>
    <p>Off-chip access latency = latency for the last chunk of an L2 block + AES + XOR</p>
    <p>Decryption directly impacts off-chip latency</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>One-Time-Pad Encryption (OTP): encrypt</p>
    <p>Processor</p>
    <p>Memory</p>
    <p>B[1]</p>
    <p>B[2]</p>
    <p>B[3]</p>
    <p>B[4]</p>
    <p>Counter</p>
    <p>(Addr,TS,1)</p>
    <p>(Addr,TS,2)</p>
    <p>(Addr,TS,3)</p>
    <p>(Addr,TS,4)</p>
    <p>Time Stamp (TS)</p>
    <p>AESK-1</p>
    <p>AESK-1</p>
    <p>AESK-1</p>
    <p>AESK-1</p>
    <p>One-Time-Pad (OTP)</p>
    <p>EB[1]EB[2]EB[3]EB[4]TS</p>
    <p>To Memory</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>One-Time-Pad Encryption (OTP): decrypt</p>
    <p>Processor</p>
    <p>Memory EB[1]EB[2]EB[3]EB[4]</p>
    <p>B[1]</p>
    <p>B[2]</p>
    <p>B[3]</p>
    <p>B[4]</p>
    <p>AESK-1</p>
    <p>AESK-1</p>
    <p>AESK-1</p>
    <p>AESK-1 L2 Miss!!</p>
    <p>Memory Request</p>
    <p>Read TS</p>
    <p>(Addr,TS,1)</p>
    <p>(Addr,TS,2)</p>
    <p>(Addr,TS,3)</p>
    <p>(Addr,TS,4)</p>
    <p>Off-chip access latency = MAX( latency for the time stamp + AES, latency for an L2 block ) + XOR</p>
    <p>Overlap the decryption with memory accesses</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Effects of Encryption on Performance</p>
    <p>Simulations based on the SimpleScalar tool set  9 SPEC CPU2000 benchmarks  256-KB, 1-MB, 4-MB L2 caches with 64-B blocks  32-bit time stamps and random vectors No caching!  Memory latency: 80/5, decryption latency: 40</p>
    <p>Performance degradation by encryption</p>
    <p>One-Time-PadDirect (CBC)</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Security and Optimizations</p>
    <p>The security of the OTP is at least as good as the conventional CBC scheme  OTP is essentially a counter-mode (CTR) encryption</p>
    <p>Further optimizations are possible  For static data such as instructions, time stamps are not</p>
    <p>required completely overlap the AES computations with memory accesses</p>
    <p>Cache time stamps on-chip, or speculate the value</p>
    <p>Will be used for instruction encryption of Philips media processors</p>
  </div>
  <div class="page">
    <p>Integrity Verification</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Difficulty of Integrity Verification</p>
    <p>Untrusted RAM</p>
    <p>Trusted State</p>
    <p>Processor</p>
    <p>ENCRYPT</p>
    <p>DECRYPT</p>
    <p>Program</p>
    <p>V E R I F Y</p>
    <p>E(124), MAC(0x45, 124)</p>
    <p>Address 0x45</p>
    <p>E(120), MAC(0x45, 120)IGNORE</p>
    <p>write</p>
    <p>read</p>
    <p>Cannot simply MAC on writes and check the MAC on reads Replay attacks</p>
    <p>Hash trees for integrity verification</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Hash Trees</p>
    <p>Processor</p>
    <p>V1 V3 V4</p>
    <p>L2 block</p>
    <p>Data Values</p>
    <p>Logarithmic overhead for every cache miss</p>
    <p>Low performance ( 10x slowdown)</p>
    <p>Cached hash trees</p>
    <p>MISS V2READ</p>
    <p>VERIFY</p>
    <p>h1=h(V1.V2) h2=h(V3.V4)</p>
    <p>root = h(h1.h2)</p>
    <p>VERIFY</p>
    <p>Untrusted Memory</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Cached Hash Trees (HPCA03)</p>
    <p>Processor</p>
    <p>V1 V2 V3 V4</p>
    <p>Cache hashes in L2</p>
    <p>L2 is trusted Stop checking earlier</p>
    <p>Less overhead ( 22% average, 51% worst case)</p>
    <p>Still expensive In L2</p>
    <p>MISS</p>
    <p>In L2</p>
    <p>h1=h(V1.V2) h2=h(V3.V4)</p>
    <p>root = h(h1.h2)</p>
    <p>VERIFY</p>
    <p>VERIFY</p>
    <p>MISS</p>
    <p>VERIFY</p>
    <p>DONE!!!</p>
    <p>Untrusted Memory</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Can we do better?</p>
    <p>Some applications only require to verify memory accesses after a long execution  Distributed computation  No need to check after each memory access</p>
    <p>Can we just check a sequence of accesses?</p>
    <p>Job Dispatcher</p>
    <p>Processors Private Key</p>
    <p>Secure Processor</p>
    <p>RESULT</p>
    <p>RESULT</p>
    <p>enter_aegis</p>
    <p>Execute</p>
    <p>Get results</p>
    <p>Verify results</p>
    <p>- H(Prog)</p>
    <p>- signature</p>
    <p>Program, Data</p>
    <p>Processors Public Key</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Log Hash Integrity Verification: Idea</p>
    <p>At run-time, maintain a log of reads and writes  Reads: make a read note with (address, value) in the log  Writes: make a write note with (address, value) in the log</p>
    <p>check: go thru log, check each read has the most recent value written to the address</p>
    <p>Problem!!: Log grows use cryptographic hashes</p>
    <p>Write 1 at 0x40Write 2 at 0x50Write ( 0x40, 1)</p>
    <p>Write (0x50, 2)</p>
    <p>Read (0x50, 2)</p>
    <p>Read (0x40, 1) Read 2 from 0x50Read 1 from 0x40</p>
    <p>Checker Log</p>
    <p>Write ( 0x40, 1)</p>
    <p>Write (0x50, 2)</p>
    <p>Read (0x50, 2)</p>
    <p>Read (0x40, 1)</p>
    <p>Write ( 0x40, 1)</p>
    <p>Write (0x50, 2)</p>
    <p>Read (0x50, 2)</p>
    <p>Read (0x40, 1)</p>
    <p>Untrusted Memory</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Log Hash Algorithms: Run-Time</p>
    <p>WriteHash</p>
    <p>(0x40, 0, 0)</p>
    <p>(0x50, 0, 0)</p>
    <p>(0x40, 10, 1)</p>
    <p>Timer: 0 Processor</p>
    <p>Initialize (all zero)</p>
    <p>Read 2 from 0x50Cache Miss!!</p>
    <p>Read 0 from 0x40</p>
    <p>ReadHash</p>
    <p>(0x40, 0, 0)</p>
    <p>Timer: 1</p>
    <p>Cache eviction</p>
    <p>Write 10 at 0x40</p>
    <p>Only one additional time</p>
    <p>stamp access for each memory</p>
    <p>access</p>
    <p>Use set hashes as compressed logs  Set hash: maps a set to a fixed length string  ReadHash: a set of read entries (addr, val, time) in the log  WriteHash: a set of write entries (addr, val, time) in the log</p>
    <p>Use Timer (time stamp) to keep the ordering of entries</p>
    <p>Untrusted Memory</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Log Hash Algorithms: Integrity Check</p>
    <p>Read all the addresses that are not in a cache</p>
    <p>Compare ReadHash and WriteHash (same set?)</p>
    <p>WriteHash</p>
    <p>(0x40, 0, 0)</p>
    <p>(0x50, 0, 0)</p>
    <p>(0x40, 10, 1)</p>
    <p>Timer: 0 Processor</p>
    <p>ReadHash</p>
    <p>(0x40, 0, 0)</p>
    <p>(0x40, 10, 1)</p>
    <p>(0x50, 0, 0)</p>
    <p>Timer: 1=? Read 2 from 0x50Read all</p>
    <p>Untrusted Memory</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Checking Overhead of Log Hash Scheme</p>
    <p>IP C</p>
    <p>LHash LHash-RT CHTree</p>
    <p>Integrity check requires reading the entire memory space being used  Cost depends on the size and the length of an application</p>
    <p>For long programs, the checking overhead is negligible  Amortized over a long execution time</p>
    <p>SWIM, 1MB L2, Uses 192MB</p>
    <p>Better than Hash Trees for programs w/ more than</p>
    <p>Check overhead is negligible for programs w/ more than a</p>
    <p>billion accesses</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Performance Comparisons</p>
    <p>Overhead for TE environments  Integrity verification</p>
    <p>Overhead for PTR environments  Integrity verification + encryption</p>
    <p>LHashCHTree</p>
    <p>LHash + OTPCHTree + CBC</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Summary</p>
    <p>Untrusted owners are becoming more prevalent  Untrusted OS, physical attacks requires a small TCB</p>
    <p>Single-chip secure processors require off-chip protection mechanisms: Integrity verification and Encryption</p>
    <p>OTP encryption scheme reduces the overhead of encryption in all cases  Allows decryption to be overlapped with memory accesses  Cache or speculate time stamps to further hide decryption latency</p>
    <p>Log Hash scheme significantly reduces the overhead of integrity verification for certified execution when programs are long enough</p>
  </div>
  <div class="page">
    <p>MICRO36  December 3-5, 2003G. Edward Suh  MIT Computer Science and Artificial Intelligence Laboratory</p>
    <p>Questions?</p>
    <p>More Information at www.csg.lcs.mit.edu</p>
  </div>
</Presentation>
