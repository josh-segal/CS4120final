<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>To SAT or Not to SAT: Ashenhurst Decomposition in a Large Scale</p>
    <p>Hsuan-Po Lin, Jie-Hong Roland Jiang, and Ruei-Rung Lee</p>
    <p>Graduate Institute of Electronics Engineering / Department of Electrical Engineering,</p>
    <p>National Taiwan University</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Introduction1</p>
    <p>Prior Work2</p>
    <p>Conclusions5</p>
    <p>Experimental Results</p>
    <p>Our Approach</p>
  </div>
  <div class="page">
    <p>Ashenhurst decomposition  f(X) = h(XH,XC,g(XG,XC))</p>
    <p>When can f be decomposed as the composition of some g and h?</p>
    <p>Comprehensible using decomposition chart</p>
    <p>Introduction</p>
  </div>
  <div class="page">
    <p>Decomposition Chart</p>
    <p>f(a,b,c,d) = h(c,d,g(a,b,d))</p>
    <p>a,b,d</p>
    <p>c,d</p>
    <p>g</p>
    <p>c,d</p>
    <p>XH : {c} XG : {a,b} XC : {d}</p>
    <p>XH XC</p>
    <p>XH XC</p>
    <p>XG XC</p>
    <p>h</p>
    <p>f</p>
  </div>
  <div class="page">
    <p>Prior Work</p>
    <p>BDD-based functional decomposition  Memory explosion problem  Variable partition cannot be</p>
    <p>automated  Hard to handle non-disjoint</p>
    <p>decomposition  Multiple-output decomposition cannot</p>
    <p>be handled naturally</p>
  </div>
  <div class="page">
    <p>Our Approach</p>
    <p>SAT-based computation  Interpolation  get g  Functional dependency  get h</p>
    <p>With/without pre-specified variable partition</p>
    <p>Single-/multiple-output decomposition</p>
  </div>
  <div class="page">
    <p>Problem formulation</p>
    <p>Given a function f(X) with variable</p>
    <p>partition X={XG|XH|XC}, find g and h such</p>
    <p>that f(X) = h(XH,XC,g(XG,XC))</p>
    <p>Single-Output Decomposition</p>
  </div>
  <div class="page">
    <p>Functions g and h exists if (f(XH1, XG1, XC) f(XH1, XG2, XC)) (f(XH2, XG2, XC) f(XH2, XG3, XC)) (f(XH3, XG3, XC) f(XH3, XG1, XC)) is UNSAT</p>
    <p>Decomposability as SAT</p>
    <p>xg 1[[XG</p>
    <p>xh 1[[XH</p>
    <p>xh 2[[XH</p>
    <p>xh 3[[XH</p>
    <p>xc[[XC]]</p>
    <p>f</p>
    <p>f f f f f f XH</p>
  </div>
  <div class="page">
    <p>For formulas A and B with A  B UNSAT, then there exists an interpolant P of A such that</p>
    <p>common variables of</p>
    <p>A and B</p>
    <p>We show the connection between P and g</p>
    <p>P</p>
    <p>BA</p>
    <p>Craig Interpolation</p>
  </div>
  <div class="page">
    <p>Interpolating g-function</p>
    <p>P: refer to the common variables XG1, XG2, XC  A: CP(XG1)CP(XG2)  B: CP(XG2)CP(XG3),CP(XG1)CP(XG3), i.e., CP(XG1)=CP(XG2)</p>
    <p>f f f f f f XH</p>
    <p>A B</p>
    <p>f(XH 1, XG</p>
  </div>
  <div class="page">
    <p>XG 1 XG</p>
    <p>XG</p>
    <p>p</p>
    <p>q</p>
    <p>r s</p>
    <p>p</p>
    <p>q</p>
    <p>r s</p>
    <p>Interpolating g-function (contd)</p>
    <p>onset</p>
    <p>offset a</p>
    <p>Relation characterized by P(XG</p>
    <p>Relation after cofactoring P(XG</p>
    <p>P(XG 1=a, XG</p>
  </div>
  <div class="page">
    <p>Computing h-function</p>
    <p>A nave approach  For XC = , function h can be derived</p>
    <p>using Shannon expansion</p>
    <p>h(XH,xg)=(xg  hxg) v (xg  hxg)</p>
    <p>Non-scalable(w.r.t. XC size)</p>
    <p>where</p>
    <p>hxg(XH) = h(XH,0) = h(XH,g(XG=a)) = f(XH,XG=a) and</p>
    <p>h xg</p>
    <p>(XH) = h(XH,1) = h(XH,g(XG=b)) = f(XH,XG=b)</p>
    <p>for a,b[[XG]] with g(a)=0 and g(b)=1</p>
  </div>
  <div class="page">
    <p>Computing h-function (contd)</p>
    <p>A scalable approach  Function h can be obtained with</p>
    <p>functional dependency formulation  f(X) = h(1(X), 2(X),, m(X)), where h is the</p>
    <p>unknown to be computed</p>
    <p>Let the above gi be such that i = xi with xi  XHXC for i = 1,,m-1 m = g(XG,XC)</p>
    <p>So-derived h is what we want  Computation can be done with pure SAT</p>
    <p>solving [Lee et al.07]</p>
  </div>
  <div class="page">
    <p>AshenhurstDecomposition(f, XH, XG, XC):</p>
    <p>return(g, h)</p>
    <p>Overall Flow</p>
  </div>
  <div class="page">
    <p>Automating Variable Partition</p>
    <p>For each xi X, add conditional clauses for XG: ((xi2xi3)(xi4xi5)(xi6xi1)) V i conditional clauses for XH: ((xi1xi2)(xi3xi4)(xi5xi6)) V i</p>
    <p>(i,i)  (0,0) xiXC  (0,1) xiXG  (1,0) xiXH  (1,1) xi can</p>
    <p>be in either of XG and XH</p>
    <p>f f f f f f XH</p>
  </div>
  <div class="page">
    <p>Automating Variable Partition (contd)</p>
    <p>Make unit assumptions on control variables i, i for each xi</p>
    <p>Avoid trivial partition  Impose seed partition</p>
    <p>Enforce one variable in XH Enforce two variables in XG</p>
    <p>Enumerate seed partitions  Incremental SAT solving</p>
    <p>Apply minimal UNSAT core refinement to reduce XC</p>
  </div>
  <div class="page">
    <p>Multi-Output Decomposition</p>
    <p>New UNSAT condition:</p>
    <p>V(fi(XH1, XG1, XC) fi(XH1, XG2, XC)) V(fi(XH2, XG2, XC) fi(XH2, XG3, XC)) V(fi(XH3, XG3, XC) fi(XH3, XG1, XC))  Computation is same as before</p>
    <p>i</p>
    <p>i</p>
    <p>i</p>
    <p>XG</p>
    <p>XH</p>
    <p>X</p>
    <p>g hf</p>
    <p>xg</p>
    <p>XC</p>
    <p>...</p>
    <p>...</p>
  </div>
  <div class="page">
    <p>Experimental Setup</p>
    <p>Implemented in ABC using MiniSAT</p>
    <p>Linux, Xeon 3.4GHz CPU, and 6Gb RAM</p>
    <p>Decompose primary-output and transition functions</p>
    <p>Only functions with no less than 50 inputs are considered</p>
    <p>ISCAS, MCNC, and ITC</p>
  </div>
  <div class="page">
    <p>Circuit #func #var #fail #SAT_TO #succ #var_succ #VP_avg rate_ valid_VP</p>
    <p>time_avg (sec)</p>
    <p>Mem (Mb)</p>
    <p>b15 370 143306 0 51 319 143306 1519 0.917 96.62 107.20</p>
    <p>b17 1009 76308 0 148 861 76308 1645 0.904 87.12 125.84</p>
    <p>c7552 36 50194 0 2 34 50194 1350 0.455 64.38 36.65</p>
    <p>s13207 3 212212 0 0 3 212212 569 0.908 70.26 50.62</p>
    <p>s38417 256 5399 6 72 178 5399 1090 0.523 103.33 136.04</p>
    <p>s38584 7 50147 0 0 7 50147 1120 0.924 47.13 51.56</p>
    <p>Experimental Results</p>
    <p>Single-output decomposition</p>
    <p>Circuit #pair #var #fail #SAT_TO #succ #var_succ #VP_avg rate_ valid_VP</p>
    <p>time_avg (sec)</p>
    <p>Mem (Mb)</p>
    <p>b15 201 145--306 0 31 170 145--269 1176 0.845 113.86 224.07</p>
    <p>b17 583 79--310 0 88 495 79--308 676 0.824 103.12 419.35</p>
    <p>c7552 21 56--195 0 2 19 56--141 188 0.465 89.57 78.67</p>
    <p>s13207 3 212--228 0 0 3 212--228 585 0.7 93.36 118.03</p>
    <p>s38417 218 53--116 13 30 175 53--116 689 0.498 109.06 319.48</p>
    <p>s38584 9 50--151 0 0 9 50--151 1656 0.713 46.17 207.78</p>
    <p>Two-output decomposition</p>
  </div>
  <div class="page">
    <p>Variable partition before / after UNSAT core refinement</p>
    <p>Experimental Results (contd)</p>
  </div>
  <div class="page">
    <p>Experimental Results (contd)</p>
    <p>Variable partition qualities resulted from diferent eforts</p>
    <p>||XG|-|XH||/|X| |XC|/|X|</p>
    <p>w/ mini w/o mini</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>Proposed pure SAT-based Ashenhurst decomposition Easily extendable to non-disjoint and</p>
    <p>multiple-output decompositions Scalable to functions with up to 300</p>
    <p>input variables</p>
    <p>Future work Functional decomposition beyond</p>
    <p>Ashenhurst</p>
  </div>
  <div class="page">
    <p>Thanks for Your Attention!</p>
  </div>
</Presentation>
