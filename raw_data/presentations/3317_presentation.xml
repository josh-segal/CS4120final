<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>ARMageddon: Cache Attacks on Mobile Devices</p>
    <p>Moritz Lipp, Daniel Gruss, Raphael Spreitzer, Clementine Maurice, Stefan Mangard Graz University of Technology</p>
    <p>August 11, 2016  Usenix Security 2016</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20161</p>
  </div>
  <div class="page">
    <p>TLDR</p>
    <p>powerful cache attacks (like Flush+Reload) on x86</p>
    <p>why not on ARM?</p>
    <p>We identified and solved challenges systematically to:</p>
    <p>make all cache attack techniques applicable to ARM</p>
    <p>monitor user activity</p>
    <p>attack weak Android crypto</p>
    <p>show that ARM TrustZone leaks through the cache</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20162</p>
  </div>
  <div class="page">
    <p>TLDR</p>
    <p>powerful cache attacks (like Flush+Reload) on x86</p>
    <p>why not on ARM?</p>
    <p>We identified and solved challenges systematically to:</p>
    <p>make all cache attack techniques applicable to ARM</p>
    <p>monitor user activity</p>
    <p>attack weak Android crypto</p>
    <p>show that ARM TrustZone leaks through the cache</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20162</p>
  </div>
  <div class="page">
    <p>What is a cache attack? (1)</p>
    <p>Access time in CPU cycles</p>
    <p>N um</p>
    <p>be r</p>
    <p>of ac</p>
    <p>ce ss</p>
    <p>es</p>
    <p>cache hits cache misses</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20163</p>
  </div>
  <div class="page">
    <p>What is a cache attack? (2)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20164</p>
  </div>
  <div class="page">
    <p>What is a cache attack? (2)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20164</p>
  </div>
  <div class="page">
    <p>What is a cache attack? (2)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20164</p>
  </div>
  <div class="page">
    <p>What is a cache attack? (2)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20164</p>
  </div>
  <div class="page">
    <p>What is a cache attack? (2)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20164</p>
  </div>
  <div class="page">
    <p>What is a cache attack? (2)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20164</p>
  </div>
  <div class="page">
    <p>What is a cache attack? (2)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20164</p>
  </div>
  <div class="page">
    <p>What is a cache attack? (2)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20164</p>
  </div>
  <div class="page">
    <p>Cache attack techniques</p>
    <p>Most important techniques:</p>
    <p>Flush+Reload</p>
    <p>Prime+Probe</p>
    <p>Both work on the last-level cache  across cores</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20165</p>
  </div>
  <div class="page">
    <p>Flush+Reload Attacker</p>
    <p>address space Cache Victim</p>
    <p>address space</p>
    <p>step 0: attacker maps shared library  shared memory, shared in cache</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20166</p>
  </div>
  <div class="page">
    <p>Flush+Reload Attacker</p>
    <p>address space Cache Victim</p>
    <p>address space</p>
    <p>step 0: attacker maps shared library  shared memory, shared in cache</p>
    <p>cached cached</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20166</p>
  </div>
  <div class="page">
    <p>Flush+Reload Attacker</p>
    <p>address space Cache Victim</p>
    <p>address space</p>
    <p>step 0: attacker maps shared library  shared memory, shared in cache step 1: attacker flushes the shared line</p>
    <p>flushes</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20166</p>
  </div>
  <div class="page">
    <p>Flush+Reload Attacker</p>
    <p>address space Cache Victim</p>
    <p>address space</p>
    <p>step 0: attacker maps shared library  shared memory, shared in cache step 1: attacker flushes the shared line step 2: victim loads data while performing encryption</p>
    <p>loads data</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20166</p>
  </div>
  <div class="page">
    <p>Flush+Reload Attacker</p>
    <p>address space Cache Victim</p>
    <p>address space</p>
    <p>step 0: attacker maps shared library  shared memory, shared in cache step 1: attacker flushes the shared line step 2: victim loads data while performing encryption step 3: attacker reloads data  fast access if the victim loaded the line</p>
    <p>reloads data</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20166</p>
  </div>
  <div class="page">
    <p>Prime+Probe Attacker</p>
    <p>address space Cache Victim</p>
    <p>address space</p>
    <p>step 0: attacker fills the cache (prime)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20167</p>
  </div>
  <div class="page">
    <p>Prime+Probe Attacker</p>
    <p>address space Cache Victim</p>
    <p>address space</p>
    <p>step 0: attacker fills the cache (prime)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20167</p>
  </div>
  <div class="page">
    <p>Prime+Probe Attacker</p>
    <p>address space Cache Victim</p>
    <p>address space</p>
    <p>step 0: attacker fills the cache (prime)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20167</p>
  </div>
  <div class="page">
    <p>Prime+Probe Attacker</p>
    <p>address space Cache Victim</p>
    <p>address space</p>
    <p>step 0: attacker fills the cache (prime) step 1: victim evicts cache lines while performing encryption</p>
    <p>loads data</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20167</p>
  </div>
  <div class="page">
    <p>Prime+Probe Attacker</p>
    <p>address space Cache Victim</p>
    <p>address space</p>
    <p>step 0: attacker fills the cache (prime) step 1: victim evicts cache lines while performing encryption</p>
    <p>loads data</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20167</p>
  </div>
  <div class="page">
    <p>Prime+Probe Attacker</p>
    <p>address space Cache Victim</p>
    <p>address space</p>
    <p>step 0: attacker fills the cache (prime) step 1: victim evicts cache lines while performing encryption</p>
    <p>loads data</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20167</p>
  </div>
  <div class="page">
    <p>Prime+Probe Attacker</p>
    <p>address space Cache Victim</p>
    <p>address space</p>
    <p>step 0: attacker fills the cache (prime) step 1: victim evicts cache lines while performing encryption</p>
    <p>loads data</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20167</p>
  </div>
  <div class="page">
    <p>Prime+Probe Attacker</p>
    <p>address space Cache Victim</p>
    <p>address space</p>
    <p>step 0: attacker fills the cache (prime) step 1: victim evicts cache lines while performing encryption</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20167</p>
  </div>
  <div class="page">
    <p>Prime+Probe Attacker</p>
    <p>address space Cache Victim</p>
    <p>address space</p>
    <p>step 0: attacker fills the cache (prime) step 1: victim evicts cache lines while performing encryption step 2: attacker probes data to determine if the set was accessed</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20167</p>
  </div>
  <div class="page">
    <p>Prime+Probe Attacker</p>
    <p>address space Cache Victim</p>
    <p>address space</p>
    <p>step 0: attacker fills the cache (prime) step 1: victim evicts cache lines while performing encryption step 2: attacker probes data to determine if the set was accessed</p>
    <p>fast access</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20167</p>
  </div>
  <div class="page">
    <p>Prime+Probe Attacker</p>
    <p>address space Cache Victim</p>
    <p>address space</p>
    <p>step 0: attacker fills the cache (prime) step 1: victim evicts cache lines while performing encryption step 2: attacker probes data to determine if the set was accessed</p>
    <p>slow access</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20167</p>
  </div>
  <div class="page">
    <p>Caches on Intel CPUs</p>
    <p>core 0</p>
    <p>L1</p>
    <p>L2</p>
    <p>core 1</p>
    <p>L1</p>
    <p>L2</p>
    <p>core 2</p>
    <p>L1</p>
    <p>L2</p>
    <p>core 3</p>
    <p>L1</p>
    <p>L2</p>
    <p>L3 slice 0</p>
    <p>L3 slice 1</p>
    <p>L3 slice 2</p>
    <p>L3 slice 3</p>
    <p>last-level cache (L3):</p>
    <p>shared</p>
    <p>inclusive</p>
    <p>= shared memory is shared in cache, across cores!</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20168</p>
  </div>
  <div class="page">
    <p>Caches on ARM Cortex-A CPUs</p>
    <p>core 0</p>
    <p>L1</p>
    <p>L2</p>
    <p>core 1</p>
    <p>L1</p>
    <p>core 2</p>
    <p>L1</p>
    <p>core 3</p>
    <p>L1</p>
    <p>last-level cache (L2):</p>
    <p>shared</p>
    <p>but not inclusive</p>
    <p>= shared memory not in L2 is not shared in cache</p>
    <p>Challenge #1: non-inclusive caches</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20169</p>
  </div>
  <div class="page">
    <p>Caches on ARM Cortex-A CPUs</p>
    <p>core 0</p>
    <p>L1</p>
    <p>L2</p>
    <p>core 1</p>
    <p>L1</p>
    <p>core 2</p>
    <p>L1</p>
    <p>core 3</p>
    <p>L1</p>
    <p>last-level cache (L2):</p>
    <p>shared</p>
    <p>but not inclusive</p>
    <p>= shared memory not in L2 is not shared in cache</p>
    <p>Challenge #1: non-inclusive caches</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 20169</p>
  </div>
  <div class="page">
    <p>Modern ARM SoCs</p>
    <p>big.LITTLE architecture (A53 + A57)</p>
    <p>multiple CPUs with no shared cache</p>
    <p>Challenge #2: no shared cache</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201610</p>
  </div>
  <div class="page">
    <p>Modern ARM SoCs</p>
    <p>big.LITTLE architecture (A53 + A57)</p>
    <p>multiple CPUs with no shared cache</p>
    <p>Challenge #2: no shared cache</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201610</p>
  </div>
  <div class="page">
    <p>Cache maintenance</p>
    <p>Instructions to enforce memory coherency</p>
    <p>x86: unprivileged clflush</p>
    <p>until ARMv7-A: n/a</p>
    <p>ARMv8-A: kernel can unlock a flush instruction for userspace</p>
    <p>Challenge #3: no flush instruction</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201611</p>
  </div>
  <div class="page">
    <p>Cache maintenance</p>
    <p>Instructions to enforce memory coherency</p>
    <p>x86: unprivileged clflush</p>
    <p>until ARMv7-A: n/a</p>
    <p>ARMv8-A: kernel can unlock a flush instruction for userspace</p>
    <p>Challenge #3: no flush instruction</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201611</p>
  </div>
  <div class="page">
    <p>Cache eviction</p>
    <p>targeted cache eviction on ARM can be complicated:</p>
    <p>existing approaches introduce much noise pseudo-random replacement policy unclear how randomness affects existing approaches</p>
    <p>Challenge #4: perform fast &amp; reliable cache eviction</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201612</p>
  </div>
  <div class="page">
    <p>Cache eviction</p>
    <p>targeted cache eviction on ARM can be complicated:</p>
    <p>existing approaches introduce much noise pseudo-random replacement policy unclear how randomness affects existing approaches</p>
    <p>Challenge #4: perform fast &amp; reliable cache eviction</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201612</p>
  </div>
  <div class="page">
    <p>Timing measurements</p>
    <p>x86: rdtsc provides unprivileged access to cycle count</p>
    <p>ARM: existing attacks require access to privileged mode cycle counter</p>
    <p>Challenge #5: find unprivileged highly accurate timing sources</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201613</p>
  </div>
  <div class="page">
    <p>Timing measurements</p>
    <p>x86: rdtsc provides unprivileged access to cycle count</p>
    <p>ARM: existing attacks require access to privileged mode cycle counter</p>
    <p>Challenge #5: find unprivileged highly accurate timing sources</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201613</p>
  </div>
  <div class="page">
    <p>Challenges</p>
    <p>#1: non-inclusive caches</p>
    <p>#2: no shared cache</p>
    <p>#3: no flush</p>
    <p>#4: random eviction</p>
    <p>#5: no unprivileged timing</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201614</p>
  </div>
  <div class="page">
    <p>Solving #1: non-inclusive caches</p>
    <p>Attacking instruction-inclusive data-non-inclusive caches</p>
    <p>Core 0</p>
    <p>L1I</p>
    <p>S et</p>
    <p>s</p>
    <p>L1D</p>
    <p>Core 1</p>
    <p>L1I L1D</p>
    <p>L2 Unified Cache</p>
    <p>S et</p>
    <p>s</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201615</p>
  </div>
  <div class="page">
    <p>Solving #1: non-inclusive caches</p>
    <p>Attacking instruction-inclusive data-non-inclusive caches</p>
    <p>Core 0</p>
    <p>L1I</p>
    <p>S et</p>
    <p>s</p>
    <p>L1D</p>
    <p>Core 1</p>
    <p>L1I L1D</p>
    <p>L2 Unified Cache</p>
    <p>S et</p>
    <p>s</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201615</p>
  </div>
  <div class="page">
    <p>Solving #1: non-inclusive caches</p>
    <p>Attacking instruction-inclusive data-non-inclusive caches</p>
    <p>Core 0</p>
    <p>L1I S</p>
    <p>et s</p>
    <p>L1D</p>
    <p>Core 1</p>
    <p>L1I L1D</p>
    <p>L2 Unified Cache</p>
    <p>S et</p>
    <p>s</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201615</p>
  </div>
  <div class="page">
    <p>Solving #1: non-inclusive caches</p>
    <p>What about entirely non-inclusive caches?</p>
    <p>cache coherency protocol</p>
    <p>fetches data from remote cores instead of DRAM</p>
    <p>remote cache hits</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201616</p>
  </div>
  <div class="page">
    <p>Solving #1: non-inclusive caches</p>
    <p>What about entirely non-inclusive caches?</p>
    <p>Core 0</p>
    <p>L1I</p>
    <p>S et</p>
    <p>s</p>
    <p>L1D</p>
    <p>Core 1</p>
    <p>L1I L1D</p>
    <p>L2 Unified Cache S</p>
    <p>et s</p>
    <p>evi ct t</p>
    <p>o D RA</p>
    <p>M</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201617</p>
  </div>
  <div class="page">
    <p>Solving #1: non-inclusive caches</p>
    <p>104</p>
    <p>Measured access time in CPU cycles (OnePlus One)</p>
    <p>N um</p>
    <p>be r</p>
    <p>of ac</p>
    <p>ce ss</p>
    <p>es</p>
    <p>Hit (same core) Hit (cross-core) Miss (same core) Miss (cross-core)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201618</p>
  </div>
  <div class="page">
    <p>Solving #2: no shared cache</p>
    <p>Multiple CPUs with no shared cache</p>
    <p>again: cache coherency protocol</p>
    <p>fetches data from remote CPUs instead of DRAM</p>
    <p>keep local L2 filled to increase probability of remote L1/L2 eviction</p>
    <p>timing difference between local and remote still small enough</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201619</p>
  </div>
  <div class="page">
    <p>Solving #2: no shared cache</p>
    <p>Multiple CPUs with no shared cache</p>
    <p>again: cache coherency protocol</p>
    <p>fetches data from remote CPUs instead of DRAM</p>
    <p>keep local L2 filled to increase probability of remote L1/L2 eviction</p>
    <p>timing difference between local and remote still small enough</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201619</p>
  </div>
  <div class="page">
    <p>Solving #3: no flush</p>
    <p>idea: replace flush instruction with cache eviction</p>
    <p>Flush+Reload  Evict+Reload</p>
    <p>(works on x86)</p>
    <p>but: cache eviction is slow and can be unreliable</p>
    <p>unless you know how to evict</p>
    <p>central idea of our Rowhammer.js paper</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201620</p>
  </div>
  <div class="page">
    <p>Solving #3: no flush</p>
    <p>idea: replace flush instruction with cache eviction</p>
    <p>Flush+Reload  Evict+Reload (works on x86)</p>
    <p>but: cache eviction is slow and can be unreliable</p>
    <p>unless you know how to evict</p>
    <p>central idea of our Rowhammer.js paper</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201620</p>
  </div>
  <div class="page">
    <p>Solving #3: no flush</p>
    <p>idea: replace flush instruction with cache eviction</p>
    <p>Flush+Reload  Evict+Reload (works on x86)</p>
    <p>but: cache eviction is slow and can be unreliable</p>
    <p>unless you know how to evict</p>
    <p>central idea of our Rowhammer.js paper</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201620</p>
  </div>
  <div class="page">
    <p>Solving #3: no flush</p>
    <p>idea: replace flush instruction with cache eviction</p>
    <p>Flush+Reload  Evict+Reload (works on x86)</p>
    <p>but: cache eviction is slow and can be unreliable</p>
    <p>unless you know how to evict</p>
    <p>central idea of our Rowhammer.js paper</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201620</p>
  </div>
  <div class="page">
    <p>Solving #3: no flush</p>
    <p>idea: replace flush instruction with cache eviction</p>
    <p>Flush+Reload  Evict+Reload (works on x86)</p>
    <p>but: cache eviction is slow and can be unreliable</p>
    <p>unless you know how to evict</p>
    <p>central idea of our Rowhammer.js paper</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201620</p>
  </div>
  <div class="page">
    <p>Solving #4: random eviction</p>
    <p>unique addr. # accesses Cycles Eviction rate</p>
    <p>(on the Alcatel One Touch Pop 2)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201621</p>
  </div>
  <div class="page">
    <p>Solving #5: no unprivileged timing</p>
    <p>Comparison of 4 different measurement techniques</p>
    <p>performance counter (privileged)</p>
    <p>perf event open (syscall, unprivileged)</p>
    <p>clock gettime (unprivileged)</p>
    <p>thread counter (multithreaded, unprivileged)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201622</p>
  </div>
  <div class="page">
    <p>Solving #5: no unprivileged timing</p>
    <p>104</p>
    <p>Measured access time (scaled)</p>
    <p>N um</p>
    <p>be r</p>
    <p>of ac</p>
    <p>ce ss</p>
    <p>es</p>
    <p>Hit (PMCCNTR) Hit (clock gettime.15) Miss (PMCCNTR) Miss (clock gettime.15) Hit (syscall.25) Hit (counter thread.05)</p>
    <p>Miss (syscall.25) Miss (counter thread.05)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201623</p>
  </div>
  <div class="page">
    <p>Flush+Flush on the Samsung Galaxy S6</p>
    <p>104</p>
    <p>Measured execution time in CPU cycles</p>
    <p>N um</p>
    <p>be r</p>
    <p>of ca</p>
    <p>se s Flush (address cached)</p>
    <p>Flush (address not cached)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201624</p>
  </div>
  <div class="page">
    <p>Prime+Probe on the Alcatel One Touch Pop 2</p>
    <p>Execution time in CPU cycles</p>
    <p>C as</p>
    <p>es</p>
    <p>Victim access No victim access</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201625</p>
  </div>
  <div class="page">
    <p>Covert channels on Android</p>
    <p>Work Type Bandwidth [bps] Error rate</p>
    <p>Ours (Samsung Galaxy S6) Flush+Reload, cross-core 1 140 650 1.10% Ours (Samsung Galaxy S6) Flush+Reload, cross-CPU 257 509 1.83% Ours (Samsung Galaxy S6) Flush+Flush, cross-core 178 292 0.48% Ours (Alcatel One Touch Pop 2) Evict+Reload, cross-core 13 618 3.79% Ours (OnePlus One) Evict+Reload, cross-core 12 537 5.00% Marforio et al. Type of Intents 4 300  Marforio et al. UNIX socket discovery 2 600  Schlegel et al. File locks 685  Schlegel et al. Volume settings 150  Schlegel et al. Vibration settings 87</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201626</p>
  </div>
  <div class="page">
    <p>Cache template attacks (CTA)</p>
    <p>Addresses</p>
    <p>text tap</p>
    <p>swipe longpress</p>
    <p>key</p>
    <p>E ve</p>
    <p>n t</p>
    <p>Cache template matrix for libinput.so (on an Alcatel One Touch Pop 2)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201627</p>
  </div>
  <div class="page">
    <p>Cache template attacks (CTA)</p>
    <p>Addresses</p>
    <p>backspace</p>
    <p>space</p>
    <p>enter</p>
    <p>alphabet</p>
    <p>In pu</p>
    <p>t</p>
    <p>Cache template matrix for the default AOSP keyboard (on a Samsung Galaxy S6)</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201628</p>
  </div>
  <div class="page">
    <p>CTA: taps and swipes</p>
    <p>Tap Tap Tap Swipe Swipe Swipe Tap Tap Tap Swipe Swipe</p>
    <p>Time in seconds</p>
    <p>A cc</p>
    <p>es s</p>
    <p>tim e</p>
    <p>measured on an Alcatel One Touch Pop 2 Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201629</p>
  </div>
  <div class="page">
    <p>CTA: taps and swipes</p>
    <p>Tap Tap Tap Swipe Swipe Swipe</p>
    <p>Time in seconds</p>
    <p>A cc</p>
    <p>es s</p>
    <p>tim e</p>
    <p>measured on a Samsung Galaxy S6 Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201630</p>
  </div>
  <div class="page">
    <p>CTA: taps and swipes</p>
    <p>Tap Tap Tap Swipe Swipe Swipe</p>
    <p>Time in seconds</p>
    <p>A cc</p>
    <p>es s</p>
    <p>tim e</p>
    <p>measured on measured on a OnePlus One Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201631</p>
  </div>
  <div class="page">
    <p>CTA: distinguishing keys</p>
    <p>t h i s Space i s Space a Space m e s s a g e</p>
    <p>Time in seconds</p>
    <p>A cc</p>
    <p>es s</p>
    <p>tim e</p>
    <p>Key Space</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201632</p>
  </div>
  <div class="page">
    <p>Bouncy Castle</p>
    <p>a widely used crypto library</p>
    <p>WhatsApp, ...</p>
    <p>uses a T-table implementation</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201633</p>
  </div>
  <div class="page">
    <p>Attacking Bouncy Castle 0x</p>
    <p>A 0</p>
    <p>C 0</p>
    <p>E 0</p>
    <p>A dd</p>
    <p>re ss</p>
    <p>B 0</p>
    <p>D 0</p>
    <p>F 0</p>
    <p>Plaintext byte values</p>
    <p>A dd</p>
    <p>re ss</p>
    <p>Evict+Reload (Alcatel) vs. Flush+Reload (Samsung) Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201634</p>
  </div>
  <div class="page">
    <p>Attacking Bouncy Castle with Prime+Probe (Alcatel)</p>
    <p>B 0</p>
    <p>D 0</p>
    <p>F 0</p>
    <p>Plaintext byte values</p>
    <p>O ff</p>
    <p>se t</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201635</p>
  </div>
  <div class="page">
    <p>Leakage from ARM TrustZone (RSA signatures)</p>
    <p>Set number</p>
    <p>P ro</p>
    <p>bi ng</p>
    <p>tim e</p>
    <p>in C</p>
    <p>P U</p>
    <p>cy cl</p>
    <p>es Valid key 1 Valid key 2 Valid key 3 Invalid key</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201636</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>all the powerful cache attacks applicable to smartphones</p>
    <p>monitor user activity with high accuracy</p>
    <p>derive crypto keys</p>
    <p>ARM TrustZone leaks through the cache</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201637</p>
  </div>
  <div class="page">
    <p>ARMageddon: Cache Attacks on Mobile Devices</p>
    <p>Moritz Lipp, Daniel Gruss, Raphael Spreitzer, Clementine Maurice, Stefan Mangard Graz University of Technology</p>
    <p>August 11, 2016  Usenix Security 2016</p>
    <p>Daniel Gruss, Graz University of Technology August 11, 2016  Usenix Security 201638</p>
  </div>
</Presentation>
