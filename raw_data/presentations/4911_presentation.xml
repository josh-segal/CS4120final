<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Dependence-Aware Transactional Memory for Increased Concurrency</p>
    <p>Hany E. Ramadan, Christopher J. Rossbach,</p>
    <p>Emmett Witchel University of Texas, Austin</p>
  </div>
  <div class="page">
    <p>Concurrency Conundrum</p>
    <p>Challenge: CMP ubiquity  Parallel programming with locks</p>
    <p>and threads is difficult  deadlock, livelock, convoys  lock ordering, poor composability  performance-complexity tradeoff</p>
    <p>Transactional Memory (HTM)  simpler programming model  removes pitfalls of locking  coarse-grain transactions can</p>
    <p>perform well under low-contention</p>
    <p>(neat!)</p>
  </div>
  <div class="page">
    <p>High contention: optimism warranted?</p>
    <p>Locks Transactions</p>
    <p>ReadSharing</p>
    <p>WriteSharing</p>
    <p>TM performs poorly with write-shared data  Increasing core counts make</p>
    <p>this worse</p>
    <p>Write sharing is common  Statistics, reference</p>
    <p>counters, lists</p>
    <p>Solutions complicate programming model  open-nesting, boosting, early</p>
    <p>release, ANTs TMs need not always serialize</p>
    <p>write-shared Transactions!</p>
    <p>Dependence-Awareness can help the programmer</p>
    <p>(transparently!) 3</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation</p>
    <p>Dependence-Aware Transactions</p>
    <p>Dependence-Aware Hardware</p>
    <p>Experimental Methodology/Evaluation</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>Two threads sharing a counter</p>
    <p>load count,r</p>
    <p>inc r</p>
    <p>store r,count</p>
    <p>Schedule:  dynamic instruction sequence  models concurrency by interleaving instructions from multiple threads</p>
    <p>Initially: count == 0</p>
    <p>Result: count == 2</p>
    <p>time</p>
    <p>Thread B</p>
    <p>load count,r</p>
    <p>inc r</p>
    <p>store r,count</p>
    <p>Thread A</p>
    <p>count: 012</p>
    <p>memory</p>
  </div>
  <div class="page">
    <p>count:</p>
    <p>TM shared counter</p>
    <p>xbegin</p>
    <p>load count,r</p>
    <p>inc r</p>
    <p>store r,count</p>
    <p>xend</p>
    <p>Conflict:  both transactions access a datum, at least one is a write  intersection between read and write sets of transactions</p>
    <p>Initially: count == 0</p>
    <p>time</p>
    <p>Tx Bxbegin</p>
    <p>load count,r</p>
    <p>inc r</p>
    <p>store r,count</p>
    <p>xend</p>
    <p>Tx A</p>
    <p>Conflict!</p>
    <p>Current HTM designs cannot accept such schedules,</p>
    <p>despite the fact that they yield the correct result!</p>
    <p>memorymemory</p>
  </div>
  <div class="page">
    <p>Does this really matter?</p>
    <p>xbegin</p>
    <p>load X,r0</p>
    <p>inc r0</p>
    <p>store r0,X</p>
    <p>xend</p>
    <p>Critsec B xbegin</p>
    <p>load X,r0</p>
    <p>inc r0</p>
    <p>store r0,X</p>
    <p>xend</p>
    <p>Critsec A xbegin</p>
    <p>&lt;lots of work&gt;</p>
    <p>load count,r</p>
    <p>inc r</p>
    <p>store r,count</p>
    <p>xend</p>
    <p>Critsec B xbegin</p>
    <p>&lt;lots of work&gt;</p>
    <p>load count,r</p>
    <p>inc r</p>
    <p>store r,count</p>
    <p>xend</p>
    <p>Critsec A</p>
    <p>DATM: use dependences to commit conflicting transactions</p>
    <p>Common Pattern!  Statistics  Linked lists  Garbage collectors</p>
  </div>
  <div class="page">
    <p>count:</p>
    <p>memory</p>
    <p>DATM shared counter</p>
    <p>xbegin</p>
    <p>load count,r</p>
    <p>inc r</p>
    <p>store r,count</p>
    <p>xend</p>
    <p>time</p>
    <p>T2xbegin</p>
    <p>load count,r</p>
    <p>inc r</p>
    <p>store r,count</p>
    <p>xend</p>
    <p>T1</p>
    <p>Forward speculative data from T1 to satisfy T2s load.</p>
    <p>T2 depends on T1</p>
    <p>T1 must commit before T2</p>
    <p>If T1 aborts, T2 must also abort</p>
    <p>If T1 overwrites count, T2 must abort</p>
    <p>Model these constraints as dependences</p>
    <p>Initially: count == 0</p>
  </div>
  <div class="page">
    <p>Conflicts become Dependences</p>
    <p>Dependence Graph  Transactions: nodes  dependences: edges  edges dictate commit order  no cycles  conflict serializable</p>
    <p>write X</p>
    <p>write Y</p>
    <p>read Z</p>
    <p>Tx B</p>
    <p>read X</p>
    <p>write Y</p>
    <p>write Z</p>
    <p>Tx A</p>
    <p>Tx A Tx BWW</p>
    <p>WR</p>
    <p>Read-Write: A commits before B</p>
    <p>Write-Write: A commits before B</p>
    <p>Write-Read:  forward data  overwrite  abort  A commits before B</p>
  </div>
  <div class="page">
    <p>Enforcing ordering using Dependence Graphs</p>
    <p>xbegin</p>
    <p>load X,r0</p>
    <p>store r0,X</p>
    <p>xend</p>
    <p>xbegin</p>
    <p>load X,r0</p>
    <p>store r0,X</p>
    <p>xend</p>
    <p>Outstanding Dependences!</p>
    <p>xbegin</p>
    <p>load X,r0</p>
    <p>store r0,X</p>
    <p>xend</p>
    <p>WR</p>
    <p>Wait for T1</p>
    <p>T1 T2</p>
    <p>T1 must serialize before T2</p>
    <p>T1 T2WR</p>
  </div>
  <div class="page">
    <p>Enforcing Consistency using Dependence Graphs</p>
    <p>xbegin</p>
    <p>load X,r0</p>
    <p>store r0,X</p>
    <p>xend</p>
    <p>CYCLE! (lost update)</p>
    <p>xbegin</p>
    <p>load X, r0</p>
    <p>store r0,X</p>
    <p>xend</p>
    <p>WW</p>
    <p>T1 T2</p>
    <p>R W</p>
    <p>T1 T2RW</p>
    <p>WW</p>
    <p>cyclenot conflict serializable  restart some tx to break cycle  invoke contention manager</p>
  </div>
  <div class="page">
    <p>Theoretical Foundation</p>
    <p>Serializability: results of concurrent interleaving equivalent to serial interleaving</p>
    <p>Conflict:</p>
    <p>Conflict-equivalent: same operations, order of conflicting operations same</p>
    <p>Conflict-serializability: conflictequivalent to a serial interleaving</p>
    <p>2-phase locking: conservative implementation of CS</p>
    <p>(LogTM, TCC, RTM, MetaTM, OneTM.)</p>
    <p>Serializable</p>
    <p>Conflict Serializable</p>
    <p>Correctness and optimality</p>
    <p>Proof: See [PPoPP 09]</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation/Background</p>
    <p>Dependence-Aware Model</p>
    <p>Dependence-Aware Hardware</p>
    <p>Experimental Methodology/Evaluation</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>DATM Requirements</p>
    <p>Mechanisms:</p>
    <p>Maintain global dependence graph  Conservative approximation</p>
    <p>Detect cycles, enforce ordering constraints</p>
    <p>Create dependences</p>
    <p>Forwarding/receiving</p>
    <p>Buffer speculative data</p>
    <p>Implementation: coherence, L1, per-core HW structures 14</p>
  </div>
  <div class="page">
    <p>Dependence-Aware Microarchitecture</p>
    <p>Order vector: dependence graph</p>
    <p>TXID, access bits: versioning, detection</p>
    <p>TXSW: transaction status</p>
    <p>Frc-ND + ND bits: disable dependences</p>
    <p>These are not programmer-visible! 15</p>
  </div>
  <div class="page">
    <p>Dependence-Aware Microarchitecture</p>
    <p>These are not programmer-visible!</p>
    <p>Order vector:</p>
    <p>dependence graph</p>
    <p>topological sort</p>
    <p>conservative approx.</p>
  </div>
  <div class="page">
    <p>Dependence-Aware Microarchitecture</p>
    <p>Order vector: dependence graph</p>
    <p>TXID, access bits: versioning, detection</p>
    <p>TXSW: transaction status</p>
    <p>Frc-ND + ND bits: disable dependences</p>
    <p>These are not programmer-visible! 17</p>
  </div>
  <div class="page">
    <p>Dependence-Aware Microarchitecture</p>
    <p>Order vector: dependence graph</p>
    <p>TXID, access bits: versioning, detection</p>
    <p>TXSW: transaction status</p>
    <p>Frc-ND + ND bits: disable dependences, no active dependences</p>
    <p>These are not programmer-visible! 18</p>
  </div>
  <div class="page">
    <p>FRMSI protocol: forwarding and receiving</p>
    <p>MSI states  TX states (T*)  Forwarded: (T*F)  Received: (T*R*)  Committing (CTM)  Bus messages:</p>
    <p>TXOVW  xABT  xCMT</p>
  </div>
  <div class="page">
    <p>FRMSI protocol: forwarding and receiving</p>
    <p>MSI states  TX states (T*)  Forwarded: (T*F)  Received: (T*R*)  Committing (CTM)  Bus messages:</p>
    <p>TXOVW  xABT  xCMT</p>
  </div>
  <div class="page">
    <p>FRMSI protocol: forwarding and receiving</p>
    <p>MSI states  TxMSI states (T*)  Forwarded: (T*F)  Received: (T*R*)  Committing (CTM)  Bus messages:</p>
    <p>TXOVW  xABT  xCMT</p>
  </div>
  <div class="page">
    <p>FRMSI protocol: forwarding and receiving</p>
    <p>MSI states  TX states (T*)  Forwarded: (T*F)  Received: (T*R*)  Committing (CTM)  Bus messages:</p>
    <p>TXOVW  xABT  xCMT</p>
  </div>
  <div class="page">
    <p>Main Memory</p>
    <p>Converting Conflicts to Dependences</p>
    <p>core 0 core 1 core_0</p>
    <p>TXID</p>
    <p>R</p>
    <p>PC</p>
    <p>core_1</p>
    <p>TXID</p>
    <p>R</p>
    <p>PC</p>
    <p>L1</p>
    <p>cnt</p>
    <p>OVec S TXID data</p>
    <p>L1</p>
    <p>cnt</p>
    <p>OVec S TXID data</p>
    <p>TxA</p>
    <p>TxATMFTS</p>
    <p>TMM 101</p>
    <p>TxB</p>
    <p>[A,B] [A,B]</p>
    <p>TRTMF TxBTMR</p>
    <p>Outstandin g</p>
    <p>Dependenc e</p>
    <p>(stall)</p>
    <p>xCMT(A)</p>
    <p>CTM 102</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation/Background</p>
    <p>Dependence-Aware Model</p>
    <p>Dependence-Aware Hardware</p>
    <p>Experimental Methodology/Evaluation</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>Experimental Setup  Implemented DATM by extending MetaTM</p>
    <p>Compared against MetaTM: [Ramadan 2007]  Simulation environment</p>
    <p>Simics 3.0.30 machine simulator  x86 ISA w/HTM instructions  32k 4-way tx L1 cache; 4MB 4-way L2; 1GB RAM  1 cycle/inst, 24 cyc/L2 hit, 350 cyc/main memory  8, 16 processors</p>
    <p>Benchmarks  Micro-benchmarks  STAMP [Minh ISCA 2007]  TxLinux: Transactional OS [Rossbach SOSP 2007]</p>
  </div>
  <div class="page">
    <p>DATM speedup, 16 CPUs</p>
  </div>
  <div class="page">
    <p>Eliminating wasted work</p>
  </div>
  <div class="page">
    <p>Dependence Aware Contention Management</p>
    <p>T3</p>
    <p>T7 T6</p>
    <p>T1</p>
    <p>T4</p>
    <p>T2</p>
    <p>W</p>
    <p>R</p>
    <p>WW</p>
    <p>W</p>
    <p>R WR</p>
    <p>W</p>
    <p>R</p>
    <p>W</p>
    <p>R</p>
    <p>Timestamp contention management</p>
    <p>T3</p>
    <p>Dependence Aware T1</p>
    <p>Cascaded abort?</p>
    <p>T2, T3, T7, T6, T4, T1Order Vector T2T2, T3, T7, T6, T4 28</p>
  </div>
  <div class="page">
    <p>Contention Management</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation/Background</p>
    <p>Dependence-Aware Model</p>
    <p>Dependence-Aware Hardware</p>
    <p>Experimental Methodology/Evaluation</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>Related Work  HTM</p>
    <p>TCC [Hammond 04], LogTM[-SE] [Moore 06], VTM [Rajwar 05], MetaTM [Ramadan 07, Rossbach 07], HASTM, PTM, HyTM, RTM/FlexTM [Shriraman 07,08]</p>
    <p>TLS  Hydra [Olukotun 99], Stampede [Steffan 98,00], Multiscalar</p>
    <p>[Sohi 95], [Garzaran 05], [Renau 05]</p>
    <p>TM Model extensions  Privatization [Spear 07], early release [Skare 06], escape</p>
    <p>actions [Zilles 06], open/closed nesting [Moss 85, Menon 07], Galois [Kulkarni 07], boosting [Herlihy 08], ANTs [Harris 07]</p>
    <p>TM + Conflict Serializability  Adaptive TSTM [Aydonat 08]</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>DATM can commit conflicting transactions</p>
    <p>Improves write-sharing performance</p>
    <p>Transparent to the programmer</p>
    <p>DATM prototype demonstrates performance benefits</p>
    <p>Source code available! www.metatm.net 32</p>
  </div>
  <div class="page">
    <p>Broadcast and Scalability Because each node maintains all deps, this design uses broadcast for:  Commit  Abort  TXOVW (broadcast writes)  Forward restarts  New Dependences</p>
    <p>These sources of broadcast could be avoided in a directory protocol:</p>
    <p>keep only the relevant subset of the dependence graph at each node</p>
    <p>Yes. We broadcast. But its less than you might think</p>
  </div>
  <div class="page">
    <p>FRMSI Transient states</p>
    <p>Ameliorating factors  best-effort: local evictions  abort, reduces WB states  T*R* states are isolated  transitions back to MSI (abort, commit) require no transient states</p>
    <p>Signatures for forward/receive sets could eliminate five states.</p>
  </div>
  <div class="page">
    <p>Why isnt this TLS? TLS DATM TM</p>
    <p>Forward data between threads</p>
    <p>Detect when reads occur too early</p>
    <p>Discard speculative state after violations</p>
    <p>Retire speculative Writes in order</p>
    <p>Memory renaming</p>
    <p>Multi-threaded workloads</p>
    <p>Programmer/Compiler transparency</p>
  </div>
  <div class="page">
    <p>Doesnt this lead to cascading aborts?</p>
    <p>YES</p>
    <p>Rare in most workloads 36</p>
  </div>
  <div class="page">
    <p>Inconsistent Reads</p>
    <p>OS modifications:  Page fault handler  Signal handler</p>
  </div>
  <div class="page">
    <p>Increasing Concurrency</p>
    <p>a rb</p>
    <p>itra te</p>
    <p>Lazy/Lazy (e.g. TCC)</p>
    <p>Eager/Eager (MetaTM,LogTM)</p>
    <p>DATM</p>
    <p>x e n d</p>
    <p>xb e</p>
    <p>g in</p>
    <p>xe n d</p>
    <p>xb e</p>
    <p>g in</p>
    <p>xe n d</p>
    <p>xb e</p>
    <p>g in</p>
    <p>xb e</p>
    <p>g in</p>
    <p>xe n d</p>
    <p>xb e</p>
    <p>g in</p>
    <p>xb e</p>
    <p>g in</p>
    <p>xe n d</p>
    <p>xe n d</p>
    <p>c o</p>
    <p>n flic</p>
    <p>t</p>
    <p>xb e</p>
    <p>g in</p>
    <p>xb e</p>
    <p>g in</p>
    <p>T1</p>
    <p>T2</p>
    <p>T1</p>
    <p>T2</p>
    <p>T1</p>
    <p>T2</p>
    <p>c o n</p>
    <p>flic t</p>
    <p>a rb</p>
    <p>itra te</p>
    <p>c o</p>
    <p>n flic</p>
    <p>t</p>
    <p>time</p>
    <p>serialized</p>
    <p>overlapped retry</p>
    <p>no retry!</p>
    <p>tc</p>
    <p>(Lazy/Lazy: Updates buffered, conflict detection at commit time)(Eager/Eager: Updates in-place, conflict detection at time of reference) 38</p>
  </div>
  <div class="page">
    <p>Design space highlights</p>
    <p>Cache granularity:  eliminate per word access bits</p>
    <p>Timestamp-based dependences:  eliminate Order Vector</p>
    <p>Dependence-Aware contention management</p>
  </div>
  <div class="page">
    <p>Design Points</p>
  </div>
  <div class="page">
    <p>Key Ideas:  Critical sections</p>
    <p>execute concurrently</p>
    <p>Conflicts are detected dynamically</p>
    <p>If conflict serializability is violated, rollback</p>
    <p>Key Abstractions:</p>
    <p>Primitives  xbegin, xend, xretry</p>
    <p>Conflict</p>
    <p>Contention Manager  Need flexible policy</p>
    <p>Hardware TM Primer</p>
    <p>Conventional Wisdom Transactionalization: Replace locks with transactions</p>
  </div>
  <div class="page">
    <p>Working Set R{} W{}</p>
    <p>cpu 0 cpu 1</p>
    <p>PC: 0</p>
    <p>Working Set R{} W{}</p>
    <p>PC: 0</p>
    <p>Working Set R{} W{}</p>
    <p>PC: 1 PC: 0PC: 1PC: 2</p>
    <p>Working Set R{ }</p>
    <p>W{} A</p>
    <p>PC: 2</p>
    <p>Working Set R{ } W{}</p>
    <p>A</p>
    <p>PC: 3</p>
    <p>Working Set R{ }</p>
    <p>W{} A, B</p>
    <p>PC: 3</p>
    <p>Working Set R{ }</p>
    <p>W{} A,B</p>
    <p>PC: 6 PC: 4PC: 7</p>
    <p>Working Set R{ }</p>
    <p>W{} A,B,C</p>
    <p>PC: 7</p>
    <p>Working Set R{ } W{ }</p>
    <p>A,B C</p>
    <p>CONFLICT:</p>
    <p>C is in the read set of cpu0, and in the write set of cpu1</p>
    <p>Assume contention manager decides cpu1 wins:</p>
    <p>cpu0 rolls back</p>
    <p>cpu1 commits</p>
    <p>PC: 0 PC: 8</p>
    <p>Working Set R{} W{}</p>
    <p>Hardware TM basics: example</p>
  </div>
</Presentation>
