<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Fast Databases with Fast Durability and Recovery</p>
    <p>Through Multicore Parallelism</p>
    <p>Wenting Zheng, Stephen Tu (MIT/UC Berkeley) Eddie Kohler (Harvard), Barbara Liskov (MIT)</p>
  </div>
  <div class="page">
    <p>Motivation  In-memory databases are popular</p>
    <p>extremely fast transaction processing</p>
    <p>VoltDB, MemSQL, etc.</p>
    <p>Replication may not be enough</p>
  </div>
  <div class="page">
    <p>Motivation  In-memory databases are popular</p>
    <p>extremely fast transaction processing</p>
    <p>VoltDB, MemSQL, etc.</p>
    <p>Replication may not be enough Potential weakness: durability!</p>
  </div>
  <div class="page">
    <p>Need a persistence system with !</p>
    <p>small performance impact on runtime throughput and latency</p>
    <p>and recovery of a big database in a few</p>
    <p>minutes! !</p>
    <p>for a fast, multicore, in-memory database</p>
  </div>
  <div class="page">
    <p>Challenges  Avoid interference with</p>
    <p>transaction execution  Fast recovery</p>
    <p>serial recovery takes too long  parallel recovery constrains</p>
    <p>logging and checkpointing designs</p>
  </div>
  <div class="page">
    <p>Challenges  Avoid interference with</p>
    <p>transaction execution  Fast recovery</p>
    <p>serial recovery takes too long  parallel recovery constrains</p>
    <p>logging and checkpointing designs</p>
  </div>
  <div class="page">
    <p>Solution  SiloR provides persistence for Silo</p>
    <p>(SOSP 13)  logging, checkpointing, recovery</p>
    <p>using disks</p>
    <p>IDEA: parallelism in all parts of the system, both runtime and recovery</p>
  </div>
  <div class="page">
    <p>Solution  SiloR provides persistence for Silo</p>
    <p>(SOSP 13)  logging, checkpointing, recovery</p>
    <p>using disks</p>
    <p>IDEA: parallelism in all parts of the system, both runtime and recovery</p>
  </div>
  <div class="page">
    <p>Silo Overview!  SiloR Design</p>
    <p>Logging  Checkpointing  Recovery</p>
    <p>Evaluation  Related work</p>
  </div>
  <div class="page">
    <p>Silo Overview  Silo is a very high performance in</p>
    <p>memory database  Workers on different cores execute</p>
    <p>transactions on a shared-memory database</p>
    <p>Optimistic concurrency control (OCC)</p>
  </div>
  <div class="page">
    <p>Silo TID and Epochs  Epochs are global time periods</p>
    <p>(~40 ms)  Silo TIDs are grouped into epochs  Writes ordered by TIDs  Epochs provide group commit and</p>
    <p>avoid contention on global TID  Epochs are recovery units</p>
  </div>
  <div class="page">
    <p>Silo Overview  SiloR Design!</p>
    <p>Logging!  Checkpointing  Recovery</p>
    <p>Evaluation  Related work</p>
  </div>
  <div class="page">
    <p>Logging  Operation vs. value logging</p>
    <p>Operation logging: smaller log size</p>
    <p>Value logging: easier to parallelize recovery</p>
    <p>SiloR uses value logging</p>
  </div>
  <div class="page">
    <p>Logging Parallelism  Must use multiple disks</p>
    <p>single disks IO not enough  One logger per disk  Multiple workers for one logger</p>
  </div>
  <div class="page">
    <p>Logging structure W W W W</p>
    <p>L L</p>
  </div>
  <div class="page">
    <p>Logging structure W W W W</p>
    <p>L L</p>
  </div>
  <div class="page">
    <p>data.log</p>
    <p>Log rotation W W W W</p>
    <p>L L</p>
  </div>
  <div class="page">
    <p>Log rotation W W W W</p>
    <p>L L</p>
    <p>Log file renamed to old_data.e, where e is the largest epoch seen in that particular file.</p>
    <p>old_data.e</p>
    <p>data.log</p>
  </div>
  <div class="page">
    <p>Log rotation W W W W</p>
    <p>L L</p>
    <p>Log file renamed to old_data.e, where e is the largest epoch seen in that particular file.</p>
    <p>old_data.e</p>
    <p>data.log</p>
  </div>
  <div class="page">
    <p>Persistence epoch W W W W</p>
    <p>L L</p>
    <p>e1 e2 e3 e4</p>
    <p>eP = min {e1, e2, e3, e4} - 1 !</p>
    <p>all transactions in epochs &lt; eP are persistent</p>
  </div>
  <div class="page">
    <p>Persistence epoch W W W W</p>
    <p>L L</p>
    <p>e1 e2 e3 e4</p>
    <p>eP = min {e1, e2, e3, e4} - 1 !</p>
    <p>all transactions in epochs &lt;= eP are persistent</p>
  </div>
  <div class="page">
    <p>Silo Overview  SiloR Design!</p>
    <p>Logging  Checkpointing!  Recovery</p>
    <p>Evaluation  Related work</p>
  </div>
  <div class="page">
    <p>Parallel checkpointing</p>
    <p>Checkpoint happens regularly</p>
    <p>records</p>
    <p>index tree</p>
    <p>W W W W</p>
    <p>L LC C</p>
  </div>
  <div class="page">
    <p>Tree walk over a range of each table inconsistent checkpoint</p>
    <p>Only committed records in checkpoint</p>
    <p>Writes out to multiple files, enabling easy recovery parallelism</p>
    <p>C</p>
  </div>
  <div class="page">
    <p>Checkpoint  Checkpoint starts in epoch eL</p>
    <p>skips over records with TID.e such that e &gt;= eL!</p>
    <p>smaller checkpoints -&gt; smaller log -&gt; faster recovery</p>
    <p>Checkpoint ends in epoch eH!  waits until eH &gt;= eP  removes old_data.e log file where e &lt; eL</p>
  </div>
  <div class="page">
    <p>Checkpoint  Checkpoint starts in epoch eL</p>
    <p>skips over records with TID.e such that e &gt;= eL!</p>
    <p>smaller checkpoints -&gt; smaller log -&gt; faster recovery</p>
    <p>Checkpoint ends in epoch eH!  waits until eH &gt;= eP  removes old_data.e log file where e &lt; eL</p>
  </div>
  <div class="page">
    <p>Checkpoint  Checkpoint starts in epoch eL</p>
    <p>skips over records with TID.e such that e &gt;= eL!</p>
    <p>smaller checkpoints -&gt; smaller log -&gt; faster recovery</p>
    <p>Checkpoint ends in epoch eH!  usable once eH &lt;= eP  removes old_data.e log file where e &lt; eL</p>
  </div>
  <div class="page">
    <p>Silo Overview  SiloR Design!</p>
    <p>Logging  Checkpointing  Recovery!</p>
    <p>Evaluation  Related work</p>
  </div>
  <div class="page">
    <p>Recovery parallelism is easy because of our</p>
    <p>logging and checkpointing designs</p>
  </div>
  <div class="page">
    <p>RR R RR R</p>
    <p>Checkpoint recovery</p>
    <p>Easy parallelism: one checkpoint</p>
    <p>recovery thread per file</p>
  </div>
  <div class="page">
    <p>Log Recovery  Value logging enables log files to</p>
    <p>be played in any order  highest TID per key wins  Logs in later epochs replayed</p>
    <p>first  No log record from epoch &gt; ep is</p>
    <p>replayed</p>
  </div>
  <div class="page">
    <p>Log Recovery  Value logging enables log files to</p>
    <p>be played in any order  highest TID per key wins  logs in later epochs replayed first</p>
    <p>No log record from epoch &gt; ep is replayed</p>
  </div>
  <div class="page">
    <p>Log Recovery  Value logging enables log files to</p>
    <p>be played in any order  highest TID per key wins  logs in later epochs replayed first</p>
    <p>No log record from epoch &gt; ep is replayed</p>
  </div>
  <div class="page">
    <p>Silo Overview  SiloR Design</p>
    <p>Logging  Checkpointing  Recovery</p>
    <p>Evaluation!  Related work</p>
  </div>
  <div class="page">
    <p>Evaluation  Experiment setup</p>
    <p>single machine with four 8 core Intel Xeon E7-4830 processors (32 physical cores)</p>
    <p>machine has 256 GB of DRAM, 64 GB of DRAM attached to each socket</p>
    <p>4 disks: 3 Fusion IO drives, 1 RAID-5 disk array</p>
  </div>
  <div class="page">
    <p>Evaluation Goals  Can SiloR keep up with high</p>
    <p>transaction throughput from Silo?  Does recovery take no more than</p>
    <p>a few minutes for a large database?</p>
  </div>
  <div class="page">
    <p>Evaluation - YCSB-A  Key-value benchmark  400 million keys, 100 byte</p>
    <p>records  70% read, 30% write  28 workers, 4 loggers, 4</p>
    <p>checkpoint threads  Database does not grow</p>
  </div>
  <div class="page">
    <p>Evaluation - YCSB-A</p>
    <p>Avg throughput: 8.76 Mtxns/s, 9.01 Mtxns/s, 10.83 Mtxns/s</p>
  </div>
  <div class="page">
    <p>Recovery for YCSB-A Simulates crash right before the second checkpoint completes</p>
    <p>Recovered database Checkpoint Log Total</p>
    <p>Size 43.2 GB 36 GB 64 GB 100 GB</p>
    <p>Recovery time 33 s 73 s 106 s</p>
  </div>
  <div class="page">
    <p>Evaluation - TPC-C  TPC-C is a popular OLTP</p>
    <p>benchmark  28 workers, 4 loggers, 4</p>
    <p>checkpoint threads  Database size grows very fast  Checkpoint period also grows</p>
  </div>
  <div class="page">
    <p>Evaluation - TPC-C</p>
    <p>Avg throughput: 548 Ktxns/s, 575 Ktxns/s, 592 Ktxns/s</p>
  </div>
  <div class="page">
    <p>Recovery for TPC-C Simulates crash right before the fourth checkpoint completes</p>
    <p>Recovered tuples Checkpoint Log Total</p>
    <p>Size 72.2 GB 15.7 GB 180 GB 195.7 GB</p>
    <p>Recovery time 17 s 194 s 211 s</p>
  </div>
  <div class="page">
    <p>Evaluation conclusion</p>
    <p>Can SiloR keep up with high transaction throughput from Silo? Does recovery take no more than a few minutes for a large database?</p>
  </div>
  <div class="page">
    <p>Evaluation conclusion</p>
    <p>Can SiloR keep up with high transaction throughput from Silo? Does recovery take no more than a few minutes for a large database?</p>
  </div>
  <div class="page">
    <p>Silo Overview  SiloR Design</p>
    <p>Logging  Checkpointing  Recovery</p>
    <p>Evaluation  Related work</p>
  </div>
  <div class="page">
    <p>Related work (partial list)  VoltDB OLTP Recovery using</p>
    <p>command logging (ICDE 14): operation logging advantages</p>
    <p>Recovery on RAMCloud (SOSP 11): really fast recovery</p>
    <p>Fast checkpoint recovery on frequently consistent applications (SIGMOD 11)</p>
  </div>
  <div class="page">
    <p>Conclusion  Built a persistence system for a very</p>
    <p>fast multicore in-memory database  Used parallelism in all parts of the</p>
    <p>system to enable  small degradation in runtime</p>
    <p>performance  recovery of large database in a few</p>
    <p>minutes</p>
  </div>
  <div class="page">
    <p>Questions?</p>
  </div>
</Presentation>
