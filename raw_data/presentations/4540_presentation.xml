<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Motivations and declarative goals as cornerstones of autonomy Felipe Meneguzzi University of Southampton</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Background: Goal types AgentSpeak and Planning AgentSpeak Example: Production Cell Issues: Execution and Control Related Work: Motivations and Decl. Goals Future Work: Motivations and Planning</p>
  </div>
  <div class="page">
    <p>Background</p>
    <p>BDI Agents Procedural vs. Declarative Procedural Efficient, yet inflexible</p>
    <p>Predefined encapsulated behaviours Designer must foresee relevant plans</p>
    <p>Declarative Expressive, not trivial Desired world states Requires a more complex reasoning mechanism</p>
    <p>Beliefs</p>
    <p>Desires</p>
    <p>IntentionsReasoningPerception Action</p>
  </div>
  <div class="page">
    <p>AgentSpeak</p>
    <p>Based on Procedural Reasoning System Agent is described in terms of a plan library Plans are defined by:</p>
    <p>A trigger condition and a context A body containing the plan itself</p>
    <p>Events drive the adoption of plans</p>
  </div>
  <div class="page">
    <p>Example AgentSpeak Plan</p>
    <p>Event is generated First plan with a matching trigger condition and a valid context is adopted If the plan fails to finish, the goal has failed</p>
    <p>+!trigger : context</p>
    <p>!subgoal1; //calls plan action1; //does smth !subgoal2;</p>
    <p>action2; +belief1; //updates bel. -belief2.</p>
  </div>
  <div class="page">
    <p>Planning AgentSpeak</p>
    <p>Prototype developed using Jason Allows declarative goals to drive plan adoption</p>
    <p>Goals are satisfied using planning</p>
    <p>Allows dynamic plan generation Supported by a planning component</p>
    <p>Where Goals is a list representing a conjunction of goals</p>
    <p>+!des(Goals) : true</p>
    <p>plan(Goals).</p>
  </div>
  <div class="page">
    <p>Issues of Execution</p>
    <p>Failure handling Not integral to procedural plans</p>
    <p>Lookahead Agent selects and executes plans without looking at the outcome Bottlenecks may cause unnecessary failures</p>
    <p>Description size Increases significantly to allow flexibility</p>
  </div>
  <div class="page">
    <p>Issues of Control</p>
    <p>Choosing dynamic behaviours over predefined ones</p>
    <p>Currently, these decisions are hard-coded</p>
    <p>Controlling the amount of time spent on planning</p>
    <p>Placing reasonable bounds on planning effort</p>
  </div>
  <div class="page">
    <p>Example</p>
    <p>Production Cell 4 Processing Units Parts come in from the Feed Belt Must be processed by certain processing units</p>
    <p>Processing Unit 3</p>
    <p>Belt DepositFeed</p>
    <p>Belt</p>
    <p>Processing Unit 2</p>
    <p>Processing Unit 4</p>
    <p>Processing</p>
    <p>L1</p>
    <p>Unit 1</p>
  </div>
  <div class="page">
    <p>Declarative vs Procedural</p>
    <p>+!finish(Block) : Block = block1 &lt;- +des([processed(Block,procUnit1),</p>
    <p>processed(Block,procUnit2), processed(Block,procUnit3), finished(Block)]).</p>
    <p>+!finish(Block) : Block = block2 &lt;- +des([processed(Block,procUnit2),</p>
    <p>processed(Block,procUnit4), finished(Block)]).</p>
    <p>+!finish(Block) : Block = block3 &lt;- +des([processed(Block,procUnit1),</p>
    <p>processed(Block,procUnit3), finished(Block)]).</p>
    <p>+!process(Block, ProcUnit) : over(Block, ProcUnit) &lt;- +processed(Block, ProcUnit).</p>
    <p>+!consume(Block) : over(Block,depositBelt) &lt;- -over(Block, depositBelt); +empty(depositBelt);</p>
    <p>+finished(Block).</p>
    <p>+!move(Block, Device1, Device2) : over(Block,Device1) &amp; empty(Device2)</p>
    <p>&lt;- +over(Block, Device2); -over(Block, Device1); -empty(Device2); +empty(Device1).</p>
    <p>+over(Block, feedBelt) : true &lt;-!finish(Block).</p>
    <p>+!finish(Block) : Block = block1 &lt;- !process(Block,procUnit1); !process(Block,procUnit2);</p>
    <p>!process(Block,procUnit3);!move(Block,procUnit3,dep ositBelt); !consume(Block).</p>
    <p>+!finish(Block) : Block = block2 &lt;- !process(Block,procUnit2); !process(Block,procUnit4);</p>
    <p>!move(Block,procUnit4,depositBelt); !consume(Block).</p>
    <p>+!finish(Block) : Block = block3 &lt;- !process(Block,procUnit1); !process(Block,procUnit3);</p>
    <p>!move(Block,procUnit3,depositBelt); !consume(Block).</p>
    <p>+!process(Block, ProcUnit) : not over(Block,ProcUnit) &amp; empty(ProcUnit) &amp; over(Block,Device)</p>
    <p>&lt;- !move(Block,Device,ProcUnit); !process(Block,ProcUnit).</p>
    <p>+!process(Block,ProcUnit) : over(Block,ProcUnit) &lt;- +processed(Block,ProcUnit).</p>
    <p>+!consume(Block) : over(Block,depositBelt) &lt;- -over(Block,depositBelt); +empty(depositBelt);</p>
    <p>+finished(Block).</p>
    <p>+!move(Block, Device1, Device2) : over(Block,Device1) &amp; empty(Device2)</p>
    <p>&lt;- +over(Block,Device2); -over(Block,Device1); -empty(Device2); +empty(Device1).</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>Motivations Often used by biological systems Provide a plan selection mechanism</p>
    <p>Declarative Goals Decouple goal achievement from actions Means-ends reasoning link current state to desired goal</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Planning as an enabler for declarative goals Balance dynamic and static behaviours Multiagent planning</p>
    <p>Motivations as a control mechanism for Planning effort Agent interaction</p>
  </div>
  <div class="page">
    <p>Motivations and declarative goals as cornerstones of autonomy Felipe Rech Meneguzzi University of Southampton</p>
  </div>
</Presentation>
