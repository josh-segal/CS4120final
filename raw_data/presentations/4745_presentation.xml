<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>PODC 2008 1</p>
    <p>Distributed Computation of the Mode</p>
    <p>Fabian Kuhn Thomas Locher</p>
    <p>ETH Zurich, Switzerland</p>
    <p>Stefan Schmid TU Munich, Germany</p>
  </div>
  <div class="page">
    <p>PODC 2008 2</p>
    <p>General Trend in Information Technology</p>
    <p>New Applications and System Paradigms</p>
    <p>Large-scale Distributed Systems</p>
    <p>Centralized Systems</p>
    <p>Networked Systems</p>
    <p>Internet</p>
  </div>
  <div class="page">
    <p>PODC 2008 3</p>
    <p>Distributed Data</p>
    <p>Earlier: Data stored on a central sever</p>
    <p>Today: Data distributed over network (e.g. distributed databases, sensor networks)</p>
    <p>Typically: Data stored where it occurs</p>
    <p>Nevertheless: Need to query all / large portion of data</p>
    <p>Methods for distributed aggregation needed</p>
  </div>
  <div class="page">
    <p>PODC 2008 4</p>
    <p>Model</p>
    <p>Network given by a graph G=(V,E)</p>
    <p>Nodes: Network devices, Edges: Communication links</p>
    <p>Data stored at the nodes  For simplicity: each node has exactly one data item / value</p>
    <p>Query initiated at some node</p>
    <p>Compute result of query by sending around (small) messages</p>
  </div>
  <div class="page">
    <p>PODC 2008 5</p>
    <p>Simple Aggregation Functions</p>
    <p>Simple aggregation functions: 1 convergecast on spanning tree (simple: algebraic, distributive e.g.: min, max, sum, avg, )</p>
    <p>On BFS tree: time complexity = O(D) (D = diameter)</p>
    <p>k independent simple functions:</p>
    <p>Time O(D+k) by using pipelining</p>
  </div>
  <div class="page">
    <p>PODC 2008 6</p>
    <p>The Mode</p>
    <p>Mode = most frequent element</p>
    <p>Every node has an element from {1,,K}</p>
    <p>k different elements e1,,ek, frequencies: m1  m2    mk (k and mi are not known to algorithm)</p>
    <p>Goal: Find mode = element occuring m1 times</p>
    <p>Per message: 1 element, O(log n + log K) additional bits</p>
  </div>
  <div class="page">
    <p>PODC 2008 7</p>
    <p>Mode: Simple Algorithm</p>
    <p>Send all elements to root, aggregate frequencies along the way</p>
    <p>Using pipelining, time O(D+k)  Always send smallest element first to avoid empty queues</p>
    <p>For almost uniform frequency distributions, algorithm is optimal</p>
    <p>Goal: Fast algorithm if frequency distribution is good (skewed)</p>
  </div>
  <div class="page">
    <p>PODC 2008 8</p>
    <p>Mode: Basic Idea</p>
    <p>Assume, nodes have access to common random hash functions h1, h2,  where hi: {1,,K}  {-1,+1}</p>
    <p>Apply hi to all elements:</p>
    <p>hi</p>
    <p>element e1, hi(e1)=-1</p>
    <p>m1 m2</p>
    <p>m4 m3 m5</p>
    <p>+1-1</p>
    <p>element e2, hi(e2)=+1 element e3, hi(e3)=+1 element e4, hi(e4)=-1 element e5, hi(e5)=-1</p>
  </div>
  <div class="page">
    <p>PODC 2008 9</p>
    <p>Mode: Basic Idea</p>
    <p>Intuition: bin containing mode tends to be larger</p>
    <p>Introduce counter ci for each element ei</p>
    <p>Go through hash functions h1, h2,</p>
    <p>Function hj: Increment ci by number of elements in bin hj(ei)</p>
    <p>Intuition: counter c1 of mode will be largest after some time</p>
  </div>
  <div class="page">
    <p>PODC 2008 10</p>
    <p>Compare Counters</p>
    <p>Compare counters c1 and c2 of elements e1 and e2</p>
    <p>If hj(e1) = hj(e2), c1 and c2 increased by same amount</p>
    <p>Consider only j for which hj(e1) hj(e2)</p>
    <p>Change in c1  c2 difference:</p>
    <p>where</p>
    <p>m1  m2  P k i=3 X i;j</p>
    <p>Pr(X i;j = +mi) = Pr(X i;j =  mi) = 1=2</p>
  </div>
  <div class="page">
    <p>PODC 2008 11</p>
    <p>Counter Difference</p>
    <p>Given indep. Z1, , Zn, Pr(Zi=i)=Pr(Zi=-i)=1/2</p>
    <p>Chernoff:</p>
    <p>H: set of hash function with hj(e1) hj(e2), |H|=s</p>
    <p>Pr</p>
    <p>@ nX</p>
    <p>i=1 Zi  t</p>
    <p>v u u t</p>
    <p>nX</p>
    <p>i=1 2i</p>
    <p>A  e t 2=2</p>
    <p>Pr(c1  c2) = Pr</p>
    <p>B @</p>
    <p>X</p>
    <p>hj 2H</p>
    <p>kX</p>
    <p>i=3 X i;j  s(m1  m2)</p>
    <p>C A</p>
    <p>e  s2(m1 m2)</p>
    <p>s(m1 m2)</p>
  </div>
  <div class="page">
    <p>PODC 2008 12</p>
    <p>Counter Difference</p>
    <p>is called the 2nd frequency moment</p>
    <p>Can make the same for all other counters:</p>
    <p>If hj(e1) hj(ei) for s hash fct.:</p>
    <p>hj(e1) hj(ei) for roughly 1/2 of all hash functions</p>
    <p>After considering O(F2/(m1m2) 2log n) hash functions:</p>
    <p>c1 largest counter w.h.p.</p>
    <p>Pr(c1  ci) &lt; e  s(m1 mi)</p>
    <p>F2 = P k i=1 m</p>
  </div>
  <div class="page">
    <p>PODC 2008 13</p>
    <p>Distributed Implementation</p>
    <p>Assume, nodes know hash functions</p>
    <p>Bin sizes for each hash function: time O(D) (simply a sum)</p>
    <p>Update counter in time O(D) (root broadcasts bin sizes)</p>
    <p>We can pipeline computations for different hash functions</p>
    <p>Algorithm with time complexity:</p>
    <p>only good if m1-m2 large</p>
    <p>O  D + F2</p>
    <p>(m1 m2)2 logn</p>
  </div>
  <div class="page">
    <p>PODC 2008 14</p>
    <p>Improvement</p>
    <p>Only apply algorithm until w.h.p., c1 &gt; ci if m1  2mi</p>
    <p>Time:</p>
    <p>Apply simple deterministic algorithm for remaining elements</p>
    <p>#elements ei with m1  2mi: at most 4F2/m1 2</p>
    <p>Time of second phase:</p>
    <p>O</p>
    <p>D + F2 (m1</p>
    <p>m1 2 )</p>
    <p>!</p>
    <p>= O  D + F2</p>
    <p>m21 logn</p>
    <p>O  D + F2</p>
    <p>m21</p>
  </div>
  <div class="page">
    <p>PODC 2008 15</p>
    <p>Improved Algorithm</p>
    <p>Many details missing (in particular: need to know F2, m1)</p>
    <p>Can be done (F2: use ideas from [Alon,Matias,Szegedy 1999])</p>
    <p>If nodes have access to common random hash functions:</p>
    <p>Mode can be computed in time</p>
    <p>O  D + F2</p>
    <p>m21 logn</p>
  </div>
  <div class="page">
    <p>PODC 2008 16</p>
    <p>Random Hash Functions</p>
    <p>Still need mechanism that provides random hash functions</p>
    <p>Select functions in advance (hard-wired into alg):  algorithm does not work for all input distributions</p>
    <p>Choosing random hash function h : [K]  {-1,+1} requires sending O(K) bits  we want messages of size O(log K + log n)</p>
  </div>
  <div class="page">
    <p>PODC 2008 17</p>
    <p>Quasi-Random Hash Functions</p>
    <p>Fix set H of hash functions s.t. |H|= O(poly(n,K)) such that H satisfies a set of uniformity conditions</p>
    <p>Choosing random hash function from H requires only O(log n + log K) bits.</p>
    <p>Show that algorithm still works if hash functions are from a set H that satisfies uniformity conditions</p>
  </div>
  <div class="page">
    <p>PODC 2008 18</p>
    <p>Quasi-Random Hash Functions</p>
    <p>Possible to give a set of uniformity conditions that allow to prove that algorithm still works (quite involved)</p>
    <p>Using probabilistic method:</p>
    <p>Show that a set H of size O(poly(n,K)) satisfying uniformity conditions exists.</p>
  </div>
  <div class="page">
    <p>PODC 2008 19</p>
    <p>Distributed Computation of the Mode</p>
    <p>Lower bound based on generalization (by Alon et. al.) of set disjointness communication complexity lower bound by Razborov</p>
    <p>Theorem: The mode can be computed in time O(D+F2/m1</p>
    <p>Theorem: The time needed to compute the mode by a distributed algorithm is at least</p>
    <p>(D+F5/(m15log n)).</p>
    <p>Theorem: The time needed to compute the mode by a distributed algorithm is at least</p>
    <p>(D+F5/(m15log n)).</p>
  </div>
  <div class="page">
    <p>PODC 2008 20</p>
    <p>Related Work</p>
    <p>Paper by Charikar, Chen, Farach-Colton: Finds element with frequency (1-)m1 in a streaming model with a different method</p>
    <p>It turns out:</p>
    <p>Basic techniques of Charikar et. al. can be applied in distributed case</p>
    <p>Our techniques can be applied in streaming model</p>
    <p>Both techniques yield same results in both cases</p>
  </div>
  <div class="page">
    <p>PODC 2008 21</p>
    <p>Conclusions:</p>
    <p>Obvious open problem: Close gap between upper and lower bound</p>
    <p>We believe: Upper bound is tight</p>
    <p>Proving that upper bound is tight would probably also prove a conjecture in [Alon,Matias,Szegedy 1999] regarding the space complexity of the computation of frequency moments in streaming models.</p>
  </div>
  <div class="page">
    <p>PODC 2008 22</p>
    <p>Questions?</p>
  </div>
</Presentation>
