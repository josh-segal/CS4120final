<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Verified Correctness and Security of OpenSSL HMAC</p>
    <p>Adam Petcher</p>
    <p>Princeton</p>
    <p>Research supported by DARPA HACMS &amp; Google ATAP</p>
    <p>Lennart Beringer, Katherine Ye, Andrew W. Appel</p>
    <p>Harvard MIT</p>
  </div>
  <div class="page">
    <p>Recently in the news</p>
    <p>Wired.com, July 21st, 2015</p>
  </div>
  <div class="page">
    <p>Also</p>
    <p>Wired.com, July 21st, 2015</p>
    <p>gas pumps</p>
    <p>medical devices</p>
    <p>skateboards</p>
    <p>sniper rifles</p>
    <p>cargo tracking systems</p>
  </div>
  <div class="page">
    <p>Recently in the news</p>
    <p>Wired.com, July 21st, 2015</p>
    <p>One lesson: dont accept (control) messages unless they are properly authenticated!</p>
  </div>
  <div class="page">
    <p>Symmetric-key authentication</p>
    <p>This talk: hash-based message authentication (HMAC) Keying Hash Functions for Message Authentication, Mihir Bellare, Ran Canetti, Hugo Krawczyk, Crypto 96</p>
  </div>
  <div class="page">
    <p>FIPS 198</p>
  </div>
  <div class="page">
    <p>FIPS-198: functional specification</p>
    <p>Inputs/outputs given as sequences of bytes  length of Data: unconstrained  length of Key: unconstrained, but normalization/padding</p>
    <p>to suit hash function (SHA-256)  length of output: same as output of hash function  ipad, opad: fixed-size constants</p>
  </div>
  <div class="page">
    <p>What could go wrong?</p>
    <p>Is HMAC a PRF (assuming SHA256 is a PRF) ? Cryptographers may have made a mistake in the proof.</p>
  </div>
  <div class="page">
    <p>What could go wrong?</p>
    <p>Is HMAC a PRF (assuming SHA256 is a PRF) ? Cryptographers may have made a mistake in the proof.</p>
    <p>Does FIPS-198-HMAC enjoy the same crypto-properties? Authors of FIPS may have accidentally introduced a mistake, or made additional/different assumptions</p>
  </div>
  <div class="page">
    <p>What could go wrong?</p>
    <p>Is HMAC a PRF (assuming SHA256 is a PRF) ? Cryptographers may have made a mistake in the proof.</p>
    <p>Does FIPS-198-HMAC enjoy the same crypto-properties? Authors of FIPS may have accidentally introduced a mistake, or made additional/different assumptions</p>
    <p>Does a C implementation of HMAC compute the correct function ? Implementors may have missed some subtle aspect of FIPS-198or FIPS-180 for SHA</p>
  </div>
  <div class="page">
    <p>What could go wrong?</p>
    <p>Is HMAC a PRF (assuming SHA256 is a PRF) ? Cryptographers may have made a mistake in the proof.</p>
    <p>Does FIPS-198-HMAC enjoy the same crypto-properties? Authors of FIPS may have accidentally introduced a mistake, or made additional/different assumptions</p>
    <p>Does a C implementation of HMAC compute the correct function ? Implementors may have missed some subtle aspect of FIPS-198</p>
    <p>Does the C implementation perform additional memory access operations? Implementors may have made programming mistakes.</p>
  </div>
  <div class="page">
    <p>What could go wrong?</p>
    <p>Is HMAC a PRF (assuming SHA256 is a PRF) ? Cryptographers may have made a mistake in the proof.</p>
    <p>Does FIPS-198-HMAC enjoy the same crypto-properties? Authors of FIPS may have accidentally introduced a mistake, or made additional/different assumptions</p>
    <p>Does a C implementation of HMAC compute the correct function ? Implementors may have missed some subtle aspect of FIPS-198</p>
    <p>Does the C implementation perform additional memory access operations? Implementors may have made programming mistakes.</p>
    <p>Did the implementor and the compiler writer agree on what C is?</p>
  </div>
  <div class="page">
    <p>What could go wrong?</p>
    <p>Is HMAC a PRF (assuming SHA256 is a PRF) ? Cryptographers may have made a mistake in the proof.</p>
    <p>Does FIPS-198-HMAC enjoy the same crypto-properties? Authors of FIPS may have accidentally introduced a mistake, or made additional/different assumptions</p>
    <p>Does a C implementation of HMAC compute the correct function ? Implementors may have missed some subtle aspect of FIPS-198</p>
    <p>Does the C implementation perform additional memory access operations? Implementors may have made programming mistakes.</p>
    <p>Did the implementor and the compiler writer agree on what C is?</p>
    <p>Is the compiler correct?</p>
  </div>
  <div class="page">
    <p>What could go wrong?</p>
    <p>Is HMAC a PRF (assuming SHA256 is a PRF) ? Cryptographers may have made a mistake in the proof.</p>
    <p>Does FIPS-198-HMAC enjoy the same crypto-properties? Authors of FIPS may have accidentally introduced a mistake, or made additional/different assumptions</p>
    <p>Does a C implementation of HMAC compute the correct function ? Implementors may have missed some subtle aspect of FIPS-198</p>
    <p>Does the C implementation perform additional memory access operations? Implementors may have made programming mistakes.</p>
    <p>Did the implementor and the compiler writer agree on what C is?</p>
    <p>Is the compiler correct?</p>
    <p>Whats the compilers view of the processor? Side channels: timing, caches, memory model,</p>
  </div>
  <div class="page">
    <p>Machine-checked functional and cryptographic correctness</p>
    <p>Correctness of C code w.r.t. functional specification Cryptographic verification Memory safety, nonleakage, and integrity (VST) Compiler correctness w.r.t. a formal processor model</p>
  </div>
  <div class="page">
    <p>FIPS-198: transcription into Coq</p>
    <p>Inputs/outputs given as (Coq) lists of (mathematical) values</p>
    <p>Definition NormAndPad k := zeropad (if |k| &gt; 64 then SHA-256 k else k).</p>
    <p>Definition HASH l m := SHA-256 (l++m).</p>
    <p>Definition HmacCore m k := HASH (opad  k) (HASH (ipad  k) m)</p>
    <p>Definition HMAC256 (m k : list Z) : list Z := let key = map Byte.repr (NormAndPad k) in HmacCore m key</p>
    <p>executable inside Coq, and extractable to Ocaml</p>
    <p>amenable to mathematical reasoning inside Coq</p>
    <p>Specification function HMAC256 is</p>
  </div>
  <div class="page">
    <p>Implementation: OpenSSL*</p>
    <p>Client-visible data structure Incremental API</p>
    <p>Intuitive protocol:</p>
    <p>* Statically linked version -- modern versions use envelopes (home-brew object system), engines</p>
    <p>struct HMAC_CTX { SHA_CTX md_ctx; SHA_CTX iSha; SHA_CTX oSha; unsigned int key_len; unsigned char key[64];</p>
    <p>} // assumed stack allocated // hence no alloc function</p>
    <p>void HMAC_Init (HMAC_CTX c, unsigned char *k, int len); //initialize iSha/oSha with PaddedKey XOR ipad/opad if //needed, copy the former into md_ctx</p>
    <p>void HMAC_Update(HMAC_CTX c, const void *data, int len); //hash data onto md_ctx, ie to inner sha</p>
    <p>void HMAC_Final(HMAC_CTX c, unsigned char *md); //finish md_ctx (inner sha), memcpy result to temp, copy //oSha to md_ctx, hash temp onto it &amp; finish it, //return result in md</p>
    <p>void HMAC_Cleanup(HMAC_CTX c); //memset entire struct to 0</p>
    <p>unsigned char *HMAC(,k,klen,data,dlen,md); //create local HMC_CTX c, call above functions in order</p>
    <p>init</p>
    <p>update</p>
    <p>update</p>
    <p>final</p>
    <p>init cleanup</p>
    <p>hmac</p>
    <p>redundant</p>
  </div>
  <div class="page">
    <p>Linking the C program to the functional specification in Coq (I)</p>
    <p>Coq data type matching HMAC_CTX:</p>
    <p>struct HMAC_CTX { SHA_CTX md_ctx; SHA_CTX iSha; SHA_CTX oSha}</p>
    <p>Inductive HMAC-ABS := hmacabs: s256ABS s256ABS s256ABS HMAC-ABS.</p>
    <p>Step 1: Model the incremental API in Coq</p>
  </div>
  <div class="page">
    <p>Definition init (key:list Z) (h:HMAC-ABS):Prop :=  sha_init</p>
    <p>Definition update (data:list Z) (h1 h2:HMAC-ABS):Prop := sha_update</p>
    <p>Definition final (h:HMAC-ABS) (mac: list Z):Prop:=  sha_finish</p>
    <p>Relations characterizing incremental functions: relations for incremental sha</p>
    <p>Coq data type matching HMAC_CTX:</p>
    <p>struct HMAC_CTX { SHA_CTX md_ctx; SHA_CTX iSha; SHA_CTX oSha}</p>
    <p>Inductive HMAC-ABS := hmacabs: s256ABS s256ABS s256ABS HMAC-ABS.</p>
    <p>Linking the C program to the functional specification in Coq (II)</p>
    <p>Step 1: Model the incremental API in Coq</p>
  </div>
  <div class="page">
    <p>Definition init (key:list Z) (h:HMAC-ABS):Prop :=  sha_init</p>
    <p>Definition update (data:list Z) (h1 h2:HMAC-ABS):Prop := sha_update</p>
    <p>Definition finish (h:HMAC-ABS) (mac: list Z):Prop:=  sha_finish</p>
    <p>Relations characterizing incremental functions:</p>
    <p>Lemma : init key h /\ update data h h1 /\ final h1 mac mac = HMAC256 data key. Proof.  Qed.</p>
    <p>relations for incremental sha</p>
    <p>Coq data type matching HMAC_CTX:</p>
    <p>struct HMAC_CTX { SHA_CTX md_ctx; SHA_CTX iSha; SHA_CTX oSha}</p>
    <p>Inductive HMAC-ABS := hmacabs: s256ABS s256ABS s256ABS HMAC-ABS.</p>
    <p>Linking the C program to the functional specification in Coq (III)</p>
    <p>Step 1: Model the incremental API in Coq</p>
  </div>
  <div class="page">
    <p>Linking the C program to the functional specification in Coq (IV)</p>
    <p>Step 2: VST specifications for all functions, referencing the abstract model</p>
    <p>Representation predicates in Separation logic</p>
    <p>Definition hmacState := shaState * shaState * shaState</p>
    <p>Definition hmacRelate (h:HMAC-ABS) (r:hmacState) := (*  shaRelate on mdCtxt, iSha, Osha components *)</p>
    <p>Definition hmacRep (h:HMAC-ABS) (c:val) := EX r:hmacState, !!hmacRelate h r &amp;&amp; data_at HMAC_CTX r c.</p>
    <p>SL predicate</p>
    <p>Link with repr in Coq</p>
    <p>Repr of CTX as C values</p>
  </div>
  <div class="page">
    <p>Representation predicates in Separation logic</p>
    <p>Definition hmacState := shaState * shaState * shaState</p>
    <p>Definition hmacRelate (h:HMAC-ABS) (r:hmacState) := (*  shaRelate on mdCtxt, iSha, Osha components *)</p>
    <p>Definition hmacRep (h:HMAC-ABS) (c:val) := EX r:hmacState, !!hmacRelate h r &amp;&amp; data_at HMAC_CTX r c.</p>
    <p>SL predicate</p>
    <p>Link with repr in Coq</p>
    <p>Repr of CTX as C values</p>
    <p>Hoare-style specification with pre- and post-conditions</p>
    <p>Definition Update-spec :=DECLARE _UPDATE WITH h c data d PRE [ ]</p>
    <p>PROP() LOCAL() SEP( hmacRep h c, data_block data d) POST [ returnType ]</p>
    <p>EX h1, PROP(update data h h1) LOCAL() SEP( hmacRep h1 c , data_block data d).</p>
    <p>Linking the C program to the functional specification in Coq (V)</p>
    <p>Step 2: VST specifications for all functions, referencing the abstract model</p>
  </div>
  <div class="page">
    <p>API-specification of HMAC function</p>
    <p>Definition HMAC256-spec := DECLARE _HMAC WITH kp: val, key:DATA, KV:val; mp: val, msg:DATA, shmd: share, md: val PRE [ _key OF tptr tuchar, _keylen OF tint, _d OF tptr tuchar,</p>
    <p>_n OF tint, _md OF tptr tuchar ] PROP(writable share shmd; has lengthK (LEN key) (CONT key);</p>
    <p>has lengthD 512 (LEN msg) (CONT msg)) LOCAL(temp _md md; temp _key kp; temp _d mp; temp _n (Vint (Int.repr (LEN msg)));</p>
    <p>temp _keylen (Vint (Int.repr (LEN key))); gvar _K256 KV) SEP(`(data-block Tsh (CONT key) kp); `(data-block Tsh (CONT msg) mp);</p>
    <p>`(K-vector KV);`(memory-block shmd (Int.repr 32) md)) POST [ tvoid ] PROP() LOCAL() SEP(`(K-vector KV); `(data-block shmd (HMAC256 (CONT msg) (CONT key)) md);</p>
    <p>`(data-block Tsh (CONT key) kp); `(data-block Tsh (CONT msg) mp)).</p>
    <p>Result here</p>
    <p>Key preserved Message</p>
    <p>preserved</p>
  </div>
  <div class="page">
    <p>Code verification</p>
    <p>Current proof state</p>
    <p>Proof script</p>
    <p>proof tactic</p>
    <p>code</p>
    <p>precondition</p>
    <p>Interactively apply the rules of VST logic, using forward symbolic execution</p>
  </div>
  <div class="page">
    <p>Cryptographic soundness</p>
  </div>
  <div class="page">
    <p>Foundational Cryptography Framework (FCF)</p>
    <p>Probabilistic programming language implemented in Coq, with a means for sampling uniformly random bit vectors</p>
    <p>Library of distributions, lemmas for bounding differences between events etc  Game-based crypto proofs: adversary tries to tell oracles apart by interacting</p>
    <p>Adversary</p>
    <p>Oracle 1 (pseudorandom function)? Oracle 2 (HMAC)?</p>
    <p>Q?</p>
    <p>A!</p>
    <p>Reduction of HMAC to hash function (SHA): probability of adversary A to separate HMAC from PRF is determined by probability of adversary B1 to separate HASHFUNCTION from PRF (assumed hard).</p>
    <p>Theorem HMAC-PRF:</p>
    <p>PRF-Advantage ({0, 1}^b) ({0, 1}^c) HMAC A &lt;=</p>
    <p>PRF-Advantage ({0, 1}^c) ({0, 1}^c) HASHFUNCTION B1</p>
    <p>+  (other terms) + .</p>
    <p>Proof.  Qed.</p>
    <p>Bellare-style: bit-oriented, NMAC-based, iterative,</p>
  </div>
  <div class="page">
    <p>Bridging the crypto gap</p>
    <p>Coq program (FCF version)</p>
    <p>Coq program HMAC256</p>
    <p>Bits versus Bytes Padding (use of SHAblocks versus byte-list)</p>
    <p>Vector versus lists (Coq)</p>
    <p>Exposure of MerkleDamgard: iterative use of keyed hash function</p>
    <p>Instantiation of parameters (hash function, ipad/opad,)</p>
    <p>Specialization to SHA256</p>
  </div>
  <div class="page">
    <p>Discussion</p>
    <p>Not covered:  timing &amp; other side channel attacks  security-preserving compilation  appropriateness of cryptographic bounds  Protocols, OS correctness,</p>
    <p>No specification gaps proofs possible across multiple abstraction layers: intermediate specs are NOT in TCB</p>
    <p>Interactive proof assistants sufficiently mature</p>
    <p>Domain-specific reasoning support helps automation</p>
    <p>Verification of other cryptoprimitives in progress use of C -&gt; other tools still apply</p>
    <p>verification of existing, open-source code: existing analyses still valid</p>
  </div>
  <div class="page">
    <p>Discussion</p>
    <p>Not covered:  timing &amp; other side channel attacks  security-preserving compilation  appropriateness of cryptographic bounds  Protocols, OS correctness,</p>
    <p>No specification gaps proofs possible across multiple abstraction layers: intermediate specs are NOT in TCB</p>
    <p>Interactive proof assistants sufficiently mature</p>
    <p>Domain-specific reasoning support helps automation</p>
    <p>Verification of other cryptoprimitives in progress use of C -&gt; other tools still apply</p>
    <p>verification of existing, open-source code: existing analyses still valid</p>
  </div>
</Presentation>
