<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Vale: Verifying High-Performance Cryptographic Assembly Code</p>
    <p>Barry Bond1, Chris Hawblitzel1, Manos Kapritsos2, K. Rustan M. Leino1, Jacob R. Lorch1, Bryan Parno3, Ashay Rane4, Srinath Setty1, Laure Thompson5</p>
  </div>
  <div class="page">
    <p>Cryptography for Information Security</p>
    <p>Strong cryptography is critical for security in various domains.</p>
    <p>Web traffic Data at rest Cryptocurrency</p>
  </div>
  <div class="page">
    <p>Cryptographic Implementation Requirements</p>
    <p>Difficult to meet all three goals.</p>
    <p>Correct control flow and free from leakage</p>
    <p>and side channels</p>
    <p>Fast</p>
    <p>Platform-agnostic &amp; platform-specific</p>
    <p>optimizations</p>
    <p>Correct</p>
    <p>Formally prove that implementation</p>
    <p>matches specification</p>
    <p>Secure</p>
  </div>
  <div class="page">
    <p>Verified but slow crypto implementations</p>
    <p>Fast but non-verified crypto implementations</p>
    <p>Result: Crypto implementations usually fall into one of two camps.</p>
  </div>
  <div class="page">
    <p>Perf gap</p>
    <p>Verified implementations</p>
    <p>Non-verified implementation</p>
    <p>OpenSSL HACL* [ePrint 15] Appel et al.</p>
    <p>[ACM TOPLAS 15]</p>
  </div>
  <div class="page">
    <p>sub BODY_00_15 { $code .= &lt;&lt;END #if __ARM_ARCH__&gt;=7 @ ldr $t1,[$inp],#4 #if $i==15 ... #endif END }</p>
    <p>C macros for code specialization</p>
    <p>C macros for target instruction selection</p>
    <p>OpenSSL Performance Tricks</p>
    <p>Assembly code is a Perl string</p>
    <p>Mix of ASM + Perl</p>
  </div>
  <div class="page">
    <p>@V = (r4, r5, r6, r7, r8, r9, r10, r11);</p>
    <p>for ($i=0; $i&lt;16; $i++) { &amp;BODY_00_15($i, @V); unshift(@V, pop(@V)); }</p>
    <p>Perl variables for register names</p>
    <p>OpenSSL Performance Tricks</p>
    <p>Code expansion using loops</p>
    <p>Register selection using Perl arrays</p>
  </div>
  <div class="page">
    <p>sub BODY_00_15 { my ($i,$a,$b,$c,$d,$e,$f,$g,$h) = @_; $code.=&lt;&lt;END if ($i&lt;16); #if __ARM_ARCH__&gt;=7</p>
    <p>@ ldr $t1,[$inp],#4 # if $i==15</p>
    <p>str $inp,[sp,#17*4] # endif</p>
    <p>eor $t0,$e,$e,ror#`$Sigma1[1]-$Sigma1[0]` add $a,$a,$t2 eor $t0,$t0,$e,ror#`$Sigma1[2]-$Sigma1[0]`</p>
    <p># ifndef __ARMEB__ rev $t1,$t1</p>
    <p># endif #else</p>
    <p>@ ldrb $t1,[$inp,#3] add $a,$a,$t2 ldrb $t2,[$inp,#2] ldrb $t0,[$inp,#1] orr $t1,$t1,$t2,lsl#8 ldrb $t2,[$inp],#4 orr $t1,$t1,$t0,lsl#16</p>
    <p># if $i==15 str $inp,[sp,#17*4]</p>
    <p># endif eor $t0,$e,$e,ror#`$Sigma1[1]-$Sigma1[0]` orr $t1,$t1,$t2,lsl#24 eor $t0,$t0,$e,ror#`$Sigma1[2]-$Sigma1[0]` @</p>
    <p>Sigma1(e) #endif END</p>
    <p>Result: Code becomes difficult to understand, debug, and formally verify for correctness and security.</p>
  </div>
  <div class="page">
    <p>Flexible framework for writing high-performance, proven correct and secure assembly code.</p>
    <p>Our Contribution: Vale</p>
    <p>Correct Secure Fast</p>
  </div>
  <div class="page">
    <p>Vale is a work in progress. Not a complete replacement to OpenSSL.</p>
    <p>Flexible Syntax</p>
    <p>Vale supports constructs for expressing functionality as</p>
    <p>well as optimizations.</p>
    <p>High Assurance</p>
    <p>Vale can be used to prove functional correctness and correct information flow.</p>
    <p>High Performance</p>
    <p>Code generated by Vale matches or exceeds</p>
    <p>OpenSSLs performance.</p>
    <p>Our Contribution: Vale</p>
    <p>Flexible framework for writing high-performance, proven correct and secure assembly code.</p>
  </div>
  <div class="page">
    <p>Key Language Constructs in Vale</p>
    <p>Structured Control Flow</p>
    <p>e.g. if, while, and procedure</p>
    <p>Enable proof composition</p>
    <p>Vary according to the target platform</p>
    <p>Assembly Instructions</p>
    <p>e.g. Mov, Rev, and AesKeygenAssist</p>
    <p>Optimization Constructs</p>
    <p>Customize code generation</p>
  </div>
  <div class="page">
    <p>Optimization Using inline if Statements</p>
    <p>Vale supports inline if statements, which are evaluated during code generation, not during code execution.</p>
    <p>Useful for selecting instructions and for unrolling loops.</p>
    <p>inline if(platform == x86_AESNI) { ... }</p>
    <p>Target Instruction Selection (Platform-dependent optimization)</p>
    <p>inline if (n &gt; 0) { ... recurse(n - 1); }</p>
    <p>Loop Unrolling (Platform-independent optimization)</p>
  </div>
  <div class="page">
    <p>Example Vale Code</p>
    <p>procedure Incr_By_N(inline n:nat) { inline if (n &gt; 0) { ADD(r5, r5, 1); Incr_By_N(n - 1); } }</p>
    <p>Incr_By_N(100);</p>
    <p>Example Vale Code</p>
  </div>
  <div class="page">
    <p>ADD(r5, r5, 1) ADD(r5, r5, 1) ADD(r5, r5, 1) ADD(r5, r5, 1)</p>
    <p>...</p>
    <p>Total 100 ADD instructions</p>
    <p>Example Vale Code</p>
    <p>Expanded Vale AST</p>
    <p>procedure Incr_By_N(inline n:nat) { inline if (n &gt; 0) { ADD(r5, r5, 1); Incr_By_N(n - 1); } }</p>
    <p>Incr_By_N(100);</p>
    <p>Example Vale Code</p>
  </div>
  <div class="page">
    <p>add r5, r5, 1 add r5, r5, 1 add r5, r5, 1 add r5, r5, 1</p>
    <p>...</p>
    <p>Total 100 ADD instructions</p>
    <p>Example Vale Code</p>
    <p>Generated Assembly Code</p>
    <p>procedure Incr_By_N(inline n:nat) { inline if (n &gt; 0) { ADD(r5, r5, 1); Incr_By_N(n - 1); } }</p>
    <p>Incr_By_N(100);</p>
    <p>Example Vale Code</p>
  </div>
  <div class="page">
    <p>Code generated by Vale matches or</p>
    <p>exceeds OpenSSLs performance.</p>
    <p>Cryptographic Implementation Requirements</p>
    <p>Fast</p>
  </div>
  <div class="page">
    <p>Cryptographic Implementation Requirements</p>
    <p>Correct</p>
    <p>Fast</p>
    <p>Code generated by Vale matches or</p>
    <p>exceeds OpenSSLs performance.</p>
  </div>
  <div class="page">
    <p>Proof Assistant</p>
    <p>Vale Architecture</p>
    <p>Vale Tool</p>
    <p>AST + Proofs</p>
    <p>Crypto Specification</p>
    <p>Verified? (Yes / No)</p>
    <p>Crypto code in Vale language</p>
    <p>Lemmas</p>
    <p>Machine Semantics (x86, x64, ARMv7)</p>
  </div>
  <div class="page">
    <p>Dafny Verifier (based on Z3 solver)</p>
    <p>Vale Architecture</p>
    <p>Vale Tool</p>
    <p>AST + Proofs</p>
    <p>Crypto Specification</p>
    <p>Verified? (Yes / No)</p>
    <p>Crypto code in Vale language</p>
    <p>Lemmas</p>
    <p>Machine Semantics (x86, x64, ARMv7)</p>
    <p>Or any other proof assistant e.g. Coq, ACL2, Lean, F*</p>
  </div>
  <div class="page">
    <p>Vale Architecture</p>
    <p>Vale Tool</p>
    <p>AST + Proofs</p>
    <p>Crypto Specification</p>
    <p>Crypto code in Vale language</p>
    <p>Lemmas</p>
    <p>Assembly Printer</p>
    <p>Assembly Code</p>
    <p>Assembler (e.g. GAS / MASM)</p>
    <p>AST</p>
    <p>Machine Semantics (x86, x64, ARMv7)</p>
    <p>Verified? (Yes / No)</p>
    <p>Dafny Verifier (based on Z3 solver)</p>
  </div>
  <div class="page">
    <p>Vale Tool</p>
    <p>AST + Proofs</p>
    <p>Machine Semantics (x86, x64, ARMv7)</p>
    <p>Crypto Specification</p>
    <p>Crypto code in Vale language</p>
    <p>Lemmas</p>
    <p>Assembly Printer</p>
    <p>Assembler (e.g. GAS / MASM)</p>
    <p>Handwritten Libraries</p>
    <p>Trusted Components</p>
    <p>Verified Components</p>
    <p>Untrusted Components</p>
    <p>Verified? (Yes / No)</p>
    <p>Dafny Verifier (based on Z3 solver)</p>
  </div>
  <div class="page">
    <p>{p} C {q}</p>
  </div>
  <div class="page">
    <p>procedure Incr_By_N(inline n:nat) requires r5+n &lt; 0x1_0000_0000</p>
    <p>{ inline if (n &gt; 0) { ADD(r5, r5, 1); Incr_By_N(n - 1); } }</p>
    <p>Example Vale Code</p>
    <p>Pre-Conditions requires keyword</p>
    <p>{p} C {q}</p>
  </div>
  <div class="page">
    <p>procedure Incr_By_N(inline n:nat) requires r5+n &lt; 0x1_0000_0000 ensures r5 == old(r5) + n</p>
    <p>{ inline if (n &gt; 0) { ADD(r5, r5, 1); Incr_By_N(n - 1); } }</p>
    <p>Example Vale Code</p>
    <p>Pre-Conditions requires keyword</p>
    <p>Post-Conditions ensures keyword</p>
    <p>{p} C {q}</p>
  </div>
  <div class="page">
    <p>procedure Incr_By_N(inline n:nat) requires r5+n &lt; 0x1_0000_0000 ensures r5 == old(r5) + n modifies r5 { inline if (n &gt; 0) { ADD(r5, r5, 1); Incr_By_N(n - 1); } }</p>
    <p>Example Vale Code</p>
    <p>Pre-Conditions requires keyword</p>
    <p>Post-Conditions ensures keyword</p>
    <p>State Manipulation modifies keyword</p>
    <p>{p} C {q}</p>
    <p>Code is verified before expansion of inline-if statement.</p>
  </div>
  <div class="page">
    <p>Cryptographic Implementation Requirements</p>
    <p>Correct</p>
    <p>Vale supports assertions that are checked by Dafny</p>
    <p>Fast</p>
    <p>Code generated by Vale matches or</p>
    <p>exceeds OpenSSLs performance.</p>
  </div>
  <div class="page">
    <p>Cryptographic Implementation Requirements</p>
    <p>Correct</p>
    <p>Vale supports assertions that are checked by Dafny</p>
    <p>Secure (Leakage Free)</p>
    <p>Fast</p>
    <p>Code generated by Vale matches or</p>
    <p>exceeds OpenSSLs performance.</p>
  </div>
  <div class="page">
    <p>Secrets should not leak through:</p>
    <p>Digital Side Channels: Observations of program behavior through cache usage, timing, memory accesses, etc.</p>
    <p>Residual Program State: Secrets left in registers or memory after termination of program</p>
    <p>Secret Information Leakage</p>
  </div>
  <div class="page">
    <p>Secrets should not leak through:</p>
    <p>Digital Side Channels: Observations of program behavior through cache usage, timing, memory accesses, etc.</p>
    <p>Secret Information Leakage</p>
    <p>Crypto Program</p>
    <p>Secret Input</p>
    <p>Output</p>
    <p>Public Input</p>
    <p>Should NOT be correlated</p>
    <p>Side Channel Observations</p>
  </div>
  <div class="page">
    <p>Information Leakage Specification</p>
    <p>Crypto Program</p>
    <p>Secret #1</p>
    <p>Digital Side Channel Observations #1</p>
    <p>Crypto Program</p>
    <p>Secret #2</p>
    <p>Digital Side Channel Observations #2</p>
    <p>Public Inputs</p>
    <p>=</p>
    <p>Based on Non-Interference</p>
  </div>
  <div class="page">
    <p>Information Leakage Specification</p>
    <p>Based on Non-Interference</p>
    <p>Formally, for a crypto program C,</p>
    <p>pairs of secrets s1 and s2  public values p, obs(C, p, s1) = obs(C, p, s2)</p>
  </div>
  <div class="page">
    <p>AST Analyzer</p>
    <p>(in the Dafny language)</p>
    <p>AST</p>
    <p>Specification</p>
    <p>Proof</p>
    <p>Output (Yes / No)</p>
    <p>Solution: Verified Analysis</p>
    <p>One-Time Verification</p>
    <p>Trustworthy Output (because of proof)</p>
  </div>
  <div class="page">
    <p>Verified Leakage Analyzer</p>
    <p>Leakage Free? (Yes / No)</p>
    <p>Verified Leakage Analysis</p>
    <p>AES AST / Poly-1305 AST / SHA-256 AST</p>
  </div>
  <div class="page">
    <p>procedure foo(public :nat, secret :nat) { // r5 := secret + 1 ADD(r5, secret, 1);</p>
    <p>if (r5 &lt; 10) { bar(); } }</p>
    <p>Step 1: Developer marks regs and mem that contain non-secret information.</p>
    <p>Leakage Analysis Using Taint Tracking</p>
  </div>
  <div class="page">
    <p>procedure foo(public :nat, secret :nat) { // r5 := secret + 1 ADD(r5, secret, 1);</p>
    <p>if (r5 &lt; 10) { bar(); } }</p>
    <p>Step 1: Developer marks regs and mem that contain non-secret information.</p>
    <p>Step 2: Analysis conservatively assumes that all other locations contain secrets.</p>
    <p>Leakage Analysis Using Taint Tracking</p>
  </div>
  <div class="page">
    <p>procedure foo(public :nat, secret :nat) { // r5 := secret + 1 ADD(r5, secret, 1);</p>
    <p>if (r5 &lt; 10) { bar(); } }</p>
    <p>Step 1: Developer marks regs and mem that contain non-secret information.</p>
    <p>Step 2: Analysis conservatively assumes that all other locations contain secrets.</p>
    <p>Step 3: Analysis tracks secrets through registers and memory locations.</p>
    <p>Leakage Analysis Using Taint Tracking</p>
  </div>
  <div class="page">
    <p>procedure foo(public :nat, secret :nat) { // r5 := secret + 1 ADD(r5, secret, 1);</p>
    <p>if (r5 &lt; 10) { bar(); } }</p>
    <p>Leakage Analysis Using Taint Tracking</p>
    <p>Step 1: Developer marks regs and mem that contain non-secret information.</p>
    <p>Step 2: Analysis conservatively assumes that all other locations contain secrets.</p>
    <p>Step 3: Analysis tracks secrets through registers and memory locations.</p>
    <p>Step 4: Report violation if secret used in branch predicate, memory address, or as input to variable-latency instruction.</p>
  </div>
  <div class="page">
    <p>store [rbx] &lt;- 0</p>
    <p>load rcx &lt;- [rbx]</p>
    <p>store [rbx] &lt;- 0</p>
    <p>store [rax] &lt;- 10</p>
    <p>load rcx &lt;- [rbx]</p>
    <p>Problems Caused by Aliasing</p>
    <p>Does rcx contain 0 or 10?</p>
    <p>Difficult to answer without knowing whether rax = rbx.</p>
  </div>
  <div class="page">
    <p>Alias Analysis is a Difficult Problem</p>
    <p>Existing alternatives:</p>
    <p>Vale is uniquely suited to use a different approach:</p>
    <p>Reuse developers effort from proof of correctness.</p>
  </div>
  <div class="page">
    <p>Functional verification requires precisely identifying information flow.</p>
    <p>Reusing Effort from Proof of Correctness</p>
    <p>store [rbx] &lt;- 0</p>
    <p>store [rax] &lt;- 10</p>
    <p>load output &lt;- [rbx]</p>
    <p>To prove that output = 0 and not 10, developer should prove that rax  rbx.</p>
    <p>output should be equal to 0</p>
    <p>Specification Implementation</p>
  </div>
  <div class="page">
    <p>Vale requires the developer to mark memory operands that contain secrets:</p>
    <p>Easy for developer since proving correctness requires identifying all information flows.</p>
    <p>Since these annotations are checked by the verifier, they are untrusted.</p>
    <p>Lightweight Annotations for Memory Taint</p>
    <p>load rax &lt;- [rdx] @secret</p>
  </div>
  <div class="page">
    <p>Cryptographic Implementation Requirements</p>
    <p>Correct</p>
    <p>Vale supports assertions that are checked by Dafny</p>
    <p>Secure</p>
    <p>Vale checks for leakage via state and digital side channels.</p>
    <p>Fast</p>
    <p>Code generated by Vale matches or</p>
    <p>exceeds OpenSSLs performance.</p>
  </div>
  <div class="page">
    <p>Case Studies Using Vale</p>
    <p>Using Vale, we developed four verified cryptographic programs:</p>
    <p>After fixing the issues, all four programs were proved correct and secure using Vale.</p>
    <p>Discovered leakage on stack.</p>
    <p>Confirmed a previously known bug.</p>
  </div>
  <div class="page">
    <p>Some of OpenSSLs optimizations were automatically proved by Dafny.</p>
    <p>Key Lessons</p>
  </div>
  <div class="page">
    <p>Vale versus OpenSSL: SHA-256</p>
    <p>x64 assembly code</p>
    <p>Throughput (KBps)</p>
  </div>
  <div class="page">
    <p>Vale versus OpenSSL: Poly-1305</p>
    <p>Throughput (MBps)</p>
  </div>
  <div class="page">
    <p>Vale versus OpenSSL: AES-CBC-128</p>
    <p>AES-NI assembly code</p>
    <p>Throughput (MBps)</p>
  </div>
  <div class="page">
    <p>Vale Leakage Analysis AES CBC Poly1305 1st SHA SHA Port</p>
    <p>Verification Effort In person-months</p>
    <p>Tool Development</p>
    <p>Crypto Implementations</p>
  </div>
  <div class="page">
    <p>The Big Picture: Project Everest Goal: Build and deploy a verified HTTPS stack.</p>
    <p>Untrusted Network (TCP, UDP) 49</p>
    <p>TLS</p>
    <p>Crypto Algorithms (RSA, ECDH, SHA, etc.)</p>
    <p>HTTPS</p>
    <p>X.509</p>
    <p>Network Buffers</p>
    <p>ASN.1</p>
    <p>Servers Clients P2P</p>
    <p>Vales contribution</p>
  </div>
  <div class="page">
    <p>The Big Picture: Project Everest</p>
    <p>Research Goals:</p>
    <p>Prove the security of new protocols.</p>
    <p>Make verified systems as fast as unverified systems.</p>
    <p>Defend against advanced threats such as side channels.</p>
    <p>Make verification accessible to non-experts.</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Vale is a framework for generating and verifying crypto implementation that is correct, secure, and fast for arbitrary architectures.</p>
    <p>Vales flexible syntax allows writing assembly code that OpenSSL expresses using ad-hoc Perl scripts, C preprocessor macros, and custom interpreters.</p>
    <p>Vale supports verified analysis of code, e.g., information leakage analysis.</p>
    <p>Vale demonstrates that verified code can be as fast as highly-optimized, unverified code.</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Verify other crypto implementations and components in the HTTPS stack.</p>
    <p>Build Vale on top of other proof assistants. Ongoing work on using F*.</p>
  </div>
  <div class="page">
    <p>Vale</p>
    <p>A flexible framework for writing high-performance, proven correct, and proven secure assembly code.</p>
    <p>https://github.com/project-everest/vale https://project-everest.github.io</p>
  </div>
</Presentation>
