<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Egalitarian Computing</p>
    <p>Alex Biryukov Dmitry Khovratovich</p>
    <p>University of Luxembourg</p>
    <p>August 10th, 2016</p>
  </div>
  <div class="page">
    <p>Attack-defence paradigm</p>
    <p>Attackers have always been more powerful than defenders:</p>
    <p>Large and variable resources;  One weakness is sufficient;  Can spend much time.</p>
  </div>
  <div class="page">
    <p>Attack-defence paradigm</p>
    <p>Defenders can</p>
    <p>Harden the protection (e.g. increase the key length);  Sometimes restrict the attack vector (e.g. limit the exposure</p>
    <p>time).</p>
    <p>Secure cryptographic algorithm with sufficient key length  solution for many confidentiality, integrity, signatures, etc..</p>
    <p>Sometimes, however, we do not have (long) keys.</p>
    <p>Reliance on human memory (password-based data protection, password-based authentication, PINs, etc.);</p>
    <p>Brute-force attacks become possible (e.g., guess a PIN).</p>
  </div>
  <div class="page">
    <p>Attack-defence paradigm</p>
    <p>Defenders can</p>
    <p>Harden the protection (e.g. increase the key length);  Sometimes restrict the attack vector (e.g. limit the exposure</p>
    <p>time).</p>
    <p>Secure cryptographic algorithm with sufficient key length  solution for many confidentiality, integrity, signatures, etc..</p>
    <p>Sometimes, however, we do not have (long) keys.</p>
    <p>Reliance on human memory (password-based data protection, password-based authentication, PINs, etc.);</p>
    <p>Brute-force attacks become possible (e.g., guess a PIN).</p>
  </div>
  <div class="page">
    <p>Understanding brute-force</p>
    <p>Brute-force attacks (such as key guessing) are most efficient on custom hardware: multiple computing cores on large ASICs.</p>
    <p>Practical example of SHA-2 hashing (Bitcoin):</p>
    <p>232 hashes/joule on ASIC;  217 hashes/joule on laptop.</p>
    <p>Consequences</p>
    <p>Keys lose 15 bits;  Passwords become 3 lowercase letters shorter;  PINs lose 5 digits.</p>
    <p>ASIC-equipped attackers are the threat from the near future.</p>
    <p>ASICs have high entry costs, but FPGA and GPU are employed too.</p>
  </div>
  <div class="page">
    <p>Understanding brute-force</p>
    <p>Brute-force attacks (such as key guessing) are most efficient on custom hardware: multiple computing cores on large ASICs.</p>
    <p>Practical example of SHA-2 hashing (Bitcoin):</p>
    <p>232 hashes/joule on ASIC;  217 hashes/joule on laptop.</p>
    <p>Consequences</p>
    <p>Keys lose 15 bits;  Passwords become 3 lowercase letters shorter;  PINs lose 5 digits.</p>
    <p>ASIC-equipped attackers are the threat from the near future.</p>
    <p>ASICs have high entry costs, but FPGA and GPU are employed too.</p>
  </div>
  <div class="page">
    <p>We need to slow down such attackers without burdening the defenders.</p>
  </div>
  <div class="page">
    <p>Solution</p>
    <p>Since 2003, memory-intensive computations have been proposed.</p>
    <p>Computing with a lot of memory would require a very large and expensive chip.</p>
    <p>Memory</p>
    <p>Core</p>
    <p>With large memory on-chip, the ASIC advantage vanishes.</p>
  </div>
  <div class="page">
    <p>Time-space tradeoffs and memory-hardness</p>
    <p>Clearly, there should be no memoryless equivalent (thus memory-hardness).</p>
    <p>Time-space tradeoff: how time grows if space is reduced.</p>
    <p>Time</p>
    <p>Space</p>
    <p>Normal computation</p>
    <p>S</p>
    <p>T</p>
    <p>T = f (1/S).</p>
    <p>Linear f means equal trading of space for time. We want f to be superpolynomial.</p>
  </div>
  <div class="page">
    <p>Earlier work: Argon2</p>
    <p>Making the password cracking more expensive. Argon2 [BK16]  memory-hard hash function, winner of the Password Hashing Competition:</p>
    <p>p lanes</p>
    <p>Password</p>
    <p>Salt</p>
    <p>Context H H</p>
    <p>Tag</p>
    <p>Exponential time growth if space reduced: log T = 1 S</p>
    <p>.</p>
  </div>
  <div class="page">
    <p>Earlier work: Equihash</p>
    <p>Memory-hard proof-of-work with fast verification [BK16], used in Zcash. Generalized birthday problem[Wagner02]: given seed I , find V and {xj} such that</p>
    <p>H(I||V ||x1) H(I||V ||x2) H(I||V ||x2k ) = 0. (1) where H is Blake2b</p>
    <p>I</p>
    <p>A Wagners algorithm</p>
    <p>H Difficulty filter</p>
    <p>V</p>
    <p>(x1, x2, . . .)</p>
    <p>n, k</p>
    <p>for 2k-XOR</p>
    <p>?</p>
    <p>x86/GPU-oriented 700-MB proof is 120 bytes long and 2 seconds to find.</p>
    <p>Apparently, any NP-complete problem is a natural candidate for a memory-hard proof-of-work...</p>
  </div>
  <div class="page">
    <p>Egalitarian computing</p>
  </div>
  <div class="page">
    <p>Why egalitarian</p>
    <p>Bitcoin dream</p>
    <p>An egalitarian currency where every user could mine money on his own laptop...</p>
    <p>...and reality:</p>
    <p>A bunch of users with factory-size rigs and their own power plants control &gt; 50% of network in a single pool.</p>
  </div>
  <div class="page">
    <p>Why egalitarian</p>
    <p>Bitcoin dream</p>
    <p>An egalitarian currency where every user could mine money on his own laptop...</p>
    <p>...and reality:</p>
    <p>A bunch of users with factory-size rigs and their own power plants control &gt; 50% of network in a single pool.</p>
  </div>
  <div class="page">
    <p>Slowing brute-force</p>
    <p>Argon2 made password hashing more secure by ensuring that both defenders and attackers hash passwords on the same platform (x86).</p>
    <p>It is desirable to slow down brute force on custom hardware in:</p>
    <p>Password-based protocols (key agreement, secret sharing);  Password-based encryption;  Proofs of work for cryptocurrencies/blockchain;  Client puzzles for denial-of-service protection.</p>
  </div>
  <div class="page">
    <p>Egalitarian computing</p>
    <p>Egalitarian computing ensures that legitimate users and attackers are equal as they are forced to use the same platform.</p>
  </div>
  <div class="page">
    <p>How?</p>
    <p>Suppose you develop a scheme where the exact output value is not important (encryption, signature, etc.).</p>
    <p>Amalgamate the computation with a memory-hard function such as Argon2.</p>
    <p>If you already use some CPU time, why not using the available memory for that period?</p>
  </div>
  <div class="page">
    <p>Alteration</p>
    <p>Alter the computing: inject memory-hard blocks in between the subfunction calls.</p>
    <p>Argon2</p>
    <p>h1 h2 hT</p>
    <p>In Out</p>
    <p>h1 h2 hT</p>
    <p>In Out</p>
    <p>Maybe even feed them back to Argon2 (may need stregthening the compression function).</p>
  </div>
  <div class="page">
    <p>Approach 2: obfuscation</p>
    <p>Obfuscate the computing with bi  memory-hard bit (extracted from the Argon2-filled memory):</p>
    <p>Original if x then A</p>
    <p>else B</p>
    <p>Obfuscated for bi = 0 if x bi then A</p>
    <p>else B for bi = 1 if x bi then B</p>
    <p>else A</p>
    <p>Memory-hard bits can be built into opaque predicates and other obfuscation tools.</p>
  </div>
  <div class="page">
    <p>Memory-hard encryption</p>
  </div>
  <div class="page">
    <p>Disk encryption</p>
    <p>Password-based disk encryption: process chunks of data with a password-derived key. Attack:</p>
    <p>Obtain an encryption of a chunk.  Decrypt a small block (16 bytes for AES) of the chunk;  Check if the plaintext has sufficient redundancy.</p>
    <p>Problem: trial decryption requires only a few blockcipher calls. Even if you use Argon2 for key derivation, the keys can still be precomputed on a memory-rich device. The trial decryption can be done memoryless on custom hardware using only a small amount of ciphertext.</p>
  </div>
  <div class="page">
    <p>Stregthening disk encryption</p>
    <p>Earlier proposal [Zaverucha15] with All-or-Nothing transform [Rivest97]:</p>
    <p>Chunk is decryptable in two passes;  It must be fully decrypted and kept in memory;  Memory size is the chunk length.</p>
    <p>We use a memory-hard function to make encryption and decryption run on the same hardware and non-outsourceable.</p>
  </div>
  <div class="page">
    <p>Memory-hard encryption</p>
    <p>Disk encryption with memory-hard function also based on ANT or another scheme without online decryption:</p>
    <p>pwd H</p>
    <p>H K1</p>
    <p>random</p>
    <p>m1</p>
    <p>C1</p>
    <p>E</p>
    <p>C2</p>
    <p>m2</p>
    <p>K0</p>
    <p>H</p>
    <p>C1 C2 Cq+1</p>
    <p>Argon2</p>
    <p>header body</p>
    <p>K1 K1</p>
    <p>K0 K0</p>
    <p>ECB E</p>
    <p>ECB</p>
    <p>E CBC</p>
    <p>E CBC</p>
    <p>E CBC</p>
    <p>Any chunk size;  Any memory size;  No way to precompute either part.</p>
  </div>
  <div class="page">
    <p>Memory-hard encryption</p>
    <p>Disk encryption with memory-hard function also based on ANT or another scheme without online decryption:</p>
    <p>pwd H</p>
    <p>H K1</p>
    <p>random</p>
    <p>m1</p>
    <p>C1</p>
    <p>E</p>
    <p>C2</p>
    <p>m2</p>
    <p>K0</p>
    <p>H</p>
    <p>C1 C2 Cq+1</p>
    <p>Argon2</p>
    <p>header body</p>
    <p>K1 K1</p>
    <p>K0 K0</p>
    <p>ECB E</p>
    <p>ECB</p>
    <p>E CBC</p>
    <p>E CBC</p>
    <p>E CBC</p>
    <p>If E is AES, we can fill 4-6x more memory at the same time. Even more: encryption of 1-MB chunk in 0.1 second can use 256 MB of RAM.</p>
  </div>
  <div class="page">
    <p>Egalitarian proofs-of-work</p>
  </div>
  <div class="page">
    <p>Proof-of-work</p>
    <p>PoW  certificate of having certain computation performed. Used in competitive consensus protocols (Bitcoin) and as a DoS protection (e.g., TLS). Necessary properties:</p>
    <p>Bitcoins Hashcash misses 3,4; Equihash misses 6 and have problems with 4,7. Proofs-of-Space lack 2,3.</p>
  </div>
  <div class="page">
    <p>Proof-of-space + difficulty test</p>
    <p>Memory-hash function does not work alone: too hard verification.</p>
    <p>P</p>
    <p>Memory-hard</p>
    <p>nonce</p>
    <p>H</p>
    <p>d leading zeros?</p>
    <p>N</p>
    <p>Proof-of-space + difficulty test? Proof: (P, , block openings).</p>
    <p>Positions to verify</p>
    <p>PH</p>
    <p>d leading zeros?</p>
    <p>N</p>
    <p>nonce</p>
  </div>
  <div class="page">
    <p>Proof-of-space + difficulty test</p>
    <p>Memory-hash function does not work alone: too hard verification.</p>
    <p>P</p>
    <p>Memory-hard</p>
    <p>nonce</p>
    <p>H</p>
    <p>d leading zeros?</p>
    <p>N</p>
    <p>Proof-of-space + difficulty test? Proof: (P, , block openings).</p>
    <p>Positions to verify</p>
    <p>PH</p>
    <p>d leading zeros?</p>
    <p>N</p>
    <p>nonce</p>
  </div>
  <div class="page">
    <p>Grinding attack</p>
    <p>In proof-of-space + difficulty test modify the last block until the test is passed  so no amortization-free.</p>
    <p>PH</p>
    <p>d leading zeros?</p>
    <p>N</p>
    <p>nonce</p>
    <p>cheat!</p>
  </div>
  <div class="page">
    <p>MTP: memory-hard proof-of-work based on Argon2</p>
    <p>The PC-oriented 2 GB-proof is 180 KB long (faster but longer than Equihash).</p>
    <p>I</p>
    <p>Argon2</p>
    <p>Merkle tree</p>
    <p>N</p>
    <p>H</p>
    <p>Nonce</p>
    <p>i1</p>
    <p>H</p>
    <p>i1</p>
    <p>iL</p>
    <p>H</p>
    <p>iL</p>
    <p>Y</p>
    <p>d trailing zeros? No Yes</p>
    <p>Open 2L blocks</p>
    <p>Compute Argon2;  Select a nonce;  Derive opening block indices</p>
    <p>from the nonce and the Merkle root.</p>
    <p>Check for difficulty. If fail, select a new nonce.</p>
    <p>Parallelism inevitable but memory use is intensive and random.</p>
    <p>Using Argon2 tradeoffs, MTP on ASICs can have AT cost reduced by at most 12.</p>
  </div>
  <div class="page">
    <p>New world</p>
    <p>Egalitarian computing</p>
    <p>deems 6-letter passwords secure;</p>
    <p>brings back 80-bit keys;</p>
    <p>renders DoS attacks harder;</p>
    <p>suffrages blockchain users.</p>
    <p>It is a chance to revert Moores law.</p>
  </div>
  <div class="page">
    <p>God may have made men, but Samuel Colt made them equal</p>
    <p>Use Egalitarian Computing</p>
  </div>
</Presentation>
