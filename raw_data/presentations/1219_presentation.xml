<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>SplinterDB: Closing the NVMe Bandwidth Gap</p>
    <p>Alex Conway Vijay Chidambaram Martin Farach-Colton</p>
    <p>Abihsihek Gupta Richard Spillane</p>
    <p>Amy Tai Rob Johnson</p>
    <p>ATC 2020</p>
  </div>
  <div class="page">
    <p>SplinterDB: A Key-Value Store for</p>
    <p>the Hard Cases</p>
  </div>
  <div class="page">
    <p>Key-Value Stores</p>
    <p>Our Approach</p>
    <p>Use new data structures to lower IO amplification and CPU overhead while enabling concurrency</p>
    <p>Fast Storage</p>
    <p>Whats hard?</p>
  </div>
  <div class="page">
    <p>Key-Value Stores</p>
    <p>Our Approach</p>
    <p>Use new data structures to lower IO amplification and CPU overhead while enabling concurrency</p>
    <p>Keep key-value pairs sorted and packed into data blocks, delay merging as much as possible</p>
    <p>Fast Storage</p>
    <p>Small Key-Value Pairs</p>
    <p>Whats hard?</p>
  </div>
  <div class="page">
    <p>Key-Value Stores</p>
    <p>Our Approach</p>
    <p>Use new data structures to lower IO amplification and CPU overhead while enabling concurrency</p>
    <p>Make all data structures swappable in order to gracefully degrade under cache pressure</p>
    <p>Keep key-value pairs sorted and packed into data blocks, delay merging as much as possible</p>
    <p>Fast Storage</p>
    <p>Small Key-Value Pairs</p>
    <p>Small Cache</p>
    <p>Whats hard?</p>
  </div>
  <div class="page">
    <p>In this talk</p>
    <p>SplinterDB</p>
    <p>Data Structures</p>
    <p>Fast Storage (NVMe)</p>
    <p>Flush-then-Compact</p>
  </div>
  <div class="page">
    <p>Flush-then-Compact</p>
    <p>In this talk</p>
    <p>SplinterDB</p>
    <p>Data Structures</p>
    <p>Fast Storage (NVMe)</p>
  </div>
  <div class="page">
    <p>Back in the day</p>
    <p>People used to use</p>
  </div>
  <div class="page">
    <p>Back in the day</p>
    <p>People used to use</p>
    <p>Slide rules</p>
  </div>
  <div class="page">
    <p>Back in the day</p>
    <p>People used to use</p>
    <p>Slide rulesVHS tapes</p>
  </div>
  <div class="page">
    <p>Back in the day</p>
    <p>People used to use</p>
    <p>Slide rules Fountain pens</p>
    <p>VHS tapes</p>
  </div>
  <div class="page">
    <p>Back in the day</p>
    <p>People used to use</p>
    <p>Slide rules Fountain pens</p>
    <p>VHS tapes</p>
    <p>Different Performance</p>
    <p>models</p>
  </div>
  <div class="page">
    <p>Back in the day</p>
    <p>People used to use</p>
    <p>Slide rules Fountain pens</p>
    <p>VHS tapes</p>
    <p>Different Performance</p>
    <p>models IOCPU</p>
  </div>
  <div class="page">
    <p>Back in the day</p>
    <p>People used to use</p>
    <p>Different Performance</p>
    <p>models IOCPU</p>
    <p>Look at e.g. key-value stores</p>
  </div>
  <div class="page">
    <p>Back in the day</p>
    <p>People used to use</p>
    <p>Different Performance</p>
    <p>models IOCPU</p>
    <p>Look at e.g. key-value stores</p>
    <p>hash tables</p>
    <p>BSTs</p>
  </div>
  <div class="page">
    <p>Back in the day</p>
    <p>People used to use</p>
    <p>Different Performance</p>
    <p>models IOCPU</p>
    <p>Look at e.g. key-value stores</p>
    <p>hash tables</p>
    <p>BSTs</p>
    <p>B-trees</p>
    <p>LSMs</p>
    <p>B-trees</p>
  </div>
  <div class="page">
    <p>Back in the day</p>
    <p>People used to use</p>
    <p>Different Performance</p>
    <p>models IOCPU</p>
    <p>Ran dom</p>
    <p>Seq uen</p>
    <p>tial</p>
    <p>HDD 200M</p>
    <p>Cycles per 64b word at bandwidth</p>
    <p>Hard Drive</p>
    <p>HDD 120</p>
  </div>
  <div class="page">
    <p>Back in the day</p>
    <p>People used to use</p>
    <p>Different Performance</p>
    <p>models IOCPU</p>
    <p>Ran dom</p>
    <p>Seq uen</p>
    <p>tial</p>
    <p>SSD</p>
    <p>SSD 100K</p>
    <p>SSD 30</p>
    <p>Cycles per 64b word at bandwidth</p>
    <p>HDD 200M</p>
    <p>HDD 120</p>
  </div>
  <div class="page">
    <p>Back in the day</p>
    <p>People used to use</p>
    <p>Different Performance</p>
    <p>models IOCPU</p>
    <p>Ran dom</p>
    <p>Seq uen</p>
    <p>tial</p>
    <p>NVMe</p>
    <p>SSD 100K</p>
    <p>SSD 30</p>
    <p>NVMe 20K</p>
    <p>NVMe 6</p>
    <p>Cycles per 64b word at bandwidth</p>
    <p>HDD 200M</p>
    <p>HDD 120</p>
  </div>
  <div class="page">
    <p>Back in the day</p>
    <p>People used to use</p>
    <p>Different Performance</p>
    <p>models IOCPU</p>
    <p>Ran dom</p>
    <p>Seq uen</p>
    <p>tial</p>
    <p>NVMe</p>
    <p>SSD 100K</p>
    <p>SSD 30</p>
    <p>NVMe 20K</p>
    <p>NVMe 6</p>
    <p>Cycles per 64b word at bandwidth</p>
    <p>HDD 200M</p>
    <p>HDD 120</p>
    <p>For NVMe, need data structures to optimize both</p>
  </div>
  <div class="page">
    <p>Back in the day</p>
    <p>People used to use</p>
    <p>Different Performance</p>
    <p>models IOCPU</p>
    <p>Ran dom</p>
    <p>Seq uen</p>
    <p>tial</p>
    <p>NVMe</p>
    <p>SSD 100K</p>
    <p>SSD 30</p>
    <p>NVMe 20K</p>
    <p>NVMe 6</p>
    <p>Cycles per 64b word at bandwidth</p>
    <p>HDD 200M</p>
    <p>HDD 120</p>
    <p>For NVMe, need data structures to optimize both</p>
    <p>Write Amplification</p>
    <p>Work Amplification</p>
  </div>
  <div class="page">
    <p>Flush-then-Compact</p>
    <p>In this talk</p>
    <p>SplinterDB</p>
    <p>Data Structures</p>
    <p>Fast Storage (NVMe)</p>
  </div>
  <div class="page">
    <p>SplinterDB</p>
    <p>SplinterDB is a key-value store which handles these tough cases:</p>
    <p>Fast Storage</p>
    <p>Small Key-Value Pairs</p>
    <p>Small Cache</p>
  </div>
  <div class="page">
    <p>SplinterDB</p>
    <p>SplinterDB is a key-value store which handles these tough cases:</p>
    <p>Fast Storage</p>
    <p>Small Key-Value Pairs</p>
    <p>Small Cache</p>
  </div>
  <div class="page">
    <p>SplinterDB</p>
    <p>SplinterDB is a key-value store which handles these tough cases:</p>
    <p>Fast Storage</p>
    <p>Small Key-Value Pairs</p>
    <p>Small Cache</p>
  </div>
  <div class="page">
    <p>SplinterDB</p>
    <p>SplinterDB is a key-value store which handles these tough cases:</p>
    <p>Size-Tiered B-Tree</p>
  </div>
  <div class="page">
    <p>SplinterDB</p>
    <p>SplinterDB is a key-value store which handles these tough cases:</p>
    <p>Reducing Work</p>
    <p>Size-Tiered B-Tree</p>
  </div>
  <div class="page">
    <p>SplinterDB</p>
    <p>SplinterDB is a key-value store which handles these tough cases:</p>
    <p>Reducing Work</p>
    <p>ConcurrencySize-Tiered B-Tree</p>
  </div>
  <div class="page">
    <p>How Does SplinterDB Perform?</p>
  </div>
  <div class="page">
    <p>RocksDB is a high performance embedded database for key-value data. It is a fork</p>
    <p>of LevelDB by Facebook optimized to exploit many central processing unit (CPU) cores, and</p>
    <p>make efficient use of fast storage, such as solid-state drives (SSD),</p>
    <p>for input/output (I/O) bound workloads.</p>
    <p>State of the Art: RocksDB</p>
    <p>RocksDB</p>
    <p>Released 2012, LevelDB traces back to 2004</p>
    <p>Built and maintained by full-time engineering team</p>
    <p>Continuous performance improvements</p>
  </div>
  <div class="page">
    <p>SplinterDB Performance</p>
    <p>Small KV-pairs</p>
    <p>Small cache (using cgroup)</p>
    <p>Intel Optane 905P</p>
    <p>Block-addressable NVMe</p>
  </div>
  <div class="page">
    <p>SplinterDB Performance</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut in</p>
    <p>f O pe</p>
    <p>ra tio</p>
    <p>ns /</p>
    <p>S ec</p>
    <p>on d</p>
    <p>Insertions Lookups</p>
    <p>SplinterDB RocksDB</p>
    <p>(YCSB Run C)</p>
    <p>Basic Operation Throughput</p>
    <p>H ig</p>
    <p>h e r</p>
    <p>is B</p>
    <p>e tt</p>
    <p>e r</p>
    <p>YCSB Load - uniform</p>
    <p>Small KV-pairs</p>
    <p>Small cache (using cgroup)</p>
    <p>Intel Optane 905P</p>
    <p>Block-addressable NVMe</p>
  </div>
  <div class="page">
    <p>SplinterDB Performance</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut in</p>
    <p>f O pe</p>
    <p>ra tio</p>
    <p>ns /</p>
    <p>S ec</p>
    <p>on d</p>
    <p>Insertions Lookups</p>
    <p>SplinterDB RocksDB</p>
    <p>(YCSB Run C)</p>
    <p>Basic Operation Throughput</p>
    <p>H ig</p>
    <p>h e r</p>
    <p>is B</p>
    <p>e tt</p>
    <p>e r</p>
    <p>IO A</p>
    <p>m pl</p>
    <p>ifi ca</p>
    <p>tio n</p>
    <p>IO Amplification</p>
    <p>e r</p>
    <p>is B</p>
    <p>e tt</p>
    <p>e r</p>
    <p>YCSB Load - uniform</p>
    <p>Small KV-pairs</p>
    <p>Small cache (using cgroup)</p>
    <p>Intel Optane 905P</p>
    <p>Block-addressable NVMe</p>
  </div>
  <div class="page">
    <p>SplinterDB Performance</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut in</p>
    <p>f O pe</p>
    <p>ra tio</p>
    <p>ns /</p>
    <p>S ec</p>
    <p>on d</p>
    <p>Insertions Lookups</p>
    <p>SplinterDB RocksDB</p>
    <p>(YCSB Run C)</p>
    <p>Basic Operation Throughput</p>
    <p>H ig</p>
    <p>h e r</p>
    <p>is B</p>
    <p>e tt</p>
    <p>e r</p>
    <p>IO A</p>
    <p>m pl</p>
    <p>ifi ca</p>
    <p>tio n</p>
    <p>IO Amplification</p>
    <p>e r</p>
    <p>is B</p>
    <p>e tt</p>
    <p>e r</p>
    <p>YCSB Load - uniform</p>
    <p>Small KV-pairs</p>
    <p>Small cache (using cgroup)</p>
    <p>Intel Optane 905P</p>
    <p>Block-addressable NVMe</p>
  </div>
  <div class="page">
    <p>SplinterDB Performance</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut in</p>
    <p>f O pe</p>
    <p>ra tio</p>
    <p>ns /</p>
    <p>S ec</p>
    <p>on d</p>
    <p>Insertions Lookups</p>
    <p>SplinterDB RocksDB</p>
    <p>YCSB Run C - Zipfian</p>
    <p>Basic Operation Throughput</p>
    <p>H ig</p>
    <p>h e r</p>
    <p>is B</p>
    <p>e tt</p>
    <p>e r</p>
    <p>YCSB Load - uniform</p>
    <p>Small KV-pairs</p>
    <p>Small cache (using cgroup)</p>
    <p>Intel Optane 905P</p>
    <p>Block-addressable NVMe</p>
  </div>
  <div class="page">
    <p>SplinterDB Performance</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut in</p>
    <p>f O pe</p>
    <p>ra tio</p>
    <p>ns /</p>
    <p>S ec</p>
    <p>on d</p>
    <p>A B C D E F</p>
    <p>YCSB Application Benchmark</p>
    <p>H ig</p>
    <p>h e r</p>
    <p>is B</p>
    <p>e tt</p>
    <p>e r</p>
    <p>Small KV-pairs</p>
    <p>Small cache (using cgroup)</p>
    <p>Intel Optane 905P</p>
    <p>Block-addressable NVMe</p>
  </div>
  <div class="page">
    <p>Flush-then-Compact</p>
    <p>In this talk</p>
    <p>SplinterDB</p>
    <p>Data Structures</p>
    <p>Fast Storage (NVMe)</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>O(logB N)</p>
    <p>B-ary Search Tree</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>O(logB N)</p>
    <p>B-ary Search Tree</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>O(logB N)</p>
    <p>B-ary Search Tree Insert76</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>O(logB N)</p>
    <p>B-ary Search Tree Insert</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>O(logB N)</p>
    <p>B-ary Search Tree Insert</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>O(logB N)</p>
    <p>B-ary Search Tree Insert</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>O(logB N)</p>
    <p>B-ary Search Tree Insert</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>O(logB N)</p>
    <p>B-ary Search Tree</p>
    <p>Insert</p>
    <p>Insertion Cost  O (logB N) Lookup Cost  O (logB N)</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>A B-tree is a search tree (like a B-tree)</p>
    <p>Each node has size B = 1 IO</p>
    <p>B pivots the rest buffer</p>
  </div>
  <div class="page">
    <p>Insertions in B-Trees</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
    <p>When a buffer is full: 1. Pick child receiving most messages 2. Move them to the childs buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
    <p>When a buffer is full: 1. Pick child receiving most messages 2. Move them to the childs buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
    <p>When a buffer is full: 1. Pick child receiving most messages 2. Move them to the childs buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
    <p>When a buffer is full: 1. Pick child receiving most messages 2. Move them to the childs buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
    <p>When a buffer is full: 1. Pick child receiving most messages 2. Move them to the childs buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
    <p>When a buffer is full: 1. Pick child receiving most messages 2. Move them to the childs buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
    <p>When a buffer is full: 1. Pick child receiving most messages 2. Move them to the childs buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
    <p>When a buffer is full: 1. Pick child receiving most messages 2. Move them to the childs buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
    <p>When a buffer is full: 1. Pick child receiving most messages 2. Move them to the childs buffer</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Inserts get put in the root buffer</p>
    <p>When a buffer is full: 1. Pick child receiving most messages 2. Move them to the childs buffer</p>
  </div>
  <div class="page">
    <p>Lookups in B-Trees</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Lookups follow pivots, but check buffers along the way</p>
    <p>Query(71)</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Lookups follow pivots, but check buffers along the way</p>
    <p>Query(71)</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Lookups follow pivots, but check buffers along the way</p>
    <p>Query(71)</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Lookups follow pivots, but check buffers along the way</p>
    <p>Query(71)</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Lookups follow pivots, but check buffers along the way</p>
    <p>Query(71) 2</p>
  </div>
  <div class="page">
    <p>B-Trees</p>
    <p>Lookups follow pivots, but check buffers along the way</p>
    <p>Query(71) 2</p>
  </div>
  <div class="page">
    <p>Write Amplification in B-Trees</p>
    <p>Work</p>
  </div>
  <div class="page">
    <p>Work Amplification in B-Trees</p>
    <p>node, the node must be rewritten</p>
    <p>Recall: Insertions in B-trees</p>
  </div>
  <div class="page">
    <p>Work Amplification in B-Trees</p>
    <p>To add new data to a B-tree node, the node must be rewritten</p>
    <p>Recall: Insertions in B-trees</p>
  </div>
  <div class="page">
    <p>Work Amplification in B-Trees</p>
    <p>To add new data to a B-tree node, the node must be rewritten</p>
    <p>Therefore, any messages already in the node get written out again</p>
    <p>Recall: Insertions in B-trees</p>
  </div>
  <div class="page">
    <p>Work Amplification in B-Trees</p>
    <p>To add new data to a B-tree node, the node must be rewritten</p>
    <p>Therefore, any messages already in the node get written out again</p>
    <p>Recall: Insertions in B-trees</p>
  </div>
  <div class="page">
    <p>Work Amplification in B-Trees</p>
    <p>And again</p>
    <p>To add new data to a B-tree node, the node must be rewritten</p>
    <p>Therefore, any messages already in the node get written out again</p>
    <p>Recall: Insertions in B-trees</p>
  </div>
  <div class="page">
    <p>Work Amplification in B-Trees</p>
    <p>And again</p>
    <p>node, the node must be rewritten</p>
    <p>Therefore, any messages already in the node get written out again</p>
    <p>Recall: Insertions in B-trees</p>
  </div>
  <div class="page">
    <p>Work Amplification in B-Trees</p>
    <p>To add new data to a B-tree node, the node must be rewritten</p>
    <p>Therefore, any messages already in the node get written out again</p>
    <p>And again</p>
    <p>And again</p>
    <p>Recall: Insertions in B-trees</p>
  </div>
  <div class="page">
    <p>Work Amplification in B-Trees</p>
    <p>To add new data to a B-tree node, the node must be rewritten</p>
    <p>Therefore, any messages already in the node get written out again</p>
    <p>And again</p>
    <p>And again In the worst case, the average message</p>
    <p>is rewritten B/2 times in each node</p>
    <p>Recall: Insertions in B-trees</p>
  </div>
  <div class="page">
    <p>Work Amplification in B-Trees</p>
    <p>In the worst case, the average message is rewritten B/2 times in each node</p>
    <p>Recall: Insertions in B-trees</p>
    <p>logB N</p>
    <p>B-Tree Work Amplification = O (B  logB N)</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees (SplinterDB)</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>B pivots the rest buffer</p>
    <p>Recall: a B-tree node has pivots and a buffer</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>B pivots the rest buffer</p>
    <p>Recall: a B-tree node has pivots and a buffer</p>
    <p>In an STB-tree, the buffer is stored</p>
    <p>separately</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>B pivots the rest buffer</p>
    <p>Recall: a B-tree node has pivots and a buffer</p>
    <p>In an STB-tree, the buffer is stored</p>
    <p>separately</p>
    <p>and in several discontiguous pieces</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>B pivots the rest buffer</p>
    <p>Recall: a B-tree node has pivots and a buffer</p>
    <p>In an STB-tree, the buffer is stored</p>
    <p>separately</p>
    <p>and in several discontiguous pieces</p>
    <p>trunk [node]</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>B pivots the rest buffer</p>
    <p>Recall: a B-tree node has pivots and a buffer</p>
    <p>In an STB-tree, the buffer is stored</p>
    <p>separately</p>
    <p>and in several discontiguous pieces</p>
    <p>trunk [node]</p>
    <p>branches</p>
  </div>
  <div class="page">
    <p>Insertions in Size-Tiered B-Trees</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>When new data is flushed into the trunk node</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>When new data is flushed into the trunk node</p>
    <p>it is added as a new branch</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>When new data is flushed into the trunk node</p>
    <p>it is added as a new branch</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>When new data is flushed into the trunk node</p>
    <p>it is added as a new branch</p>
    <p>The old branches do not need to be rewritten</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>Branches may have overlapping key ranges</p>
    <p>When new data is flushed into the trunk node</p>
    <p>it is added as a new branch</p>
    <p>The old branches do not need to be rewritten</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>When new data is flushed into the trunk node</p>
    <p>it is added as a new branch</p>
    <p>The old branches do not need to be rewritten</p>
    <p>Branches may have overlapping key ranges</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>When new data is flushed into the trunk node</p>
    <p>it is added as a new branch</p>
    <p>The old branches do not need to be rewritten</p>
    <p>Branches may have overlapping key ranges</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>When new data is flushed into the trunk node</p>
    <p>it is added as a new branch</p>
    <p>The old branches do not need to be rewritten</p>
    <p>Branches may have overlapping key ranges</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>The fullness threshold is: Fanout  Average Buffer Size</p>
    <p>When new data is flushed into the trunk node</p>
    <p>it is added as a new branch</p>
    <p>The old branches do not need to be rewritten</p>
    <p>Branches may have overlapping key ranges</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>When the node is full: 1. Pick child receiving most messages 2. Merge them into a new branch for the child</p>
    <p>The fullness threshold is: Fanout  Average Buffer Size</p>
    <p>When new data is flushed into the trunk node</p>
    <p>it is added as a new branch</p>
    <p>The old branches do not need to be rewritten</p>
    <p>Branches may have overlapping key ranges</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>The fullness threshold is: Fanout  Average Buffer Size</p>
    <p>When new data is flushed into the trunk node</p>
    <p>it is added as a new branch</p>
    <p>The old branches do not need to be rewritten</p>
    <p>When the node is full: 1. Pick child receiving most messages 2. Merge them into a new branch for the child</p>
    <p>Branches may have overlapping key ranges</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>The fullness threshold is: Fanout  Average Buffer Size</p>
    <p>When new data is flushed into the trunk node</p>
    <p>it is added as a new branch</p>
    <p>The old branches do not need to be rewritten</p>
    <p>When the node is full: 1. Pick child receiving most messages 2. Merge them into a new branch for the child</p>
    <p>Branches may have overlapping key ranges</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>The fullness threshold is: Fanout  Average Buffer Size</p>
    <p>When new data is flushed into the trunk node</p>
    <p>it is added as a new branch</p>
    <p>The old branches do not need to be rewritten</p>
    <p>Each key-value pair is read/ written once per trunk node</p>
    <p>When the node is full: 1. Pick child receiving most messages 2. Merge them into a new branch for the child</p>
    <p>Branches may have overlapping key ranges</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>Each key-value pair is read/ written once per trunk node</p>
    <p>logB N</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>Each key-value pair is read/ written once per trunk node</p>
    <p>logB N B-Tree: O (B  logB N) Size-Tiered B-Tree: O (logB N)</p>
    <p>Work Amplification</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>Each key-value pair is read/ written once per trunk node</p>
    <p>logB N</p>
    <p>B  lessB-Tree: O (B  logB N) Size-Tiered B-Tree: O (logB N)</p>
    <p>Work Amplification</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>Each key-value pair is read/ written once per trunk node</p>
    <p>logB N</p>
    <p>B  less</p>
    <p>B-Tree: O (B  logB N) Size-Tiered B-Tree: O (logB N)</p>
    <p>Work Amplification</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>A Size-Tiered B-tree is a B-tree where the buffer is</p>
    <p>stored discontiguously</p>
    <p>Each key-value pair is read/ written once per trunk node</p>
    <p>logB N</p>
    <p>B-Tree: = O ( 1B B  logB N M )</p>
    <p>Size-Tiered B-Tree: = O ( 1B logB N M )</p>
    <p>B  less</p>
    <p>B-Tree: O (B  logB N) Size-Tiered B-Tree: O (logB N)</p>
    <p>Work Amplification</p>
    <p>Insertion Cost B  less</p>
  </div>
  <div class="page">
    <p>Lookups in Size-Tiered B-Trees</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>Lookups in a STB-tree are like lookups in a B-tree, except they must check</p>
    <p>each branch</p>
    <p>Query(71)</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>Query(71) Lookups in a STB-tree are like lookups in a B-tree, except they must check</p>
    <p>each branch</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>Query(71) Lookups in a STB-tree are like lookups in a B-tree, except they must check</p>
    <p>each branch</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>Query(71) Lookups in a STB-tree are like lookups in a B-tree, except they must check</p>
    <p>each branch</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>Query(71) Lookups in a STB-tree are like lookups in a B-tree, except they must check</p>
    <p>each branch</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>Query(71) Lookups in a STB-tree are like lookups in a B-tree, except they must check</p>
    <p>each branch</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>Query(71) Lookups in a STB-tree are like lookups in a B-tree, except they must check</p>
    <p>each branch</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>Query(71) Lookups in a STB-tree are like lookups in a B-tree, except they must check</p>
    <p>each branch</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>Query(71) Lookups in a STB-tree are like lookups in a B-tree, except they must check</p>
    <p>each branch</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>Query(71) Lookups in a STB-tree are like lookups in a B-tree, except they must check</p>
    <p>each branch</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>Query(71) Lookups in a STB-tree are like lookups in a B-tree, except they must check</p>
    <p>each branch</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>Query(71) Lookups in a STB-tree are like lookups in a B-tree, except they must check</p>
    <p>each branch</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>Query(71) 2</p>
    <p>Lookups in a STB-tree are like lookups in a B-tree, except they must check</p>
    <p>each branch</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>Query(71)</p>
    <p>B-Tree Lookup Cost = O (logB NM ) Size-Tiered B-Tree Lookup Cost = O (B logB NM )</p>
    <p>Lookups in a STB-tree are like lookups in a B-tree, except they must check</p>
    <p>each branch</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>Query(71)</p>
    <p>B  more B-Tree Lookup Cost = O (logB NM ) Size-Tiered B-Tree Lookup Cost = O (B logB NM )</p>
    <p>Lookups in a STB-tree are like lookups in a B-tree, except they must check</p>
    <p>each branch</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Trees</p>
    <p>Query(71)</p>
    <p>B  more</p>
    <p>B-Tree Lookup Cost = O (logB NM ) Size-Tiered B-Tree Lookup Cost = O (B logB NM )</p>
    <p>Lookups in a STB-tree are like lookups in a B-tree, except they must check</p>
    <p>each branch</p>
  </div>
  <div class="page">
    <p>Fixing Lookups in Size-Tiered B-Trees</p>
  </div>
  <div class="page">
    <p>Fixing Lookups in Size-Tiered B-Trees</p>
    <p>The problem is that each node has multiple branches</p>
  </div>
  <div class="page">
    <p>Fixing Lookups in Size-Tiered B-Trees</p>
    <p>Idea: use filters to avoid searching them</p>
    <p>A filter is a probabilistic data structure with answers membership</p>
    <p>with no false negatives</p>
    <p>Examples: Bloom, cuckoo, quotient</p>
    <p>The problem is that each node has multiple branches</p>
  </div>
  <div class="page">
    <p>Fixing Lookups in Size-Tiered B-Trees</p>
    <p>The problem is that each node has multiple branches</p>
    <p>Now a lookup will only search those branches which contain the key</p>
    <p>(plus rare false positives)</p>
    <p>A filter is a probabilistic data structure with answers membership</p>
    <p>with no false negatives</p>
    <p>Examples: Bloom, cuckoo, quotient</p>
    <p>Idea: use filters to avoid searching them</p>
  </div>
  <div class="page">
    <p>Fixing Lookups in Size-Tiered B-Trees</p>
    <p>Query(64)</p>
    <p>A filter is a probabilistic data structure with answers membership</p>
    <p>with no false negatives</p>
    <p>Examples: Bloom, cuckoo, quotient</p>
    <p>Idea: use filters to avoid searching them</p>
    <p>The problem is that each node has multiple branches</p>
    <p>Now a lookup will only search those branches which contain the key</p>
    <p>(plus rare false positives)</p>
  </div>
  <div class="page">
    <p>Fixing Lookups in Size-Tiered B-Trees</p>
    <p>Query(64)</p>
    <p>A filter is a probabilistic data structure with answers membership</p>
    <p>with no false negatives</p>
    <p>Examples: Bloom, cuckoo, quotient</p>
    <p>Idea: use filters to avoid searching them</p>
    <p>The problem is that each node has multiple branches</p>
    <p>Now a lookup will only search those branches which contain the key</p>
    <p>(plus rare false positives)</p>
  </div>
  <div class="page">
    <p>Fixing Lookups in Size-Tiered B-Trees</p>
    <p>Query(64)</p>
    <p>A filter is a probabilistic data structure with answers membership</p>
    <p>with no false negatives</p>
    <p>Examples: Bloom, cuckoo, quotient</p>
    <p>Idea: use filters to avoid searching them</p>
    <p>The problem is that each node has multiple branches</p>
    <p>Now a lookup will only search those branches which contain the key</p>
    <p>(plus rare false positives)</p>
  </div>
  <div class="page">
    <p>Fixing Lookups in Size-Tiered B-Trees</p>
    <p>Query(64)</p>
    <p>A filter is a probabilistic data structure with answers membership</p>
    <p>with no false negatives</p>
    <p>Examples: Bloom, cuckoo, quotient</p>
    <p>Idea: use filters to avoid searching them</p>
    <p>The problem is that each node has multiple branches</p>
    <p>Now a lookup will only search those branches which contain the key</p>
    <p>(plus rare false positives)</p>
  </div>
  <div class="page">
    <p>Fixing Lookups in Size-Tiered B-Trees</p>
    <p>Query(64)</p>
    <p>A filter is a probabilistic data structure with answers membership</p>
    <p>with no false negatives</p>
    <p>Examples: Bloom, cuckoo, quotient</p>
    <p>Idea: use filters to avoid searching them</p>
    <p>The problem is that each node has multiple branches</p>
    <p>Now a lookup will only search those branches which contain the key</p>
    <p>(plus rare false positives)</p>
  </div>
  <div class="page">
    <p>Fixing Lookups in Size-Tiered B-Trees</p>
    <p>Query(64)</p>
    <p>A filter is a probabilistic data structure with answers membership</p>
    <p>with no false negatives</p>
    <p>Examples: Bloom, cuckoo, quotient</p>
    <p>Idea: use filters to avoid searching them</p>
    <p>The problem is that each node has multiple branches</p>
    <p>Now a lookup will only search those branches which contain the key</p>
    <p>(plus rare false positives)</p>
  </div>
  <div class="page">
    <p>Fixing Lookups in Size-Tiered B-Trees</p>
    <p>Query(64)</p>
    <p>A filter is a probabilistic data structure with answers membership</p>
    <p>with no false negatives</p>
    <p>Examples: Bloom, cuckoo, quotient</p>
    <p>Idea: use filters to avoid searching them</p>
    <p>The problem is that each node has multiple branches</p>
    <p>Now a lookup will only search those branches which contain the key</p>
    <p>(plus rare false positives)</p>
  </div>
  <div class="page">
    <p>Fixing Lookups in Size-Tiered B-Trees</p>
    <p>Query(64)</p>
    <p>A filter is a probabilistic data structure with answers membership</p>
    <p>with no false negatives</p>
    <p>Examples: Bloom, cuckoo, quotient</p>
    <p>Idea: use filters to avoid searching them</p>
    <p>The problem is that each node has multiple branches</p>
    <p>Now a lookup will only search those branches which contain the key</p>
    <p>(plus rare false positives)</p>
  </div>
  <div class="page">
    <p>Fixing Lookups in Size-Tiered B-Trees</p>
    <p>Query(64) 8</p>
    <p>A filter is a probabilistic data structure with answers membership</p>
    <p>with no false negatives</p>
    <p>Examples: Bloom, cuckoo, quotient</p>
    <p>Idea: use filters to avoid searching them</p>
    <p>The problem is that each node has multiple branches</p>
    <p>Now a lookup will only search those branches which contain the key</p>
    <p>(plus rare false positives)</p>
  </div>
  <div class="page">
    <p>Fixing Lookups in Size-Tiered B-Trees</p>
    <p>False Positive Rate  O ( B logB N )</p>
    <p>Query(64) 8</p>
    <p>Idea: use filters to avoid searching them</p>
    <p>The problem is that each node has multiple branches</p>
    <p>Now a lookup will only search those branches which contain the key</p>
    <p>(plus rare false positives)</p>
  </div>
  <div class="page">
    <p>Fixing Lookups in Size-Tiered B-Trees</p>
    <p>Query(64) 8</p>
    <p>False Positive Rate  O ( B logB N ) Lookups in O(1) IOs</p>
    <p>Idea: use filters to avoid searching them</p>
    <p>The problem is that each node has multiple branches</p>
    <p>Now a lookup will only search those branches which contain the key</p>
    <p>(plus rare false positives)</p>
  </div>
  <div class="page">
    <p>Size-Tiered B-Tree</p>
    <p>Less compaction</p>
    <p>Less IO Less CPU</p>
    <p>Low lookup cost Scans</p>
    <p>Short  more expensive</p>
    <p>Long  disk bandwidth</p>
    <p>Se e</p>
    <p>th e</p>
    <p>te xt</p>
    <p>!</p>
  </div>
  <div class="page">
    <p>Flush-then-Compact</p>
    <p>In this talk</p>
    <p>SplinterDB</p>
    <p>Data Structures</p>
    <p>Fast Storage (NVMe)</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Sequential Insertions into a B-tree</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Sequential Insertions into a B-tree</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Sequential Insertions into a B-tree</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Sequential Insertions into a B-tree</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Sequential Insertions into a B-tree</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Sequential Insertions into a B-tree</p>
    <p>After inserting the first message, the root-toleaf path is in cache</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Sequential Insertions into a B-tree</p>
    <p>Subsequent insertions are cheaper. (only incur IO at node boundaries)</p>
    <p>After inserting the first message, the root-toleaf path is in cache</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Sequential Insertions into a B-tree</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Sequential Insertions into a B-tree</p>
    <p>B insertions trigger a flush to the leaf bringing the root-to</p>
    <p>leaf path into cache</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Sequential Insertions into a B-tree</p>
    <p>B insertions trigger a flush to the leaf bringing the root-to</p>
    <p>leaf path into cache</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Sequential Insertions into a B-tree</p>
    <p>B insertions trigger a flush to the leaf bringing the root-to</p>
    <p>leaf path into cache</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Sequential Insertions into a B-tree</p>
    <p>B insertions trigger a flush to the leaf bringing the root-to</p>
    <p>leaf path into cache</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Sequential Insertions into a B-tree</p>
    <p>B insertions trigger a flush to the leaf bringing the root-to</p>
    <p>leaf path into cache</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Sequential Insertions into a B-tree</p>
    <p>Subsequent insertions are cheaper. (only incur IO at node boundaries)</p>
    <p>B insertions trigger a flush to the leaf bringing the root-to</p>
    <p>leaf path into cache</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>After merging and flushing another flush will be triggered</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Want: Sequential insertions with lower work amplification</p>
    <p>After merging and flushing another flush will be triggered</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>After merging and flushing another flush will be triggered</p>
    <p>Want: Sequential insertions with lower work amplification</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>After merging and flushing another flush will be triggered</p>
    <p>Want: Sequential insertions with lower work amplification</p>
    <p>Any data already present will get merged again</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>After merging and flushing another flush will be triggered</p>
    <p>Want: Sequential insertions with lower work amplification</p>
    <p>Any data already present will get merged again</p>
    <p>Can still end up merging on each level</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Idea: Flush-then-compact</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Idea: Flush-then-compact</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>First flush references to the branches, but do not compact</p>
    <p>Idea: Flush-then-compact</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Idea: Flush-then-compact</p>
    <p>First flush references to the branches, but do not compact</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Want: Sequential insertions with lower work amplification</p>
    <p>The parent only sees the unflushed data</p>
    <p>Idea: Flush-then-compact</p>
    <p>First flush references to the branches, but do not compact</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>The child only sees the flushed data</p>
    <p>Idea: Flush-then-compact</p>
    <p>First flush references to the branches, but do not compact</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Then can flush again</p>
    <p>Idea: Flush-then-compact</p>
    <p>First flush references to the branches, but do not compact</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Then can flush again</p>
    <p>Idea: Flush-then-compact</p>
    <p>First flush references to the branches, but do not compact</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Then can flush again</p>
    <p>Idea: Flush-then-compact</p>
    <p>First flush references to the branches, but do not compact</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Then can flush again</p>
    <p>Finally, asynchronously compact the flushed buffers</p>
    <p>in each node</p>
    <p>Idea: Flush-then-compact</p>
    <p>First flush references to the branches, but do not compact</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>No work on immediately flushed data</p>
    <p>First flush references to the branches, but do not compact</p>
  </div>
  <div class="page">
    <p>Use metadata to mask out data</p>
    <p>Flush-Then-Compact</p>
    <p>No work on immediately flushed data</p>
    <p>Sequential insertions have work amp ~1</p>
    <p>First flush references to the branches, but do not compact</p>
  </div>
  <div class="page">
    <p>Use metadata to mask out data</p>
    <p>Flush-Then-Compact</p>
    <p>No work on immediately flushed data</p>
    <p>Sequential insertions have work amp ~1</p>
    <p>First flush references to the branches, but do not compact</p>
    <p>Break a serial chain of compactions into parallel</p>
  </div>
  <div class="page">
    <p>Use metadata to mask out data</p>
    <p>Flush-Then-Compact</p>
    <p>No work on immediately flushed data</p>
    <p>Sequential insertions have work amp ~1</p>
    <p>First flush references to the branches, but do not compact</p>
    <p>Break a serial chain of compactions into parallel</p>
    <p>Concurrent compactions in trunk nodes</p>
  </div>
  <div class="page">
    <p>First flush references to the branches, but do not compact</p>
    <p>Use metadata to mask out data</p>
    <p>Flush-Then-Compact</p>
    <p>No work on immediately flushed data</p>
    <p>Concurrent compactions in trunk nodes</p>
    <p>Break a serial chain of compactions into parallel</p>
    <p>Sequential insertions have work amp ~1</p>
    <p>Improve insertion concurrency</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Run a single-threaded workload with a percentage sequential</p>
    <p>insertions and the rest random</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut (I</p>
    <p>ns er</p>
    <p>tio ns</p>
    <p>/S ec</p>
    <p>on d)</p>
    <p>Percentage Sequential 0 50 90 99 100</p>
    <p>SplinterDB RocksDB</p>
    <p>H ig</p>
    <p>h e r</p>
    <p>is B</p>
    <p>e tt</p>
    <p>e r</p>
    <p>X-axis not to scale</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Because of flush-then-compact, SplinterDB smoothly increases</p>
    <p>throughput as the workload gets more sequential</p>
    <p>Run a single-threaded workload with a percentage sequential</p>
    <p>insertions and the rest random</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut (I</p>
    <p>ns er</p>
    <p>tio ns</p>
    <p>/S ec</p>
    <p>on d)</p>
    <p>Percentage Sequential 0 50 90 99 100</p>
    <p>SplinterDB RocksDB</p>
    <p>H ig</p>
    <p>h e r</p>
    <p>is B</p>
    <p>e tt</p>
    <p>e r</p>
    <p>X-axis not to scale</p>
  </div>
  <div class="page">
    <p>Flush-Then-Compact</p>
    <p>Because of flush-then-compact, SplinterDB smoothly increases</p>
    <p>throughput as the workload gets more sequential</p>
    <p>Run a single-threaded workload with a percentage sequential</p>
    <p>insertions and the rest random</p>
    <p>RocksDB improves, but at a much lower rate</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut (I</p>
    <p>ns er</p>
    <p>tio ns</p>
    <p>/S ec</p>
    <p>on d)</p>
    <p>Percentage Sequential 0 50 90 99 100</p>
    <p>SplinterDB RocksDB</p>
    <p>H ig</p>
    <p>h e r</p>
    <p>is B</p>
    <p>e tt</p>
    <p>e r</p>
    <p>X-axis not to scale</p>
  </div>
  <div class="page">
    <p>Flush-then-Compact</p>
    <p>Insertions in SplinterDB scale well</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut (I</p>
    <p>ns er</p>
    <p>tio ns</p>
    <p>/S ec</p>
    <p>on d)</p>
    <p>Number of Threads 2 4 6 8 10 12 14 16 18 20</p>
    <p>SplinterDB RocksDB</p>
    <p>H ig</p>
    <p>h e r</p>
    <p>is B</p>
    <p>e tt</p>
    <p>e r</p>
  </div>
  <div class="page">
    <p>Flush-then-Compact</p>
    <p>Insertions in SplinterDB scale well</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut (I</p>
    <p>ns er</p>
    <p>tio ns</p>
    <p>/S ec</p>
    <p>on d)</p>
    <p>Number of Threads 2 4 6 8 10 12 14 16 18 20</p>
    <p>SplinterDB RocksDB</p>
    <p>At 12 threads, SplinterDB has 7x the throughput of 1 thread</p>
    <p>H ig</p>
    <p>h e r</p>
    <p>is B</p>
    <p>e tt</p>
    <p>e r</p>
  </div>
  <div class="page">
    <p>Flush-then-Compact</p>
    <p>Insertions in SplinterDB scale well</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut (I</p>
    <p>ns er</p>
    <p>tio ns</p>
    <p>/S ec</p>
    <p>on d)</p>
    <p>Number of Threads 2 4 6 8 10 12 14 16 18 20</p>
    <p>SplinterDB RocksDB</p>
    <p>At 12 threads, SplinterDB has 7x the throughput of 1 thread</p>
    <p>At 12+ threads, SplinterDB uses 85%+ of the device bandwidth</p>
    <p>H ig</p>
    <p>h e r</p>
    <p>is B</p>
    <p>e tt</p>
    <p>e r</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>SplinterDB is a key-value store which handles these tough cases:</p>
    <p>Fast Storage</p>
    <p>Small Key-Value Pairs</p>
    <p>Small Cache</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>SplinterDB is a key-value store which handles these tough cases:</p>
    <p>Fast Storage</p>
    <p>Small Key-Value Pairs</p>
    <p>Small Cache</p>
    <p>Size-Tiered B-Tree</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>SplinterDB is a key-value store which handles these tough cases:</p>
    <p>Fast Storage</p>
    <p>Small Key-Value Pairs</p>
    <p>Small Cache</p>
    <p>Size-Tiered B-Tree</p>
    <p>Flush-then-Compact</p>
  </div>
  <div class="page">
    <p>Thank you!!!</p>
    <p>Alex Conway</p>
    <p>ajhconway.com</p>
    <p>aconway@vmware.com</p>
  </div>
</Presentation>
