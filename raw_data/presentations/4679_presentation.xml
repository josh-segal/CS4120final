<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>A Typed Interrupt Calculus</p>
    <p>Jens Palsberg</p>
    <p>Purdue University</p>
    <p>Department of Computer Science</p>
    <p>Joint work with Ma Di</p>
    <p>Supported by an NSF ITR award and by DARPA.</p>
  </div>
  <div class="page">
    <p>Secure Software Systems Group</p>
    <p>Faculty: Antony Hosking, Jens Palsberg, Jan Vitek</p>
    <p>Current Support:</p>
    <p>NSF DARPA Lockheed Martin  2 CAREER awards CERIAS Microsoft  2 ITR awards IBM Motorola  regular awards Intel Sun Microsystems</p>
  </div>
  <div class="page">
    <p>Our Results</p>
    <p>An interrupt calculus.  No program can terminate.</p>
    <p>A type system.  A well-typed program cannot cause stack overflow.</p>
    <p>A prototype implementation.</p>
  </div>
  <div class="page">
    <p>(3) Micro</p>
    <p>controller</p>
    <p>Fan control signal</p>
    <p>Network</p>
    <p>(2)</p>
    <p>Power Pulse</p>
    <p>(1)</p>
    <p>Internal Timer</p>
  </div>
  <div class="page">
    <p>Example Program in Z86 Assembly Language</p>
    <p>; Constant Pool (Symbol Table); Bit Flags for IMR and IRQ.</p>
    <p>IRQ0 .EQU #00000001b</p>
    <p>; Bit Flags for external devices on Port 0 and Port 3.</p>
    <p>DEV2 .EQU #00010000b</p>
    <p>; Interrupt Vectors.</p>
    <p>.ORG %00h</p>
    <p>.WORD #HANDLER ; Device 0</p>
    <p>; Main Program Code.</p>
    <p>.ORG 0Ch</p>
    <p>INIT: ; Initialization section.</p>
  </div>
  <div class="page">
    <p>Example Program in Z86 Assembly Language</p>
    <p>START: ; Start of main program loop. 1C DJNZ r2, START ; If our counter expires, 1E LD r1, P3 ; send this sensors reading 20 CALL SEND ; to the output device. 23 JP START</p>
    <p>SEND: ; Send Data to Device 2. 26 PUSH IMR ; Remember what IMR was.</p>
    <p>DELAY: 28 DI ; Musnt be interrupted during pulse. 29 LD P0, #DEV2 ; Select control line for Device 2. 2C DJNZ r3, DELAY ; Short delay. 2E CLR P0 30 POP IMR ; Reactivate interrupts. 32 RET</p>
    <p>HANDLER: ; Interrupt for Device 0. 33 LD r2, #00h ; Reset counter in main loop. 35 CALL SEND 38 IRET ; Interrupt Handler is done.</p>
    <p>.END</p>
  </div>
  <div class="page">
    <p>Resource-Aware Compilation</p>
    <p>A machine readable specification and an implementation:</p>
    <p>Resource Constraints:  Available code space: 512 KB  Maximum stack size: 800 bytes  Maximum time to handle event 1: 400 s  Minimum battery life time: 2 years</p>
    <p>Source Code: // in a high-level language such as C</p>
    <p>Can be compiled by a resource-aware compiler.</p>
    <p>The generated assembly code can be verified by a model checker.</p>
  </div>
  <div class="page">
    <p>A Nasty Programming Error</p>
    <p>handler 1 {</p>
    <p>// do something</p>
    <p>enable-handling-of-interrupt-2</p>
    <p>// do something else</p>
    <p>iret</p>
    <p>}</p>
    <p>handler 2 {</p>
    <p>// do something</p>
    <p>enable-handling-of-interrupt-1</p>
    <p>// do something else</p>
    <p>iret</p>
    <p>} 8</p>
  </div>
  <div class="page">
    <p>Interrupt Mask Register</p>
    <p>Well-known product Processor interrupt master sources bit</p>
    <p>Microcontroller Zilog Z86 6 yes iPAQ Pocket PC Intel strongARM, XScale 21 no Palm Motorola Dragonball (68K Family) 22 yes Microcontroller Intel MCS-51 Family (8051 etc) 6 yes</p>
    <p>MCS51 interrupt mask register:</p>
    <p>EA  ET2 ES ET1 EX1 ET0 EX0</p>
  </div>
  <div class="page">
    <p>Properties</p>
    <p>Program</p>
    <p>Model</p>
    <p>Model Checking</p>
    <p>Model Extraction</p>
  </div>
  <div class="page">
    <p>!3</p>
    <p>!2 !1 !1 !2</p>
    <p>?2 ?2?1 ?1</p>
    <p>?3</p>
    <p>e e e e</p>
    <p>INIT: START:</p>
    <p>HANDLER:</p>
  </div>
  <div class="page">
    <p>Stack-Size Analysis</p>
    <p>Program Lower Upper CTurk 17 18 GTurk 16 17 ZTurk 16 17 DRop 12 14 Rop 12 14 Fan 11 N/A Serial 10 10</p>
    <p>The lower bounds were found with a software simulator for Z86 assembly language that we wrote.</p>
  </div>
  <div class="page">
    <p>Two Selfish Handlers</p>
    <p>maximum stack size: 1</p>
    <p>imr = imr or 111b</p>
    <p>loop {</p>
    <p>skip</p>
    <p>imr = imr or 111b</p>
    <p>}</p>
    <p>handler 1 [ ( 111b -&gt; 111b : 0 )</p>
    <p>] {</p>
    <p>skip</p>
    <p>iret</p>
    <p>}</p>
    <p>handler 2 [ ( 111b -&gt; 111b : 0 )</p>
    <p>] {</p>
    <p>skip</p>
    <p>iret</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Two Prioritized Handlers</p>
    <p>maximum stack size: 2</p>
    <p>imr = imr or 111b</p>
    <p>loop {</p>
    <p>skip</p>
    <p>imr = imr or 111b</p>
    <p>}</p>
    <p>handler 1 [ ( 111b -&gt; 111b : 0 )</p>
    <p>( 110b -&gt; 110b : 0 )</p>
    <p>] {</p>
    <p>skip</p>
    <p>iret</p>
    <p>}</p>
    <p>handler 2 [ ( 111b -&gt; 111b : 1 )</p>
    <p>] {</p>
    <p>skip</p>
    <p>imr = imr and 110b</p>
    <p>imr = imr or 100b</p>
    <p>iret</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Two Cooperative Handlers</p>
    <p>maximum stack size: 2</p>
    <p>imr = imr or 111b</p>
    <p>loop {</p>
    <p>imr = imr or 111b</p>
    <p>}</p>
    <p>handler 1 [ ( 111b -&gt; 101b : 1 )</p>
    <p>( 110b -&gt; 100b : 0 )</p>
    <p>] {</p>
    <p>imr = imr and 101b</p>
    <p>imr = imr or 100b</p>
    <p>iret</p>
    <p>}</p>
    <p>handler 2 [ ( 111b -&gt; 110b : 1 )</p>
    <p>( 101b -&gt; 100b : 0 )</p>
    <p>] {</p>
    <p>imr = imr and 110b</p>
    <p>imr = imr or 100b</p>
    <p>iret</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Two Fancy Handlers</p>
    <p>maximum stack size: 3</p>
    <p>imr = imr or 111b</p>
    <p>loop {</p>
    <p>imr = imr or 111b</p>
    <p>}</p>
    <p>handler 1 [ ( 111b -&gt; 111b : 2 )</p>
    <p>( 110b -&gt; 100b : 0 )</p>
    <p>] {</p>
    <p>imr = imr and 101b</p>
    <p>imr = imr or 100b</p>
    <p>iret</p>
    <p>}</p>
    <p>handler 2 [ ( 111b -&gt; 100b : 1 )</p>
    <p>( 101b -&gt; 100b : 1 )</p>
    <p>] {</p>
    <p>imr = imr and 110b</p>
    <p>imr = imr or 010b</p>
    <p>imr = imr or 100b</p>
    <p>imr = imr and 101b</p>
    <p>iret</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>A Timer</p>
    <p>maximum stack size: 1</p>
    <p>SEC = SEC + 60</p>
    <p>imr = imr or 110b</p>
    <p>loop {</p>
    <p>if( SEC == 0 ) {</p>
    <p>OUT = 1</p>
    <p>imr = imr and 101b</p>
    <p>imr = imr or 001b</p>
    <p>} else {</p>
    <p>OUT = 0</p>
    <p>}</p>
    <p>}</p>
    <p>handler 1 [ ( 111b -&gt; 111b : 0 )</p>
    <p>( 110b -&gt; 110b : 0 )</p>
    <p>] {</p>
    <p>SEC = SEC + (-1)</p>
    <p>iret</p>
    <p>}</p>
    <p>handler 2 [ ( 111b -&gt; 110b : 0 )</p>
    <p>( 101b -&gt; 110b : 0 )</p>
    <p>] {</p>
    <p>SEC = 60</p>
    <p>imr = imr and 110b</p>
    <p>imr = imr or 010b</p>
    <p>iret</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>The Interrupt Calculus</p>
    <p>(program) p ::= (m, h)</p>
    <p>(main) m ::= loop s | s ; m</p>
    <p>(handler) h ::= iret | s ; h</p>
    <p>(statements) s ::= x = e | imr = imr  imr | imr = imr  imr | if0 x then s1 else s2 | s1 ; s2 | skip</p>
    <p>(expression) e ::= c | x | x + c | x1 + x2</p>
  </div>
  <div class="page">
    <p>Operational Semantics</p>
    <p>Handlers h, store R, interrupt mask register imr, stack , action a.</p>
    <p>h, R, imr, , a  h, R, imr  t0, a :: , h(i) if enabled(imr, i)</p>
    <p>h, R, imr, , iret  h, R, imr  t0,  , a if  = a ::</p>
    <p>h, R, imr, , imr = imr  imr; a  h, R, imr  imr, , a</p>
    <p>h, R, imr, , skip; a  h, R, imr, , a</p>
    <p>Theorem: No program can terminate</p>
  </div>
  <div class="page">
    <p>Type Judgments</p>
    <p>n</p>
    <p>j=1 ((imr) j</p>
    <p>j (imr  ) j).</p>
    <p>Type Judgment Meaning  ` h :  Interrupt handler h has type  , imr `K  Stack  type checks , imr `K m Main part m type checks , imr `K h : imr</p>
    <p>Handler h type checks</p>
    <p>, imr `K s : imr</p>
    <p>Statement s type checks  `K P Program state P type checks</p>
  </div>
  <div class="page">
    <p>Type Rules</p>
    <p>, (imr) j  t0 ` j h : (imr  ) j j  1..n</p>
    <p>` h : n</p>
    <p>j=1((imr) j</p>
    <p>j</p>
    <p>(imr  ) j)</p>
    <p>, imr `K s1 : imr1 , imr1 `K s2 : imr2 , imr `K s1; s2 : imr2</p>
    <p>, imr `K skip : imr [ safe(, imr, K)</p>
    <p>]</p>
    <p>safe(, imr, K) =</p>
    <p>i  1 . . . n if enabled(imr, i)</p>
    <p>then, whenever (i) = . . .</p>
    <p>(imr  imr</p>
    <p>)</p>
    <p>. . . ,</p>
    <p>we have imr   imr   + 1  K</p>
    <p>.</p>
    <p>Theorem: A well-typed program cannot cause stack overflow 21</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Calculus + type system + stack boundedness + prototype.</p>
    <p>Future work: type inference + experiments.</p>
    <p>High-assurance embedded systems in high-level languages = machine-readable specifications</p>
    <p>+ type systems + model checking + time-, space-, and power-aware compiler + automatic testcase generation.</p>
    <p>[Brylow, Damgaard &amp; Palsberg, ICSE 2001]: model checking [Naik &amp; Palsberg, LCTES 2002]: space-aware compilation [Palsberg &amp; Ma, FTRTFT 2002]: stack boundedness [Palsberg &amp; Wallace, manuscript]: reverse engineering</p>
  </div>
</Presentation>
