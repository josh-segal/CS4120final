<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Nonuniform Coercions</p>
    <p>via</p>
    <p>Unification Hints</p>
    <p>Claudio Sacerdoti Coen1, Enrico Tassi2</p>
    <p>TYPES 2010  15 October 2010  Warsaw</p>
  </div>
  <div class="page">
    <p>Context of this work</p>
    <p>I Interactive theorem prover Matita (CIC)</p>
    <p>I Formalization of formal topology (Algebraic Structures)</p>
    <p>I Unification made user-extensible (Unification Hints)</p>
    <p>I In some corner cases the system is unable to exploit the knowledge given by hints</p>
  </div>
  <div class="page">
    <p>Context of this work</p>
    <p>I Interactive theorem prover Matita (CIC)</p>
    <p>I Formalization of formal topology (Algebraic Structures)</p>
    <p>Type Inference</p>
    <p>Matita</p>
    <p>Type Checking</p>
    <p>? =</p>
    <p>Kernel Refiner</p>
    <p>I Unification made user-extensible (Unification Hints)</p>
    <p>I In some corner cases the system is unable to exploit the knowledge given by hints</p>
  </div>
  <div class="page">
    <p>Context of this work</p>
    <p>I Interactive theorem prover Matita (CIC)</p>
    <p>I Formalization of formal topology (Algebraic Structures)</p>
    <p>Type Inference</p>
    <p>Matita</p>
    <p>Type Checking</p>
    <p>? =</p>
    <p>Kernel Refiner</p>
    <p>I Unification made user-extensible (Unification Hints)</p>
    <p>I In some corner cases the system is unable to exploit the knowledge given by hints</p>
  </div>
  <div class="page">
    <p>Context of this work</p>
    <p>I Interactive theorem prover Matita (CIC)</p>
    <p>I Formalization of formal topology (Algebraic Structures)</p>
    <p>Type Inference</p>
    <p>Matita</p>
    <p>Type Checking</p>
    <p>? =</p>
    <p>Kernel Refiner</p>
    <p>I Unification made user-extensible (Unification Hints)</p>
    <p>I In some corner cases the system is unable to exploit the knowledge given by hints</p>
  </div>
  <div class="page">
    <p>Example   record Group : Type := { carr : Type,  : . . .} definition Z : Group :=  Z, +, 0, . . .. lemma mulg1: G:Group, a:carr G. a  1 = a. lemma cardG gt0 : G : Group, 0 &lt; |G|.   check (mulg1 ?G 2).</p>
    <p>Works, since 2 has type Z, and its context expects a term of type carr ?G and the unification algorithm knows a canonical solution for Z</p>
    <p>? =carr ?G .</p>
    <p>check (cardG gt0 Z).  Error: Z has type Type but its context expects a term of type Group. The unification problem Type</p>
    <p>? = Group has no</p>
    <p>solution.</p>
  </div>
  <div class="page">
    <p>Example   record Group : Type := { carr : Type,  : . . .} definition Z : Group :=  Z, +, 0, . . .. lemma mulg1: G:Group, a:carr G. a  1 = a. lemma cardG gt0 : G : Group, 0 &lt; |G|.   check (mulg1 ?G 2).  Works, since 2 has type Z, and its context expects a term of type carr ?G and the unification algorithm knows a canonical solution for Z</p>
    <p>? =carr ?G .</p>
    <p>check (cardG gt0 Z).  Error: Z has type Type but its context expects a term of type Group. The unification problem Type</p>
    <p>? = Group has no</p>
    <p>solution.</p>
  </div>
  <div class="page">
    <p>Example   record Group : Type := { carr : Type,  : . . .} definition Z : Group :=  Z, +, 0, . . .. lemma mulg1: G:Group, a:carr G. a  1 = a. lemma cardG gt0 : G : Group, 0 &lt; |G|.   check (mulg1 ?G 2).  Works, since 2 has type Z, and its context expects a term of type carr ?G and the unification algorithm knows a canonical solution for Z</p>
    <p>? =carr ?G .</p>
    <p>check (cardG gt0 Z).</p>
    <p>Error: Z has type Type but its context expects a term of type Group. The unification problem Type</p>
    <p>? = Group has no</p>
    <p>solution.</p>
  </div>
  <div class="page">
    <p>Example   record Group : Type := { carr : Type,  : . . .} definition Z : Group :=  Z, +, 0, . . .. lemma mulg1: G:Group, a:carr G. a  1 = a. lemma cardG gt0 : G : Group, 0 &lt; |G|.   check (mulg1 ?G 2).  Works, since 2 has type Z, and its context expects a term of type carr ?G and the unification algorithm knows a canonical solution for Z</p>
    <p>? =carr ?G .</p>
    <p>check (cardG gt0 Z).  Error: Z has type Type but its context expects a term of type Group. The unification problem Type</p>
    <p>? = Group has no</p>
    <p>solution.</p>
  </div>
  <div class="page">
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Type inference and coercions</p>
    <p>I These problems have to be addressed by type inference</p>
    <p>` t : T t : T</p>
    <p>I Looks like coercions could solve these typing errors</p>
    <p>(k, (N,Z ))    ` k x : Z Z ?= Z</p>
    <p>` x : N</p>
    <p>k x</p>
    <p>: Z</p>
    <p>I but (uniform) coercions are type theoretic functions whose insertion is type driven.</p>
  </div>
  <div class="page">
    <p>Type inference and coercions</p>
    <p>I These problems have to be addressed by type inference</p>
    <p>` t : T t : T</p>
    <p>I Looks like coercions could solve these typing errors</p>
    <p>(k, (N,Z ))</p>
    <p>` k x : Z Z ?= Z</p>
    <p>` x : N</p>
    <p>k x</p>
    <p>: Z</p>
    <p>I but (uniform) coercions are type theoretic functions whose insertion is type driven.</p>
  </div>
  <div class="page">
    <p>Type inference and coercions</p>
    <p>I These problems have to be addressed by type inference</p>
    <p>` t : T t : T</p>
    <p>I Looks like coercions could solve these typing errors</p>
    <p>(k, (N,Z ))</p>
    <p>` k x : Z Z ?= Z</p>
    <p>` x : N</p>
    <p>k x</p>
    <p>: Z</p>
    <p>I but (uniform) coercions are type theoretic functions whose insertion is type driven.</p>
  </div>
  <div class="page">
    <p>Type inference and coercions</p>
    <p>I These problems have to be addressed by type inference</p>
    <p>` t : T t : T</p>
    <p>I Looks like coercions could solve these typing errors</p>
    <p>(k, (N,Z ))</p>
    <p>` k x : Z Z ?= Z</p>
    <p>` x : N</p>
    <p>k x</p>
    <p>: Z</p>
    <p>I but (uniform) coercions are type theoretic functions whose insertion is type driven.</p>
  </div>
  <div class="page">
    <p>Type inference and coercions</p>
    <p>I These problems have to be addressed by type inference</p>
    <p>` t : T t : T</p>
    <p>I Looks like coercions could solve these typing errors</p>
    <p>(k, (N,Z ))    ` k x : Z</p>
    <p>Z ?</p>
    <p>= Z</p>
    <p>` x : N</p>
    <p>k x</p>
    <p>: Z</p>
    <p>I but (uniform) coercions are type theoretic functions whose insertion is type driven.</p>
  </div>
  <div class="page">
    <p>Type inference and coercions</p>
    <p>I These problems have to be addressed by type inference</p>
    <p>` t : T t : T</p>
    <p>I Looks like coercions could solve these typing errors</p>
    <p>(k, (N,Z ))    ` k x : Z Z ?= Z  ` x : N</p>
    <p>k x</p>
    <p>: Z</p>
    <p>I but (uniform) coercions are type theoretic functions whose insertion is type driven.</p>
  </div>
  <div class="page">
    <p>Type inference and coercions</p>
    <p>I These problems have to be addressed by type inference</p>
    <p>` t : T t : T</p>
    <p>I Looks like coercions could solve these typing errors</p>
    <p>(k, (N,Z ))    ` k x : Z Z ?= Z  ` x : N k x : Z</p>
    <p>I but (uniform) coercions are type theoretic functions whose insertion is type driven.</p>
  </div>
  <div class="page">
    <p>Type inference and coercions</p>
    <p>I These problems have to be addressed by type inference</p>
    <p>` t : T t : T</p>
    <p>I Looks like coercions could solve these typing errors</p>
    <p>(k, (N,Z ))    ` k x : Z Z ?= Z  ` x : N k x : Z</p>
    <p>I but (uniform) coercions are type theoretic functions whose insertion is type driven.</p>
    <p>( .Z, (Type,Group))    ` ( .Z) Z : Group  ` Z : Type ( .Z) Z : Group</p>
  </div>
  <div class="page">
    <p>Type inference and coercions</p>
    <p>I These problems have to be addressed by type inference</p>
    <p>` t : T t : T</p>
    <p>I Looks like coercions could solve these typing errors</p>
    <p>(k, (N,Z ))    ` k x : Z Z ?= Z  ` x : N k x : Z</p>
    <p>I but (uniform) coercions are type theoretic functions whose insertion is type driven.</p>
    <p>( .Z, (Type,Group))    ` ( .Z) Q : Group  ` Q : Type ( .Z) Q : Group</p>
  </div>
  <div class="page">
    <p>Nonuniform coercions</p>
    <p>=</p>
    <p>{ 1 `</p>
    <p>S1  T1 s1 7 t1</p>
    <p>. . . n ` Sn  Tn sn 7 tn</p>
    <p>} where</p>
    <p>i ` si : Si i ` ti : Ti</p>
    <p>Inserting a nonuniform coercion works as follows:</p>
    <p>( i `</p>
    <p>Si  Ti si 7 ti</p>
    <p>)</p>
    <p>S ?</p>
    <p>= Si s</p>
    <p>? = si</p>
    <p>T ?</p>
    <p>= Ti</p>
    <p>` s : S</p>
    <p>ti</p>
    <p>: T</p>
    <p>where variables in i are replaced by unification variables.</p>
  </div>
  <div class="page">
    <p>Nonuniform coercions</p>
    <p>=</p>
    <p>{ 1 `</p>
    <p>S1  T1 s1 7 t1</p>
    <p>. . . n ` Sn  Tn sn 7 tn</p>
    <p>} where</p>
    <p>i ` si : Si i ` ti : Ti</p>
    <p>Inserting a nonuniform coercion works as follows:</p>
    <p>( i `</p>
    <p>Si  Ti si 7 ti</p>
    <p>)</p>
    <p>S ?</p>
    <p>= Si s</p>
    <p>? = si</p>
    <p>T ?</p>
    <p>= Ti</p>
    <p>` s : S</p>
    <p>ti</p>
    <p>: T</p>
    <p>where variables in i are replaced by unification variables.</p>
  </div>
  <div class="page">
    <p>Nonuniform coercions</p>
    <p>=</p>
    <p>{ 1 `</p>
    <p>S1  T1 s1 7 t1</p>
    <p>. . . n ` Sn  Tn sn 7 tn</p>
    <p>} where</p>
    <p>i ` si : Si i ` ti : Ti</p>
    <p>Inserting a nonuniform coercion works as follows:</p>
    <p>( i `</p>
    <p>Si  Ti si 7 ti</p>
    <p>)</p>
    <p>S ?</p>
    <p>= Si</p>
    <p>s ?</p>
    <p>= si T</p>
    <p>? = Ti</p>
    <p>` s : S</p>
    <p>ti</p>
    <p>: T</p>
    <p>where variables in i are replaced by unification variables.</p>
  </div>
  <div class="page">
    <p>Nonuniform coercions</p>
    <p>=</p>
    <p>{ 1 `</p>
    <p>S1  T1 s1 7 t1</p>
    <p>. . . n ` Sn  Tn sn 7 tn</p>
    <p>} where</p>
    <p>i ` si : Si i ` ti : Ti</p>
    <p>Inserting a nonuniform coercion works as follows:</p>
    <p>( i `</p>
    <p>Si  Ti si 7 ti</p>
    <p>)</p>
    <p>S ?</p>
    <p>= Si s</p>
    <p>? = si</p>
    <p>T ?</p>
    <p>= Ti</p>
    <p>` s : S</p>
    <p>ti</p>
    <p>: T</p>
    <p>where variables in i are replaced by unification variables.</p>
  </div>
  <div class="page">
    <p>Nonuniform coercions</p>
    <p>=</p>
    <p>{ 1 `</p>
    <p>S1  T1 s1 7 t1</p>
    <p>. . . n ` Sn  Tn sn 7 tn</p>
    <p>} where</p>
    <p>i ` si : Si i ` ti : Ti</p>
    <p>Inserting a nonuniform coercion works as follows:</p>
    <p>( i `</p>
    <p>Si  Ti si 7 ti</p>
    <p>)</p>
    <p>S ?</p>
    <p>= Si s</p>
    <p>? = si</p>
    <p>T ?</p>
    <p>= Ti</p>
    <p>` s : S</p>
    <p>ti</p>
    <p>: T</p>
    <p>where variables in i are replaced by unification variables.</p>
  </div>
  <div class="page">
    <p>Nonuniform coercions</p>
    <p>=</p>
    <p>{ 1 `</p>
    <p>S1  T1 s1 7 t1</p>
    <p>. . . n ` Sn  Tn sn 7 tn</p>
    <p>} where</p>
    <p>i ` si : Si i ` ti : Ti</p>
    <p>Inserting a nonuniform coercion works as follows:</p>
    <p>( i `</p>
    <p>Si  Ti si 7 ti</p>
    <p>)</p>
    <p>S ?</p>
    <p>= Si s</p>
    <p>? = si</p>
    <p>T ?</p>
    <p>= Ti</p>
    <p>` s : S ti : T where variables in i are replaced by unification variables.</p>
  </div>
  <div class="page">
    <p>Nonuniform coercions: examples</p>
    <p>Uniform coercions</p>
    <p>x : N ` N  Z x 7 k x</p>
    <p>Nonuniform coercions</p>
    <p>` Type  Group Z 7 Z</p>
    <p>` Type  Group Q 7 Q</p>
  </div>
  <div class="page">
    <p>Cheap implementation: ingredient #1</p>
    <p>Unification hints:</p>
    <p>?x :=</p>
    <p>H</p>
    <p>` myhint P  Q</p>
    <p>Examples:</p>
    <p>?G := Z` Z  carr ?G</p>
    <p>?A := carr G ?B := carr H</p>
    <p>?X := product group G H G,H : Group `</p>
    <p>?A  ?B  carr ?X</p>
  </div>
  <div class="page">
    <p>Cheap implementation: ingredient #1</p>
    <p>Unification hints:</p>
    <p>?x :=</p>
    <p>H</p>
    <p>` myhint P  Q</p>
    <p>Examples:</p>
    <p>?G := Z` Z  carr ?G</p>
    <p>?A := carr G ?B := carr H</p>
    <p>?X := product group G H G,H : Group `</p>
    <p>?A  ?B  carr ?X</p>
  </div>
  <div class="page">
    <p>Cheap implementation: ingredient #1</p>
    <p>Unification hints:</p>
    <p>?x :=</p>
    <p>H</p>
    <p>` myhint P  Q</p>
    <p>Examples:</p>
    <p>?G := Z` Z  carr ?G</p>
    <p>?A := carr G ?B := carr H</p>
    <p>?X := product group G H G,H : Group `</p>
    <p>?A  ?B  carr ?X</p>
  </div>
  <div class="page">
    <p>Cheap implementation: ingredient #1 (cont.)</p>
    <p>Note that hints define equivalence classes of constants, thus approximated indexing for fast retrieval must take them into account.</p>
    <p>(k, (N,Z ))    ` k s : Z Z ?= carr Z  ` s : N k s : carr Z</p>
  </div>
  <div class="page">
    <p>Cheap implementation: ingredient #1 (cont.)</p>
    <p>Note that hints define equivalence classes of constants, thus approximated indexing for fast retrieval must take them into account.</p>
    <p>(k, (N,Z ))    ` k s : Z Z ?= carr Z  ` s : N k s : carr Z</p>
  </div>
  <div class="page">
    <p>Cheap implementation: ingredient #2</p>
    <p>Uniform coercion loosely indexed:</p>
    <p>(result, (,target))    ` result s : target target ?= T  ` x : S result s : T</p>
    <p>Note that T and target can be in the same equivalence class.</p>
  </div>
  <div class="page">
    <p>Encoding nonuniform coercions</p>
    <p>record solution (S : Type) (s : S) : Type :={</p>
    <p>target : Type; ( T ) result : target ( t )</p>
    <p>}.</p>
    <p>coercion result : S:Type.s:S.sol:solution S s. target S s sol on s : ? &gt;&gt; target ???.</p>
    <p>s result ? s ?sol</p>
  </div>
  <div class="page">
    <p>Encoding nonuniform coercions</p>
    <p>record solution (S : Type) (s : S) : Type :={</p>
    <p>target : Type; ( T ) result : target ( t )</p>
    <p>}.</p>
    <p>coercion result : S:Type.s:S.sol:solution S s. target S s sol on s : ? &gt;&gt; target ???.</p>
    <p>s result ? s ?sol</p>
  </div>
  <div class="page">
    <p>Declaring nonuniform coercions</p>
    <p>` Type  Group Z 7 Z</p>
    <p>(result, (,target))    ` result ? Z ?sol : target Type Z ?sol</p>
    <p>target Type Z ?sol ?</p>
    <p>= Group</p>
    <p>` Z : Type</p>
    <p>result ? Z ?sol</p>
    <p>: Group</p>
    <p>We declare the following hint:</p>
    <p>?sol := mk solution Type Z Group Z` target Type Z ?sol  Group</p>
    <p>Note that:</p>
    <p>target Type Z ?sol BGroup result Type Z ?sol BZ</p>
  </div>
  <div class="page">
    <p>Declaring nonuniform coercions</p>
    <p>` Type  Group Z 7 Z</p>
    <p>(result, (,target))</p>
    <p>` result ? Z ?sol : target Type Z ?sol target Type Z ?sol</p>
    <p>? = Group</p>
    <p>` Z : Type</p>
    <p>result ? Z ?sol</p>
    <p>: Group</p>
    <p>We declare the following hint:</p>
    <p>?sol := mk solution Type Z Group Z` target Type Z ?sol  Group</p>
    <p>Note that:</p>
    <p>target Type Z ?sol BGroup result Type Z ?sol BZ</p>
  </div>
  <div class="page">
    <p>Declaring nonuniform coercions</p>
    <p>` Type  Group Z 7 Z</p>
    <p>(result, (,target))</p>
    <p>` result ? Z ?sol : target Type Z ?sol target Type Z ?sol</p>
    <p>? = Group</p>
    <p>` Z : Type</p>
    <p>result ? Z ?sol</p>
    <p>: Group</p>
    <p>We declare the following hint:</p>
    <p>?sol := mk solution Type Z Group Z` target Type Z ?sol  Group</p>
    <p>Note that:</p>
    <p>target Type Z ?sol BGroup result Type Z ?sol BZ</p>
  </div>
  <div class="page">
    <p>Declaring nonuniform coercions</p>
    <p>` Type  Group Z 7 Z</p>
    <p>(result, (,target))</p>
    <p>` result ? Z ?sol : target Type Z ?sol target Type Z ?sol</p>
    <p>? = Group</p>
    <p>` Z : Type</p>
    <p>result ? Z ?sol</p>
    <p>: Group</p>
    <p>We declare the following hint:</p>
    <p>?sol := mk solution Type Z Group Z` target Type Z ?sol  Group</p>
    <p>Note that:</p>
    <p>target Type Z ?sol BGroup result Type Z ?sol BZ</p>
  </div>
  <div class="page">
    <p>Declaring nonuniform coercions</p>
    <p>` Type  Group Z 7 Z</p>
    <p>(result, (,target))    ` result ? Z ?sol : target Type Z ?sol</p>
    <p>target Type Z ?sol ?</p>
    <p>= Group</p>
    <p>` Z : Type</p>
    <p>result ? Z ?sol</p>
    <p>: Group</p>
    <p>We declare the following hint:</p>
    <p>?sol := mk solution Type Z Group Z` target Type Z ?sol  Group</p>
    <p>Note that:</p>
    <p>target Type Z ?sol BGroup result Type Z ?sol BZ</p>
  </div>
  <div class="page">
    <p>Declaring nonuniform coercions</p>
    <p>` Type  Group Z 7 Z</p>
    <p>(result, (,target))    ` result ? Z ?sol : target Type Z ?sol</p>
    <p>target Type Z ?sol ?</p>
    <p>= Group  ` Z : Type</p>
    <p>result ? Z ?sol</p>
    <p>: Group</p>
    <p>We declare the following hint:</p>
    <p>?sol := mk solution Type Z Group Z` target Type Z ?sol  Group</p>
    <p>Note that:</p>
    <p>target Type Z ?sol BGroup result Type Z ?sol BZ</p>
  </div>
  <div class="page">
    <p>Declaring nonuniform coercions</p>
    <p>` Type  Group Z 7 Z</p>
    <p>(result, (,target))    ` result ? Z ?sol : target Type Z ?sol</p>
    <p>target Type Z ?sol ?</p>
    <p>= Group  ` Z : Type result ? Z ?sol : Group</p>
    <p>We declare the following hint:</p>
    <p>?sol := mk solution Type Z Group Z` target Type Z ?sol  Group</p>
    <p>Note that:</p>
    <p>target Type Z ?sol BGroup result Type Z ?sol BZ</p>
  </div>
  <div class="page">
    <p>Declaring nonuniform coercions</p>
    <p>` Type  Group Z 7 Z</p>
    <p>(result, (,target))    ` result ? Z ?sol : target Type Z ?sol</p>
    <p>target Type Z ?sol ?</p>
    <p>= Group  ` Z : Type result ? Z ?sol : Group</p>
    <p>We declare the following hint:</p>
    <p>?sol := mk solution Type Z Group Z` target Type Z ?sol  Group</p>
    <p>Note that:</p>
    <p>target Type Z ?sol BGroup result Type Z ?sol BZ</p>
  </div>
  <div class="page">
    <p>Declaring nonuniform coercions</p>
    <p>` Type  Group Z 7 Z</p>
    <p>(result, (,target))    ` result ? Z ?sol : target Type Z ?sol</p>
    <p>target Type Z ?sol ?</p>
    <p>= Group  ` Z : Type result ? Z ?sol : Group</p>
    <p>We declare the following hint:</p>
    <p>?sol := mk solution Type Z Group Z` target Type Z ?sol  Group</p>
    <p>Note that:</p>
    <p>target Type Z ?sol BGroup</p>
    <p>result Type Z ?sol BZ</p>
  </div>
  <div class="page">
    <p>Declaring nonuniform coercions</p>
    <p>` Type  Group Z 7 Z</p>
    <p>(result, (,target))    ` result ? Z ?sol : target Type Z ?sol</p>
    <p>target Type Z ?sol ?</p>
    <p>= Group  ` Z : Type result ? Z ?sol : Group</p>
    <p>We declare the following hint:</p>
    <p>?sol := mk solution Type Z Group Z` target Type Z ?sol  Group</p>
    <p>Note that:</p>
    <p>target Type Z ?sol BGroup result Type Z ?sol BZ</p>
  </div>
  <div class="page">
    <p>Declaring nonuniform coercions (the right way)</p>
    <p>This is unsatisfactory, we need one new hint per coercion</p>
    <p>?sol := mk solution Type Z Group Z` target Type Z ?sol  Group</p>
    <p>Moreover, the system is already aware that</p>
    <p>?G := Z  `</p>
    <p>Z  carr ?G We need only this hint:</p>
    <p>?Z := carr G ?sol := mk solution Type ?Z Group G</p>
    <p>G : Group ` target Type ?Z ?sol  Group</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Nonuniform coercions:</p>
    <p>I Generalization of type-theoretic coercions</p>
    <p>I Cheap implementation on top of unification hints</p>
    <p>I Both type inference and unification can exploit the knowledge expressed in terms of Unification Hints</p>
    <p>Further research:</p>
    <p>I Notion of coherence (sanity check on  as a whole)</p>
    <p>I Notion of composition for nonuniform coercions</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Nonuniform coercions:</p>
    <p>I Generalization of type-theoretic coercions</p>
    <p>I Cheap implementation on top of unification hints</p>
    <p>I Both type inference and unification can exploit the knowledge expressed in terms of Unification Hints</p>
    <p>Further research:</p>
    <p>I Notion of coherence (sanity check on  as a whole)</p>
    <p>I Notion of composition for nonuniform coercions</p>
  </div>
  <div class="page">
    <p>Thanks</p>
    <p>Thanks for your attention!</p>
  </div>
</Presentation>
