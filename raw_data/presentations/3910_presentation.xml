<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Provenance Analyzer: Exploring Provenance Semantics with Logic Rules</p>
    <p>by Saumen Dey, Sean Riddle, and Bertram Ludscher</p>
  </div>
  <div class="page">
    <p>Overview  The Problem</p>
    <p>The Open Provenance Model  Toward a Temporal Semantics  Provenance Analyzer prototype</p>
    <p>Approach  Deductive  Abduce Time  Abduce Partial Order</p>
  </div>
  <div class="page">
    <p>Open Provenance Model  Graph model, N = P (processes) U A (artifacts)  Edge types</p>
    <p>A genby P (artifact A was generated by process P)  P1 informedBy P2 (process P1 influenced the execution of process P2)  A1 derivedFrom A2 (artifact A1 used A2 in its creation)  P used A (process P used artifact A)</p>
    <p>Time is optional annotation  Legality</p>
    <p>Each datum must have one immediate creating process  Broken use-generate-derive triangles [1] are not allowed</p>
    <p>Few completeness restrictions (a trace does not have to say very much  it is difficult to tell at a glance how detailed/ restrictive a trace is)</p>
  </div>
  <div class="page">
    <p>Legal OPM Trace</p>
    <p>Each artifact can only be precisely generated by one process</p>
    <p>Each precise derived from edge is part of a use-generatederive triangle</p>
    <p>!</p>
    <p>&quot; !&quot;#$%&amp;'!</p>
    <p>#</p>
    <p>!&quot;#$%&amp;'!</p>
    <p>Invalid!</p>
    <p>!&quot; !</p>
    <p>!&quot; !</p>
    <p>#</p>
    <p>&quot;!</p>
    <p>If then,</p>
  </div>
  <div class="page">
    <p>Example</p>
    <p>AP genby!</p>
    <p>B used!</p>
    <p>! Indicates edge has a role, used in algorithm in [1], use-generate-derive triangles</p>
  </div>
  <div class="page">
    <p>Example</p>
    <p>AB r</p>
    <p>P</p>
    <p>!r</p>
    <p>! Indicates edge has a role  Forms a use-generate</p>
    <p>derive triangle, which encodes additional semantics according to [1]</p>
    <p>P P use(P,B) A B</p>
    <p>P used B to create A</p>
  </div>
  <div class="page">
    <p>Many Different Possible Worlds</p>
    <p>P P use(P,B) A B</p>
    <p>P P use(P,B) A B</p>
    <p>P P use(P,B) A B</p>
    <p>(5 models elided) AP genby!</p>
    <p>B used!</p>
  </div>
  <div class="page">
    <p>Deductive Algorithm  From Kwasnikowska et al.[1]  Graph patterns  Temporal constraints  .</p>
    <p>(ax 1) P</p>
    <p>begin(P ) ! end(P ) (1)</p>
    <p>B</p>
    <p>A</p>
    <p>create(B) ! create(A)</p>
    <p>(ax 2) A</p>
    <p>P</p>
    <p>!</p>
    <p>begin(P ) ! create(A) ! end(P ) (2)</p>
    <p>A</p>
    <p>P</p>
    <p>begin(P ) ! create(A)</p>
    <p>(ax 3) P</p>
    <p>A</p>
    <p>r</p>
    <p>begin(P ) ! use(P, r, A) ! end(P ) create(A) ! use(P, r, A)</p>
    <p>(3) P</p>
    <p>A</p>
    <p>create(A) ! end(P ) (4)</p>
    <p>P</p>
    <p>Q</p>
    <p>begin(Q) ! end(P ) (5)</p>
    <p>r</p>
    <p>P</p>
    <p>A</p>
    <p>B</p>
    <p>create(B) ! use(P, r, A)</p>
    <p>(6)</p>
    <p>Q</p>
    <p>r</p>
    <p>P</p>
    <p>A</p>
    <p>begin(Q) ! use(P, r, A) (ax 8)</p>
    <p>r</p>
    <p>B</p>
    <p>A</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>use(P, r, B) ! create(A)</p>
    <p>(7) A</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>r</p>
    <p>B</p>
    <p>C</p>
    <p>use(P, r, C) ! create(A) (8)</p>
    <p>Q</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>r</p>
    <p>A</p>
    <p>B</p>
    <p>use(P, r, B) ! end(Q)</p>
    <p>(9a)</p>
    <p>s</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>r</p>
    <p>A</p>
    <p>B</p>
    <p>Q</p>
    <p>use(P, r, B) ! use(Q, s, A) (9b)</p>
    <p>s</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>C</p>
    <p>B</p>
    <p>r</p>
    <p>A</p>
    <p>Q</p>
    <p>use(P, r, B) ! use(Q, s, A)</p>
    <p>Figure 7: Characterization of temporal inference.</p>
    <p>P starts</p>
    <p>P ends</p>
    <p>P uses B A</p>
    <p>created</p>
    <p>B</p>
    <p>created</p>
  </div>
  <div class="page">
    <p>Implementation  Implemented in ASP (answer set programming) system</p>
    <p>DLV: dlvsystem.com  Instrumented/interconnected with Python  Sets of rules run in different combinations:</p>
    <p>Definitions of axioms in different terms (deductive, abductive over different structures)</p>
    <p>Definitions of OPM legality  Rules to generate linear extensions of a partial order (ie., total</p>
    <p>orders that obey the partial order)</p>
  </div>
  <div class="page">
    <p>ASP Example</p>
    <p>a :- not b. b :- not a.</p>
    <p>Evaluate bodies of rules wrt model; does it produce same model?</p>
    <p>Is {a} a model? Yes.  a :- true  b :- false</p>
    <p>Is {b} a model? Yes.  a :- false  b :- true</p>
    <p>Is {a, b} a model? No.  a :- false  b :- false</p>
  </div>
  <div class="page">
    <p>Implementation - Deductive  Implemented axioms and temporal inference rules from</p>
    <p>[1]  Deductive generation of constraints from graph structure</p>
    <p>Axiom 2 prototype implementation</p>
    <p>leq(beginP, createA) :pGenBy(a, p). leq(createA, endP) :pGenBy(a, p).</p>
    <p>Axiom 2 as given by [1]</p>
    <p>(ax 1) P</p>
    <p>begin(P ) ! end(P ) (1)</p>
    <p>B</p>
    <p>A</p>
    <p>create(B) ! create(A)</p>
    <p>(ax 2) A</p>
    <p>P</p>
    <p>!</p>
    <p>begin(P ) ! create(A) ! end(P ) (2)</p>
    <p>A</p>
    <p>P</p>
    <p>begin(P ) ! create(A)</p>
    <p>(ax 3) P</p>
    <p>A</p>
    <p>r</p>
    <p>begin(P ) ! use(P, r, A) ! end(P ) create(A) ! use(P, r, A)</p>
    <p>(3) P</p>
    <p>A</p>
    <p>create(A) ! end(P ) (4)</p>
    <p>P</p>
    <p>Q</p>
    <p>begin(Q) ! end(P ) (5)</p>
    <p>r</p>
    <p>P</p>
    <p>A</p>
    <p>B</p>
    <p>create(B) ! use(P, r, A)</p>
    <p>(6)</p>
    <p>Q</p>
    <p>r</p>
    <p>P</p>
    <p>A</p>
    <p>begin(Q) ! use(P, r, A) (ax 8)</p>
    <p>r</p>
    <p>B</p>
    <p>A</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>use(P, r, B) ! create(A)</p>
    <p>(7) A</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>r</p>
    <p>B</p>
    <p>C</p>
    <p>use(P, r, C) ! create(A) (8)</p>
    <p>Q</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>r</p>
    <p>A</p>
    <p>B</p>
    <p>use(P, r, B) ! end(Q)</p>
    <p>(9a)</p>
    <p>s</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>r</p>
    <p>A</p>
    <p>B</p>
    <p>Q</p>
    <p>use(P, r, B) ! use(Q, s, A) (9b)</p>
    <p>s</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>C</p>
    <p>B</p>
    <p>r</p>
    <p>A</p>
    <p>Q</p>
    <p>use(P, r, B) ! use(Q, s, A)</p>
    <p>Figure 7: Characterization of temporal inference.</p>
  </div>
  <div class="page">
    <p>Implementation  Abduce Time  Abductive approach guesses mapping of events to time</p>
    <p>points and throws out violators.</p>
    <p>Axiom 2 as given by [1]</p>
    <p>(ax 1) P</p>
    <p>begin(P ) ! end(P ) (1)</p>
    <p>B</p>
    <p>A</p>
    <p>create(B) ! create(A)</p>
    <p>(ax 2) A</p>
    <p>P</p>
    <p>!</p>
    <p>begin(P ) ! create(A) ! end(P ) (2)</p>
    <p>A</p>
    <p>P</p>
    <p>begin(P ) ! create(A)</p>
    <p>(ax 3) P</p>
    <p>A</p>
    <p>r</p>
    <p>begin(P ) ! use(P, r, A) ! end(P ) create(A) ! use(P, r, A)</p>
    <p>(3) P</p>
    <p>A</p>
    <p>create(A) ! end(P ) (4)</p>
    <p>P</p>
    <p>Q</p>
    <p>begin(Q) ! end(P ) (5)</p>
    <p>r</p>
    <p>P</p>
    <p>A</p>
    <p>B</p>
    <p>create(B) ! use(P, r, A)</p>
    <p>(6)</p>
    <p>Q</p>
    <p>r</p>
    <p>P</p>
    <p>A</p>
    <p>begin(Q) ! use(P, r, A) (ax 8)</p>
    <p>r</p>
    <p>B</p>
    <p>A</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>use(P, r, B) ! create(A)</p>
    <p>(7) A</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>r</p>
    <p>B</p>
    <p>C</p>
    <p>use(P, r, C) ! create(A) (8)</p>
    <p>Q</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>r</p>
    <p>A</p>
    <p>B</p>
    <p>use(P, r, B) ! end(Q)</p>
    <p>(9a)</p>
    <p>s</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>r</p>
    <p>A</p>
    <p>B</p>
    <p>Q</p>
    <p>use(P, r, B) ! use(Q, s, A) (9b)</p>
    <p>s</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>C</p>
    <p>B</p>
    <p>r</p>
    <p>A</p>
    <p>Q</p>
    <p>use(P, r, B) ! use(Q, s, A)</p>
    <p>Figure 7: Characterization of temporal inference.</p>
    <p>Axiom 2 prototype implementation</p>
    <p>false :pGenBy(a, p), at(createA, TA), at(beginP, TP), TP &gt; TA. false :pGenBy(a, p), at(createA, TA), at(endP, TP), TA &gt; TP.</p>
  </div>
  <div class="page">
    <p>Implementation  Abduce Partial Order  Abductive approach guesses mapping of events to events</p>
    <p>and then throws out all that do not describe a partial order (or total order if desired).</p>
    <p>Axiom 2 as given by [1]</p>
    <p>(ax 1) P</p>
    <p>begin(P ) ! end(P ) (1)</p>
    <p>B</p>
    <p>A</p>
    <p>create(B) ! create(A)</p>
    <p>(ax 2) A</p>
    <p>P</p>
    <p>!</p>
    <p>begin(P ) ! create(A) ! end(P ) (2)</p>
    <p>A</p>
    <p>P</p>
    <p>begin(P ) ! create(A)</p>
    <p>(ax 3) P</p>
    <p>A</p>
    <p>r</p>
    <p>begin(P ) ! use(P, r, A) ! end(P ) create(A) ! use(P, r, A)</p>
    <p>(3) P</p>
    <p>A</p>
    <p>create(A) ! end(P ) (4)</p>
    <p>P</p>
    <p>Q</p>
    <p>begin(Q) ! end(P ) (5)</p>
    <p>r</p>
    <p>P</p>
    <p>A</p>
    <p>B</p>
    <p>create(B) ! use(P, r, A)</p>
    <p>(6)</p>
    <p>Q</p>
    <p>r</p>
    <p>P</p>
    <p>A</p>
    <p>begin(Q) ! use(P, r, A) (ax 8)</p>
    <p>r</p>
    <p>B</p>
    <p>A</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>use(P, r, B) ! create(A)</p>
    <p>(7) A</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>r</p>
    <p>B</p>
    <p>C</p>
    <p>use(P, r, C) ! create(A) (8)</p>
    <p>Q</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>r</p>
    <p>A</p>
    <p>B</p>
    <p>use(P, r, B) ! end(Q)</p>
    <p>(9a)</p>
    <p>s</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>r</p>
    <p>A</p>
    <p>B</p>
    <p>Q</p>
    <p>use(P, r, B) ! use(Q, s, A) (9b)</p>
    <p>s</p>
    <p>P</p>
    <p>!</p>
    <p>r</p>
    <p>C</p>
    <p>B</p>
    <p>r</p>
    <p>A</p>
    <p>Q</p>
    <p>use(P, r, B) ! use(Q, s, A)</p>
    <p>Figure 7: Characterization of temporal inference.</p>
    <p>Axiom 2 prototype implementation</p>
    <p>false :pGenBy(a, p), after(beginP, createA). false :pGenBy(a, p), after(createA, endP).</p>
  </div>
  <div class="page">
    <p>Abduce Time vs. Abduce Partial Order  Abduce Time faster on small examples, sensitive to</p>
    <p>definition of time points (too many can cause drastic slowdown)</p>
    <p>Abduce Time allows for constraints that depend on time, eg., creation events can only occur with a certain maximum frequency</p>
  </div>
  <div class="page">
    <p>Design</p>
    <p>ComputePO</p>
    <p>One partial order</p>
    <p>ComputeTO</p>
    <p>Events Ev</p>
    <p>GuessPO</p>
    <p>TOFilter</p>
    <p>GuessTime</p>
    <p>TOFilter</p>
    <p>Inferences 1-9B &amp; Extended Axioms Axioms 4-7 Axioms 1-3,8</p>
    <p>Deduce Partial Order Abduce Partial Order Abduce Time</p>
    <p>All possible partial orders</p>
    <p>All possible total orders</p>
    <p>All valid total orders of</p>
    <p>events</p>
    <p>(T-E)!</p>
    <p>E! E! E!</p>
  </div>
  <div class="page">
    <p>Conclusions and Future Work  Provides measure of constrained-ness (how many total</p>
    <p>orders of events correspond to this trace?)  Can query what is true in some/all models (analogous to</p>
    <p>brave/cautious reasoning in LP)  Allows experimentation with axioms  Future work</p>
    <p>Combinations of axioms that describe easily characterizable subsets of temporal constraints (eg., no-use inequalities)</p>
    <p>Increase performance with subsumption</p>
  </div>
  <div class="page">
    <p>Provenance Analyzer  Available at:</p>
    <p>http://code.google.com/p/provenance-analyzer  Works Cited</p>
    <p>Acknowledgements  Work supported in part by NSF awards DGE-0841297,</p>
    <p>OCI-0830944, and IIS-1118088.</p>
  </div>
</Presentation>
