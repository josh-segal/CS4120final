<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Preferred Operators and Deferred Evaluation in Satisficing Planning</p>
    <p>Silvia Richter1 Malte Helmert2</p>
    <p>ICAPS 2009</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Deferred Evaluation Preferred Operators</p>
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Deferred Evaluation Preferred Operators</p>
    <p>Motivation</p>
    <p>Preferred operators and deferred evaluation used by many planners (Fast Downward, LAMA, Temporal Fast Downward, many research systems)</p>
    <p>However, little empirical evidence to date:</p>
    <p>Best use of preferred operators? (cf. FFs helpful actions vs. Fast Downwards pref. ops.)</p>
    <p>How useful is deferred evaluation?</p>
    <p>Is there interaction?</p>
    <p>We fill this gap in common knowledge Experiments conducted with greedy best-first search</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Deferred Evaluation Preferred Operators</p>
    <p>Deferred Evaluation</p>
    <p>Standard greedy best-first search (Eager): Given a state,</p>
    <p>Generate successors and compute their heuristic values</p>
    <p>Enqueue successors with their h-values</p>
    <p>Remove state with minimal h-value from queue, iterate</p>
    <p>Observation: Most time (80%!) spent on heuristic computation, often many more states generated than expanded Idea: compute h-values only for expanded states</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Deferred Evaluation Preferred Operators</p>
    <p>Deferred Evaluation (cont.)</p>
    <p>Deferred evaluation (Lazy):</p>
    <p>Do not compute h-values of successors immediately</p>
    <p>Enqueue successors with parents h-value</p>
    <p>When removing state from queue, compute its h-value</p>
    <p>Lazy reduces expansion time, but results in loss of heuristic accuracy</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Deferred Evaluation Preferred Operators</p>
    <p>Preferred Operators</p>
    <p>Idea of preferred operators:</p>
    <p>Prefer actions that are likely to lead to better state</p>
    <p>Those which appear in simplified solution (and are applicable)</p>
    <p>Identified during computation of heuristic</p>
    <p>Generation:</p>
    <p>FF heuristic: actions from relaxed plan, e. g. best supports for necessary facts, calculated recursively from goals</p>
    <p>Additive heuristic: same method as in FF heuristic</p>
    <p>Causal Graph (CG) &amp; Context-enhanced additive (cea) heuristics: actions that achieve necessary changes in DTGs</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Deferred Evaluation Preferred Operators</p>
    <p>Preferred Operators (cont.)</p>
    <p>Methods of exploitation:</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Deferred Evaluation Preferred Operators</p>
    <p>Preferred Operators (cont.)</p>
    <p>Prune all states that are not preferred successors If that fails (no solution), restart without pref. ops. Radical, but potentially very helpful method due to reduced branching factor</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Deferred Evaluation Preferred Operators</p>
    <p>Preferred Operators (cont.)</p>
    <p>Add separate queue for preferred successors When expanding states, alternate between queues preferred successors expanded sooner, on average Less radical than pruning, search remains complete</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Deferred Evaluation Preferred Operators</p>
    <p>Preferred Operators (cont.)</p>
    <p>Expand states from preferred queue more often Whenever progress was made (new best h-value), expand 1000 more preferred successors Boosts accumulate if progress made again within 1000 states Complete as dual queue, but more aggressive if search progresses quickly</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Deferred Evaluation Preferred Operators</p>
    <p>Preferred Operators (cont.)</p>
    <p>Expand preferred successors whenever possible Only if pref. succs. run out, use non-preferred successors Within each group, choose as usual (according to h-values) Similar to pruning (expands same states as long as pref. succs. present) Unlike pruning complete, but does not reduce branching factor</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Deferred Evaluation Preferred Operators</p>
    <p>Preferred Operators (cont.)</p>
    <p>Use preferred operators for tie-breaking Always expand the state with lowest h-value If several states equally good, expand any preferred ones first Comparatively subtle way of using preferred operators Expectation: likely to be useful (and unlikely to be harmful)</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Experimental Setup</p>
    <p>All IPC tasks from 19982006</p>
    <p>Results measured via scores with range 0100 (higher score better)</p>
    <p>Coverage: normalised percentage of tasks solved</p>
    <p>Quality (plan length): IPC-2008 criterion q/q  100 Evaluations:  100  100 pts.,  1,000,000  0 pts., log interpolation</p>
    <p>Runtime:  1sec  100 pts.,  30min  0 pts., log interpolation</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Results FF Heuristic</p>
    <p>Search Pref. Op. Use Coverage Quality Eval. Time Score Score Score Score</p>
    <p>FF Heuristic</p>
    <p>Lazy</p>
    <p>None 74.03 68.19 54.34 67.63 Heur. &gt; Pref. 79.11 72.65 62.92 72.29 Pref. &gt; Heur. 83.71 75.40 70.75 79.08 Pruning 84.02 76.01 70.52 79.49 Dual Queue 83.43 77.00 65.11 76.14 B. Dual Queue 86.74 78.83 72.58 81.95</p>
    <p>Eager</p>
    <p>None 75.07 72.08 52.42 68.08 Heur. &gt; Pref. 75.80 72.24 54.28 69.31 Pref. &gt; Heur. 81.42 76.86 58.20 74.66 Pruning 84.64 79.33 68.12 79.74 Dual Queue 86.89 83.22 60.91 79.17 B. Dual Queue 83.65 79.22 58.60 75.96</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Results FF Heuristic</p>
    <p>Search Pref. Op. Use Coverage Quality Eval. Time Score Score Score Score</p>
    <p>FF Heuristic</p>
    <p>Lazy</p>
    <p>None 74.03 68.19 54.34 67.63 Heur. &gt; Pref. 79.11 72.65 62.92 72.29 Pref. &gt; Heur. 83.71 75.40 70.75 79.08 Pruning 84.02 76.01 70.52 79.49 Dual Queue 83.43 77.00 65.11 76.14 B. Dual Queue 86.74 78.83 72.58 81.95</p>
    <p>Eager</p>
    <p>None 75.07 72.08 52.42 68.08 Heur. &gt; Pref. 75.80 72.24 54.28 69.31 Pref. &gt; Heur. 81.42 76.86 58.20 74.66 Pruning 84.64 79.33 68.12 79.74 Dual Queue 86.89 83.22 60.91 79.17 B. Dual Queue 83.65 79.22 58.60 75.96</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Results FF Heuristic</p>
    <p>Search Pref. Op. Use Coverage Quality Eval. Time Score Score Score Score</p>
    <p>FF Heuristic</p>
    <p>Lazy</p>
    <p>None 74.03 68.19 54.34 67.63 Heur. &gt; Pref. 79.11 72.65 62.92 72.29 Pref. &gt; Heur. 83.71 75.40 70.75 79.08 Pruning 84.02 76.01 70.52 79.49 Dual Queue 83.43 77.00 65.11 76.14 B. Dual Queue 86.74 78.83 72.58 81.95</p>
    <p>Eager</p>
    <p>None 75.07 72.08 52.42 68.08 Heur. &gt; Pref. 75.80 72.24 54.28 69.31 Pref. &gt; Heur. 81.42 76.86 58.20 74.66 Pruning 84.64 79.33 68.12 79.74 Dual Queue 86.89 83.22 60.91 79.17 B. Dual Queue 83.65 79.22 58.60 75.96</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Results Cea Heuristic</p>
    <p>Search Pref. Op. Use Coverage Quality Eval. Time Score Score Score Score</p>
    <p>Cea Heuristic</p>
    <p>Lazy</p>
    <p>None 74.06 67.85 54.97 66.08 Heur. &gt; Pref. 75.35 69.25 60.63 68.44 Pref. &gt; Heur. 83.57 74.71 68.39 76.50 Pruning 83.19 75.16 68.04 76.37 Dual Queue 80.14 73.45 63.68 72.68 B. Dual Queue 86.24 77.48 70.23 78.81</p>
    <p>Eager</p>
    <p>None 74.02 70.91 51.99 65.03 Heur. &gt; Pref. 74.00 70.77 52.44 65.26 Pref. &gt; Heur. 81.90 76.49 56.48 71.75 Pruning 83.48 77.98 66.17 76.44 Dual Queue 85.23 81.40 59.05 74.86 B. Dual Queue 84.10 78.39 56.89 72.58</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Results CG Heuristic</p>
    <p>Search Pref. Op. Use Coverage Quality Eval. Time Score Score Score Score</p>
    <p>CG Heuristic</p>
    <p>Lazy</p>
    <p>None 71.15 64.97 50.01 64.50 Heur. &gt; Pref. 72.96 65.46 54.29 66.53 Pref. &gt; Heur. 73.38 66.81 54.69 66.62 Pruning 72.38 66.05 52.36 65.37 Dual Queue 75.10 67.94 56.53 68.68 B. Dual Queue 76.38 69.57 56.47 69.42</p>
    <p>Eager</p>
    <p>None 71.82 68.51 47.90 64.20 Heur. &gt; Pref. 71.97 68.41 48.17 64.46 Pref. &gt; Heur. 71.22 67.78 47.34 64.30 Pruning 72.39 67.70 50.20 64.70 Dual Queue 75.74 72.61 49.67 67.52 B. Dual Queue 71.80 68.34 47.37 64.50</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Results Additive Heuristic</p>
    <p>Search Pref. Op. Use Coverage Quality Eval. Time Score Score Score Score</p>
    <p>Additive Heuristic</p>
    <p>Lazy</p>
    <p>None 70.84 63.72 50.64 63.93 Heur. &gt; Pref. 73.80 66.46 57.27 67.09 Pref. &gt; Heur. 83.56 75.08 66.96 77.58 Pruning 84.07 75.66 66.88 78.17 Dual Queue 78.18 70.57 59.75 70.75 B. Dual Queue 85.55 77.32 68.95 79.93</p>
    <p>Eager</p>
    <p>None 71.59 67.83 49.02 64.24 Heur. &gt; Pref. 72.26 67.94 49.94 64.97 Pref. &gt; Heur. 83.35 78.01 55.88 74.05 Pruning 84.88 79.47 65.24 78.60 Dual Queue 84.24 79.91 57.06 75.47 B. Dual Queue 84.71 79.45 56.33 75.08</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Results Overview (cont.)</p>
    <p>Preferred operators:</p>
    <p>Pref. ops. drastically improve performance (by 1015 pts.)  no. of unsolved tasks halved Pref. ops. much more important than heuristic ( 5 pts.) Best exploitation method depends on search type</p>
    <p>Results consistent across heuristics</p>
    <p>Best: Eager + dual queue or Lazy + boosted dual queue</p>
    <p>Stronger use of pref. ops. better for Lazy</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Results Overview (cont.)</p>
    <p>Search type:</p>
    <p>Eager and Lazy comparable on average re. coverage</p>
    <p>However: Lazy huge advantages in some cases</p>
    <p>Lazy faster, but worse-quality plans</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>A Controlled Experiment</p>
    <p>Q.: How does performance vary with heuristic accuracy and quality of pref. ops.?</p>
    <p>Experiment with artificial search space</p>
    <p>Start state has approx. goal distance (agd )</p>
    <p>Probability distribution over agd s of successors</p>
    <p>States with agd 0 are goals</p>
    <p>We test Eager in 3 configurations: without pref. ops., pruning and dual queue For each data point, results averaged over 100 runs</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>A Controlled Experiment (cont.)</p>
    <p>We vary 2 parameters dev . fac. and rec. rate</p>
    <p>Heuristic:</p>
    <p>Quality parameterized by number dev . fac. in range 0.10.9</p>
    <p>Defines how much h-value may deviate from agd of state</p>
    <p>Then dev (s) := random(0, dev . fac.), and h(s) := agd (s)  (dev (s)  agd (s))</p>
    <p>Preferred Operators:</p>
    <p>Quality parameterized by number rec. rate in range 0%100%</p>
    <p>If an action leads to a better state, prefer it randomly with probability rec. rate</p>
    <p>Else, prefer it with 10% probability</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Varying Quality of Preferred Operators (Rec. Rate)</p>
    <p>E va</p>
    <p>lu a</p>
    <p>tio n</p>
    <p>s</p>
    <p>Recognition rate for pref. ops. (%)</p>
    <p>No pref. ops. Pruning</p>
    <p>Dual queue</p>
    <p>Heuristic quality low (dev . fac. 0.5)</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Varying Quality of Preferred Operators (Rec. Rate)</p>
    <p>E va</p>
    <p>lu a</p>
    <p>tio n</p>
    <p>s</p>
    <p>Recognition rate for pref. ops. (%)</p>
    <p>No pref. ops. Pruning</p>
    <p>Dual queue</p>
    <p>Heuristic quality medium (dev . fac. 0.7)</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Varying Quality of Preferred Operators (Rec. Rate)</p>
    <p>E va</p>
    <p>lu a</p>
    <p>tio n</p>
    <p>s</p>
    <p>Recognition rate for pref. ops. (%)</p>
    <p>No pref. ops. Pruning</p>
    <p>Dual queue</p>
    <p>Heuristic quality high (dev . fac. 0.9)</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Results</p>
    <p>Even with high-quality heuristic, performance can be notably improved through good preferred operators</p>
    <p>However, bad pref. ops. may be detrimental to search</p>
    <p>Pruning reacts worse to bad pref. ops. than dual queue</p>
    <p>Dual queue good if rec. rate &gt; 2030%</p>
    <p>Pruning good if rec. rate &gt; 4050%</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Summary</p>
    <p>Preferred operators are extremely useful</p>
    <p>Deferred evaluation can be useful (but isnt on average)</p>
    <p>Dual queue is best method for pref. ops. in a standard BFS</p>
    <p>If using deferred evaluation, then use boosted dual queue</p>
    <p>Eager + dual queue  Lazy + boosted dual queue</p>
  </div>
  <div class="page">
    <p>Introduction Experiments on IPC benchmarks</p>
    <p>Thank you!</p>
    <p>Questions?</p>
  </div>
</Presentation>
