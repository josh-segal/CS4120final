<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>GraphX: Graph Processing in a  Distributed Dataflow Framework Joseph Gonzalez Postdoc, UC-Berkeley AMPLab Co-founder, GraphLab Inc.  Joint work with Reynold Xin, Ankur Dave, Daniel Crankshaw, Michael Franklin, and Ion Stoica OSDI 2014 UC BERKELEY</p>
  </div>
  <div class="page">
    <p>Modern Analytics</p>
    <p>Raw Wikipedia</p>
    <p>&lt; / &gt;!&lt; / &gt;!&lt; / &gt;! XML!</p>
    <p>Hyperlinks PageRank Top 20 Pages Title PR</p>
    <p>Link Table Title Link</p>
    <p>Editor Graph Community Detection</p>
    <p>User Community</p>
    <p>User Com.</p>
    <p>Discussion Table</p>
    <p>User Disc.</p>
    <p>Top Communities Com. PR..</p>
  </div>
  <div class="page">
    <p>Tables</p>
    <p>Raw Wikipedia</p>
    <p>&lt; / &gt;!&lt; / &gt;!&lt; / &gt;! XML!</p>
    <p>Hyperlinks PageRank Top 20 Pages Title PR</p>
    <p>Link Table Title Link</p>
    <p>Editor Graph Community Detection</p>
    <p>User Community</p>
    <p>User Com.</p>
    <p>Discussion Table</p>
    <p>User Disc.</p>
    <p>Top Communities Com. PR..</p>
  </div>
  <div class="page">
    <p>Graphs</p>
    <p>Raw Wikipedia</p>
    <p>&lt; / &gt;!&lt; / &gt;!&lt; / &gt;! XML!</p>
    <p>Hyperlinks PageRank Top 20 Pages Title PR</p>
    <p>Link Table Title Link</p>
    <p>Editor Graph Community Detection</p>
    <p>User Community</p>
    <p>User Com.</p>
    <p>Discussion Table</p>
    <p>User Disc.</p>
    <p>Top Communities Com. PR..</p>
  </div>
  <div class="page">
    <p>Separate Systems</p>
    <p>Tables Graphs</p>
  </div>
  <div class="page">
    <p>Separate Systems</p>
    <p>Graphs Dataflow Systems</p>
    <p>Table</p>
    <p>Result</p>
    <p>Row</p>
    <p>Row</p>
    <p>Row</p>
    <p>Row</p>
  </div>
  <div class="page">
    <p>Separate Systems Dataflow Systems Graph Systems</p>
    <p>Dependency Graph</p>
    <p>Table</p>
    <p>Result</p>
    <p>Row</p>
    <p>Row</p>
    <p>Row</p>
    <p>Row</p>
  </div>
  <div class="page">
    <p>Difficult to Use Users must Learn, Deploy, and Manage</p>
    <p>multiple systems</p>
    <p>Leads to brittle and often  complex interfaces</p>
  </div>
  <div class="page">
    <p>Inefficient</p>
    <p>Extensive data movement and duplication across  the network and file system</p>
    <p>&lt; / &gt;!&lt; / &gt;!&lt; / &gt;! XML!</p>
    <p>HDFS HDFS HDFS HDFS</p>
    <p>Limited reuse internal data-structures  across stages</p>
  </div>
  <div class="page">
    <p>Spark Dataflow Framework</p>
    <p>GraphX</p>
    <p>GraphX Unifies Computation on  Tables and Graphs</p>
    <p>Table View Graph View</p>
    <p>Enabling a single system to easily and efficiently support the entire pipeline</p>
  </div>
  <div class="page">
    <p>Separate Systems Dataflow Systems Graph Systems</p>
    <p>Dependency Graph</p>
    <p>Table</p>
    <p>Result</p>
    <p>Row</p>
    <p>Row</p>
    <p>Row</p>
    <p>Row</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>Separate Systems Dataflow Systems</p>
    <p>Dependency Graph</p>
    <p>Graph Systems 6. Before</p>
    <p>Table</p>
    <p>Result</p>
    <p>Row</p>
    <p>Row</p>
    <p>Row</p>
    <p>Row</p>
  </div>
  <div class="page">
    <p>GraphLab</p>
    <p>Spark</p>
    <p>Hadoop</p>
    <p>Runtime (in seconds, PageRank for 10 iterations)</p>
    <p>PageRank on the Live-Journal Graph</p>
    <p>Hadoop is 60x slower than GraphLab Spark is 16x slower than GraphLab</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>Key Question</p>
    <p>How can we naturally express and efficiently execute graph computation in a general purpose dataflow framework?</p>
    <p>Distill the lessons learned from specialized graph systems</p>
  </div>
  <div class="page">
    <p>Key Question</p>
    <p>How can we naturally express and efficiently execute graph computation in a general purpose dataflow framework?</p>
    <p>Representation Optimizations</p>
  </div>
  <div class="page">
    <p>Raw Wikipedia</p>
    <p>&lt; / &gt;!&lt; / &gt;!&lt; / &gt;! XML!</p>
    <p>Hyperlinks PageRank Top 20 Pages Title PR</p>
    <p>Link Table Title Link</p>
    <p>Editor Graph Community Detection</p>
    <p>User Community</p>
    <p>User Com.</p>
    <p>Discussion Table</p>
    <p>User Disc.</p>
    <p>Top Communities Com. PR..</p>
  </div>
  <div class="page">
    <p>Express computation locally:</p>
    <p>Iterate until convergence</p>
    <p>Rank of Page i Weighted sum of</p>
    <p>neighbors ranks</p>
    <p>Example Computation: PageRank</p>
    <p>Random Reset Prob.</p>
    <p>R[i] = 0.15 + X</p>
    <p>j2InLinks(i)</p>
    <p>R[j]</p>
    <p>OutLinks(j)</p>
  </div>
  <div class="page">
    <p>Think like a Vertex. - Malewicz et al., SIGMOD10</p>
  </div>
  <div class="page">
    <p>Gather information from neighboring vertices</p>
    <p>Graph-Parallel Pattern Gonzalez et al. [OSDI12]</p>
  </div>
  <div class="page">
    <p>Apply an update the vertex property</p>
    <p>Graph-Parallel Pattern Gonzalez et al. [OSDI12]</p>
  </div>
  <div class="page">
    <p>Scatter information to neighboring vertices</p>
    <p>Graph-Parallel Pattern Gonzalez et al. [OSDI12]</p>
  </div>
  <div class="page">
    <p>Many Graph-Parallel Algorithms Collaborative Filtering  Alternating Least Squares  Stochastic Gradient Descent  Tensor Factorization</p>
    <p>Structured Prediction  Loopy Belief Propagation  Max-Product Linear Programs  Gibbs Sampling</p>
    <p>Semi-supervised ML  Graph SSL  CoEM</p>
    <p>Community Detection  Triangle-Counting  K-core Decomposition  K-Truss</p>
    <p>Graph Analytics  PageRank  Personalized PageRank  Shortest Path  Graph Coloring</p>
    <p>MACHINE LEARNING</p>
    <p>NETWORK ANALYSIS</p>
  </div>
  <div class="page">
    <p>Specialized Computational</p>
    <p>Pattern</p>
    <p>Specialized Graph</p>
    <p>Optimizations</p>
  </div>
  <div class="page">
    <p>Graph System Optimizations</p>
    <p>Specialized Data-Structures</p>
    <p>Vertex-Cuts Partitioning</p>
    <p>Remote Caching / Mirroring</p>
    <p>Message Combiners Active Set Tracking</p>
  </div>
  <div class="page">
    <p>Representation</p>
    <p>Optimizations</p>
    <p>Distributed Graphs</p>
    <p>Horizontally Partitioned Tables</p>
    <p>Join</p>
    <p>Vertex Programs</p>
    <p>Dataflow Operators</p>
    <p>Advances in Graph Processing Systems Distributed Join Optimization</p>
    <p>Materialized View Maintenance</p>
  </div>
  <div class="page">
    <p>Property Graph Data Model</p>
    <p>B C</p>
    <p>A D</p>
    <p>F E</p>
    <p>A D D</p>
    <p>Property Graph</p>
    <p>B C</p>
    <p>D</p>
    <p>E</p>
    <p>A A</p>
    <p>F</p>
    <p>Vertex Property:  User Profile  Current PageRank Value</p>
    <p>Edge Property:  Weights  Timestamps</p>
  </div>
  <div class="page">
    <p>Part. 2</p>
    <p>Part. 1</p>
    <p>Vertex Table</p>
    <p>(RDD)</p>
    <p>B C</p>
    <p>A D</p>
    <p>F E</p>
    <p>A D</p>
    <p>Encoding Property Graphs as Tables</p>
    <p>D</p>
    <p>Property Graph</p>
    <p>B C</p>
    <p>D</p>
    <p>E</p>
    <p>A A</p>
    <p>F</p>
    <p>M achine 1</p>
    <p>M achine 2</p>
    <p>Edge Table (RDD)</p>
    <p>A B</p>
    <p>A C</p>
    <p>C D</p>
    <p>B C</p>
    <p>A E</p>
    <p>A F</p>
    <p>E F</p>
    <p>E D</p>
    <p>B</p>
    <p>C</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>Routing Table</p>
    <p>(RDD)</p>
    <p>B</p>
    <p>C</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>Vertex Cut</p>
  </div>
  <div class="page">
    <p>Separate Properties and Structure Reuse structural information across multiple graphs</p>
    <p>Input Graph</p>
    <p>Transform Vertex Properties</p>
    <p>Transformed Graph Vertex Table</p>
    <p>Routing  Table</p>
    <p>Edge Table</p>
    <p>Vertex Table</p>
    <p>Routing  Table</p>
    <p>Edge Table</p>
  </div>
  <div class="page">
    <p>Table Operators Table operators are inherited from Spark:</p>
    <p>map</p>
    <p>filter</p>
    <p>groupBy</p>
    <p>sort</p>
    <p>union</p>
    <p>join</p>
    <p>leftOuterJoin</p>
    <p>rightOuterJoin</p>
    <p>reduce</p>
    <p>count</p>
    <p>fold</p>
    <p>reduceByKey</p>
    <p>groupByKey</p>
    <p>cogroup</p>
    <p>cross</p>
    <p>zip</p>
    <p>sample</p>
    <p>take</p>
    <p>first</p>
    <p>partitionBy</p>
    <p>mapWith</p>
    <p>pipe</p>
    <p>save</p>
    <p>...</p>
  </div>
  <div class="page">
    <p>class Graph [ V, E ] { def Graph(vertices: Table[ (Id, V) ], edges: Table[ (Id, Id, E) ])</p>
    <p>// Table Views ----------------def vertices: Table[ (Id, V) ] def edges: Table[ (Id, Id, E) ] def triplets: Table [ ((Id, V), (Id, V), E) ] // Transformations -----------------------------def reverse: Graph[V, E] def subgraph(pV: (Id, V) =&gt; Boolean,</p>
    <p>pE: Edge[V,E] =&gt; Boolean): Graph[V,E] def mapV(m: (Id, V) =&gt; T ): Graph[T,E] def mapE(m: Edge[V,E] =&gt; T ): Graph[V,T] // Joins ---------------------------------------def joinV(tbl: Table [(Id, T)]): Graph[(V, T), E ] def joinE(tbl: Table [(Id, Id, T)]): Graph[V, (E, T)] // Computation ---------------------------------def mrTriplets(mapF: (Edge[V,E]) =&gt; List[(Id, T)], reduceF: (T, T) =&gt; T): Graph[T, E]</p>
    <p>}</p>
    <p>Graph Operators (Scala)</p>
  </div>
  <div class="page">
    <p>class Graph [ V, E ] { def Graph(vertices: Table[ (Id, V) ], edges: Table[ (Id, Id, E) ])</p>
    <p>// Table Views ----------------def vertices: Table[ (Id, V) ] def edges: Table[ (Id, Id, E) ] def triplets: Table [ ((Id, V), (Id, V), E) ] // Transformations -----------------------------def reverse: Graph[V, E] def subgraph(pV: (Id, V) =&gt; Boolean,</p>
    <p>pE: Edge[V,E] =&gt; Boolean): Graph[V,E] def mapV(m: (Id, V) =&gt; T ): Graph[T,E] def mapE(m: Edge[V,E] =&gt; T ): Graph[V,T] // Joins ---------------------------------------def joinV(tbl: Table [(Id, T)]): Graph[(V, T), E ] def joinE(tbl: Table [(Id, Id, T)]): Graph[V, (E, T)] // Computation ---------------------------------def mrTriplets(mapF: (Edge[V,E]) =&gt; List[(Id, T)], reduceF: (T, T) =&gt; T): Graph[T, E]</p>
    <p>}</p>
    <p>Graph Operators (Scala)</p>
    <p>def mrTriplets(mapF: (Edge[V,E]) =&gt; List[(Id, T)], reduceF: (T, T) =&gt; T): Graph[T, E]</p>
    <p>capture the Gather-Scatter pattern from specialized graph-processing systems</p>
  </div>
  <div class="page">
    <p>Triplets Join Vertices and Edges The triplets operator joins vertices and edges:</p>
    <p>Triplets Vertices</p>
    <p>B</p>
    <p>A</p>
    <p>C</p>
    <p>D</p>
    <p>Edges</p>
    <p>A B A C B C C D</p>
    <p>A B A B A C</p>
    <p>B C C D</p>
  </div>
  <div class="page">
    <p>Map-Reduce Triplets Map-Reduce triplets collects information about the neighborhood of each vertex:</p>
    <p>C D</p>
    <p>A C</p>
    <p>B C</p>
    <p>A B</p>
    <p>Src. or Dst.</p>
    <p>MapFunction( )  (B, )</p>
    <p>MapFunction( )  (C, ) MapFunction( )  (C, )</p>
    <p>MapFunction( )  (D, )</p>
    <p>Reduce</p>
    <p>(B, )</p>
    <p>(C, + )</p>
    <p>(D, ) Message</p>
    <p>Combiners</p>
  </div>
  <div class="page">
    <p>Using these basic GraphX operators  we implemented Pregel and GraphLab</p>
    <p>in under 50 lines of code!</p>
  </div>
  <div class="page">
    <p>The GraphX Stack (Lines of Code)</p>
    <p>GraphX (2,500)</p>
    <p>Spark (30,000)</p>
    <p>Pregel API (34)</p>
    <p>PageRank (20)</p>
    <p>Connected Comp. (20)</p>
    <p>K-core (60) Triangle Count</p>
    <p>(50)</p>
    <p>LDA (220)</p>
    <p>SVD++ (110)</p>
    <p>Some algorithms are more naturally expressed using the GraphX primitive operators</p>
  </div>
  <div class="page">
    <p>Representation</p>
    <p>Optimizations</p>
    <p>Distributed Graphs</p>
    <p>Horizontally Partitioned Tables</p>
    <p>Join</p>
    <p>Vertex Programs</p>
    <p>Dataflow Operators</p>
    <p>Advances in Graph Processing Systems Distributed Join Optimization</p>
    <p>Materialized View Maintenance</p>
  </div>
  <div class="page">
    <p>Vertex Table</p>
    <p>(RDD)</p>
    <p>Join Site Selection using Routing Tables Edge Table</p>
    <p>(RDD) A B</p>
    <p>A C</p>
    <p>C D</p>
    <p>B C</p>
    <p>A E</p>
    <p>A F</p>
    <p>E F</p>
    <p>E D</p>
    <p>B</p>
    <p>C</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>Routing Table</p>
    <p>(RDD)</p>
    <p>B</p>
    <p>C</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>Never Shuffle Edges!</p>
  </div>
  <div class="page">
    <p>Vertex Table</p>
    <p>(RDD)</p>
    <p>Caching for Iterative mrTriplets Edge Table</p>
    <p>(RDD) A B</p>
    <p>A C</p>
    <p>C D</p>
    <p>B C</p>
    <p>A E</p>
    <p>A F</p>
    <p>E F</p>
    <p>E D</p>
    <p>Mirror Cache</p>
    <p>B C D</p>
    <p>A</p>
    <p>Mirror Cache</p>
    <p>D E F</p>
    <p>A</p>
    <p>B</p>
    <p>C</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>B</p>
    <p>C</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>A</p>
    <p>D</p>
    <p>Scan Scan</p>
    <p>Reusable Hash Index</p>
    <p>Reusable Hash Index</p>
  </div>
  <div class="page">
    <p>Vertex Table</p>
    <p>(RDD)</p>
    <p>Edge Table (RDD)</p>
    <p>A B</p>
    <p>A C</p>
    <p>C D</p>
    <p>B C</p>
    <p>A E</p>
    <p>A F</p>
    <p>E F</p>
    <p>E D</p>
    <p>Mirror Cache</p>
    <p>B C D</p>
    <p>A</p>
    <p>Mirror Cache</p>
    <p>D E F</p>
    <p>A</p>
    <p>Incremental Updates for Triplets View</p>
    <p>B</p>
    <p>C</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>Change A A</p>
    <p>Change E</p>
    <p>Scan</p>
  </div>
  <div class="page">
    <p>Vertex Table</p>
    <p>(RDD)</p>
    <p>Edge Table (RDD)</p>
    <p>A B</p>
    <p>A C</p>
    <p>C D</p>
    <p>B C</p>
    <p>A E</p>
    <p>A F</p>
    <p>E F</p>
    <p>E D</p>
    <p>Mirror Cache</p>
    <p>B C D</p>
    <p>A</p>
    <p>Mirror Cache</p>
    <p>D E F</p>
    <p>A</p>
    <p>Aggregation for Iterative mrTriplets</p>
    <p>B</p>
    <p>C</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>Change</p>
    <p>Change</p>
    <p>Scan</p>
    <p>Change</p>
    <p>Change</p>
    <p>Change</p>
    <p>Change</p>
    <p>Local Aggregate</p>
    <p>Local Aggregate</p>
    <p>B C</p>
    <p>D</p>
    <p>F</p>
  </div>
  <div class="page">
    <p>Reduction in Communication Due to Cached Updates</p>
    <p>N et</p>
    <p>w or</p>
    <p>k C</p>
    <p>om m</p>
    <p>. ( M</p>
    <p>B)</p>
    <p>Iteration</p>
    <p>Connected Components on Twitter Graph</p>
    <p>Most vertices are within 8 hops of all vertices in their comp.</p>
  </div>
  <div class="page">
    <p>Benefit of Indexing Active Vertices</p>
    <p>Ru nt</p>
    <p>im e</p>
    <p>(S ec</p>
    <p>on ds</p>
    <p>)</p>
    <p>Iteration</p>
    <p>Connected Components on Twitter Graph</p>
    <p>Without Active Tracking</p>
    <p>Active Vertex Tracking</p>
  </div>
  <div class="page">
    <p>Join Elimination Identify and bypass joins for unused triplet fields</p>
    <p>Java bytecode inspection</p>
    <p>C om</p>
    <p>m un</p>
    <p>ica tio</p>
    <p>n (M</p>
    <p>B)</p>
    <p>Iteration</p>
    <p>PageRank on Twitter</p>
    <p>Factor of 2 reduction in communication</p>
    <p>Better</p>
    <p>Join Elimination</p>
    <p>Without Join Elimination</p>
  </div>
  <div class="page">
    <p>Additional Optimizations Indexing and Bitmaps:  To accelerate joins across graphs  To efficiently construct sub-graphs</p>
    <p>Lineage based fault-tolerance  Exploits Spark lineage to recover in parallel  Eliminates need for costly check-points</p>
    <p>Substantial Index and Data Reuse:  Reuse routing tables across graphs and sub-graphs  Reuse edge adjacency information and indices</p>
  </div>
  <div class="page">
    <p>System Comparison Goal:</p>
    <p>Demonstrate that GraphX achieves performance parity with specialized graph-processing systems.</p>
    <p>Setup: 16 node EC2 Cluster (m2.4xLarge) + 1GigE Compare against GraphLab/PowerGraph (C++), Giraph (Java), &amp; Spark (Java/Scala)</p>
  </div>
  <div class="page">
    <p>Twitter Graph (42M Vertices,1.5B Edges) UK-Graph (106M Vertices, 3.7B Edges)</p>
    <p>PageRank Benchmark</p>
    <p>GraphX performs comparably to  state-of-the-art graph processing systems.</p>
    <p>Ru nt</p>
    <p>im e</p>
    <p>(S ec</p>
    <p>on ds</p>
    <p>)</p>
    <p>EC2 Cluster of 16 x m2.4xLarge (8 cores) + 1GigE</p>
  </div>
  <div class="page">
    <p>Connected Comp. Benchmark</p>
    <p>Twitter Graph (42M Vertices,1.5B Edges) UK-Graph (106M Vertices, 3.7B Edges)</p>
    <p>GraphX performs comparably to  state-of-the-art graph processing systems.</p>
    <p>O ut</p>
    <p>-o f-M</p>
    <p>em or</p>
    <p>y</p>
    <p>EC2 Cluster of 16 x m2.4xLarge (8 cores) + 1GigE</p>
    <p>Ru nt</p>
    <p>im e</p>
    <p>(S ec</p>
    <p>on ds</p>
    <p>)</p>
  </div>
  <div class="page">
    <p>Graphs are just one stage.</p>
    <p>What about a pipeline?</p>
  </div>
  <div class="page">
    <p>HDFS HDFS</p>
    <p>Compute Spark Preprocess Spark Post.</p>
    <p>A Small Pipeline in GraphX</p>
    <p>Timed end-to-end GraphX is the fastest</p>
    <p>Raw Wikipedia</p>
    <p>&lt; / &gt;!&lt; / &gt;!&lt; / &gt;! XML!</p>
    <p>Hyperlinks PageRank Top 20 Pages</p>
    <p>GraphX GraphLab + Spark</p>
    <p>Giraph + Spark Spark</p>
    <p>Total Runtime (in Seconds)</p>
  </div>
  <div class="page">
    <p>Adoption and Impact GraphX is now part of Apache Spark</p>
    <p>Part of Cloudera Hadoop Distribution</p>
    <p>In production at Alibaba Taobao</p>
    <p>Order of magnitude gains over Spark</p>
    <p>Inspired GraphLab Inc. SFrame technology</p>
    <p>Unifies Tables &amp; Graphs on Disk</p>
  </div>
  <div class="page">
    <p>GraphX  Unified Tables and Graphs</p>
    <p>Enabling users to easily and efficiently express the entire analytics pipeline</p>
    <p>New API Blurs the distinction between</p>
    <p>Tables and Graphs</p>
    <p>New System Unifies Data-Parallel</p>
    <p>Graph-Parallel Systems</p>
  </div>
  <div class="page">
    <p>Graph Systems GraphX</p>
    <p>Specialized Systems Integrated Frameworks</p>
    <p>What did we Learn?</p>
  </div>
  <div class="page">
    <p>Graph Systems GraphX</p>
    <p>Specialized Systems Integrated Frameworks</p>
    <p>Parameter Server</p>
    <p>?</p>
    <p>Future Work</p>
  </div>
  <div class="page">
    <p>Graph Systems GraphX</p>
    <p>Specialized Systems Integrated Frameworks</p>
    <p>Parameter Server</p>
    <p>Future Work</p>
    <p>Asynchrony Non-deterministic</p>
    <p>Shared-State</p>
  </div>
  <div class="page">
    <p>Thank You</p>
    <p>jegonzal@eecs.berkeley.edu</p>
    <p>http://amplab.cs.berkeley.edu/projects/graphx/</p>
    <p>Reynold Xin</p>
    <p>Ankur Dave</p>
    <p>Daniel Crankshaw</p>
    <p>Michael Franklin</p>
    <p>Ion Stoica</p>
  </div>
  <div class="page">
    <p>Related Work Specialized Graph-Processing Systems:</p>
    <p>GraphLab [UAI10], Pregel [SIGMOD10], Signal-Collect [ISWC10], Combinatorial BLAS [IJHPCA11], GraphChi [OSDI12], PowerGraph [OSDI12],  Ligra [PPoPP13], X-Stream [SOSP13]</p>
    <p>Alternative to Dataflow framework: Naiad [SOSP13]: GraphLINQ  Hyracks: Pregelix [VLDB15]</p>
    <p>Distributed Join Optimization: Multicast Join [Afrati et al., EDBT10] Semi-Join in MapReduce [Blanas et al., SIGMOD10]</p>
  </div>
  <div class="page">
    <p>Edge Files Have Locality</p>
    <p>GraphLab GraphX + Shuffle</p>
    <p>GraphX</p>
    <p>GraphLab rebalances the edge-files on-load.</p>
    <p>GraphX preserves the ondisk layout through Spark.  Better Vertex-Cut</p>
    <p>UK-Graph (106M Vertices, 3.7B Edges)</p>
    <p>Runtim e (Seconds)</p>
  </div>
  <div class="page">
    <p>Scalability</p>
    <p>Linear Scaling</p>
    <p>Twitter Graph (42M Vertices,1.5B Edges)</p>
    <p>Scales slightly better than  PowerGraph/GraphLab</p>
    <p>Ru nt</p>
    <p>im e</p>
    <p>EC2-Nodes</p>
  </div>
  <div class="page">
    <p>Apache Spark Dataflow Platform Resilient Distributed Datasets (RDD):</p>
    <p>Zaharia et al., NSDI12</p>
    <p>HDFS</p>
    <p>HDFS</p>
    <p>Map</p>
    <p>Map</p>
    <p>RDD RDD</p>
    <p>Reduce</p>
    <p>RDD</p>
    <p>Load</p>
    <p>Load</p>
  </div>
  <div class="page">
    <p>Apache Spark Dataflow Platform Resilient Distributed Datasets (RDD):</p>
    <p>Zaharia et al., NSDI12</p>
    <p>HDFS</p>
    <p>HDFS</p>
    <p>Map</p>
    <p>Map</p>
    <p>RDD RDD</p>
    <p>Reduce</p>
    <p>Optimized for iterative access to data.</p>
    <p>RDD</p>
    <p>Load</p>
    <p>Load</p>
    <p>.cache()</p>
    <p>Persist in Memory</p>
  </div>
  <div class="page">
    <p>PageRank Benchmark</p>
    <p>GraphX performs comparably to  state-of-the-art graph processing systems.</p>
    <p>Twitter Graph (42M Vertices,1.5B Edges) UK-Graph (106M Vertices, 3.7B Edges)</p>
    <p>?  Ru nt</p>
    <p>im e</p>
    <p>(S ec</p>
    <p>on ds</p>
    <p>)</p>
    <p>EC2 Cluster of 16 x m2.4xLarge Nodes + 1GigE</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>Shared Memory Advantage Spark Shared Nothing Model</p>
    <p>Core Core Core Core</p>
    <p>Shuffle Files</p>
    <p>GraphLab Shared Memory</p>
    <p>Core Core Core Core</p>
    <p>Shared De-serialized In-Memory Graph</p>
  </div>
  <div class="page">
    <p>Shared Memory Advantage</p>
    <p>GraphLab GraphLab NoSHM</p>
    <p>GraphX</p>
    <p>Twitter Graph (42M Vertices,1.5B Edges) Spark Shared Nothing Model</p>
    <p>GraphLab No SHM.</p>
    <p>Core Core Core Core</p>
    <p>Shuffle Files</p>
    <p>Core Core Core Core</p>
    <p>TCP/IP</p>
    <p>Runtim e (Seconds)</p>
  </div>
  <div class="page">
    <p>PageRank Benchmark</p>
    <p>Twitter Graph (42M Vertices,1.5B Edges) UK-Graph (106M Vertices, 3.7B Edges)</p>
    <p>GraphX performs comparably to  state-of-the-art graph processing systems.</p>
  </div>
  <div class="page">
    <p>Connected Comp. Benchmark</p>
    <p>Twitter Graph (42M Vertices,1.5B Edges) UK-Graph (106M Vertices, 3.7B Edges)</p>
    <p>GraphX performs comparably to  state-of-the-art graph processing systems.</p>
    <p>O ut</p>
    <p>-o f-M</p>
    <p>em or</p>
    <p>y</p>
    <p>EC2 Cluster of 16 x m2.4xLarge Nodes + 1GigE</p>
    <p>Ru nt</p>
    <p>im e</p>
    <p>(S ec</p>
    <p>on ds</p>
    <p>)</p>
    <p>O ut</p>
    <p>-o f-M</p>
    <p>em or</p>
    <p>y</p>
  </div>
  <div class="page">
    <p>Fault-Tolerance Leverage Spark Fault-Tolerance Mechanism</p>
    <p>No Failure Lineage Restart</p>
    <p>Ru nt</p>
    <p>im e</p>
    <p>(S ec</p>
    <p>on ds</p>
    <p>)</p>
  </div>
  <div class="page">
    <p>Graph-Processing Systems</p>
    <p>oogle</p>
    <p>Expose specialized API to simplify graph programming.</p>
    <p>CombBLAS</p>
    <p>Kineograph</p>
    <p>X-Stream</p>
    <p>GraphChi</p>
    <p>Ligra</p>
    <p>GPS</p>
    <p>Representation</p>
  </div>
  <div class="page">
    <p>Vertex-Program Abstraction</p>
    <p>i Pregel_PageRank(i, messages) : // Receive all the messages total = 0 foreach( msg in messages) : total = total + msg // Update the rank of this vertex R[i] = 0.15 + total // Send new messages to neighbors foreach(j in out_neighbors[i]) : Send msg(R[i]) to vertex j</p>
  </div>
  <div class="page">
    <p>The Vertex-Program Abstraction</p>
    <p>GraphLab_PageRank(i) // Compute sum over neighbors total = 0 foreach( j in neighbors(i)): total += R[j] * wji // Update the PageRank R[i] = 0.15 + total</p>
    <p>R[4] * w41</p>
    <p>+ +</p>
    <p>Low, Gonzalez, et al. [UAI10]</p>
  </div>
  <div class="page">
    <p>F</p>
    <p>E</p>
    <p>Example: Oldest Follower</p>
    <p>D</p>
    <p>B</p>
    <p>A</p>
    <p>C Calculate the number of older followers for each user?</p>
    <p>val olderFollowerAge = graph .mrTriplets(</p>
    <p>e =&gt; // Map if(e.src.age &gt; e.dst.age) { (e.srcId, 1) else { Empty } , (a,b) =&gt; a + b // Reduce ) .vertices</p>
  </div>
  <div class="page">
    <p>Enhanced Pregel in GraphX</p>
    <p>pregelPR(i, messageList ): ! // Receive all the messages ! total = 0 ! foreach( msg in messageList) : ! total = total + msg!</p>
    <p>// Update the rank of this vertex ! R[i] = 0.15 + total !</p>
    <p>// Send new messages to neighbors ! foreach(j in out_neighbors[i]) : ! Send msg(R[i]/E[i,j]) to vertex!</p>
    <p>Require Message Combiners messageSum</p>
    <p>messageSum</p>
    <p>Remove Message Computation</p>
    <p>from the Vertex Program</p>
    <p>sendMsg(ij, R[i], R[j], E[i,j]): ! // Compute single message ! return msg(R[i]/E[i,j]) ! !</p>
    <p>combineMsg(a, b): ! // Compute sum of two messages ! return a + b ! !</p>
  </div>
  <div class="page">
    <p>PageRank in GraphX</p>
    <p>// Load and initialize the graph !</p>
    <p>val graph = GraphBuilder.text(hdfs://web.txt) ! val prGraph = graph.joinVertices(graph.outDegrees) ! !</p>
    <p>// Implement and Run PageRank !</p>
    <p>val pageRank = ! prGraph.pregel(initialMessage = 0.0, iter = 10)( ! (oldV, msgSum) =&gt; 0.15 + 0.85 * msgSum, ! triplet =&gt; triplet.src.pr / triplet.src.deg, !</p>
    <p>(msgA, msgB) =&gt; msgA + msgB) !</p>
  </div>
  <div class="page">
    <p>Example Analytics Pipeline // Load raw data tables !</p>
    <p>val articles = sc.textFile(hdfs://wiki.xml).map(xmlParser) !</p>
    <p>val links = articles.flatMap(article =&gt; article.outLinks) !</p>
    <p>// Build the graph from tables !</p>
    <p>val graph = new Graph(articles, links) !</p>
    <p>// Run PageRank Algorithm !</p>
    <p>val pr = graph.PageRank(tol = 1.0e-5) !</p>
    <p>// Extract and print the top 20 articles !</p>
    <p>val topArticles = articles.join(pr).top(20).collect !</p>
    <p>for ((article, pageRank) &lt;- topArticles) { ! println(article.title + \t + pageRank) ! } !</p>
  </div>
  <div class="page">
    <p>Apache Spark Dataflow Platform Resilient Distributed Datasets (RDD):</p>
    <p>Zaharia et al., NSDI12</p>
    <p>HDFS</p>
    <p>HDFS</p>
    <p>Map</p>
    <p>Map</p>
    <p>RDD RDD</p>
    <p>Reduce</p>
    <p>Lineage:</p>
    <p>RDD</p>
    <p>Load</p>
    <p>Load</p>
    <p>HDFS RDD RDD Reduce Map</p>
    <p>RDD Load</p>
    <p>.cache()</p>
    <p>Persist in Memory</p>
  </div>
</Presentation>
