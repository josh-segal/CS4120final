<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Verifying concurrent software using movers in CSPEC</p>
    <p>Tej Chajed, Frans Kaashoek, Butler Lampson*, Nickolai Zeldovich MIT CSAIL and *Microsoft</p>
  </div>
  <div class="page">
    <p>Concurrent software is difficult to get right</p>
    <p>!2</p>
    <p>Programmer cannot reason about code in sequence</p>
  </div>
  <div class="page">
    <p>Concurrent software is difficult to get right</p>
    <p>!3</p>
    <p>instead, must consider many executions: Programmer cannot reason about code in sequence</p>
  </div>
  <div class="page">
    <p>Concurrent software is difficult to get right</p>
    <p>!3</p>
    <p>instead, must consider many executions:</p>
    <p>Programmer cannot reason about code in sequence</p>
  </div>
  <div class="page">
    <p>Goal: verify concurrent software</p>
    <p>!4</p>
  </div>
  <div class="page">
    <p>Challenge for formal verification</p>
    <p>Proofs must also cover every execution  Many approaches to managing this complexity  movers [Lipton, 1975]  rely-guarantee [1983]  RGSep [CONCUR 2007]  FCSL [PLDI 2015]  Iris [POPL 2017, LICS 2018, others]  many others</p>
    <p>!5</p>
  </div>
  <div class="page">
    <p>Challenge for formal verification</p>
    <p>Proofs must also cover every execution  Many approaches to managing this complexity  movers [Lipton, 1975]  rely-guarantee [1983]  RGSep [CONCUR 2007]  FCSL [PLDI 2015]  Iris [POPL 2017, LICS 2018, others]  many others</p>
    <p>This work: our experience using movers</p>
    <p>!5</p>
  </div>
  <div class="page">
    <p>Movers: reduce concurrent executions to sequential ones</p>
    <p>!6</p>
    <p>time</p>
    <p>B32A1</p>
    <p>blue thread</p>
    <p>green thread</p>
    <p>A B</p>
  </div>
  <div class="page">
    <p>Movers: reduce concurrent executions to sequential ones</p>
    <p>!6</p>
    <p>has the same effect as movers</p>
    <p>B32A1</p>
    <p>blue thread</p>
    <p>green thread</p>
    <p>A B</p>
    <p>B32 A1</p>
  </div>
  <div class="page">
    <p>Movers: reduce concurrent executions to sequential ones</p>
    <p>!6</p>
    <p>has the same effect as movers</p>
    <p>sequential reasoning</p>
    <p>B32A1</p>
    <p>blue thread</p>
    <p>green thread</p>
    <p>A B</p>
    <p>B32 A1</p>
    <p>B32 A1</p>
  </div>
  <div class="page">
    <p>Prior systems with mover reasoning</p>
    <p>!7</p>
    <p>CIVL [CAV 15, CAV 18] framework relies pen &amp; paper proofs</p>
    <p>IronFleet [SOSP 15] only move network send/receive</p>
  </div>
  <div class="page">
    <p>Contribution: CSPEC</p>
    <p>Framework for verifying concurrency in systems software  general-purpose movers  patterns to support mover reasoning  machine checked in Coq to support extensibility</p>
    <p>!8</p>
  </div>
  <div class="page">
    <p>Contribution: CSPEC</p>
    <p>Framework for verifying concurrency in systems software  general-purpose movers  patterns to support mover reasoning  machine checked in Coq to support extensibility</p>
    <p>Case studies using CSPEC  Lock-free file-system concurrency  Spinlock on top of x86-TSO (see paper)</p>
    <p>!8</p>
  </div>
  <div class="page">
    <p>Case study: mail server using file-system concurrency</p>
    <p>!9</p>
    <p>spool</p>
    <p>file system</p>
    <p>mbox</p>
  </div>
  <div class="page">
    <p>Mail servers exploit file-system concurrency</p>
    <p>!10</p>
    <p>spool</p>
    <p>file system</p>
    <p># accept def deliver(msg): # spool create(/spool/$TID) write(/spool/$TID, msg) # store while True: t = time.time() if link(/spool/$TID, /mbox/$t): break # cleanup</p>
    <p>unlink(/spool/$TID)</p>
    <p>mbox</p>
  </div>
  <div class="page">
    <p>Mail servers exploit file-system concurrency</p>
    <p>!11</p>
    <p>spool</p>
    <p>file system</p>
    <p>msg</p>
    <p>mbox</p>
    <p># accept def deliver(msg): # spool create(/spool/$TID) write(/spool/$TID, msg) # store while True: t = time.time() if link(/spool/$TID, /mbox/$t): break # cleanup</p>
    <p>unlink(/spool/$TID)</p>
  </div>
  <div class="page">
    <p>Spooling avoids reading partially-written messages</p>
    <p>!12</p>
    <p>spool</p>
    <p>file system</p>
    <p>mbox</p>
    <p>$TID =10</p>
    <p># accept def deliver(msg): # spool create(/spool/$TID) write(/spool/$TID, msg) # store while True: t = time.time() if link(/spool/$TID, /mbox/$t): break # cleanup</p>
    <p>unlink(/spool/$TID)</p>
  </div>
  <div class="page">
    <p>Spooling avoids reading partially-written messages</p>
    <p>!12</p>
    <p>spool</p>
    <p>file system</p>
    <p>mbox</p>
    <p>$TID =10</p>
    <p># accept def deliver(msg): # spool create(/spool/$TID) write(/spool/$TID, msg) # store while True: t = time.time() if link(/spool/$TID, /mbox/$t): break # cleanup</p>
    <p>unlink(/spool/$TID)</p>
  </div>
  <div class="page">
    <p>Threads use unique IDs to avoid conflicts</p>
    <p>!13</p>
    <p>spool</p>
    <p>file system</p>
    <p>msg</p>
    <p>mbox</p>
    <p>$TID =10 $TID =11</p>
    <p># accept def deliver(msg): # spool create(/spool/$TID) write(/spool/$TID, msg) # store while True: t = time.time() if link(/spool/$TID, /mbox/$t): break # cleanup</p>
    <p>unlink(/spool/$TID)</p>
  </div>
  <div class="page">
    <p>Threads use unique IDs to avoid conflicts</p>
    <p>!14</p>
    <p>spool</p>
    <p>file system</p>
    <p>mbox</p>
    <p>$TID =10 $TID =11</p>
    <p># accept def deliver(msg): # spool create(/spool/$TID) write(/spool/$TID, msg) # store while True: t = time.time() if link(/spool/$TID, /mbox/$t): break # cleanup</p>
    <p>unlink(/spool/$TID)</p>
  </div>
  <div class="page">
    <p>Threads use unique IDs to avoid conflicts</p>
    <p>!14</p>
    <p>spool</p>
    <p>file system</p>
    <p>mbox</p>
    <p>$TID =10 $TID =11</p>
    <p># accept def deliver(msg): # spool create(/spool/$TID) write(/spool/$TID, msg) # store while True: t = time.time() if link(/spool/$TID, /mbox/$t): break # cleanup</p>
    <p>unlink(/spool/$TID)</p>
  </div>
  <div class="page">
    <p>Timestamps help generate unique message names</p>
    <p>!15</p>
    <p>spool</p>
    <p>file system</p>
    <p>mbox</p>
    <p>link(/spool/11, /mbox/4)</p>
    <p># accept def deliver(msg): # spool create(/spool/$TID) write(/spool/$TID, msg) # store while True: t = time.time() if link(/spool/$TID, /mbox/$t): break # cleanup</p>
    <p>unlink(/spool/$TID)</p>
  </div>
  <div class="page">
    <p>Timestamps help generate unique message names</p>
    <p>!16</p>
    <p>spool mbox</p>
    <p>file system</p>
    <p>link(/spool/10, /mbox/4)</p>
    <p>EEXISTS</p>
    <p># accept def deliver(msg): # spool create(/spool/$TID) write(/spool/$TID, msg) # store while True: t = time.time() if link(/spool/$TID, /mbox/$t): break # cleanup</p>
    <p>unlink(/spool/$TID)</p>
  </div>
  <div class="page">
    <p>Timestamps help generate unique message names</p>
    <p>!17</p>
    <p>spool</p>
    <p>file system</p>
    <p>mbox</p>
    <p>link(/spool/10, /mbox/5)</p>
    <p># accept def deliver(msg): # spool create(/spool/$TID) write(/spool/$TID, msg) # store while True: t = time.time() if link(/spool/$TID, /mbox/$t): break # cleanup</p>
    <p>unlink(/spool/$TID)</p>
  </div>
  <div class="page">
    <p>Delivery concurrency does not use locks</p>
    <p>!18</p>
    <p>spool</p>
    <p>file system</p>
    <p>mbox</p>
    <p># accept def deliver(msg): # spool create(/spool/$TID) write(/spool/$TID, msg) # store while True: t = time.time() if link(/spool/$TID, /mbox/$t): break # cleanup</p>
    <p>unlink(/spool/$TID)</p>
  </div>
  <div class="page">
    <p>Delivery concurrency does not use locks</p>
    <p>!19</p>
    <p>spool</p>
    <p>file system</p>
    <p>mbox</p>
    <p># accept def deliver(msg): # spool create(/spool/$TID) write(/spool/$TID, msg) # store while True: t = time.time() if link(/spool/$TID, /mbox/$t): break # cleanup</p>
    <p>unlink(/spool/$TID)</p>
  </div>
  <div class="page">
    <p>Proving delivery correct in CSPEC</p>
    <p>!20</p>
    <p>file-system spec</p>
    <p>delivery specification</p>
    <p>implementation and proof</p>
    <p>CSPEC CSPEC provides supporting definitions and theorems</p>
  </div>
  <div class="page">
    <p>Proof engineer reasons about file-system operations</p>
    <p>!21</p>
    <p>def deliver(msg): create(/spool/$TID, msg) while True: t = time.time() if link(/spool/$TID, /mbox/$t): break</p>
    <p>unlink(/spool/$TID)</p>
    <p>create( /sp/$TID, msg)</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>EEXISTS</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>unlink( /sp/$TID)</p>
  </div>
  <div class="page">
    <p>Proof engineer reasons about file-system operations</p>
    <p>!21</p>
    <p>def deliver(msg): create(/spool/$TID, msg) while True: t = time.time() if link(/spool/$TID, /mbox/$t): break</p>
    <p>unlink(/spool/$TID)</p>
    <p>create( /sp/$TID, msg)</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>EEXISTS</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>unlink( /sp/$TID)</p>
    <p>create(/spool/$TID) write(/spool/$TID, msg)</p>
    <p>collapsed to one operation</p>
  </div>
  <div class="page">
    <p>Proof engineer reasons about interleaving of filesystem operations</p>
    <p>!22</p>
    <p>def deliver(msg): create(/spool/$TID, msg) while True: t = time.time() if link(/spool/$TID, /mbox/$t): break</p>
    <p>unlink(/spool/$TID)</p>
    <p>We assume file-system operations are atomic</p>
    <p>create( /sp/$TID, msg)</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>EEXISTS</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>unlink( /sp/$TID)</p>
    <p>create</p>
    <p>link unlink</p>
  </div>
  <div class="page">
    <p>Proving atomicity of delivery</p>
    <p>!23</p>
    <p>atomicity: concurrent deliveries appear to execute all at once (in some order)</p>
    <p>create</p>
    <p>link</p>
    <p>link unlinkcreate</p>
    <p>link unlink</p>
    <p>create</p>
    <p>link unlink</p>
    <p>deliver create</p>
    <p>link</p>
    <p>link unlink deliver</p>
  </div>
  <div class="page">
    <p>Proving atomicity of delivery</p>
    <p>!23</p>
    <p>atomicity: concurrent deliveries appear to execute all at once (in some order)</p>
    <p>create</p>
    <p>link</p>
    <p>link unlinkcreate</p>
    <p>link unlink</p>
    <p>create</p>
    <p>link unlink</p>
    <p>deliver create</p>
    <p>link</p>
    <p>link unlink deliver</p>
    <p>Step 1: developer identifies commit point</p>
  </div>
  <div class="page">
    <p>Proving atomicity of delivery</p>
    <p>!23</p>
    <p>atomicity: concurrent deliveries appear to execute all at once (in some order)</p>
    <p>create</p>
    <p>link</p>
    <p>link unlinkcreate</p>
    <p>link unlink</p>
    <p>create</p>
    <p>link unlink</p>
    <p>deliver create</p>
    <p>link</p>
    <p>link unlink deliver</p>
    <p>Step 1: developer identifies commit point</p>
    <p>Step 2: prove operation occurs logically at commit point</p>
  </div>
  <div class="page">
    <p>Example of movers for this execution</p>
    <p>!24</p>
    <p>create</p>
    <p>link</p>
    <p>link unlinkcreate</p>
    <p>link unlink</p>
  </div>
  <div class="page">
    <p>Example of movers for this execution</p>
    <p>!24</p>
    <p>create</p>
    <p>link</p>
    <p>link unlinkcreate</p>
    <p>link unlink</p>
    <p>create</p>
    <p>link</p>
    <p>link unlinkcreate</p>
    <p>link unlink</p>
  </div>
  <div class="page">
    <p>Example of movers for this execution</p>
    <p>!24</p>
    <p>create</p>
    <p>link</p>
    <p>link unlinkcreate</p>
    <p>link unlink</p>
    <p>create</p>
    <p>link</p>
    <p>link unlinkcreate</p>
    <p>link unlink</p>
    <p>create</p>
    <p>link</p>
    <p>link unlinkcreate</p>
    <p>link unlink</p>
  </div>
  <div class="page">
    <p>Right mover can be reordered after any green thread operation</p>
    <p>!25</p>
    <p>A r</p>
    <p>A r</p>
  </div>
  <div class="page">
    <p>Right mover can be reordered after any green thread operation</p>
    <p>!25</p>
    <p>A r</p>
    <p>A r</p>
    <p>left movers are the converse</p>
  </div>
  <div class="page">
    <p>Movers need to consider only possible operations from other threads</p>
    <p>!26</p>
    <p>create( /sp/$TID, msg)</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>EEXISTS</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>unlink( /sp/$TID)</p>
    <p>is one of</p>
    <p>A r</p>
    <p>A rfor all green operations ,</p>
    <p>is a right mover ifA</p>
    <p>left movers are the converse</p>
  </div>
  <div class="page">
    <p>Example mover proof: failing link is a right mover</p>
    <p>!27</p>
    <p>Proof sketch (only case):link</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>EEXISTS</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>EEXISTS</p>
  </div>
  <div class="page">
    <p>Example mover proof: failing link is a right mover</p>
    <p>!27</p>
    <p>Proof sketch (only case):link</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>$t $t</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>EEXISTS</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>EEXISTS</p>
    <p>link</p>
    <p>link</p>
    <p>(otherwise then is impossible)</p>
  </div>
  <div class="page">
    <p>Example mover proof: failing link is a right mover</p>
    <p>!27</p>
    <p>Proof sketch (only case):link</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>$t $t</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>EEXISTS</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>EEXISTS</p>
    <p>link</p>
    <p>link</p>
    <p>(otherwise then is impossible)</p>
    <p>link operations are independent</p>
  </div>
  <div class="page">
    <p>Failing link does not move left</p>
    <p>!28</p>
  </div>
  <div class="page">
    <p>Failing link does not move left</p>
    <p>!28</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>EEXISTS</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>link( /sp/$TID, /mbox/$t)</p>
    <p>EEXISTS</p>
    <p>if = $t $t</p>
  </div>
  <div class="page">
    <p>Challenge: how to limit what other operations to consider in mover proofs?</p>
    <p>!29</p>
    <p>Delivery</p>
    <p>File system</p>
    <p>deliver</p>
    <p>create(f, d) link(f1, f2) unlink(f) rename(f1, f2)</p>
    <p>mover proof?</p>
  </div>
  <div class="page">
    <p>Challenge: how to limit what other operations to consider in mover proofs?</p>
    <p>!29</p>
    <p>Delivery</p>
    <p>File system</p>
    <p>deliver</p>
    <p>create(f, d) link(f1, f2) unlink(f) rename(f1, f2)</p>
    <p>mover proof?</p>
    <p>create( f1, d)</p>
    <p>create( f2, d)</p>
    <p>create( f1, d)</p>
    <p>create( f2, d)</p>
    <p>if filenames are identical</p>
  </div>
  <div class="page">
    <p>Layers enable mover reasoning</p>
    <p>!30</p>
    <p>Delivery</p>
    <p>File system</p>
    <p>deliver</p>
    <p>create(f, d) link(f1, f2) unlink(f) rename(f1, f2)</p>
    <p>Layers limit what operations are available use multiple layers to make operations movers</p>
  </div>
  <div class="page">
    <p>Layers enable mover reasoning</p>
    <p>!31</p>
    <p>Delivery</p>
    <p>File system</p>
    <p>Restricted file system</p>
    <p>restrict arguments to include $TID</p>
    <p>create(/spool/$TID, d) link(/spool/$TID, /mbox/$t) unlink(/spool/$TID)</p>
    <p>mover proof</p>
    <p>Layers limit what operations are available use multiple layers to make operations movers</p>
  </div>
  <div class="page">
    <p>Layers enable mover reasoning</p>
    <p>!31</p>
    <p>Delivery</p>
    <p>File system</p>
    <p>Restricted file system</p>
    <p>upper layers can only use restricted operations</p>
    <p>create(/spool/$TID, d) link(/spool/$TID, /mbox/$t) unlink(/spool/$TID)</p>
    <p>mover proof</p>
    <p>Layers limit what operations are available use multiple layers to make operations movers</p>
  </div>
  <div class="page">
    <p>Movers are a layer proof pattern</p>
    <p>!32</p>
    <p>mover pattern</p>
    <p>Obligation for developer: movers for each implementation</p>
    <p>layer 1</p>
    <p>layer 2 A B C D</p>
    <p>foo bar</p>
  </div>
  <div class="page">
    <p>Movers are a layer proof pattern</p>
    <p>!32</p>
    <p>mover pattern</p>
    <p>A B DC</p>
    <p>B A C</p>
    <p>def foo:</p>
    <p>def bar:</p>
    <p>Obligation for developer: movers for each implementation</p>
    <p>layer 1</p>
    <p>layer 2 A B C D</p>
    <p>foo bar</p>
  </div>
  <div class="page">
    <p>Movers are a layer proof pattern</p>
    <p>!32</p>
    <p>mover pattern</p>
    <p>A B DC</p>
    <p>B A C</p>
    <p>def foo:</p>
    <p>def bar:</p>
    <p>Obligation for developer: movers for each implementation</p>
    <p>CSPEC theorem: entire layer implementation is atomic</p>
    <p>layer 1</p>
    <p>layer 2 A B C D</p>
    <p>foo bar</p>
  </div>
  <div class="page">
    <p>CSPEC provides other patterns to support mover reasoning</p>
    <p>Abstraction / forward simulation  Invariants  Error state</p>
    <p>Protocols  Retry loops  Partitioning</p>
    <p>!33</p>
    <p>(see paper for details)</p>
    <p>pattern obligations proof connecting layers</p>
  </div>
  <div class="page">
    <p>Using CSPEC to verify CMAIL</p>
    <p>!34</p>
    <p>file-system spec</p>
    <p>mail library spec</p>
    <p>implementation layers</p>
    <p>patterns</p>
    <p>CMAIL (Coq)</p>
    <p>Coq</p>
    <p>CSPEC auto generated</p>
    <p>framework</p>
  </div>
  <div class="page">
    <p>Using CSPEC to verify CMAIL</p>
    <p>!34</p>
    <p>file-system spec</p>
    <p>mail library spec</p>
    <p>implementation layers</p>
    <p>patterns</p>
    <p>CMAIL (Coq)</p>
    <p>Coq</p>
    <p>calls to file-system</p>
    <p>SMTP + POP3</p>
    <p>extracted implementation</p>
    <p>CMAIL (Haskell)</p>
    <p>Coq extraction</p>
    <p>CSPEC auto generated</p>
    <p>framework</p>
  </div>
  <div class="page">
    <p>Using CSPEC to verify CMAIL</p>
    <p>!34</p>
    <p>file-system spec</p>
    <p>mail library spec</p>
    <p>implementation layers</p>
    <p>patterns</p>
    <p>CMAIL (Coq)</p>
    <p>Coq</p>
    <p>calls to file-system</p>
    <p>SMTP + POP3</p>
    <p>extracted implementation</p>
    <p>CMAIL (Haskell)</p>
    <p>Coq extraction</p>
    <p>GHC</p>
    <p>CSPEC</p>
    <p>executable</p>
    <p>auto generated</p>
    <p>framework</p>
    <p>Linux</p>
  </div>
  <div class="page">
    <p>What is proven vs. assumed correct?</p>
    <p>!35</p>
    <p>file-system spec</p>
    <p>mail library spec</p>
    <p>implementation layers</p>
    <p>patterns</p>
    <p>CMAIL (Coq)</p>
    <p>Coq</p>
    <p>calls to file-system</p>
    <p>SMTP + POP3</p>
    <p>extracted implementation</p>
    <p>CMAIL (Haskell)</p>
    <p>Coq extraction</p>
    <p>GHC</p>
    <p>CSPEC</p>
    <p>executable</p>
    <p>ok Coq proof checker</p>
    <p>Linux</p>
    <p>proven</p>
    <p>auto generated</p>
    <p>assumed correct</p>
  </div>
  <div class="page">
    <p>Concurrency inside CMAIL is proven</p>
    <p>!36</p>
    <p>file-system spec</p>
    <p>mail library spec</p>
    <p>implementation layers</p>
    <p>patterns</p>
    <p>CMAIL (Coq)</p>
    <p>Coq</p>
    <p>calls to file-system</p>
    <p>SMTP + POP3</p>
    <p>extracted implementation</p>
    <p>CMAIL (Haskell)</p>
    <p>Coq extraction</p>
    <p>GHC</p>
    <p>CSPEC</p>
    <p>executable</p>
    <p>ok Coq proof checker</p>
    <p>Linux</p>
    <p>proven</p>
    <p>auto generated</p>
    <p>assumed correct</p>
  </div>
  <div class="page">
    <p>Trust that the tools and OS are correct</p>
    <p>!37</p>
    <p>file-system spec</p>
    <p>mail library spec</p>
    <p>implementation layers</p>
    <p>patterns</p>
    <p>CMAIL (Coq)</p>
    <p>Coq</p>
    <p>calls to file-system</p>
    <p>SMTP + POP3</p>
    <p>extracted implementation</p>
    <p>CMAIL (Haskell)</p>
    <p>Coq extraction</p>
    <p>GHC</p>
    <p>CSPEC</p>
    <p>executable</p>
    <p>ok Coq proof checker</p>
    <p>Linux</p>
    <p>proven</p>
    <p>auto generated</p>
    <p>assumed correct</p>
  </div>
  <div class="page">
    <p>Mail server-specific assumptions</p>
    <p>!38</p>
    <p>file-system spec</p>
    <p>mail library spec</p>
    <p>implementation layers</p>
    <p>patterns</p>
    <p>CMAIL (Coq)</p>
    <p>Coq</p>
    <p>calls to file-system</p>
    <p>SMTP + POP3</p>
    <p>extracted implementation</p>
    <p>CMAIL (Haskell)</p>
    <p>Coq extraction</p>
    <p>GHC</p>
    <p>CSPEC</p>
    <p>executable</p>
    <p>ok Coq proof checker</p>
    <p>Linux</p>
    <p>proven</p>
    <p>auto generated</p>
    <p>assumed correct</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Can CMAIL exploit file-system concurrency for speedup?  How much effort was verifying CMAIL?  What is the benefit of CSPECs machine-checked proofs?</p>
    <p>!39</p>
  </div>
  <div class="page">
    <p>CMAIL achieves speedup with multiple cores</p>
    <p>!40</p>
    <p>kr eq</p>
    <p>/s</p>
    <p># cores 1 2 3 4 5 6 7 8 9 10 11 12</p>
    <p>CMAIL GoMail</p>
  </div>
  <div class="page">
    <p>CMAIL was work but doable</p>
    <p>!41</p>
    <p>proof:code ratio</p>
    <p>CMAIL 11.5x</p>
    <p>CertiKOS 13.8x</p>
    <p>IronFleet 7.7x</p>
    <p>IronClad 4.8x</p>
    <p>CompCert 4.6x</p>
    <p>Took two authors 6 months</p>
    <p>{concurrent</p>
    <p>{sequential</p>
  </div>
  <div class="page">
    <p>Machine-checked proofs give confidence in framework changes</p>
    <p>!42</p>
    <p>Three anecdotes of changes to CSPEC:</p>
    <p>Machine-checked proofs ensure soundness of entire system</p>
  </div>
  <div class="page">
    <p>Machine-checked proofs give confidence in framework changes</p>
    <p>!42</p>
    <p>Implemented partitioning pattern to support multiple users</p>
    <p>Three anecdotes of changes to CSPEC:</p>
    <p>Machine-checked proofs ensure soundness of entire system</p>
  </div>
  <div class="page">
    <p>Machine-checked proofs give confidence in framework changes</p>
    <p>!42</p>
    <p>Implemented partitioning pattern to support multiple users  Improved mover pattern for a CMAIL left mover proof</p>
    <p>Three anecdotes of changes to CSPEC:</p>
    <p>Machine-checked proofs ensure soundness of entire system</p>
  </div>
  <div class="page">
    <p>Machine-checked proofs give confidence in framework changes</p>
    <p>!42</p>
    <p>Implemented partitioning pattern to support multiple users  Improved mover pattern for a CMAIL left mover proof  Implemented error-state pattern for the x86-TSO lock proof</p>
    <p>Three anecdotes of changes to CSPEC:</p>
    <p>Machine-checked proofs ensure soundness of entire system</p>
  </div>
  <div class="page">
    <p>CSPEC is a framework for verifying concurrency in systems software</p>
    <p>Layers and patterns (esp. movers) make proofs manageable  Machine-checked framework supports adding new patterns  Evaluated by verifying mail server and x86-TSO lock</p>
    <p>github.com/mit-pdos/cspec</p>
    <p>!43</p>
  </div>
  <div class="page">
    <p>CSPEC is a framework for verifying concurrency in systems software</p>
    <p>Layers and patterns (esp. movers) make proofs manageable  Machine-checked framework supports adding new patterns  Evaluated by verifying mail server and x86-TSO lock</p>
    <p>github.com/mit-pdos/cspec</p>
    <p>!43</p>
    <p>poster #1</p>
  </div>
</Presentation>
