<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Modelling and Analysis of a Hierarchy of Distance Bounding Attacks</p>
    <p>Tom Chothia, Joeri de Ruiter and Ben Smyth</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>A unified framework for distance bounding attacks.</p>
    <p>Examples: Contactless EMV &amp; NXPs DB protocol.</p>
    <p>A modelling language for DB protocols.</p>
    <p>A hierarchy of security properties, matched to particular attacker models.</p>
    <p>Automatically checking previously defined symbolic properties.</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Core EMV Protocol Shop Card</p>
    <p>UN, amount, currency, . . .</p>
    <p>MACKs(amount,currency,UN,..) SignKcard (amount,currency,UN,Nc..)</p>
    <p>Generate nonce: Nc Session key based on ATC: Ks=EncKbank(ATC)</p>
    <p>Kbank: 3-DES key shared with bank Kcard: an RSA public Kcert : Bank cert. for KcardBanks</p>
    <p>Verification key</p>
    <p>Kcert, ATC</p>
    <p>AC, ATC</p>
  </div>
  <div class="page">
    <p>Mastercards PayPass</p>
  </div>
  <div class="page">
    <p>Shop Phone1 Phone2 Card SELECT</p>
    <p>AIDs</p>
    <p>GPO</p>
    <p>ATC,AC, SDAD, PAN</p>
    <p>READ1</p>
    <p>Static data</p>
    <p>SELECT AID</p>
    <p>AIDs</p>
    <p>READ2</p>
    <p>SSAD,Nc</p>
    <p>READ2</p>
    <p>SSAD,Nc</p>
    <p>SELECT</p>
    <p>AIDs</p>
    <p>UN, amount GPO</p>
    <p>ATC,AC,SDAD,PAN AC, SDAD</p>
    <p>Nc</p>
    <p>Only added time delay</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Uses New Command</p>
    <p>MasterCards Relay Resistance Protocol (RRP) (similar to PaySafe)</p>
    <p>Timing profile sent by card</p>
    <p>We check this as auth. property</p>
  </div>
  <div class="page">
    <p>NXP distance bounding protocol</p>
    <p>NXP sell a distance bounding smart card.</p>
    <p>NXP have patented a distance bounding J</p>
    <p>Patent documents are really hard to read L</p>
    <p>This need may be met by the subject matter according to the independent claims. Advantageous embodiments of the present</p>
    <p>invention are set forth in the dependent claims.</p>
  </div>
  <div class="page">
    <p>NXP Protocol.</p>
    <p>Can be split into 8 one bytes</p>
    <p>message</p>
    <p>Only in one version</p>
  </div>
  <div class="page">
    <p>Some Questions</p>
    <p>How can we formally (symbolically) define these protocols?</p>
    <p>How can we say if these protocols are secure?</p>
    <p>What does secure even mean in this context?</p>
  </div>
  <div class="page">
    <p>Our modelling language for DB</p>
    <p>in (x).P out &lt;x&gt;.P P | Q !P new a.P let x = D in P else Q event(X).P startTimer.P stopTimer.P</p>
    <p>Locations: L = [ P ] or L | L Eg. [ EMVCard ] | [ ShopReader ] [ EMVCard | ShopReader ]</p>
  </div>
  <div class="page">
    <p>PaySafe Model let Verifier = out c&lt;SELECT,AID&gt;. in c(pdol). new UN. out c&lt;GET_PROCESSING_OPTIONS,UN,amount&gt;. in c(aip,afl,NC). out c&lt;GENERATE_AC&gt;. in c(SDAD,AC). out c&lt;READ_RECORD&gt;. in c(cCert). let cKey, cId = checksign(cCert,getPubKey(BANK_ID)) in let (=UN,=NC,=rAmount,ATC,AC)=checksign(SDAD,cKey) in event Verified(cId).</p>
  </div>
  <div class="page">
    <p>PaySafe Model let Verifier = out c&lt;SELECT,AID&gt;. in c(pdol). new UN. out c&lt;GET_PROCESSING_OPTIONS,UN,amount&gt;. in c(aip,afl,NC). startTimer. out c&lt;GENERATE_AC&gt;. in c(SDAD,AC). stopTimer. out c&lt;READ_RECORD&gt;. in c(cCert). let cKey, cId = checksign(cCert,getPubKey(BANK_ID)) in let (=UN,=NC,=rAmount,ATC,AC)=checksign(SDAD,cKey) in event Verified(cId).</p>
    <p>[ Verifiers ] | [ Provers ]</p>
    <p>[ Verifiers | Provers ]</p>
    <p>Verifiers = !(new amount.!Verifier) Provers = !(new id. let idP = id in</p>
    <p>let cCert = sign(getPubKey(idP), idP), getPrivKey(BANK_ID)) in</p>
    <p>!event Start(idP). Prover ]</p>
    <p>Unbounded number ids each for an unbounded number of runs</p>
  </div>
  <div class="page">
    <p>challenge</p>
    <p>response</p>
    <p>startTimer</p>
    <p>stopTimer</p>
    <p>challenge</p>
    <p>response</p>
    <p>startTimer</p>
    <p>stopTimer</p>
    <p>StartTimer blocks an messages from remote locations</p>
    <p>stopTimer re-enables messages from remote</p>
    <p>locations</p>
  </div>
  <div class="page">
    <p>(b) (c)</p>
    <p>We write [ Process ]&lt;number of timers running&gt;</p>
    <p>[ in c(x).P | out c&lt;n&gt;.Q ]r -&gt; [ P{n/x} | Q ]r</p>
    <p>[out c&lt;n&gt;.Q]r | [P]0 -&gt; [Q]r | [out c&lt;n&gt;|P]0</p>
    <p>[out c&lt;n&gt;.Q ]r -&gt; [ out c&lt;n&gt; | Q ]r</p>
    <p>Key observation: The semantics just needs to block outputs from remote locations while a timer is running</p>
  </div>
  <div class="page">
    <p>Definitions for the symbolic literature</p>
  </div>
  <div class="page">
    <p>Relay/Mafia Fraud: attackers relay and interfere with messages</p>
    <p>Images from freepik</p>
  </div>
  <div class="page">
    <p>Distance Fraud: remote dishonest prover tricks the verifier</p>
  </div>
  <div class="page">
    <p>Distance Hijacking: remote dishonest prover uses a local honest prover</p>
    <p>Images from freepik</p>
  </div>
  <div class="page">
    <p>Terrorist Fraud: A remote dishonest prover* and local attacker</p>
  </div>
  <div class="page">
    <p>Assisted Distance Fraud: remote dishonest prover* and local dishonest prover</p>
  </div>
  <div class="page">
    <p>Definitions for the symbolic literature</p>
    <p>Relay/Mafia Fraud: attackers relay and interfere with messages</p>
    <p>Lone Distance Fraud: remote dishonest prover tricks the verifier</p>
    <p>Distance Hijacking: remote dishonest prover uses a local honest prover</p>
    <p>Terrorist Fraud: A remote dishonest prover* and local attacker</p>
    <p>Assisted Distance Fraud: remote dishonest prover* and local dishonest prover</p>
  </div>
  <div class="page">
    <p>[ V | A ] | [ A | P(id) ] Location 2Location 1</p>
    <p>AttackerAttackerPOS Card</p>
  </div>
  <div class="page">
    <p>Relay Attack</p>
    <p>There exists relay attack against the protocol P and V if there exists A such that</p>
    <p>[V(id)|A] | [P(id)|A]</p>
    <p>I.e. [ V | A ] | [P(id) | A] -&gt;* [X] | [ new id.Q | Y ] -&gt; [X] | [ Q{a/id} | Y ]</p>
    <p>[ event verified(a).R | W] | [Z]</p>
  </div>
  <div class="page">
    <p>Distance Fraud</p>
    <p>Dishonest prover DP-A(id) = !new id.&lt;board cast all secret values&gt; | A</p>
    <p>Lone Distance Fraud: A dishonest prover remotely authenticates to a verifier.</p>
    <p>[ V(id) ] | [DP-A(id)]</p>
    <p>Distance Hijacking: remote dishonest prover uses a local honest prover</p>
    <p>[V(id)|P(id)] | [DP-A(id)]</p>
    <p>E.g.: For RRP:</p>
    <p>DP-A(id) = A | ! new id. out c&lt;id&gt;!</p>
    <p>let cert = sign((getPubKey(id), id), getPrivKey(BANK_ID)) in</p>
    <p>out c&lt;getPrivKey(id), cert, sharedKey(id))).</p>
  </div>
  <div class="page">
    <p>Terrorist Fraud, TP-A(id): = A | oracle for all functions and values</p>
    <p>Terrorist Fraud: A remote terrorist prover and local attacker [V(id) | A] | [TP-A(id)]</p>
    <p>Assisted Terrorist Fraud: remote terrorist prover and local attacker and honest prover [V(id) | P(id) | A] | [TP-A(id)]</p>
    <p>Assisted Distance Fraud: remote terrorist prover and local dishonest prover</p>
    <p>[V(id)|DP-A(id)] |[TP-A(id)]</p>
    <p>Terrorist Frauds E.g.: For RRP: TP-A(id) = A | ! new id. out c&lt;id&gt;. (</p>
    <p>! in c (atc, message); let macKey=genKey(atc, sharedKey(idP)) in let messageMAC = mac(message, macKey) in out c&lt;messageMAC&gt;</p>
    <p>| ! in c(message); let signed=sign(message,getPrivKey(id)) in out c&lt;signed)&gt;</p>
    <p>| out c&lt;cardCert, id&gt;.</p>
  </div>
  <div class="page">
    <p>Distance Fraud [V(id)] | [DP-A(id)]</p>
    <p>Mafia fraud/Relay [V(id)|A] | [P(id)|A]</p>
    <p>Terrorist Fraud [V(id)|A] | [TP-A(id)]</p>
    <p>Distance Hijacking [V(id)|P(id)] | [DP-A(id)]</p>
    <p>Assisted Distance Fraud [V(id)|DP-A(id)] |[TP-A(id)]</p>
  </div>
  <div class="page">
    <p>Our Building Blocks</p>
    <p>Arbitrary number of provers</p>
    <p>Verifier looking for one of id</p>
    <p>A DolevYao attacker</p>
    <p>Other Provers</p>
    <p>P(id)</p>
    <p>V(id)</p>
    <p>A dishonest prover</p>
    <p>A terrorist prover</p>
    <p>A dishonest prover</p>
    <p>A terrorist prover</p>
    <p>A</p>
    <p>P(id)</p>
    <p>Trying to trick verifier</p>
    <p>Verifier doesnt care about</p>
    <p>DP-A(id)</p>
    <p>TP-A(id)</p>
    <p>DP-A(id)</p>
    <p>TP-A(id)</p>
  </div>
  <div class="page">
    <p>Ordering the Properties  Our building blocks form a</p>
    <p>hierarchy.</p>
    <p>Each level is strictly more expressive than the one below.</p>
    <p>Replacing any process with the one above it, at a particular location, makes the attacker more powerful.</p>
    <p>P(id) A</p>
    <p>P(id)|A</p>
    <p>TF-A(id)</p>
    <p>DF-A(id)</p>
  </div>
  <div class="page">
    <p>[V(id)|A] | [P(id)|A]</p>
    <p>[V(id)|A] | [P(id)|A|P(id)] =</p>
    <p>Equalities between processes</p>
  </div>
  <div class="page">
    <p>Distance Fraud [V(id)] | [DP-A(id)]</p>
    <p>Mafia fraud/Relay [V(id)|A] | [P(id)|A]</p>
    <p>Terrorist Fraud [V(id)|A] | [TP-A(id)]</p>
    <p>Distance Hijacking [V(id)|P(id)] | [DP-A(id)]</p>
    <p>[V(id)|A] | [TP-A(id)|P(id)]</p>
    <p>Assisted Distance Fraud [V(id)|DP-A(id)] |[TP-A(id)]</p>
    <p>[V(id)|P(id)|A] | [TP-A(id)]</p>
    <p>[V(id)|TP-A(id) ] | [TP-A(id)]</p>
  </div>
  <div class="page">
    <p>Distance Fraud [V(id)] | [DP-A(id)]</p>
    <p>[V(id)|TP-A(id)] | [P(id)]</p>
    <p>Mafia fraud/Relay [V(id)|A] | [P(id)|A]</p>
    <p>[V(id)] | [P(id)|A]</p>
    <p>[V(id)|P(id)] | [P(id)|A]</p>
    <p>[V(id)|P(id)] | [P(id) | TP-A(id)] [V(id)|A|P(id)] | [P(id)]</p>
    <p>Terrorist Fraud [V(id)|A] | [TP-A(id)]</p>
    <p>[V(id)|P(id)|A] | [TP-A(id)]</p>
    <p>Distance Hijacking [V(id)|P(id)] | [DP-A(id)]</p>
    <p>V(id)] | [TP-A(id)]</p>
    <p>[V(id) | TP-A(id) ] | [TP-A(id)]</p>
    <p>[V(id)|DP-A(id)] | [P(id)]</p>
    <p>Assisted Distance Fraud [V(id)|DP-A(id)] | [TP-A(id)]</p>
    <p>[V(id)|A] | [P(id)]</p>
    <p>[V(id)|TP-A(id)] | [P(id)|A]</p>
    <p>[V(id)|P(id)|A] | [P(id)|A]</p>
    <p>[V(id)|DP-A(id)] | [P(id)|A]</p>
    <p>[V(id)] | [P(id) | DP-A(id')]</p>
    <p>[V(id)] | [P(id)|TP-A(id')]</p>
    <p>[V(id)] | [TP-A(id)|DP-A(id')] [V(id)|A] | [TP-A(id)|P(id) ]</p>
    <p>[V(id)|P(id)] | [TP-A(id)|DP-A(id)]</p>
    <p>[V(id)|P(id)] | [ TP-A(id)] [V(id)|P(id)] | [P(id) | DP-A(id)]</p>
    <p>[V(id)|TP-A(id)] | [P(id)|TP-A(id)]</p>
    <p>[V(id) | DP-A(id) ] | [P(id) | TP-A(id)]</p>
    <p>[V(id)|A|P(id)] | [P(id)|TP-A(id)]</p>
  </div>
  <div class="page">
    <p>[V(id)] | [DP-A(id)]</p>
    <p>[V(id)] | [TP-A(id)]</p>
    <p>=</p>
    <p>Some Heuristics</p>
  </div>
  <div class="page">
    <p>Distance Fraud [V(id)] | [DP-A(id)]</p>
    <p>Mafia fraud/Relay [V(id)|A] | [P(id)|A]</p>
    <p>[V(id)] | [P(id)|A]</p>
    <p>[V(id)|P(id)] | [P(id)|A]</p>
    <p>Terrorist Fraud [V(id)|A] | [TP-A(id)]</p>
    <p>[V(id)|P(id')|A] | [TP-A(id)]</p>
    <p>Distance Hijacking [V(id)|P(id')] | [DP-A(id)]</p>
    <p>Assisted Distance Fraud [V(id)|DP-A(id') ] | [TP-A(id)]</p>
    <p>Uncompromised Distance Bounding [V(id)|DP-A(id')] | [P(id)|DP-A(id)]</p>
    <p>Relay Hijacking [V(id)|P(id')|A] | [P(id)|A]</p>
    <p>[V(id)] | [P(id)|DP-A(id')]</p>
    <p>[V(id)|A] | [P(id)|TP-A(id')] [V(id)|P(id')] | [P(id)|DP-A(id')]</p>
    <p>[V(id)|P(id')|A] | [P(id)|DTP(id')]</p>
    <p>Key: P(id): honest provers with identity id V(id): verifier wishing to verifier id A: attacker process TP-A(id): terrorist provers, acting as id DP-A(id): dishonest provers, acting as id</p>
  </div>
  <div class="page">
    <p>Relay Hijacking</p>
    <p>Uncompromised Distance Bounding</p>
  </div>
  <div class="page">
    <p>Distance Fraud [V(id)] | [DP-A(id)]</p>
    <p>Mafia fraud/Relay [V(id)|A] | [P(id)|A]</p>
    <p>[V(id)] | [P(id)|A]</p>
    <p>[V(id)|P(id)] | [P(id)|A]</p>
    <p>Terrorist Fraud [V(id)|A] | [TP-A(id)]</p>
    <p>[V(id)|P(id')|A] | [TP-A(id)]</p>
    <p>Distance Hijacking [V(id)|P(id')] | [DP-A(id)]</p>
    <p>Assisted Distance Fraud [V(id)|DP-A(id') ] | [TP-A(id)]</p>
    <p>Uncompromised Distance Bounding [V(id)|DP-A(id')] | [P(id)|DP-A(id)]</p>
    <p>Relay Hijacking [V(id)|P(id')|A] | [P(id)|A]</p>
    <p>[V(id)] | [P(id)|DP-A(id')]</p>
    <p>[V(id)|A] | [P(id)|TP-A(id')] [V(id)|P(id')] | [P(id)|DP-A(id')]</p>
    <p>[V(id)|P(id')|A] | [P(id)|DTP(id')]</p>
    <p>Key: P(id): honest provers with identity id V(id): verifier wishing to verifier id A: attacker process TP-A(id): terrorist provers, acting as id DP-A(id): dishonest provers, acting as id</p>
    <p>Terrorist attackerNo terrorist attacker</p>
    <p>Remote attacker only</p>
    <p>Remote and local attackers</p>
    <p>Trusted devices only</p>
    <p>Some untrusted devices</p>
  </div>
  <div class="page">
    <p>Distance Fraud [V(id)] | [DP-A(id)]</p>
    <p>Mafia fraud/Relay [V(id)|A] | [P(id)|A]</p>
    <p>[V(id)] | [P(id)|A]</p>
    <p>[V(id)|P(id)] | [P(id)|A]</p>
    <p>Terrorist Fraud [V(id)|A] | [TP-A(id)]</p>
    <p>[V(id)|P(id')|A] | [TP-A(id)]</p>
    <p>Distance Hijacking [V(id)|P(id')] | [DP-A(id)]</p>
    <p>Assisted Distance Fraud [V(id)|DP-A(id') ] | [TP-A(id)]</p>
    <p>Remote attacker only Uncompromised Distance Bounding [V(id)|DP-A(id')] | [P(id)|DP-A(id)]</p>
    <p>Relay Hijacking [V(id)|P(id')|A] | [P(id)|A]</p>
    <p>Trusted devices only</p>
    <p>Some untrusted devices</p>
    <p>Terrorist attacker</p>
    <p>[V(id)] | [P(id)|DP-A(id')]</p>
    <p>[V(id)|A] | [P(id)|TP-A(id')] [V(id)|P(id')] | [P(id)|DP-A(id')]</p>
    <p>[V(id)|P(id')|A] | [P(id)|DTP(id')]</p>
    <p>No terrorist attacker</p>
    <p>Remote and local attackers</p>
    <p>Key: P(id): honest provers with identity id V(id): verifier wishing to verifier id A: attacker process TP-A(id): terrorist provers, acting as id DP-A(id): dishonest provers, acting as id</p>
    <p>Prover being checked is compromised</p>
    <p>Prover being checked is not compromised</p>
  </div>
  <div class="page">
    <p>Automatically Checking</p>
    <p>We translate our DB calculus into the applied pi-calculus, and use ProVerif to check processes automatically.</p>
    <p>The translation uses 3 phases:  Phase 1, before the timer start  Phase 2, while the timer is running  Phase 3, after the time stops.</p>
    <p>startTimer jumps from phase 1 to phase 2. stopTimer jumpes from phase 2 to phase 3.</p>
    <p>Process at the same location as the verifier can act in all phases Process at a different location can only act in Phase 1 and Phase 2.</p>
  </div>
  <div class="page">
    <p>Demo</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Conclusion</p>
    <p>A unified framework for distance bounding attacks.</p>
    <p>Examples: Contactless EMV &amp; NXPs DB protocol.</p>
    <p>A modelling language for DB protocols.</p>
    <p>A hierarchy of security properties, matched to particular attacker models.</p>
    <p>Automatically checking previously defined symbolic properties.</p>
  </div>
</Presentation>
