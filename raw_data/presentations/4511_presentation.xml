<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>(C) 2001 Daniel Sorin</p>
    <p>Correctly Implementing Value Prediction in Microprocessors that Support</p>
    <p>Multithreading or Multiprocessing</p>
    <p>Milo M.K. Martin, Daniel J. Sorin, Harold W. Cain,</p>
    <p>Mark D. Hill, and Mikko H. Lipasti</p>
    <p>Computer Sciences Department</p>
    <p>Department of Electrical and Computer Engineering</p>
    <p>University of WisconsinMadison</p>
  </div>
  <div class="page">
    <p>slide 2</p>
    <p>Big Picture</p>
    <p>Nave value prediction can break concurrent systems</p>
    <p>Microprocessors incorporate concurrency  Multithreading (SMT)  Multiprocessing (SMP, CMP)</p>
    <p>Coherent I/O</p>
    <p>Correctness defined by memory consistency model  Comparing predicted value to actual value not always OK</p>
    <p>Different issues for different models</p>
    <p>Violations can occur in practice</p>
    <p>Solutions exist for detecting violations</p>
  </div>
  <div class="page">
    <p>slide 3</p>
    <p>Outline</p>
    <p>The Issues  Value prediction</p>
    <p>Memory consistency models</p>
    <p>The Problem</p>
    <p>Value Prediction and Sequential Consistency</p>
    <p>Value Prediction and Relaxed Consistency Models</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>slide 4</p>
    <p>Value Prediction</p>
    <p>Predict the value of an instruction  Speculatively execute with this value</p>
    <p>Later verify that prediction was correct</p>
    <p>Example: Value predict a load that misses in cache  Execute instructions dependent on value-predicted load</p>
    <p>Verify the predicted value when the load data arrives</p>
    <p>Without concurrency: simple verification is OK  Compare actual value to predicted</p>
    <p>Value prediction literature has ignored concurrency</p>
  </div>
  <div class="page">
    <p>slide 5</p>
    <p>Memory Consistency Models</p>
    <p>Correctness defined by consistency model  Rules about legal orderings of reads and writes</p>
    <p>E.g., do all processors observe writes in the same order?  Example: Sequential consistency (SC)</p>
    <p>Simplest memory model  System appears to be multitasking uniprocessor</p>
    <p>Memory</p>
    <p>P1</p>
    <p>P2</p>
    <p>P3 Appearance of one memory operation at a time</p>
  </div>
  <div class="page">
    <p>slide 6</p>
    <p>Outline</p>
    <p>The Issues</p>
    <p>The Problem  Informal example  Linked list code example</p>
    <p>Value Prediction and Sequential Consistency</p>
    <p>Value Prediction and Relaxed Consistency Models</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>slide 7</p>
    <p>Informal Example of Problem, part 1</p>
    <p>Student #2 predicts grades are on bulletin board B</p>
    <p>Based on prediction, assumes score is 60</p>
    <p>Grades for Class</p>
    <p>Student ID score</p>
    <p>Bulletin Board B</p>
  </div>
  <div class="page">
    <p>slide 8</p>
    <p>Informal Example of Problem, part 2</p>
    <p>Professor now posts actual grades for this class  Student #2 actually got a score of 80</p>
    <p>Announces to students that grades are on board B</p>
    <p>Grades for Class</p>
    <p>Student ID score</p>
    <p>Bulletin Board B</p>
  </div>
  <div class="page">
    <p>slide 9</p>
    <p>Informal Example of Problem, part 3</p>
    <p>Student #2 sees profs announcement and says,</p>
    <p>I made the right prediction (bulletin board B), and my score is 60!</p>
    <p>Actually, Student #2s score is 80</p>
    <p>What went wrong here?  Intuition: predicted value from future</p>
    <p>Problem is concurrency  Interaction between student and professor</p>
    <p>Just like multiple threads, processors, or devices  E.g., SMT, SMP, CMP</p>
  </div>
  <div class="page">
    <p>slide 10</p>
    <p>Linked List Example of Problem (initial state)</p>
    <p>head A</p>
    <p>null</p>
    <p>null A.data</p>
    <p>B.data</p>
    <p>A.next</p>
    <p>B.next</p>
    <p>Linked list with single writer and single reader</p>
    <p>No synchronization (e.g., locks) needed</p>
    <p>Initial state of list Uninitialized node</p>
  </div>
  <div class="page">
    <p>slide 11</p>
    <p>Linked List Example of Problem (Writer)</p>
    <p>head B</p>
    <p>null</p>
    <p>A</p>
    <p>Writer sets up node B and inserts it into list</p>
    <p>A.data</p>
    <p>B.data</p>
    <p>A.next</p>
    <p>B.next</p>
    <p>Code For Writer Thread</p>
    <p>W1: store mem[B.data] &lt;- 80</p>
    <p>W2: load reg0 &lt;- mem[Head]</p>
    <p>W3: store mem[B.next] &lt;- reg0</p>
    <p>W4: store mem[Head] &lt;- B</p>
    <p>I n se</p>
    <p>rt</p>
    <p>{ S</p>
    <p>et u p n</p>
    <p>o d e</p>
  </div>
  <div class="page">
    <p>slide 12</p>
    <p>Linked List Example of Problem (Reader)</p>
    <p>head ?</p>
    <p>null</p>
    <p>null</p>
    <p>Reader cache misses on head and value predicts head=B.</p>
    <p>Cache hits on B.data and reads 60.</p>
    <p>Later verifies prediction of B. Is this execution legal?</p>
    <p>A.data</p>
    <p>B.data</p>
    <p>A.next</p>
    <p>B.next</p>
    <p>Predict head=B Code For Reader Thread</p>
    <p>R1: load reg1 &lt;- mem[Head] = B</p>
    <p>R2: load reg2 &lt;- mem[reg1] = 60</p>
  </div>
  <div class="page">
    <p>slide 13</p>
    <p>Why This Execution Violates SC</p>
    <p>Sequential Consistency  Simplest memory consistency model</p>
    <p>Must exist total order of all operations</p>
    <p>Total order must respect program order at each processor</p>
    <p>Our example execution has a cycle  No total order exists</p>
  </div>
  <div class="page">
    <p>slide 14</p>
    <p>Trying to Find a Total Order</p>
    <p>What orderings are enforced in this example?</p>
    <p>Code For Writer Thread</p>
    <p>W1: store mem[B.data] &lt;- 80</p>
    <p>W2: load reg0 &lt;- mem[Head]</p>
    <p>W3: store mem[B.next] &lt;- reg0</p>
    <p>W4: store mem[Head] &lt;- B</p>
    <p>Code For Reader Thread</p>
    <p>R1: load reg1 &lt;- mem[Head]</p>
    <p>R2: load reg2 &lt;- mem[reg1]</p>
    <p>S et</p>
    <p>u p n</p>
    <p>o d e</p>
    <p>I n se</p>
    <p>rt</p>
    <p>{</p>
    <p>S et</p>
    <p>u p n</p>
    <p>o d e</p>
  </div>
  <div class="page">
    <p>slide 15</p>
    <p>Program Order</p>
    <p>Code For Writer Thread</p>
    <p>W1: store mem[B.data] &lt;- 80</p>
    <p>W2: load reg0 &lt;- mem[Head]</p>
    <p>W3: store mem[B.next] &lt;- reg0</p>
    <p>W4: store mem[Head] &lt;- B</p>
    <p>Code For Reader Thread</p>
    <p>R1: load reg1 &lt;- mem[Head]</p>
    <p>R2: load reg2 &lt;- mem[reg1]</p>
    <p>S et</p>
    <p>u p n</p>
    <p>o d e</p>
    <p>I n se</p>
    <p>rt</p>
    <p>{</p>
    <p>Must enforce program order</p>
  </div>
  <div class="page">
    <p>slide 16</p>
    <p>Data Order</p>
    <p>If we predict that R1 returns the value B, we can violate SC</p>
    <p>Code For Writer Thread</p>
    <p>W1: store mem[B.data] &lt;- 80</p>
    <p>W2: load reg0 &lt;- mem[Head]</p>
    <p>W3: store mem[B.next] &lt;- reg0</p>
    <p>W4: store mem[Head] &lt;- B</p>
    <p>Code For Reader Thread</p>
    <p>R1: load reg1 &lt;- mem[Head] = B</p>
    <p>R2: load reg2 &lt;- mem[reg1] = 60</p>
    <p>S et</p>
    <p>u p n</p>
    <p>o d e</p>
    <p>I n se</p>
    <p>rt</p>
    <p>{</p>
  </div>
  <div class="page">
    <p>slide 17</p>
    <p>Outline</p>
    <p>The Issues</p>
    <p>The Problem</p>
    <p>Value Prediction and Sequential Consistency  Why the problem exists</p>
    <p>How to fix it</p>
    <p>Value Prediction and Relaxed Consistency Models</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>slide 18</p>
    <p>Value Prediction and Sequential Consistency</p>
    <p>Key: value prediction reorders dependent operations  Specifically, read-to-read data dependence order</p>
    <p>Execute dependent operations out of program order</p>
    <p>Applies to almost all consistency models  Models that enforce data dependence order</p>
    <p>Must detect when this happens and recover</p>
    <p>Similar to other optimizations that complicate SC</p>
  </div>
  <div class="page">
    <p>slide 19</p>
    <p>How to Fix SC Implementations</p>
    <p>Address-based detection of violations  Student watches board B between prediction and verification</p>
    <p>Like existing techniques for out-of-order SC processors</p>
    <p>Track stores from other threads  If address matches speculative load, possible violation</p>
    <p>Value-based detection of violations  Student checks grade again at verification  Also an existing idea</p>
    <p>Replay all speculative instructions at commit</p>
    <p>Can be done with dynamic verification (e.g., DIVA)</p>
  </div>
  <div class="page">
    <p>slide 20</p>
    <p>Outline</p>
    <p>The Issues</p>
    <p>The Problem</p>
    <p>Value Prediction and Sequential Consistency</p>
    <p>Value Prediction and Relaxed Consistency Models  Relaxed consistency models</p>
    <p>Value prediction and processor consistency (PC)  Value prediction and weakly ordered models</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>slide 21</p>
    <p>Relaxed Consistency Models</p>
    <p>Relax some orderings between reads and writes</p>
    <p>Allows HW/SW optimizations</p>
    <p>Software must add memory barriers to get ordering</p>
    <p>Intuition: should make value prediction easier</p>
    <p>Our intuition is wrong</p>
  </div>
  <div class="page">
    <p>slide 22</p>
    <p>Processor Consistency</p>
    <p>Just like SC, but relaxes order from write to read  Optimization: allows for FIFO store queue  Examples of PC models:</p>
    <p>SPARC Total Store Order</p>
    <p>IA-32</p>
    <p>Bad news  Same VP issues as for SC</p>
    <p>Intuition: VP breaks read-to-read dependence order</p>
    <p>Relaxing write-to-read order doesnt change issues</p>
    <p>Good news  Same solutions as for SC</p>
  </div>
  <div class="page">
    <p>slide 23</p>
    <p>Weakly Ordered Consistency Models</p>
    <p>Relax orderings unless memory barrier between</p>
    <p>Examples:  SPARC RMO  IA-64</p>
    <p>PowerPC</p>
    <p>Alpha</p>
    <p>Subtle point that affects value prediction  Does model enforce data dependence order?</p>
  </div>
  <div class="page">
    <p>slide 24</p>
    <p>Models that Enforce Data Dependence</p>
    <p>Examples: SPARC RMO, PowerPC, and IA-64</p>
    <p>Code For Writer Thread</p>
    <p>W1: store mem[B.data] &lt;- 80</p>
    <p>W2: load reg0 &lt;- mem[Head]</p>
    <p>W3: store mem[B.next] &lt;- reg0</p>
    <p>W3b: Memory Barrier</p>
    <p>W4: store mem[Head] &lt;- B</p>
    <p>Code For Reader Thread</p>
    <p>R1: load reg1 &lt;- mem[Head]</p>
    <p>R2: load reg2 &lt;- mem[reg1]</p>
    <p>Memory barrier orders W4 after W1, W2, W3</p>
    <p>I n se</p>
    <p>rt</p>
    <p>{</p>
    <p>S et</p>
    <p>u p n</p>
    <p>o d e</p>
  </div>
  <div class="page">
    <p>slide 25</p>
    <p>Violating Consistency Model</p>
    <p>Simple value prediction can break RMO, PPC, IA-64</p>
    <p>How? By relaxing dependence order between reads</p>
    <p>Same issues as for SC and PC</p>
  </div>
  <div class="page">
    <p>slide 26</p>
    <p>Solutions to Problem</p>
    <p>Breaks backward compatibility</p>
    <p>Not practical</p>
  </div>
  <div class="page">
    <p>slide 27</p>
    <p>Models that Dont Enforce Data Dependence</p>
    <p>Example: Alpha</p>
    <p>Requires extra memory barrier (between R1 &amp; R2)</p>
    <p>Code For Writer Thread</p>
    <p>W1: store mem[B.data] &lt;- 80</p>
    <p>W2: load reg0 &lt;- mem[Head]</p>
    <p>W3: store mem[B.next] &lt;- reg0</p>
    <p>W3b: Memory Barrier</p>
    <p>W4: store mem[Head] &lt;- B</p>
    <p>Code For Reader Thread</p>
    <p>R1: load reg1 &lt;- mem[Head]</p>
    <p>R1b: Memory Barrier</p>
    <p>R2: load reg2 &lt;- mem[reg1]</p>
    <p>I n se</p>
    <p>rt</p>
    <p>{</p>
    <p>S et</p>
    <p>u p n</p>
    <p>o d e</p>
  </div>
  <div class="page">
    <p>slide 28</p>
    <p>Issues in Not Enforcing Data Dependence</p>
    <p>Works correctly with value prediction  No detection mechanism necessary</p>
    <p>Do not need to add any more memory barriers for VP</p>
    <p>Additional memory barriers  Non-intuitive locations  Added burden on programmer</p>
  </div>
  <div class="page">
    <p>slide 29</p>
    <p>Summary of Memory Model Issues</p>
    <p>SC Relaxed Models</p>
    <p>Weakly Ordered Models</p>
    <p>PC</p>
    <p>IA-32 SPARC TSO</p>
    <p>Enforce Data Dependence</p>
    <p>NOT Enforce Data Dependence</p>
    <p>IA-64 SPARC RMO</p>
    <p>Alpha</p>
  </div>
  <div class="page">
    <p>slide 30</p>
    <p>Could this Problem Happen in Practice?</p>
    <p>Theoretically, value prediction can break consistency</p>
    <p>Could it happen in practice?</p>
    <p>Experiment:  Ran multithreaded workloads on SimOS</p>
    <p>Looked for code sequences that could violate model</p>
    <p>Result: sequences occurred that could violate model</p>
  </div>
  <div class="page">
    <p>slide 31</p>
    <p>Conclusions</p>
    <p>Nave value prediction can violate consistency</p>
    <p>Subtle issues for each class of memory model</p>
    <p>Solutions for SC &amp; PC require detection mechanism  Use existing mechanisms for enhancing SC performance</p>
    <p>Solutions for more relaxed memory models  Enforce stronger model</p>
  </div>
</Presentation>
