<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Making the Fast Case Common and the Uncommon Case Simple</p>
    <p>in Unbounded Transactional Memory</p>
    <p>Colin Blundell (University of Pennsylvania)</p>
    <p>Joe Devietti (University of Pennsylvania) E Christopher Lewis (VMware, Inc.) Milo M. K. Martin (University of</p>
    <p>Pennsylvania)</p>
  </div>
  <div class="page">
    <p>[ 2 ]</p>
    <p>Overview</p>
    <p>Small transactions: no problem  Implement using local structures of bounded size  Simple/highly-concurrent/low-overhead</p>
    <p>Overflowed transactions: problem  Difficult to preserve all nice properties of bounded TM  Many papers in last several years</p>
    <p>Previous approaches: focus on concurrency + Sustain performance as overflows increase  Involve complex resource manipulation</p>
    <p>Our approach: decouple into two problems  Simple overflow handling: OneTM  Making overflows rare: Permissions-only cache</p>
  </div>
  <div class="page">
    <p>[ 3 ]</p>
    <p>Background</p>
    <p>Transactional memory: the new hot thing  Interface: serialization</p>
    <p>Implementation: optimistic parallelism</p>
    <p>Tasks of every TM  Conflict detection: was serializability violated?</p>
    <p>Version management: how do we recover serializability?</p>
    <p>Bounded hardware TM implementation:  Conflict detection: extend cache coherence</p>
    <p>Version management: many schemes</p>
  </div>
  <div class="page">
    <p>[ 4 ]</p>
    <p>Running Example</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>P1</p>
    <p>a</p>
    <p>b</p>
    <p>S</p>
    <p>M</p>
    <p>L1 Cache</p>
    <p>Memory</p>
    <p>P0</p>
    <p>L1 direct-mapped  No L2  Invalidation-based system  b &amp; d map to same L1 entry</p>
    <p>Tags State Data</p>
  </div>
  <div class="page">
    <p>[ 5 ]</p>
    <p>Transactional Execution</p>
    <p>Memory</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>checkpoint P0 P1</p>
    <p>a</p>
    <p>b</p>
    <p>Tags</p>
    <p>S</p>
    <p>M</p>
    <p>State</p>
    <p>Data</p>
    <p>L1 Cache</p>
  </div>
  <div class="page">
    <p>[ 6 ]</p>
    <p>Conflict Detection</p>
    <p>Memory</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>checkpoint P0 P1</p>
    <p>a</p>
    <p>b</p>
    <p>Tags</p>
    <p>S R</p>
    <p>M</p>
    <p>State</p>
    <p>Data</p>
    <p>L1 Cache</p>
    <p>load a a: re</p>
    <p>ad</p>
    <p>+ Conflict detection is local</p>
  </div>
  <div class="page">
    <p>[ 7 ]</p>
    <p>Committing a Transaction</p>
    <p>Memory</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>checkpoint P0 P1</p>
    <p>a</p>
    <p>b</p>
    <p>Tags</p>
    <p>S R</p>
    <p>M</p>
    <p>State</p>
    <p>Data</p>
    <p>L1 Cache</p>
    <p>X</p>
    <p>Xcommit</p>
    <p>+ Commits are local</p>
  </div>
  <div class="page">
    <p>[ 8 ]</p>
    <p>Version Management</p>
    <p>Memory</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>checkpoint P0 P1</p>
    <p>b: 56</p>
    <p>Log</p>
    <p>a</p>
    <p>b</p>
    <p>Tags</p>
    <p>S R</p>
    <p>M W</p>
    <p>State</p>
    <p>Data</p>
    <p>L1 Cache</p>
    <p>X</p>
    <p>store b, 42</p>
    <p>+ Commits do not change + Log is not bounded</p>
  </div>
  <div class="page">
    <p>[ 9 ]</p>
    <p>Aborting a Transaction</p>
    <p>Memory</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>checkpoint P0 P1</p>
    <p>b: 56</p>
    <p>Log</p>
    <p>a</p>
    <p>b</p>
    <p>Tags</p>
    <p>S R</p>
    <p>M W</p>
    <p>State</p>
    <p>Data</p>
    <p>L1 Cache</p>
    <p>b: rea</p>
    <p>d</p>
    <p>X XX</p>
    <p>X</p>
    <p>X</p>
    <p>X</p>
  </div>
  <div class="page">
    <p>[ 10 ]</p>
    <p>The Catch: Overflows</p>
    <p>Memory</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>checkpoint P0 P1</p>
    <p>b: 56</p>
    <p>Log</p>
    <p>load d</p>
    <p>a</p>
    <p>b</p>
    <p>Tags</p>
    <p>S R</p>
    <p>M W</p>
    <p>State</p>
    <p>Data</p>
    <p>L1 Cache</p>
    <p>X</p>
    <p>Need another mechanism for conflict detection</p>
  </div>
  <div class="page">
    <p>[ 11 ]</p>
    <p>Handling Overflows: Strawman</p>
    <p>Memory</p>
    <p>X</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>W</p>
    <p>checkpoint P0 P1</p>
    <p>b: 56</p>
    <p>Log</p>
    <p>load d</p>
    <p>a</p>
    <p>b</p>
    <p>Tags</p>
    <p>S R</p>
    <p>M W</p>
    <p>State</p>
    <p>Data</p>
    <p>L1 Cache</p>
    <p>X</p>
    <p>d: rea</p>
    <p>d</p>
  </div>
  <div class="page">
    <p>[ 12 ]</p>
    <p>Handling Overflows: Strawman</p>
    <p>Memory</p>
    <p>X</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>W</p>
    <p>checkpoint P0 P1</p>
    <p>b: 56</p>
    <p>Log</p>
    <p>a</p>
    <p>d</p>
    <p>Tags</p>
    <p>S R</p>
    <p>S R</p>
    <p>State</p>
    <p>Data</p>
    <p>L1 Cache</p>
    <p>b: rea</p>
    <p>d</p>
    <p>load d</p>
    <p>+ Preserved safety</p>
    <p>d: rea</p>
    <p>d</p>
  </div>
  <div class="page">
    <p>[ 13 ]</p>
    <p>The Catch to Handling Overflows</p>
    <p>a</p>
    <p>d</p>
    <p>Tags</p>
    <p>S R</p>
    <p>S R</p>
    <p>State</p>
    <p>Data</p>
    <p>Memory</p>
    <p>X</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>L1 Cache</p>
    <p>W . . .</p>
    <p>checkpoint P0 P1</p>
    <p>b: 56</p>
    <p>Log</p>
    <p>n sets</p>
    <p>Need metadata for all n processors</p>
  </div>
  <div class="page">
    <p>[ 14 ]</p>
    <p>The Catch to Handling Overflows</p>
    <p>a</p>
    <p>d</p>
    <p>Tags</p>
    <p>S R</p>
    <p>S R</p>
    <p>State</p>
    <p>Data</p>
    <p>Memory</p>
    <p>X</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>L1 Cache</p>
    <p>W . . . . . .</p>
    <p>checkpoint P0 P1</p>
    <p>b: 56</p>
    <p>Log</p>
    <p>unbounded</p>
    <p>Need metadata for all n processors</p>
    <p>each SW thread</p>
  </div>
  <div class="page">
    <p>[ 15 ]</p>
    <p>The Catch to Handling Overflows</p>
    <p>a</p>
    <p>d</p>
    <p>Tags</p>
    <p>S R</p>
    <p>S R</p>
    <p>State</p>
    <p>Data</p>
    <p>Memory</p>
    <p>X</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>L1 Cache</p>
    <p>W . . . . . .</p>
    <p>How to detect conflicts efficiently?</p>
    <p>How to commit efficiently?</p>
    <p>How to (de)allocate metadata?</p>
    <p>checkpoint P0 P1</p>
    <p>b: 56</p>
    <p>Log UTM, VTM, PTM,</p>
    <p>Bulk, LogTM(-SE),</p>
    <p>unbounded</p>
  </div>
  <div class="page">
    <p>[ 16 ]</p>
    <p>Rest of my talk: a different approach</p>
    <p>Claim 1: bounding concurrency of overflows simplifies implementation</p>
    <p>Eases the problem of conflict detection</p>
    <p>Removes the problem of dynamic metadata allocation</p>
    <p>Is unbounded concurrency necessary?  Depends on the frequency of overflows</p>
    <p>Claim 2: We can make overflows rare</p>
    <p>Take each claim in order  Claim 1: OneTM</p>
    <p>Claim 2: Permissions-only cache</p>
  </div>
  <div class="page">
    <p>[ 17 ]</p>
    <p>OneTM</p>
    <p>Key idea: one overflowed transaction at a time  On a per-application basis</p>
    <p>Better name: HighlanderTM?</p>
    <p>Two implementations  OneTM-Serialized: all threads stall for overflow</p>
    <p>OneTM-Concurrent: serialize only overflows</p>
    <p>Key mechanism: per-application overflow bit  Processors check to determine when to stall</p>
    <p>Coherently cached in a special register</p>
  </div>
  <div class="page">
    <p>[ 18 ]</p>
    <p>OneTM-Serialized</p>
    <p>Fully Concurrent OneTM-Serialized</p>
    <p>P0 P1 P2 P3 P0 P1 P2 P3 No changes to bounded TM Similar to original TCC, but: Maintain aborts Standard CC protocol</p>
    <p>Non-trans</p>
    <p>Bounded</p>
    <p>Overflowed</p>
    <p>Stalled</p>
    <p>T im</p>
    <p>e</p>
  </div>
  <div class="page">
    <p>[ 19 ]</p>
    <p>OneTM-Serialized: Evaluation</p>
    <p>Takeaway #1: If overflows are rare, serialization is sufficient</p>
    <p>barnes cholesky</p>
    <p>ocean radix</p>
    <p>raytrace-baseraytrace-opt</p>
    <p>volrend water</p>
    <p>btree-10btree-33btree-45</p>
    <p>Normalized Runtime</p>
    <p>idealized overflows OneTM-Serialized</p>
    <p>OneTM-Concurrent OneTM-Concurrent+PO-cache</p>
    <p>OneTM-Serialized+PO-cache</p>
    <p>Compare to TM that idealizes overflow handling First workload: SPLASH2</p>
  </div>
  <div class="page">
    <p>[ 20 ]</p>
    <p>OneTM-Serialized: Evaluation</p>
    <p>btree-&lt;n&gt;: mix of updates &amp; read scans (n% read scans)  Performance worse as number of overflows increases</p>
    <p>barnes cholesky</p>
    <p>ocean radix</p>
    <p>raytrace-baseraytrace-opt</p>
    <p>volrend water</p>
    <p>btree-10btree-33btree-45</p>
    <p>Normalized Runtime</p>
    <p>idealized overflows OneTM-Serialized</p>
    <p>OneTM-Concurrent OneTM-Concurrent+PO-cache</p>
    <p>OneTM-Serialized+PO-cache</p>
  </div>
  <div class="page">
    <p>[ 21 ]</p>
    <p>OneTM-Concurrent</p>
    <p>Fully Concurrent OneTM-Serialized OneTM-Concurrent</p>
    <p>P0 P1 P2 P3 P0 P1 P2 P3 P0 P1 P2 P3</p>
    <p>Non-trans</p>
    <p>Bounded</p>
    <p>Overflowed</p>
    <p>Stalled</p>
    <p>T im</p>
    <p>e 4-processor execution No conflicts</p>
  </div>
  <div class="page">
    <p>[ 22 ]</p>
    <p>OneTM-Concurrent Conflict Detection</p>
    <p>a</p>
    <p>b</p>
    <p>Tags</p>
    <p>S R</p>
    <p>M W</p>
    <p>State</p>
    <p>Data</p>
    <p>checkpoint</p>
    <p>WX</p>
    <p>load d P1</p>
    <p>Memory</p>
    <p>X</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>W d: read</p>
    <p>L1 Cache</p>
    <p>P0</p>
    <p>b: 56</p>
    <p>Log</p>
  </div>
  <div class="page">
    <p>[ 23 ]</p>
    <p>OneTM-Concurrent Conflict Detection</p>
    <p>b: 56</p>
    <p>a</p>
    <p>d</p>
    <p>Tags</p>
    <p>S R</p>
    <p>S R</p>
    <p>State</p>
    <p>Data</p>
    <p>Memory</p>
    <p>X</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>L1 Cache</p>
    <p>Log</p>
    <p>W</p>
    <p>load d b: r</p>
    <p>ead</p>
    <p>+ Preserved safety  Added metadata</p>
    <p>P1P0 checkpoint</p>
    <p>d: read</p>
    <p>bounded</p>
  </div>
  <div class="page">
    <p>[ 24 ]</p>
    <p>OneTM-Concurrent Commits</p>
    <p>Problem: actively clearing metadata is nasty  Commit is now a high-overhead operation</p>
    <p>Solution: lazy clearing of metadata  Mechanism: overflowed transaction IDs</p>
    <p>Block metadata extended to include IDs</p>
    <p>Current ID stored with overflow bit</p>
    <p>Key: only one active ID (so, notion of a current ID)</p>
    <p>Changes + Commit now cheap</p>
    <p>Widens datapath</p>
    <p>Admits false conflicts (since IDs are finite-length)</p>
  </div>
  <div class="page">
    <p>[ 25 ]</p>
    <p>OneTM-Concurrent: Evaluation</p>
    <p>+ Performance better than OneTM-Serialized  Still falls off ideal as overflows increase</p>
    <p>barnes cholesky</p>
    <p>ocean radix</p>
    <p>raytrace-baseraytrace-opt</p>
    <p>volrend water</p>
    <p>btree-10btree-33btree-45</p>
    <p>Normalized Runtime</p>
    <p>idealized overflows OneTM-Serialized</p>
    <p>OneTM-Concurrent OneTM-Concurrent+PO-cache</p>
    <p>OneTM-Serialized+PO-cache</p>
  </div>
  <div class="page">
    <p>[ 26 ]</p>
    <p>The Permissions-Only Cache</p>
    <p>a</p>
    <p>b</p>
    <p>Tags</p>
    <p>S R</p>
    <p>M W</p>
    <p>State</p>
    <p>Data</p>
    <p>checkpoint</p>
    <p>L1 Cache</p>
    <p>X</p>
    <p>load d</p>
    <p>Back to cache eviction Goal: avoid overflow Soln: permissions-only cache</p>
    <p>P0 P1</p>
    <p>Memory</p>
    <p>X</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>b</p>
    <p>Tags</p>
    <p>E W</p>
    <p>State</p>
    <p>PO Cache</p>
    <p>b: 56</p>
    <p>Log</p>
    <p>d: read</p>
  </div>
  <div class="page">
    <p>[ 27 ]</p>
    <p>The Permissions-Only Cache</p>
    <p>b: 56</p>
    <p>a</p>
    <p>d</p>
    <p>Tags</p>
    <p>S R</p>
    <p>S R</p>
    <p>State</p>
    <p>Data</p>
    <p>Memory</p>
    <p>X</p>
    <p>checkpoint</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>L1 Cache</p>
    <p>Log</p>
    <p>load d</p>
    <p>b</p>
    <p>Tags</p>
    <p>E W</p>
    <p>State</p>
    <p>PO Cache</p>
    <p>P1P0</p>
    <p>d: read</p>
  </div>
  <div class="page">
    <p>[ 28 ]</p>
    <p>The Permissions-Only Cache</p>
    <p>b: 56</p>
    <p>a</p>
    <p>d</p>
    <p>Tags</p>
    <p>S R</p>
    <p>S R</p>
    <p>State</p>
    <p>Data</p>
    <p>Memory</p>
    <p>X</p>
    <p>checkpoint</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>L1 Cache</p>
    <p>Log</p>
    <p>b</p>
    <p>Tags</p>
    <p>E W</p>
    <p>State</p>
    <p>PO Cache</p>
    <p>Basically unchanged: + Conflict detection + Version management + Commits &amp; aborts</p>
    <p>P1P0</p>
    <p>b: rea</p>
    <p>d</p>
  </div>
  <div class="page">
    <p>[ 29 ]</p>
    <p>The Permissions-Only Cache</p>
    <p>Two key features 1. Accessed only on snoops and evictions</p>
    <p>Impact: Extends overflow threshold 1. 4 KB PO cache: ~1 MB data</p>
    <p>Takeaway #2: We can engineer systems for rare overflows</p>
  </div>
  <div class="page">
    <p>[ 30 ]</p>
    <p>The Permissions-Only Cache: Evaluation</p>
    <p>Add 4 KB permissions-only cache to OneTM</p>
    <p>barnes cholesky</p>
    <p>ocean radix</p>
    <p>raytrace-baseraytrace-opt</p>
    <p>volrend water</p>
    <p>btree-10btree-33btree-45</p>
    <p>Normalized Runtime</p>
    <p>idealized OneTM-Serialized</p>
    <p>OneTM-Concurrent OneTM-Concurrent+PO-cache</p>
    <p>OneTM-Serialized+PO-cache</p>
  </div>
  <div class="page">
    <p>[ 31 ]</p>
    <p>The Permissions-Only Cache: Evaluation</p>
    <p>Overflows reduced to virtually nil OneTM-Serialized + PO cache: a sweet spot?</p>
    <p>barnes cholesky</p>
    <p>ocean radix</p>
    <p>raytrace-baseraytrace-opt</p>
    <p>volrend water</p>
    <p>btree-10btree-33btree-45</p>
    <p>Normalized Runtime</p>
    <p>idealized overflows OneTM-Serialized</p>
    <p>OneTM-Concurrent OneTM-Concurrent+PO-cache</p>
    <p>OneTM-Serialized+PO-cache</p>
  </div>
  <div class="page">
    <p>[ 32 ]</p>
    <p>Related Work</p>
    <p>Lots!  Proposals with low-overhead overflow handling mechanisms</p>
    <p>UTM/LTM, VTM, PTM, LogTM,   Our scheme: PO cache reduces overflow, OneTM handles it simply  Many proposals enhanced by permissions-only cache</p>
    <p>Bounded HTMs backed by software (HyTM, XTM, )  Similar philosophy to ours (uncommon case simple)  Their schemes maintain concurrency but introduce overheads  OneTM-Concurrent sacrifices concurrency but has low overheads  Again, enhanced by permissions-only cache</p>
    <p>Signature-based TMs: conflict detection through finite-sized signatures (Bulk, LogTM-SE, )</p>
    <p>+ Signatures can be saved architecturally + Serialize gradually rather than abruptly  Still an unbounded number of signatures</p>
  </div>
  <div class="page">
    <p>[ 33 ]</p>
    <p>Conclusions</p>
    <p>OneTM: make overflow handling simple  OneTM-Serialized: entry-point unbounded TM  OneTM-Concurrent: more robust to overflows</p>
    <p>Permissions-only cache: make overflows rare + Can engineer to keep overflow rate low for your workload + Enhances many prior unbounded TM proposals</p>
    <p>Combination: TM thats both fast and simple to implement</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>[ 35 ]</p>
    <p>LogTM-SE</p>
    <p>+Very neat! Paging more complex than in OneTM</p>
    <p>Commit of a transaction that has migrated processors must trap to OS</p>
    <p>Our hope for PO cache: overflow only on context switch</p>
    <p>And there LogTM-SE loses directory filter</p>
    <p>Sticky state + OneTM-Serialized?</p>
  </div>
  <div class="page">
    <p>[ 36 ]</p>
    <p>Hybrid Transactional Memories</p>
    <p>Similar philosophy to OneTM  Our goal: make overflows so rare that it doesnt</p>
    <p>really matter what you use for them  And then OneTM-Serialized is pretty simple</p>
    <p>If overflows are frequent, need to handle them with high performance</p>
    <p>Permissions-only cache + UTM/VTM/PTM?</p>
    <p>Spot in the middle for hybrid TMs/OneTMConcurrent</p>
    <p>Occasional overflow: OneTM-Concurrent appealing  Tipping point where concurrency matters more than</p>
    <p>overheadsI dont know where it is (need workloads)</p>
  </div>
  <div class="page">
    <p>[ 37 ]</p>
    <p>Context Switching &amp; Paging</p>
    <p>Context switching just works  OneTM-Serialized: overflowed bit persists</p>
    <p>OneTM-Concurrent: metadata persists as well</p>
    <p>Paging during an overflowed transaction:  OneTM-Serialized: no problem</p>
    <p>OneTM-Concurrent: page metadata (OS help)</p>
    <p>Paging during a bounded transaction:  Abort and transition to overflowed mode</p>
  </div>
  <div class="page">
    <p>[ 38 ]</p>
    <p>Transitioning to Overflowed Mode</p>
    <p>OneTM-Serialized: just set the bit  Synchronize access</p>
    <p>OneTM-Concurrent: have to set metadata  Simple: abort and restart (what we simulate)</p>
    <p>Higher-performance schemes are possible</p>
    <p>Walk the cache</p>
    <p>Overflow gradually</p>
  </div>
  <div class="page">
    <p>[ 39 ]</p>
    <p>Summary</p>
    <p>a</p>
    <p>b</p>
    <p>Tags</p>
    <p>S R</p>
    <p>M W</p>
    <p>State</p>
    <p>Data</p>
    <p>checkpoint</p>
    <p>X</p>
    <p>P1</p>
    <p>Memory</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>L1 Cache</p>
    <p>P0</p>
    <p>b: 56</p>
    <p>Log</p>
    <p>overflow bit</p>
  </div>
  <div class="page">
    <p>[ 40 ]</p>
    <p>Summary</p>
    <p>a</p>
    <p>b</p>
    <p>Tags</p>
    <p>S R</p>
    <p>M W</p>
    <p>State</p>
    <p>Data</p>
    <p>checkpoint</p>
    <p>X</p>
    <p>P1</p>
    <p>a:</p>
    <p>b:</p>
    <p>d:</p>
    <p>L1 Cache</p>
    <p>P0</p>
    <p>b: 56</p>
    <p>Log</p>
    <p>overflow bit</p>
    <p>Memory</p>
    <p>Tags State</p>
    <p>PO Cache</p>
    <p>Metadata (for OneTM-Concurrent only)</p>
  </div>
  <div class="page">
    <p>[ 41 ]</p>
    <p>The Permissions-only Cache: Efficient Storage</p>
    <p>Sector cache to reduce tag overhead  Now: (close to) 2 bits per data block  64-byte blocks: 256 to 1 compression ratio  4 KB metadata: 1 MB transactional data</p>
    <p>Even larger: metadata in L2 data lines  add bit to distinguish data/metadata  4 MB L2: 1 GB transactional data</p>
    <p>WRTags WR WR WR WRTags</p>
  </div>
</Presentation>
