<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>MALT: NSDI 2020MALT: NSDI 2020</p>
    <p>Experiences with Modeling Network Topologies at Multiple Levels of Abstraction</p>
    <p>Jeffrey C. Mogul, Drago Goricanec, Martin Pool, Anees Shaikh, Douglas Turk, Bikash Koley (Google) Xiaoxue Zhao (Alibaba Group Inc.)  and a cast of hundreds</p>
  </div>
  <div class="page">
    <p>A common standard for representing network topology</p>
    <p>It's not as easy as you might think -- the paper tries to explain what we learned  This talk only scratches the surface</p>
  </div>
  <div class="page">
    <p>Google has some big networks</p>
  </div>
  <div class="page">
    <p>PoPs and network: 134 points of presence and 14 subsea cable investments around the globe (as of Feb 2020) (Google internal data)</p>
    <p>Network Edge point of presence</p>
  </div>
  <div class="page">
    <p>MALT: NSDI 2020 5</p>
  </div>
  <div class="page">
    <p>MALT: NSDI 2020 6</p>
    <p>These networks have a lot of wires ...</p>
  </div>
  <div class="page">
    <p>Big networks need automated management</p>
    <p>At our scale, we need to automate all phases of managing a network:  Demand forecasting and capacity planning  High-level network design  Detailed network design  Ordering materials -- racks, switches, cables, etc.  Installing the physical network (instructions to human operators)  Configuring switches and SDN controllers  Monitoring the state of the network and its pieces  Diagnosing problems</p>
  </div>
  <div class="page">
    <p>Big networks need automated management</p>
    <p>At our scale, we need to automate all phases of managing a network:  Demand forecasting and capacity planning  High-level network design  Detailed network design  Ordering materials -- racks, switches, cables, etc.  Installing the physical network (instructions to human operators)  Configuring switches and SDN controllers  Monitoring the state of the network and its pieces  Diagnosing problems</p>
    <p>Note: smaller networks need automation, too -- it's just less obvious</p>
  </div>
  <div class="page">
    <p>Automation needs data</p>
    <p>In order to automate safely, we need precise and accurate data about our networks:</p>
    <p>High-level plans for connectivity  Low-level details of connectivity  Device &amp; controller configuration  Access control policies  Routing policies  IP address allocations</p>
  </div>
  <div class="page">
    <p>Automation needs data</p>
    <p>In order to automate safely, we need precise and accurate data about our networks:</p>
    <p>High-level plans for connectivity  Low-level details of connectivity  Device &amp; controller configuration  Access control policies  Routing policies  IP address allocations</p>
    <p>} topology intent for a network</p>
    <p>} policy intent controlling how topology intent leads to config</p>
    <p>} derived from topology intent</p>
  </div>
  <div class="page">
    <p>Automation needs data</p>
    <p>In order to automate safely, we need precise and accurate data about our networks:</p>
    <p>High-level plans for connectivity  Low-level details of connectivity  Device &amp; controller configuration  Access control policies  Routing policies  IP address allocations</p>
    <p>Topology: the starting point for almost all inputs to automated network management</p>
    <p>} topology intent for a network</p>
    <p>} policy for deriving config from topology } derived from topology intent</p>
  </div>
  <div class="page">
    <p>A common standard for representing network topology</p>
    <p>Multi-Abstraction-Layer Topology (MALT):</p>
    <p>Google's internal standard for (almost) all representations of network topology  Supports interoperability between many software systems  Supports multiple layers of abstraction  Supports extensibility and evolution  Supports declarative approaches to network management  Supported by a rich software ecosystem</p>
  </div>
  <div class="page">
    <p>Why a standard representation?</p>
    <p>Prior to adopting MALT, we had lots of ad hoc producer-consumer agreements  knowledge was often hidden in code</p>
    <p>A standard representation:  decouples producers and consumers  exposes knowledge in the data, rather than</p>
    <p>hiding it in code  enables the development of shared</p>
    <p>infrastructure  Overall: enables faster innovation</p>
    <p>P1 P2 Pn...</p>
    <p>C1 C2 ... Cm</p>
    <p>P1 P2 Pn...</p>
    <p>C1 C2 ... Cm</p>
    <p>Single standard</p>
    <p>No standard: m*n agreements</p>
    <p>With standard: m+n agreements</p>
  </div>
  <div class="page">
    <p>Key</p>
    <p>Example: MALT for a multi-phase network design pipeline</p>
    <p>Demand forecast</p>
    <p>Human inputs</p>
    <p>High-level network design</p>
    <p>Detailed L3 network design</p>
    <p>Detailed L1 network design</p>
    <p>Automated high-level designer</p>
    <p>Automated L3 designer</p>
    <p>Automated L1 designer</p>
    <p>L3 design rules</p>
    <p>L1 design rules</p>
    <p>Spatial data</p>
    <p>L3 consumers: device config, SDN controllers, etc.</p>
    <p>L1 consumers: materials ordering, fiber installation, etc.</p>
    <p>MALT data</p>
    <p>Process step</p>
    <p>Other data</p>
    <p>Generate network designs automatically  Start with high-level abstractions  Expand detail at each step, based on</p>
    <p>additional data</p>
  </div>
  <div class="page">
    <p>Abstractions go deep</p>
    <p>router</p>
    <p>physical_packet_link</p>
    <p>optical transponder/ muxponder card</p>
    <p>client port</p>
    <p>line port</p>
    <p>optical common mux/demux, ROADM</p>
    <p>local port DWDM</p>
    <p>port</p>
    <p>SMF28 fiber</p>
    <p>LEAF fiber</p>
    <p>fiber joint</p>
    <p>ODU</p>
    <p>OTU</p>
    <p>OCH / OMSG</p>
    <p>OMS</p>
    <p>OTS fiber</p>
    <p>segment optical amplifier</p>
    <p>Media_link</p>
    <p>Media_link</p>
    <p>Example of &quot;Optical Transport Network&quot; hierarchy (used in WANs)</p>
  </div>
  <div class="page">
    <p>Basics of MALT</p>
    <p>MALT is an entity-relationship model:  Entities represent things: real or abstract  Entities have entity-kinds, names and attributes  Relationships connect entities, and don't have attributes</p>
    <p>Example real entities: routers; connectors; fibers; server machines; racks  Example abstract entities: Clos networks; trunk links; groups of all sorts  Example relationships: contains, aggregates, controls</p>
    <p>MALT today has:  ca. 250 entity-kinds  ca. 20 relationship-kinds</p>
  </div>
  <div class="page">
    <p>Trivial entity-relationship graph (one L3 link)</p>
    <p>L2 elements</p>
    <p>L3 elements</p>
    <p>EK_LOGICAL_PACKET_LINK Y:1.0 - X:1.0</p>
    <p>EK_PORT X:1</p>
    <p>EK_PORT Y:1</p>
    <p>EK_PHYSICAL_PACKET_LINK X:1 - Y:1</p>
    <p>EK_PHYSICAL_PACKET_LINK Y:1 - X:1</p>
    <p>RK_CONTAINS RK_TRAVERSES RK_ORGINATES RK_TERMINATES</p>
    <p>EK_ROUTER X</p>
    <p>EK_ROUTER Y</p>
    <p>EK_INTERFACE X:1.0</p>
    <p>EK_INTERFACE Y:1.0</p>
    <p>EK_LOGICAL_PACKET_LINK X:1.0 - Y:1.0</p>
    <p>Entity</p>
  </div>
  <div class="page">
    <p>Trivial entity-relationship graph (one L3 link)</p>
    <p>L2 elements</p>
    <p>L3 elements</p>
    <p>EK_LOGICAL_PACKET_LINK Y:1.0 - X:1.0</p>
    <p>EK_PORT X:1</p>
    <p>EK_PORT Y:1</p>
    <p>EK_PHYSICAL_PACKET_LINK X:1 - Y:1</p>
    <p>EK_PHYSICAL_PACKET_LINK Y:1 - X:1</p>
    <p>RK_CONTAINS RK_TRAVERSES RK_ORGINATES RK_TERMINATES</p>
    <p>EK_ROUTER X</p>
    <p>EK_ROUTER Y</p>
    <p>EK_INTERFACE X:1.0</p>
    <p>EK_INTERFACE Y:1.0</p>
    <p>EK_LOGICAL_PACKET_LINK X:1.0 - Y:1.0Relationship</p>
  </div>
  <div class="page">
    <p>Trivial entity-relationship graph (one L3 link)</p>
    <p>L2 elements</p>
    <p>L3 elements</p>
    <p>EK_ROUTER X</p>
    <p>EK_ROUTER Y</p>
    <p>EK_INTERFACE X:1.0</p>
    <p>EK_INTERFACE Y:1.0</p>
    <p>EK_LOGICAL_PACKET_LINK X:1.0 - Y:1.0</p>
    <p>EK_LOGICAL_PACKET_LINK Y:1.0 - X:1.0</p>
    <p>EK_PORT X:1</p>
    <p>EK_PORT Y:1</p>
    <p>EK_PHYSICAL_PACKET_LINK X:1 - Y:1</p>
    <p>EK_PHYSICAL_PACKET_LINK Y:1 - X:1</p>
    <p>RK_CONTAINS RK_TRAVERSES RK_ORGINATES RK_TERMINATES</p>
  </div>
  <div class="page">
    <p>&quot;This looks too verbose&quot;</p>
    <p>MALT is meant for computers, not for humans!  Computers are good at processing graphs with millions of entities  Software is bad at making inferences -- it's better to have too much detail</p>
  </div>
  <div class="page">
    <p>&quot;This looks too verbose&quot;</p>
    <p>MALT is meant for computers, not for humans!  Computers are good at processing graphs with millions of entities  Software is bad at making inferences -- it's better to have too much detail</p>
    <p>But we can still express MALT graphs in text, when we have to: EK_ROUTER/X RK_CONTAINS EK_INTERFACE/X:1.0</p>
    <p>EK_INTERFACE/X:1.0 RK_TRAVERSES EK_PORT/X:1</p>
    <p>EK_ROUTER/Y RK_CONTAINS EK_INTERFACE/Y:1.0</p>
    <p>EK_INTERFACE/Y:1.0 RK_TRAVERSES EK_PORT/Y:1</p>
    <p>EK_LOGICAL_PACKET_LINK/&quot;X:1.0 - Y:1.0&quot;</p>
    <p>RK_TRAVERSES EK_PHYSICAL_PACKET_LINK/&quot;X:1 - Y:1&quot;</p>
    <p>EK_PORT/X:1 RK_ORIGINATES</p>
    <p>EK_PHYSICAL_PACKET_LINK/&quot;X:1 - Y:1&quot;</p>
    <p>EK_PORT/Y:1 RK_TERMINATES</p>
    <p>EK_PHYSICAL_PACKET_LINK/&quot;X:1 - Y:1&quot;</p>
    <p>EK_INTERFACE/X:1.0 RK_ORIGINATES</p>
    <p>EK_LOGICAL_PACKET_LINK/&quot;X:1.0 - Y:1.0&quot;</p>
    <p>EK_INTERFACE/Y:1.0 RK_TERMINATES</p>
    <p>EK_LOGIICAL_PACKET_LINK/&quot;X:1.0 - Y:1.0&quot;</p>
    <p>(this is about 80% of the previous diagram) 21</p>
  </div>
  <div class="page">
    <p>Entity attributes</p>
    <p>Attributes allow us to express intent and status for specific points in the topology</p>
    <p>Partial examples for EK_PORT and EK_INTERFACE, using Google Protocol Buffer notation:</p>
    <p>port_attr: &lt;</p>
    <p>device_port_name: &quot;port-1/24&quot;</p>
    <p>openflow: &lt;</p>
    <p>of_port_number: 24</p>
    <p>&gt;</p>
    <p>port_role: PR_SINGLETON</p>
    <p>port_attributes: &lt;</p>
    <p>physical_capacity_bps: 40000000000</p>
    <p>&gt;</p>
    <p>dropped_packets_per_second: 3</p>
    <p>&gt;</p>
    <p>interface_attr: &lt;</p>
    <p>address: &lt;</p>
    <p>ipv4: &lt;</p>
    <p>address: &quot;10.1.2.3&quot;</p>
    <p>prefixlen: 32</p>
    <p>&gt;</p>
    <p>ipv6: &lt;</p>
    <p>address: &quot;1111:2222:3333:4444::&quot;</p>
    <p>prefixlen: 64</p>
    <p>&gt;</p>
    <p>&gt;</p>
    <p>&gt;</p>
  </div>
  <div class="page">
    <p>Entity attributes</p>
    <p>Attributes allow us to express intent and status for specific points in the topology</p>
    <p>Partial examples for EK_PORT and EK_INTERFACE, using Google Protocol Buffer notation:</p>
    <p>port_attr: &lt;</p>
    <p>device_port_name: &quot;port-1/24&quot;</p>
    <p>openflow: &lt;</p>
    <p>of_port_number: 24</p>
    <p>&gt;</p>
    <p>port_role: PR_SINGLETON</p>
    <p>port_attributes: &lt;</p>
    <p>physical_capacity_bps: 40000000000</p>
    <p>&gt;</p>
    <p>dropped_packets_per_second: 3</p>
    <p>&gt;</p>
    <p>interface_attr: &lt;</p>
    <p>address: &lt;</p>
    <p>ipv4: &lt;</p>
    <p>address: &quot;10.1.2.3&quot;</p>
    <p>prefixlen: 32</p>
    <p>&gt;</p>
    <p>ipv6: &lt;</p>
    <p>address: &quot;1111:2222:3333:4444::&quot;</p>
    <p>prefixlen: 64</p>
    <p>&gt;</p>
    <p>&gt;</p>
    <p>&gt;</p>
    <p>intent attributes</p>
    <p>observed attribute</p>
  </div>
  <div class="page">
    <p>MALT's software ecosystem</p>
    <p>MALT's representation would be useless without a rich software ecosystem:</p>
    <p>Libraries to support common operations and hide some details  Systems to automatically generate detailed models from abstract models  Model visualization and network visualization GUIs  A domain-specific query language  A scalable, reliable storage system</p>
  </div>
  <div class="page">
    <p>MALT queries</p>
    <p>Most applications navigate small regions of a model, not an entire graph  e.g.: generate config for a single device; figure out what fails if a rack dies</p>
    <p>MALT has a query language to make this reasonably efficient  It's hard to get the right tradeoff between expressive power and usability  The raw query language is still confusing to many programmers</p>
    <p>We added a layer of &quot;canned queries&quot; with specific semantics  E.g. &quot;All L2 links between a pair of switches&quot; or &quot;Rack that contains a line card&quot;</p>
    <p>Canned queries also insulate clients against many kinds of schema change</p>
    <p>Why didn't we use SQL queries?  We have good reasons not to expose SQL  see the paper</p>
  </div>
  <div class="page">
    <p>Example MALT query # Given a device, find its geographical information and</p>
    <p># the ports and interfaces it contains.</p>
    <p>cmd { find { match { id { kind: EK_DEVICE name: 'foo' }}}}</p>
    <p>cmd</p>
    <p>branch {</p>
    <p># Expand backwards.</p>
    <p>sequence {</p>
    <p>cmd {</p>
    <p>follow_until {</p>
    <p>kind: RK_CONTAINS dir:DIR_BACKWARDS</p>
    <p>target { match { id { kind: EK_CONTINENT }}}</p>
    <p>}</p>
    <p>}</p>
    <p>}</p>
    <p># Expand forwards.</p>
    <p>sequence {</p>
    <p>cmd {</p>
    <p>follow_until {</p>
    <p>kind: RK_CONTAINS</p>
    <p>target {</p>
    <p>match { id { kind: EK_PORT } }</p>
    <p>match { id { kind: EK_INTERFACE } }</p>
    <p>}</p>
    <p>}</p>
    <p>}</p>
    <p>}</p>
    <p>}</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Storage: MALTshop</p>
    <p>We wanted a single (replicated) service for storing MALT models:  Implement and operate just one high-availability service, not lots of them  Promote controlled sharing between applications and teams  Ensure there's an easy way to find anything across all of our network models</p>
    <p>MALTshop:  Supports zillions of named &quot;shards&quot; with ACLs + immutable-version semantics  Efficient support for incremental updates, queries, etc.  Based on Spanner for scale and geo-consistency  Currently: thousands of shards, millions of entities/shard, 1000s of queries/sec</p>
  </div>
  <div class="page">
    <p>MALT: NSDI 2020Confidential + Proprietary</p>
    <p>This is not as easy as you might think</p>
  </div>
  <div class="page">
    <p>We learned a lot of lessons, the hard way</p>
    <p>Schema design principles (and the need to be rigorous about them)  Support for schema evolution  Structure design pipelines as dataflow graphs, not shared-database updates  Use different models for different phases of a network's lifecycle  Migrating users from older representations (it's really hard)  The dangers of string-parsing (it's really bad)  Using human-readable names for entities (not our best idea)  A good representation doesn't save you from dirty data</p>
  </div>
  <div class="page">
    <p>We learned a lot of lessons, the hard way</p>
    <p>Schema design principles (and the need to be rigorous about them)  Support for schema evolution  Structure design pipelines as dataflow graphs, not shared-database updates  Use different models for different phases of a network's lifecycle  Migrating users from older representations (it's really hard)  The dangers of string-parsing (it's really bad)  Using human-readable names for entities (not our best idea)  A good representation doesn't save you from dirty data</p>
    <p>Only enough time for a few of these topics; see the paper for the others</p>
  </div>
  <div class="page">
    <p>Schema design principles</p>
    <p>&quot;Fewer entity-kinds&quot; does not make the schema &quot;simpler&quot;  Overloaded concepts lead to ambiguity, which leads to complex/fragile code</p>
    <p>Instead, favor orthogonality and separation of aspects  Orthogonality: two &quot;things&quot; with mostly-disjoint attributes/relationships should be two EKs  Separation of aspects: complex things (e.g., routers) can be multiple EK (data plane, metal, etc.)</p>
    <p>Use explicit relationships rather than name-based attributes</p>
    <p>Use relationship-kinds consistently  Otherwise, it's harder to create straightforward queries</p>
  </div>
  <div class="page">
    <p>Schema evolution</p>
    <p>Networks are complex and we're constantly innovating in unexpected ways  So, the MALT schema needs to continually evolve</p>
    <p>We use multiple processes to manage evolution:  Curation of schema changes via expert &quot;review board&quot; + a written Style Guide  &quot;Profiles&quot; to further constrain schema for specific parts of our networks</p>
    <p>+ machine-checkable profile language to enforce contract between producers + consumers</p>
    <p>Explicit profile versions, so consumers can evolve independent of producers  Automated model generation allows producers to create the same data for multiple profiles</p>
    <p>&quot;Canned queries&quot; insulate most consumers from much of our evolution</p>
    <p>Abstraction is vital, but taxonomy is hard -- even for experts</p>
  </div>
  <div class="page">
    <p>Why we prefer dataflow design pipelines to databases Demand forecast</p>
    <p>Human inputs</p>
    <p>High-level network design</p>
    <p>Detailed L3 network design</p>
    <p>Detailed L1 network design</p>
    <p>Automated high-level designer</p>
    <p>Automated L3 designer</p>
    <p>Automated L1 designer</p>
    <p>L3 design rules</p>
    <p>L1 design rules</p>
    <p>Spatial data</p>
    <p>Dataflow-style design pipeline</p>
    <p>L3 consumers</p>
    <p>L1 consumers</p>
  </div>
  <div class="page">
    <p>Why we prefer dataflow design pipelines to databases Demand forecast</p>
    <p>Human inputs</p>
    <p>High-level network design</p>
    <p>Detailed L3 network design</p>
    <p>Detailed L1 network design</p>
    <p>Automated high-level designer</p>
    <p>Automated L3 designer</p>
    <p>Automated L1 designer</p>
    <p>L3 design rules</p>
    <p>L1 design rules</p>
    <p>Spatial data</p>
    <p>Dataflow-style design pipeline</p>
    <p>Human inputs</p>
    <p>Automated high-level designer</p>
    <p>Automated L3 designer</p>
    <p>Automated L1 designer</p>
    <p>L3 design rules</p>
    <p>L1 design rules</p>
    <p>Spatial data</p>
    <p>Topology database</p>
    <p>L3 consumers</p>
    <p>L1 consumers</p>
    <p>L3 consumers</p>
    <p>L1 consumers</p>
    <p>Database-style design pipeline 34</p>
    <p>&gt;&gt;</p>
  </div>
  <div class="page">
    <p>Why we prefer dataflow design pipelines to databases Demand forecast</p>
    <p>Human inputs</p>
    <p>High-level network design</p>
    <p>Detailed L3 network design</p>
    <p>Detailed L1 network design</p>
    <p>Automated high-level designer</p>
    <p>Automated L3 designer</p>
    <p>Automated L1 designer</p>
    <p>L3 design rules</p>
    <p>L1 design rules</p>
    <p>Spatial data</p>
    <p>Dataflow-style design pipeline</p>
    <p>Human inputs</p>
    <p>Automated high-level designer</p>
    <p>Automated L3 designer</p>
    <p>Automated L1 designer</p>
    <p>L3 design rules</p>
    <p>L1 design rules</p>
    <p>Spatial data</p>
    <p>Topology database</p>
    <p>L3 consumers</p>
    <p>L1 consumers</p>
    <p>L3 consumers</p>
    <p>L1 consumers</p>
    <p>Database-style design pipeline 35</p>
    <p>Dataflow-style pipeline:</p>
    <p>Clear ownership of data at each stage</p>
    <p>Clear producer-consumer contracts</p>
    <p>Easy to create test datasets</p>
    <p>Easy to re-run the pipeline when things change</p>
    <p>Easy to insert validations at each step</p>
  </div>
  <div class="page">
    <p>Why we prefer dataflow design pipelines to databases Demand forecast</p>
    <p>Human inputs</p>
    <p>High-level network design</p>
    <p>Detailed L3 network design</p>
    <p>Detailed L1 network design</p>
    <p>Automated high-level designer</p>
    <p>Automated L3 designer</p>
    <p>Automated L1 designer</p>
    <p>L3 design rules</p>
    <p>L1 design rules</p>
    <p>Spatial data</p>
    <p>Dataflow-style design pipeline</p>
    <p>Human inputs</p>
    <p>Automated high-level designer</p>
    <p>Automated L3 designer</p>
    <p>Automated L1 designer</p>
    <p>L3 design rules</p>
    <p>L1 design rules</p>
    <p>Spatial data</p>
    <p>Topology database</p>
    <p>L3 consumers</p>
    <p>L1 consumers</p>
    <p>L3 consumers</p>
    <p>L1 consumers</p>
    <p>Database-style design pipeline 36</p>
    <p>Dataflow-style pipeline:</p>
    <p>Clear ownership of data at each stage</p>
    <p>Clear producer-consumer contracts</p>
    <p>Easy to create test datasets</p>
    <p>Easy to re-run the pipeline when things change</p>
    <p>Easy to insert validations at each step</p>
    <p>Database-style pipeline:</p>
    <p>Stages are unclear</p>
    <p>Ownership is global</p>
    <p>Fuzzy producer-consumer contracts</p>
    <p>Hard to create test datasets</p>
    <p>Hard to re-run the pipeline, because you first have to undo the previous updates</p>
  </div>
  <div class="page">
    <p>Thanks!</p>
    <p>Automation requires both low-level detail and abstraction  Abstraction is hard and requires support for controlled evolution  A data-exchange format needs a full software ecosystem  Network topology ties together all of our network management automation  Network management: it's about the whole lifecycle, not just the running network</p>
  </div>
</Presentation>
