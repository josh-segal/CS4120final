<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>We Still Dont Have Secure Cross-Domain Requests: an Empirical Study of CORS</p>
    <p>Jianjun Chen, Jian Jiang, Haixin Duan, Tao Wan, Shuo Chen, Vern Paxson, Min Yang</p>
    <p>Tsinghua University, Shape Security, Huawei Canada, Microsoft Research, UC Berkeley, Fudan University</p>
  </div>
  <div class="page">
    <p>Same Origin Policy (SOP)</p>
    <p>Isolate resources from different origins  Cross origin network access: Can send, Cant Read</p>
    <p>Browser</p>
    <p>Web server (a.com)</p>
    <p>Web server (b.com)</p>
    <p>GE T h</p>
    <p>ttp ://</p>
    <p>b.c om</p>
    <p>Security Isolation</p>
    <p>a.com b.com</p>
    <p>HT TP</p>
    <p>res pon</p>
    <p>se</p>
  </div>
  <div class="page">
    <p>Developers need cross origin reading</p>
    <p>JSON with Padding (JSON-P)  A workaround to server the need  introduces many inherent security issues</p>
    <p>Cross Origin Resource Sharing (CORS)  A more disciplined mechanism  Browsers support(2009), W3C standard(2014)</p>
  </div>
  <div class="page">
    <p>Our work</p>
    <p>Conducted an empirical study on CORS  Including its design, implementation and deployment</p>
    <p>Discovered a number of security issues  4 categories of browser-side issues  7 categories of sever-side issues</p>
    <p>Conducted a large-scale measurement on popular websites  27.5% of CORS configured websites have insecure CORS configuration</p>
    <p>Proposed mitigations and some of them have been adopted by web standard and major browsers.</p>
  </div>
  <div class="page">
    <p>Contents</p>
    <p>Web SOP and CORS background</p>
    <p>Our discovery: CORS security issues  Browser-side: overly permissive sending  Server-side: CORS misconfigurations</p>
    <p>CORS real-world deployments  Our large scale measurement</p>
    <p>Disclosure and Mitigation</p>
  </div>
  <div class="page">
    <p>Web &amp; CORS background</p>
  </div>
  <div class="page">
    <p>The default SOP prevents cross origin reading</p>
    <p>a.com Server</p>
    <p>Browser b.comServer Load JS</p>
    <p>GET http://b.com</p>
    <p>Developers need cross origin reading!</p>
    <p>Same Origin Policy</p>
    <p>Online Shopping Website Shipping Website</p>
  </div>
  <div class="page">
    <p>Cross origin resource sharing (CORS)</p>
    <p>a.com Server</p>
    <p>Browser b.com Server</p>
    <p>Load JS GET request</p>
    <p>Origin: http://a.com</p>
    <p>HTTP response with CORS policy Access-Control-Allow-Origin:http://a.com</p>
    <p>Browser enforce policy</p>
    <p>Explicit authorization access control mechanism  Browsers support(2009), W3C standard(2014)</p>
  </div>
  <div class="page">
    <p>CORS allows JS to customize method, header and body</p>
    <p>CORS JavaScript interfaces (e.g. XHR)</p>
    <p>var xhr=new XMLHttpRequest(); xhr.open(PATCH, http://b.com/r, true); xhr.setRequestHeader(X-Requested-With, XMLHttpRequest &quot;); xhr.withCredentials = true;</p>
    <p>xhr.send(any data);</p>
    <p>But this interface is very powerful, and may break CSRF defense of many websites.</p>
    <p>Document of a.com</p>
  </div>
  <div class="page">
    <p>Simple requests in CORS standard</p>
    <p>Two categories of requests  Simple request: can be sent directly  Non-simple request: not to cover this in this talk (refer to the paper)</p>
    <p>A simple request must satisfy all of the three conditions 1. Request method is HEAD, GET or POST. 2. Request headers are not customized, except for 9 whitelisted headers: Accept,</p>
    <p>Accept-Language, Content-Language, Content-Type, etc. 3. Content-Type header value is one of three specific values: text/plain,</p>
    <p>multipart/form-data, and application/x-form-uri-encoded.</p>
  </div>
  <div class="page">
    <p>Browser-side Issues: Overly Permissive Sending Permissions</p>
    <p>(4 categories of issues)</p>
  </div>
  <div class="page">
    <p>CORS relax send restrictions unintentionally, allowing malicious customization of HTTP headers and bodies  The relaxation can be exploited by attackers</p>
    <p>Problems Attacks P1. Overly permissive header values RCE attack on intranet servers P2. Few limitations on header size Infer cookie presence for ANY website P3. Overly flexible body values Attack MacOS AFP server P4. Few limitations on body format Exploit previously unexploitable CSRF</p>
    <p>Overly permissive request headers and bodies</p>
  </div>
  <div class="page">
    <p>P1. Overly permissive header values</p>
    <p>CORS allows JavaScript to modify 9 whitelisted headers.  CORS imposes few limitations on header values except Content-Type  eg. (, {, \x01,\x0b</p>
    <p>GET /api HTTP/1.1 Host: 192.168.1.1 Accept: (){:;}; /bin/rm rf /</p>
    <p>Victim Attackers website</p>
    <p>Intranet website(Shellshock vul)</p>
    <p>Affected browser(4/5):</p>
  </div>
  <div class="page">
    <p>P1. Overly permissive header values</p>
    <p>CORS restricts Content-Type to three specific values  But the restriction can be bypassed due to browsers implementation flaws.</p>
    <p>GET /api HTTP/1.1 Host: 192.168.1.1 Content-Type: text/plain ; %{(apache struts exploit)}</p>
    <p>Victim Attackers website</p>
    <p>Intranet website(Apache structs vul)</p>
    <p>Affected browsers(5/5):</p>
  </div>
  <div class="page">
    <p>Case study: obtain a shell on Intranet server by exploiting browsers</p>
    <p>InternetIntranet</p>
    <p>NAT/ Gateway AttackerDatabase</p>
    <p>File ServerWebsite</p>
    <p>Users</p>
  </div>
  <div class="page">
    <p>Demo: Obtain a shell on Intranet server by exploiting browsers(https://youtu.be/jO6hoXyXVqk) Victims browser in Intranet Attacker in Internet</p>
  </div>
  <div class="page">
    <p>P2. Few limitations on header size</p>
    <p>Both HTTP and CORS standards have no explicit limit on request header sizes.  Browsers header size limitation are more relaxed than servers.</p>
    <p>Case study 2: Remotely infer cookie presence for ANY website.</p>
  </div>
  <div class="page">
    <p>Remotely infer cookie presence for ANY website Step 1: Measure the header size limit of target server</p>
    <p>Health.com (Max header size limitation: S)</p>
    <p>Issue HTTP request with head size 1</p>
    <p>Attacker</p>
    <p>Victim</p>
  </div>
  <div class="page">
    <p>Remotely infer cookie presence for ANY website Step 1: Measure the header size limit of target server</p>
    <p>Health.com (Max header size limitation: S)</p>
    <p>Issue HTTP request with head size S+1</p>
    <p>Attacker</p>
    <p>Victim</p>
  </div>
  <div class="page">
    <p>Remotely infer cookie presence for ANY website</p>
    <p>Step 2: Send request from the victims browser with header</p>
    <p>size slightly smaller than the measured limit.</p>
    <p>Re qu</p>
    <p>est wi</p>
    <p>th he</p>
    <p>ad siz</p>
    <p>e S -1</p>
    <p>Victim visits the attackers website</p>
    <p>ad req</p>
    <p>ue st</p>
    <p>Victim</p>
    <p>Attacker</p>
    <p>Health.com</p>
    <p>(Max header size</p>
    <p>limitation: S)</p>
    <p>When Cookie is present, 400 Bad request is returned</p>
  </div>
  <div class="page">
    <p>Remotely infer cookie presence for ANY website</p>
    <p>Step 2: Send request from the victims browser with header size slightly smaller than the measured limit.</p>
    <p>Req uest</p>
    <p>with head</p>
    <p>size S-1</p>
    <p>Victim visits the attackers website</p>
    <p>TTP Rep</p>
    <p>ly Health.com (Max header size</p>
    <p>limitation: S)</p>
    <p>Victim</p>
    <p>Attacker</p>
    <p>When Cookie is not present, 200 OK is returned</p>
  </div>
  <div class="page">
    <p>Remotely infer cookie presence for ANY website</p>
    <p>Step 3: Infer the response status through timing channel.</p>
    <p>Req uest</p>
    <p>with hea</p>
    <p>d siz e S</p>
    <p>Victim visits the attackers website</p>
    <p>req ues</p>
    <p>t</p>
    <p>Victim</p>
    <p>Attacker</p>
    <p>Health.com (Max header size</p>
    <p>limitation: S)</p>
    <p>One general timing channel is response time.  In Chrome, Performance.getEntries() directly exposes it.</p>
  </div>
  <div class="page">
    <p>Remotely infer cookie presence for ANY website  The presence of a cookie can leak private information.  victims health conditions  Financial considerations  Political preferences</p>
    <p>Affected browsers(5/5):</p>
  </div>
  <div class="page">
    <p>P3. Overly flexible body values</p>
    <p>CORS impose no limitations on the values of request body  CORS allows JavaScript to construct ANY binary data in request body</p>
    <p>Public attacker site Victim 1. visit attacker site 2. send cross site request</p>
    <p>POST / HTTP/1.1 Host: 192.168.1.1</p>
    <p>MacOS AFP server</p>
    <p>Affected browsers(5/5):</p>
  </div>
  <div class="page">
    <p>Demo: exploiting MacOS built-in Apple file server to create local files(https://youtu.be/WXIy94prfvs)</p>
  </div>
  <div class="page">
    <p>Server-side issues: CORS misconfigurations (7 categories of issues)</p>
    <p>Inspired by these previous work: [1] James Kettle, Exploiting CORS misconfigurations for Bitcoins and bounties, AppSecUSA 2016 [2] Evan Johnson, Misconfigured CORS and why web appsec is not getting easier, AppSecUSA 2016 [3] Von Jens Mller, &quot;CORS misconfigurations on a large scale&quot;</p>
  </div>
  <div class="page">
    <p>CORS misconfigurations</p>
  </div>
  <div class="page">
    <p>How does CORS policy work? a.com Server Browser</p>
    <p>b.com Server</p>
    <p>Load JS GET request</p>
    <p>Origin: http://a.com</p>
    <p>Access-Control-Allow-Origin:http://a.com Access-Control-Allow-Credentials: true</p>
    <p>c.com Server</p>
    <p>Load JS</p>
    <p>GET request Origin: http://c.com</p>
    <p>Access-Control-Allow-Origin: http://a.com, http://c.com Access-Control-Allow-Credentials: true</p>
  </div>
  <div class="page">
    <p>How does CORS policy work? a.com Server Browser</p>
    <p>b.com Server</p>
    <p>Load JS GET request</p>
    <p>Origin: http://a.com</p>
    <p>Access-Control-Allow-Origin:http://a.com Access-Control-Allow-Credentials: true</p>
    <p>c.com Server</p>
    <p>Load JS</p>
    <p>GET request Origin: http://c.com</p>
    <p>Access-Control-Allow-Origin: http://c.com Access-Control-Allow-Credentials: true CORS Specification :</p>
    <p>Access-Control-Allow-Origin = single origin, null or *</p>
  </div>
  <div class="page">
    <p>P1: Origin reflection</p>
    <p>GET /api HTTP/1.1 Host: example.com Origin: http://attacker.com</p>
    <p>HTTP/1.1 200 OK Access-Control-Allow-Origin: http://attacker.com Access-Control-Allow-Credentials: true</p>
    <p>Browser example.com</p>
    <p>Serverattacker.com Server</p>
    <p>Load JS</p>
  </div>
  <div class="page">
    <p>P2: Validation mistakes</p>
    <p>if ($http_origin ~ http://(example.com|foo.com)) { add_header &quot;Access-Control-Allow-Origin&quot; $http_origin;</p>
    <p>}</p>
    <p>GET /api HTTP/1.1 Host: www. example.com Origin: http://example.com.evil.com</p>
    <p>HTTP/1.1 200 OK Access-Control-Allow-Origin: http:// example.com.evil.com Access-Control-Allow-Credentials: true</p>
    <p>$</p>
  </div>
  <div class="page">
    <p>P2: Validation mistakes</p>
    <p>A example of insecure CORS policy generation : if (reqOrigin.endswith(example.com) ) {</p>
    <p>respHeaders[Access-Control-Allow-Origin] = reqOrigin }</p>
    <p>GET /api HTTP/1.1</p>
    <p>Host: www.example.com</p>
    <p>Origin: http://attackexample.com</p>
    <p>HTTP/1.1 200 OK</p>
    <p>Access-Control-Allow-Origin: http://attackexample.com</p>
    <p>Access-Control-Allow-Credentials: true</p>
  </div>
  <div class="page">
    <p>P3: HTTPS trust HTTP  HTTPS provides confidentiality protection  Prevent man-in-the-middle(MITM) attackers</p>
    <p>When a HTTPS site configured to trust its HTTP site  eg. Access-Control-Allow-Origin: http://example.com</p>
    <p>A MITM attacker can first hijack HTTP site, and then steal secrets on HTTPS by issuing cross origin requests</p>
    <p>Network attacker</p>
  </div>
  <div class="page">
    <p>CORS measurement</p>
    <p>Target</p>
    <p>Extract</p>
    <p>Probe</p>
    <p>Statistic</p>
    <p>Alexa Top 50,000 websites</p>
    <p>Extract 97,199,966 subdomains  From Qihoo 360 network security lab</p>
    <p>Actively probe CORS configurations GET /api HTTP/1.1 Host: www.example.com Origin: example.com.attacker.com</p>
    <p>HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com.attacker.com Access-Control-Allow-Credentials: true</p>
  </div>
  <div class="page">
    <p>Measurement results</p>
    <p>481,589 subdomains configured CORS  132,476 subdomains(27.5%) have insecure configurations</p>
    <p>CORS Measurement</p>
    <p>Secure Insecure</p>
  </div>
  <div class="page">
    <p>Disclosure &amp; Response</p>
  </div>
  <div class="page">
    <p>Response by CORS standard organization  For cross origin sending attacks  Accepted some of our suggestions and made corresponding</p>
    <p>changes to the CORS specification  Added more restrictions on CORS simple requests, e.g. restricting</p>
    <p>header length, restricting access to unsafe ports  Acknowledged us in the CORS specification.</p>
    <p>For CORS misconfigurations issues  Misconfigured websites should fix those issues by themselves.  Agreed to add a security consideration section in the standard</p>
  </div>
  <div class="page">
    <p>Response by vendors</p>
    <p>Browsers  Chrome and Firefox: have blocked port 548 and 427, and are</p>
    <p>implementing specification changes.</p>
    <p>Safari: are testing those changes with a beta testing program.  Edge/IE: acknowledged our report.</p>
    <p>CORS frameworks and Websites  Tomcat(CVE-2018-8014 ), Yii and Go-CORS fixed  Some(e.g., nasdaq.com, sohu.com, mail.ru) have fixed the issues.</p>
    <p>We provide an open-source tool for automatic CORS configuration checking.</p>
  </div>
  <div class="page">
    <p>CORScanner (https://github.com/chenjj/CORScanner)</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>An empirical security study on CORS  Discovered multiple security issues in browsers and specs  4 categories of browser-side issues  7 categories of server-side issues</p>
    <p>Conducted a large-scale measurement  27.5% of CORS configured websites have insecure CORS</p>
    <p>configuration  Proposed mitigations  Some of them have been adopted by web standard and major</p>
    <p>browsers.</p>
  </div>
  <div class="page">
    <p>Thank you! Twitter: whucjj</p>
    <p>Blog: https://www.jianjunchen.com</p>
  </div>
</Presentation>
