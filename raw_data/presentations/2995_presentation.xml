<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>CertiKOS: An Extensible Architecture for Building Certified Concurrent OS Kernels</p>
    <p>Ronghui Gu, Zhong Shao, Hao Chen, Xiongnan (Newman) Wu, Jieung Kim, Vilhelm Sjberg, David Costanzo</p>
    <p>Yale University</p>
  </div>
  <div class="page">
    <p>OS Kernel</p>
  </div>
  <div class="page">
    <p>OS Kernel error</p>
  </div>
  <div class="page">
    <p>Complete formal verification is the only known way to guarantee that a system is free of programming errors.</p>
    <p>only</p>
    <p>error seL4 [SOSP09]</p>
  </div>
  <div class="page">
    <p>seL4 [SOSP09]</p>
    <p>Verve [PLDI10]</p>
    <p>Ironclad [OSDI14]</p>
    <p>mCertiKOS [POPL15]</p>
    <p>FSCQ [SOSP15]</p>
    <p>CoGENT [ASPLOS16]</p>
  </div>
  <div class="page">
    <p>seL4 [SOSP09]</p>
    <p>mCertiKOS [POPL15]</p>
    <p>FSCQ [SOSP15]</p>
    <p>CoGENT [ASPLOS16]</p>
    <p>verified sequential kernels</p>
    <p>Verve [PLDI10]</p>
    <p>Ironclad [OSDI14]</p>
  </div>
  <div class="page">
    <p>seL4 [SOSP09]</p>
    <p>mCertiKOS [POPL15]</p>
    <p>FSCQ [SOSP15]</p>
    <p>CoGENT [ASPLOS16]</p>
    <p>verified software stacks</p>
    <p>Ironclad [OSDI14]</p>
    <p>Verve [PLDI10]</p>
  </div>
  <div class="page">
    <p>seL4 [SOSP09]</p>
    <p>mCertiKOS [POPL15]</p>
    <p>FSCQ [SOSP15]  verified sequential file systems</p>
    <p>CoGENT [ASPLOS16]</p>
    <p>Ironclad [OSDI14]</p>
    <p>Verve [PLDI10]</p>
  </div>
  <div class="page">
    <p>seL4 [SOSP09]</p>
    <p>Verve [PLDI10]</p>
    <p>Ironclad [OSDI14]</p>
    <p>mCertiKOS [POPL15]</p>
    <p>CoGENT</p>
    <p>shared-memory concurrency?</p>
  </div>
  <div class="page">
    <p>seL4 [SOSP09]</p>
    <p>Verve [PLDI10]</p>
    <p>Ironclad [OSDI14]</p>
    <p>mCertiKOS [POPL15]</p>
    <p>FSCQ [SOSP15]</p>
    <p>CoGENT [ASPLOS16]</p>
    <p>shared-memory concurrency?</p>
  </div>
  <div class="page">
    <p>seL4 [SOSP09]</p>
    <p>Proofs about concurrent programs are hard, much harder than proofs about sequential programs.</p>
    <p>hard</p>
  </div>
  <div class="page">
    <p>seL4 [SOSP09]</p>
    <p>Verve [PLDI10]</p>
    <p>Ironclad [OSDI14]</p>
    <p>mCertiKOS [POPL15]</p>
    <p>FSCQ [SOSP15]</p>
    <p>CoGENT [ASPLOS16]</p>
    <p>hard</p>
  </div>
  <div class="page">
    <p>[]multiprocessor support, which may require global changes []</p>
    <p>global changes</p>
    <p>FSCQ [SOSP15]</p>
    <p>multiprocessor</p>
    <p>hard</p>
  </div>
  <div class="page">
    <p>[]multiprocessor support, which may require global changes []</p>
    <p>global changes FSCQ [SOSP15]</p>
    <p>multiprocessor</p>
    <p>hard</p>
  </div>
  <div class="page">
    <p>multiprocessor</p>
    <p>I/O concurrency</p>
    <p>mult i-thre</p>
    <p>ad</p>
    <p>global changes hard</p>
    <p>I/O concurrency</p>
    <p>mult i-thre</p>
    <p>ad</p>
  </div>
  <div class="page">
    <p>multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes hard</p>
    <p>multiprocessor</p>
    <p>I/O concurrency</p>
    <p>mult i-thre</p>
    <p>ad</p>
  </div>
  <div class="page">
    <p>multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes hard</p>
    <p>multiprocessor</p>
    <p>I/O concurrency</p>
    <p>mult i-thre</p>
    <p>ad</p>
    <p>Big Lock</p>
  </div>
  <div class="page">
    <p>multiprocessor</p>
    <p>I/O concurrency</p>
    <p>mult i-thre</p>
    <p>ad fine-grained lock</p>
    <p>fine-grained lock fine-grained lock</p>
    <p>fine-grained lock multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes hard</p>
  </div>
  <div class="page">
    <p>the verification to a kernel version with fine-grained locking will far exceed the cost already paid for verifying the single core version.</p>
    <p>fine-grained lock</p>
    <p>multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes hardS.Peters et al.</p>
    <p>[APSys15]</p>
  </div>
  <div class="page">
    <p>S.Peters et al. [APSys15]</p>
    <p>fine-grained lock multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes hard</p>
    <p>the verification to a kernel version with fine-grained locking will far exceed the cost already paid for verifying the single core version.</p>
  </div>
  <div class="page">
    <p>What to prove?</p>
    <p>functional correctness</p>
    <p>liveness system calls will eventually return</p>
    <p>fine-grained lock multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes hard</p>
  </div>
  <div class="page">
    <p>liveness fine-grained lock multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes hardconcurrent OS kernel</p>
  </div>
  <div class="page">
    <p>concurrent OS kernel</p>
    <p>C</p>
    <p>AsmAsm</p>
    <p>Compiler liveness fine-grained lock multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes hard</p>
  </div>
  <div class="page">
    <p>liveness fine-grained lock multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes hard</p>
    <p>asm&amp;C compiler</p>
    <p>cost</p>
  </div>
  <div class="page">
    <p>formal reasoning about concurrency seems to be still in the early stages[] Addressing these basic questions is critical to make progress on OS verification.</p>
    <p>liveness fine-grained lock multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes hard</p>
    <p>asm&amp;C compiler cost</p>
    <p>solves all these challenges</p>
  </div>
  <div class="page">
    <p>formal reasoning about concurrency seems to be still in the early stages[] Addressing these basic questions is critical to make progress on OS verification.</p>
    <p>CertiKOS liveness fine-grained lock multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes hard</p>
    <p>asm&amp;C compiler cost</p>
    <p>solves all these challenges</p>
  </div>
  <div class="page">
    <p>mC2, the first formally verified concurrent OS kernel with fine-grained locks.</p>
    <p>CertiKOS</p>
    <p>mC2</p>
    <p>liveness fine-grained lock multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes hard</p>
    <p>asm&amp;C compiler</p>
    <p>cost</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>CertiKOS mC2</p>
    <p>liveness</p>
    <p>fine-grained lock</p>
    <p>multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes hard</p>
    <p>asm&amp;C compiler</p>
    <p>cost</p>
    <p>mC2, the first formally verified concurrent OS kernel with fine-grained locks.</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>CertiKOS mC2</p>
    <p>liveness</p>
    <p>fine-grained lock</p>
    <p>multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes hard</p>
    <p>asm&amp;C compiler</p>
    <p>cost</p>
    <p>both functional correctness and liveness</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>CertiKOS mC2</p>
    <p>liveness fine-grained lock</p>
    <p>multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes hard</p>
    <p>asm&amp;C compiler</p>
    <p>cost</p>
    <p>contributions</p>
    <p>both functional correctness and liveness</p>
  </div>
  <div class="page">
    <p>CertiKOS</p>
    <p>certified concurrent layers</p>
    <p>mC2</p>
    <p>liveness fine-grained lock</p>
    <p>multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes hard</p>
    <p>asm&amp;C compiler</p>
    <p>cost</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>CertiKOS mC2</p>
    <p>liveness fine-grained lock</p>
    <p>multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes hard</p>
    <p>asm&amp;C compiler</p>
    <p>cost</p>
    <p>reuses sequential verification techniques.</p>
    <p>contributions</p>
    <p>certified concurrent layers</p>
  </div>
  <div class="page">
    <p>CertiKOS mC2</p>
    <p>liveness fine-grained lock</p>
    <p>multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>global changes</p>
    <p>hard</p>
    <p>asm&amp;C compiler</p>
    <p>cost</p>
    <p>contributions</p>
    <p>reuses sequential verification techniques.</p>
    <p>certified concurrent layers</p>
  </div>
  <div class="page">
    <p>CertiKOS mC2</p>
    <p>liveness fine-grained lock</p>
    <p>multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>reuse of techs</p>
    <p>hard</p>
    <p>asm&amp;C compiler</p>
    <p>cost</p>
    <p>handles all 3 kinds of concurrency</p>
    <p>contributions</p>
    <p>certified concurrent layers</p>
  </div>
  <div class="page">
    <p>CertiKOS mC2</p>
    <p>liveness fine-grained lock</p>
    <p>multiprocessor</p>
    <p>I/O concurrency multi-thread</p>
    <p>reuse of techs</p>
    <p>hard</p>
    <p>asm&amp;C compiler</p>
    <p>cost</p>
    <p>contributions</p>
    <p>handles all 3 kinds of concurrency</p>
    <p>certified concurrent layers</p>
  </div>
  <div class="page">
    <p>CertiKOS mC2</p>
    <p>liveness fine-grained lock</p>
    <p>mix of 3 reuse of techs</p>
    <p>hard</p>
    <p>asm&amp;C compiler</p>
    <p>cost</p>
    <p>C</p>
    <p>Asm</p>
    <p>contributions</p>
    <p>LOC</p>
  </div>
  <div class="page">
    <p>CertiKOS hard</p>
    <p>asm&amp;C</p>
    <p>compiler</p>
    <p>cost</p>
    <p>mC2</p>
    <p>liveness fine-grained lock</p>
    <p>mix of 3 reuse of techs</p>
    <p>C</p>
    <p>Asm</p>
    <p>LOC</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>CertiKOS hard</p>
    <p>compiler</p>
    <p>cost</p>
    <p>asm&amp;C</p>
    <p>mC2</p>
    <p>liveness fine-grained lock</p>
    <p>mix of 3 reuse of techs C</p>
    <p>AsmAsm</p>
    <p>CompCertX</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>CertiKOS hard</p>
    <p>compiler</p>
    <p>cost</p>
    <p>C</p>
    <p>AsmAsm</p>
    <p>CompCertXasm&amp;C</p>
    <p>mC2</p>
    <p>liveness fine-grained lock</p>
    <p>mix of 3 reuse of techs 6100</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>CertiKOS hard</p>
    <p>cost</p>
    <p>C Asm asm&amp;C</p>
    <p>mC2</p>
    <p>liveness fine-grained lock</p>
    <p>mix of 3 reuse of techs</p>
    <p>CompCertX model</p>
    <p>checking SMT</p>
    <p>solver Coq</p>
    <p>machine-checkable proof</p>
    <p>verified</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>CertiKOS hard</p>
    <p>cost</p>
    <p>asm&amp;C</p>
    <p>mC2</p>
    <p>liveness fine-grained lock</p>
    <p>mix of 3 reuse of techs</p>
    <p>CompCertX</p>
    <p>machine-checkable proof AsmAsmAsm</p>
    <p>C Asm</p>
    <p>verified</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>CertiKOS hard</p>
    <p>cost</p>
    <p>asm&amp;C</p>
    <p>mC2</p>
    <p>liveness fine-grained lock</p>
    <p>mix of 3 reuse of techs</p>
    <p>CompCertX</p>
    <p>machine-checkable proof AsmAsmAsm executable</p>
    <p>C Asm</p>
    <p>verified</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>CertiKOS hard</p>
    <p>cost</p>
    <p>asm&amp;C</p>
    <p>mC2</p>
    <p>liveness fine-grained lock</p>
    <p>mix of 3 reuse of techs</p>
    <p>CompCertX</p>
    <p>machine-checkable proof AsmAsmAsm executable</p>
    <p>C Asm</p>
    <p>verified certified</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>CertiKOS hard</p>
    <p>cost</p>
    <p>CompCertX asm&amp;C</p>
    <p>mC2</p>
    <p>liveness fine-grained lock</p>
    <p>mix of 3 reuse of techs</p>
    <p>certified</p>
    <p>mCertiKOS [POPL15]</p>
    <p>+ extensions 0.5 py + device [PLDI16]</p>
    <p>+ concurrency 2 py</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>CertiKOS</p>
    <p>cost</p>
    <p>extensibility CompCertX asm&amp;C</p>
    <p>mC2</p>
    <p>liveness fine-grained lock</p>
    <p>mix of 3 reuse of techs</p>
    <p>certified</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>certified concurrent layers</p>
    <p>cost</p>
    <p>extensibility CompCertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>new technical contributions</p>
    <p>certified</p>
    <p>multicore machine lifting</p>
    <p>logical log + hardware scheduler + environment context</p>
    <p>push/pull model</p>
  </div>
  <div class="page">
    <p>certified concurrent layerssequential</p>
    <p>cost</p>
    <p>extensibility CompCertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>contributions</p>
    <p>certified</p>
    <p>certified objects</p>
    <p>specification of modules to trust</p>
  </div>
  <div class="page">
    <p>certified concurrent layerssequential</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contribution</p>
    <p>certified</p>
  </div>
  <div class="page">
    <p>certified concurrent layerssequential</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contribution</p>
    <p>certified</p>
    <p>abs-state</p>
  </div>
  <div class="page">
    <p>certified concurrent layerssequential</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contribution</p>
    <p>certified</p>
    <p>primitives</p>
    <p>abs-state</p>
  </div>
  <div class="page">
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contribution</p>
    <p>certified</p>
    <p>memory</p>
    <p>code</p>
  </div>
  <div class="page">
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contribution</p>
    <p>certified</p>
  </div>
  <div class="page">
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contribution</p>
    <p>certified</p>
    <p>implementation</p>
  </div>
  <div class="page">
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contribution</p>
    <p>certified</p>
    <p>specification</p>
    <p>implementation</p>
  </div>
  <div class="page">
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contribution</p>
    <p>certified</p>
    <p>implementation</p>
    <p>specification</p>
  </div>
  <div class="page">
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contribution</p>
    <p>certified</p>
    <p>simulation proof</p>
    <p>specification</p>
    <p>implementation</p>
  </div>
  <div class="page">
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contribution</p>
    <p>certified</p>
    <p>kernelverify a sequential [POPL15]</p>
  </div>
  <div class="page">
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contribution</p>
    <p>certified</p>
    <p>kernel</p>
    <p>MM</p>
    <p>TM</p>
    <p>PM</p>
    <p>Trap</p>
    <p>code</p>
    <p>seq machine</p>
  </div>
  <div class="page">
    <p>TM</p>
    <p>PM</p>
    <p>Trap</p>
    <p>MM</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contribution</p>
    <p>certified</p>
    <p>seq machine</p>
  </div>
  <div class="page">
    <p>mem</p>
    <p>MM</p>
    <p>TM</p>
    <p>PM</p>
    <p>Trap</p>
    <p>memory management</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contribution</p>
    <p>certified</p>
    <p>seq machine</p>
  </div>
  <div class="page">
    <p>Trap</p>
    <p>PM</p>
    <p>MM</p>
    <p>TM</p>
    <p>TM</p>
    <p>PM</p>
    <p>Trap</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contribution</p>
    <p>certified</p>
    <p>seq machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>proc</p>
    <p>trap</p>
  </div>
  <div class="page">
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contribution</p>
    <p>certified</p>
    <p>Trap</p>
    <p>PM</p>
    <p>TM</p>
    <p>mem</p>
    <p>thread</p>
    <p>proc</p>
    <p>trap</p>
    <p>seq machine</p>
    <p>verified sequential kernel MM</p>
  </div>
  <div class="page">
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contribution</p>
    <p>certified mem</p>
    <p>thread</p>
    <p>proc</p>
    <p>trap</p>
    <p>seq machine</p>
  </div>
  <div class="page">
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contribution</p>
    <p>certified mem</p>
    <p>thread</p>
    <p>proc</p>
    <p>trap</p>
    <p>seq machine</p>
  </div>
  <div class="page">
    <p>mem</p>
    <p>thread</p>
    <p>proc</p>
    <p>trap</p>
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>contributions</p>
    <p>certified seq machine</p>
  </div>
  <div class="page">
    <p>Trap</p>
    <p>PM</p>
    <p>MM</p>
    <p>TM</p>
    <p>mem</p>
    <p>thread</p>
    <p>proc</p>
    <p>trap</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>certified seq machine</p>
    <p>VM</p>
    <p>cost</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>Trap</p>
    <p>PM</p>
    <p>MM</p>
    <p>TM</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>certified seq machine</p>
    <p>VM</p>
    <p>cost</p>
    <p>mem</p>
    <p>thread</p>
    <p>proc</p>
    <p>trap</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>mem</p>
    <p>thread</p>
    <p>proc</p>
    <p>Trap</p>
    <p>PM</p>
    <p>MM</p>
    <p>TM</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>certified seq machine</p>
    <p>VM</p>
    <p>cost</p>
    <p>trap</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>Trap</p>
    <p>PM</p>
    <p>MM</p>
    <p>TM</p>
    <p>trap</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>certified seq machine</p>
    <p>VM</p>
    <p>VM</p>
    <p>virt</p>
    <p>cost</p>
    <p>mem</p>
    <p>thread</p>
    <p>proc</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>Trap</p>
    <p>PM</p>
    <p>MM</p>
    <p>TM</p>
    <p>verified hypervisor</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>certified seq machine</p>
    <p>VM</p>
    <p>cost</p>
    <p>trap</p>
    <p>virt</p>
    <p>mem</p>
    <p>thread</p>
    <p>proc</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C 3 concurrency</p>
    <p>certified extensibility is the key to support</p>
    <p>concurrency</p>
    <p>seq machine</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>mem</p>
    <p>thread</p>
    <p>proc</p>
    <p>cost</p>
    <p>CompcertX asm&amp;C</p>
    <p>mix of 3</p>
    <p>certified</p>
    <p>trap</p>
    <p>virt</p>
    <p>multicore machine</p>
    <p>seq machine</p>
    <p>contributions support concurrency</p>
    <p>extensibility</p>
  </div>
  <div class="page">
    <p>mem</p>
    <p>thread</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>multicore machine</p>
    <p>CPU-local machine 1 1</p>
    <p>cost</p>
    <p>CompcertX asm&amp;C</p>
    <p>mix of 3</p>
    <p>certified</p>
    <p>reuse</p>
    <p>contributions</p>
    <p>extensibility</p>
  </div>
  <div class="page">
    <p>mem</p>
    <p>thread</p>
    <p>proc</p>
    <p>cost</p>
    <p>CompcertX asm&amp;C</p>
    <p>mix of 3</p>
    <p>certified</p>
    <p>multicore machine</p>
    <p>CPU-local machine 1 1</p>
    <p>trap</p>
    <p>virt</p>
    <p>spin-lock</p>
    <p>reuse</p>
    <p>contributions</p>
    <p>extensibility</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>CompcertX asm&amp;C</p>
    <p>mix of 3</p>
    <p>certified</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>reuse</p>
    <p>contributions</p>
    <p>extensibility</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>CompcertX asm&amp;C</p>
    <p>mC2</p>
    <p>mix of 3</p>
    <p>certified</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>reuse</p>
    <p>contributions</p>
    <p>extensibility</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contributions</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>certified concurrent layers</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>local objects</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>certified concurrent layers</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>k</p>
    <p>atomic objects</p>
    <p>logical log multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>certified concurrent layers</p>
    <p>a sequence of events</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>certified concurrent layers</p>
    <p>k</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>certified concurrent layers</p>
    <p>k</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>certified concurrent layers</p>
    <p>k</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>share</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>k</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C</p>
    <p>fine-grained lock</p>
    <p>mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>k k</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C</p>
    <p>fine-grained lock</p>
    <p>mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
  </div>
  <div class="page">
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>step 0: raw x86 multicore model</p>
    <p>CPU0</p>
    <p>CPU1</p>
    <p>atom</p>
    <p>private</p>
    <p>share</p>
    <p>atom</p>
    <p>assume sequential consistency</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>CPU0</p>
    <p>CPU1</p>
    <p>atom</p>
    <p>private</p>
    <p>share</p>
    <p>atom</p>
    <p>non-determinism step 0: raw x86 multicore model</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>CPU0</p>
    <p>CPU1</p>
    <p>atom</p>
    <p>private</p>
    <p>share</p>
    <p>atom</p>
    <p>non-determinism step 0: raw x86 multicore model</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>CPU0</p>
    <p>CPU1</p>
    <p>atom</p>
    <p>private</p>
    <p>share</p>
    <p>atom</p>
    <p>non-determinism step 0: raw x86 multicore model</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>CPU0</p>
    <p>CPU1</p>
    <p>atom</p>
    <p>private</p>
    <p>share</p>
    <p>atom</p>
    <p>non-determinism</p>
    <p>oracle</p>
    <p>hardware scheduler step 0: raw x86 multicore model</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>CPU0</p>
    <p>CPU1</p>
    <p>atom</p>
    <p>private</p>
    <p>share</p>
    <p>atom</p>
    <p>non-determinism</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>step 1: hardware scheduler purely logical</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>CPU0</p>
    <p>CPU1</p>
    <p>atom</p>
    <p>private</p>
    <p>share</p>
    <p>atom</p>
    <p>non-determinism</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>step 1: hardware scheduler purely logical</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virtnon-determinism</p>
    <p>?8</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>step 1: hardware scheduler purely logical</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>machine with hardware scheduler8</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>step 1: hardware scheduler</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>machine with hardware scheduler</p>
    <p>share</p>
    <p>shared mem</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>CPU0</p>
    <p>step 2: push/pull model</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>machine with hardware scheduler</p>
    <p>CPU0 share</p>
    <p>shared mem</p>
    <p>pull</p>
    <p>logical copy</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>step 2: push/pull model</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>machine with hardware scheduler</p>
    <p>sharepull</p>
    <p>shared mem</p>
    <p>logical copy</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>CPU0</p>
    <p>step 2: push/pull model</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>machine with hardware scheduler</p>
    <p>sharepull</p>
    <p>shared mem</p>
    <p>logical copy</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>CPU0</p>
    <p>step 2: push/pull model</p>
    <p>CPU1 pull</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>machine with hardware scheduler</p>
    <p>share</p>
    <p>shared mem</p>
    <p>pull</p>
    <p>logical copy</p>
    <p>push</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>CPU0</p>
    <p>step 2: push/pull model</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>machine with hardware scheduler</p>
    <p>share</p>
    <p>shared mem</p>
    <p>pull</p>
    <p>logical copy</p>
    <p>push</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>CPU0</p>
    <p>step 2: push/pull model</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>machine with hardware scheduler</p>
    <p>machine with local copy</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>machine with hardware scheduler</p>
    <p>machine with local copy</p>
    <p>CPU0</p>
    <p>CPU1</p>
    <p>atom</p>
    <p>private</p>
    <p>private</p>
    <p>atom</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>step 3: per-CPU machine</p>
  </div>
  <div class="page">
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>machine with hardware scheduler</p>
    <p>machine with local copy</p>
    <p>CPU0</p>
    <p>CPU1</p>
    <p>atom</p>
    <p>private</p>
    <p>private</p>
    <p>atom</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>step 3: per-CPU machine</p>
  </div>
  <div class="page">
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>CPU1 private atom</p>
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>machine with hardware scheduler</p>
    <p>machine with local copy</p>
    <p>CPU0 atom private</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>step 3: per-CPU machine</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>machine with hardware scheduler</p>
    <p>machine with local copy</p>
    <p>CPU0 atom private</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>step 3: per-CPU machine</p>
    <p>environment context</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>machine with hardware scheduler</p>
    <p>CPU i machine CPU j machine</p>
    <p>machine with local copy</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>machine with hardware scheduler</p>
    <p>CPU i machine CPU j machine</p>
    <p>machine with local copy</p>
    <p>share privateatom pull push</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>step 4: remove unnecessary interleaving</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>machine with hardware scheduler</p>
    <p>CPU i machine CPU j machine</p>
    <p>machine with local copy</p>
    <p>shuffle</p>
    <p>share privateatom pull push</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>step 4: remove unnecessary interleaving</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contributions</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>machine with hardware scheduler</p>
    <p>CPU i machine CPU j machine</p>
    <p>machine with local copy</p>
    <p>merge</p>
    <p>share privateatom pull push</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
    <p>step 4: remove unnecessary interleaving</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contributions</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>machine with hardware scheduler</p>
    <p>CPU i machine CPU j machine</p>
    <p>machine with local copy</p>
    <p>atom</p>
    <p>reuse</p>
    <p>be modeled as a sequence of shared memory access events, which is sequentially</p>
    <p>consistent. Therefore, by showing that the cCertiKOS kernel is data-race free, we</p>
    <p>have that this sequential consistency assumption is valid.</p>
    <p>As a first step toward abstracting away the low-level details of concurrent CPUs, we</p>
    <p>introduce a new partial machine (hs) configured with a hardware scheduler (Ehs) that specifies a particular interleaving for an execution. This results in a deterministic</p>
    <p>machine model. To take a program from x86mc and run it on top of hs, we insert a</p>
    <p>logical switch point (denoted as ) before each assembly instruction. Each switch point switch pointyields to the hardware scheduler and generates a switch event</p>
    <p>c  hs, which is a local step hs.. Then, the machine has to take an environment step to query the hardware scheduler and get the CPU id c to execute next. This decision made by E</p>
    <p>hs</p>
    <p>is stored in the log as a switch event hs  c. The previous example on x86mc can be simulated by the following Ehs:</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1CPU0</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>atom1</p>
    <p>private1 atom2</p>
    <p>shared1</p>
    <p>CPU1</p>
    <p>shared1</p>
    <p>private2</p>
    <p>shared1CPU0 pull1 push1</p>
    <p>shared mem at i</p>
    <p>shared1</p>
    <p>invalid</p>
    <p>log</p>
    <p>x y z invalid</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1 shared1</p>
    <p>atom1 shared1 CPU0 pull1 push1shared1</p>
    <p>shuffle</p>
    <p>atom1 shared1CPU0 pull1 push1shared1</p>
    <p>merge adjacent</p>
    <p>CPU0</p>
    <p>hardware scheduling</p>
    <p>switch event</p>
    <p>returned events</p>
    <p>...</p>
    <p>pull1 push1</p>
    <p>pull1 push1</p>
    <p>We write (c  c) as an abbreviation of (c  hs)(hs  c). Thus, the log recorded by this execution is as follows:</p>
    <p>(0  0)(0.atom1)(0  1)(1  1)(1  1)(1.atom2)(1  0) (0.pull1)(0  0)(0  0)(0  0)(0.push1)(0  1)</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contributions</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contributions</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>specificationacq-lock</p>
    <p>logical copysafely</p>
    <p>pull</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>specificationacq-lock</p>
    <p>logical copysafely</p>
    <p>pull pull will</p>
    <p>eventually return</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>specificationacq-lock</p>
    <p>logical copymutual</p>
    <p>exclusion liveness</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>ticket lock</p>
    <p>void acq_lock (uint i) {</p>
    <p>uint t = FAI_ticket (i);</p>
    <p>while ( get_now (i) != t) { }</p>
    <p>pull (i); }</p>
    <p>FAI_ticket</p>
    <p>get_now</p>
    <p>pull</p>
    <p>FAI ticket</p>
    <p>mutual exclusion liveness+</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>void acq_lock (uint i) {</p>
    <p>uint t = FAI_ticket (i);</p>
    <p>while ( get_now (i) != t) { }</p>
    <p>pull (i); }</p>
    <p>FAI_ticket</p>
    <p>get_now</p>
    <p>pull</p>
    <p>FAI ticket</p>
    <p>get now</p>
    <p>mutual exclusion liveness+</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>void acq_lock (uint i) {</p>
    <p>uint t = FAI_ticket (i);</p>
    <p>while ( get_now (i) != t) { }</p>
    <p>pull (i); }</p>
    <p>FAI_ticket</p>
    <p>pull</p>
    <p>FAI ticket</p>
    <p>get now</p>
    <p>get_now get now</p>
    <p>mutual exclusion liveness+</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>void acq_lock (uint i) {</p>
    <p>uint t = FAI_ticket (i);</p>
    <p>while ( get_now (i) != t) { }</p>
    <p>pull (i); }</p>
    <p>FAI_ticket</p>
    <p>pull</p>
    <p>FAI ticket</p>
    <p>get now</p>
    <p>get_now</p>
    <p>get now</p>
    <p>pull</p>
    <p>mutual exclusion liveness+</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>void acq_lock (uint i) {</p>
    <p>uint t = FAI_ticket (i);</p>
    <p>while ( get_now (i) != t) { }</p>
    <p>pull (i); }</p>
    <p>FAI_ticket</p>
    <p>pull</p>
    <p>FAI ticket</p>
    <p>get now</p>
    <p>get_now</p>
    <p>get now pull</p>
    <p>mutual exclusion liveness+</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>void acq_lock (uint i) {</p>
    <p>uint t = FAI_ticket (i);</p>
    <p>while ( get_now (i) != t) { }</p>
    <p>pull (i); }</p>
    <p>FAI_ticket</p>
    <p>pull</p>
    <p>FAI ticket</p>
    <p>get now</p>
    <p>get_now</p>
    <p>get now pull</p>
    <p>mutual exclusion</p>
    <p>liveness+</p>
    <p>unique t</p>
    <p>#CPUs &lt; max_uint</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>void acq_lock (uint i) {</p>
    <p>uint t = FAI_ticket (i);</p>
    <p>while ( get_now (i) != t) { }</p>
    <p>pull (i); }</p>
    <p>FAI_ticket</p>
    <p>pull</p>
    <p>FAI ticket</p>
    <p>get now</p>
    <p>get_now</p>
    <p>get now pull</p>
    <p>contributions</p>
    <p>liveness</p>
    <p>} bounded</p>
    <p>mutual exclusion liveness+</p>
    <p>#CPUs is bounded a fair scheduler lock holders will release lock</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>liveness</p>
    <p>acq_lock</p>
    <p>acq_lock acq lock</p>
    <p>contributions</p>
    <p>FAI ticket</p>
    <p>get now</p>
    <p>get now pull</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>acq_lock</p>
    <p>acq_lock acq lock</p>
    <p>FAI ticket</p>
    <p>get now</p>
    <p>get now pull</p>
    <p>liveness</p>
    <p>contributions</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contributions</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contributions</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>enq</p>
    <p>local memory</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>enq</p>
    <p>local memory</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>enq</p>
    <p>logical copy</p>
    <p>shared memory</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>enq</p>
    <p>logical copy</p>
    <p>shared memory</p>
    <p>acq lock</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>enq</p>
    <p>logical copy</p>
    <p>shared memory</p>
    <p>acq lock</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>enq</p>
    <p>logical copy</p>
    <p>shared memory</p>
    <p>acq lock</p>
    <p>rel lock</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>enq</p>
    <p>shared memory</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>enq</p>
    <p>shared memory</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>contributions</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility</p>
    <p>mix of 3</p>
    <p>certified</p>
    <p>contributions</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virtvoid yield () {</p>
    <p>uint t = tid();  (t, rdq());</p>
    <p>uint s = (rdq());  (t, s)</p>
    <p>}</p>
    <p>enq</p>
    <p>deq</p>
    <p>context_switchCompcertX asm&amp;C</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX asm&amp;C</p>
    <p>mix of 3</p>
    <p>certified</p>
    <p>contributions</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virtvoid yield () {</p>
    <p>uint t = tid();  (t, rdq());</p>
    <p>uint s = (rdq());  (t, s)</p>
    <p>}</p>
    <p>enq</p>
    <p>deq</p>
    <p>context_switch</p>
  </div>
  <div class="page">
    <p>cost</p>
    <p>extensibility CompcertX</p>
    <p>asm&amp;C mix of 3</p>
    <p>certified</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>yield</p>
    <p>sleep</p>
    <p>software schedulercontribution</p>
    <p>wakeup</p>
  </div>
  <div class="page">
    <p>extensibility</p>
    <p>mix of 3</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>CompcertX asm&amp;C</p>
  </div>
  <div class="page">
    <p>extensibility</p>
    <p>mix of 3</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>CompcertX asm&amp;C</p>
    <p>IPC</p>
    <p>CV</p>
  </div>
  <div class="page">
    <p>extensibility</p>
    <p>mix of 3</p>
    <p>Coq &amp;machine checkable</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>CompcertX asm&amp;C</p>
    <p>evaluation: proof effort for concurrency(LOC)</p>
    <p>top spec: 450 machine model: 943 intermediate spec: 40K proof(concurrency): 50K</p>
  </div>
  <div class="page">
    <p>extensibility</p>
    <p>mix of 3</p>
    <p>Coq &amp;machine checkable</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>CompcertX asm&amp;C</p>
    <p>mC2 is comparable with kvmmC2</p>
    <p>evaluation: performance</p>
  </div>
  <div class="page">
    <p>extensibility</p>
    <p>mix of 3</p>
    <p>Coq &amp;machine checkable</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>CompcertX asm&amp;C</p>
    <p>mC2 is comparable with kvmmC2</p>
    <p>evaluation: performance</p>
  </div>
  <div class="page">
    <p>extensibility</p>
    <p>mix of 3</p>
    <p>Coq &amp;machine checkable</p>
    <p>contribution</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>CompcertX asm&amp;C</p>
    <p>limitations &amp; future work</p>
    <p>bootloader</p>
    <p>assembler of CompCert</p>
    <p>sequential consistency machine model is in the TCB</p>
    <p>file system &amp; network stack</p>
  </div>
  <div class="page">
    <p>extensibility</p>
    <p>mix of 3</p>
    <p>Coq &amp;machine checkable</p>
    <p>contributions</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>CompcertX asm&amp;C CertiKOS</p>
  </div>
  <div class="page">
    <p>extensibility</p>
    <p>mC2</p>
    <p>mix of 3 reuse</p>
    <p>Coq &amp;machine checkable</p>
    <p>contributions</p>
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>fine-grained lock liveness</p>
    <p>CompcertX asm&amp;C CertiKOS</p>
  </div>
  <div class="page">
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>CertiKOS</p>
    <p>extensibility</p>
    <p>mix of 3</p>
    <p>Coq &amp;machine checkable</p>
    <p>contributions</p>
    <p>CompcertX asm&amp;C</p>
    <p>the first formally verified concurrent OS kernel.</p>
    <p>mC2</p>
  </div>
  <div class="page">
    <p>multicore machine</p>
    <p>CPU-local machine</p>
    <p>thread-local machine</p>
    <p>mem</p>
    <p>thread</p>
    <p>spin-lock</p>
    <p>proc</p>
    <p>trap</p>
    <p>virt</p>
    <p>extensibility</p>
    <p>mix of 3</p>
    <p>Coq &amp;machine checkable</p>
    <p>contributions</p>
    <p>CompcertX asm&amp;C</p>
    <p>CertiKOS certified concurrent layers</p>
    <p>multicore machine lifting</p>
    <p>logical log + hardware scheduler + environment context</p>
    <p>push/pull model</p>
    <p>new technical contributions</p>
  </div>
</Presentation>
