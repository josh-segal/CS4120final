<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Towards Efficient Heap Overflow Discovery</p>
    <p>Xiangkun Jia, Chao Zhang, Purui Su, Yi Yang, Huafeng Huang, Dengguo Feng</p>
    <p>TCA/SKLCS lab, Institute of Software, Chinese Academy of Sciences, University of Chinese Academy of Sciences,</p>
    <p>Institute for Network Science and Cyberspace, Tsinghua University</p>
  </div>
  <div class="page">
    <p>Contents</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Stack overflow exploits are rare  Defenses are deployed, e.g., ASLR, shadow stack, Stackguard, StackArmor, etc.</p>
    <p>Heap overflows vulnerabilities become popular and realistic  Attack techniques are developing, e.g., dword shoot, heap spray, heap fengshui, etc.</p>
    <p>Motivation</p>
    <p>Microsoft RCE exploitation trend (2008-2014) Heap overflow vulnerabilities in NVD (2014-2017)</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Runtime detections are passive</p>
    <p>- rely on triggering vuls</p>
    <p>Fuzzers are sometimes blind</p>
    <p>- just bypass vuls because of value</p>
    <p>Dynamic analysis is lack of a complete model</p>
    <p>- find heap overflow by integer overflow</p>
    <p>Existing methods</p>
    <p>X = input() buffer1 = malloc(X+2) //Heap overflow only if X+2 is integer overflow but X+1 not memcpy(buffer1, xxxx, X+1)</p>
    <p>Y: Value</p>
    <p>Z: Time</p>
    <p>X: Address</p>
    <p>Normal End</p>
    <p>Crash</p>
    <p>Value changed at the same path</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>More proactive  Find vulnerabilities before attackers</p>
    <p>More targeted  Focus on heap overflow vulnerabilities</p>
    <p>More complete  Build a complete model of vulnerabilities</p>
    <p>Goal</p>
  </div>
  <div class="page">
    <p>Background</p>
    <p>Example of a heap overflow  Heap allocation operations</p>
    <p>(obj, sizeallocation)</p>
    <p>Heap access operations</p>
    <p>(ptr, offsetptr, sizeaccess)</p>
    <p>Heap overflow happens  When input size = SIZE</p>
    <p>Root causeSpatial inconsistency</p>
    <p>Heap overflow condition: Rangeaccess &gt; Rangeobj</p>
  </div>
  <div class="page">
    <p>Types of heap overflow (based on controllable attributes)</p>
    <p>Background</p>
    <p>ObservationControllable attributes</p>
    <p>Alloc</p>
    <p>Access1</p>
    <p>Access2Input</p>
    <p>Alloc controllable</p>
    <p>Access controllable</p>
    <p>How to overflow</p>
    <p>S1 N N --/inherent errors</p>
    <p>S2 N Y Copy more data/Copy to outside offset</p>
    <p>S3 Y N Allocate small buffer/allocation size is integer overflow</p>
    <p>S4 Y</p>
    <p>(bytes_1) Y</p>
    <p>(bytes_2) Change the value of two sides independently</p>
    <p>S5 Y</p>
    <p>(bytes_0) Y</p>
    <p>(bytes_0) Check IO2BO (e.g., (x+2, x+1))</p>
    <p>Call graph of an example</p>
  </div>
  <div class="page">
    <p>Design</p>
    <p>Overview of HOTracer</p>
    <p>Alloc</p>
    <p>Access1</p>
    <p>Access2Input PoC</p>
  </div>
  <div class="page">
    <p>Design</p>
    <p>Challenges Make it efficient</p>
    <p>Get representative traces efficiently</p>
    <p>Handle custom function implementations</p>
    <p>Pair heap operations accurately</p>
    <p>Use fine-grained taint analysis</p>
    <p>Based on the complete model</p>
    <p>Consider path constraints</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Testcase selection  Diverse sources: mutator, crawler</p>
    <p>Select representative ones: min-set coverage analysis based on sub-types (e.g., tags in MP4)</p>
    <p>Step1. Get execution traces - Get representative traces efficiently</p>
    <p>MP4 file structures</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Binary instrument with record and replay</p>
    <p>Step1. Get execution traces - Get representative traces efficiently</p>
    <p>Snapshot Binary traceChangelog</p>
    <p>Our instrument: Xede (RAID 15)</p>
    <p>Inspired by PANDA (CCS 13)</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Custom Heap allocation operations  Functionality</p>
    <p>A. return a heap pointer</p>
    <p>Process inside function  B1. invoke standard allocation interfaces</p>
    <p>B2. response to allocation applications bases on different sizes</p>
    <p>B3. pad extra bytes to align</p>
    <p>B4. update heap management structures in a critical way</p>
    <p>Used way  C1. return space is written before read</p>
    <p>C2. allocator is called many times</p>
    <p>C3. allocator returns different space</p>
    <p>C4. allocator sometimes initials the space</p>
    <p>Step2. Identify heap operations - Handle custom function implementations</p>
    <p>High-level workflow of custom allocators</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Custom Heap access operations</p>
    <p>Access the buffer in loops</p>
    <p>Access the buffer with REP instructions</p>
    <p>Access the buffer with continuous instructions</p>
    <p>Step2. Identify heap operations - Handle custom function implementations</p>
    <p>History buffer</p>
    <p>Candidate loop</p>
    <p>Loop body</p>
    <p>Exit condition</p>
    <p>Identify loops as continuously repeated sub-strings, ending with jump instructions</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Pair heap access operations to heap allocation operations  Pointer taint analysis</p>
    <p>Taint source: heap pointers returned from allocators</p>
    <p>Heap access: dereference of a heap pointer</p>
    <p>Under-taint issue</p>
    <p>//EAX is a pointer, EBX is another pointer</p>
    <p>//EAX (TaintEAX ) EBX (TaintEBX )</p>
    <p>SUB EAX, EBX</p>
    <p>//previous solutions bleach EAXs taint</p>
    <p>MOV ESI, EAX</p>
    <p>//ESI=(EAX-EBX)+EBX=EAX, not related to EBX</p>
    <p>ADD ESI, EBX</p>
    <p>Step3. Track Spatial Attributes - Pair heap operations accurately</p>
    <p>Signed taint label</p>
    <p>EAX (TaintEAX , TaintEBX )</p>
    <p>ESI (TaintEAX , TaintEBX )</p>
    <p>ESI (TaintEAX )</p>
    <p>Previous solution</p>
    <p>EAX (NULL )</p>
    <p>ESI (NULL)</p>
    <p>ESI (TaintEBX )</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Multiple label taint analysis at byte level</p>
    <p>Kernel instructions: NOT record</p>
    <p>Sub-Step: Heap Operation Pairs Sorting  Select more vulnerable pairs</p>
    <p>Filter heap management functions</p>
    <p>Step3. Track Taint Attributes - Use fine-grained taint analysis</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Rangeaccess &gt; Rangeobj  Consider integer overflow (IO2BO)</p>
    <p>Step4. Build Vulnerability Conditions - Based on the complete model</p>
    <p>Step5. Generate PoC inputs - Consider path constraints</p>
    <p>Analyze from the last read to the vulnerable point</p>
    <p>Only symbolize relevant input bytes</p>
    <p>Use Z3 to solve the conditions</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Test on known vulnerabilities  Correct the vulnerable points in PoC files</p>
    <p>Test if we could find the same vulnerabilities</p>
    <p>Discover unknown vulnerabilities  Representative samples</p>
    <p>Effectiveness</p>
    <p>Known vulnerabilities (8 vuls in 8 apps)</p>
    <p>Unknown vulnerabilities (47 vuls in 17 apps)</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>We have discovered 6 vulnerabilities of 8 known ones.</p>
    <p>CVE-2015-0327: overwrite the program function with scripts and change the behavior</p>
    <p>CVE-2010-2553: multiple level nested loops of accesses</p>
    <p>Details</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Tainted access offset  offset is influenced by input</p>
    <p>dst address = Object + offset memcpy(Dst, Src)</p>
    <p>Implicit taint situations  Allocation side: Size of malloc is based on the length of inputs  Access side: Number of data copy is based on keywords</p>
    <p>while (input != \0 ){ length++;</p>
    <p>} buffer = malloc(length);</p>
    <p>Case studies</p>
    <p>while(input == keywords){ memcpy();</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Multiple vulnerabilities in one trace  We found two vulnerable points when testing the PoC of CVE-2014-1761</p>
    <p>Long testing time  A VLC vulnerability happened at the end of playing for more than several minutes</p>
    <p>Case studies</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>WinAFL  Need more knowledge of the target software and its functions</p>
    <p>Fail to find new vulnerabilities</p>
    <p>Radamsa  Black-box fuzzer with various kinds of heuristics and change patterns</p>
    <p>Potplayer: 1144 crashes, 11 crash points, 3 vulnerable points (included by HOTracer)</p>
    <p>Comparison</p>
    <p>Alloc</p>
    <p>Access2: Overflow</p>
    <p>Crash</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Custom heap management functions</p>
    <p>Complicated heap access operations</p>
    <p>Constraint simplification and solve</p>
    <p>Exploitability assess</p>
    <p>Use after free</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>We proposed a new offline dynamic analysis solution to discover</p>
    <p>heap overflow vulnerabilities.</p>
    <p>We pointed out the root cause of heap overflow vulnerabilities is the</p>
    <p>inconsistency between heap operations.</p>
    <p>We addressed several challenges to make the solution practical and</p>
    <p>efficient.</p>
    <p>We implemented a prototype system, HOTracer, and found 47</p>
    <p>previously unknown heap vulnerabilities in 17 applications with it.</p>
  </div>
  <div class="page">
    <p>Thank you</p>
    <p>Xiangkun Jia jiaxiangkun@tca.iscas.ac.cn</p>
  </div>
</Presentation>
