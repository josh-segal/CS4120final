<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>The Guards Dilemma Efficient Code-Reuse Attacks Against Intel SGX</p>
    <p>Andrea Biondo1, Mauro Conti1, Lucas Davi2, Tommaso Frassetto3, Ahmad-Reza Sadeghi3</p>
  </div>
  <div class="page">
    <p>Intel SGX (Software Guard eXtensions)</p>
    <p>App</p>
    <p>Enclave</p>
    <p>App Code</p>
    <p>Enclave Code</p>
    <p>Entry/exit</p>
    <p>Kernel</p>
    <p>Encryption</p>
    <p>Attestation</p>
    <p>Physical memory</p>
    <p>Remote server</p>
  </div>
  <div class="page">
    <p>Intel SGX (Software Guard eXtensions)</p>
    <p>App</p>
    <p>Enclave</p>
    <p>App Code</p>
    <p>Enclave Code</p>
    <p>Entry/exit</p>
    <p>Kernel</p>
    <p>Encryption</p>
    <p>Attestation</p>
    <p>Physical memory</p>
    <p>Remote server</p>
    <p>SGX SDK</p>
  </div>
  <div class="page">
    <p>SGX provides strong isolation.</p>
    <p>(thats what it says on the box!)</p>
  </div>
  <div class="page">
    <p>Just like normal programs, SGX code can have bugs.</p>
  </div>
  <div class="page">
    <p>Control-Flow Attacks</p>
    <p>A</p>
    <p>CB</p>
    <p>D</p>
    <p>F</p>
    <p>E</p>
    <p>Control-Flow Hijacking</p>
    <p>Shellcode</p>
    <p>Code Injection</p>
  </div>
  <div class="page">
    <p>Control-Flow Attacks</p>
    <p>A</p>
    <p>CB</p>
    <p>D</p>
    <p>F</p>
    <p>E</p>
    <p>Control-Flow Hijacking</p>
    <p>Shellcode</p>
    <p>A</p>
    <p>CB</p>
    <p>D</p>
    <p>F</p>
    <p>E</p>
    <p>Control-Flow Hijacking</p>
    <p>Gadget</p>
    <p>Code Injection Code Reuse (e.g., Return-Oriented Programming)</p>
    <p>Write</p>
    <p>eXecute F</p>
  </div>
  <div class="page">
    <p>Control-Flow Attacks</p>
    <p>A</p>
    <p>CB</p>
    <p>D</p>
    <p>F</p>
    <p>E</p>
    <p>Control-Flow Hijacking</p>
    <p>Shellcode</p>
    <p>A</p>
    <p>CB</p>
    <p>D</p>
    <p>F</p>
    <p>E</p>
    <p>Control-Flow Hijacking</p>
    <p>Gadget</p>
    <p>Code Injection Code Reuse (e.g., Return-Oriented Programming)</p>
    <p>Write</p>
    <p>eXecute</p>
    <p>Control Flow Integrity</p>
    <p>F</p>
  </div>
  <div class="page">
    <p>Related work</p>
    <p>Dark-ROP [Lee et al., USENIX</p>
    <p>Security 2017]</p>
    <p>Remote attestation + loader = no access to enclave code  ROP still feasible by finding gadgets through oracles</p>
    <p>SGX-Shield [Seo et al., NDSS</p>
    <p>Fine-grained enclave randomization, WX, Software Fault Isolation, Control Flow Integrity</p>
    <p>State-of-the-art hardening scheme</p>
  </div>
  <div class="page">
    <p>The SGX SDK</p>
    <p>Source</p>
    <p>SGX SDK</p>
    <p>App</p>
    <p>Enclave</p>
    <p>Function 0 Function 1</p>
    <p>Function 2 Function 3</p>
    <p>Compiler</p>
    <p>App Code</p>
    <p>Untrusted Runtime System (uRTS)</p>
    <p>Trusted Runtime System (tRTS)</p>
    <p>App-to-Enclave function call</p>
    <p>(ECALL)</p>
  </div>
  <div class="page">
    <p>The SGX SDK</p>
    <p>Source</p>
    <p>SGX SDK</p>
    <p>App</p>
    <p>Enclave</p>
    <p>Function 0 Function 1</p>
    <p>Function 2 Function 3</p>
    <p>Compiler</p>
    <p>App Code</p>
    <p>Untrusted Runtime System (uRTS)</p>
    <p>Trusted Runtime System (tRTS)</p>
    <p>Enclave-to-App function call</p>
    <p>(OCALL)</p>
  </div>
  <div class="page">
    <p>The SGX SDK</p>
    <p>Source</p>
    <p>SGX SDK</p>
    <p>App</p>
    <p>Enclave</p>
    <p>Function 0 Function 1</p>
    <p>Function 2 Exc. Handler</p>
    <p>Compiler</p>
    <p>App Code</p>
    <p>Untrusted Runtime System (uRTS)</p>
    <p>Trusted Runtime System (tRTS) Signal</p>
    <p>OS Kernel AEX</p>
    <p>Exception</p>
  </div>
  <div class="page">
    <p>The Guards Dilemma</p>
    <p>Novel SGX code-reuse attack</p>
    <p>Dispatches ROP gadgets</p>
    <p>Uses only existing tRTS functionality</p>
    <p>Why?</p>
  </div>
  <div class="page">
    <p>Motivation</p>
    <p>Widespread SDK usage</p>
    <p>Easier exploitation</p>
    <p>Existing hardening does not cover tRTS</p>
  </div>
  <div class="page">
    <p>The Basic Idea</p>
    <p>App</p>
    <p>Enclave</p>
    <p>Function 0 Function 1</p>
    <p>Function 2 Function 3</p>
    <p>Trusted Runtime System (tRTS)</p>
    <p>Restore State</p>
    <p>State</p>
    <p>Counterfeit state</p>
  </div>
  <div class="page">
    <p>The ORET Primitive</p>
    <p>OCALL</p>
    <p>Save context in OCALL frame</p>
    <p>Exit enclave</p>
    <p>Execute untrusted function</p>
    <p>Re-enter enclave</p>
    <p>Restore context (do_oret)</p>
    <p>Control-Flow Hijacking</p>
    <p>Fake OCALL frame</p>
    <p>Partial register control</p>
    <p>Stack control</p>
  </div>
  <div class="page">
    <p>The CONT Primitive</p>
    <p>Exception</p>
    <p>Resume enclave</p>
    <p>Call exception handlers</p>
    <p>Restore exception context (continue_execution)</p>
    <p>Control-Flow Hijacking</p>
    <p>Fake exception context</p>
    <p>Full register control</p>
    <p>Exit enclave to OS handler</p>
    <p>Re-enter, save context, exit (see paper)</p>
  </div>
  <div class="page">
    <p>The ORET+CONT Loop</p>
    <p>ORET</p>
    <p>rip, rsp rip, rdi, ...</p>
    <p>CONT</p>
    <p>rip, rdi rip, rsp, *</p>
    <p>ROP Gadget</p>
  </div>
  <div class="page">
    <p>Attack Overview</p>
    <p>Payload Preparation  Find gadgets  Design gadget chain</p>
    <p>Fake Structures Prep.  n fake exception infos  1 fake stack (ROP, OCALL)</p>
    <p>Attack Execution  Launch first CONT</p>
    <p>Gadget</p>
    <p>ORET</p>
    <p>CONT</p>
    <p>Fake exc. info 1 Gadget 1</p>
    <p>Fake exc. info 2 Gadget 2</p>
    <p>Fake exc. info 3 Gadget 3</p>
    <p>Fake stack</p>
  </div>
  <div class="page">
    <p>Example Attack</p>
    <p>App</p>
    <p>Enclave</p>
    <p>vuln_f oth_f</p>
    <p>get_key send_file</p>
    <p>Trusted Runtime System (tRTS)</p>
    <p>ORET: rip, stack  rdi + rip +</p>
    <p>CONT: rdi  rip + all registers Stack</p>
    <p>rip</p>
    <p>rdi</p>
    <p>Other registers</p>
  </div>
  <div class="page">
    <p>SGX-Shield [Seo et al., NDSS 2017]</p>
    <p>Source</p>
    <p>SGX-Shield Runtime</p>
    <p>App</p>
    <p>Enclave</p>
    <p>Rand. Unit 0 Rand. Unit 1</p>
    <p>Rand. Unit 2 Rand. Unit 3 SGX-Shield Toolchain</p>
    <p>App Code</p>
    <p>Untrusted Runtime System (uRTS)</p>
    <p>Trusted Runtime System (tRTS)</p>
    <p>Fine-grained code randomization</p>
    <p>tRTS is not randomized</p>
    <p>SGX SDK</p>
  </div>
  <div class="page">
    <p>Attacking SGX-Shield</p>
    <p>Fine-grained code randomization</p>
    <p>Reusing tRTS code (not randomized)</p>
    <p>Coarse-grained Control Flow Integrity</p>
    <p>Return edges are not properly instrumented  ORET is possible</p>
    <p>Other mitigations (SFI, WX) assume CFI</p>
  </div>
  <div class="page">
    <p>SGX-Shield Exploit</p>
    <p>Hijack return edge</p>
    <p>Untrusted memory</p>
    <p>Write shellcode to WX memory</p>
    <p>Jump to shellcode</p>
    <p>Stage 1 ORET+CONT</p>
    <p>Gather enclave keys</p>
    <p>Copy keys to attackers memory</p>
    <p>Stage 2 Shellcode</p>
  </div>
  <div class="page">
    <p>Mitigations</p>
    <p>SDK Hardening</p>
    <p>Secret canaries in contexts</p>
    <p>Mangling context data</p>
    <p>External Hardening</p>
    <p>Randomization of SDK code</p>
    <p>Stronger CFI</p>
  </div>
  <div class="page">
    <p>Lessons Learned</p>
    <p>SGX presents significant hardening challenges  Strong attacker</p>
    <p>The SDK can increase an enclaves attack surface  Powerful code-reuse primitives</p>
    <p>Low-level code hidden from sight</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>We presented a novel code-reuse attack on Intel SGX</p>
    <p>Using forgotten code to bypass SoA hardening</p>
    <p>Underlines the need to consider implications of SDK usage</p>
    <p>Questions?</p>
  </div>
</Presentation>
