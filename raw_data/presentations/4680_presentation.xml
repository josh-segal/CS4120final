<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>From OO to FPGA:From OO to FPGA: Fitting Round ObjectsFitting Round Objects into Square Hardware?into Square Hardware?</p>
    <p>Stephen KouStephen Kou</p>
    <p>Jens PalsbergJens Palsberg</p>
    <p>UCLA Computer Science DepartmentUCLA Computer Science Department</p>
    <p>University of California, Los AngelesUniversity of California, Los Angeles</p>
    <p>Presented at OOPSLA 2010Presented at OOPSLA 2010</p>
  </div>
  <div class="page">
    <p>Our tool: from OO to FPGA;Our tool: from OO to FPGA; big energy savingsbig energy savings  OO = object oriented languageOO = object oriented language</p>
    <p>FPGA = field programmable gate arrayFPGA = field programmable gate array</p>
  </div>
  <div class="page">
    <p>CPU vs. FPGA vs. ASIC</p>
    <p>energy use flexibility programmability</p>
    <p>CPU: high high easy</p>
    <p>FPGA: medium medium hard</p>
    <p>ASIC: low low extremely hard</p>
    <p>So: use ASICs to increase battery lifetime</p>
    <p>Example: cell phones</p>
    <p>But: use FPGAs if you predict lots of modifications</p>
  </div>
  <div class="page">
    <p>ASIC and FPGA cheat sheet</p>
    <p>Finished ASIC designs: 3,408 in 2006; 3,275 in 2007; then</p>
    <p>fell 9.5% in 2008 and fell again about 22% in 2009</p>
    <p>Now: 30x more design starts in FPGA over ASIC</p>
    <p>Projected market for FPGAs in 2016: $9.6 billion</p>
    <p>Feature sizes: 2002 Virtex-2 90 nm</p>
  </div>
  <div class="page">
    <p>The Challenge</p>
    <p>Compile a bare object-oriented program to an FPGA with</p>
    <p>significant energy savings compared to a CPU, while still</p>
    <p>maintaining acceptable performance and space usage.</p>
  </div>
  <div class="page">
    <p>How people traditionally program FPGAs</p>
    <p>Write in a hardware description language</p>
    <p>VHDL</p>
    <p>Verilog</p>
    <p>Compile with a synthesis tool: VDHL  FPGA</p>
  </div>
  <div class="page">
    <p>How some people program FPGAs nowadays</p>
    <p>Program in a small subset of C</p>
    <p>Compile to VHDL or Verilog with a high-level synthesis tool  AutoESL: AutoPilot ( based on xPilot [Cong et al., UCLA] )</p>
    <p>Synopsys: Synphony C Compiler</p>
    <p>Mentor Graphics: Catapult</p>
    <p>Ponder whether writing directly in VHDL is better  Fine-tune speed?</p>
    <p>Fine-tune energy use?</p>
    <p>Fine-tune area</p>
    <p>Really?</p>
  </div>
  <div class="page">
    <p>From OO to FPGA: a JVM on an FPGA</p>
    <p>Schoeberl [2004]: execute bytecodes on a FPGA</p>
    <p>No comparisons with a CPU</p>
  </div>
  <div class="page">
    <p>From OO to FPGA: state of the art</p>
    <p>Liquid Metal (Auerbach, Bacon, Cheng, Rabbah, IBM)</p>
    <p>Goal: one language for all platforms</p>
    <p>Approach: careful language design</p>
    <p>Key papers: ECOOP 2008 (DES)</p>
    <p>OOPSLA 2010 (DES + JPEG decoder)</p>
  </div>
  <div class="page">
    <p>From OO to FPGA: state of the art</p>
    <p>Liquid Metal (Auerbach, Bacon, Cheng, Rabbah, IBM)</p>
    <p>Goal: one language for all platforms</p>
    <p>Approach: careful language design</p>
    <p>Key papers: ECOOP 2008 (DES)</p>
    <p>OOPSLA 2010 (DES + JPEG decoder) Our goals:</p>
    <p>work with an existing language</p>
    <p>low energy use, good performance, small area</p>
  </div>
  <div class="page">
    <p>A match made in heaven?A match made in heaven?</p>
    <p>Virgil is an object-oriented language developed at UCLAVirgil is an object-oriented language developed at UCLA</p>
    <p>[[TitzerTitzer, OOPSLA 2006; , OOPSLA 2006; Titzer Titzer &amp; P., CASES 2007],&amp; P., CASES 2007],</p>
    <p>targeted to programming small devices, e.g., sensor nodestargeted to programming small devices, e.g., sensor nodes</p>
    <p>The Virgil compiler translates to CThe Virgil compiler translates to C</p>
    <p>AutoPilot AutoPilot is a C to FPGA synthesizeris a C to FPGA synthesizer</p>
    <p>Can we doCan we do</p>
    <p>VirgilVirgil C FPGA AutoPilot??</p>
  </div>
  <div class="page">
    <p>Virgil</p>
    <p>run</p>
    <p>initialization</p>
    <p>Heap</p>
    <p>IR</p>
    <p>Heap</p>
    <p>IRIR</p>
    <p>Source Code</p>
    <p>optimization</p>
    <p>Program initialization phase</p>
    <p>Heap-specific optimization: static analysis</p>
    <p>Lightweight features</p>
    <p>Compiler</p>
  </div>
  <div class="page">
    <p>The AutoPilot subset of C</p>
    <p>Places severe limitations on many C constructs</p>
    <p>Pointers</p>
    <p>Struct casting</p>
    <p>Contents of structs</p>
    <p>Rules out the traditional way of compiling OO languages</p>
    <p>Cannot represent objects with method tables</p>
    <p>Cannot use structs</p>
  </div>
  <div class="page">
    <p>Our technique</p>
    <p>OO to FPGA = type case for method dispatch +</p>
    <p>grouped arrays +</p>
    <p>hybrid object layout</p>
  </div>
  <div class="page">
    <p>Key features of OO</p>
    <p>Classes, extends, fields, constructors, methods</p>
    <p>class Point { int x,y; Point(int a, int b) {</p>
    <p>x=a; y=b; } void move(int d) {</p>
    <p>x=x+d; y=y+d; } }</p>
    <p>class ColorPoint extends Point { int color; ColorPoint(int a, int b, int c) {</p>
    <p>super(a,b); color=c; } void bump(int c) {</p>
    <p>color=c; this.move(1);</p>
    <p>} }</p>
  </div>
  <div class="page">
    <p>Key features of OO</p>
    <p>Classes, extends, fields, constructors, methods</p>
    <p>class Point { int x,y; Point(int a, int b) {</p>
    <p>x=a; y=b; } void move(int d) {</p>
    <p>x=x+d; y=y+d; } }</p>
    <p>class ColorPoint extends Point { int color; ColorPoint(int a, int b, int c) {</p>
    <p>super(a,b); color=c; } void bump(int c) {</p>
    <p>color=c; this.move(1);</p>
    <p>} }</p>
  </div>
  <div class="page">
    <p>Key features of OO</p>
    <p>Classes, extends, fields, constructors, methods</p>
    <p>class Point { int x,y; Point(int a, int b) {</p>
    <p>x=a; y=b; } void move(int d) {</p>
    <p>x=x+d; y=y+d; } }</p>
    <p>class ColorPoint extends Point { int color; ColorPoint(int a, int b, int c) {</p>
    <p>super(a,b); color=c; } void bump(int c) {</p>
    <p>color=c; this.move(1);</p>
    <p>} }</p>
  </div>
  <div class="page">
    <p>Key features of OO</p>
    <p>Classes, extends, fields, constructors, methods</p>
    <p>class Point { int x,y; Point(int a, int b) {</p>
    <p>x=a; y=b; } void move(int d) {</p>
    <p>x=x+d; y=y+d; } }</p>
    <p>class ColorPoint extends Point { int color; ColorPoint(int a, int b, int c) {</p>
    <p>super(a,b); color=c; } void bump(int c) {</p>
    <p>color=c; this.move(1);</p>
    <p>} }</p>
  </div>
  <div class="page">
    <p>Key features of OO</p>
    <p>Classes, extends, fields, constructors, methods</p>
    <p>class Point { int x,y; Point(int a, int b) {</p>
    <p>x=a; y=b; } void move(int d) {</p>
    <p>x=x+d; y=y+d; } }</p>
    <p>class ColorPoint extends Point { int color; ColorPoint(int a, int b, int c) {</p>
    <p>super(a,b); color=c; } void bump(int c) {</p>
    <p>color=c; this.move(1);</p>
    <p>} }</p>
  </div>
  <div class="page">
    <p>Key features of OO</p>
    <p>Classes, extends, fields, constructors, methods</p>
    <p>class Point { int x,y; Point(int a, int b) {</p>
    <p>x=a; y=b; } void move(int d) {</p>
    <p>x=x+d; y=y+d; } }</p>
    <p>class ColorPoint extends Point { int color; ColorPoint(int a, int b, int c) {</p>
    <p>super(a,b); color=c; } void bump(int c) {</p>
    <p>color=c; this.move(1);</p>
    <p>} }</p>
  </div>
  <div class="page">
    <p>Two objects, standard (horizontal) layout</p>
    <p>Point p = new Point(); ColorPoint cp = new ColorPoint();</p>
    <p>y =</p>
    <p>x =</p>
    <p>Point_move</p>
    <p>color =</p>
    <p>y =</p>
    <p>x =  ColorPoint_bump</p>
    <p>Point_move</p>
    <p>An object is a heap pointer</p>
    <p>Problem: pointers! Not supported by AutoPilot</p>
  </div>
  <div class="page">
    <p>Five objects, vertical layout [Titzer &amp; P., 2007]</p>
    <p>Row_x :</p>
    <p>Row_y :</p>
    <p>Row_color : 510------------</p>
    <p>point1 point2 point3 colorpoint1 colorpoint2</p>
    <p>An object is an integer</p>
  </div>
  <div class="page">
    <p>Idea for saving space: an extra table (!! :-)</p>
    <p>Row_x :</p>
    <p>Row_y :</p>
    <p>Row_color :</p>
    <p>Row_x :</p>
    <p>Row_y :</p>
    <p>Row_color : 10------------</p>
    <p>point1 point2 point3 colorpoint1 colorpoint2</p>
  </div>
  <div class="page">
    <p>Improved idea: drop extra table, keep tuples</p>
    <p>Row_x :</p>
    <p>Row_y :</p>
    <p>Row_color :</p>
    <p>point1 point2 point3 colorpoint1 colorpoint2</p>
    <p>An object is a tuple</p>
  </div>
  <div class="page">
    <p>Ultimate idea: condensed rows</p>
    <p>Row_Point :</p>
    <p>Row_ColorPoint :</p>
    <p>point1 point2 point3 colorpoint1 colorpoint2</p>
    <p>An object is a tuple</p>
  </div>
  <div class="page">
    <p>Instead of function pointers: custom dispatcher</p>
    <p>void move_dispatch(struct Tuple __this, int d) {</p>
    <p>switch( Row_Point[__this.f0].TypeId ) {</p>
    <p>case 101: // Point, ColorPoint</p>
    <p>return Point_move(__this, d);</p>
    <p>}</p>
    <p>}</p>
    <p>We added a field TypeId to each entry of Row_Point</p>
  </div>
  <div class="page">
    <p>Experimental results: our platforms</p>
    <p>CPU (xeon) 2.66 GHz TDP = 80 W</p>
    <p>CPU (atom) 1.6 GHz TDP = 4 W</p>
    <p>FPGA (Xilinx Virtex-II) 100 MHz N/A</p>
    <p>Auerbach et al. [previous paper] run on a Xilinx Virtex-5</p>
    <p>TDP = Thermal Design Power (can be viewed as a max)</p>
    <p>Excludes power for memory, storage drives, etc.</p>
  </div>
  <div class="page">
    <p>VirgilOriginal</p>
    <p>Originally in C++:</p>
    <p>Originally in C:</p>
    <p>Lines of code</p>
    <p>Experimental results: our benchmarks</p>
    <p>Similar!</p>
  </div>
  <div class="page">
    <p>Experimental results: C vs. Virgil</p>
    <p>area</p>
    <p>(slices)</p>
    <p>energy</p>
    <p>(mJ)</p>
    <p>time</p>
    <p>(us)</p>
    <p>energy</p>
    <p>(mJ)</p>
    <p>time</p>
    <p>(us)</p>
    <p>energy</p>
    <p>(mJ)</p>
    <p>time</p>
    <p>(us)</p>
    <p>FPGACPU (atom)CPU (xeon)SHA1</p>
  </div>
  <div class="page">
    <p>Experimental results: C++ vs. Virgil</p>
    <p>N/AN/AN/A159.6039,900805.210,065C++</p>
    <p>area</p>
    <p>(slices)</p>
    <p>energy</p>
    <p>(mJ)</p>
    <p>time</p>
    <p>(us)</p>
    <p>energy</p>
    <p>(mJ)</p>
    <p>time</p>
    <p>(us)</p>
    <p>energy</p>
    <p>(mJ)</p>
    <p>time</p>
    <p>(us)</p>
    <p>FPGACPU (atom)CPU (xeon)</p>
    <p>Richards</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>OO to FPGA is possible</p>
    <p>Energy savings!</p>
    <p>Virgil on an FPGA beats C++ on an Atom by 8x</p>
    <p>Faster OO code!</p>
    <p>Virgil on an FPGA beats C++ on an Atom by 3x</p>
    <p>Competitive area</p>
  </div>
</Presentation>
