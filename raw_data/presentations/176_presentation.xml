<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Automatically Inferring Quantified Loop Invariants by Algorithmic Learning from Simple Templates</p>
    <p>Soonho Kong1 Yungbum Jung1 Cristina David2 Bow-Yaw Wang3 Kwangkeun Yi1</p>
    <p>APLAS10@Shanghai</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Automated Technique</p>
    <p>Output</p>
    <p>Input Annotated Loop</p>
    <p>(Pre-/Post-conditions)</p>
    <p>InputAtomic Propositions</p>
    <p>A Loop Invariant (Quantified Formulae)</p>
  </div>
  <div class="page">
    <p>Automated Technique</p>
    <p>Overview</p>
    <p>Input Annotated Loop</p>
    <p>(Pre-/Post-conditions)</p>
    <p>InputAtomic Propositions</p>
    <p>Algorithmic Learning</p>
    <p>Query</p>
    <p>Answer</p>
    <p>Query</p>
    <p>Answer . .</p>
    <p>.</p>
    <p>Output</p>
    <p>A Loop Invariant (Quantified Formulae)</p>
  </div>
  <div class="page">
    <p>Automated Technique</p>
    <p>Overview</p>
    <p>Input Annotated Loop</p>
    <p>(Pre-/Post-conditions)</p>
    <p>InputAtomic Propositions</p>
    <p>Decision Procedures</p>
    <p>Algorithmic Learning</p>
    <p>Query</p>
    <p>Answer</p>
    <p>Query</p>
    <p>Answer . .</p>
    <p>.</p>
    <p>Output</p>
    <p>(SMT solvers) A Loop Invariant (Quantified Formulae)</p>
  </div>
  <div class="page">
    <p>Automated Technique</p>
    <p>Overview</p>
    <p>Input Annotated Loop</p>
    <p>(Pre-/Post-conditions)</p>
    <p>Decision Procedures</p>
    <p>Algorithmic Learning</p>
    <p>Query</p>
    <p>Answer</p>
    <p>Query</p>
    <p>Answer . .</p>
    <p>.</p>
    <p>Boolean Formulae</p>
    <p>Quantified Formulae</p>
    <p>InputAtomic Propositions</p>
    <p>Output</p>
    <p>(SMT solvers) A Loop Invariant (Quantified Formulae)</p>
  </div>
  <div class="page">
    <p>Automated Technique</p>
    <p>Overview</p>
    <p>Input Annotated Loop</p>
    <p>(Pre-/Post-conditions)</p>
    <p>Decision Procedures</p>
    <p>Algorithmic Learning</p>
    <p>Query</p>
    <p>Answer</p>
    <p>Query</p>
    <p>Answer . .</p>
    <p>.</p>
    <p>Predicate Abstraction Boolean</p>
    <p>Formulae Quantified Formulae</p>
    <p>InputAtomic Propositions</p>
    <p>Output</p>
    <p>A Loop Invariant (Quantified Formulae)</p>
    <p>k.k &lt; i  a[k]  a[m]</p>
    <p>Templates</p>
    <p>Templates Input</p>
    <p>k.[ ] (SMT solvers)</p>
  </div>
  <div class="page">
    <p>(a) rm pkey { i = 0  key = 0  ret  break} 1 while(i &lt; n  break) do 2 if(pkeys[i] = key) then 3 pkeyrefs[i]:=pkeyrefs[i]  1; 4 if(pkeyrefs[i] = 0) then 5 pkeys[i]:=0; ret:=true; 6 break:=true; 7 else i:=i + 1; 8 done {(ret  break)  (k.k &lt; n  pkeys[k] = key)</p>
    <p>(ret  break)  (pkeys[i] = key  pkeyrefs[i] = 0)  ret  (pkeyrefs[i] = 0  pkeys[i] = 0) }</p>
    <p>(c) devres { i = 0  ret } 1 while i &lt; n  ret do 2 if tbl[i] = addr then 3 tbl[i]:=0; ret:=true 4 else 5 i:=i + 1 6 end {(ret  k. k &lt; n  tbl[k] = addr)</p>
    <p>(ret  tbl[i] = 0) }</p>
    <p>(b) selection sort { i = 0 }</p>
    <p>{(i  n  1)  (k1.k1 &lt; n</p>
    <p>(k2.k2 &lt; n  a[k1] = a[k2]))}</p>
    <p>Fig. 5. Benchmark Examples: (a) rm pkey from Linux InfiniBand driver, (b) selection sort from [20], and (c) devres from Linux library.</p>
    <p>Observe that our algorithm is able to infer an arbitrary quantifier-free formula</p>
    <p>(over a fixed set of atomic propositions) to fill the hole in the given template. A</p>
    <p>simple template such as k.[] suffices to serve as a hint in our approach.</p>
    <p>selection sort from [20] Consider the selection sort algorithm in Figure 5(b). Let</p>
    <p>a[] denote the content of the array a[] before the algorithm is executed. The postcondition states that the contents of array a[] come from its old contents. In this test case, we apply our invariant generation algorithm to compute an</p>
    <p>invariant to establish the postcondition of the outer loop. For computing the</p>
    <p>invariant of the outer loop, we make use of the inner loops specification.</p>
    <p>We use the following set of atomic propositions: {k1  0, k1 &lt; i, k1 = i, k2 &lt; n, k2 = n, a[k1] =</p>
    <p>a[k2], i &lt; n1, i = min}. Using the template k1.k2.[], our algorithm infers following invariants in different runs:</p>
    <p>k1.(k2.[(k2 &lt; n  a[k1] = a[k2])  k1  i]); and k1.(k2.[(k1  i  min = i  k2 &lt; n)  (k1  i  (min = i  a[k1] = a[k2]))]).</p>
    <p>Note that all membership queries are resolved randomly due to the alternation of</p>
    <p>quantifiers in array theory. Still a simple random walk suffices to find invariants in this example. Moreover, templates allow us to infer not only universally quantified</p>
    <p>invariants but also first-order invariants with alternating quantifications. Inferring</p>
    <p>arbitrary quantifier-free formulae over a fixed set of atomic propositions again</p>
    <p>greatly simplifies the form of templates used in this example.</p>
    <p>From Linux InfiniBand Driver</p>
    <p>Templates 8 atomic propositionsk.[ ]</p>
  </div>
  <div class="page">
    <p>(a) rm pkey { i = 0  key = 0  ret  break} 1 while(i &lt; n  break) do 2 if(pkeys[i] = key) then 3 pkeyrefs[i]:=pkeyrefs[i]  1; 4 if(pkeyrefs[i] = 0) then 5 pkeys[i]:=0; ret:=true; 6 break:=true; 7 else i:=i + 1; 8 done {(ret  break)  (k.k &lt; n  pkeys[k] = key)</p>
    <p>(ret  break)  (pkeys[i] = key  pkeyrefs[i] = 0)  ret  (pkeyrefs[i] = 0  pkeys[i] = 0) }</p>
    <p>(c) devres { i = 0  ret } 1 while i &lt; n  ret do 2 if tbl[i] = addr then 3 tbl[i]:=0; ret:=true 4 else 5 i:=i + 1 6 end {(ret  k. k &lt; n  tbl[k] = addr)</p>
    <p>(ret  tbl[i] = 0) }</p>
    <p>(b) selection sort { i = 0 }</p>
    <p>{(i  n  1)  (k1.k1 &lt; n</p>
    <p>(k2.k2 &lt; n  a[k1] = a[k2]))}</p>
    <p>Fig. 5. Benchmark Examples: (a) rm pkey from Linux InfiniBand driver, (b) selection sort from [20], and (c) devres from Linux library.</p>
    <p>Observe that our algorithm is able to infer an arbitrary quantifier-free formula</p>
    <p>(over a fixed set of atomic propositions) to fill the hole in the given template. A</p>
    <p>simple template such as k.[] suffices to serve as a hint in our approach.</p>
    <p>selection sort from [20] Consider the selection sort algorithm in Figure 5(b). Let</p>
    <p>a[] denote the content of the array a[] before the algorithm is executed. The postcondition states that the contents of array a[] come from its old contents. In this test case, we apply our invariant generation algorithm to compute an</p>
    <p>invariant to establish the postcondition of the outer loop. For computing the</p>
    <p>invariant of the outer loop, we make use of the inner loops specification.</p>
    <p>We use the following set of atomic propositions: {k1  0, k1 &lt; i, k1 = i, k2 &lt; n, k2 = n, a[k1] =</p>
    <p>a[k2], i &lt; n1, i = min}. Using the template k1.k2.[], our algorithm infers following invariants in different runs:</p>
    <p>k1.(k2.[(k2 &lt; n  a[k1] = a[k2])  k1  i]); and k1.(k2.[(k1  i  min = i  k2 &lt; n)  (k1  i  (min = i  a[k1] = a[k2]))]).</p>
    <p>Note that all membership queries are resolved randomly due to the alternation of</p>
    <p>quantifiers in array theory. Still a simple random walk suffices to find invariants in this example. Moreover, templates allow us to infer not only universally quantified</p>
    <p>invariants but also first-order invariants with alternating quantifications. Inferring</p>
    <p>arbitrary quantifier-free formulae over a fixed set of atomic propositions again</p>
    <p>greatly simplifies the form of templates used in this example.</p>
    <p>rm pkey from Linux Infin</p>
    <p>iBand Driv er Figure 5</p>
    <p>(a) is a whi le statemen</p>
    <p>t</p>
    <p>extracted from Lin</p>
    <p>ux Infini Band dri</p>
    <p>ver. 4 The conj</p>
    <p>uncts in the postc</p>
    <p>ondition</p>
    <p>represent (1) if the</p>
    <p>loop term inates w</p>
    <p>ithout br eak, all e</p>
    <p>lements of pkeys are</p>
    <p>not equa l to key (line</p>
    <p>terminat es with b</p>
    <p>reak but ret is false,</p>
    <p>then pkeys[i ] is equa</p>
    <p>l to key (line 2) but pkeyr</p>
    <p>efs[i] is not e qual to z</p>
    <p>ero (line</p>
    <p>ter the lo op, then</p>
    <p>both pkeyref s[i] (line 4)</p>
    <p>and pkeys[i]</p>
    <p>(line 5) a re equal</p>
    <p>to zero. From the</p>
    <p>postcond ition, we</p>
    <p>guess tha t an inva</p>
    <p>riant</p>
    <p>can be u niversally</p>
    <p>quantifie d with k. Us</p>
    <p>ing the s imple tem</p>
    <p>plate k.[] and t he</p>
    <p>set of ato mic prop</p>
    <p>ositions {ret, bre ak, i &lt; n, k &lt;</p>
    <p>i, pkeys[i] = 0, pkeys[i] =</p>
    <p>key,</p>
    <p>pkeyrefs[i] = 0, pkeyrefs[k</p>
    <p>] = key}, our a lgorithm</p>
    <p>finds foll owing qu</p>
    <p>antified</p>
    <p>invariant s in different</p>
    <p>runs:</p>
    <p>(k.(k &lt; i)  pk eys[k] = key)  (</p>
    <p>ret  pkeyrefs[i] = 0  pkeys[i] =</p>
    <p>(ret  break  pkeys[i] = ke</p>
    <p>y  pkeyrefs[i] = 0); and</p>
    <p>(k.(ret  bre ak  (pkeyrefs[i]</p>
    <p>= 0  pkeys[i] = 0))  (pkeys[k] =</p>
    <p>key  k  i)</p>
    <p>(ret  (pkeyre fs[i] = 0  pkeys[</p>
    <p>i] = 0  i &lt; n  b reak))</p>
    <p>(break  pkey refs[i] = 0  ret)</p>
    <p>(break  pkey s[i] = key  ret))</p>
    <p>.</p>
    <p>In spite o f undecid</p>
    <p>ability of first-orde</p>
    <p>r theories in Yices and</p>
    <p>random a nswers,</p>
    <p>each of th e 3000 (=</p>
    <p>ents infer s an invar</p>
    <p>iant succe ssfully.</p>
    <p>Moreover , several</p>
    <p>quantifie d invaria</p>
    <p>nts are fo und in ea</p>
    <p>ch case a mong 50</p>
    <p>This sug gests tha</p>
    <p>t invaria nts are a</p>
    <p>bundant. Note tha</p>
    <p>t the tem plates in</p>
    <p>the</p>
    <p>test case s selection</p>
    <p>sort and t racepoint2</p>
    <p>have alte rnating q</p>
    <p>uantifica tion.</p>
    <p>Satisfiabi lity of alt</p>
    <p>ernating quantified</p>
    <p>formulae is in gene</p>
    <p>ral undec idable. T</p>
    <p>hat is</p>
    <p>why both cases hav</p>
    <p>e substan tially mo</p>
    <p>re restart s than th</p>
    <p>e others. Interestin</p>
    <p>gly,</p>
    <p>our algor ithm is a</p>
    <p>ble to ge nerate a</p>
    <p>verifiable invariant</p>
    <p>in each r un. Our</p>
    <p>simple</p>
    <p>randomiz ed mecha</p>
    <p>nism pro ves to be</p>
    <p>effective even for most</p>
    <p>difficult cases .</p>
    <p>Comparin g with th</p>
    <p>e work [1 5] of gene</p>
    <p>rating qu antifier-fr</p>
    <p>ee invaria nts, we d</p>
    <p>evelop</p>
    <p>the follow ing techn</p>
    <p>ical exten sions. Fir</p>
    <p>st, we int egrate po</p>
    <p>tential co unterexam</p>
    <p>ples</p>
    <p>in resolvi ng equiva</p>
    <p>lence que ry algorit</p>
    <p>hm (line 6 - 7 in A</p>
    <p>lgorithm 1, and lin</p>
    <p>e 3 in</p>
    <p>Algorithm 2) instea</p>
    <p>d of resta rting. Du</p>
    <p>e to the u ndecidab</p>
    <p>ility of sa tisfiabilit</p>
    <p>y of</p>
    <p>quantified formulae,</p>
    <p>SMT solv ers often</p>
    <p>give pote ntial coun</p>
    <p>terexamp les. We ex</p>
    <p>ploit</p>
    <p>potential countere</p>
    <p>xamples to enhan</p>
    <p>ce our al gorithm.</p>
    <p>Second, a new cond</p>
    <p>ition</p>
    <p>(Definitio n 1) to a</p>
    <p>nswer po sitively in</p>
    <p>resolving members</p>
    <p>hip queri es is prop</p>
    <p>osed.</p>
    <p>Without this cond</p>
    <p>ition, we can answ</p>
    <p>er negati vely to m</p>
    <p>embershi p queries</p>
    <p>.</p>
    <p>In contra st to prev</p>
    <p>ious temp late-base</p>
    <p>d approac hes [20,9]</p>
    <p>, our tem plate is m</p>
    <p>ore</p>
    <p>general a s it allow</p>
    <p>s arbitrar y hole-fil</p>
    <p>ling quan tifier-free</p>
    <p>formulae. The temp</p>
    <p>lates</p>
    <p>in [20] ca n only be</p>
    <p>filled wit h formul</p>
    <p>ae over c onjunctio</p>
    <p>ns of pre dicates fr</p>
    <p>om a</p>
    <p>given set . Any di</p>
    <p>sjunction must be</p>
    <p>explicitly specified</p>
    <p>as part o f a temp</p>
    <p>late.</p>
    <p>In [9], th e authors</p>
    <p>consider invariant</p>
    <p>s of the f orm E</p>
    <p>n j=1</p>
    <p>Uj(Fj  ej), w here</p>
    <p>E, Fj and ej must be</p>
    <p>quantifie r free fini</p>
    <p>te conjuc tions of a</p>
    <p>tomic fac ts.</p>
    <p>found in fun ction rm pke</p>
    <p>y of driver s/infiniba</p>
    <p>nd/hw/</p>
    <p>ipath/ipat h mad.c in L</p>
    <p>inux 2.6.28</p>
    <p>Find this invaria nt in 3 seconds</p>
  </div>
  <div class="page">
    <p>(a) rm pkey { i = 0  key = 0  ret  break} 1 while(i &lt; n  break) do 2 if(pkeys[i] = key) then 3 pkeyrefs[i]:=pkeyrefs[i]  1; 4 if(pkeyrefs[i] = 0) then 5 pkeys[i]:=0; ret:=true; 6 break:=true; 7 else i:=i + 1; 8 done {(ret  break)  (k.k &lt; n  pkeys[k] = key)</p>
    <p>(ret  break)  (pkeys[i] = key  pkeyrefs[i] = 0)  ret  (pkeyrefs[i] = 0  pkeys[i] = 0) }</p>
    <p>(c) devres { i = 0  ret } 1 while i &lt; n  ret do 2 if tbl[i] = addr then 3 tbl[i]:=0; ret:=true 4 else 5 i:=i + 1 6 end {(ret  k. k &lt; n  tbl[k] = addr)</p>
    <p>(ret  tbl[i] = 0) }</p>
    <p>(b) selection sort { i = 0 }</p>
    <p>{(i  n  1)  (k1.k1 &lt; n</p>
    <p>(k2.k2 &lt; n  a[k1] = a[k2]))}</p>
    <p>Fig. 5. Benchmark Examples: (a) rm pkey from Linux InfiniBand driver, (b) selection sort from [20], and (c) devres from Linux library.</p>
    <p>Observe that our algorithm is able to infer an arbitrary quantifier-free formula</p>
    <p>(over a fixed set of atomic propositions) to fill the hole in the given template. A</p>
    <p>simple template such as k.[] suffices to serve as a hint in our approach.</p>
    <p>selection sort from [20] Consider the selection sort algorithm in Figure 5(b). Let</p>
    <p>a[] denote the content of the array a[] before the algorithm is executed. The postcondition states that the contents of array a[] come from its old contents. In this test case, we apply our invariant generation algorithm to compute an</p>
    <p>invariant to establish the postcondition of the outer loop. For computing the</p>
    <p>invariant of the outer loop, we make use of the inner loops specification.</p>
    <p>We use the following set of atomic propositions: {k1  0, k1 &lt; i, k1 = i, k2 &lt; n, k2 = n, a[k1] =</p>
    <p>a[k2], i &lt; n1, i = min}. Using the template k1.k2.[], our algorithm infers following invariants in different runs:</p>
    <p>k1.(k2.[(k2 &lt; n  a[k1] = a[k2])  k1  i]); and k1.(k2.[(k1  i  min = i  k2 &lt; n)  (k1  i  (min = i  a[k1] = a[k2]))]).</p>
    <p>Note that all membership queries are resolved randomly due to the alternation of</p>
    <p>quantifiers in array theory. Still a simple random walk suffices to find invariants in this example. Moreover, templates allow us to infer not only universally quantified</p>
    <p>invariants but also first-order invariants with alternating quantifications. Inferring</p>
    <p>arbitrary quantifier-free formulae over a fixed set of atomic propositions again</p>
    <p>greatly simplifies the form of templates used in this example.</p>
    <p>rm pkey from Linux Infin</p>
    <p>iBand Driv er Figure 5</p>
    <p>(a) is a whi le statemen</p>
    <p>t</p>
    <p>extracted from Lin</p>
    <p>ux Infini Band dri</p>
    <p>ver. 4 The conj</p>
    <p>uncts in the postc</p>
    <p>ondition</p>
    <p>represent (1) if the</p>
    <p>loop term inates w</p>
    <p>ithout br eak, all e</p>
    <p>lements of pkeys are</p>
    <p>not equa l to key (line</p>
    <p>terminat es with b</p>
    <p>reak but ret is false,</p>
    <p>then pkeys[i ] is equa</p>
    <p>l to key (line 2) but pkeyr</p>
    <p>efs[i] is not e qual to z</p>
    <p>ero (line</p>
    <p>ter the lo op, then</p>
    <p>both pkeyref s[i] (line 4)</p>
    <p>and pkeys[i]</p>
    <p>(line 5) a re equal</p>
    <p>to zero. From the</p>
    <p>postcond ition, we</p>
    <p>guess tha t an inva</p>
    <p>riant</p>
    <p>can be u niversally</p>
    <p>quantifie d with k. Us</p>
    <p>ing the s imple tem</p>
    <p>plate k.[] and t he</p>
    <p>set of ato mic prop</p>
    <p>ositions {ret, bre ak, i &lt; n, k &lt;</p>
    <p>i, pkeys[i] = 0, pkeys[i] =</p>
    <p>key,</p>
    <p>pkeyrefs[i] = 0, pkeyrefs[k</p>
    <p>] = key}, our a lgorithm</p>
    <p>finds foll owing qu</p>
    <p>antified</p>
    <p>invariant s in different</p>
    <p>runs:</p>
    <p>(k.(k &lt; i)  pk eys[k] = key)  (</p>
    <p>ret  pkeyrefs[i] = 0  pkeys[i] =</p>
    <p>(ret  break  pkeys[i] = ke</p>
    <p>y  pkeyrefs[i] = 0); and</p>
    <p>(k.(ret  bre ak  (pkeyrefs[i]</p>
    <p>= 0  pkeys[i] = 0))  (pkeys[k] =</p>
    <p>key  k  i)</p>
    <p>(ret  (pkeyre fs[i] = 0  pkeys[</p>
    <p>i] = 0  i &lt; n  b reak))</p>
    <p>(break  pkey refs[i] = 0  ret)</p>
    <p>(break  pkey s[i] = key  ret))</p>
    <p>.</p>
    <p>In spite o f undecid</p>
    <p>ability of first-orde</p>
    <p>r theories in Yices and</p>
    <p>random a nswers,</p>
    <p>each of th e 3000 (=</p>
    <p>ents infer s an invar</p>
    <p>iant succe ssfully.</p>
    <p>Moreover , several</p>
    <p>quantifie d invaria</p>
    <p>nts are fo und in ea</p>
    <p>ch case a mong 50</p>
    <p>This sug gests tha</p>
    <p>t invaria nts are a</p>
    <p>bundant. Note tha</p>
    <p>t the tem plates in</p>
    <p>the</p>
    <p>test case s selection</p>
    <p>sort and t racepoint2</p>
    <p>have alte rnating q</p>
    <p>uantifica tion.</p>
    <p>Satisfiabi lity of alt</p>
    <p>ernating quantified</p>
    <p>formulae is in gene</p>
    <p>ral undec idable. T</p>
    <p>hat is</p>
    <p>why both cases hav</p>
    <p>e substan tially mo</p>
    <p>re restart s than th</p>
    <p>e others. Interestin</p>
    <p>gly,</p>
    <p>our algor ithm is a</p>
    <p>ble to ge nerate a</p>
    <p>verifiable invariant</p>
    <p>in each r un. Our</p>
    <p>simple</p>
    <p>randomiz ed mecha</p>
    <p>nism pro ves to be</p>
    <p>effective even for most</p>
    <p>difficult cases .</p>
    <p>Comparin g with th</p>
    <p>e work [1 5] of gene</p>
    <p>rating qu antifier-fr</p>
    <p>ee invaria nts, we d</p>
    <p>evelop</p>
    <p>the follow ing techn</p>
    <p>ical exten sions. Fir</p>
    <p>st, we int egrate po</p>
    <p>tential co unterexam</p>
    <p>ples</p>
    <p>in resolvi ng equiva</p>
    <p>lence que ry algorit</p>
    <p>hm (line 6 - 7 in A</p>
    <p>lgorithm 1, and lin</p>
    <p>e 3 in</p>
    <p>Algorithm 2) instea</p>
    <p>d of resta rting. Du</p>
    <p>e to the u ndecidab</p>
    <p>ility of sa tisfiabilit</p>
    <p>y of</p>
    <p>quantified formulae,</p>
    <p>SMT solv ers often</p>
    <p>give pote ntial coun</p>
    <p>terexamp les. We ex</p>
    <p>ploit</p>
    <p>potential countere</p>
    <p>xamples to enhan</p>
    <p>ce our al gorithm.</p>
    <p>Second, a new cond</p>
    <p>ition</p>
    <p>(Definitio n 1) to a</p>
    <p>nswer po sitively in</p>
    <p>resolving members</p>
    <p>hip queri es is prop</p>
    <p>osed.</p>
    <p>Without this cond</p>
    <p>ition, we can answ</p>
    <p>er negati vely to m</p>
    <p>embershi p queries</p>
    <p>.</p>
    <p>In contra st to prev</p>
    <p>ious temp late-base</p>
    <p>d approac hes [20,9]</p>
    <p>, our tem plate is m</p>
    <p>ore</p>
    <p>general a s it allow</p>
    <p>s arbitrar y hole-fil</p>
    <p>ling quan tifier-free</p>
    <p>formulae. The temp</p>
    <p>lates</p>
    <p>in [20] ca n only be</p>
    <p>filled wit h formul</p>
    <p>ae over c onjunctio</p>
    <p>ns of pre dicates fr</p>
    <p>om a</p>
    <p>given set . Any di</p>
    <p>sjunction must be</p>
    <p>explicitly specified</p>
    <p>as part o f a temp</p>
    <p>late.</p>
    <p>In [9], th e authors</p>
    <p>consider invariant</p>
    <p>s of the f orm E</p>
    <p>n j=1</p>
    <p>Uj(Fj  ej), w here</p>
    <p>E, Fj and ej must be</p>
    <p>quantifie r free fini</p>
    <p>te conjuc tions of a</p>
    <p>tomic fac ts.</p>
    <p>found in fun ction rm pke</p>
    <p>y of driver s/infiniba</p>
    <p>nd/hw/</p>
    <p>ipath/ipat h mad.c in L</p>
    <p>inux 2.6.28</p>
    <p>Find this invaria nt in 3 seconds</p>
    <p>rm pkey from Linux Infin</p>
    <p>iBand Driv er Figure 5</p>
    <p>(a) is a whi le statemen</p>
    <p>t</p>
    <p>extracted from Lin</p>
    <p>ux Infini Band dri</p>
    <p>ver. 4 The conj</p>
    <p>uncts in the postc</p>
    <p>ondition</p>
    <p>represent (1) if the</p>
    <p>loop term inates w</p>
    <p>ithout br eak, all e</p>
    <p>lements of pkeys are</p>
    <p>not equa l to key (line</p>
    <p>terminat es with b</p>
    <p>reak but ret is false,</p>
    <p>then pkeys[i ] is equa</p>
    <p>l to key (line 2) but pkeyr</p>
    <p>efs[i] is not e qual to z</p>
    <p>ero (line</p>
    <p>ter the lo op, then</p>
    <p>both pkeyref s[i] (line 4)</p>
    <p>and pkeys[i]</p>
    <p>(line 5) a re equal</p>
    <p>to zero. From the</p>
    <p>postcond ition, we</p>
    <p>guess tha t an inva</p>
    <p>riant</p>
    <p>can be u niversally</p>
    <p>quantifie d with k. Us</p>
    <p>ing the s imple tem</p>
    <p>plate k.[] and t he</p>
    <p>set of ato mic prop</p>
    <p>ositions {ret, bre ak, i &lt; n, k &lt;</p>
    <p>i, pkeys[i] = 0, pkeys[i] =</p>
    <p>key,</p>
    <p>pkeyrefs[i] = 0, pkeyrefs[k</p>
    <p>] = key}, our a lgorithm</p>
    <p>finds foll owing qu</p>
    <p>antified</p>
    <p>invariant s in different</p>
    <p>runs:</p>
    <p>(k.(k &lt; i)  pk eys[k] = key)  (</p>
    <p>ret  pkeyrefs[i] = 0  pkeys[i] =</p>
    <p>(ret  break  pkeys[i] = ke</p>
    <p>y  pkeyrefs[i] = 0); and</p>
    <p>(k.(ret  bre ak  (pkeyrefs[i]</p>
    <p>= 0  pkeys[i] = 0))  (pkeys[k] =</p>
    <p>key  k  i)</p>
    <p>(ret  (pkeyre fs[i] = 0  pkeys[</p>
    <p>i] = 0  i &lt; n  b reak))</p>
    <p>(break  pkey refs[i] = 0  ret)</p>
    <p>(break  pkey s[i] = key  ret))</p>
    <p>.</p>
    <p>In spite o f undecid</p>
    <p>ability of first-orde</p>
    <p>r theories in Yices and</p>
    <p>random a nswers,</p>
    <p>each of th e 3000 (=</p>
    <p>ents infer s an invar</p>
    <p>iant succe ssfully.</p>
    <p>Moreover , several</p>
    <p>quantifie d invaria</p>
    <p>nts are fo und in ea</p>
    <p>ch case a mong 50</p>
    <p>This sug gests tha</p>
    <p>t invaria nts are a</p>
    <p>bundant. Note tha</p>
    <p>t the tem plates in</p>
    <p>the</p>
    <p>test case s selection</p>
    <p>sort and t racepoint2</p>
    <p>have alte rnating q</p>
    <p>uantifica tion.</p>
    <p>Satisfiabi lity of alt</p>
    <p>ernating quantified</p>
    <p>formulae is in gene</p>
    <p>ral undec idable. T</p>
    <p>hat is</p>
    <p>why both cases hav</p>
    <p>e substan tially mo</p>
    <p>re restart s than th</p>
    <p>e others. Interestin</p>
    <p>gly,</p>
    <p>our algor ithm is a</p>
    <p>ble to ge nerate a</p>
    <p>verifiable invariant</p>
    <p>in each r un. Our</p>
    <p>simple</p>
    <p>randomiz ed mecha</p>
    <p>nism pro ves to be</p>
    <p>effective even for most</p>
    <p>difficult cases .</p>
    <p>Comparin g with th</p>
    <p>e work [1 5] of gene</p>
    <p>rating qu antifier-fr</p>
    <p>ee invaria nts, we d</p>
    <p>evelop</p>
    <p>the follow ing techn</p>
    <p>ical exten sions. Fir</p>
    <p>st, we int egrate po</p>
    <p>tential co unterexam</p>
    <p>ples</p>
    <p>in resolvi ng equiva</p>
    <p>lence que ry algorit</p>
    <p>hm (line 6 - 7 in A</p>
    <p>lgorithm 1, and lin</p>
    <p>e 3 in</p>
    <p>Algorithm 2) instea</p>
    <p>d of resta rting. Du</p>
    <p>e to the u ndecidab</p>
    <p>ility of sa tisfiabilit</p>
    <p>y of</p>
    <p>quantified formulae,</p>
    <p>SMT solv ers often</p>
    <p>give pote ntial coun</p>
    <p>terexamp les. We ex</p>
    <p>ploit</p>
    <p>potential countere</p>
    <p>xamples to enhan</p>
    <p>ce our al gorithm.</p>
    <p>Second, a new cond</p>
    <p>ition</p>
    <p>(Definitio n 1) to a</p>
    <p>nswer po sitively in</p>
    <p>resolving members</p>
    <p>hip queri es is prop</p>
    <p>osed.</p>
    <p>Without this cond</p>
    <p>ition, we can answ</p>
    <p>er negati vely to m</p>
    <p>embershi p queries</p>
    <p>.</p>
    <p>In contra st to prev</p>
    <p>ious temp late-base</p>
    <p>d approac hes [20,9]</p>
    <p>, our tem plate is m</p>
    <p>ore</p>
    <p>general a s it allow</p>
    <p>s arbitrar y hole-fil</p>
    <p>ling quan tifier-free</p>
    <p>formulae. The temp</p>
    <p>lates</p>
    <p>in [20] ca n only be</p>
    <p>filled wit h formul</p>
    <p>ae over c onjunctio</p>
    <p>ns of pre dicates fr</p>
    <p>om a</p>
    <p>given set . Any di</p>
    <p>sjunction must be</p>
    <p>explicitly specified</p>
    <p>as part o f a temp</p>
    <p>late.</p>
    <p>In [9], th e authors</p>
    <p>consider invariant</p>
    <p>s of the f orm E</p>
    <p>n j=1</p>
    <p>Uj(Fj  ej), w here</p>
    <p>E, Fj and ej must be</p>
    <p>quantifie r free fini</p>
    <p>te conjuc tions of a</p>
    <p>tomic fac ts.</p>
    <p>found in fun ction rm pke</p>
    <p>y of driver s/infiniba</p>
    <p>nd/hw/</p>
    <p>ipath/ipat h mad.c in L</p>
    <p>inux 2.6.28</p>
  </div>
  <div class="page">
    <p>Algorithmic Learning: CDNF Algorithm</p>
  </div>
  <div class="page">
    <p>CDNF Algorithm</p>
    <p>Query</p>
    <p>CDNF Algorithm</p>
    <p>Answer</p>
    <p>...</p>
    <p>Query</p>
    <p>Answer</p>
    <p>Teacher</p>
    <p>Boolean Formula</p>
    <p>Actively learning a Boolean formula from membership and equivalence queries</p>
    <p>(polynomial # of queries in and # of variables)</p>
    <p>Teacher is required</p>
    <p>Result</p>
    <p>Bshouty, N.H.: Exact learning boolean functions via the monotone theory. Information and Computation 123 (1995) 146153</p>
    <p>Deriving Invariants by Algorithmic Learning, Decision Procedures, and Predicate Abstraction1</p>
    <p>Yungbum Jung and Soonho Kong and Bow-Yaw Wang and Kwangkeun Yi</p>
    <p>School of Computer Science and Engineering, Seoul National University</p>
    <p>{dreameye,soon,kwang}@ropas.snu.ac.kr</p>
    <p>Institute of Information Science, Academia Sinica</p>
    <p>bywang@iis.sinica.edu.tw</p>
    <p>We present a novel technique for finding loop invariants in propositional formulae by com</p>
    <p>bining algorithmic learning, decision procedures, and predicate abstraction. Given invariant</p>
    <p>approximations derived from pre- and post-conditions, our new technique exploits the flexibil</p>
    <p>ity in invariants by a simple randomized mechanism.</p>
    <p>Algorithmic learning has been applied to assumption generation in compositional reasoning.</p>
    <p>In contrast to traditional techniques, the learning approach does not derive assumptions in an</p>
    <p>off-line manner. It instead finds assumptions by interacting with a model checker progressively. Since assumptions in compositional reasoning are generally not unique, algorithmic learning can</p>
    <p>exploit the flexibility in assumptions to attain preferable solutions. Applications in verifying</p>
    <p>concurrent systems have been reported.</p>
    <p>Finding loop invariants follows a similar pattern. Invariants are often not unique. Indeed,</p>
    <p>programmers derive invariants incrementally. They usually have their guesses of invariants in</p>
    <p>mind, and gradually refine their guesses by observing program behavior more. Since in practice</p>
    <p>there are many invariants for given pre- and post-conditions, programmers have more freedom in</p>
    <p>deriving invariants. Yet traditional invariant generation techniques do not exploit the flexibility.</p>
    <p>They have a similar impediment to traditional assumption generation.</p>
    <p>We report our first findings in applying algorithmic learning to invariant generation. We</p>
    <p>show that the three technologies (algorithmic learning, decision procedures, and predicate ab</p>
    <p>straction) can be arranged in concert to derive loop invariants in propositional (or, quantifier</p>
    <p>free) formulae. The new technique is able to generate invariants for some Linux device drivers</p>
    <p>and SPEC2000 benchmarks without any help from static or dynamic analyses.</p>
    <p>For a while loop, an exact learning algorithm for Boolean formulae searches for invariants</p>
    <p>by asking queries. Queries can be resolved (not always, see below) by decision procedures</p>
    <p>automatically. Recall that the learning algorithm generates only Boolean formulae but deci</p>
    <p>sion procedures work in propositional formulae. We thus perform predicate abstraction and</p>
    <p>concretization to integrate the two components.</p>
    <p>In reality, information about loop invariant is incomplete. Queries may not be resolvable</p>
    <p>due to insufficient information. One striking feature of our learning approach is to exploit the flexibility in invariants. When query resolution requires information unavailable to decision</p>
    <p>procedures, we simply give a random answer. We surely could use static analysis to compute</p>
    <p>soundly approximated information other than random answers. Yet there are so many invariants</p>
    <p>for the given pre- and post-conditions. A little bit of incorrect information does not prevent</p>
    <p>algorithmic learning from inferring correct invariants. Indeed, the learning algorithm is able to</p>
    <p>derive invariants in our experiments by coin tossing.</p>
    <p>The technique can be seen as a framework for invariant generation. Static analyzers can</p>
    <p>contribute by providing information to algorithmic learning. Ours is hence orthogonal to existing</p>
    <p>techniques.</p>
    <p>Deriving Invariants by Algorithmic Learning, Decision Procedures, and Predicate Abstraction1</p>
    <p>Yungbum Jung and Soonho Kong and Bow-Yaw Wang and Kwangkeun Yi</p>
    <p>School of Computer Science and Engineering, Seoul National University</p>
    <p>{dreameye,soon,kwang}@ropas.snu.ac.kr</p>
    <p>Institute of Information Science, Academia Sinica</p>
    <p>bywang@iis.sinica.edu.tw</p>
    <p>We present a novel technique for finding loop invariants in propositional formulae by com</p>
    <p>bining algorithmic learning, decision procedures, and predicate abstraction. Given invariant</p>
    <p>approximations derived from pre- and post-conditions, our new technique exploits the flexibil</p>
    <p>ity in invariants by a simple randomized mechanism.</p>
    <p>Algorithmic learning has been applied to assumption generation in compositional reasoning.</p>
    <p>In contrast to traditional techniques, the learning approach does not derive assumptions in an</p>
    <p>off-line manner. It instead finds assumptions by interacting with a model checker progressively. Since assumptions in compositional reasoning are generally not unique, algorithmic learning can</p>
    <p>exploit the flexibility in assumptions to attain preferable solutions. Applications in verifying</p>
    <p>concurrent systems have been reported.</p>
    <p>Finding loop invariants follows a similar pattern. Invariants are often not unique. Indeed,</p>
    <p>programmers derive invariants incrementally. They usually have their guesses of invariants in</p>
    <p>mind, and gradually refine their guesses by observing program behavior more. Since in practice</p>
    <p>there are many invariants for given pre- and post-conditions, programmers have more freedom in</p>
    <p>deriving invariants. Yet traditional invariant generation techniques do not exploit the flexibility.</p>
    <p>They have a similar impediment to traditional assumption generation.</p>
    <p>We report our first findings in applying algorithmic learning to invariant generation. We</p>
    <p>show that the three technologies (algorithmic learning, decision procedures, and predicate ab</p>
    <p>straction) can be arranged in concert to derive loop invariants in propositional (or, quantifier</p>
    <p>free) formulae. The new technique is able to generate invariants for some Linux device drivers</p>
    <p>and SPEC2000 benchmarks without any help from static or dynamic analyses.</p>
    <p>For a while loop, an exact learning algorithm for Boolean formulae searches for invariants</p>
    <p>by asking queries. Queries can be resolved (not always, see below) by decision procedures</p>
    <p>automatically. Recall that the learning algorithm generates only Boolean formulae but deci</p>
    <p>sion procedures work in propositional formulae. We thus perform predicate abstraction and</p>
    <p>concretization to integrate the two components.</p>
    <p>In reality, information about loop invariant is incomplete. Queries may not be resolvable</p>
    <p>due to insufficient information. One striking feature of our learning approach is to exploit the flexibility in invariants. When query resolution requires information unavailable to decision</p>
    <p>procedures, we simply give a random answer. We surely could use static analysis to compute</p>
    <p>soundly approximated information other than random answers. Yet there are so many invariants</p>
    <p>for the given pre- and post-conditions. A little bit of incorrect information does not prevent</p>
    <p>algorithmic learning from inferring correct invariants. Indeed, the learning algorithm is able to</p>
    <p>derive invariants in our experiments by coin tossing.</p>
    <p>The technique can be seen as a framework for invariant generation. Static analyzers can</p>
    <p>contribute by providing information to algorithmic learning. Ours is hence orthogonal to existing</p>
    <p>techniques.</p>
    <p>||</p>
    <p>CDNF Algorithm</p>
    <p>Query</p>
    <p>CDNF Algorithm</p>
    <p>Answer</p>
    <p>...</p>
    <p>Query</p>
    <p>Answer</p>
    <p>Teacher</p>
    <p>Boolean Formula</p>
    <p>Actively learning a Boolean formula from membership and equivalence queries</p>
    <p>(polynomial # of queries in and # of variables)</p>
    <p>Teacher is required</p>
    <p>Result</p>
    <p>Bshouty, N.H.: Exact learning boolean functions via the monotone theory. Information and Computation 123 (1995) 146153</p>
    <p>Deriving Invariants by Algorithmic Learning, Decision Procedures, and Predicate Abstraction1</p>
    <p>Yungbum Jung and Soonho Kong and Bow-Yaw Wang and Kwangkeun Yi</p>
    <p>School of Computer Science and Engineering, Seoul National University</p>
    <p>{dreameye,soon,kwang}@ropas.snu.ac.kr</p>
    <p>Institute of Information Science, Academia Sinica</p>
    <p>bywang@iis.sinica.edu.tw</p>
    <p>We present a novel technique for finding loop invariants in propositional formulae by com</p>
    <p>bining algorithmic learning, decision procedures, and predicate abstraction. Given invariant</p>
    <p>approximations derived from pre- and post-conditions, our new technique exploits the flexibil</p>
    <p>ity in invariants by a simple randomized mechanism.</p>
    <p>Algorithmic learning has been applied to assumption generation in compositional reasoning.</p>
    <p>In contrast to traditional techniques, the learning approach does not derive assumptions in an</p>
    <p>off-line manner. It instead finds assumptions by interacting with a model checker progressively. Since assumptions in compositional reasoning are generally not unique, algorithmic learning can</p>
    <p>exploit the flexibility in assumptions to attain preferable solutions. Applications in verifying</p>
    <p>concurrent systems have been reported.</p>
    <p>Finding loop invariants follows a similar pattern. Invariants are often not unique. Indeed,</p>
    <p>programmers derive invariants incrementally. They usually have their guesses of invariants in</p>
    <p>mind, and gradually refine their guesses by observing program behavior more. Since in practice</p>
    <p>there are many invariants for given pre- and post-conditions, programmers have more freedom in</p>
    <p>deriving invariants. Yet traditional invariant generation techniques do not exploit the flexibility.</p>
    <p>They have a similar impediment to traditional assumption generation.</p>
    <p>We report our first findings in applying algorithmic learning to invariant generation. We</p>
    <p>show that the three technologies (algorithmic learning, decision procedures, and predicate ab</p>
    <p>straction) can be arranged in concert to derive loop invariants in propositional (or, quantifier</p>
    <p>free) formulae. The new technique is able to generate invariants for some Linux device drivers</p>
    <p>and SPEC2000 benchmarks without any help from static or dynamic analyses.</p>
    <p>For a while loop, an exact learning algorithm for Boolean formulae searches for invariants</p>
    <p>by asking queries. Queries can be resolved (not always, see below) by decision procedures</p>
    <p>automatically. Recall that the learning algorithm generates only Boolean formulae but deci</p>
    <p>sion procedures work in propositional formulae. We thus perform predicate abstraction and</p>
    <p>concretization to integrate the two components.</p>
    <p>In reality, information about loop invariant is incomplete. Queries may not be resolvable</p>
    <p>due to insufficient information. One striking feature of our learning approach is to exploit the flexibility in invariants. When query resolution requires information unavailable to decision</p>
    <p>procedures, we simply give a random answer. We surely could use static analysis to compute</p>
    <p>soundly approximated information other than random answers. Yet there are so many invariants</p>
    <p>for the given pre- and post-conditions. A little bit of incorrect information does not prevent</p>
    <p>algorithmic learning from inferring correct invariants. Indeed, the learning algorithm is able to</p>
    <p>derive invariants in our experiments by coin tossing.</p>
    <p>The technique can be seen as a framework for invariant generation. Static analyzers can</p>
    <p>contribute by providing information to algorithmic learning. Ours is hence orthogonal to existing</p>
    <p>techniques.</p>
    <p>Deriving Invariants by Algorithmic Learning, Decision Procedures, and Predicate Abstraction1</p>
    <p>Yungbum Jung and Soonho Kong and Bow-Yaw Wang and Kwangkeun Yi</p>
    <p>School of Computer Science and Engineering, Seoul National University</p>
    <p>{dreameye,soon,kwang}@ropas.snu.ac.kr</p>
    <p>Institute of Information Science, Academia Sinica</p>
    <p>bywang@iis.sinica.edu.tw</p>
    <p>We present a novel technique for finding loop invariants in propositional formulae by com</p>
    <p>bining algorithmic learning, decision procedures, and predicate abstraction. Given invariant</p>
    <p>approximations derived from pre- and post-conditions, our new technique exploits the flexibil</p>
    <p>ity in invariants by a simple randomized mechanism.</p>
    <p>Algorithmic learning has been applied to assumption generation in compositional reasoning.</p>
    <p>In contrast to traditional techniques, the learning approach does not derive assumptions in an</p>
    <p>off-line manner. It instead finds assumptions by interacting with a model checker progressively. Since assumptions in compositional reasoning are generally not unique, algorithmic learning can</p>
    <p>exploit the flexibility in assumptions to attain preferable solutions. Applications in verifying</p>
    <p>concurrent systems have been reported.</p>
    <p>Finding loop invariants follows a similar pattern. Invariants are often not unique. Indeed,</p>
    <p>programmers derive invariants incrementally. They usually have their guesses of invariants in</p>
    <p>mind, and gradually refine their guesses by observing program behavior more. Since in practice</p>
    <p>there are many invariants for given pre- and post-conditions, programmers have more freedom in</p>
    <p>deriving invariants. Yet traditional invariant generation techniques do not exploit the flexibility.</p>
    <p>They have a similar impediment to traditional assumption generation.</p>
    <p>We report our first findings in applying algorithmic learning to invariant generation. We</p>
    <p>show that the three technologies (algorithmic learning, decision procedures, and predicate ab</p>
    <p>straction) can be arranged in concert to derive loop invariants in propositional (or, quantifier</p>
    <p>free) formulae. The new technique is able to generate invariants for some Linux device drivers</p>
    <p>and SPEC2000 benchmarks without any help from static or dynamic analyses.</p>
    <p>For a while loop, an exact learning algorithm for Boolean formulae searches for invariants</p>
    <p>by asking queries. Queries can be resolved (not always, see below) by decision procedures</p>
    <p>automatically. Recall that the learning algorithm generates only Boolean formulae but deci</p>
    <p>sion procedures work in propositional formulae. We thus perform predicate abstraction and</p>
    <p>concretization to integrate the two components.</p>
    <p>In reality, information about loop invariant is incomplete. Queries may not be resolvable</p>
    <p>due to insufficient information. One striking feature of our learning approach is to exploit the flexibility in invariants. When query resolution requires information unavailable to decision</p>
    <p>procedures, we simply give a random answer. We surely could use static analysis to compute</p>
    <p>soundly approximated information other than random answers. Yet there are so many invariants</p>
    <p>for the given pre- and post-conditions. A little bit of incorrect information does not prevent</p>
    <p>algorithmic learning from inferring correct invariants. Indeed, the learning algorithm is able to</p>
    <p>derive invariants in our experiments by coin tossing.</p>
    <p>The technique can be seen as a framework for invariant generation. Static analyzers can</p>
    <p>contribute by providing information to algorithmic learning. Ours is hence orthogonal to existing</p>
    <p>techniques.</p>
    <p>||</p>
  </div>
  <div class="page">
    <p>Membership Query Membership Query asks whether Boolean assignment satisfies the Boolean formula</p>
    <p>MEM ()</p>
    <p>MEM () = Yes if  |=  MEM () = No if  |=</p>
    <p>Example: XOR function</p>
    <p>MEM({b1 = T, b2 = F}) = Yes</p>
    <p>MEM({b1 = T, b2 = T}) = No</p>
    <p>T  F = T</p>
    <p>T  T = F</p>
    <p>= b1  b2</p>
    <p>Membership Query Membership Query asks whether Boolean assignment satisfies the Boolean formula</p>
    <p>MEM ()</p>
    <p>MEM () = Yes if  |=  MEM () = No if  |=</p>
    <p>Example: XOR function</p>
    <p>MEM({b1 = T, b2 = F}) = Yes</p>
    <p>MEM({b1 = T, b2 = T}) = No</p>
    <p>T  F = T</p>
    <p>T  T = F</p>
    <p>= b1  b2</p>
    <p>Yes</p>
    <p>No</p>
  </div>
  <div class="page">
    <p>Equivalence Query Equivalence Query asks whether the guessed Boolean formula is equivalent to ..</p>
    <p>EQ()</p>
    <p>if</p>
    <p>Yes EQ(b1  b2  b1  b2) = Yes Example: XOR function = b1  b2 EQ((b1  b2)  (b1  b2)) = Yes</p>
  </div>
  <div class="page">
    <p>Equivalence Query</p>
    <p>if</p>
    <p>Yes</p>
    <p>if     ( |=   )</p>
    <p>No with</p>
    <p>Otherwise, the teacher needs to provide a truth assignment as a counterexample .</p>
    <p>Example: XOR function</p>
    <p>Example: XOR function</p>
    <p>=</p>
    <p>=</p>
    <p>b1  b2</p>
    <p>b1  b2</p>
    <p>T  T = F T  T = T</p>
    <p>EQ(b1  b2) = No with {b1 = T, b2 = T}</p>
    <p>Equivalence Query asks whether the guessed Boolean formula is equivalent to ..</p>
    <p>EQ()</p>
    <p>EQ(b1  b2  b1  b2) = YesEQ((b1  b2)  (b1  b2)) = Yes</p>
  </div>
  <div class="page">
    <p>Goal</p>
    <p>Query</p>
    <p>CDNF Algorithm</p>
    <p>Answer</p>
    <p>... Query</p>
    <p>Answer</p>
    <p>Teacher for</p>
    <p>an Invariant</p>
    <p>A Loop Invariant</p>
    <p>Result</p>
    <p>Implement a Teacher to guide CDNF algorithm infer an Invariant</p>
    <p>Implementing a Teacher for guiding CDNF algorithm to find a quantified invariant</p>
    <p>Goal</p>
  </div>
  <div class="page">
    <p>Automated Technique Input</p>
    <p>Annotated Loop (Pre-/Post-conditions)</p>
    <p>Decision Procedures</p>
    <p>Algorithmic Learning</p>
    <p>Query</p>
    <p>Answer</p>
    <p>Query</p>
    <p>Answer . .</p>
    <p>.</p>
    <p>Predicate Abstraction Boolean</p>
    <p>Formulae Quantified Formulae</p>
    <p>InputAtomic Propositions</p>
    <p>Output</p>
    <p>A Loop Invariant (Quantified Formulae)</p>
    <p>i.[i &lt; n  A[i] = 0]</p>
    <p>First Issue</p>
    <p>Templates</p>
    <p>Templates Input</p>
    <p>k.[ ] (SMT solvers)</p>
  </div>
  <div class="page">
    <p>Automated Technique Input</p>
    <p>Annotated Loop (Pre-/Post-conditions)</p>
    <p>Decision Procedures</p>
    <p>Algorithmic Learning</p>
    <p>Query</p>
    <p>Answer</p>
    <p>Query</p>
    <p>Answer . .</p>
    <p>.</p>
    <p>Predicate Abstraction Boolean</p>
    <p>Formulae Quantified Formulae</p>
    <p>InputAtomic Propositions</p>
    <p>Output</p>
    <p>A Loop Invariant (Quantified Formulae)</p>
    <p>i.[i &lt; n  A[i] = 0]</p>
    <p>First Issue</p>
    <p>Templates</p>
    <p>Templates Input</p>
    <p>k.[ ] (SMT solvers)</p>
  </div>
  <div class="page">
    <p>Relating Domains</p>
    <p>We want to find a Quantified invariant while the CDNF algorithm finds a Boolean formula.</p>
    <p>Problem:</p>
    <p>Boolean Formula</p>
    <p>Quantified Formula</p>
    <p>Propositional Formula</p>
    <p>VMCAI10APLAS10</p>
    <p>Templates</p>
    <p>k.k &lt; i  a[k]  a[m] k &lt; i  a[k]  a[m] bk&lt;i  ba[k]a[m]</p>
    <p>k.[ ] Predicate Abstraction</p>
  </div>
  <div class="page">
    <p>Quantified Formula Boolean Formula</p>
    <p>Teacher CDNF Algorithm</p>
    <p>Answering Queries</p>
    <p>k.k &lt; i  a[k]  a[m] bk&lt;i  ba[k]a[m]</p>
  </div>
  <div class="page">
    <p>Quantified Formula Boolean Formula</p>
    <p>Teacher CDNF Algorithm</p>
    <p>Answering Queries</p>
    <p>Yes Yes</p>
    <p>If teacher says Yes then it should really mean Yes</p>
    <p>k.k &lt; i  a[k]  a[m] bk&lt;i  ba[k]a[m]</p>
  </div>
  <div class="page">
    <p>Quantified Formula Boolean Formula</p>
    <p>Teacher CDNF Algorithm</p>
    <p>Answering Queries</p>
    <p>Yes Yes</p>
    <p>If teacher says Yes then it should really mean Yes</p>
    <p>No No</p>
    <p>If teacher says No then it should really mean No</p>
    <p>k.k &lt; i  a[k]  a[m] bk&lt;i  ba[k]a[m]</p>
  </div>
  <div class="page">
    <p>Answering Queries</p>
    <p>if t[1]  t[2] then 1  2 If teacher says Yes then it should really mean Yes</p>
    <p>If teacher says No then it should really mean No if t[1]  t[2] then 1  2</p>
  </div>
  <div class="page">
    <p>Answering Queries</p>
    <p>if t[1]  t[2] then 1  2 If teacher says Yes then it should really mean Yes</p>
    <p>If teacher says No then it should really mean No if t[1]  t[2] then 1  2</p>
  </div>
  <div class="page">
    <p>Answering Queries</p>
    <p>if t[1]  t[2] then 1  2 If teacher says Yes then it should really mean Yes</p>
    <p>If teacher says No then it should really mean No if t[1]  t[2] then 1  2</p>
    <p>A Counter Example</p>
    <p>if i.i &lt; 10  i.i &lt; 1 then i &lt; 10  i &lt; 1i &lt; 10  i &lt; 1</p>
  </div>
  <div class="page">
    <p>Answering Queries</p>
    <p>if t[1]  t[2] then 1  2 If teacher says Yes then it should really mean Yes</p>
    <p>If teacher says No then it should really mean No if t[1]  t[2] then 1  2</p>
    <p>A Counter Example</p>
    <p>if i.i &lt; 10  i.i &lt; 1 then i &lt; 10  i &lt; 1i &lt; 10  i &lt; 1</p>
  </div>
  <div class="page">
    <p>Answering Queries</p>
    <p>if t[1]  t[2] then 1  2 If teacher says Yes then it should really mean Yes</p>
    <p>If teacher says No then it should really mean No if t[1]  t[2] then 1  2</p>
    <p>A Counter Example</p>
    <p>if i.i &lt; 10  i.i &lt; 1 then i &lt; 10  i &lt; 1i &lt; 10  i &lt; 1</p>
  </div>
  <div class="page">
    <p>Answering Queries</p>
    <p>if t[1]  t[2] then 1  2 If teacher says Yes then it should really mean Yes</p>
    <p>If teacher says No then it should really mean No if t[1]  t[2] then 1  2</p>
    <p>Well-formedness condition</p>
    <p>A Counter Example</p>
    <p>if i.i &lt; 10  i.i &lt; 1 then i &lt; 10  i &lt; 1i &lt; 10  i &lt; 1</p>
  </div>
  <div class="page">
    <p>Second Issue</p>
    <p>The teacher is asked to answer questions about invariants without knowing invariants.</p>
    <p>Problem:</p>
  </div>
  <div class="page">
    <p>Second Issue</p>
    <p>The teacher is asked to answer questions about invariants without knowing invariants.</p>
    <p>Problem:</p>
    <p>We use approximations and random answers</p>
    <p>Solution:</p>
  </div>
  <div class="page">
    <p>Invariant Properties For the annotated loop</p>
    <p>An Invariant I must satisfy all the following conditions:</p>
    <p>(A) ( holds when entering the loop)</p>
    <p>(B) ( holds at each iteration)</p>
    <p>(C) ( gives after leaving the loop)</p>
    <p>Let   PropA be a quantifier-free formula. We write t[] to denote the first-order formula obtained by replacing the hole in t[] with . Observe that any first-order formula can be transformed into the prenex normal form; it can be expressed in</p>
    <p>the form of a proper template.</p>
    <p>A precondition Pre(, S) for   Pred with respect to a statement S is a first-order formula that guarantees  after the execution of the statement S. Let {} while  do S {} be an annotated loop and t[]   be a template. The invariant generation problem with template t[] is to compute a first-order formula t[] such that (1)   t[]; (2)   t[]  ; and (3)   t[]  Pre(t[], S). Observe that the condition (2) is equivalent to t[]  . We have   t[] and t[]   for any invariant t[].  and  are subsequently called the strongest under-approximation and weakest over-approximation to invariants respectively.</p>
    <p>A valuation  is an assignment of natural numbers to integer variables and truth values to Boolean variables. If A is a set of atomic propositions and Var(A) is the set of variables occurred in A, ValVar(A) denotes the set of valuations for Var(A). A valuation  is a model of a first-order formula  (written  |= ) if  evaluates to T under . Let B be a set of Boolean variables. We write BoolB for the class of Boolean formulae over Boolean variables B. A Boolean valuation  is an assignment of truth values to Boolean variables. The set of Boolean valuations</p>
    <p>for B is denoted by ValB. A Boolean valuation  is a Boolean model of the Boolean formula  (written  |= ) if  evaluates to T under .</p>
    <p>Given a first-order formula , a satisfiability modulo theories (SMT) solver [6,16] returns a model of  if it exists. In general, SMT solver is incomplete over quan</p>
    <p>tified formulae and may return a potential model (written SMT() ! ). It</p>
    <p>returns UNSAT (written SMT()  UNSAT) if the solver proves the formula unsatisfiable. Note that an SMT solver can only err when it returns a (potential)</p>
    <p>model. If UNSAT is returned, the input formula is certainly unsatisfiable.</p>
    <p>CDNF Learning Algorithm [3] The CDNF (Conjunctive Disjunctive Normal Form) algorithm is an exact algorithm that computes a representation for any</p>
    <p>target   BoolB by asking a teacher queries. The teacher is required to resolve two types of queries:</p>
    <p>Membership query MEM () where   ValB. If the valuation  is a Boolean model of the target Boolean formula , the teacher answers YES. Otherwise, the teacher answers NO;</p>
    <p>Equivalence query EQ() where   BoolB. If the target Boolean formula  is equivalent to , the teacher answers YES. Otherwise, the teacher gives a counterexample. A counterexample is a valuation   ValB such that  and  evaluate to different truth values under .</p>
    <p>For a Boolean formula   BoolB, define ||CNF and ||DNF to be the sizes of minimal Boolean formulae equivalent to  in conjunctive and disjunctive normal forms respectively. The CDNF algorithm infers any target Boolean formula</p>
    <p>BoolB with a polynomial number of queries in ||CNF , ||DNF , and |B| [3].</p>
    <p>I I I</p>
    <p>II     I    Pre(I, S)</p>
  </div>
  <div class="page">
    <p>Invariant Properties For the annotated loop</p>
    <p>An Invariant I must satisfy all the following conditions:</p>
    <p>(A) ( holds when entering the loop)</p>
    <p>(B) ( holds at each iteration)</p>
    <p>(C) ( gives after leaving the loop)</p>
    <p>Observation #1 In equivalence query we can say YES by checking these conditions.</p>
    <p>Let   PropA be a quantifier-free formula. We write t[] to denote the first-order formula obtained by replacing the hole in t[] with . Observe that any first-order formula can be transformed into the prenex normal form; it can be expressed in</p>
    <p>the form of a proper template.</p>
    <p>A precondition Pre(, S) for   Pred with respect to a statement S is a first-order formula that guarantees  after the execution of the statement S. Let {} while  do S {} be an annotated loop and t[]   be a template. The invariant generation problem with template t[] is to compute a first-order formula t[] such that (1)   t[]; (2)   t[]  ; and (3)   t[]  Pre(t[], S). Observe that the condition (2) is equivalent to t[]  . We have   t[] and t[]   for any invariant t[].  and  are subsequently called the strongest under-approximation and weakest over-approximation to invariants respectively.</p>
    <p>A valuation  is an assignment of natural numbers to integer variables and truth values to Boolean variables. If A is a set of atomic propositions and Var(A) is the set of variables occurred in A, ValVar(A) denotes the set of valuations for Var(A). A valuation  is a model of a first-order formula  (written  |= ) if  evaluates to T under . Let B be a set of Boolean variables. We write BoolB for the class of Boolean formulae over Boolean variables B. A Boolean valuation  is an assignment of truth values to Boolean variables. The set of Boolean valuations</p>
    <p>for B is denoted by ValB. A Boolean valuation  is a Boolean model of the Boolean formula  (written  |= ) if  evaluates to T under .</p>
    <p>Given a first-order formula , a satisfiability modulo theories (SMT) solver [6,16] returns a model of  if it exists. In general, SMT solver is incomplete over quan</p>
    <p>tified formulae and may return a potential model (written SMT() ! ). It</p>
    <p>returns UNSAT (written SMT()  UNSAT) if the solver proves the formula unsatisfiable. Note that an SMT solver can only err when it returns a (potential)</p>
    <p>model. If UNSAT is returned, the input formula is certainly unsatisfiable.</p>
    <p>CDNF Learning Algorithm [3] The CDNF (Conjunctive Disjunctive Normal Form) algorithm is an exact algorithm that computes a representation for any</p>
    <p>target   BoolB by asking a teacher queries. The teacher is required to resolve two types of queries:</p>
    <p>Membership query MEM () where   ValB. If the valuation  is a Boolean model of the target Boolean formula , the teacher answers YES. Otherwise, the teacher answers NO;</p>
    <p>Equivalence query EQ() where   BoolB. If the target Boolean formula  is equivalent to , the teacher answers YES. Otherwise, the teacher gives a counterexample. A counterexample is a valuation   ValB such that  and  evaluate to different truth values under .</p>
    <p>For a Boolean formula   BoolB, define ||CNF and ||DNF to be the sizes of minimal Boolean formulae equivalent to  in conjunctive and disjunctive normal forms respectively. The CDNF algorithm infers any target Boolean formula</p>
    <p>BoolB with a polynomial number of queries in ||CNF , ||DNF , and |B| [3].</p>
    <p>I I I</p>
    <p>II     I    Pre(I, S)</p>
  </div>
  <div class="page">
    <p>Invariant Properties For the annotated loop</p>
    <p>An Invariant I must satisfy all the following conditions:</p>
    <p>(A) ( holds when entering the loop)</p>
    <p>(B) ( holds at each iteration)</p>
    <p>(C) ( gives after leaving the loop)</p>
    <p>Observation #1 In equivalence query we can say YES by checking these conditions.</p>
    <p>Let   PropA be a quantifier-free formula. We write t[] to denote the first-order formula obtained by replacing the hole in t[] with . Observe that any first-order formula can be transformed into the prenex normal form; it can be expressed in</p>
    <p>the form of a proper template.</p>
    <p>A precondition Pre(, S) for   Pred with respect to a statement S is a first-order formula that guarantees  after the execution of the statement S. Let {} while  do S {} be an annotated loop and t[]   be a template. The invariant generation problem with template t[] is to compute a first-order formula t[] such that (1)   t[]; (2)   t[]  ; and (3)   t[]  Pre(t[], S). Observe that the condition (2) is equivalent to t[]  . We have   t[] and t[]   for any invariant t[].  and  are subsequently called the strongest under-approximation and weakest over-approximation to invariants respectively.</p>
    <p>A valuation  is an assignment of natural numbers to integer variables and truth values to Boolean variables. If A is a set of atomic propositions and Var(A) is the set of variables occurred in A, ValVar(A) denotes the set of valuations for Var(A). A valuation  is a model of a first-order formula  (written  |= ) if  evaluates to T under . Let B be a set of Boolean variables. We write BoolB for the class of Boolean formulae over Boolean variables B. A Boolean valuation  is an assignment of truth values to Boolean variables. The set of Boolean valuations</p>
    <p>for B is denoted by ValB. A Boolean valuation  is a Boolean model of the Boolean formula  (written  |= ) if  evaluates to T under .</p>
    <p>Given a first-order formula , a satisfiability modulo theories (SMT) solver [6,16] returns a model of  if it exists. In general, SMT solver is incomplete over quan</p>
    <p>tified formulae and may return a potential model (written SMT() ! ). It</p>
    <p>returns UNSAT (written SMT()  UNSAT) if the solver proves the formula unsatisfiable. Note that an SMT solver can only err when it returns a (potential)</p>
    <p>model. If UNSAT is returned, the input formula is certainly unsatisfiable.</p>
    <p>CDNF Learning Algorithm [3] The CDNF (Conjunctive Disjunctive Normal Form) algorithm is an exact algorithm that computes a representation for any</p>
    <p>target   BoolB by asking a teacher queries. The teacher is required to resolve two types of queries:</p>
    <p>Membership query MEM () where   ValB. If the valuation  is a Boolean model of the target Boolean formula , the teacher answers YES. Otherwise, the teacher answers NO;</p>
    <p>Equivalence query EQ() where   BoolB. If the target Boolean formula  is equivalent to , the teacher answers YES. Otherwise, the teacher gives a counterexample. A counterexample is a valuation   ValB such that  and  evaluate to different truth values under .</p>
    <p>For a Boolean formula   BoolB, define ||CNF and ||DNF to be the sizes of minimal Boolean formulae equivalent to  in conjunctive and disjunctive normal forms respectively. The CDNF algorithm infers any target Boolean formula</p>
    <p>BoolB with a polynomial number of queries in ||CNF , ||DNF , and |B| [3].</p>
    <p>I I I</p>
    <p>II     I    Pre(I, S)</p>
    <p>strongest under-approximation</p>
    <p>of an invariant</p>
    <p>weakest over-approximation</p>
    <p>of an invariant</p>
    <p>I     Observation #2</p>
  </div>
  <div class="page">
    <p>Equivalence Query Resolution</p>
    <p>(A) ( holds when entering the loop)</p>
    <p>(B) ( holds at each iteration)</p>
    <p>(C) ( gives after leaving the loop)</p>
    <p>I I I</p>
    <p>II     I    Pre(I, S)</p>
  </div>
  <div class="page">
    <p>No</p>
    <p>Guess</p>
    <p>No, with found a counterexample</p>
    <p>Equivalence Query Resolution</p>
    <p>Under Approximation Over Approximation</p>
    <p>Case 1</p>
  </div>
  <div class="page">
    <p>No, with found a counterexample</p>
    <p>Equivalence Query Resolution</p>
    <p>Under Approximation Over Approximation</p>
    <p>Guess</p>
    <p>No</p>
    <p>Case 2</p>
  </div>
  <div class="page">
    <p>No, with found a counterexample</p>
    <p>Equivalence Query Resolution</p>
    <p>Under Approximation Over Approximation</p>
    <p>Guess</p>
    <p>No</p>
    <p>Case 1 &amp; 2</p>
    <p>No</p>
  </div>
  <div class="page">
    <p>No, with found a counterexample</p>
    <p>Equivalence Query Resolution</p>
    <p>Under Approximation Over Approximation</p>
    <p>Guess</p>
    <p>No</p>
    <p>Case 1 &amp; 2</p>
    <p>No</p>
    <p>Guess</p>
    <p>Case 3</p>
    <p>Cannot find a counterexample.</p>
  </div>
  <div class="page">
    <p>No, with found a counterexample</p>
    <p>Equivalence Query Resolution</p>
    <p>Guess</p>
    <p>No</p>
    <p>Case 1 &amp; 2</p>
    <p>No</p>
    <p>Guess</p>
    <p>Case 3</p>
    <p>A random counterexample.</p>
    <p>No No</p>
    <p>Case 3</p>
    <p>?</p>
    <p>()</p>
    <p>Unknown</p>
    <p>Random Answer!Answer Yes / No</p>
    <p>Yes</p>
    <p>No</p>
    <p>Case 1 &amp; 2</p>
    <p>()</p>
    <p>Membership Query Resolution: MEM ()</p>
  </div>
  <div class="page">
    <p>Membership Query Resolution</p>
    <p>i = 0  i = 1</p>
  </div>
  <div class="page">
    <p>Membership Query Resolution</p>
    <p>Answer Yes</p>
    <p>Yes</p>
    <p>Under Approximation Over Approximation</p>
    <p>model</p>
    <p>Case 1</p>
  </div>
  <div class="page">
    <p>Membership Query Resolution</p>
    <p>Yes</p>
    <p>Under Approximation Over Approximation</p>
    <p>model</p>
    <p>No</p>
    <p>Case 2</p>
    <p>Answer/No</p>
  </div>
  <div class="page">
    <p>Membership Query Resolution</p>
    <p>Yes</p>
    <p>Under Approximation Over Approximation</p>
    <p>No</p>
    <p>Case 1 &amp; 2</p>
    <p>Answer/Yes or No</p>
    <p>Yes</p>
  </div>
  <div class="page">
    <p>Membership Query Resolution</p>
    <p>Yes</p>
    <p>Under Approximation Over Approximation</p>
    <p>model</p>
    <p>No</p>
    <p>Case 1 &amp; 2</p>
    <p>Answer/Yes or No</p>
    <p>Case 3</p>
    <p>? Unknown</p>
    <p>Yes</p>
  </div>
  <div class="page">
    <p>Membership Query Resolution</p>
    <p>Yes</p>
    <p>model</p>
    <p>No</p>
    <p>Case 1 &amp; 2</p>
    <p>Answer/Yes or No</p>
    <p>Case 3</p>
    <p>? Unknown</p>
    <p>Yes</p>
    <p>Answer/Yes or No randomly</p>
    <p>Case 3</p>
    <p>?</p>
    <p>()</p>
    <p>Unknown</p>
    <p>Random Answer!Answer Yes / No</p>
    <p>Yes</p>
    <p>No</p>
    <p>Case 1 &amp; 2</p>
    <p>()</p>
    <p>Membership Query Resolution: MEM ()</p>
  </div>
  <div class="page">
    <p>Effect of Random Answer</p>
    <p>Under Approximation</p>
    <p>Over Approximation</p>
    <p>? Unknown</p>
    <p>Membership Query</p>
    <p>model</p>
  </div>
  <div class="page">
    <p>Effect of Random Answer</p>
    <p>Under Approximation</p>
    <p>Over Approximation</p>
    <p>Invariants</p>
    <p>? Unknown</p>
    <p>Both of the random answers can lead to an invariant.</p>
    <p>Membership Query</p>
    <p>model</p>
    <p>I1</p>
    <p>I2</p>
  </div>
  <div class="page">
    <p>Effect of Random Answer</p>
    <p>Under Approximation</p>
    <p>Over Approximation</p>
    <p>Invariants</p>
    <p>Yes</p>
    <p>Membership Query</p>
    <p>model</p>
    <p>I1</p>
    <p>Yes leads to I1</p>
  </div>
  <div class="page">
    <p>Effect of Random Answer</p>
    <p>Under Approximation</p>
    <p>Over Approximation</p>
    <p>Invariants</p>
    <p>No</p>
    <p>Membership Query</p>
    <p>model</p>
    <p>No leads to</p>
    <p>I2</p>
    <p>I2</p>
  </div>
  <div class="page">
    <p>Random Algorithm</p>
    <p>Random Membership and Equivalence query resolution causes conflict!</p>
    <p>Then we simply restart the whole algorithm Case 3</p>
    <p>?</p>
    <p>()</p>
    <p>Unknown</p>
    <p>Random Answer!Answer Yes / No</p>
    <p>Yes</p>
    <p>No</p>
    <p>Case 1 &amp; 2</p>
    <p>()</p>
    <p>Membership Query Resolution: MEM ()</p>
  </div>
  <div class="page">
    <p>Random Algorithm</p>
    <p>Random Membership and Equivalence query resolution causes conflict!</p>
    <p>Then we simply restart the whole algorithm Case 3</p>
    <p>?</p>
    <p>()</p>
    <p>Unknown</p>
    <p>Random Answer!Answer Yes / No</p>
    <p>Yes</p>
    <p>No</p>
    <p>Case 1 &amp; 2</p>
    <p>()</p>
    <p>Membership Query Resolution: MEM ()</p>
    <p>Memoization could not save the time :( Because the search space is huge</p>
  </div>
  <div class="page">
    <p>Random Algorithm</p>
    <p>Random Membership and Equivalence query resolution causes conflict!</p>
    <p>Then we simply restart the whole algorithm Case 3</p>
    <p>?</p>
    <p>()</p>
    <p>Unknown</p>
    <p>Random Answer!Answer Yes / No</p>
    <p>Yes</p>
    <p>No</p>
    <p>Case 1 &amp; 2</p>
    <p>()</p>
    <p>Membership Query Resolution: MEM ()</p>
    <p>Memoization could not save the time :( Because the search space is huge</p>
    <p>where is #atomic propositionsn</p>
  </div>
  <div class="page">
    <p>We always verify the conditions before say Yes.</p>
    <p>SMT solvers are not complete but sound</p>
    <p>for quantified formulae.</p>
    <p>Its still Sound</p>
    <p>(A) ( holds when entering the loop)</p>
    <p>(B) ( holds at each iteration)</p>
    <p>(C) ( gives after leaving the loop)</p>
    <p>I I I</p>
    <p>II     I    Pre(I, S)</p>
    <p>Why? When resolving equivalence query</p>
  </div>
  <div class="page">
    <p>Experiment Results</p>
    <p>Program Template AP MEM EQ MEM EQ ITER Time</p>
    <p>max 7 5,968 1,742 65% 26% 269 5.7s</p>
    <p>selection_sort 6 9,630 5,832 100% 4% 1,672 9.6s</p>
    <p>devres 7 2,084 1,214 91% 21% 310 0.9s</p>
    <p>rm_pkey 8 2,204 919 67% 20% 107 2.5s</p>
    <p>tracepoint1 4 246 195 61% 25% 31 0.3s</p>
    <p>tracepoint2 7 33,963 13,063 69% 5% 2,088 157.6s</p>
    <p>k.[ ]</p>
    <p>k1.k2.[ ]</p>
    <p>k.[ ]</p>
    <p>k.[ ]</p>
    <p>k.[ ]</p>
    <p>k1.k2.[ ]</p>
    <p>T otal    T otal  Total RandomAverage of 500 runs</p>
  </div>
  <div class="page">
    <p>Experiment Results</p>
    <p>Program Template AP MEM EQ MEM EQ ITER Time</p>
    <p>max 7 5,968 1,742 65% 26% 269 5.7s</p>
    <p>selection_sort 6 9,630 5,832 100% 4% 1,672 9.6s</p>
    <p>devres 7 2,084 1,214 91% 21% 310 0.9s</p>
    <p>rm_pkey 8 2,204 919 67% 20% 107 2.5s</p>
    <p>tracepoint1 4 246 195 61% 25% 31 0.3s</p>
    <p>tracepoint2 7 33,963 13,063 69% 5% 2,088 157.6s</p>
    <p>k.[ ]</p>
    <p>k1.k2.[ ]</p>
    <p>k.[ ]</p>
    <p>k.[ ]</p>
    <p>k.[ ]</p>
    <p>k1.k2.[ ]</p>
    <p>T otal    T otal  Total Random</p>
    <p>Membership Query: After a few equivalence queries, a membership query</p>
    <p>asks whether  {i  n, m = 0, i = 0, k  n, a[k]  a[m], a[m]  a[i]} is a</p>
    <p>part of an invariant. The teacher replies YES since the query is included in</p>
    <p>the precondition and therefore should also be included in an invariant.</p>
    <p>Membership Query: The membership query MEM (  {i &lt; n, m = 0, i =</p>
    <p>In this case, the teacher gives a random answer (YES or NO). Interestingly,</p>
    <p>each answer leads to a different invariant for this query. If the answer is YES, we find an invariant k.(i &lt; nk  i)(a[k]  a[m])(k  n); if the answer is NO, we find another invariant k.(i &lt; n  k  i)  (a[k]  a[m])  (k  n  k  i). This shows how our approach exploits a multitude of invariants for the annotated loop.</p>
    <p>We organize this paper as follows. After preliminaries in Section 2, we present</p>
    <p>problems and solutions in Section 3. Our abstraction is briefly described in</p>
    <p>Section 4. The details of our technique are described in Section 5. We report</p>
    <p>experiments in Section 6, discuss related work in Section 7, then conclude in</p>
    <p>Section 8.</p>
    <p>The abstract syntax of our simple imperative language is given below:</p>
    <p>Stmt  = nop | Stmt; Stmt | x := Exp | b := Prop | a[Exp] := Exp |</p>
    <p>a[Exp] := nondet | x := nondet | b := nondet | if Prop then Stmt else Stmt | { Pred } while Prop do Stmt { Pred }</p>
    <p>Exp  = n | x | a[Exp] | Exp + Exp | Exp  Exp</p>
    <p>Prop  = F | b | Prop | Prop  Prop | Exp &lt; Exp | Exp = Exp</p>
    <p>Pred  = Prop | x.Pred | x.Pred | Pred  Pred | Pred</p>
    <p>The language has two basic types: Booleans and natural numbers. A term in Exp is a natural number; a term in Prop is a quantifier-free formula and of Boolean type; a term in Pred is a first-order formula. The keyword nondet is used for unknown values from users input or complex structures (e.g, pointer operations,</p>
    <p>function calls, etc.). In an annotated loop {} while  do S {},   Prop is its guard, and ,   Pred are its precondition and postcondition respectively. Quantifier-free formulae of the forms b, 0 &lt; 1, and 0 = 1 are called atomic propositions. If A is a set of atomic propositions, then PropA and PredA denote the set of quantifier-free and first-order formulae generated from A, respectively.</p>
    <p>A template t[]   is a finite sequence of quantifiers followed by a hole to be filled with a quantifier-free formula in PropA.</p>
    <p>= [] | I. | I..</p>
    <p>Average of 500 runs</p>
  </div>
  <div class="page">
    <p>Experiment Results</p>
    <p>Program Template AP MEM EQ MEM EQ ITER Time</p>
    <p>max 7 5,968 1,742 65% 26% 269 5.7s</p>
    <p>selection_sort 6 9,630 5,832 100% 4% 1,672 9.6s</p>
    <p>devres 7 2,084 1,214 91% 21% 310 0.9s</p>
    <p>rm_pkey 8 2,204 919 67% 20% 107 2.5s</p>
    <p>tracepoint1 4 246 195 61% 25% 31 0.3s</p>
    <p>tracepoint2 7 33,963 13,063 69% 5% 2,088 157.6s</p>
    <p>k.[ ]</p>
    <p>k1.k2.[ ]</p>
    <p>k.[ ]</p>
    <p>k.[ ]</p>
    <p>k.[ ]</p>
    <p>k1.k2.[ ]</p>
    <p>T otal    T otal  Total Random</p>
    <p>Membership Query: After a few equivalence queries, a membership query</p>
    <p>asks whether  {i  n, m = 0, i = 0, k  n, a[k]  a[m], a[m]  a[i]} is a</p>
    <p>part of an invariant. The teacher replies YES since the query is included in</p>
    <p>the precondition and therefore should also be included in an invariant.</p>
    <p>Membership Query: The membership query MEM (  {i &lt; n, m = 0, i =</p>
    <p>In this case, the teacher gives a random answer (YES or NO). Interestingly,</p>
    <p>each answer leads to a different invariant for this query. If the answer is YES, we find an invariant k.(i &lt; nk  i)(a[k]  a[m])(k  n); if the answer is NO, we find another invariant k.(i &lt; n  k  i)  (a[k]  a[m])  (k  n  k  i). This shows how our approach exploits a multitude of invariants for the annotated loop.</p>
    <p>We organize this paper as follows. After preliminaries in Section 2, we present</p>
    <p>problems and solutions in Section 3. Our abstraction is briefly described in</p>
    <p>Section 4. The details of our technique are described in Section 5. We report</p>
    <p>experiments in Section 6, discuss related work in Section 7, then conclude in</p>
    <p>Section 8.</p>
    <p>The abstract syntax of our simple imperative language is given below:</p>
    <p>Stmt  = nop | Stmt; Stmt | x := Exp | b := Prop | a[Exp] := Exp |</p>
    <p>a[Exp] := nondet | x := nondet | b := nondet | if Prop then Stmt else Stmt | { Pred } while Prop do Stmt { Pred }</p>
    <p>Exp  = n | x | a[Exp] | Exp + Exp | Exp  Exp</p>
    <p>Prop  = F | b | Prop | Prop  Prop | Exp &lt; Exp | Exp = Exp</p>
    <p>Pred  = Prop | x.Pred | x.Pred | Pred  Pred | Pred</p>
    <p>The language has two basic types: Booleans and natural numbers. A term in Exp is a natural number; a term in Prop is a quantifier-free formula and of Boolean type; a term in Pred is a first-order formula. The keyword nondet is used for unknown values from users input or complex structures (e.g, pointer operations,</p>
    <p>function calls, etc.). In an annotated loop {} while  do S {},   Prop is its guard, and ,   Pred are its precondition and postcondition respectively. Quantifier-free formulae of the forms b, 0 &lt; 1, and 0 = 1 are called atomic propositions. If A is a set of atomic propositions, then PropA and PredA denote the set of quantifier-free and first-order formulae generated from A, respectively.</p>
    <p>A template t[]   is a finite sequence of quantifiers followed by a hole to be filled with a quantifier-free formula in PropA.</p>
    <p>= [] | I. | I..</p>
    <p>Average of 500 runs</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Algorithmic Learning + Decision Procedures + Predicate Abstraction + Simple Template =&gt; Quantified Invariant Generation Technique</p>
    <p>Exploits the flexibility in invariants by randomized mechanism.</p>
    <p>Static/Dynamic Analysis can help with tighter approximations on invariants.</p>
    <p>Apply the CDNF algorithm to your own problems.</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Algorithmic Learning + Decision Procedures + Predicate Abstraction + Simple Template =&gt; Quantified Invariant Generation Technique</p>
    <p>Exploits the flexibility in invariants by randomized mechanism.</p>
    <p>Static/Dynamic Analysis can help with tighter approximations on invariants.</p>
    <p>Apply the CDNF algorithm to your own problems.</p>
    <p>Thanks!</p>
  </div>
</Presentation>
