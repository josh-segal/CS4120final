<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Truthful and near-optimal mechanism design via linear</p>
    <p>programming</p>
    <p>Chaitanya Swamy Caltech and U. Waterloo</p>
    <p>Joint work with Ron Lavi Caltech</p>
  </div>
  <div class="page">
    <p>Mechanism Design</p>
    <p>Environment with selfish players who hold the inputs selfish  players only care about maximizing their</p>
    <p>utility</p>
    <p>will lie if that increases their utility  Cannot assume algorithm knows the true inputs.</p>
    <p>Goal: want that algorithms work with respect to the true input</p>
    <p>Mechanism = algorithm + prices to affect players utilities and motivate them to reveal the</p>
    <p>true inputs</p>
  </div>
  <div class="page">
    <p>Combinatorial Auctions (CAs)</p>
    <p>m indivisible non-identical items for sale  n players that compete for subsets of these items  Player i has a valuation vi(S) for each subset S of</p>
    <p>items  vi() = 0</p>
    <p>vi(.) is non-decreasing: vi(S)  vi(T) for S  T</p>
    <p>items {1,, m}</p>
    <p>indivisible item</p>
    <p>players</p>
  </div>
  <div class="page">
    <p>Combinatorial Auctions (CAs)</p>
    <p>m indivisible non-identical items for sale  n players that compete for subsets of these items  Player i has a valuation vi(S) for each subset S of</p>
    <p>items  vi() = 0</p>
    <p>vi(.) is non-decreasing: vi(S)  vi(T) for S  T Goal: Compute an allocation (S1,, Sn) of items to players, where Si Sj = , that maximizes social welfare: i vi(Si).</p>
    <p>Called Social-Welfare Maximization (SWM) problem</p>
    <p>items {1,, m}</p>
    <p>indivisible item</p>
    <p>players</p>
  </div>
  <div class="page">
    <p>SWM for CAs: Main Issues</p>
    <p>Complexity issues  Communication: vi(.)s have exponential</p>
    <p>length. Solving SWM exactly may need exponential communication, polynomial communication forces approximation</p>
    <p>Computation: SWM problem is NP-hard even when each vi(.) has small length, e.g., vi(S) = vi for S Ti for some set Ti, 0 o/w.</p>
  </div>
  <div class="page">
    <p>SWM for CAs: Main Issues Complexity issues</p>
    <p>Communication: Exact solution  exponential communication</p>
    <p>Computation: SWM problem is NP-hard even with short vi(.).</p>
    <p>Strategic issues Players are strategic: may report valuation bi(.) different from</p>
    <p>true input vi(.) Approach problem via Mechanism Design. Mechanism M = (f, {pi}i=1,,n)</p>
    <p>specifies allocation, f: (v1,, vn)  (S1,, Sn) that maximizes i vi(Si).</p>
    <p>pi specifies price charged to player i, pi: (v1,, vn)</p>
  </div>
  <div class="page">
    <p>SWM for CAs: Main Issues Complexity issues</p>
    <p>Communication: Exact solution  exponential communication  Computation: SWM problem is NP-hard even with short vi(.).</p>
    <p>Strategic issues Mechanism M = (f, {pi}i=1,,n) Want: compute f(.) on true input v = (v1,, vn); vi not publicly</p>
    <p>known Mechanism gets bids b=(b1,, bn) and computes</p>
    <p>Allocation: f(b) = (S1,, Sn) Price: pi(b) to charge to each player i</p>
    <p>Player is goal: maximize its utility(vi; (bi, b-i)) = vi(Si)  pi(bi, b-i)</p>
    <p>Truthful mechanism: for any i, for any true input vi, i maximizes its utility by saying vi regardless of others bids b-i :</p>
    <p>utility(vi; (vi, b-i))  utility(vi; (bi, b-i)) for every bi</p>
  </div>
  <div class="page">
    <p>Yes. VCG (Vickrey-Clarke-Groves) prices ensure truthfulness.</p>
    <p>Let f(b) = (S1,, Sn) (allocation maximizing i bi(Si)) set pi(b) =  j i bj(Sj) + hi(b-i)</p>
    <p>VCG mechanisms Basic question: Given SWM function f; Are there prices {pi} such that (f, {pi}) is a truthful mechanism? That is, are there prices that truthfully implement f?</p>
    <p>Ignore this term</p>
  </div>
  <div class="page">
    <p>Yes. VCG (Vickrey-Clarke-Groves) prices ensure truthfulness. Let f(b) = (S1,, Sn) (allocation maximizing i bi(Si)) set pi(b) =  j i bj(Sj)</p>
    <p>Proof of truthfulness: fix i, true valuation vi, others bids b-i. Let f(vi, b-i) = (T1,, Tn)  utility(vi; (vi, b-i)) = vi(Ti) + j i bj(Tj)</p>
    <p>= max {vi(Ui) + j i bj(Uj) : allocations (U1,, Un)} utility(vi; (bi, b-i)) is maximized at bi = vi.</p>
    <p>VCG mechanisms Basic question: Given SWM function f; Are there prices {pi} such that (f, {pi}) is a truthful mechanism? That is, are there prices that truthfully implement f?</p>
  </div>
  <div class="page">
    <p>VCG (contd.) VCG mechanisms/payments:</p>
    <p>classic positive result for truthful implementation.</p>
    <p>ensure truthfulness in a more general setting. any function f: V1xx Vn A with f(b) = argmaxaA i bi(a)</p>
    <p>A = set of outcomes, for CAs A = {allocations (S1,, Sn): Si Sj = }</p>
    <p>Vi = {valid valuations vi: A }, for CAs Vi = {vi(.): vi depends only on Si, vi() = 0, vi</p>
    <p>is monotone}</p>
    <p>VCG prices are pi(b) =  j i bj(a) + hi(b-i), where a = f(b)</p>
    <p>Only general tool for truthful mechanism design.</p>
    <p>(SWM function)</p>
  </div>
  <div class="page">
    <p>Complexity vs. Strategic Issues</p>
    <p>VCG prices</p>
    <p>VCG prices</p>
    <p>truthful mechani sm</p>
    <p>Strate gic player s</p>
    <p>exact algorithm for SWM, f(.)</p>
    <p>VCG requires computing f(v), i.e., solving SWM problem: this is NP-hard!</p>
    <p>Want computationally efficient, truthful mechanisms  VCG mechanism is not (computationally) efficient</p>
  </div>
  <div class="page">
    <p>Complexity vs. Strategic Issues</p>
    <p>approx. algorithm for SWM, f(.)</p>
    <p>VCG prices</p>
    <p>VCG prices</p>
    <p>truthful mechani sm</p>
    <p>Strate gic player s</p>
    <p>?</p>
    <p>VCG requires computing f(v), i.e., solving SWM problem: this is NP-hard!</p>
    <p>Want computationally efficient, truthful mechanisms  VCG mechanism is not (computationally) efficient</p>
    <p>Hope: can use approximation algorithm for f(.) to get truthful, approximation mechanism</p>
    <p>Cannot just plug in approx. algorithm and use VCG prices  VCG wont work with any sub-optimal reasonable</p>
    <p>algorithm [NR00]</p>
  </div>
  <div class="page">
    <p>Complexity vs. Strategic Issues</p>
    <p>VCG requires computing f(v), i.e., solving SWM problem: this is NP-hard!</p>
    <p>Want computationally efficient, truthful mechanisms  VCG mechanism is not (computationally) efficient</p>
    <p>Hope: can use approximation algorithm for f(.) to get truthful, approximation mechanism</p>
    <p>Cannot just plug in approx. algorithm and use VCG prices  VCG wont work with any sub-optimal reasonable algorithm</p>
    <p>[NR00]</p>
    <p>More bad news: for many approx. algorithms/techniques, there are no prices that will ensure truthfulness.</p>
    <p>approx. algorithm for SWM, f(.)</p>
    <p>truthful mechani sm</p>
    <p>Strate gic player s</p>
    <p>?other price scheme</p>
  </div>
  <div class="page">
    <p>What is known for CAs?</p>
    <p>Multi-unit CA (MUCA)</p>
    <p>General B, arbitrary vi(.): nothing is known (vi() =0, vi(.) monotone multi-parameter domain)</p>
    <p>m items, n players</p>
    <p>B copies of each item, player wants at most 1 copy (CA: B=1)</p>
  </div>
  <div class="page">
    <p>What is known for CAs? Multi-unit CA (MUCA)</p>
    <p>General B, arbitrary vi(.): nothing is known  Special cases</p>
    <p>B  3: Bartal-Gonen-Nisan give O(B.m(1/(B-2)))-approx. mechanism</p>
    <p>m items, n players</p>
    <p>B copies of each item, player wants at most 1 copy (CA: B=1)</p>
    <p>Bounds in non-strategic setting (no truthfulness requirement)</p>
    <p>O(m(1/(B+1)))-approx. ratio, cannot do better unless P = NP B=1 (CA): O(m1/2)-approx. B=(log m): (1+)approx.</p>
    <p>Large B: big gap between bounds with/without truthfulness.</p>
  </div>
  <div class="page">
    <p>What is known for CAs? Multi-unit CA (MUCA)</p>
    <p>General B, arbitrary vi(.): nothing is known  Special cases</p>
    <p>B  3: Bartal-Gonen-Nisan give O(B.m(1/(B-2)))-approx. mechanism</p>
    <p>Single-minded players (i wants Ti: vi(S) = vi for S Ti, and 0 o/w): B = 1  Lehman-OCallaghan-Shoham give O(m1/2)-approx. B = (log m)  Archer-Papadimitriou-Talwar-Tardos give (1+)-approx. mechanism for known single-minded case B  2  Briest-Krysta-Vocking give O(m1/B)-approx. mechanism</p>
    <p>Subadditive valuations: Dobzinski-Nisan-Schapira give O(m1/2)-approx. mechanism for CA (B=1)</p>
    <p>m items, n players</p>
    <p>B copies of each item, player wants at most 1 copy (CA: B=1)</p>
    <p>Results obtained by cleverly tailoring approx. algorithm or technique to ensure that prices yielding truthfulness exist.</p>
  </div>
  <div class="page">
    <p>Our Results  Give the first truthful, approximation</p>
    <p>mechanisms for many multi-parameter problems  O(m1/2)-approx. for CA  O(m1/(B+1))-approx. for MUCA</p>
    <p>for all B  (1+)-approx. when B = (log m)  2-approx. for multi-parameter knapsack auctions</p>
    <p>For CA, MUCA, ratios match approximation bounds when truthfulness is not required</p>
    <p>Exponential valuations: get iterative mechanisms; same approximation ratios, strategic concept is truthfulness as ex-post Nash equilibirium.</p>
    <p>for short general valuations</p>
  </div>
  <div class="page">
    <p>Our Results (contd.)  General technique to export approx. algorithm</p>
    <p>for packing SWM problem into a randomized, truthful-in-expectation, approximation mechanism</p>
    <p>c-approx. algorithm i) LP-based, ii) proves an integrality gap of c</p>
    <p>c-approximation, truthful-inexpectation mechanism</p>
    <p>VCG +  + randomizati on</p>
    <p>simple, quite general: get (versatility of VCG as MD tool) + (tractability of approx. algorithms)</p>
    <p>no need to tailor the algorithm: can decouple algorithmic and strategic parts of mechanism design</p>
  </div>
  <div class="page">
    <p>Truthfulness in expectation</p>
    <p>Deterministic mechanism M = (f, {pi}),</p>
    <p>f: (v1,,vn)  outcome aA, pi: (v1,vn)</p>
    <p>Truthfulness: for any i, any true vi, any bids b-i of others, utility(vi; (bi, b-i)) = vi(f(bi, b-i))  pi(bi, b-i) is maximized at bi= vi.</p>
    <p>Randomized mechanism M = (f, {pi})</p>
    <p>outcome f(v), price pi(v) are random variables</p>
    <p>Truthfulness-in-expectation [Archer-Tardos01]: for any i, any true vi, any b-i, E[utility(vi, (bi, b-i))] is maximized at bi= vi.</p>
  </div>
  <div class="page">
    <p>An Integer Program for CA vi(.) : valuation of player i, vi(S) : is value for set S</p>
    <p>xi,S : indicates if i gets set SMaximize i,S vi(S)xi,S subject to</p>
    <p>S xi,S  1 for each player i</p>
    <p>i S:jS xi,S 1 for each item j xi,S  {0,1} for each i, S.</p>
  </div>
  <div class="page">
    <p>A Linear Program for CA vi(.) : valuation of player i, vi(S) : is value for set S</p>
    <p>xi,S : indicates if i gets set SMaximize i,S vi(S)xi,S (CA-P) subject to</p>
    <p>S xi,S  1 for each player i</p>
    <p>i S:jS xi,S 1 for each item j xi,S  {0,1} for each i, S. xi,S  0 for each i, S.</p>
    <p>Short valuations  (CA-P) is a poly-size linear program  (CA-P) can be solved in polynomial time.</p>
  </div>
  <div class="page">
    <p>Construction Overview Let P = feasible region of (CA-P)</p>
    <p>{yk}kI = all integer points in P, i.e., yk  valid allocation</p>
    <p>(CA-P) is an SWM problem: outcome set A = points in P,</p>
    <p>player is value for xP is vi(x) = S vi(S)xi,S  vi.x</p>
    <p>(vi = {vi(S)}S) (CA-P) can be efficiently solved  can use VCG</p>
    <p>g(v1,, vn) = x *(v) = optimal solution to (CA</p>
    <p>P) for (v1,, vn)</p>
    <p>{qi(v)} = VCG prices.</p>
  </div>
  <div class="page">
    <p>Construction Overview Given: LP-based c-approximation algorithm A:</p>
    <p>maps any v=(v1,, vn) to integer soln. yk s.t. i vi.yk</p>
    <p>(i vi.x*(v))/c.</p>
    <p>Decomposition Lemma [based on Carr-Vempala02]: Given any xP, can use A to compute in poly-time</p>
    <p>{k} kI values s.t. a) kI kyk = x/c, b) k  0, kI k = 1</p>
    <p>Exploits packing property: yk integer solution  yk with some components set to 0 is also an integer solution</p>
    <p>P</p>
    <p>v, yk s.t.</p>
    <p>i vi.yk  i</p>
    <p>(vi.x*(v))/c</p>
  </div>
  <div class="page">
    <p>Construction Overview Given: LP-based c-approximation algorithm A:</p>
    <p>maps any v=(v1,, vn) to integer soln. yk s.t. i vi.yk</p>
    <p>(i vi.x*(v))/c.</p>
    <p>Decomposition Lemma [based on Carr-Vempala02]: Given any xP, can use A to compute in poly-time</p>
    <p>{k} kI values s.t. a) kI kyk = x/c, b) k  0, kI k = 1</p>
    <p>solutions. Gives randomized mechanism MR = (h, {ri}) where</p>
    <p>h(v) = yk with probability k (random) price ri(v) is set so that E[ri(v)] =</p>
    <p>qi(v)/c.</p>
  </div>
  <div class="page">
    <p>Construction Overview VCG mechanism MF = (g, {qi}); g(v) = x</p>
    <p>*(v), {qi(v)} = VCG prices Randomized mechanism MR = (h, {ri}),</p>
    <p>h(v) = yk with probability k where x *(v)/c = kI</p>
    <p>kyk (random) price ri(v) is set so that E[ri(v)] = qi(v)/c.</p>
    <p>MR is truthful in expectation: for every true value vi,</p>
    <p>bids (bi, b-i), expected value of i = E[vi.h(bi,</p>
    <p>b-i)] = vi.g(bi, b-i) /c</p>
    <p>expected price of i = E[ri(bi, b-i)] = qi(bi, b-i) /c</p>
    <p>MF truthful  (vi.g(bi, b-i)  qi(bi, b-i)) is maximized at bi = vi</p>
    <p>E[vi.h(bi, b-i)  ri(bi, b-i)] is maximized at bi = vi</p>
    <p>Also shows MR is a c-approximation mechanism (in expectation).</p>
  </div>
  <div class="page">
    <p>Getting a convex decomposition</p>
    <p>Given: xP, LP-based c-approx. algorithm A</p>
    <p>Want k values</p>
    <p>s.t. kI kyk = x/c</p>
    <p>kI k = 1</p>
    <p>k  0</p>
    <p>Linear inequalities in k variables  turn into a convenient LP</p>
  </div>
  <div class="page">
    <p>Getting a convex decomposition</p>
    <p>Min. kI k (P)</p>
    <p>s.t. kI kyk = x/c</p>
    <p>kI k  1</p>
    <p>k  0 for every kI</p>
    <p>(P) is LP with exponential variables, but polynomial constraints.</p>
    <p>Max. w.x/c + z (D)</p>
    <p>s.t. w.yk+ z  1 for every kI</p>
    <p>z  0, w is free</p>
    <p>Dual (D)  polynomial variables, exponential number of constraints.</p>
    <p>Have to show the following: (P) is feasible optimal value of (P) is 1 (P) can be solved efficiently</p>
    <p>will show that optimal value of (D) is 1</p>
    <p>will show that (D) can be solved using the ellipsoid method</p>
    <p>Algorithm A can be used to obtain a separation oracle</p>
    <p>Running ellipsoid gives an equivalent, compact dual program (D') with only polynomial constraints. Its dual is a program of the form (P) but with polynomial k variables  solve to get desired k values.</p>
  </div>
  <div class="page">
    <p>Getting a convex decomposition</p>
    <p>Min. kI k (P)</p>
    <p>s.t. kI kyk = x/c</p>
    <p>kI k  1</p>
    <p>k  0 for every kI</p>
    <p>(P) is LP with exponential variables, but polynomial constraints.</p>
    <p>Max. w.x/c + z (D)</p>
    <p>s.t. w.yk+ z  1 for every kI</p>
    <p>z  0, w is free</p>
    <p>Dual (D)  polynomial variables, exponential number of constraints.</p>
    <p>To show: optimal value of (D) is 1 w = 0, z = 1 is a feasible solution  OPT(D)  1</p>
    <p>Suppose there is a feasible solution (w,z) with w.x/c+z &gt; 1 Interpret w = (wi,S) as a valuation vector</p>
    <p>integer soln. yk such that w.yk  w.x/c &gt; 1z</p>
    <p>contradictio nAlso yields oracle for use in ellipsoid method:</p>
    <p>w.x/c+z &gt; 1: use algorithm A to find above yk  get violated inequality</p>
    <p>w.x/c+z  1: use w.x/c+z  1 hyperplane to cut ellipsoid (obj. fn. cut)</p>
  </div>
  <div class="page">
    <p>Getting a convex decomposition</p>
    <p>Min. kI k (P)</p>
    <p>s.t. kI kyk = x/c</p>
    <p>kI k  1</p>
    <p>k  0 for every kI</p>
    <p>(P) is LP with exponential variables, but polynomial constraints.</p>
    <p>Max. w.x/c + z (D)</p>
    <p>s.t. w.yk+ z  1 for every kI</p>
    <p>z  0, w is free</p>
    <p>Dual (D)  polynomial variables, exponential number of constraints.</p>
    <p>Also yields oracle for use in ellipsoid method:</p>
    <p>w.x/c+z &gt; 1: use algorithm A to find above yk  get violated inequality</p>
    <p>w.x/c+z  1: use w.x/c+z  1 hyperplane to cut ellipsoid (obj. fn. cut)</p>
    <p>One last hurdle: w = (wi,S) may not be a valid valuation vector</p>
    <p>cannot run A on w directly</p>
    <p>Easy fix: simply monotonize w; set w+(i,S) = max(0, maxTS wi,S) and</p>
    <p>run A on w+</p>
  </div>
  <div class="page">
    <p>To summarize,</p>
    <p>Move from integer problem to fractional domain  Use VCG to get fractional truthful mechanism</p>
    <p>Use decomposition lemma to express scaleddown optimal solution as convex combination of integer solutions</p>
    <p>Interpret this as a randomized mechanism  Obtain a truthful-in-expectation, approx.</p>
    <p>mechanism</p>
    <p>General way to exploit VCG for packing SWM problems using approximation algorithms.</p>
  </div>
  <div class="page">
    <p>Open Questions</p>
    <p>Packing SWM problems: how to exploit structure of valuation class, e.g., submodular valuations?</p>
    <p>Non-SWM social-choice fns f: V1xx Vn A: ways to export approximation algorithms to truthful mechanisms?</p>
    <p>General techniques to get deterministic truthful mechanisms for multi-parameter problems? Or truthfulness with high probability?</p>
  </div>
  <div class="page">
    <p>Thank You.</p>
  </div>
</Presentation>
