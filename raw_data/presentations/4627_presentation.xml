<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Deconstructing Hardware</p>
    <p>Architectures for Security</p>
    <p>Michael Dalton Hari Kannan Christos Kozyrakis</p>
    <p>Computer Systems Laboratory</p>
    <p>Stanford University</p>
  </div>
  <div class="page">
    <p>@ 2006, Michael Dalton 2</p>
    <p>Computer Security</p>
    <p>Computers are a critical component of national infrastructure</p>
    <p>Store critical information (credit card #s, SSNs, )</p>
    <p>Provide essential services (power, phones, banking, )</p>
    <p>Computer security flaws are pervasive and dangerous</p>
    <p>Internet is a hostile environment, programmers make mistakes</p>
    <p>Results in identity theft, data loss, downtime, IP theft,</p>
    <p>Costs billions per year</p>
    <p>Must provide safe, reliable computing</p>
    <p>Confidentiality</p>
    <p>Integrity</p>
    <p>Availability</p>
  </div>
  <div class="page">
    <p>@ 2006, Michael Dalton 3</p>
    <p>Why Hardware Support for Security?</p>
    <p>Software should have final say on security policy</p>
    <p>But HW support provides crucial advantages  High precision with low overhead</p>
    <p>HW can examine every instruction executed</p>
    <p>HW can examine every byte accessed</p>
    <p>Powerful, fine-grain analysis with little or no runtime cost</p>
    <p>Compatibility  Does not require source code access or recompilation</p>
    <p>Does not require debugging information or binary instrumentation</p>
    <p>Works with self-modifying, dynamically generated/loaded code</p>
    <p>Proposed architectures for security  Tainting architectures to prevent memory corruption exploits  Information leak prevention architectures to prevent information leaks</p>
    <p>by malicious/vulnerable programs</p>
  </div>
  <div class="page">
    <p>@ 2006, Michael Dalton 4</p>
    <p>Outline</p>
    <p>Motivation</p>
    <p>Tainting architectures</p>
    <p>Memory corruption bugs</p>
    <p>Tainting architectures summary</p>
    <p>Flaws: input validation, new format string attacks</p>
    <p>Information leakage prevention architectures</p>
    <p>RIFLE summary</p>
    <p>Flaws: implicit information flow</p>
    <p>Conclusions</p>
    <p>Read paper for</p>
    <p>Details of new format string attack</p>
    <p>Full discussion on information leak, tainting</p>
  </div>
  <div class="page">
    <p>@ 2006, Michael Dalton 5</p>
    <p>Memory Corruption Bugs</p>
    <p>Basic idea</p>
    <p>Programmer bugs allow overwrite of critical memory regions</p>
    <p>Can result in complete application compromise</p>
    <p>One of oldest and most damaging security flaws</p>
    <p>The basis for the Internet worm, NIMDA, Slapper,</p>
    <p>Several possible forms</p>
    <p>Buffer overflows, format string bugs, off-by-ones</p>
    <p>Common issue with type-unsafe languages (C and C++)</p>
    <p>Unsafe languages do not restrict or check memory accesses</p>
  </div>
  <div class="page">
    <p>@ 2006, Michael Dalton 6</p>
    <p>Memory Corruption Example</p>
    <p>int vuln(char * username){</p>
    <p>char buf[512];</p>
    <p>strcpy(buf,username);</p>
    <p>process_input(buf);</p>
    <p>...</p>
    <p>return 0;</p>
    <p>}</p>
    <p>No bounds check on strcpy()</p>
    <p>If username is longer than 512 bytes, buffer overflow</p>
    <p>Strcpy() may overwrite other data structures on stack</p>
    <p>Attack</p>
    <p>Write arbitrary malicious code on the stack</p>
    <p>Overwrite return address for vuln() function</p>
    <p>When vuln() returns, malicious code is run</p>
  </div>
  <div class="page">
    <p>@ 2006, Michael Dalton 7</p>
    <p>Tainting Architectures</p>
    <p>Basic model [Suh04, Crandall04, Chen05]</p>
    <p>Extend each memory/register byte by one taint bit</p>
    <p>Data from untrusted sources tainted by the OS</p>
    <p>Taint bits propagate across instructions</p>
    <p>When tainted data used as pointer, trap to OS</p>
    <p>E.g., use tainted value as instruction pointer in our example</p>
    <p>Several alternatives</p>
    <p>Dynamic Information Flow Tracking (DIFT) [Suh04]</p>
    <p>Minos [Crandall04]</p>
    <p>Similar to DIFT for control-only attacks; not discussed</p>
    <p>Pointer Taintedness Detection (PTD) [Chen05]</p>
  </div>
  <div class="page">
    <p>@ 2006, Michael Dalton 8</p>
    <p>Validating Untrusted Input</p>
    <p>Applications must be able to validate their input  E.g., bounds checking</p>
    <p>int safe(char * username){</p>
    <p>char buf[512];</p>
    <p>if (strlen(username) &gt;= 512) return -1;</p>
    <p>strcpy(buf,username);</p>
    <p>process_input(buf);</p>
    <p>return 0;</p>
    <p>}</p>
    <p>Validation trade-offs</p>
    <p>Too frequent to run in software (e.g. trap into OS)</p>
    <p>Ideal validation policy  untaint operand only when user validates</p>
    <p>Too strict  false positives  performance loss</p>
    <p>Too lenient  false negatives  security flaw</p>
  </div>
  <div class="page">
    <p>@ 2006, Michael Dalton 9</p>
    <p>Input Validation Flaws: DIFT</p>
    <p>Validation on pointer arithmetic (scaled addition)</p>
    <p>Add untainted base + a tainted index  untainted pointer</p>
    <p>Problems</p>
    <p>Several ISAs dont have scaled addition instructions</p>
    <p>Untainting on regular adds  false positives</p>
    <p>Several compilers use scaled addition instructions for integers</p>
    <p>Incorrect validation  false negatives</p>
    <p>Tainted indices can produce arbitrary values</p>
    <p>Without bounds checking  false negatives</p>
    <p>No correlation between pointer arithmetic and bounds checks!</p>
  </div>
  <div class="page">
    <p>@ 2006, Michael Dalton 10</p>
    <p>Input Validation: PTD</p>
    <p>Validation on comparisons</p>
    <p>Tainted pointer compared to untainted value  untainted value</p>
    <p>Strengths</p>
    <p>Covers most bounds checks</p>
    <p>No dependence on exotic instructions in ISA, compiler</p>
    <p>Untaint directly associated with bounds check</p>
    <p>Problems</p>
    <p>Bounds checks may have multiple forms  Integer truncation, masking bits,</p>
    <p>Missing validation  false positives</p>
    <p>Bugs in comparisons  Signedness, translation tables</p>
    <p>Incorrect validation  false negatives</p>
  </div>
  <div class="page">
    <p>@ 2006, Michael Dalton 11</p>
    <p>Format String Bugs</p>
    <p>Exploit format string directives for printf(), sprintf(),   Untrusted input passed as printf format string  printf(%x) reads arguments from stack  %n directive writes number of chars output to its argument  %d will pad output with spaces if given width specifier</p>
    <p>Classical attack examples  E.g., printf(%12345d%n,17,&amp;x) writes 12345 to x  E.g., printf(\x41\x42\x43\x44%12345d%0d%0%d%0d%n)</p>
    <p>Write address 0x44434241 if format string begins at 5th word from top of stack</p>
    <p>Prevention by tainting architectures  Can write arbitrary value but will be tainted because derived from fmt</p>
    <p>string</p>
    <p>Cannot place target address in fmt string because fmt string tainted</p>
  </div>
  <div class="page">
    <p>@ 2006, Michael Dalton 12</p>
    <p>New Format Sting Attack</p>
    <p>Write an arbitrary untainted value to an arbitrary address</p>
    <p>Avoid the use of a constant field width</p>
    <p>Create one from existing untainted values</p>
    <p>Ingredients</p>
    <p>* specifier to get field width from the stack</p>
    <p>printf positional parameters to use arguments multiple times</p>
    <p>Two pointer pairs that reference adjacent halfwords</p>
    <p>Created with environment variables if local</p>
    <p>Tainting architectures will not catch this</p>
    <p>The new arbitrary value is not tainted!</p>
  </div>
  <div class="page">
    <p>@ 2006, Michael Dalton 13</p>
    <p>Information Leakage Prevention</p>
    <p>Problem: ensure confidentiality of data</p>
    <p>Prevent untrusted applications from leaking information</p>
    <p>E.g., cannot send private data to network</p>
    <p>RIFLE overview [Vachharajani04]</p>
    <p>Each information type has a security label</p>
    <p>Labels propagate through instruction execution</p>
    <p>Forbid sensitive labels from being sent to untrusted output channels</p>
  </div>
  <div class="page">
    <p>@ 2006, Michael Dalton 14</p>
    <p>Implicit Information Flow</p>
    <p>Must track all information flow to prevent leaks</p>
    <p>Implicit information flow occurs through control dependences</p>
    <p>if (a)</p>
    <p>b = 0;</p>
    <p>else</p>
    <p>b = 1;</p>
    <p>RIFLE implicit information flow tracking</p>
    <p>Security registers track labels of any operand used as branch condition</p>
    <p>Instructions for update of security registers inserted before each branch</p>
    <p>Add label of branch operand to security register</p>
  </div>
  <div class="page">
    <p>@ 2006, Michael Dalton 15</p>
    <p>Implicit Information Flow: Flaws</p>
    <p>No memory corruption protection</p>
    <p>Attacker can corrupt code pointers to jump over security register update and just execute branch!</p>
    <p>If security register has not been updated, implicit information flow occurs undetected by RIFLE</p>
    <p>Implications</p>
    <p>Untrusted application may leak arbitrary amounts of sensitive information by corrupting own code pointers</p>
    <p>If attacking nonmalicious application, only succeed if security register does not already contain label of branch operand</p>
  </div>
  <div class="page">
    <p>@ 2006, Michael Dalton 16</p>
    <p>Conclusion</p>
    <p>Hardware support can greatly improve system security</p>
    <p>High precision analysis with low overhead</p>
    <p>Compatibility with existing software</p>
    <p>Need more flexible hardware security solutions</p>
    <p>Flexibility in setting check/propagation policies</p>
    <p>No one policy will catch all our bugs</p>
    <p>Concurrent use of multiple types of checks</p>
    <p>Different rules, hardware/software checks,</p>
    <p>Beyond memory corruption and information leakage</p>
    <p>SQL injection, Cross Site Scripting, Directory Traversal,</p>
  </div>
</Presentation>
