<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Evaluating the Power of Flexible Packet Processing for Network Resource Allocation</p>
    <p>Naveen Kr. Sharma, Antoine Kaufmann, Thomas Anderson,</p>
    <p>Changhoon Kim, Arvind Krishnamurthy, Jacob Nelson, Simon Peter</p>
  </div>
  <div class="page">
    <p>Programmable Switching Hardware</p>
    <p>Reconfigurable network chips that process at line rate</p>
    <p>Not software or FPGA based routers</p>
    <p>Achieve high performance using a restricted computation model e.g. RMT</p>
    <p>Allows operators to reconfigure switches in the field</p>
    <p>Deploy new protocols without waiting for new hardware</p>
    <p>Re-allocate resources to various switch features (L2, L3 or ACLs)</p>
    <p>Flexibility comes at a minimal hardware cost</p>
    <p>Commercial examples include Caviums XPliant, Barefoots Tofino</p>
  </div>
  <div class="page">
    <p>Features of Flexible Switches</p>
    <p>P ro</p>
    <p>g ra</p>
    <p>m m</p>
    <p>a b</p>
    <p>le</p>
    <p>P a</p>
    <p>rs e</p>
    <p>r</p>
    <p>Packet Stream . . .</p>
    <p>TCAM</p>
    <p>SRAM</p>
    <p>REGs</p>
    <p>. .</p>
    <p>. Egress Queues</p>
    <p>Eth</p>
    <p>IPv4</p>
    <p>TCP UDP</p>
    <p>RCP</p>
    <p>TCAM for arbitrary wildcard matches</p>
    <p>SRAM for exact/LPM lookups</p>
    <p>Stateful memory for counter and meters</p>
    <p>ALUs for modifying headers and registers</p>
    <p>Switch CPU</p>
    <p>. .</p>
    <p>.</p>
    <p>. .</p>
    <p>.</p>
    <p>Match</p>
    <p>Action</p>
  </div>
  <div class="page">
    <p>Flexible Switches are not all-powerful</p>
    <p>Processing primitives are limited  Cannot perform arbitrary operations</p>
    <p>Available stateful memory is constrained  Cannot maintain significant per-flow state</p>
    <p>Limited number of stages and limited communication across stages  Imposes a limit on computation performed per-packet</p>
    <p>What can we do with these switches?  Custom routing and tunneling protocols such as VxLAN or MPLS</p>
    <p>Most are packet-level transformations involving static table lookups</p>
  </div>
  <div class="page">
    <p>What about network-rich protocols?</p>
    <p>Several protocols proposed in the past require active network elements</p>
    <p>Persistent and mutable state for cross-packet transformations</p>
    <p>Require implementing some state machine functionality</p>
    <p>They solve a broad class of network problems</p>
    <p>Congestion Control (XCP, RCP, QCN, HULL)</p>
    <p>Load Balancing (Hedera, CONGA, WCMP, Ananta)</p>
    <p>Fairness &amp; QoS Scheduling (Seawall, FairCloud, CoDel, D3)</p>
    <p>Can we implement these amazing protocols on Flexible Switches?</p>
  </div>
  <div class="page">
    <p>Rest of the Talk</p>
    <p>Our Approach</p>
    <p>Analyze protocols to determine their requirements</p>
    <p>Running example: RCP (Rate Control Protocol)</p>
    <p>Building Blocks</p>
    <p>Propose several modules that approximate some network function</p>
    <p>Use approximation to overcome hardware limitations</p>
    <p>Evaluation</p>
    <p>Are our approximations effective and accurate enough?</p>
  </div>
  <div class="page">
    <p>Example : RCP (Rate Control Protocol)</p>
    <p>Congestion control scheme that relies on explicit network feedback</p>
    <p>The original algorithm computes rate periodically using,</p>
    <p>=  +</p>
    <p>Ra Rb</p>
    <p>R = 50 R = 25 R = 20</p>
    <p>Sender Switch A Switch B Receiver</p>
    <p>= 25 = 20</p>
    <p>Rate</p>
  </div>
  <div class="page">
    <p>=  +</p>
    <p>Straight-forward, switches already have counters for this purpose</p>
    <p>Difficult, but can be approximated using log-table lookups</p>
    <p>Challenging to implement without maintaining per-flow state</p>
  </div>
  <div class="page">
    <p>Example: Cardinality Estimation</p>
    <p>Use case: Count the number of unique flows traversing a switch</p>
    <p>We extend an approach from streaming algorithms</p>
    <p>pkt-1</p>
    <p>hash(5-tuple)</p>
    <p>pkt-2 0000 1000 1010 1100</p>
    <p>Maximum leading zeroes:</p>
    <p>pkt-3 0001 0111 0011 0110 Estimate = 24 = 16</p>
    <p>. .</p>
    <p>.</p>
    <p>. .</p>
    <p>.</p>
  </div>
  <div class="page">
    <p>Example: Cardinality Estimation</p>
    <p>The estimate is coarse-grained with high variation</p>
    <p>Split the input stream into multiple buckets and aggregate</p>
    <p>Estimate using bloom-filter counting if too few elements</p>
    <p>Less than 5% error with 1KiB of memory for 100K flows</p>
    <p>Aggregate across all N buckets</p>
  </div>
  <div class="page">
    <p>More protocols and building blocks in the paper</p>
  </div>
  <div class="page">
    <p>Example: Approximate Flow Timestamps</p>
    <p>Use case: Implement flowlet routing (e.g., CONGA, HULA)</p>
    <p>We use a custom sketch that stores timestamps and per-flow state</p>
    <p>For each packet, hash the 5-tuple and update cell corresponding to hashi % N</p>
    <p>- - - - - - -</p>
    <p>- - - - - - -</p>
    <p>- - - - - - -</p>
    <p>- - - - - - -</p>
    <p>hash1( ) % N</p>
    <p>hash2( ) % N</p>
    <p>hashR( ) % N</p>
    <p>R</p>
    <p>N</p>
    <p>pkt</p>
  </div>
  <div class="page">
    <p>Flowlet routing using Approximate Flow Timestamps</p>
    <p>Flowlet Timestamps</p>
    <p>Flowlet is live: if all cell timestamps are within timeout (say T = 10)</p>
    <p>Update: Replace all cell timestamps with current time</p>
    <p>Flowlet Route-id</p>
    <p>Sum of all cell routei is the desired route-id</p>
    <p>Update: Re-write all non-live cells such that new sum = new route-id</p>
    <p>This method is always safe and maintains liveness of flowlets</p>
    <p>- - - - - - -</p>
    <p>- - - - - - -</p>
    <p>T0, 0 T0, 0 T0, 0 T0, 0 T0, 0 T0, 0 T0, 0 T0, 0</p>
    <p>T0, 0 T0, 0 T0, 0 T0, 0 T0, 0 T0, 0 T0, 0 T0, 0</p>
    <p>pkt-1</p>
    <p>pkt-1</p>
    <p>pkt-2</p>
    <p>T = 20</p>
    <p>T = 25</p>
    <p>T = 29</p>
    <p>route-id: 5</p>
    <p>route-id: 8 T0, 0</p>
    <p>T0, 0</p>
    <p>Each cell stores a tuple (timestamp, routei)</p>
    <p>T = 20</p>
    <p>T = 20</p>
    <p>T20, 0</p>
    <p>T20, 0</p>
    <p>T20, 2</p>
    <p>T20, 3</p>
    <p>T0, 0 T = 25</p>
    <p>T = 5T20, 3T25, 3</p>
    <p>T25, 0 5 + 3 = 8</p>
    <p>T25, 5T29, 2</p>
    <p>T29, 3</p>
    <p>T = 9</p>
    <p>T = 4</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Implement RCP on Cavium XPliant switch and measure performance</p>
    <p>Compare original and approximated versions using ns3 simulations</p>
    <p>Measure additional resource usage on top of a P4 switch</p>
  </div>
  <div class="page">
    <p>RCP implementation on a flexible switch</p>
    <p>Implemented on Cavium XPliant CNX880xx using our building blocks</p>
    <p>2-level FatTree topology with 4 ToRs, 2 core switches using VLANs</p>
    <p>Short Flows Medium Flows Long Flows</p>
    <p>Flow Completion Time in ms</p>
    <p>TCP RCP</p>
  </div>
  <div class="page">
    <p>Impact of approximation on protocols</p>
    <p>Implement both original and approximate protocols in ns3 simulator</p>
    <p>Simulate a FatTree topology with 2560 servers and 112 switches</p>
    <p>C D</p>
    <p>F</p>
    <p>Flow Completion Time for short flows in ms</p>
    <p>RCP</p>
    <p>XCP</p>
    <p>TCP</p>
    <p>RCP-Approx</p>
    <p>XCP-Approx</p>
  </div>
  <div class="page">
    <p>Resource usage of approximate protocols</p>
    <p>Implement protocols in P4 on open-source switch.p4</p>
    <p>Compile to a baseline switch based on Tofino hardware model  L2 switching, L3 routing, LAGs, ECMP, VxLAN, GRE, Geneve, etc</p>
    <p>Resource Baseline RCP XCP CONGA</p>
    <p>Packet Header Vector 187 191 + 2% 195 + 4% 199 + 6%</p>
    <p>Pipeline Stages 9 10 + 11% 9 + 0% 11 + 22%</p>
    <p>Match Crossbar 462 473 + 2% 471 + 2% 478 + 3%</p>
    <p>Hash Bits 1050 1115 + 6% 1058 + 1% 1137 + 8%</p>
    <p>SRAM 165 175 + 6% 172 + 4% 213 + 29%</p>
    <p>TCAM 43 44 + 2% 45 + 5% 44 + 2%</p>
    <p>ALU Instructions 83 88 + 6% 92 + 11% 98 + 18%</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Programmable switches can implement a broad class of protocols</p>
    <p>Overcome hardware constraints using approximation techniques</p>
    <p>Approximations are effective and accurate enough</p>
    <p>Demonstrate benefits on real hardware</p>
    <p>Simulations show protocol performance largely unaffected by approximations</p>
    <p>On-going work: design new protocols tailored to flexible switches</p>
  </div>
</Presentation>
