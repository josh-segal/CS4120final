<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Factored Planning: How, When, and When Not</p>
    <p>Carmel Domshlak - Technion, Israel</p>
    <p>Joint work with Ronen Brafman - Stanford/NASA (on leave from Ben-Gurion Univ.)</p>
  </div>
  <div class="page">
    <p>State model for Classical AI Planning</p>
    <p>finite state space S</p>
    <p>an initial state s0  S</p>
    <p>a set SG  S of goal states</p>
    <p>applicable actions A(s)  A for s  S</p>
    <p>a transition function s = f (a, s) for a  A(s)</p>
    <p>cost function c : A  [0,)</p>
    <p>A solution is a sequence of applicable actions that maps s0 into SG</p>
    <p>An optimal solution minimizes c</p>
  </div>
  <div class="page">
    <p>Planning Languages</p>
    <p>Key issue:</p>
    <p>state models represented implicitly in a declarative language</p>
    <p>representations use state variables to represent different aspects of the overall</p>
    <p>state of the system</p>
    <p>Play two roles</p>
    <p>specification: concise model description</p>
    <p>computation: reveal useful info about problems structure</p>
  </div>
  <div class="page">
    <p>The (simplified) SAS+ language (Backstrom &amp; Nebel, 95)</p>
    <p>A problem in SAS+ is a tuple V, A, I, G</p>
    <p>V is a set of n finite-domain variables</p>
    <p>A is a set of actions</p>
    <p>I is a complete assignment to V (initial state)</p>
    <p>G is a partial assignment to V (goal situation)</p>
    <p>Actions a  A represented by two partial assignments to V :</p>
    <p>the Precondition pre(a)</p>
    <p>the Effect eff(a)</p>
    <p>A problem in SAS+ determines a state model.</p>
  </div>
  <div class="page">
    <p>Factored planning</p>
    <p>Basic problem: state space of size exp(n)</p>
    <p>Basic idea: divide &amp; conquer</p>
    <p>overall state space</p>
    <p>Space division:</p>
    <p>vertical (in contrast to horizontal)</p>
    <p>each subspace S(i)  S is defined in terms of a variable subset V(i)  V</p>
    <p>V(1), . . . , V(r) are called the factors of the division</p>
    <p>Potential gain: sub-problems are each exponentially easier</p>
  </div>
  <div class="page">
    <p>Factored planning</p>
    <p>Basic problem: state space of size exp(n)</p>
    <p>Basic idea: divide &amp; conquer</p>
    <p>Potential gain: sub-problems are each exponentially easier</p>
    <p>Potential problems:</p>
    <p>sub-problems not informed about global structure</p>
    <p>backtracking between sub-problems possible</p>
    <p>composing sub-solutions may be expensive</p>
    <p>Main research questions:</p>
    <p>How to factor and merge? Complexity for a given factorization? How does it</p>
    <p>compare to unfactored planning?</p>
    <p>Guaranteed properties for FP-generated plans? How does it compare to non</p>
    <p>factored planning?</p>
  </div>
  <div class="page">
    <p>S a c e r d o t iK n o b l o c kB a c c h u s &amp; Y a n gL a n s k y &amp; G e t o o rW i l l i a m s &amp; N a y a k. . .</p>
    <p>B r a f m a n &amp; D o m s h l a kD i n i t z &amp; D o m s h l a k H e l m e r t A m i r &amp; E n g e l h a r d t</p>
  </div>
  <div class="page">
    <p>(Undirected) Causal Graph CG</p>
    <p>Nodes of CG are problem variables V , and (v, u)  CG iff:</p>
    <p>some action that changes v is preconditioned by a value of u, or</p>
    <p>some action changes both v and u</p>
    <p>Example:</p>
    <p>R rocket location</p>
    <p>E, M possible package locations</p>
    <p>F fuel tank state (full/empty)</p>
    <p>Actions:</p>
    <p>f ly-@l1-@l2</p>
    <p>(un)load-@p-@l</p>
    <p>f uel</p>
    <p>E (ar t h ) M (ar s )</p>
    <p>F R</p>
    <p>E M</p>
  </div>
  <div class="page">
    <p>First things first</p>
    <p>How to factor and merge?</p>
    <p>Factoring  factor = variable (for now)</p>
    <p>Focus on:</p>
  </div>
  <div class="page">
    <p>Step 1: Sequences Combination Problem</p>
    <p>Assumption: For every v  V , we are given a set of pre-scheduled action</p>
    <p>sequences SP lan(v) where</p>
    <p>each   SP lan(v) is a finite sequence of pairs (a, t), such that</p>
    <p>a is an action affecting v, and</p>
    <p>t is the time point at which a is to be performed.</p>
    <p>Task: Construct a global plan using these n sets of action sequences SP lan(v).</p>
  </div>
  <div class="page">
    <p>Sequence-based Planning as CSP</p>
    <p>Assumption: For every v  V , we are given a set of pre-scheduled action</p>
    <p>sequences SP lan(v) where</p>
    <p>each   SP lan(v) is a finite sequence of pairs (a, t), such that</p>
    <p>a is an action affecting v, and</p>
    <p>t is the time point at which a is to be performed.</p>
    <p>Task: Construct a global plan using these n sets of action sequences SP lan(v).</p>
    <p>Solution: CSP (denoted SeqCSP) over n variables X1, . . . , Xn where:</p>
    <p>graph CG.</p>
  </div>
  <div class="page">
    <p>From Sequences Combination to Planning</p>
    <p>procedure LID</p>
    <p>d := 1</p>
    <p>loop</p>
    <p>for i := 1 . . . n do</p>
    <p>Dom(Xi) := all sub-plans for vi of length up to d,</p>
    <p>over all schedules across nd time points.</p>
    <p>f ly-E-M</p>
    <p>f ly-M -E</p>
    <p>f uel</p>
    <p>f uel</p>
    <p>n = 4</p>
    <p>d = 2</p>
    <p>variable: F uel</p>
  </div>
  <div class="page">
    <p>From Sequences Combination to Planning</p>
    <p>procedure LID</p>
    <p>d := 1</p>
    <p>loop</p>
    <p>for i := 1 . . . n do</p>
    <p>Dom(Xi) := all sub-plans for vi of length up to d,</p>
    <p>over all schedules across nd time points.</p>
    <p>Construct SeqCSP(d) over X1, . . . , Xn.</p>
    <p>if ( solve-csp(SeqCSP(d)) ) then</p>
    <p>Reconstruct a plan  from the solution of SeqCSP(d).</p>
    <p>return</p>
    <p>else</p>
    <p>d := d + 1</p>
    <p>endloop</p>
  </div>
  <div class="page">
    <p>Correctness and Local Optimality</p>
    <p>Theorem 1</p>
    <p>LID is a sound and complete planning algorithm.</p>
    <p>If LID terminates with a plan  at iteration , then, for any plan , there exists a</p>
    <p>state variable that changes its value on  at least  times.</p>
    <p>Intuition behind :</p>
    <p>cannot be solved if we force all problem variables to be changed less than  times</p>
    <p>each.</p>
  </div>
  <div class="page">
    <p>Complexity</p>
    <p>Theorem 2 Given a planning problem , it can be solved using LID in time</p>
    <p>O(n(na)w+) (1)</p>
    <p>where a = maxi {|Ai|}, w is the tree-width of CG, and  is the local depth of ,</p>
    <p>defined as:</p>
    <p>= min P lan()</p>
    <p>max 1in</p>
    <p>{|i|} (2)</p>
    <p>Intuition behind :</p>
    <p>cannot be solved if we force all problem variables to be changed less than  times</p>
    <p>each.</p>
  </div>
  <div class="page">
    <p>Tree-width of graphs by example</p>
  </div>
  <div class="page">
    <p>Factored vs. Non-factored planning: Plan Optimality</p>
    <p>Standard notions of plan optimality</p>
    <p>Sequential optimality (OP): minimize number of actions</p>
    <p>Step-optimality (SOP): minimize number of concurrent steps</p>
    <p>can be of interest on its own, or</p>
    <p>a reasonable compromise when OP is beyond reach.</p>
  </div>
  <div class="page">
    <p>Factored vs. Non-factored planning: Plan Optimality</p>
    <p>Standard notions of plan optimality</p>
    <p>Sequential optimality (OP): minimize number of actions</p>
    <p>Step-optimality (SOP): minimize number of concurrent steps</p>
    <p>can be of interest on its own, or</p>
    <p>a reasonable compromise when OP is beyond reach.</p>
    <p>Local optimality (LOP) guaranteed by LID is not any different.</p>
    <p>Lemma 1 Given a planning problem , let mop, msop, mlop denote the number of</p>
    <p>actions in an optimal, step-optimal, and locally optimal plan, respectively.</p>
    <p>We have that msop  n  mop and mlop  n  mop, and both these bounds are tight.</p>
  </div>
  <div class="page">
    <p>Time Complexity</p>
    <p>Worst-case time complexity guarantees</p>
    <p>exp (mop) exp (n) exp (n)</p>
  </div>
  <div class="page">
    <p>Factored vs. Non-factored planning: Complexity</p>
    <p>Worst-case time complexity guarantees</p>
    <p>exp (mop) exp (n) exp (n)</p>
    <p>exp (w)</p>
  </div>
  <div class="page">
    <p>Causal graph in standardly optimal planning?</p>
    <p>The DK encoding for planning-as-CSP (Do &amp; Kambhampati 01)</p>
    <p>Fix upper bound m on plan step-length</p>
    <p>CSP variables v [k] i correspond to problem variables vi at time points k  1, . . . , m</p>
    <p>CSP variable domains: actions affecting corresponding problem variables, plus</p>
    <p>noops</p>
    <p>CSP constraints (informally)</p>
    <p>Initial state holds at t = 0, goal situation at t = m</p>
    <p>If v [k] i = a, then P rec(a) are provided at t = k  1 and preserved at t = k</p>
    <p>If a affects both vi and vj , then v [k] i = a  v</p>
    <p>[k] j = a</p>
    <p>We ignore here: additional constraints from planning graph that capture certain</p>
    <p>reachability information</p>
  </div>
  <div class="page">
    <p>Complexity of DK-based SOP</p>
    <p>The DK encoding + iterative deepening on m = step-optimal plan</p>
    <p>Theorem 3 A planning problem with minimal plan step-length m, and causal graph</p>
    <p>tree-width w can be solved in time:</p>
    <p>O(min{nm  an+1, nm  awm+1}),</p>
  </div>
  <div class="page">
    <p>Complexity of DK-based SOP</p>
    <p>The DK encoding + iterative deepening on m = step-optimal plan</p>
    <p>Theorem 4 A planning problem with minimal plan step-length m, and causal graph</p>
    <p>tree-width w can be solved in time:</p>
    <p>O(min{nm  an+1, nm  awm+1}),</p>
    <p>Key: Tree-width of DK constraint graph  min{wm, n}</p>
    <p>(+ some tight bounds, e.g., tree-width = n for m &gt; n.)</p>
    <p>ONMLHIJK F [1]</p>
    <p>ONMLHIJK F [2]</p>
    <p>SS SS</p>
    <p>SS SS</p>
    <p>SS SS</p>
    <p>SS</p>
    <p>kk kk</p>
    <p>kk kk</p>
    <p>kk kk</p>
    <p>kk ONMLHIJK F [3]</p>
    <p>ONMLHIJK R[1]</p>
    <p>vv vv</p>
    <p>vv</p>
    <p>ONMLHIJK R[2]</p>
    <p>vv vv</p>
    <p>vv</p>
    <p>kkkkkkkkkkkkkk</p>
    <p>SSSSSSSSSSSSSS ONMLHIJK R[3]</p>
    <p>vv vv</p>
    <p>vv</p>
    <p>ONMLHIJK E[1]</p>
    <p>ONMLHIJK E[2]</p>
    <p>HHHHHH</p>
    <p>ONMLHIJK E[3]</p>
    <p>HHHHHH</p>
    <p>WVUTPQRS M [1]</p>
    <p>WVUTPQRS M [2]</p>
    <p>WVUTPQRS M [3]</p>
  </div>
  <div class="page">
    <p>Factored vs. Non-factored: Summary of Complexity Guarantees</p>
    <p>Factored planning is a win when w = o(n)</p>
    <p>Each factor contributes a relatively (to n) small number of actions to the plan</p>
    <p>Causal graph is not too dense</p>
    <p>Factored planning is more likely to scale up</p>
    <p>Does not depend on problem size and plan length directly</p>
    <p>Unfactored planning does not scale up with problem size</p>
    <p>Unless the plans are short . . . in which case factored planning is better, provided</p>
    <p>CG is not too dense</p>
  </div>
  <div class="page">
    <p>Is LID practically interesting?</p>
    <p>LID is appealing when</p>
    <p>plans not too long in relation to domain size</p>
    <p>relatively well balanced</p>
    <p>Is this setting of any relevance?</p>
  </div>
  <div class="page">
    <p>Is LID practically interesting?</p>
    <p>LID is appealing when</p>
    <p>plans not too long in relation to domain size</p>
    <p>relatively well balanced</p>
    <p>Is this setting of any relevance?</p>
    <p>YES!</p>
    <p>All solved instances in recent planning competitions have short step-optimal plans</p>
    <p>relative to n (indirectly from Hoffman, Subharwal, &amp; Domshlak, 06)</p>
    <p>Recent results indicate each action is used only a few times, and typically only once!</p>
    <p>(Geffner &amp; Vidal, 06)</p>
    <p>Over-subscription and distributed planning problems seem ideal a priori</p>
  </div>
  <div class="page">
    <p>Comparison with (Amir and Engelhardt 03)</p>
    <p>Similarity</p>
    <p>factoring + sequence of planning phases in iterative deepening on d</p>
    <p>similar guarantees of local optimality</p>
    <p>factoring is based on a certain graphical problem analysis</p>
    <p>Difference</p>
    <p>everything else</p>
    <p>Complexity guarantees?</p>
  </div>
  <div class="page">
    <p>Comparison with (Amir and Engelhardt 03)</p>
    <p>Similarity</p>
    <p>factoring + sequence of planning phases in iterative deepening on d</p>
    <p>similar guarantees of local optimality</p>
    <p>factoring is based on a certain graphical problem analysis</p>
    <p>Difference</p>
    <p>everything else</p>
    <p>Complexity guarantees</p>
    <p>No advantage to AE, and up to exp(n) reduction with LID</p>
    <p>Key: AE has to rely on graphs that are strictly denser than causal graphs</p>
  </div>
  <div class="page">
    <p>Generalized factoring</p>
    <p>Recall: we started with factor = single variable.</p>
    <p>Suppose we combine some v1, . . . , vk to form a single factor</p>
    <p>Same algorithm LID, but now a single local plan handles v1, . . . , vk</p>
    <p>Changes in SeqCSP:</p>
    <p>, Variable domain size increases, but only linearly in k</p>
    <p>/ Local depth  may increase to 1 +    + k.</p>
    <p>So is it good or bad?</p>
  </div>
  <div class="page">
    <p>Tree decomposition of the causal graph</p>
    <p>Fact: Every graph with tree-width w, can be transformed into a join-tree with node size</p>
    <p>w + 1</p>
    <p>Factoring = optimal join-tree of CG</p>
    <p>Join-tree width is 1 (because it is a tree)</p>
    <p>NP-complete, but not a too bad NP-complete [Amir01]</p>
    <p>Join-tree with node size 4w + 1 in time exp(w)</p>
    <p>Join-tree with node size log(n)w + 1 in time poly(n)</p>
  </div>
  <div class="page">
    <p>Tree decomposition of the causal graph</p>
    <p>Fact: Every graph with tree-width w, can be transformed into a join-tree with node size</p>
    <p>w + 1</p>
    <p>Factoring = optimal join-tree of CG</p>
    <p>Join-tree width is 1 (because it is a tree)</p>
    <p>Local plan length: (w + 1)avg  (w + 1)max</p>
    <p>Exponent (w + 1)   = 1  (w + 1)avg</p>
    <p>avg is likely to be smaller than , possibly much smaller!</p>
    <p>Bottom line:</p>
    <p>Join-tree provides a-priori best factorization.</p>
    <p>If you have some domain knowledge, seek join-tree that minimizes local plans</p>
    <p>length</p>
  </div>
  <div class="page">
    <p>Example</p>
    <p>= 1</p>
    <p>= 3</p>
  </div>
  <div class="page">
    <p>Summary: Insights</p>
    <p>Two crucial complexity parameters</p>
    <p>Domain parameter: causal graphs tree-width</p>
    <p>for factored and non-factored planning</p>
    <p>Problem specific parameter:</p>
    <p>Non-factored: length of (step-)optimal plan</p>
    <p>Factored: minmax length of local plans</p>
    <p>How to best factor domain:</p>
    <p>Use causal graph to create join-tree that minimizes minimax sum of value changes</p>
    <p>within sub-domains</p>
    <p>Comment: very similar objective in probabilistic reasoning</p>
  </div>
  <div class="page">
    <p>Contributions in a nutshell</p>
    <p>Complexity-wise best (so far?) approach for factored planning</p>
    <p>Tractable planning classes of practical interest</p>
    <p>Relation of local optimality to standard (to date) notions of optimality</p>
    <p>The star in our movie is the causal graph</p>
  </div>
</Presentation>
