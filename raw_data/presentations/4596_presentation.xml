<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Representing and Operating with Model Differences</p>
    <p>Jose E. Rivera, Antonio Vallecillo</p>
    <p>Universidad de Mlaga, Spain</p>
    <p>TOOLS Europe 2008, Zurich</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(2) June 30, 2008</p>
    <p>IntroductionIntroduction  Model-Driven Software Development (MDSD)</p>
    <p>Models are the key artifacts  Most of the efforts are currently on the definition of</p>
    <p>models, metamodels and transformations between them  Other model operations (e.g., model subtyping, model</p>
    <p>difference) are required in MDSD practices</p>
    <p>Model difference  An essential operation in several software development</p>
    <p>processes:  Version and change management  Software evolution  Model/data integration  etc.</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(3) June 30, 2008</p>
    <p>Model difference solutionsModel difference solutions  Previous approaches:</p>
    <p>Edit scripts and coloring techniques:  Do not produce models as results  Do not fulfill other interesting properties</p>
    <p>(composability) Based on text, data structures or models</p>
    <p>Usually restricted to a specific metamodel (UML)  Our approach:</p>
    <p>Model-based:  Differences are models, conforming to a metamodel</p>
    <p>Metamodel independent  Self-contained, compact, composable, applicable to</p>
    <p>models conforming to different metamodel  Implementation available integrated in Eclipse</p>
    <p>MAUDELINMAUDELIN GG</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(4) June 30, 2008</p>
    <p>Model comparisonModel comparison 1) Matching</p>
    <p>Finding different objects from the two models that represent the same element</p>
    <p>The result is a model:</p>
    <p>elements  The result is a model:</p>
    <p>Benefits:</p>
    <p>Self-contained Compact Independent of the metamodel of the source models</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(5) June 30, 2008</p>
    <p>Matching ObjectsMatching Objects</p>
    <p>Option 1: Using object persistent identifiers  Matching process is simple and robust</p>
    <p>But not always feasible!</p>
    <p>Option 2: Using structural similarities  Allows comparing models</p>
    <p>that do not use persistent object identifiers  conforming to different metamodels  that have evolved independently</p>
    <p>Harder to define and implement  You need an algorithm to identify the matches</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(6) June 30, 2008</p>
    <p>The Matching AlgorithmThe Matching Algorithm</p>
    <p>Compares objects independently of their depth in the containment tree Implies more comparisons ...but brings very interesting advantages:</p>
    <p>Moved elements through different levels can be detected;  Example of refactorization-&gt; adding packages</p>
    <p>Failing to identify a match does not condition other potential matches below in the tree hierarchy</p>
    <p>Implemented in Maude MAUDELINMAUDELIN</p>
    <p>GG</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(7) June 30, 2008</p>
    <p>The Matching AlgorithmThe Matching Algorithm  Comparing two objects:</p>
    <p>Class rate:</p>
    <p>Name rate:</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(8) June 30, 2008</p>
    <p>Matching Algorithm: Structural Matching Algorithm: Structural raterate Structural rate depends on the type of the feature</p>
    <p>Boolean attributes and enumerations match (with rate = 1.0) if they have the same value (otherwise rate = 0.0)</p>
    <p>String attribute values distances are calculated using the Levenshtein distance</p>
    <p>Numerical attribute values match rate is computed with a relative distance function (1-|n-m|/|n+m|) limited to [0..1]</p>
    <p>References are matched recursively, i.e., objects referenced are compared using the same match operation but without taking into account their own references (to avoid cycles)</p>
    <p>If the upper cardinality is greater than 1 (i.e., if its value is a collection), the average rate is calculated</p>
    <p>If a structural feature is defined only in one of the</p>
    <p>objects, a penalty is applied to the final sfRate</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(9) June 30, 2008</p>
    <p>Matching Algorithm: AnalysisMatching Algorithm: Analysis</p>
    <p>If (Rate &gt; Threshold) the two objects potentially match</p>
    <p>Initially considered (although it is fully configurable):  wc = 0.5; wsf = 0.25; wn = 0.0; Threshold = 0.66</p>
    <p>nameRate is used in models in which the attribute name is considered as an identifier.  If the name rate is omitted (wn=0.0), potential matches</p>
    <p>are harder: features should be more strongly related</p>
    <p>At the end of the process, only those objects that together obtain the biggest rate are kept</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(10) June 30, 2008</p>
    <p>Maude (Maude (http://maude.cs.uiuc.edu/)http://maude.cs.uiuc.edu/)  Formal notation and system</p>
    <p>High-level language and a high-performance interpreter and compiler of the OBJ algebraic specification family</p>
    <p>Supports membership equational and rewriting logic specification and programming</p>
    <p>Maude specifications are executable</p>
    <p>Supported by a toolkit  Executing the specifications, model-checking, theorem</p>
    <p>proving, termination and confluence, etc.</p>
    <p>Highly efficient and integrated with Eclipse</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(11) June 30, 2008</p>
    <p>Representing Representing ModelsModels in Maude in Maude  Maude supports OO specifications and computations</p>
    <p>Classes: class C | a1 : S1, ., an : Sn  Objects: &lt; O : C | a1 : v1, ., an : vn &gt;  Messages: msg m : S1  Sn -&gt; Msg .  A configuration is a multiset of objects and messages that</p>
    <p>evolves by rewriting rules</p>
    <p>Models are represented as configuration of objects</p>
    <p>Nodes</p>
    <p>Nodes attributes</p>
    <p>Nodes Edges</p>
    <p>Objects</p>
    <p>Objects attributes</p>
    <p>Multigraph Maude Configuration of</p>
    <p>objects</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(12) June 30, 2008</p>
    <p>Representing Representing MetamodelsMetamodels in in MaudeMaude Object-oriented modules (i.e., specifications)</p>
    <p>They contain the classes to which the Maude objects belong</p>
    <p>Models conform to metamodels by construction  Used to instantiate models, to add behavior</p>
    <p>Metamodels are models too!  They can be represented as Configuration of objects</p>
    <p>The classes of such objects will be the ones that specify the meta-metamodels (for example Ecore)</p>
    <p>Used to operate and reason about them</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(13) June 30, 2008</p>
    <p>(omod SimpleStateMachines is pr STRING . class State | name : String, stateMachine : Oid, incoming : Set{Oid}, outgoing : Set{Oid} . class StateMachine | initialState : Maybe{Oid}, containedState : Set{Oid} . class Transition | name : String, target : Oid, src : Oid . endom)</p>
    <p>Models and Metamodels in Models and Metamodels in MaudeMaude Simple State Machine example</p>
    <p>membership axioms</p>
    <p>&lt; SM : StateMachine | initialState : ST1, containedStates : (ST1, ST2) &gt; &lt; ST1 : State | name : &quot;St1&quot;, stateMachine : SM, outgoing : TR, incoming : empty &gt; &lt; ST2 : State | name : &quot;St2&quot;, stateMachine : SM, incoming : TR, outgoing : empty &gt; &lt; TR : Transition | name : &quot;Tr&quot;, src : ST1, target : ST2 &gt;</p>
    <p>Conforms to</p>
    <p>+</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(14) June 30, 2008</p>
    <p>Calculation of Differences op modelDiff : Configuration Configuration -&gt; DiffModel .</p>
    <p>Possible situations : The element appears in both models and has not</p>
    <p>been modified</p>
    <p>The element appears in both models but has been modified;</p>
    <p>ceq modelDiff(&lt; O1 : C | ATTS &gt; CONF1&gt; &lt; O2 : C | ATTS &gt; CONF2, MATCHM) = modelDiff(CONF1, CONF2, MATCHM) if match(O1, O2, MATCHM) .</p>
    <p>ceq modelDiff( &lt; O1 : C1 | ATTS1 &gt; CONF1, &lt; O2 : C2 | ATTS2 &gt; CONF2, MATCHM) = &lt; newModId(O1) : ModifiedElement | element : newId(O1), oldElement : oldId(O2) &gt; &lt; newId(O1) : C1 | attsDiff(ATTS1,ATTS2) &gt; &lt; oldId(O2) : C2 | attsDiff(ATTS2,ATTS1) &gt; modelDiff(CONF1,CONF2,MATCHM) if match(O1, O2, MATCHM) /\ (not(ATTS1 == ATTS2) or not(C1 == C2)) .</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(15) June 30, 2008</p>
    <p>Calculation of Differences The element only appears in the minuend model;</p>
    <p>The element only appears in the subtrahend model.</p>
    <p>Both the minuend and subtrahend models are empty:</p>
    <p>eq modelDiff( &lt; O1 : C1 | ATTS1 &gt; CONF1, CONF2, MATCHM ) = &lt; newAddId(O1) : AddedElement | element : newId(O1) &gt; &lt; newId(O1) : C1 | ATTS1 &gt; modelDiff(CONF1, CONF2, MATCHM) [owise] .</p>
    <p>eq modelDiff( CONF1, &lt; O2 : C2 | ATTS2 &gt; CONF2, MATCHM ) = &lt; newDelId(O2) : DeletedElement | element : oldId(O2) &gt; &lt; oldId(O2) : C2 | ATTS2 &gt; modelDiff(CONF1, CONF2, MATCHM) [owise] .</p>
    <p>eq modelDiff( none, none, MATCHMODEL ) = none .</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(16) June 30, 2008</p>
    <p>An ExampleAn Example</p>
    <p>&lt; SM : StateMachine | initialState : ST1, containedStates : (ST1, ST2) &gt; &lt; ST1 : State | name : &quot;St1&quot;, stateMachine : SM, outgoing : TR, incoming : empty &gt; &lt; ST2 : State | name : &quot;St2&quot;, stateMachine : SM, outgoing : empty, incoming : TR &gt; &lt; TR : Transition | name : &quot;Tr&quot;, src : ST1, target : ST2 &gt;</p>
    <p>&lt; SM : StateMachine | initialState : ST1, containedState : (ST1, ST2) &gt; &lt; ST1 : State | name : &quot;St1&quot;, stateMachine : SM, outgoing : TR, incoming : TR2 &gt; &lt; ST2 : State | name : &quot;St2&quot;, stateMachine : SM, outgoing : TR2, incoming : TR &gt; &lt; TR : Transition | name : &quot;Tr&quot;, src : ST1 , target : ST2 &gt; &lt; TR2 : Transition | name : &quot;Tr2&quot;, src : ST2 , target : ST1 &gt;</p>
    <p>(Minuend Model)</p>
    <p>(Subtrahend Model)</p>
    <p>Tr2</p>
    <p>&lt; 'ST1@MOD : ModifiedElement | element : 'ST1@NEW, oldElement : 'ST1@OLD&gt; &lt; 'ST1@NEW : State | incoming : 'TR2 &gt; &lt; 'ST1@OLD : State | incoming : empty &gt; &lt; 'ST2@MOD : ModifiedElement | element : 'ST2@NEW, oldElement : 'ST2@OLD &gt; &lt; 'ST2@NEW : State | outgoing : 'TR2 &gt; &lt; 'ST2@OLD : State | outgoing : empty &gt; &lt; 'TR2@ADD : AddedElement | element : 'TR2@NEW &gt; &lt; 'TR2@NEW : Transition | name : &quot;Tr2&quot;, src : 'ST2, target : 'ST1 &gt;</p>
    <p>(Difference Model)</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(17) June 30, 2008</p>
    <p>Further OperationsFurther Operations  Operation do</p>
    <p>do ( Ms , Md ) = Mm .  Applies to a model all the changes specified in a</p>
    <p>difference model</p>
    <p>Operation undo  undo ( Mm , Md ) = Ms .  Reverts all the changes specified in a difference model</p>
    <p>Sequential composition of differences  Very useful to, e.g., optimize the process of applying</p>
    <p>successive modifications to the same model</p>
    <p>undo(do(Ms, Md), Md) = Ms . do(undo(Mm, Md), Md) = Mm.</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(18) June 30, 2008</p>
    <p>do operation specificationdo operation specification op do : Configuration DiffModel -&gt; Configuration .</p>
    <p>eq do ( MODEL, &lt; O : AddedElement | element : NEWO &gt; &lt; NEWO : NEWC | NEWATTS &gt; CONF )</p>
    <p>= &lt; originalId(NEWO) : NEWC | NEWATTS &gt; do ( MODEL, CONF ) .</p>
    <p>ceq do (&lt; O : C | ATTS &gt; MODEL, &lt; O2 : DeletedElement | element : OLDO &gt; &lt; OLDO : OLDC | OLDATTS &gt; CONF )</p>
    <p>= do ( MODEL, CONF ) if O = originalId(OLDO) .</p>
    <p>ceq do (&lt; O : C | ATTS &gt; MODEL, &lt; O2 : ModifiedElement | element : NEWO, oldElement : OLDO &gt; &lt; NEWO : NEWC | NEWATTS &gt; &lt; OLDO : OLDC | OLDATTS &gt; CONF )</p>
    <p>= &lt; originalId(NEWO) : NEWC | (excludingAll(ATTS,OLDATTS), NEWATTS)) &gt; do(MODEL, CONF)</p>
    <p>if O = originalId(OLDO) .</p>
    <p>eq do ( MODEL, none ) = MODEL .</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(19) June 30, 2008</p>
    <p>ConclusionsConclusions  Model difference definition</p>
    <p>Independent of the metamodel of the source models  Can be fully integrated into other MDSD processes  Self-contained and compact  Applicable to models conforming to different metamodel  Suitable for composing deltas and implementing further</p>
    <p>operations on them  Results are very encouraging</p>
    <p>Tool support:  All the difference operations implemented in Maude  Integrated in Eclipse</p>
    <p>MAUDELINMAUDELIN GG</p>
  </div>
  <div class="page">
    <p>TOOLS Europe 2008(20) June 30, 2008</p>
    <p>Future WorkFuture Work  Make Maude completely transparent to the user</p>
    <p>Conflict detection and resolution of concurrent modifications</p>
    <p>Improving the matching algorithm  More complex heuristics  More customizable parameters</p>
    <p>Make model operations available via Web services</p>
  </div>
</Presentation>
