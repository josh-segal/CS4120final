<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>The Microarchitecture of FPGA-Based Soft Processors Peter Yiannacouras Jonathan Rose Greg Steffan</p>
    <p>University of Toronto Electrical and Computer Engineering</p>
  </div>
  <div class="page">
    <p>Processors and FPGAs</p>
    <p>Custom Logic Processor</p>
    <p>Our goal is to study the architecture of soft processors</p>
    <p>FPGA</p>
    <p>Processors present in many digital systems</p>
    <p>Soft processors - implemented in FPGA fabric</p>
  </div>
  <div class="page">
    <p>Motivation for understanding soft processor architecture</p>
    <p>FPGA Journal, November 2003</p>
    <p>This number has and will continue to increase</p>
  </div>
  <div class="page">
    <p>Dont we already understand processor architecture?</p>
    <p>Not accurately/completely  Accurate cycle-to-cycle behaviour  Estimated area/power  No clock frequency impact</p>
    <p>Not in FPGA domain  Lookup tables vs transistors  Dedicated RAMs and Multipliers fast</p>
    <p>Must revisit processor architecture in FPGA context</p>
  </div>
  <div class="page">
    <p>Research Goals</p>
    <p>Explore soft processor architecture experimentally</p>
  </div>
  <div class="page">
    <p>Soft Processor Rapid Exploration Environment (SPREE)</p>
    <p>SPREE</p>
    <p>RTL</p>
    <p>ISA  Datapath</p>
  </div>
  <div class="page">
    <p>Input: Instruction Set Architecture (ISA) Description</p>
    <p>SPREE</p>
    <p>RTL</p>
    <p>ISA  Datapath</p>
    <p>FETCH</p>
    <p>RFREAD</p>
    <p>ADD</p>
    <p>RFWRITE</p>
    <p>RFREAD</p>
    <p>MIPS ADD  add rd, rs, rt</p>
    <p>Graph of Generic Operations (GENOPs)  Edges indicate flow of data</p>
    <p>ISA currently fixed (subset of MIPS I)</p>
  </div>
  <div class="page">
    <p>Input: Datapath Description</p>
    <p>SPREE</p>
    <p>RTL</p>
    <p>ISA  Datapath</p>
    <p>Mul</p>
    <p>Ifetch Reg File</p>
    <p>ALU Write Back</p>
    <p>Mul</p>
    <p>Ifetch Reg File</p>
    <p>ALU Shifter</p>
    <p>Data Mem</p>
    <p>SPREE Component Library</p>
    <p>Mul</p>
    <p>Ifetch Reg file</p>
    <p>ALU Write Back</p>
    <p>Data Mem</p>
    <p>Limited to simple in-order issue pipelines</p>
    <p>Interconnection of hand-coded components  Allows efficient synthesis</p>
    <p>Described using C++</p>
  </div>
  <div class="page">
    <p>Step 1. ISA vs Datapath Verification</p>
    <p>SPREE</p>
    <p>RTL</p>
    <p>ISA  Datapath</p>
    <p>Components described using GENOPs</p>
    <p>FETCH</p>
    <p>RFREAD</p>
    <p>ADD</p>
    <p>RFWRITE</p>
    <p>RFREAD</p>
    <p>Mul</p>
    <p>Ifetch Reg File</p>
    <p>ALU Write Back</p>
    <p>Data Mem</p>
    <p>RFREAD</p>
    <p>RFREAD ADD</p>
    <p>RFWRITE</p>
    <p>FETCH</p>
    <p>Verify</p>
  </div>
  <div class="page">
    <p>Step 2. Datapath Instantiation</p>
    <p>SPREE</p>
    <p>RTL</p>
    <p>ISA  Datapath</p>
    <p>Multiplexer insertion  Unused connection/component removal</p>
    <p>Mul</p>
    <p>Ifetch Reg File</p>
    <p>ALU Write Back</p>
    <p>Data Mem</p>
  </div>
  <div class="page">
    <p>Step 3. Control Generation</p>
    <p>SPREE</p>
    <p>RTL</p>
    <p>ISA  Datapath</p>
    <p>Mul</p>
    <p>Ifetch Reg File</p>
    <p>ALU Write Back</p>
    <p>Data Mem</p>
    <p>Control Control Control Control</p>
    <p>Laborious step performed automatically</p>
  </div>
  <div class="page">
    <p>Verilog RTL</p>
    <p>Output: Verilog RTL Description</p>
    <p>SPREE</p>
    <p>RTL</p>
    <p>ISA  Datapath</p>
    <p>Mul</p>
    <p>Ifetch Reg File</p>
    <p>ALU Write Back</p>
    <p>Data Mem</p>
    <p>Control Control Control Control</p>
  </div>
  <div class="page">
    <p>Back-end Infrastructure RTL</p>
    <p>Quartus II 4.2 CAD Software</p>
    <p>Modelsim RTL Simulator</p>
    <p>Benchmarks (MiBench,</p>
    <p>Dhrystone 2.1, RATES, XiRisc)</p>
    <p>Stratix 1S40</p>
    <p>In this work we can measure each accurately!</p>
  </div>
  <div class="page">
    <p>Metrics for Measurement</p>
    <p>Area: Equivalent Stratix Logic Elements (LEs)  Relative silicon areas used for RAMs/Multipliers</p>
    <p>Performance: Wall clock time  Cycle count  clock frequency  Arithmetic mean across benchmark set</p>
    <p>Energy: Dynamic Energy (eg. nJ/instr)  Excluding I/O</p>
  </div>
  <div class="page">
    <p>RTL</p>
    <p>Trace-Based Verification</p>
    <p>Ensure SPREE generates functional processors</p>
    <p>Modelsim (RTL Simulator)</p>
    <p>MINT (Instruction-set</p>
    <p>Simulator)</p>
    <p>Benchmark Applications</p>
    <p>Compare</p>
    <p>Trace</p>
    <p>Trace</p>
    <p>All generated soft processors are verified this way</p>
  </div>
  <div class="page">
    <p>Architectural Exploration Results</p>
  </div>
  <div class="page">
    <p>Architectural Features Explored</p>
    <p>Hardware vs software multiplication  Shifter implementation  Pipelining</p>
    <p>Depth  Organization  Forwarding</p>
  </div>
  <div class="page">
    <p>Validation of SPREE Through Comparison to Alteras Nios II  Has three variations:</p>
    <p>Nios II/e  unpipelined, no HW multiplier  Nios II/s  5-stage, with HW multiplier  Nios II/f  6-stage, dynamic branch prediction</p>
    <p>Caveats  not completely fair comparison  Very similar but tweaked ISA  Nios II Supports exceptions, OS, and caches</p>
    <p>We do not and save on the hardware costs</p>
    <p>We believe the comparison is meaningful</p>
  </div>
  <div class="page">
    <p>SPREE vs Nios II</p>
    <p>Competitive and can dominate (9% smaller, 11% faster)</p>
    <p>smaller</p>
    <p>faster</p>
    <p>-3-stage pipe -HW multiply -Multiply-based shifter</p>
  </div>
  <div class="page">
    <p>Architectural Features Explored</p>
    <p>Hardware vs software multiplication  Shifter implementation  Pipelining</p>
    <p>Depth  Organization  Forwarding</p>
  </div>
  <div class="page">
    <p>Hardware vs Software Multiplication  Hardware multiply is fast but not always needed</p>
    <p>Wastes area (220 LEs) and can waste energy</p>
    <p>Total energy wasted if few multiply instructions, saved if many</p>
  </div>
  <div class="page">
    <p>Shifter Implementation</p>
    <p>Shifters are expensive in FPGAs  We explore three implementations:</p>
  </div>
  <div class="page">
    <p>Performance-Area of Different Shifter Implementations</p>
    <p>smaller</p>
    <p>faster</p>
    <p>Multplier-based shifter is a good compromise</p>
  </div>
  <div class="page">
    <p>Pipeline Depth</p>
    <p>Explored between 2 and 7 stages  1-stage and 6-stage pipeline not interesting</p>
    <p>F D R/EX EX/M WB</p>
    <p>F D R/EX/M WB</p>
    <p>F/D R/EX/M WB</p>
    <p>F/D/R/EX/M WB2-stage</p>
    <p>F D EX EX/M WB(new) 7-stage R EX</p>
  </div>
  <div class="page">
    <p>Pipeline Depth and Performance</p>
  </div>
  <div class="page">
    <p>Pipeline Organization Tradeoff</p>
    <p>F D R/EX/M WB</p>
    <p>F/D R/EX EX/M WB</p>
  </div>
  <div class="page">
    <p>Pipeline Forwarding</p>
    <p>Prevent stalls when data hazards occur  MIPS has two source operands (rs &amp; rt)  Four forwarding configuration are possible:</p>
    <p>No forwarding  Forward rs  Forward rt  Forward both rs and rt</p>
    <p>F D/R EX M WB</p>
  </div>
  <div class="page">
    <p>Pipeline Forwarding</p>
    <p>Up to 20% speed improvement for both operands</p>
    <p>The rs operand benefits more than rt (9% faster)</p>
  </div>
  <div class="page">
    <p>Summary of Presented Architectural Conclusions</p>
    <p>Hardware multiplication can be wasteful  Multiplier-based shifter is a sweet spot  3-stage pipelines are attractive  Tradeoffs exist within pipeline organization  Forwarding</p>
    <p>Improves performance by 20%  Favours the rs operand</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Explore other exciting architectural axes  Branch prediction, aggressive forwarding  ISA changes  VLIW datapaths  Caches and memory hierarchy  Compiler optimizations</p>
    <p>Port to other devices  Explore aggressive customization  Add exceptions and OS support</p>
  </div>
</Presentation>
