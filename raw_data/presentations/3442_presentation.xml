<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>MAN-IN-THE-MACHINE: EXPLOIT ILL-SECURE COMMUNICATION</p>
    <p>INSIDE THE COMPUTER Thanh Bui*, Siddharth Rao*, Markku Antikainen,</p>
    <p>Viswanathan Bojan*, Tuomas Aura* *Aalto University, Finland University of Helsinki, Finland</p>
    <p>USENIX Security 2018</p>
  </div>
  <div class="page">
    <p>Traditional network threat model</p>
    <p>Server and user device are trusted  Untrusted network:</p>
    <p>man in the middle  Solution: crypto (TLS and web PKI)</p>
    <p>to protect communication</p>
    <p>Server</p>
    <p>User device</p>
    <p>Client</p>
  </div>
  <div class="page">
    <p>Not all communication goes over the network</p>
    <p>Software consists of multiple local processes that need to communicate</p>
    <p>We try to understand security of communication inside the computer</p>
    <p>Our focus: Inter-process communication (IPC)</p>
    <p>User device</p>
    <p>Frontend process</p>
    <p>Backend process</p>
  </div>
  <div class="page">
    <p>Man-in-the-Machine (MitMa)</p>
  </div>
  <div class="page">
    <p>Man-in-the-Machine (MitMa)</p>
    <p>Attacker: Unprivileged user, e.g. coworker, guest user  Target: Multi-user computers  Method: Intercept IPC from the attackers login session</p>
    <p>Fast user switching, nohup, remote access (SSH and remote desktop)</p>
    <p>Victims session</p>
    <p>Attackers session Evil process</p>
    <p>Frontend process</p>
    <p>Backend process</p>
  </div>
  <div class="page">
    <p>What makes IPC vulnerable</p>
    <p>Vulnerable IPC methods: Server binds to a specific identifier or name and waits for client communication  Client and server impersonation possible:</p>
    <p>Network socket on localhost 127.0.0.1:&lt;port&gt;  Named pipe on Windows \\.\pipe\</p>
    <p>Unauthorized access to Windows USB HID devices (e.g. security keys)</p>
    <p>Secure IPC methods: No server waiting for clients  Socket pairs  Unnamed pipes</p>
  </div>
  <div class="page">
    <p>Case studies</p>
  </div>
  <div class="page">
    <p>Native desktop app manages the password vault  Browser extension enters passwords into login pages and</p>
    <p>stores new ones in the vault  Native app and browser extension communicate via IPC</p>
    <p>Web browser</p>
    <p>Native app</p>
    <p>Browser extension</p>
    <p>Standalone password managers</p>
  </div>
  <div class="page">
    <p>Desktop app runs a HTTP server on a port 54512  Browser extension connects as a client to the server  NO authentication</p>
    <p>Web browser</p>
    <p>Browser extension</p>
    <p>Native app</p>
    <p>Case 1: RoboForm</p>
  </div>
  <div class="page">
    <p>Client impersonation on RoboForm</p>
    <p>Web browser</p>
    <p>Browser extension</p>
    <p>Native app</p>
    <p>MitMa attacker</p>
  </div>
  <div class="page">
    <p>Case 2: 1Password</p>
    <p>Desktop app runs a WebSocket server on port 6263  Server verifies client by checking:</p>
    <p>Browser extension ID  Code signature  Server and client processes owned by the same user</p>
    <p>Client does NOT verify the server  Server and client run a cryptographic protocol to agree on a</p>
    <p>shared key, but its ad-hoc design is insecure</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Insecure protocol  No server verification</p>
    <p>Server impersonation</p>
  </div>
  <div class="page">
    <p>Server impersonation on 1Password</p>
    <p>Web browser</p>
    <p>Browser extension</p>
    <p>MitMa attacker</p>
  </div>
  <div class="page">
    <p>Case 3: FIDO U2F security key</p>
    <p>2nd authentication factor based on public-key crypto</p>
    <p>Challenge-response protocol  Browser keeps sending the</p>
    <p>challenge to the device  User activates the device</p>
    <p>by touching a button on it  The device responds to</p>
    <p>only the first request after the touch</p>
    <p>Browser Security key Server</p>
    <p>username, password</p>
    <p>Verify password</p>
    <p>challenge challenge</p>
    <p>User touches button</p>
    <p>response response</p>
    <p>Verify response</p>
  </div>
  <div class="page">
    <p>Unauthorized access of FIDO U2F key</p>
    <p>Assumption: Attacker has obtained the 1st authentication factor</p>
    <p>Attack steps: 1. Attacker signs in using the 1st factor and receives a challenge 2. Attacker keeps sending the challenge to the device at a high</p>
    <p>rate 3. Victim signs in to ANY service using the same security key</p>
    <p>and touches the button on the device  Attacker receives the response with high probability</p>
    <p>On Windows, USB HIDs can be accessed from any user session</p>
  </div>
  <div class="page">
    <p>Application OS IPC Channel Attack</p>
    <p>Password managers</p>
    <p>Roboform macOS Network socket Client imp. Dashlane macOS, Windows Network socket Server imp. 1Password macOS Network socket Server imp.</p>
    <p>F-Secure Key macOS, Windows Network socket Client imp. Server imp. Password Boss Windows Named pipe MitM Sticky Password macOS Network socket</p>
    <p>Client imp. Server imp.</p>
    <p>Hardware tokens</p>
    <p>FIDO U2F Key Windows USB Unauthorized access DigiSign macOS, Windows, Linux Network socket Client imp.</p>
    <p>Others</p>
    <p>MySQL Windows Named pipe MitM Transmission macOS, Windows, Linux Network socket Client imp. Spotify macOS, Windows, Linux Network socket Client imp. Blizzard macOS, Windows Network socket Client imp. Keybase Windows Named pipe Server imp.</p>
  </div>
  <div class="page">
    <p>Mitigation</p>
    <p>Spatial and temporal separation of users  Limit the number of users that have access a computer  Disable remote access: SSH, Remote desktop</p>
    <p>Attack detection easier in IPC than in network  Compare owner of client and server processes with OS</p>
    <p>APIs  Cryptographic protection</p>
    <p>User-assisted pairing vs TLS and PKI  Avoid self-made crypto!</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>IPC is not inherently secure!  IPC client-server architecture may be vulnerable to client and</p>
    <p>server impersonation and man-in-the-middle attacks  Unprivileged user or process can attack IPC of other users on</p>
    <p>the same computer</p>
  </div>
</Presentation>
