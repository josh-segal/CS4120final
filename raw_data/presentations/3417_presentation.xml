<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>CacheD: Identifying Cache-Based Timing Channels in Production Software</p>
    <p>USENIX Security 2017</p>
    <p>Shuai Wang, Pei Wang, Xiao Liu, Danfeng Zhang, Dinghao Wu</p>
    <p>The Pennsylvania State University</p>
  </div>
  <div class="page">
    <p>Outline  Background  Overview  Design  Evaluation</p>
  </div>
  <div class="page">
    <p>Cache-based Timing Channel Attack</p>
    <p>Hit Miss Hit Miss Miss Miss Hit Hit Hit Miss Hit Miss Hit Miss Miss Hit Miss Miss Miss Hit</p>
    <p>Hit Miss Hit Miss Miss Miss Hit Hit Hit Miss Hit Hit Miss Miss Miss Hit Miss Miss Miss Hit</p>
    <p>Secret Input Trace of Cache Status</p>
    <p>By (indirectly) observing cache status variants, attackers can infer which secret input is feed to the program.</p>
    <p>Some pictures are from http://www.securecontenttechnologies.com/paloalto.html and http://clipartix.com/key-clipart/.</p>
  </div>
  <div class="page">
    <p>Cache-based Timing Channel Attack Leakage due to secretdependent control flow</p>
    <p>r = 1; for i from n1 to 0 {</p>
    <p>r = rr mod m; if (e[i] == 1) {</p>
    <p>r = rb mod m; }</p>
    <p>}</p>
    <p>square-and-multiply implementation of modular exponentiation.</p>
    <p>Real vulnerabilities in RSA and ElGamal implementations.</p>
    <p>Leakage due to secretdependent memory access</p>
    <p>idx = 0; for i from 0 to n-1 {</p>
    <p>idx = window_ith(key, i); t = table[idx];</p>
    <p>}</p>
    <p>sliding-window-based modular exponentiation.</p>
    <p>Real vulnerabilities in AES, RSA and ElGamal implementations.</p>
    <p>n-bit secret exponent e</p>
    <p>secret keywindow size of key Prime+Probe corresponding</p>
    <p>cache line</p>
    <p>Prime+Probe corresponding</p>
    <p>cache line</p>
  </div>
  <div class="page">
    <p>Threat Model Attackers share the same hardware platform with the victim</p>
    <p>A common scenario in the era of cloud computing.  (Indirectly) learn the trace of cache lines being accessed.</p>
    <p>Our threat model is stronger than those based on cache hit/miss</p>
    <p>A trace of cache lines being accessed uniquely determines cache hit/miss at any program point.</p>
    <p>Cache line-based abstraction makes the vulnerability analysis more general</p>
    <p>This abstraction is independent of cache implementation details.</p>
  </div>
  <div class="page">
    <p>The Goal of Our Project Existing work</p>
    <p>Prove the absence of side channels in software.  Identify the upper-bound of information leakage.  Unable to provide counter examples to trigger vulnerabilities.  May suffer from scalability issue.</p>
    <p>Find cache-based timing channels in production software</p>
    <p>Identify variants in cache line access traces.  Provide counter examples (a pair of program secrets) to trigger</p>
    <p>such cache behavior variants.  Scalable enough to analyze real world software systems.</p>
  </div>
  <div class="page">
    <p>Set-Associative Cache</p>
    <p>The minimal storage unit of a cache is called a line and the cache is divided into sets consisting of the same number of lines.  Set index: locate the set in which the data may be stored.  Tag: confirm the data is present in one of its lines (cache</p>
    <p>hit vs. cache miss).  Line offset: locate the data inside a cache line. The upper NL bits of a memory address maps a memory access to a cache line access.</p>
  </div>
  <div class="page">
    <p>Outline  Background  Overview  Design  Evaluation</p>
  </div>
  <div class="page">
    <p>A Motivating Example</p>
    <p>Secret-dependent memory access (where &amp; how):  Capture program secret dependence  Construct symbolic formula</p>
    <p>Program secret flow in the first loop iteration secret</p>
    <p>mov index, (0+secret)%128 load t, 10 + 4 * index load t, 10 + 4 * index % 4</p>
    <p>F1 =10+4secret mod 128 F2 =10+4(secret mod 128) mod 4</p>
  </div>
  <div class="page">
    <p>Checking Cache Line Access Variants</p>
    <p>F(): symbolic formula in which the only free variable is program secret . F(): substituting all occurrences of  in F with a new variable . L: recall only the upper N-L bits are relevant to the cache behavior. C: conjunction of branch conditions; yielding a valid path to the memory access. Constraint: can different secrets (here  must not be equal to ) lead to different cache line access? Satisfiable solution: cache line access variants would depend on program secrets.</p>
    <p>F()  F() L  L  C</p>
  </div>
  <div class="page">
    <p>Return to the Motivating Example</p>
    <p>t = table[index]: memory access formula  F(k)  10+4k mod 128 cache line access formula  F(k) &gt;&gt; 6  10+4k mod 128 &gt;&gt; 6 satisfiability of F()  6  F()  6  [=1,  =30] interpretation of the results:  different k can access different cache lines</p>
    <p>By observing different cache line accesses, attackers may be able to</p>
    <p>infer program secrets.</p>
    <p>L equals 6 is a standard configuration.</p>
  </div>
  <div class="page">
    <p>Return to the Motivating Example</p>
    <p>t = table[index%4]: memory access formula  F(k)  10+4(k mod 128) mod 4 cache line access formula  F(k) &gt;&gt; 6  10+4(k mod 128) mod 4 &gt;&gt; 6 satisfiability of F()  6  F()  6  NO satisfiable solution interpretation of the results:  cache line access is independent with k</p>
    <p>On the current execution trace, this memory access is free from the</p>
    <p>threats we are interested.</p>
  </div>
  <div class="page">
    <p>Outline  Background  Overview  Design  Evaluation</p>
  </div>
  <div class="page">
    <p>Design Overview</p>
    <p>Online: execution trace-logging to get a single trace.  Offline: execution trace analysis:</p>
    <p>Taint analysis with the program secrets as taint seed.  Lift program secrets as free symbols, and perform symbolic</p>
    <p>execution on the tainted instructions.  For each collected pair of memory addressing formula and path</p>
    <p>condition, perform constraint solving.  The satisfiable solution for a memory access indicates a potential</p>
    <p>vulnerable program point.</p>
    <p>Programmers can provide inputs to cover security-sensitive code</p>
    <p>components.</p>
  </div>
  <div class="page">
    <p>Taint Analysis Leverage taint analysis to capture instructions that are dependent on the program secrets  Taint propagation rules:</p>
    <p>Registers: straightforward tainting rules.  CPU flags: taint all CPU flags that can be affected in case any</p>
    <p>operand in an instruction is tainted.  Memory:</p>
    <p>Taint memory if the stored content is tainted (explicit information flow).</p>
    <p>Whenever the base registers or the offsets are tainted, the visited memory content is tainted (implicit information flow).</p>
  </div>
  <div class="page">
    <p>Symbolic Execution Symbolic execution is used to construct memory addressing formulas and path conditions</p>
    <p>Symbolization of program secrets :  One free key symbol for register or memory that store the secrets.</p>
    <p>Symbolic engine:  Computation along the trace through symbolic values.  Implicit information flow through memory access: symbolize the</p>
    <p>visited memory content if the addressing formula contains key symbols.</p>
  </div>
  <div class="page">
    <p>Optimization: Identify Independent Vulnerabilities</p>
    <p>No solution for F()  F()  C  Memory access is independent of the secret.  Opt: no need to create new key symbol.</p>
    <p>Has solution for F()  L  F()  L  C  Independent point: further vulnerable points depend on this one.  Timing channel could probably leak the same piece of information.  Most-likely attack surface but attack on further points are feasible.</p>
    <p>Has solution for F()  F()  C but no solution for F()  L  F()  L  C  Different secrets would still access different memory cells.  Can construct information flow so we create new key symbol.</p>
    <p>load reg, [F(k)] In general, we create new key symbol for</p>
    <p>the load output.</p>
  </div>
  <div class="page">
    <p>Outline  Background  Overview  Design  Evaluation</p>
  </div>
  <div class="page">
    <p>Evaluation Cases</p>
    <p>Algorithm Implementation Versions</p>
    <p>RSA Libgcrypt OpenSSL</p>
    <p>Botan</p>
    <p>AES OpenSSL 0.9.7c; 1.0.2f</p>
    <p>Write sample code to invoke the decryption routine of each implementation.</p>
    <p>Default compilation and configuration settings when building each cryptosystem.</p>
  </div>
  <div class="page">
    <p>Evaluation Results Overview</p>
    <p>We identified known vulnerabilities, and discovered new program points that can potentially lead to cache access variants.</p>
    <p>Known/unknown independent vulnerable points are also identified, which indicates most-likely attack surface.</p>
    <p>Scalability: CacheD processes over 120 million instructions within 17 CPU hours.</p>
  </div>
  <div class="page">
    <p>Exploring Independent Vulnerabilities</p>
    <p>Instrument the source code and modify secrets with (k, k).  Monitor the execution of instrumented code and intercept cache access</p>
    <p>from CPU to L1 Data Cache using a hardware simulator (gem5).  Memory accesses at all vulnerable points visit different cache lines.  Cache status are different at the vulnerable program points for most of</p>
    <p>the cases.</p>
    <p>Conservatively check the cache status only at the</p>
    <p>vulnerable program points!</p>
  </div>
  <div class="page">
    <p>Case Study of RSA Vulnerabilities</p>
    <p>Case study of two RSA vulnerable program points in Libgcrypt (v1.6.1).  Program secrets are marked as red.  Vulnerable program points in the source and traces are bold.  For each vulnerable program point, the constraint solver gives a pair of</p>
    <p>counter examples (k, k).  Observation in the hardware simulator shows cache behavior variants.</p>
  </div>
  <div class="page">
    <p>Unknown Vulnerabilities in OpenSSL RSA Implementation</p>
    <p>A lookup table to determine the exact number of bits in the last entry of a-&gt;d.</p>
    <p>Calculate the length of the secret key by bit.</p>
    <p>Previously unknown vulnerable program point.</p>
    <p>We have also identified unknown vulnerabilities in Botan (1.10.13) RSA decryption procedures.</p>
  </div>
  <div class="page">
    <p>Summary Identify cache-based timing channels in production software</p>
    <p>A trace-based analysis method that models the cache line access variants.</p>
    <p>A conceptually simple yet general enough model to capture most adopted threats.</p>
    <p>Perform precise and scalable analysis to identify known vulnerabilities as well as discover previously unknown issue.</p>
  </div>
  <div class="page">
    <p>Thank You</p>
    <p>Q &amp; A</p>
    <p>Shuai Wang http://www.personal.psu.edu/szw175/</p>
  </div>
</Presentation>
