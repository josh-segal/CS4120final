<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Hacking in Darkness: Return-oriented Programming</p>
    <p>against Secure Enclaves</p>
    <p>Jaehyuk Lee Jinsoo Jang Yeongjin Jang</p>
    <p>Nohyun Kwak Yeseul Choi Changho Choi</p>
    <p>Taesoo Kim Marcus Peinado Brent Byunghoon Kang</p>
  </div>
  <div class="page">
    <p>Big Idea: Cloud Computing</p>
    <p>Big Hurdle: Security</p>
  </div>
  <div class="page">
    <p>SGX protects enclave from outside</p>
    <p>Code</p>
    <p>System Administrator</p>
    <p>Untrusted Operating System</p>
    <p>Untrusted Application</p>
    <p>Secure Enclave</p>
    <p>Data Code CPU Package</p>
  </div>
  <div class="page">
    <p>Memory encryption in SGX</p>
    <p>Physical Memory</p>
    <p>MEE encrypts all contents of the enclave memory  Decrypts using the hardware provided key  Cold boot attacks &amp; Snooping is impossible</p>
    <p>Plain Text</p>
    <p>CPU</p>
    <p>Snooping</p>
    <p>MEE</p>
  </div>
  <div class="page">
    <p>Another Enclave</p>
    <p>System Software</p>
    <p>Memory protection in SGX</p>
    <p>MMU keeps system software from accessing Enclaves  Allows the accessibility of the enclave to its own contents</p>
    <p>CPU</p>
    <p>MMU</p>
    <p>Physical Memory</p>
  </div>
  <div class="page">
    <p>Data Code</p>
    <p>Untrusted Operating System</p>
    <p>Untrusted Application</p>
    <p>Secure Enclave</p>
    <p>Data Code CPU Package</p>
    <p>Remote Server</p>
    <p>Now, can we say all software is secure ?</p>
  </div>
  <div class="page">
    <p>Software vulnerabilities are prevalent</p>
    <p>Vulnerabilities By Year (http://www.cvedetails.com/browse-by-date.php)</p>
  </div>
  <div class="page">
    <p>void vuln(char *input) {</p>
    <p>char dst[0x100];</p>
    <p>memcpy(dst, input, 0x200);</p>
    <p>}</p>
    <p>ret</p>
    <p>dst</p>
    <p>Return-oriented programming (ROP) attack</p>
    <p>Stack</p>
  </div>
  <div class="page">
    <p>void vuln(char *input) {</p>
    <p>char dst[0x100];</p>
    <p>memcpy(dst, input, 0x200);</p>
    <p>}</p>
    <p>ret</p>
    <p>dst</p>
    <p>Return-oriented programming (ROP) attack</p>
    <p>/bin/sh</p>
    <p>e.g., system(/bin/sh)</p>
    <p>StackStack</p>
  </div>
  <div class="page">
    <p>void vuln(char *input) {</p>
    <p>char dst[0x100];</p>
    <p>memcpy(dst, input, 0x200);</p>
    <p>}</p>
    <p>system(/bin/sh)</p>
    <p>ret</p>
    <p>dst</p>
    <p>Return-oriented programming (ROP) attack</p>
    <p>e.g., system(/bin/sh)</p>
    <p>pop rdi; ret</p>
    <p>/bin/sh</p>
    <p>Stack StackStack</p>
    <p>Addresses of the pop gadget &amp; function are known (e.g., reverse engineering)</p>
  </div>
  <div class="page">
    <p>Deploying an encrypted binary in SGX</p>
    <p>Operating System loads the enclave pages to memory.  Malicious OS can see the content of enclave binaries.</p>
    <p>Software vendor can make use of full encryption over enclave binaries.</p>
    <p>Prevent the reverse engineering.</p>
    <p>VC3 first showed private code can be loaded to enclaves.</p>
  </div>
  <div class="page">
    <p>Deploying an encrypted binary in SGX</p>
    <p>Remote Server</p>
    <p>Private code Encrypted code</p>
    <p>User platform</p>
    <p>Secure Enclave</p>
    <p>Public Loader</p>
    <p>Encryption over the binary to prevent reverse engineering 12</p>
  </div>
  <div class="page">
    <p>ROP inside an enclave</p>
    <p>void vuln(char *input) {</p>
    <p>char dst[0x100];</p>
    <p>memcpy(dst, input, 0x200);</p>
    <p>}</p>
    <p>dst</p>
    <p>Code is not visible (i.e., loaded in an encrypted form)</p>
    <p>- 0x100: ???? - 0x200: ????</p>
    <p>ret 0x0110 0x0118</p>
    <p>- Crashed @0x0108 - Where to jump?</p>
    <p>You (attacker) are a malicious OS!</p>
    <p>Stack Stack</p>
    <p>For the enclave binaries Addresses of the pop gadget &amp; function</p>
    <p>are unknown</p>
  </div>
  <div class="page">
    <p>Threat model of Dark-ROP  The attacker has full control of all software of the system</p>
    <p>including the operating system and the untrusted app.</p>
    <p>The attacker can make the enclave program crash multiple times.</p>
    <p>Inspecting the program behavior from the crash.</p>
    <p>The application is built with a standard compiler with Intel SDK</p>
    <p>(e.g. Visual Studio for SGX, or gcc)</p>
    <p>Enclave application is distributed in an encrypted format</p>
    <p>All the runtime information of the enclaves are hidden</p>
  </div>
  <div class="page">
    <p>Contribution of Dark-ROP</p>
    <p>We devise a new way to launch a code-reuse attack against encrypted enclave binaries</p>
    <p>Finding POP gadgets to control registers in enclaves  Finding memcpy function to copy data from enclaves</p>
    <p>The Dark-ROP attack can completely disarm the security guarantees of SGX</p>
    <p>Decrypting and generating the correctly sealed data.  Bypassing local and remote attestation.</p>
  </div>
  <div class="page">
    <p>Dark ROP: ROP in darkness</p>
    <p>Step 1. Finding the locations of pop gadgets  Pop gadget: bunch of pops followed by ret instruction.</p>
    <p>pop r??; ret  pop r??; pop r??; ret</p>
    <p>Enabling load value into the registers in enclave context</p>
    <p>Step 2. Locating ENCLU + pop rax (i.e., EEXIT)  ENCLU instruction is used to</p>
    <p>Decipher pop gadgets  Retrieve the hardware provided key for unsealing  Generate the malicious report data to bypass remote attestation</p>
  </div>
  <div class="page">
    <p>Dark ROP: ROP in darkness</p>
    <p>Step 3. Deciphering all pop gadgets  ENCLU instruction is used to decipher pop gadgets found at</p>
    <p>first step.</p>
    <p>Discerning which gadget loads value to which register.  pop r??; ret -&gt; pop rax; ret;</p>
    <p>Step 4. Locating memcpy()  Copying secret data from the enclaves</p>
    <p>Injecting malicious data to the enclaves</p>
  </div>
  <div class="page">
    <p>Step 1. Looking for pop gadgets</p>
    <p>Attackers have a full control over the layout of the enclave</p>
    <p>Address Access</p>
    <p>Permission</p>
    <p>E N C L A V E</p>
    <p>rw</p>
    <p>Enclave Memory map</p>
    <p>Stack</p>
    <p>Heap</p>
    <p>Code</p>
  </div>
  <div class="page">
    <p>Step 1. Looking for pop gadgets</p>
    <p>Exception Context</p>
    <p>When Exception happens</p>
    <p>inside enclave</p>
    <p>CPU fills synthetic state But, we know</p>
    <p>which page incurs fault</p>
    <p>Enclave Context</p>
    <p>CPU</p>
    <p>rax = 0x00000003 rdx = 0x00000000</p>
    <p>. cr2 = 0x7f181000</p>
    <p>CPU</p>
    <p>Asynchronous Enclave Exit (AEX)</p>
    <p>rax = 0x00000001 rdx = 0x00000002</p>
    <p>.</p>
  </div>
  <div class="page">
    <p>Step 1. Looking for pop gadgets 0xF7500000</p>
    <p>ret</p>
    <p>Enc code</p>
    <p>Enc heap</p>
    <p>Write addresses of non-executable pages on the stack</p>
    <p>RET to a non-executable address produces a page fault and an AEX  This is how we find RET instructions.</p>
    <p>The page incurring the fault is known (CR2 register)</p>
    <p>The faulting page tells us how many POPs happened before the RET</p>
    <p>Enc Stack</p>
    <p>Key idea</p>
    <p>No POP gadget Undefined behavior</p>
  </div>
  <div class="page">
    <p>Step 1. Looking for pop gadgets</p>
    <p>ret</p>
    <p>Enc code</p>
    <p>Enc heap</p>
    <p>ret</p>
    <p>pop r?? ret</p>
    <p>One POP and a RET Page fault at the second address</p>
    <p>No POP gadget Undefined behavior</p>
    <p>CR2 = 0xF7742000 (segfault)</p>
  </div>
  <div class="page">
    <p>Step 1. Looking for pop gadgets</p>
    <p>CR2 = 0xF7742000 (segfault)</p>
    <p>ret</p>
    <p>Enc code</p>
    <p>Enc heap</p>
    <p>ret</p>
    <p>pop r?? ret</p>
    <p>CR2 = 0xF7744000 (segfault)</p>
    <p>ret 0xF7741000</p>
    <p>pop r?? pop r?? pop r?? ret</p>
    <p>No POP gadget Undefined behavior</p>
  </div>
  <div class="page">
    <p>Catalog of pop gadgets (unknown args)</p>
    <p>Step 1. Looking for pop gadgets</p>
    <p>CR2 = 0xF7742000 (segfault)</p>
    <p>ret</p>
    <p>pop r?? ret</p>
    <p>CR2 = 0xF7744000 (segfault)</p>
    <p>ret</p>
    <p>pop r?? pop r?? pop r?? ret</p>
    <p>Search entire enclave code</p>
  </div>
  <div class="page">
    <p>Catalog of pop gadgets (unknown args)</p>
    <p>We still need to find the target registers</p>
    <p>Catalog of pop gadgets (known args)</p>
  </div>
  <div class="page">
    <p>Step 2. Looking for ENCLU: One opcode represents multiple functionalities</p>
    <p>ENCLU instruction handles all user level enclave operations.  ENCLU behavior depends on RAX value.  RAX = 4 -&gt; Enclave exit.  EEXIT does not erase enclave register values.</p>
    <p>ENCLU</p>
    <p>EREPORT</p>
    <p>EGETKEY</p>
    <p>EEXIT</p>
    <p>EMODPE</p>
    <p>Create a cryptographic report</p>
    <p>Retrieve a cryptographic key</p>
    <p>Synchronously exit an enclave</p>
    <p>Extend an access permission of EPC</p>
    <p>Rax value Leaf function Description</p>
  </div>
  <div class="page">
    <p>Step 2. Looking for ENCLU instruction</p>
    <p>It's &quot;required&quot; to have a ENCLU (to exit) for proper functioning.</p>
    <p>Chain multiple pop gadgets we found</p>
    <p>in step 1 with a probing address.</p>
    <p>IF POP gadget loads RAX = 4</p>
    <p>and ENCLU at probing address</p>
    <p>then EEXIT happens</p>
    <p>pop;pop;pop;ret</p>
    <p>ENCLU ??</p>
    <p>ret</p>
    <p>pop;ret</p>
    <p>Enc Stack</p>
    <p>.</p>
    <p>rax = 0x00000004 rbx = 0x00000004 rcx = 0x00000004</p>
  </div>
  <div class="page">
    <p>Step 2. Looking for ENCLU instruction</p>
    <p>How do we know whether eexit is invoked ?</p>
    <p>If EEXIT happens, it will jump to address loaded in RBX register.</p>
    <p>If pop rax; ret &amp; pop rbx; ret gadget was chained, enclave exits to 0x4</p>
    <p>Application Space</p>
    <p>SEGFAULT !</p>
    <p>pop;pop;pop;ret</p>
    <p>ENCLU ??</p>
    <p>pop;ret</p>
    <p>Enc Stack Untrusted App</p>
    <p>rip = 0x00000004 .</p>
    <p>rax = 0x00000004 rbx = 0x00000004 rcx = 0x00000004</p>
  </div>
  <div class="page">
    <p>Step 2. Looking for pop rax; ret  Now, locate pop rax; ret; gadget</p>
    <p>EEXIT (RAX == 0x4) / AEX (RAX == 0x3)  Chain gadgets one by one and checks EEXIT happens</p>
    <p>pop;pop;ret</p>
    <p>ENCLU0xF751b000</p>
    <p>pop;ret</p>
    <p>SEGFAULT &amp;</p>
    <p>RAX == 0x3</p>
    <p>AEX!!</p>
    <p>Enc Stack</p>
  </div>
  <div class="page">
    <p>Step 2. Looking for pop rax; ret  Now, locate pop rax; ret; gadget</p>
    <p>EEXIT (RAX == 0x4) / AEX (RAX == 0x3)  Chain gadgets one by one and checks EEXIT happens</p>
    <p>pop;pop;ret</p>
    <p>ENCLU0xF751b000</p>
    <p>pop;ret</p>
    <p>pop;pop;ret</p>
    <p>ENCLU0xF751b000</p>
    <p>pop;ret</p>
    <p>SEGFAULT &amp;</p>
    <p>RAX = 0x4</p>
    <p>EEXIT!!</p>
    <p>Enc Stack Enc Stack</p>
    <p>The last gadget is pop rax ret;</p>
  </div>
  <div class="page">
    <p>Step 3. Deciphering pop gadgets: in search of r?? registers</p>
    <p>Outside Enclave</p>
    <p>When EEXIT is invoked</p>
    <p>Enclave register values visible</p>
    <p>outside enclave</p>
    <p>Enclave Context</p>
    <p>CPU</p>
    <p>rax = 0x00000004 rbx = 0x00000004 rcx = 0x00000002</p>
    <p>. rdi = 0x00000001</p>
    <p>CPU</p>
    <p>rax = 0x00000004 rbx = 0x00000004 rcx = 0x00000002</p>
    <p>. rdi = 0x00000001</p>
  </div>
  <div class="page">
    <p>Step 3. Deciphering pop gadgets: in search of r?? registers</p>
    <p>pop arg1; pop arg2; ret</p>
    <p>pop rax; ret</p>
    <p>ENCLU</p>
    <p>EEXIT (ENCLU &amp; rax=4) leaves register file uncleaned</p>
    <p>Scan code for all pop gadgets</p>
    <p>check arguments</p>
    <p>EEXIT</p>
  </div>
  <div class="page">
    <p>Step 3. Deciphering pop gadgets: in search of r?? registers  EEXIT (ENCLU &amp; rax=4) left a register file uncleaned</p>
    <p>Scan code for all pop gadgets</p>
    <p>check arguments</p>
    <p>arg1 = 0x0001 arg2 = 0x0002</p>
    <p>rax = 0x0004 rsi = 0x0001 rdi = 0x0002</p>
    <p>Deciphering pop? pop? gadget</p>
    <p>Register file +</p>
    <p>pop rsi pop rdi ret</p>
    <p>=pop arg1; pop arg2; ret</p>
    <p>pop rax; ret</p>
    <p>ENCLU 32</p>
    <p>Gadget (0xF750020)</p>
    <p>EEXIT</p>
  </div>
  <div class="page">
    <p>Step 4. Looking for memcpy()  Identifying memcpy(dst*, some valid address, 0x10)</p>
    <p>Check if dst contains data</p>
    <p>pop rdi; pop rsi; pop rdx; ret</p>
    <p>. 0x7fff2000: 01 02 03 04 05 06 07 08 09  0x7fff2010: 11 12 13 14 15 16 17 18 19</p>
    <p>. 0x7fff2000: 01 02 03 04 05 06 07 08 09  0x7fff2010: 11 12 13 14 15 16 17 18 19</p>
    <p>Untrusted application memory</p>
  </div>
  <div class="page">
    <p>Gadgets everywhere (e.g., SDK)</p>
  </div>
  <div class="page">
    <p>What can we do with all this?</p>
    <p>Leak sensitive information</p>
    <p>Permanently parasite to the enclave program</p>
    <p>Leak secrets</p>
    <p>Enclave</p>
    <p>Emulated Enclave</p>
    <p>Enclave</p>
    <p>MiTM</p>
  </div>
  <div class="page">
    <p>Case study 0: Dumping confidential data</p>
    <p>Memcpy all enclave memory contents into untrusted memory  i.e., memcpy(non-enclave region, enclave, size)</p>
    <p>Complete breakdown in enclave confidentiality 36</p>
    <p>Untrusted Application Secure Enclave</p>
    <p>memcpy Gadget</p>
    <p>RSI Gadget</p>
    <p>RDI Gadget</p>
    <p>RCX Gadget</p>
    <p>Memcpy_enclave {</p>
    <p>buf = malloc (4096); ROP_to_memcpy(buf, enc_data, 4096)</p>
    <p>}</p>
    <p>CodeData</p>
  </div>
  <div class="page">
    <p>Case study 1: Compromising sealed data</p>
    <p>Untrusted Application Secure Enclave</p>
    <p>RAX Gadget</p>
    <p>RBX Gadget</p>
    <p>RCX Gadget</p>
    <p>ENCLU Gadget</p>
    <p>memcpy Gadget</p>
    <p>Unsealing and leaking confidential data i.e., EGETKEY retrieves the hardware key bound to specific enclave</p>
    <p>Shadow_read_sealing_data( ) {</p>
    <p>ROP_to_egetkey( ) unseal_data ( )</p>
    <p>}</p>
    <p>Sealing key</p>
  </div>
  <div class="page">
    <p>Case study 2: Hijacking remote attestation</p>
    <p>Breaking the Integrity guarantees of SGX  MiTM between secure enclave and attestation server</p>
    <p>Masquerading the enclave to deceive remote attestation server 38</p>
    <p>Emulated Enclave Secure Enclave</p>
    <p>memcpy Gadget</p>
    <p>RAX Gadget</p>
    <p>RBX Gadget</p>
    <p>RCX Gadget</p>
    <p>RDX Gadget</p>
    <p>ENCLU Gadget</p>
    <p>RSI Gadget</p>
    <p>RDI Gadget</p>
    <p>RCX Gadget</p>
    <p>Fake_Attestation () {</p>
    <p>Compute_DH_key( ) Generate_REPORTDATA( ) ROP_to_copy_parameter( ) ROP_to_get_report( ) Get_Quote( )</p>
    <p>}</p>
    <p>REPORTDATA REPORTDATA</p>
    <p>REPORT</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>The first practical ROP attack on real SGX hardware  Exploits a memory-corruption vulnerability</p>
    <p>Demonstrates how the security of SGX can be disarmed.  Exfiltrate all memory contents from the enclave  Bypass the SGX attestation  Break the data-sealing properties</p>
    <p>Encourage the community  Explore the SGX characteristic-aware defense mechanisms  Develop an efficient way to reduce the TCB in the enclave.</p>
  </div>
  <div class="page">
    <p>DEMO: PoC Dark ROP</p>
    <p>https://youtu.be/hyuZFf3QxvM</p>
    <p>Target binary: remote attestation example from Intel SDK</p>
    <p>Vulnerability: stack overflow</p>
  </div>
  <div class="page">
    <p>Q&amp;A</p>
  </div>
</Presentation>
