<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>EigenBench: A Simple Exploration Tool for</p>
    <p>Orthogonal TM Characteristics</p>
    <p>Pervasive Parallelism Laboratory, Stanford University</p>
    <p>Sungpack Hong Tayo Oguntebi Jared Casper</p>
    <p>Nathan Bronson Christos Kozyrakis</p>
    <p>Kunle Olukotun</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Yet Another Benchmark for TM?</p>
    <p>Orthogonal Characteristics</p>
    <p>EigenBench</p>
    <p>Orthogonal Analysis</p>
    <p>Application Behavior</p>
  </div>
  <div class="page">
    <p>TM Benchmarks</p>
    <p>Transactional Memory (TM)</p>
    <p>Significant number of TM proposals</p>
    <p>: Hardware TM, Software TM, Hybrid TM</p>
    <p>How do we evaluate them?</p>
    <p>Conventional TM Benchmarks</p>
    <p>Conventional TM Benchmarks</p>
    <p>Application benchmark (STAMP, ) [Cao Minh et al, IISWC08]</p>
    <p>Realistic</p>
    <p>Synthetic benchmarks (STMBench7, ) [Guerraoui et al, Eurosys07]</p>
    <p>Easy to configure and parametrize.</p>
    <p>Do they reflect realistic application behavior?</p>
    <p>(e.g.) SwissTM outperformed TL2 2x~5x in synthetic bench, but only 20~90% in STAMPs. [Dragojevic et al, PLDI09]</p>
    <p>why new bench</p>
  </div>
  <div class="page">
    <p>Conventional Synthetic Benchmarks</p>
    <p>Synthetic Benchmarks (contd)</p>
    <p>Typically based on shared data-structure access (e.g. red-black tree)</p>
    <p>Degree of freedom for exploration?</p>
    <p>(Example)</p>
    <p>(Example)</p>
    <p>L% lookups, U% updates</p>
    <p>L% lookups, U% updates</p>
    <p>L2 %lookups, U2% updates</p>
    <p>Conflicts? or Number of writes?</p>
    <p>why new bench</p>
    <p>Transaction Length? Conflicts?</p>
  </div>
  <div class="page">
    <p>Knobs Wanted</p>
    <p>Want to observe each TM characteristics, separately</p>
    <p>. But what are the TM characteristics?</p>
    <p>People mean different things with one term.</p>
    <p>ex&gt; Large Transactions</p>
    <p>ex&gt; Large Transactions</p>
    <p>Many TX reads &amp; writes? (STM barrier overhead)</p>
    <p>Many different addresses? (HTM overflow)</p>
    <p>Many (non-tm) instructions inside TX? (rollback overhead)</p>
    <p>We propose eight orthogonal TM characteristics.</p>
    <p>characteristics</p>
  </div>
  <div class="page">
    <p>Address</p>
    <p>TM Characteristics (1/2)</p>
    <p>Translation Length</p>
    <p>Number of Transactional read,write</p>
    <p>Pollution (0.0 ~ 1.0)</p>
    <p>(WR) / (RD + WR)</p>
    <p>Locality (0.0 ~ 1.0)</p>
    <p>R R W</p>
    <p>IISWC10, 2010-Dec-02 characteristics</p>
    <p>Locality (0.0 ~ 1.0)</p>
    <p>Prob {Repeated Address in transaction}</p>
    <p>Working-Set Size</p>
    <p>Size of memory address region frequently used in application</p>
  </div>
  <div class="page">
    <p>TM Characteristics (2/2)</p>
    <p>Contention (0.0 ~ 1.0)</p>
    <p>Prob {Conflict of a transaction}</p>
    <p>Concurrency</p>
    <p>Number of concurrent threads</p>
    <p>Predominance (0.0 ~ 1.0) Program Program</p>
    <p>End</p>
    <p>Non-transactional instructions in TX</p>
    <p>Instructions outside TX</p>
    <p>Predominance (0.0 ~ 1.0)</p>
    <p>Fraction of transactional access</p>
    <p>/ ( + + )</p>
    <p>Density (0.0 ~ 1.0)</p>
    <p>Fraction of non-tm instr in TX</p>
    <p>(complementary)</p>
    <p>/ ( + )</p>
    <p>Program Begin End</p>
    <p>Transactional read/write</p>
    <p>R R W</p>
    <p>TX_Begin TX_End</p>
    <p>characteristics</p>
  </div>
  <div class="page">
    <p>How do characteristics affect performance?</p>
    <p>HTM STM</p>
    <p>Tx Length Overflow TX-Barrier overhead</p>
    <p>Pollution Overflow ;</p>
    <p>conflict detection</p>
    <p>Write-buffer manage;</p>
    <p>conflict detection</p>
    <p>Locality Overflow Write-buffer searching</p>
    <p>Locality Overflow Write-buffer searching</p>
    <p>Working-Set Size</p>
    <p>Conflict detection; cache miss latency</p>
    <p>Conflict Conflict detection</p>
    <p>Concurrency Scalability</p>
    <p>Density Cost of re-execution</p>
    <p>Predom. TM impact on overall performance</p>
    <p>(*) Write-set size = (TX Length) * (Pollution) * (1 - Locality)</p>
    <p>characteristics</p>
  </div>
  <div class="page">
    <p>Thread # 1 AHot Array Mild Array Cold Array</p>
    <p>EigenBench</p>
    <p>How to explore each characteristic one by one?</p>
    <p>EigenBench  a simple exploration tool</p>
    <p>R2 + W2</p>
    <p>IISWC10, 2010-Dec-02 EigenBench</p>
    <p>R1 + W1</p>
    <p>Thread # N</p>
    <p>R2 + W2</p>
    <p>R1 + W1</p>
    <p>R3i + W3i R3o + W3o</p>
  </div>
  <div class="page">
    <p>EigenBench (Contd)</p>
    <p>Implementation is very simple (randomized memory accesses)</p>
    <p>EigenBench can induce each TM characteristic orthogonally.</p>
    <p>IISWC10, 2010-Dec-02 EigenBench</p>
    <p>Detailed explanation available in the paper</p>
  </div>
  <div class="page">
    <p>Orthogonal Analysis: How-to</p>
    <p>Our approach</p>
    <p>Start from a typical transaction; explore each characteristic.</p>
    <p>Non-conflicting transactions  overhead</p>
    <p>Conflicting transactions  detection precision</p>
    <p>Conflicting transactions  detection precision</p>
    <p>Example Analysis</p>
    <p>TL2 vs. SwissTM</p>
    <p>Default Transaction;</p>
    <p>Length:100, Pollution:0.1,</p>
    <p>Conflict: 0.0, Working-set:256kB (per thread),</p>
    <p>Locality:0.0, Predom:1.0,</p>
    <p>Density:1.0, Concurrency: 8</p>
    <p>Analysis</p>
  </div>
  <div class="page">
    <p>Orthogonal Analysis: Results(1)</p>
    <p>Transaction Length</p>
    <p>TM overhead</p>
    <p>Unprotected: Performance Upperbound (No TM protection)</p>
    <p>Pollution</p>
    <p>Unprotected SwissTM TL2</p>
    <p>Very short or long transactions</p>
    <p>(%)</p>
    <p>Fast Performance drop (p.s. both performance eventually drops)</p>
    <p>Write-only TXs</p>
    <p>Analysis</p>
  </div>
  <div class="page">
    <p>Orthogonal Analysis: Results(2)</p>
    <p>Working-Set Size</p>
    <p>Cache Effect (Last-Level Cache Overflow)</p>
    <p>IISWC10, 2010-Dec-02 Analysis</p>
    <p>(KB/thread)</p>
    <p>Unprotected SwissTM TL2</p>
    <p>SwissTM suffers more from cache pressure</p>
  </div>
  <div class="page">
    <p>Orthogonal Analysis: Results(3)</p>
    <p>Conflicts Unprotected SwissTM TL2</p>
    <p>Upper-bound ~ Unprotected x</p>
    <p>Cache-Line Migration Effect</p>
    <p>More rollbacks, but better performance</p>
    <p>IISWC10, 2010-Dec-02 Analysis</p>
    <p>Estimated Conflicts</p>
    <p>Estimated Conflicts</p>
    <p>Unprotected x (1- conflicts)</p>
    <p>High conflicting region (But are we interested?)</p>
  </div>
  <div class="page">
    <p>Pathology Generation</p>
    <p>TM Pathology [Bobba et al, ISCA 2007]</p>
    <p>memory access patterns causing low performance</p>
    <p>Can we generate pathologies from EigenBench? Yes</p>
    <p>Friendly Fire (Eager) Starving Elder (Lazy)</p>
    <p>Short TXs</p>
    <p>IISWC10, 2010-Dec-02 Application</p>
    <p>TX trace via timestamp</p>
    <p>Two TXs violating each other</p>
    <p>TX trace via timestamp</p>
    <p>Short TXs preventing long TXs progress</p>
  </div>
  <div class="page">
    <p>Application Characteristics</p>
    <p>Questions</p>
    <p>What are TM characteristics of real applications?</p>
    <p>Can we explain application performance via TM characteristics?</p>
    <p>Example Study: STAMP applications mimicry</p>
    <p>To demonstrate relationship between characteristics and application performance</p>
    <p>Instrumentation/Profiling  statistics for TM characterisitcs  Replay with EigenBench</p>
    <p>Application</p>
  </div>
  <div class="page">
    <p>STAMP Application (1)</p>
    <p>Observations</p>
    <p>Different distributions of characteristics</p>
    <p>Single average may not be enough  Mix of discrete characteristics.</p>
    <p>Genome</p>
    <p>IISWC10, 2010-Dec-02 Application</p>
    <p>TX Length</p>
    <p>Long-tailed distribution</p>
  </div>
  <div class="page">
    <p>STAMP Application (2)</p>
    <p>Vacation (Low)</p>
    <p>IISWC10, 2010-Dec-02 Application</p>
    <p>TX Length Working Set</p>
    <p>Normal distribution Wide memory</p>
    <p>access</p>
  </div>
  <div class="page">
    <p>STAMP Application (3)</p>
    <p>Long TX Low Density</p>
    <p>Short TX Large</p>
    <p>Working-Set</p>
    <p>Short TX High Conflicts</p>
  </div>
  <div class="page">
    <p>EigenBench Use-cases</p>
    <p>How to use EigenBench?</p>
    <p>: Length, Working-Set, Pollution, Conflicts, Concurrency, (locality, density, predom)</p>
    <p>Non-conflicting</p>
    <p>Non-conflicting</p>
    <p>Conflicting</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Orthogonal TM Characteristics</p>
    <p>EigenBench</p>
    <p>Orthogonal Analysis</p>
    <p>Application Performance Explanation</p>
    <p>Subsidiary Lessons for STM designers</p>
    <p>Cache effect should be considered</p>
    <p>Trade-off barrier overhead vs. conflict resolution</p>
    <p>Restart penalty can be small</p>
    <p>Download: http://ppl.stanford.edu/eigenbench</p>
    <p>E-mail: eigenbench_manager@lists.stanford.edu</p>
  </div>
</Presentation>
