<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Oscar: A Practical Page-Permissions-Based Scheme for</p>
    <p>Thwarting Dangling Pointers (USENIX Security 2017)</p>
    <p>Thurston Dang1, Petros Maniatis2, David Wagner1</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Provides heap temporal memory safety for C/C++ with lowest overhead of any published scheme and no source code required</p>
  </div>
  <div class="page">
    <p>Temporal memory safety</p>
    <p>aFuncPtr = malloc();</p>
    <p>? ? ? ? ? ? ? ?</p>
  </div>
  <div class="page">
    <p>Temporal memory safety</p>
    <p>aFuncPtr = malloc();</p>
    <p>userName = malloc(); fgets(); // Type in &amp;Elmo (0xE11770)</p>
    <p>*aFuncPtr = &amp;Grouch; // At 0x05CADA</p>
    <p>Grouch(){</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Temporal memory safety</p>
    <p>aFuncPtr = malloc();</p>
    <p>E 1 1 7 7 0 0 0 free (aFuncPtr);</p>
    <p>userName = malloc(); fgets(); // Type in &amp;Elmo (0xE11770)</p>
    <p>(*someFuncPtr)(); // Use-after-free!</p>
    <p>*aFuncPtr = &amp;Grouch; // At 0x05CADA</p>
    <p>Elmo(){</p>
    <p>}</p>
    <p>Grouch(){</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Provides heap temporal memory safety for C/C++ with lowest overhead of any published scheme and no source code required</p>
  </div>
  <div class="page">
    <p>Design Goals</p>
    <p>No requirement for source code  Deterministic protection  Compatibility with typecasts, pointer arithmetic, and other common programming idioms</p>
    <p>Low runtime and memory overhead</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Provides heap temporal memory safety for C/C++ with lowest overhead of any published scheme and no source code required</p>
  </div>
  <div class="page">
    <p>Potato?</p>
    <p>DangNull</p>
    <p>FreeSentry</p>
    <p>DangSan</p>
    <p>CETS</p>
    <p>PageHeap</p>
    <p>Electric Fence</p>
    <p>Dhurjati &amp; Adve What do these schemes do?</p>
    <p>How can we put them in a common framework?</p>
  </div>
  <div class="page">
    <p>aFuncPtr = malloc();</p>
    <p>aFuncPtr</p>
    <p>someObject</p>
    <p>Toy example</p>
  </div>
  <div class="page">
    <p>Toy example</p>
    <p>aFuncPtr = malloc();</p>
    <p>aFuncPtr</p>
    <p>callback</p>
    <p>someObject</p>
    <p>callback = someFuncPtr;</p>
  </div>
  <div class="page">
    <p>Scheme 1: lock-and-key schemes (change lock) e.g., CETS</p>
    <p>aFuncPtr</p>
    <p>callback</p>
    <p>someObject</p>
    <p>aFuncPtr = malloc(); // Change lock</p>
    <p>key:42</p>
    <p>key:42</p>
    <p>lock:42</p>
    <p>callback = someFuncPtr;</p>
    <p>free (aFuncPtr);</p>
    <p>if (callback_key != callback_lock) abort()</p>
  </div>
  <div class="page">
    <p>Scheme 1: lock-and-key schemes (change lock) e.g., CETS</p>
    <p>aFuncPtr</p>
    <p>callback</p>
    <p>someObject</p>
    <p>aFuncPtr = malloc(); // Change lock</p>
    <p>key:42</p>
    <p>key:42</p>
    <p>callback = someFuncPtr;</p>
    <p>free (aFuncPtr); userName = malloc (); // Change lock</p>
    <p>lock:43</p>
    <p>if (callback_key != callback_lock) abort()</p>
  </div>
  <div class="page">
    <p>Scheme 1: lock-and-key schemes (change lock) e.g., CETS</p>
    <p>aFuncPtr</p>
    <p>callback</p>
    <p>someObject</p>
    <p>aFuncPtr = malloc(); // Change lock</p>
    <p>key:42</p>
    <p>key:42</p>
    <p>lock:43</p>
    <p>free (aFuncPtr);</p>
    <p>userName key:43</p>
    <p>callback = someFuncPtr;</p>
    <p>userName = malloc (); // Change lock</p>
    <p>if (callback_key != callback_lock) abort()</p>
  </div>
  <div class="page">
    <p>Scheme 2: lock-and-key schemes (revoke keys) [works, but slow]</p>
    <p>aFuncPtr</p>
    <p>callback</p>
    <p>someObject</p>
    <p>aFuncPtr = malloc();</p>
    <p>key:</p>
    <p>key:</p>
    <p>userName key:42</p>
    <p>lock:42</p>
    <p>callback = someFuncPtr;</p>
    <p>free (aFuncPtr); // Revoke keys for // aFuncPtr and callback</p>
    <p>if (callback_key != callback_lock) abort()</p>
    <p>userName = malloc ();</p>
  </div>
  <div class="page">
    <p>Scheme 3: dangling pointer nullification e.g., DangNull, FreeSentry, DangSan</p>
    <p>aFuncPtr</p>
    <p>callback</p>
    <p>someObject</p>
    <p>aFuncPtr = malloc(); callback = someFuncPtr;</p>
    <p>free (aFuncPtr);</p>
    <p>// No pointer dereference checks // added</p>
  </div>
  <div class="page">
    <p>Scheme 3: dangling pointer nullification e.g., DangNull, FreeSentry, DangSan</p>
    <p>aFuncPtr</p>
    <p>callback</p>
    <p>someObject</p>
    <p>aFuncPtr = malloc(); callback = someFuncPtr;</p>
    <p>free (aFuncPtr); aFuncPtr = NULL; callback = NULL;</p>
    <p>// No pointer dereference checks // added</p>
  </div>
  <div class="page">
    <p>Scheme 3: dangling pointer nullification e.g., DangNull, FreeSentry, DangSan</p>
    <p>aFuncPtr</p>
    <p>callback</p>
    <p>someObject</p>
    <p>aFuncPtr = malloc();</p>
    <p>userName</p>
    <p>NULL callback = someFuncPtr;</p>
    <p>aFuncPtr = NULL; callback = NULL;</p>
    <p>free (aFuncPtr);</p>
    <p>// No pointer dereference checks // added</p>
    <p>userName = malloc ();</p>
  </div>
  <div class="page">
    <p>someFuncPtr</p>
    <p>callback</p>
    <p>someObject</p>
    <p>userName</p>
    <p>NULL</p>
    <p>Software *ptr checks Hardware *ptr checks</p>
    <p>DangNull FreeSentry DangSan</p>
    <p>Key = pointer Revoke keys = nullify pointers</p>
    <p>Re vo ke th</p>
    <p>e ke ys</p>
    <p>someFuncPtr</p>
    <p>callback</p>
    <p>someObject key:</p>
    <p>key:</p>
    <p>userName</p>
    <p>key:42</p>
    <p>lock:42</p>
    <p>Works, but slow</p>
  </div>
  <div class="page">
    <p>someFuncPtr</p>
    <p>callback</p>
    <p>someObject key:</p>
    <p>key:</p>
    <p>userName</p>
    <p>key:42</p>
    <p>lock:42</p>
    <p>someFuncPtr</p>
    <p>callback</p>
    <p>someObject key:42</p>
    <p>key:42</p>
    <p>userName</p>
    <p>key:43</p>
    <p>lock:43</p>
    <p>Software *ptr checks Hardware *ptr checks Re</p>
    <p>vo ke th</p>
    <p>e ke ys</p>
    <p>Ch an ge th</p>
    <p>e lo ck</p>
    <p>CETS</p>
    <p>DangNull FreeSentry DangSan</p>
    <p>Works, but slow</p>
    <p>???Page-permissions-based schemes</p>
    <p>Key = pointer Revoke keys = nullify pointers</p>
    <p>Object = lock Change the lock = ???</p>
    <p>someFuncPtr</p>
    <p>callback</p>
    <p>someObject</p>
    <p>userName</p>
    <p>NULL</p>
  </div>
  <div class="page">
    <p>Recall that objects are accessed via virtual addresses</p>
    <p>C AB</p>
    <p>bPtr</p>
    <p>C AB</p>
    <p>We can mark a virtual page as inaccessible  4KB-page granularity  Many objects per page</p>
  </div>
  <div class="page">
    <p>Scheme 4: page table protections e.g., Electric Fence, PageHeap</p>
    <p>One object per page</p>
    <p>B</p>
    <p>B</p>
    <p>Physical page frames</p>
    <p>C</p>
    <p>Virtual pages</p>
    <p>C A</p>
    <p>A</p>
  </div>
  <div class="page">
    <p>Scheme 4: page table protections e.g., Electric Fence, PageHeap</p>
    <p>One object per page</p>
    <p>Drawbacks:  Inefficient use of physical memory (+ cache)  Many system calls (to update virtual page mappings)  TLB pressure</p>
    <p>B</p>
    <p>B</p>
    <p>Physical page frames C</p>
    <p>Virtual pages</p>
    <p>C A</p>
    <p>A</p>
  </div>
  <div class="page">
    <p>Scheme 4+: page table protections revisited e.g., Dhurjati &amp; Adve</p>
    <p>Aliased virtual page 1</p>
    <p>Aliased virtual page 2</p>
    <p>Aliased virtual page 3</p>
    <p>Canonical virtual page</p>
    <p>Physical page frame</p>
    <p>C B A</p>
    <p>Drawbacks:  Inefficient use of physical memory</p>
    <p>Many system calls (to update aliased page mappings)</p>
    <p>TLB pressure C B A</p>
    <p>C</p>
    <p>B</p>
    <p>A</p>
  </div>
  <div class="page">
    <p>Dealing with freed objects  Vanilla approach keeps memory mappings (PROT_NONE) for freed objects</p>
    <p>memory leak (vm_area_structs)</p>
    <p>Dhurjati &amp; Adve use automatic pool allocation  requires source code analysis  can suffer from long-lived pools</p>
  </div>
  <div class="page">
    <p>someFuncPtr</p>
    <p>callback</p>
    <p>someObject key:</p>
    <p>key:</p>
    <p>userName key:42</p>
    <p>lock:42</p>
    <p>someFuncPtr</p>
    <p>callback</p>
    <p>someObject key:42</p>
    <p>key:42</p>
    <p>userName key:43</p>
    <p>lock:43</p>
    <p>Software *ptr checks</p>
    <p>Hardware *ptr checks Re</p>
    <p>vo ke th</p>
    <p>e ke ys</p>
    <p>Ch an ge th</p>
    <p>e lo ck</p>
    <p>CETS</p>
    <p>DangNull FreeSentry DangSan</p>
    <p>Works, but slow</p>
    <p>someFuncPtr</p>
    <p>callback</p>
    <p>someObject</p>
    <p>userName</p>
    <p>NULL</p>
    <p>Page-permissions-based schemes e.g., Electric Fence, PageHeap, Dhurjati &amp; Adve</p>
    <p>Oscar</p>
    <p>Theoretically: best approach Conventional wisdom: impractical</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Provides heap temporal memory safety for C/C++ with lowest overhead of any published scheme and no source code required</p>
  </div>
  <div class="page">
    <p>Our Design</p>
    <p>Builds upon core idea of page permissions with aliased virtual pages, with:</p>
    <p>a) no requirement for source code b) less stateholding of kernel metadata for</p>
    <p>freed objects c) better compatibility with fork() d) optimizations to reduce runtime overhead</p>
  </div>
  <div class="page">
    <p>Handling long-lived applications (b)</p>
    <p>We keep a high water mark for allocations  will never allocate new objects in address space of old objects</p>
    <p>Lower memory overhead: no vm_area_structs for freed objects</p>
    <p>obj1</p>
    <p>obj2</p>
    <p>obj3</p>
    <p>obj4</p>
  </div>
  <div class="page">
    <p>Correct semantics for fork() (c)  We need MAP_SHARED to create aliases  Unwanted side-effect: parent and child will share physical memory</p>
    <p>child: alias1</p>
    <p>child: alias2</p>
    <p>parent: alias1</p>
    <p>I love trash</p>
    <p>parent: alias2</p>
    <p>Virtual addresses</p>
    <p>Physical page frames</p>
    <p>To our knowledge, not discussed in prior work</p>
    <p>We solve this with a fork() wrapper that weans the child from the parents physical frames</p>
  </div>
  <div class="page">
    <p>Making large allocations faster (d)</p>
    <p>We need MAP_SHARED to create aliases  Another unwanted side-effect of MAP_SHARED: slows down some programs  e.g., on mcf, this has ~30% overhead</p>
    <p>Very large objects are placed by malloc() on their own physical page frames  i.e., no aliases required</p>
    <p>We use MAP_PRIVATE for those large objects  on mcf: &lt; 1% overhead</p>
  </div>
  <div class="page">
    <p>Reducing syscalls by refreshing aliases (d)</p>
    <p>syscall: create alias</p>
    <p>syscall: destroy alias</p>
    <p>syscall: create alias</p>
    <p>syscall: destroy alias</p>
    <p>syscall: create alias</p>
    <p>syscall: refresh alias</p>
    <p>syscall: refresh alias</p>
    <p>syscall: destroy alias</p>
    <p>syscall: create alias syscall: refresh alias</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Provides heap temporal memory safety for C/C++ with lowest overhead of any published scheme and no source code required</p>
  </div>
  <div class="page">
    <p>? 3.7% 31.8%</p>
    <p>Runtime overhead Memory overhead</p>
    <p>CETS (reported) Oscar N.B. CETS includes stack use-after-free protection</p>
    <p>Memory overhead not reported by CETS</p>
    <p>Overhead vs. CETS* (2010) *actually, SoftBoundCETS temporal-only, which is faster than CETS</p>
  </div>
  <div class="page">
    <p>Overhead vs. FreeSentry (2015)</p>
    <p>? 4.2% 34.0%</p>
    <p>Runtime overhead Memory overhead</p>
    <p>FreeSentry (reported) Oscar Memory overhead not reported by FreeSentry</p>
  </div>
  <div class="page">
    <p>Overhead vs. DangNull (2015)</p>
    <p>-40%</p>
    <p>Runtime overhead Memory overhead</p>
    <p>DangNull (reported) Oscar N.B. DangNull provides weaker protection (pointers stored on heap)</p>
  </div>
  <div class="page">
    <p>Overhead vs. DangSan (2017)</p>
    <p>Runtime overhead Memory overhead</p>
    <p>DangSan (reported) Oscar DangSan and Oscar report all non-Fortran SPEC CPU2006 benchmarks</p>
  </div>
  <div class="page">
    <p>dealII</p>
    <p>omnetpp perlbench</p>
    <p>sphinx3</p>
    <p>xalancbmk</p>
    <p>-50</p>
    <p>Ru nt im</p>
    <p>e ov er he</p>
    <p>ad (%</p>
    <p>)</p>
    <p>Memory overhead (%)</p>
    <p>Oscars runtime overhead, memory overhead (and VMA exhaustion: not shown) are correlated</p>
    <p>Apps with few malloc calls generally have low runtime overhead, low memory overhead, low rate of exhausting virtual address space38</p>
    <p>Allocation-intensive</p>
    <p>Not alloc intensive</p>
    <p>Special case</p>
    <p>N.B. Baseline memory usage is ~45MB</p>
  </div>
  <div class="page">
    <p>Intuition</p>
    <p>Oscars overhead is proportional to the number of objects  other classes of schemes have memory and runtime overhead proportional to the number of pointers or pointer operations</p>
    <p>Oscar doesnt need nor instrument the source code, so it avoids edge cases (e.g., typecasts)  other classes of schemes need source and have some compatibility issues</p>
  </div>
  <div class="page">
    <p>Additional details in paper</p>
    <p>Sources of overhead  Server support: fork(), custom memory allocators</p>
    <p>Theoretical comparison of schemes</p>
  </div>
  <div class="page">
    <p>Conclusion  Oscar provides heap temporal memory safety for C/C++ with lowest overhead of any published scheme  no source code required</p>
    <p>Bring about page-permissions based schemes to be worthy of consideration once more</p>
  </div>
  <div class="page">
    <p>References  [CETS] NAGARAKATTE, S. G. Practical low-overhead enforcement of</p>
    <p>memory safety for C programs. University of Pennsylvania, 2012. Doctoral dissertation.</p>
    <p>[DangNull] LEE, B., SONG, C., JANG, Y., WANG, T., KIM, T., LU, L., AND LEE, W. Preventing Use-after-free with Dangling Pointers Nullification. In NDSS (2015).</p>
    <p>[DangSan] VAN DER KOUWE, E., NIGADE, V., AND GIUFFRIDA, C. DangSan: Scalable Use-after-free Detection. In EuroSys (2017), pp. 405419.</p>
    <p>[Dhurjati &amp; Adve] DHURJATI, D., AND ADVE, V. Efficiently detecting all dangling pointer uses in production servers. In Dependable Systems and Networks (2006), IEEE, pp. 269280.</p>
    <p>[Electric Fence] Electric Fence. http://elinux.org/index.php?title=Electric_Fence&amp;oldid=369914, January 2015.</p>
    <p>[FreeSentry] YOUNAN, Y. FreeSentry: protecting against use-after-free vulnerabilities due to dangling pointers. In NDSS (2015).</p>
    <p>[PageHeap] How to use Pageheap.exe in Windows XP, Windows 2000, and Windows Server 2003. https://support.microsoft.com/en-us/kb/286470.</p>
  </div>
  <div class="page">
    <p>mcf: MAP_SHARED  MAP_PRIVATE: Create a private copy-on-write mapping</p>
    <p>perf hardware performance counters:</p>
    <p>ca ch em is se s</p>
    <p>ca ch ere fe re nc es</p>
    <p>L1 -d ca ch elo ad -m</p>
    <p>is se s</p>
    <p>L1 -d ca ch elo ad s</p>
    <p>L1 -d ca ch epr ef et ch -</p>
    <p>L1 -d ca ch epr ef et ch es</p>
    <p>L1 -d ca ch est or em is se s</p>
    <p>L1 -d ca ch est or es</p>
    <p>L1 -ic ac he</p>
    <p>-lo ad -m</p>
    <p>is se s</p>
    <p>L1 -ic ac he</p>
    <p>-lo ad s</p>
    <p>LL Clo ad -m</p>
    <p>is se s</p>
    <p>LL Clo ad s</p>
    <p>LL Cpr ef et ch -m</p>
    <p>is se s</p>
    <p>LL Cpr ef et ch es</p>
    <p>LL Cst or em is se s</p>
    <p>LL Cst or es</p>
    <p>br an ch -lo</p>
    <p>ad -m</p>
    <p>is se s</p>
    <p>br an ch -lo</p>
    <p>ad s</p>
    <p>dT LB -lo</p>
    <p>ad -m</p>
    <p>is se s</p>
    <p>dT LB -lo</p>
    <p>ad s</p>
    <p>dT LB -s to re -m</p>
    <p>is se s</p>
    <p>dT LB -s to re s</p>
    <p>iT LB -lo</p>
    <p>ad -m</p>
    <p>is se s</p>
    <p>iT LB -lo</p>
    <p>ad s</p>
    <p>no de</p>
    <p>-lo ad -m</p>
    <p>is se s</p>
    <p>no de</p>
    <p>-lo ad s</p>
    <p>no de</p>
    <p>-p re fe tc hm is se s</p>
    <p>no de</p>
    <p>-p re fe tc he</p>
    <p>s no</p>
    <p>de -s to re -m</p>
    <p>is se s</p>
    <p>no de</p>
    <p>-s to re s</p>
    <p>Ti m e</p>
    <p>Ra ti o of e ve nt s (v s. M</p>
    <p>A P_</p>
    <p>SH A RE</p>
    <p>D )</p>
  </div>
</Presentation>
