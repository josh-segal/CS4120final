<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Code-Pointer Integrity Volodymyr Kuznetsov, Lszl Szekeres, Mathias Payer,</p>
    <p>George Candea, R. Sekar, Dawn Song</p>
  </div>
  <div class="page">
    <p>Memory</p>
    <p>int *q = buf + input; *q = input2;  (*func_ptr)();</p>
    <p>func_ptr</p>
    <p>Control-Flow Hijack Attack</p>
    <p>shell code</p>
    <p>buf q X</p>
    <p>Attacker corrupts a data pointer  Attacker uses it to overwrite a code pointer  Control-flow is transferred to shell code</p>
  </div>
  <div class="page">
    <p>C on</p>
    <p>tro l-F</p>
    <p>lo w</p>
    <p>H ija</p>
    <p>ck C</p>
    <p>VE s</p>
    <p>Acrobat Firefox IE OS X Linux Average</p>
    <p>Control-flow hijacks are still abundant today!</p>
  </div>
  <div class="page">
    <p>MEMORY</p>
    <p>Swift</p>
    <p>Sample Python program (Dropbox SDK example):</p>
    <p>Python program 3 KLOC of Python</p>
    <p>Python runtime 500 KLOC of C</p>
    <p>libc 2500 KLOC of C</p>
    <p>Memory safety prevents control-flow hijacks</p>
    <p>but memory safe programs still rely on C/C++</p>
  </div>
  <div class="page">
    <p>MEMORY</p>
    <p>C/C++ Overhead</p>
    <p>SoftBound+CETS 116%</p>
    <p>CCured (language modifications)</p>
    <p>Watchdog (hardware modifications)</p>
    <p>AddressSanitizer (approximate)</p>
    <p>Memory safety can be retrofitted to C/C++</p>
  </div>
  <div class="page">
    <p>State of the art:</p>
    <p>Control-Flow Integrity</p>
    <p>Finest-grained CFI has 10-21% overhead [5-6]</p>
    <p>Coarse-grained CFI can be bypassed [1-4] and</p>
    <p>[1] Gkta et al., IEEE S&amp;P 2014 [2] Gkta et al., USENIX Security 2014 [3] Davi et al., USENIX Security 2014 [4] Carlini et al., USENIX Security 2014</p>
    <p>Static property: limit the set of functions that</p>
    <p>can be called at each call site</p>
    <p>[5] Akritidis et al., IEEE S&amp;P 2008 [6] Abadi et al., CCS 2005</p>
  </div>
  <div class="page">
    <p>Flexibility Performance</p>
    <p>Safety Security</p>
    <p>vs</p>
    <p>Programmers have to choose</p>
  </div>
  <div class="page">
    <p>Code-Pointer Integrity provides both</p>
    <p>and</p>
    <p>Control-flow hijack protection Unmodified C/C++</p>
    <p>Practical protection 0.5 - 1.9% overhead Guaranteed protection 8.4 - 10.5% overhead</p>
    <p>Key insight: memory safety for code pointers only</p>
    <p>h a r d e n e d PostgreSQL</p>
    <p>OpenSSL</p>
    <p>Apache</p>
    <p>Tested on:</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Does it solve a real problem? How does it work?</p>
    <p>How secure is it? How practical is it?</p>
    <p>Practical protection: CPS Guaranteed protection: CPI</p>
    <p>Threat model &amp; background</p>
  </div>
  <div class="page">
    <p>Threat Model</p>
    <p>Attacker can read/write data, read code</p>
    <p>Attacker cannot:</p>
    <p>Modify program code</p>
    <p>Influence program loading</p>
  </div>
  <div class="page">
    <p>buf_lower = p; buf_upper = p+10;</p>
    <p>q_lower = buf_lower; q_upper = buf_upper; if (q &lt; q_lower || q &gt;= q_upper-size) abort();</p>
    <p>char *buf = malloc(10);</p>
    <p>char *q = buf + input;</p>
    <p>*q = input2;</p>
    <p>Memory Safety program instrumentation</p>
    <p>(*func_ptr)();</p>
    <p>All-or-nothing protection</p>
    <p>(Nagarakatte et al., PLDI09 and ISMM10)</p>
    <p>Memory</p>
    <p>func_ptr</p>
    <p>buf q</p>
  </div>
  <div class="page">
    <p>Control-flow hijack protection 1.9% or 8.4% average performance overhead</p>
    <p>?</p>
    <p>Memory Safety</p>
    <p>Can memory safety be enforced for code pointers only ?</p>
  </div>
  <div class="page">
    <p>int *q = buf + input; *q = input2;  (*func_ptr)();</p>
    <p>Regular Memory</p>
    <p>Safe Memory</p>
    <p>func_ptr</p>
    <p>All non-code</p>
    <p>pointer data</p>
    <p>Code pointers</p>
    <p>only buf</p>
    <p>Separation is enforced using hardwareenforced instruction-level isolation</p>
    <p>Practical Protection (CPS): Heap</p>
    <p>Instructions that access code pointers are identified using type-based static analysis</p>
    <p>(on SPEC2006 CPU)</p>
    <p>(on SPEC2006 CPU)</p>
    <p>Program memory</p>
    <p>is separated</p>
    <p>Memory layout</p>
    <p>unchanged</p>
  </div>
  <div class="page">
    <p>int foo() { char buf[16]; int r; r = scanf(%s, buf); return r; }</p>
    <p>Safe stack adds &lt;0.1% performance overhead!</p>
    <p>Regular Stack</p>
    <p>Safe Stack</p>
    <p>ret address</p>
    <p>buf Not needed in most small functions</p>
    <p>r</p>
    <p>Practical Protection (CPS): Stack</p>
    <p>All accesses are safe</p>
    <p>Only locals accessed through pointers</p>
    <p>Stacks are separated</p>
    <p>All locals that are only</p>
    <p>accessed safely</p>
  </div>
  <div class="page">
    <p>Practical Protection (CPS): Memory Layout</p>
    <p>Safe Heap</p>
    <p>Safe memory (code pointers)</p>
    <p>Regular memory (non-code-pointer data)</p>
    <p>Regular Heap</p>
    <p>Code (Read-Only)</p>
    <p>Safe Stack (thread1)</p>
    <p>Safe Stack (thread2)</p>
    <p>Regular Stack (thread1)</p>
    <p>Regular Stack (thread2)</p>
    <p>Hardware-based instruction-level isolation</p>
    <p>Only instructions that operate on code pointers can access the safe memory</p>
  </div>
  <div class="page">
    <p>The CPS Promise</p>
    <p>Under CPS, an attacker cannot forge a code pointer</p>
  </div>
  <div class="page">
    <p>Memory</p>
    <p>int *q = p + input; *q = input2;</p>
    <p>(*func_ptr)(); func_ptr = struct_ptr-&gt;f;</p>
    <p>func_ptr</p>
    <p>struct_ptr</p>
    <p>Is this enough? In practice, yes!</p>
    <p>Under CPS, an attacker cannot forge a code pointer</p>
    <p>func1_ptr</p>
    <p>With CPS: a ptr to another</p>
    <p>function or NULL</p>
    <p>Contrived example of an attack on a CPS-protected program</p>
    <p>Attacker corrupts a data pointer  Attacker uses it to corrupt a struct pointer  Program loads a function pointer from wrong</p>
    <p>location in the safe memory  Control-flow is transferred to different function whose</p>
    <p>address was previously stored in the safe memory</p>
    <p>X</p>
    <p>q</p>
    <p>valid function</p>
  </div>
  <div class="page">
    <p>int *q = p + input; *q = input2;</p>
    <p>(*func_ptr)(); func_ptr = struct_ptr-&gt;f;</p>
    <p>Sensitive pointers = code pointers Sensitive pointers = code pointers and pointers used to access sensitive pointers</p>
    <p>Is this enough? In practice, yes!</p>
    <p>Under CPS, an attacker cannot forge a code pointer</p>
    <p>Precise solution: protect all sensitive pointers</p>
    <p>Memory</p>
    <p>func_ptr</p>
    <p>struct_ptr</p>
    <p>func1_ptr</p>
    <p>valid function</p>
    <p>Contrived example of an attack on a CPS-protected program</p>
    <p>With CPI: struct_ptr is</p>
    <p>sensitive and cannot be corrupted</p>
  </div>
  <div class="page">
    <p>Sensitive pointers = code pointers and pointers used to access sensitive pointers</p>
    <p>On SPEC2006 6.5% memory accesses are sensitive</p>
    <p>Guaranteed Protection (CPI)</p>
    <p>CPI identifies all sensitive pointers using over-approximate type-based static analysis: is_sensitive(v) = is_sensitive_type(type of v)</p>
    <p>Over-approximation doesnt hurt security, it only affects performance:</p>
  </div>
  <div class="page">
    <p>Guaranteed Protection (CPI): Memory Layout</p>
    <p>Safe memory (sensitive pointers and metadata)</p>
    <p>Regular memory (non-sensitive data)</p>
    <p>Accesses are fast</p>
    <p>Accesses are checked for memory safety</p>
    <p>Safe Heap Regular Heap</p>
    <p>Code (Read-Only)</p>
    <p>Safe Stack (thread1)</p>
    <p>Safe Stack (thread2)</p>
    <p>Regular Stack (thread1)</p>
    <p>Regular Stack (thread2)</p>
    <p>Hardware-based instruction-level isolation</p>
    <p>Only instructions that operate on sensitive pointers can access the safe memory</p>
  </div>
  <div class="page">
    <p>Guaranteed Protection (CPI)</p>
    <p>Guaranteed memory safety for all sensitive pointers</p>
    <p>Sensitive pointers = code pointers and pointers used to access sensitive pointers</p>
    <p>Guaranteed protection against</p>
    <p>control-flow hijack attacks enabled by memory bugs</p>
  </div>
  <div class="page">
    <p>movl input2, q</p>
    <p>call *%gs:func_ptr</p>
    <p>Regular Memory</p>
    <p>ds.base</p>
    <p>ds.limit</p>
    <p>Safe Memory</p>
    <p>gs.base</p>
    <p>gs.limit</p>
    <p>Instruction-Level Isolation</p>
    <p>int *q = ptr + input; *q = input2;  (*func_ptr)();</p>
    <p>Regular Memory</p>
    <p>Safe Memory</p>
    <p>fs.base (randomized)</p>
    <p>x86-32 x86-64 Perfect hiding: regular memory</p>
    <p>contains no pointers to safe memory</p>
    <p>Alternative: Software Fault Isolation</p>
    <p>Dedicated segment register,</p>
    <p>used only to access the safe</p>
    <p>memory</p>
  </div>
  <div class="page">
    <p>CPS CPI</p>
    <p>Separate sensitive pointers and regular data Sensitive pointers = code pointers</p>
    <p>Sensitive pointers = code pointers + indirect pointers to sensitive pointers</p>
    <p>Accessing sensitive pointers is safe Separation Separation +</p>
    <p>runtime checks</p>
    <p>Accessing regular data is fast Instruction-level safe region isolation</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Does it solve a real problem? How does it work?</p>
    <p>How secure is it? How practical is it?</p>
    <p>Practical protection: CPS Guaranteed protection: CPI</p>
    <p>Threat model &amp; background</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Does it solve a real problem? How does it work? How secure is it? How practical is it?</p>
  </div>
  <div class="page">
    <p>How secure is it?</p>
    <p>RIPE runtime intrusion prevention evaluator:</p>
    <p>Both CPS and CPI prevent all attacks from RIPE</p>
    <p>Future attacks:</p>
    <p>CPI correctness proof in the paper</p>
    <p>Wilander at al., ACSAC 2011</p>
  </div>
  <div class="page">
    <p>Protects Against Technique Security Guarantees</p>
    <p>Average Overhead</p>
    <p>Memory corruption</p>
    <p>vulnerabilities Memory Safety Precise 116%</p>
    <p>Control-flow hijack</p>
    <p>vulnerabilities</p>
    <p>CPI (Guaranteed protection)</p>
    <p>Precise 8.4-10.5%</p>
    <p>CPS (Practical protection)</p>
    <p>Strong 0.5-1.9%</p>
    <p>Finest-grained CFI</p>
    <p>Medium (attacks may exist) Gkta el., IEEE S&amp;P 2014</p>
    <p>Coarse-grained CFI</p>
    <p>Weak (known attacks) Gkta el., IEEE S&amp;P 2014 and USENIX Security 2014,</p>
    <p>Davi et al, USENIX Security 2014 Carlini et al., USENIX Security 2014</p>
    <p>ASLR DEP</p>
    <p>Stack cookies</p>
    <p>Weakest (bypassable + widespread attacks) ~0%</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Does it solve a real problem? How does it work? How secure is it? How practical is it?</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Does it solve a real problem? How does it work? How secure is it? How practical is it?</p>
    <p>Implementation Is it practical? Is it fast enough?</p>
  </div>
  <div class="page">
    <p>Implementation cc -fcpi foo.c</p>
    <p>LLVM-based prototype at http://levee.epfl.ch</p>
    <p>Plan to integrate upstream into LLVM</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Front-end (clang): Collect type information</p>
    <p>Back-end (LLVM): CPI/CPS and SafeStack instrumentation passes</p>
    <p>Runtime support (compiler-rt or libc): Safe heap and stacks management</p>
    <p>LLVM-based prototype at http://levee.epfl.ch</p>
  </div>
  <div class="page">
    <p>Recompiled the entire FreeBSD userspace</p>
    <p>and more than 100 packages</p>
    <p>Full OS Distribution with CPS/CPI protection</p>
    <p>PostgreSQL</p>
    <p>OpenSSL</p>
    <p>h a r d e n e d</p>
  </div>
  <div class="page">
    <p>Performance overhead on Phoronix pgbench openssl</p>
    <p>encode-mp3 graphics-magick 1 graphics-magick 2 graphics-magick 3 graphics-magick 4 graphics-magick 5</p>
    <p>hmmer postmark</p>
    <p>sqlite pybench</p>
    <p>dcraw crafty</p>
    <p>compress-lzma compress-pbzip2</p>
    <p>c-ray</p>
    <p>Average Median</p>
    <p>-5% 5% 15% 25% 35% 45% 55% 65% 75% 85%</p>
    <p>Safe stack only CPS (practical protection) CPI (guaranteed protection)</p>
    <p>Safe stack: 0.01% CPS: 0.5% CPI: 10.5%</p>
  </div>
  <div class="page">
    <p>Average Median</p>
    <p>-5% 0% 5% 10% 15% 20% 25% 30% 35% 40% 45%</p>
    <p>Safe stack only CPS (practical protection) CPI (guaranteed protection)</p>
    <p>Safe stack: 0.03% CPS: 1.9% CPI: 8.4%</p>
    <p>Performance overhead on SPEC2006 CPU</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Does it solve a real problem? How does it work? How secure is it? How practical is it?</p>
    <p>Implementation Is it fast enough? Is it practical?</p>
  </div>
  <div class="page">
    <p>Code-Pointer Integrity</p>
    <p>and</p>
    <p>Control-flow hijack protection Unmodified C/C++</p>
    <p>Practical protection 0.5 - 1.9% overhead Guaranteed protection 8.4 - 10.5% overhead</p>
    <p>Key insight: memory safety for code pointers only</p>
    <p>h a r d e n e d PostgreSQL</p>
    <p>OpenSSL</p>
    <p>Apache</p>
    <p>http://levee.epfl.ch</p>
  </div>
</Presentation>
