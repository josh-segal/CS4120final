<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>We Crashed, Now What?</p>
    <p>Cristiano Giuffrida Lorenzo Cavallaro Andrew S. Tanenbaum</p>
    <p>Vrije Universiteit Amsterdam</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>OS Dependability Threats</p>
  </div>
  <div class="page">
    <p>OS Dependability Threats</p>
  </div>
  <div class="page">
    <p>OS Dependability Threats</p>
  </div>
  <div class="page">
    <p>Are Core Components Safe?</p>
    <p>Were getting bloated and huge. Yes, its a problem.</p>
    <p>[. . .] Id like to say we have a plan.</p>
    <p>Linus Torvalds on the Linux kernel, 2009</p>
  </div>
  <div class="page">
    <p>Are Core Components Safe?</p>
    <p>Were getting bloated and huge.</p>
    <p>Yes, its a problem. [. . .] Id like to say we have a plan.</p>
    <p>Linus Torvalds on the Linux kernel, 2009</p>
  </div>
  <div class="page">
    <p>Are Core Components Safe?</p>
    <p>Were getting bloated and huge. Yes, its a problem.</p>
    <p>[. . .] Id like to say we have a plan.</p>
    <p>Linus Torvalds on the Linux kernel, 2009</p>
  </div>
  <div class="page">
    <p>Are Core Components Safe?</p>
    <p>Were getting bloated and huge. Yes, its a problem.</p>
    <p>[. . .] Id like to say we have a plan.</p>
    <p>Linus Torvalds on the Linux kernel, 2009</p>
  </div>
  <div class="page">
    <p>Are Core Components Safe?</p>
    <p>Were getting bloated and huge. Yes, its a problem.</p>
    <p>[. . .] Id like to say we have a plan.</p>
    <p>Linus Torvalds on the Linux kernel, 2009</p>
  </div>
  <div class="page">
    <p>High-coverage Crash Recovery</p>
    <p>Rapid evolution and huge size cause more bugs</p>
    <p>Crash recovery solution with smaller TCB needed</p>
    <p>Whole-OS crash recovery</p>
    <p>How?</p>
  </div>
  <div class="page">
    <p>High-coverage Crash Recovery</p>
    <p>Rapid evolution and huge size cause more bugs</p>
    <p>Crash recovery solution with smaller TCB needed</p>
    <p>Whole-OS crash recovery</p>
    <p>How?</p>
  </div>
  <div class="page">
    <p>High-coverage Crash Recovery</p>
    <p>Rapid evolution and huge size cause more bugs</p>
    <p>Crash recovery solution with smaller TCB needed</p>
    <p>Whole-OS crash recovery</p>
    <p>How?</p>
  </div>
  <div class="page">
    <p>High-coverage Crash Recovery</p>
    <p>Rapid evolution and huge size cause more bugs</p>
    <p>Crash recovery solution with smaller TCB needed</p>
    <p>Whole-OS crash recovery</p>
    <p>How?</p>
  </div>
  <div class="page">
    <p>Isolated Subsystems ? Entire OS</p>
    <p>Work on extensions and drivers</p>
    <p>e.g., Safedrive, Nooks, Minix 3</p>
    <p>Filesystems</p>
    <p>e.g., Membrane</p>
    <p>Assume isolated untrusted parties with well-defined interfaces</p>
    <p>Several recoverer-recoveree pairs to scale to the entire OS</p>
    <p>Complex and hard-to-maintain recovery infrastructure</p>
    <p>High exposure of the recovery code to the programmer</p>
    <p>. . . it is like a dog chasing its tail!</p>
  </div>
  <div class="page">
    <p>Isolated Subsystems ? Entire OS</p>
    <p>Work on extensions and drivers</p>
    <p>e.g., Safedrive, Nooks, Minix 3</p>
    <p>Filesystems</p>
    <p>e.g., Membrane</p>
    <p>Assume isolated untrusted parties with well-defined interfaces</p>
    <p>Several recoverer-recoveree pairs to scale to the entire OS</p>
    <p>Complex and hard-to-maintain recovery infrastructure</p>
    <p>High exposure of the recovery code to the programmer</p>
    <p>. . . it is like a dog chasing its tail!</p>
  </div>
  <div class="page">
    <p>Emerging High-coverage Solutions</p>
    <p>Shadow kernel vs Pure instrumentation e.g., Otherworld e.g., Recovery Domains</p>
    <p>Best-effort (weak failure model)</p>
    <p>Heavyweight (high complexity) (poor performance) (poor scalability)</p>
  </div>
  <div class="page">
    <p>Emerging High-coverage Solutions</p>
    <p>Shadow kernel vs Pure instrumentation e.g., Otherworld e.g., Recovery Domains</p>
    <p>Best-effort (weak failure model)</p>
    <p>Heavyweight (high complexity) (poor performance) (poor scalability)</p>
  </div>
  <div class="page">
    <p>Emerging High-coverage Solutions</p>
    <p>Shadow kernel vs Pure instrumentation e.g., Otherworld e.g., Recovery Domains</p>
    <p>Best-effort (weak failure model)</p>
    <p>Heavyweight (high complexity) (poor performance) (poor scalability)</p>
  </div>
  <div class="page">
    <p>WWW: What We Want</p>
  </div>
  <div class="page">
    <p>WWW: What We Want</p>
    <p>High coverage</p>
  </div>
  <div class="page">
    <p>WWW: What We Want</p>
    <p>Low complexity</p>
  </div>
  <div class="page">
    <p>WWW: What We Want</p>
    <p>Reasonable performance and scalability</p>
  </div>
  <div class="page">
    <p>WWW: What We Want</p>
    <p>Good maintainability</p>
  </div>
  <div class="page">
    <p>WWW: What We Want</p>
    <p>Address the many challenges of the crash recovery problem</p>
  </div>
  <div class="page">
    <p>The Crash Recovery Problem  I</p>
    <p>Crash detection</p>
    <p>Detect crashes proactively or reactively</p>
    <p>Isolate crashes so they do not disrupt the recovery process</p>
    <p>State transfer</p>
    <p>Create a new execution context to restart execution</p>
    <p>Transfer the state from the old execution context</p>
    <p>State consistency</p>
    <p>Restore a stable and consistent state in the new context</p>
    <p>Allow for deterministic execution upon restart</p>
  </div>
  <div class="page">
    <p>The Crash Recovery Problem  I</p>
    <p>Crash detection</p>
    <p>Detect crashes proactively or reactively</p>
    <p>Isolate crashes so they do not disrupt the recovery process</p>
    <p>State transfer</p>
    <p>Create a new execution context to restart execution</p>
    <p>Transfer the state from the old execution context</p>
    <p>State consistency</p>
    <p>Restore a stable and consistent state in the new context</p>
    <p>Allow for deterministic execution upon restart</p>
  </div>
  <div class="page">
    <p>The Crash Recovery Problem  I</p>
    <p>Crash detection</p>
    <p>Detect crashes proactively or reactively</p>
    <p>Isolate crashes so they do not disrupt the recovery process</p>
    <p>State transfer</p>
    <p>Create a new execution context to restart execution</p>
    <p>Transfer the state from the old execution context</p>
    <p>State consistency</p>
    <p>Restore a stable and consistent state in the new context</p>
    <p>Allow for deterministic execution upon restart</p>
  </div>
  <div class="page">
    <p>The Crash Recovery Problem  II</p>
    <p>State dependency tracking</p>
    <p>Preserve state dependencies among different contexts</p>
    <p>Allow for a globally coherent state upon restart</p>
    <p>State corruption</p>
    <p>Detect arbitrary data corruption</p>
    <p>Attempt to recover from arbitrary data corruption</p>
    <p>Restart</p>
    <p>Determine a safe execution point to resume operation</p>
    <p>Attempt to avoid further crashes</p>
  </div>
  <div class="page">
    <p>The Crash Recovery Problem  II</p>
    <p>State dependency tracking</p>
    <p>Preserve state dependencies among different contexts</p>
    <p>Allow for a globally coherent state upon restart</p>
    <p>State corruption</p>
    <p>Detect arbitrary data corruption</p>
    <p>Attempt to recover from arbitrary data corruption</p>
    <p>Restart</p>
    <p>Determine a safe execution point to resume operation</p>
    <p>Attempt to avoid further crashes</p>
  </div>
  <div class="page">
    <p>The Crash Recovery Problem  II</p>
    <p>State dependency tracking</p>
    <p>Preserve state dependencies among different contexts</p>
    <p>Allow for a globally coherent state upon restart</p>
    <p>State corruption</p>
    <p>Detect arbitrary data corruption</p>
    <p>Attempt to recover from arbitrary data corruption</p>
    <p>Restart</p>
    <p>Determine a safe execution point to resume operation</p>
    <p>Attempt to avoid further crashes</p>
  </div>
  <div class="page">
    <p>Our Approach</p>
    <p>Combine OS design and lightweight instumentation</p>
    <p>OS Design</p>
    <p>Reduce complexity at recovery time</p>
    <p>Good performance and scalability</p>
    <p>Lightweight Compiler-based Instrumentation</p>
    <p>High coverage and component-agnostic recovery</p>
    <p>Good maintainability and evolvability</p>
  </div>
  <div class="page">
    <p>Our Approach</p>
    <p>Combine OS design and lightweight instumentation</p>
    <p>OS Design</p>
    <p>Reduce complexity at recovery time</p>
    <p>Good performance and scalability</p>
    <p>Lightweight Compiler-based Instrumentation</p>
    <p>High coverage and component-agnostic recovery</p>
    <p>Good maintainability and evolvability</p>
  </div>
  <div class="page">
    <p>Our Approach</p>
    <p>Combine OS design and lightweight instumentation</p>
    <p>OS Design</p>
    <p>Reduce complexity at recovery time</p>
    <p>Good performance and scalability</p>
    <p>Lightweight Compiler-based Instrumentation</p>
    <p>High coverage and component-agnostic recovery</p>
    <p>Good maintainability and evolvability</p>
  </div>
  <div class="page">
    <p>OS Architecture</p>
    <p>AppApp AppApp . . . App</p>
    <p>NETSCHVFS VM . . . PM</p>
    <p>NDDHDDPRN SND . . . RS</p>
    <p>Microkernel</p>
    <p>R 3</p>
    <p>R 0</p>
    <p>We break down the OS into several userspace components</p>
    <p>Multiserver microkernel architecture based on message-passing</p>
  </div>
  <div class="page">
    <p>The Programming Model</p>
    <p>O.S. Component</p>
    <p>We rely on an event-driven model</p>
  </div>
  <div class="page">
    <p>The Programming Model</p>
    <p>O.S. Component</p>
    <p>Events trigger execution of the task loop</p>
  </div>
  <div class="page">
    <p>The Programming Model</p>
    <p>O.S. Component</p>
    <p>Idempotent messages possible within the task loop</p>
  </div>
  <div class="page">
    <p>The Programming Model</p>
    <p>O.S. Component</p>
    <p>Idempotent messages possible within the task loop</p>
  </div>
  <div class="page">
    <p>The Programming Model</p>
    <p>O.S. Component</p>
    <p>Idempotent messages possible within the task loop</p>
  </div>
  <div class="page">
    <p>The Programming Model</p>
    <p>O.S. Component</p>
    <p>Push non-idempotent messages to the end</p>
  </div>
  <div class="page">
    <p>The Programming Model</p>
    <p>O.S. Component</p>
    <p>Back to the top of the loop!</p>
  </div>
  <div class="page">
    <p>The Programming Model</p>
    <p>O.S. Component</p>
    <p>Pending interactions are remembered in the state</p>
  </div>
  <div class="page">
    <p>State Management</p>
    <p>Identify state of data and state of execution</p>
    <p>Both well-defined and consistent at the top of the task loop</p>
    <p>The top of the loop is a local stable state point</p>
    <p>Global state consistency by design</p>
  </div>
  <div class="page">
    <p>Instrumentation-based Recovery</p>
    <p>The task loop is the recovery window</p>
    <p>Lightweight instrumentation to track local state changes</p>
    <p>Used by the recovery code to revert to the last stable state</p>
    <p>Different strategies possible</p>
  </div>
  <div class="page">
    <p>Our Implemented Instrumentation</p>
    <p>Maintain shadow state regions</p>
    <p>Track dynamic memory allocations</p>
    <p>Track changes on state objects</p>
    <p>Use alias analysis to detect changes at the object granularity</p>
    <p>Automatically commit changes at the end of the task loop (i.e., it synchronizes shadow and main state regions)</p>
  </div>
  <div class="page">
    <p>The Crash Recovery Process</p>
    <p>AppApp AppApp . . . App</p>
    <p>NETSCHVFS VM . . . PM PMR</p>
    <p>NDDHDDPRN SND . . . RS</p>
    <p>Microkernel</p>
    <p>R 3</p>
    <p>R 0</p>
    <p>PM</p>
    <p>PM</p>
    <p>PM PM</p>
    <p>PMR PM</p>
  </div>
  <div class="page">
    <p>The Crash Recovery Process</p>
    <p>AppApp AppApp . . . App</p>
    <p>NETSCHVFS VM . . . PM PMR #PF</p>
    <p>NDDHDDPRN SND . . . RS</p>
    <p>Microkernel</p>
    <p>R 3</p>
    <p>R 0</p>
    <p>PM</p>
    <p>PM</p>
    <p>PM PM</p>
    <p>PMR PM</p>
    <p>An OS component crashes: the system manager detects the crash and initiates recovery</p>
    <p>(the microkernel actually signals the system manager)</p>
  </div>
  <div class="page">
    <p>The Crash Recovery Process</p>
    <p>AppApp AppApp . . . App</p>
    <p>NETSCHVFS VM . . . PMR</p>
    <p>NDDHDDPRN SND . . . RS</p>
    <p>Microkernel</p>
    <p>R 3</p>
    <p>R 0</p>
    <p>PM</p>
    <p>PM</p>
    <p>PM PM</p>
    <p>PMR PM</p>
    <p>The system manager selects a new replica and tells the microkernel</p>
    <p>(virtual ids make transparent recovery possible!)</p>
  </div>
  <div class="page">
    <p>The Crash Recovery Process</p>
    <p>AppApp AppApp . . . App</p>
    <p>NETSCHVFS VM . . . PMR</p>
    <p>NDDHDDPRN SND . . . RS</p>
    <p>Microkernel</p>
    <p>R 3</p>
    <p>R 0</p>
    <p>PM</p>
    <p>PM</p>
    <p>PM PM</p>
    <p>PMR PM</p>
    <p>PM</p>
    <p>The system manager yields control to the new replica for state transfer. . .</p>
    <p>(libary-based recovery code starts executing. . . )</p>
  </div>
  <div class="page">
    <p>The Crash Recovery Process</p>
    <p>AppApp AppApp . . . App</p>
    <p>NETSCHVFS VM . . . PMR</p>
    <p>NDDHDDPRN SND . . . RS</p>
    <p>Microkernel</p>
    <p>R 3</p>
    <p>R 0</p>
    <p>PM</p>
    <p>PM</p>
    <p>PM PM</p>
    <p>PMR PM</p>
    <p>PM</p>
    <p>. . . the component is brought back to the last stable state and resumes operation</p>
    <p>(shadow and main state regions are synced!)</p>
  </div>
  <div class="page">
    <p>The Crash Recovery Process</p>
    <p>AppApp AppApp . . . App</p>
    <p>NETSCHVFS VM . . .</p>
    <p>NDDHDDPRN SND . . . RS</p>
    <p>Microkernel</p>
    <p>R 3</p>
    <p>R 0</p>
    <p>PM</p>
    <p>PM</p>
    <p>PM PM</p>
    <p>PMR PM</p>
    <p>The system manager cleans up the dead replica (the new replica may even be involved in the process!)</p>
  </div>
  <div class="page">
    <p>The Crash Recovery Process</p>
    <p>AppApp AppApp . . . App</p>
    <p>NETSCHVFS VM . . .</p>
    <p>NDDHDDPRN SND . . . RS</p>
    <p>Microkernel</p>
    <p>R 3</p>
    <p>R 0</p>
    <p>PM</p>
    <p>PM</p>
    <p>PM PM</p>
    <p>PMR PM</p>
    <p>The system manager spawns a new replica (if needed) (per-component recovery policies apply)</p>
  </div>
  <div class="page">
    <p>The Crash Recovery Process</p>
    <p>AppApp AppApp . . . App</p>
    <p>NETSCHVFS VM . . .</p>
    <p>NDDHDDPRN SND . . . RS</p>
    <p>Microkernel</p>
    <p>R 3</p>
    <p>R 0</p>
    <p>PM</p>
    <p>PM</p>
    <p>PM PM</p>
    <p>PMR PM</p>
    <p>The system manager spawns a new replica (if needed) (per-component recovery policies apply)</p>
    <p>The system keeps running as nothing bad ever happened!</p>
  </div>
  <div class="page">
    <p>Prototype</p>
    <p>Implemented on top of Minix 3</p>
    <p>Restructured OS processes to fit our event-driven model</p>
    <p>Instrumentation implemented as a series of LLVM passes</p>
    <p>Successfully recovered even the most critical components</p>
    <p>Early experiments confirmed key properties of our design</p>
  </div>
  <div class="page">
    <p>Scalability Properties</p>
    <p>N o rm</p>
    <p>a liz</p>
    <p>e d R</p>
    <p>e la</p>
    <p>ti v e O</p>
    <p>v e rh</p>
    <p>e a d</p>
    <p>N</p>
    <p>POSIX Suite Postmark</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>A new high-coverage approach to OS crash recovery</p>
    <p>Combines OS design and compiler-based instrumentation</p>
    <p>Low complexity, good performance, scalability, maintainability</p>
    <p>No heavy burden for the OS programmer</p>
    <p>Addresses many of the crash recovery challenges efficiently</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Finer-grained instrumentation to track the state</p>
    <p>Realistic fault injection scenarios</p>
    <p>Experiment and evaluate restart strategies</p>
    <p>Recover from state corruption</p>
    <p>Per-component recovery policies</p>
  </div>
  <div class="page">
    <p>We Crashed, Now What?</p>
    <p>Thank you! Any questions?</p>
    <p>Cristiano Giuffrida, Lorenzo Cavallaro, Andy Tanenbaum {giuffrida,sullivan,ast}@cs.vu.nl</p>
    <p>Vrije Universiteit Amsterdam</p>
  </div>
</Presentation>
