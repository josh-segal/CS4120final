<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Efficient Pattern Matching over Event Streams</p>
    <p>Jagrati Agrawal Yanlei Diao</p>
    <p>Daniel Gyllstrom Neil Immerman</p>
    <p>University of Massachusetts, Amherst</p>
  </div>
  <div class="page">
    <p>A New Stream Processing Paradigm</p>
    <p>Pattern matching over event streams</p>
    <p>Input Events</p>
    <p>Pattern</p>
    <p>e1e2e3e4e5</p>
    <p>Matching Results R1R2R3</p>
  </div>
  <div class="page">
    <p>Applications</p>
    <p>Existing and emerging applications  Financial services  RFID-based supply chain management  Click stream analysis  Electronic health systems  Network monitoring  E-commerce purchase tracking</p>
  </div>
  <div class="page">
    <p>Supply Chain Management</p>
    <p>Tag id: 01.001298.6EF.0A Time: 2008-01-12, 14:30:00 Manufacturer: X Ltd. Location: AAB</p>
    <p>Tag id: 01.001298.6EF.0A Reader id: 3478 Time: 2008-01-15, 06:10:00 Temperature: 80</p>
    <p>Tag id: 01.001298.6EF.0A Reader id: 5140 Time: 2008-01-21 08:15:00 Temperature: 91</p>
    <p>Tag id: 01.001298.6EF.0A Reader id: 6647 Time: 2008-01-30 15:00:00 Temperature: 102</p>
    <p>Tag id: 01.001298.6EF.0A Reader id: 7990 Time: 2008-02-04, 09:10:00 Temperature: 97</p>
    <p>Tag id: 01.001298.6EF.0A Reader id: 5140 Time: 2008-02-10, 12:40:00 Temperature: 85</p>
    <p>Spoiled drugs: drugs that were exposed to temperature &gt; 100F for 24 hours.</p>
    <p>Contaminated shipments: all shipments that were co-located with products originating from a source of contamination or subsequently infected products.</p>
    <p>Warehouse management: count pallets, detect missing pallets</p>
    <p>Retail management: shoplifting, misplaced inventory, fast shelf depletion</p>
  </div>
  <div class="page">
    <p>Challenges</p>
    <p>Rich languages  Sequencing  Kleene closure  Negation  Complex predicates  Event selection strategies</p>
    <p>Efficient evaluation over streams  Relational stream systems:</p>
    <p>selection-join-aggregation  Recent event systems</p>
    <p>Significantly richer than regular languages!</p>
    <p>Lacking support for key features. Not optimized.</p>
  </div>
  <div class="page">
    <p>Our Goal and Contributions</p>
    <p>A fundamental evaluation and optimization framework for the full set of event pattern queries  Formal evaluation model</p>
    <p>Precise semantics of queries  Query evaluation plans  Formal results on expressive power</p>
    <p>Runtime complexity analysis  Runtime algorithms and optimizations  Performance evaluation results</p>
  </div>
  <div class="page">
    <p>Event Pattern Languages</p>
    <p>Recent proposals: SQL-TS, Cayuga, SASE+, CEDR, StreamSQL, Coral8</p>
    <p>Language structure of SASE+:</p>
    <p>FROM &lt;input stream&gt; PATTERN &lt;pattern structure&gt; [WHERE &lt;pattern matching condition&gt;] [WITHIN &lt;time window&gt;] [RETURN &lt;output specification&gt;]</p>
  </div>
  <div class="page">
    <p>Q1: Stock Trend Monitoring</p>
    <p>FROM InputStream PATTERN SEQ(Stock+ a[], Stock b) WHERE [symbol] AND</p>
    <p>a[1].volume &gt; 1000 AND a[i].price &gt; a[i-1].price AND b.volume &lt; 80% * a[a.LEN].volume</p>
    <p>WITHIN 1 hour</p>
    <p>In an hour, the volume of a stock sales record started high, but after a period of price increasing, the volume plummeted.</p>
    <p>min(a[..i-1].price)</p>
  </div>
  <div class="page">
    <p>Q1 Using Partition Contiguity</p>
    <p>FROM InputStream PATTERN SEQ(Stock+ a[], Stock b) WHERE partition_contiguity(a[],b)</p>
    <p>{ [symbol] AND a[1].volume &gt; 1000 AND a[i].price &gt; a[i-1].price AND b.volume &lt; 80% * a[a.LEN].volume }</p>
    <p>WITHIN 1 hour</p>
    <p>Event Selection Strategy: Partition Contiguity  Captures a continuous trend in each partition</p>
  </div>
  <div class="page">
    <p>Q1 Using Skip Till Next Match</p>
    <p>FROM InputStream PATTERN SEQ(Stock+ a[], Stock b) WHERE skip_till_next_match(a[],b)</p>
    <p>{ [symbol] AND a[1].volume &gt; 1000 AND a[i].price &gt; a[i-1].price AND b.volume &lt; 80%*a[a.LEN].volume }</p>
    <p>WITHIN 1 hour</p>
    <p>Event Selection Strategy: Skip Till Next Match  Captures a broad trend while ignoring local fluctuating values</p>
    <p>Two overlapping matches</p>
  </div>
  <div class="page">
    <p>Q2: Contaminated Shipments</p>
    <p>FROM InputStream PATTERN SEQ(Alert a, Shipment+ b[]) WHERE skip_till_any_match(a, b[])</p>
    <p>{ a.type = contaminated AND b[1].from = a.site AND b[i].from = b[i-1].to }</p>
    <p>WITHIN 12 hours RETURN a.type, a.site, b[].to</p>
    <p>In a food supply chain, detect contaminated shipments.</p>
  </div>
  <div class="page">
    <p>Q2 Using Skip Till Any Match</p>
    <p>Shipment (W  X) Shipment (X  Y)</p>
    <p>Shipment (X  Z)</p>
    <p>W  X  Y W  X  Z</p>
    <p>Event Selection Strategy: Skip Till Any Match  Can both select and skip relevant events, non-deterministic  Computes transitive closure over an event stream</p>
  </div>
  <div class="page">
    <p>A Formal Evaluation Model: NFAb</p>
    <p>a[i]_ignore</p>
    <p>a[1]_begina[1] Fba[i]</p>
    <p>a[i]_take</p>
    <p>b_begina[i]_proceed</p>
    <p>b_ignore</p>
    <p>NFA</p>
    <p>Match Buffer</p>
    <p>a[1] a[i] b Computation</p>
    <p>State value 1</p>
    <p>value 2 value 3</p>
    <p>Automaton State a[1]e1 e2</p>
  </div>
  <div class="page">
    <p>A Formal Evaluation Model: NFAb</p>
    <p>a[i]_ignore</p>
    <p>a[1]_begina[1] Fba[i]</p>
    <p>a[i]_take</p>
    <p>b_begina[i]_proceed</p>
    <p>b_ignore</p>
    <p>NFA</p>
    <p>e2</p>
    <p>Match Buffer</p>
    <p>a[1] a[i] b Computation</p>
    <p>State value 1</p>
    <p>value 2 value 3</p>
    <p>Automaton State a[i]e1 e2 e3</p>
  </div>
  <div class="page">
    <p>A Formal Evaluation Model: NFAb</p>
    <p>a[i]_ignore</p>
    <p>a[1]_begina[1] Fba[i]</p>
    <p>a[i]_take</p>
    <p>b_begina[i]_proceed</p>
    <p>b_ignore</p>
    <p>NFA</p>
    <p>e2 e3</p>
    <p>Match Buffer</p>
    <p>a[1] a[i] b Computation</p>
    <p>State value 1</p>
    <p>value 2 value 3</p>
    <p>Automaton State a[i]e1 e2 e3 e4 e5</p>
  </div>
  <div class="page">
    <p>A Formal Evaluation Model: NFAb</p>
    <p>a[i]_ignore</p>
    <p>a[1]_begina[1] Fba[i]</p>
    <p>a[i]_take</p>
    <p>b_begina[i]_proceed</p>
    <p>b_ignore</p>
    <p>NFA</p>
    <p>e2 e3</p>
    <p>e5</p>
    <p>Match Buffer</p>
    <p>a[1] a[i] b Computation</p>
    <p>State value 1</p>
    <p>value 2 value 3</p>
    <p>Automaton State a[i]e1 e2 e3 e4 e5 e6</p>
  </div>
  <div class="page">
    <p>Accepting Run</p>
    <p>A Formal Evaluation Model: NFAb</p>
    <p>a[i]_ignore</p>
    <p>a[1]_begina[1] Fba[i]</p>
    <p>a[i]_take</p>
    <p>b_begina[i]_proceed</p>
    <p>b_ignore</p>
    <p>NFA</p>
    <p>e2 e3</p>
    <p>e5</p>
    <p>e6</p>
    <p>Match Buffer</p>
    <p>a[1] a[i] b Computation</p>
    <p>State value 1</p>
    <p>value 2 value 3</p>
    <p>Automaton State F</p>
  </div>
  <div class="page">
    <p>Expressibility of NFAb</p>
    <p>Complexity Hierarchy</p>
    <p>NFAb</p>
    <p>(SASE+)</p>
    <p>Regular</p>
    <p>Stream SQL w.o. recursion</p>
    <p>Stream SQL w. recursion</p>
  </div>
  <div class="page">
    <p>WHERE [symbol] AND a[1].volume &gt; 1000 AND a[i].price &gt; a[i-1].price AND b.volume &lt; 80% * a[a.LEN].volume</p>
    <p>Query Compilation into NFAb PATTERN SEQ(Stock+ a[], Stock b)</p>
    <p>a[1]_begin a[1] Fba[i]</p>
    <p>a[i]_take</p>
    <p>b_begina[i]_proceed</p>
    <p>Event_Selection_Strategy(a[], b) {</p>
    <p>}</p>
    <p>a[i]_ignore b_ignore</p>
    <p>a[1]_begin = a[1].type = Stock  a[1].volume &gt; 1000</p>
    <p>a[i]_take = a[i].type = Stock  a[i].symbol = a[1].symbol  a[i].price &gt; a[i-1].price</p>
    <p>b_begin = b.type = Stock  b.symbol = a[1].symbol  b.volume &lt; 80% * a[a.LEN].volume</p>
    <p>a[i]_proceed = b_begin</p>
    <p>Partition contiguity:  (partition condition) Skip till next match:  (take or begin condition) Skip till any match: TrueCompile time optimizations: push filtering and stopping conditions early in appropriate places in the automaton</p>
  </div>
  <div class="page">
    <p>Computation State of NFAb</p>
    <p>a[i]_ignore</p>
    <p>a[1]_begina[1] Fba[i]</p>
    <p>a[i]_take</p>
    <p>b_begina[i]_proceed</p>
    <p>b_ignore</p>
    <p>a[i]_take = a[i].type = Stock  a[i].symbol = a[1].symbol  a[i].price &gt; a[i-1].price</p>
    <p>b_begin = b.type = Stock  b.symbol = a[1].symbol  b.volume &lt; 80% * a[a.LEN].volume</p>
    <p>Computation state: a minimum set of values for edge evaluation, extracted from parameterized predicates.</p>
    <p>Computation State NFAb state Attribute Operation</p>
    <p>a[1] symbol set() a[i] price setLast() a[i] volume setLast()</p>
  </div>
  <div class="page">
    <p>A Single Run of NFAb Automaton State a[i]</p>
    <p>Runtime Challenges a[i]_ignore</p>
    <p>a[1]_begin a[1] Fba[i]</p>
    <p>a[i]_take</p>
    <p>b_begina[i]_proceed</p>
    <p>b_ignore</p>
    <p>NFA</p>
    <p>e2 e3</p>
    <p>e5</p>
    <p>Match Buffer</p>
    <p>a[1] a[i] b Computation State</p>
    <p>value 1</p>
    <p>value 2 value 3</p>
    <p>a[i]</p>
  </div>
  <div class="page">
    <p>Runtime Challenges Simultaneous runs of NFAb:  A new run can start before an old run completes.  A run can branch at an NFAb state due to nondeterminism.</p>
    <p>A Single Run of NFAb Automaton State a[i]</p>
    <p>e2 e3</p>
    <p>e5</p>
    <p>Match Buffer</p>
    <p>a[1] a[i] b Computation State</p>
    <p>value 1</p>
    <p>value 2 value 3</p>
    <p>a[i]</p>
  </div>
  <div class="page">
    <p>A Single Run of NFAb Automaton State a[i]</p>
    <p>Runtime Complexity</p>
    <p>e2 e3</p>
    <p>e5</p>
    <p>Match Buffer</p>
    <p>a[1] a[i] b Computation State</p>
    <p>value 1</p>
    <p>value 2 value 3</p>
    <p>a[i]</p>
    <p>How many runs can we have?  Depends on event selection strategy, partition window size  Polynomial to exponential in the worse case.</p>
  </div>
  <div class="page">
    <p>Merging Match Buffers</p>
    <p>e1 e2</p>
    <p>e3</p>
    <p>Match Buffer for Run 1</p>
    <p>a[1] a[i] b</p>
    <p>e4</p>
    <p>e5</p>
    <p>e6 e1 e2</p>
    <p>e3</p>
    <p>Match Buffer for Run 3</p>
    <p>a[1] a[i] b</p>
    <p>e4</p>
    <p>e5</p>
    <p>e8</p>
    <p>e3 e4</p>
    <p>Match Buffer for Run 2</p>
    <p>a[1] a[i] b</p>
    <p>e6</p>
    <p>e6</p>
    <p>e7</p>
  </div>
  <div class="page">
    <p>Merging Match Buffers</p>
    <p>e1 e2</p>
    <p>e3</p>
    <p>Shared Buffer for Runs 1, 2, 3</p>
    <p>a[1] a[i] b</p>
    <p>e4</p>
    <p>e5</p>
    <p>e6</p>
    <p>e6</p>
    <p>e7</p>
    <p>e3 e8</p>
    <p>Erroneous result!</p>
  </div>
  <div class="page">
    <p>A Shared, Versioned Match Buffer</p>
    <p>e1 e2</p>
    <p>e3</p>
    <p>Shared, Versioned Buffer for Runs 1, 2, 3</p>
    <p>a[1] a[i] b</p>
    <p>e4</p>
    <p>e5</p>
    <p>e6</p>
    <p>e6</p>
    <p>e7</p>
    <p>e3</p>
    <p>e8</p>
  </div>
  <div class="page">
    <p>Merging Equivalent Runs</p>
    <p>Equivalent runs  Despite distinct history, two runs have the same</p>
    <p>computation state at present.  They will select the same events till completion, hence</p>
    <p>can be merged.</p>
  </div>
  <div class="page">
    <p>Merging Equivalent Runs</p>
    <p>Computation State of Run 1 NFAb state attribute value</p>
    <p>a[1] symbol XYZ a[i] price last:121 a[i] volume last:1000</p>
    <p>Computation State of Run 2 NFAb state attribute operation</p>
    <p>a[1] symbol XYZ a[i] price last:121 a[i] volume last:1000</p>
    <p>WHERE skip_till_next_match(a[],b) { [symbol] AND a[1].volume &gt; 1000 AND a[i].price &gt; a[i-1].price AND b.volume &lt; 80% * a[a.LEN].volume }</p>
    <p>PATTERN SEQ(Stock+ a[], Stock b)</p>
    <p>(symbol, price and volume of the recent selected event)</p>
  </div>
  <div class="page">
    <p>Merging Equivalent Runs</p>
    <p>Computation State of Run 1 NFAb state attribute value</p>
    <p>a[1] symbol XYZ a[i] price min:101 a[i] volume last:1000</p>
    <p>Computation State of Run 2 NFAb state attribute operation</p>
    <p>a[1] symbol XYZ a[i] price min:101 a[i] volume last:1000</p>
    <p>WHERE skip_till_next_match(a[],b) { [symbol] AND a[1].volume &gt; 1000 AND a[i].price &gt; min(a[..i-1].price) AND b.volume &lt; 80% * a[a.LEN].volume }</p>
    <p>PATTERN SEQ(Stock+ a[], Stock b)</p>
    <p>( symbol, min price of all selected events, volume of last event)</p>
  </div>
  <div class="page">
    <p>Performance of Kleene Closure PATTERN SEQ(Stock+ a[ ], Stock b) WHERE S(a[ ], b) {</p>
    <p>[symbol] AND a[1].price % 500 = 0 AND</p>
    <p>P(a[i]) AND b.volume &lt; 150 }</p>
    <p>WITHIN W</p>
    <p>Parameters: P = (p1) true (p2) a[i].price &gt; a[i-1].price (p3) a[i].price &gt; aggr(a[..i-1].price) aggr = min | max | avg S = (s2) partition contiguity (s3) skip till next match W = 500</p>
    <p>Basic Algorithm: shared buffer + separate run execution</p>
    <p>Predicate selectivity: strong effect on match length and num. of runs, hence overall performance.</p>
    <p>Event selection strategy: s3 can be more expensive than s2.</p>
    <p>p1s2 p1s3 p2s2 p2s3 p3s2 p3s3</p>
    <p>Query Type</p>
    <p>T h</p>
    <p>ro u</p>
    <p>g h</p>
    <p>u p</p>
    <p>t (e</p>
    <p>v e</p>
    <p>n ts</p>
    <p>/s e</p>
    <p>c )</p>
    <p>Lo ga</p>
    <p>rit hm</p>
    <p>ic s</p>
    <p>ca le</p>
  </div>
  <div class="page">
    <p>Comparing to a Backtrack Algorithm</p>
    <p>Basic vs. Backtrack:  Basic evaluates all runs of the automaton simultaneously; it</p>
    <p>processes each event only once.</p>
    <p>Backtrack handles one run at a time, backtracks upon failure or to find another match; it reprocesses events multiple times.</p>
    <p>Lo ga</p>
    <p>rit hm</p>
    <p>ic s</p>
    <p>ca le</p>
  </div>
  <div class="page">
    <p>Benefit of Shared Processing</p>
    <p>Benefits of merging runs of automata:  Performance gains 40% to 110% across all queries.</p>
    <p>Throughput over 10,000 events/sec even for expensive queries.</p>
    <p>Higher performance gains when partition window size increases.</p>
    <p>Lo ga</p>
    <p>rit hm</p>
    <p>ic s</p>
    <p>ca le</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>NFAb automaton, a formal evaluation model for event pattern queries  Expressibility of NFAb</p>
    <p>Compilation techniques</p>
    <p>Runtime complexity and sharing techniques  Performance results</p>
    <p>Tens of thousands of events/sec for fairly expensive queries</p>
    <p>Even higher throughput for cheaper queries</p>
    <p>Sharing among runs offers 40%-110% performance gains</p>
    <p>Potential impact: a pattern matching operator to be integrated into relational stream systems</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Query complexity analysis  What pattern queries can be evaluated using constant</p>
    <p>time per event?</p>
    <p>Optimizations  Negation  Composed queries</p>
    <p>Robust event processing  Uncertain events  Out of order events</p>
    <p>Benchmark for event pattern matching</p>
  </div>
  <div class="page">
    <p>Questions</p>
  </div>
</Presentation>
