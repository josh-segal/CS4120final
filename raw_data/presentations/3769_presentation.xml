<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Shortest Paths in Directed Planar Graphs with Negative Lengths:</p>
    <p>a Linear-Space O(n log2 n)-Time Algorithm</p>
    <p>Shay Mozes (Brown University)</p>
    <p>joint work with</p>
    <p>Philip Klein (Brown University)</p>
    <p>Oren Weimann (MIT)</p>
  </div>
  <div class="page">
    <p>Single-Source shortest paths</p>
    <p>Planar graph  Directed  Positive and negative lengths  No negative cycles</p>
  </div>
  <div class="page">
    <p>Single-Source shortest paths</p>
    <p>Planar graph  Directed  Positive and negative lengths  No negative cycles</p>
  </div>
  <div class="page">
    <p>Single-Source shortest paths</p>
    <p>Planar graph  Directed  Positive and negative lengths  No negative cycles</p>
    <p>-4</p>
  </div>
  <div class="page">
    <p>Applications</p>
    <p>Feasible circulation  Feasible flow  Perfect matching  Image segmentation  Stereo matching</p>
    <p>,</p>
    <p>Figure 3. The edge connectivity in the stereo</p>
    <p>case.</p>
    <p>Figure 4. The effect of the term gD. Four sample frames equally spaced from a sequence</p>
    <p>consisting of a total of 25 frames.</p>
    <p>tionary while the left-hand circle moves to the right. Due to</p>
    <p>the intensity gradient, is non-zero for the moving circle,</p>
    <p>while i t is zero for the stationary circle. This results i n the</p>
    <p>correct identification of the moving circle over each triple</p>
    <p>of frames, with the identified boundary switching from the</p>
    <p>right- to the left-hand circle when the former stops and the</p>
    <p>latter begins to move. Note that the identification of the</p>
    <p>right-hand circle occurs i n spite of the fact that by mov</p>
    <p>ing up i n the image this circle acquires a reduced average</p>
    <p>intensity flow across its boundary, and hence a weaker n u</p>
    <p>merator, N [ d R ] . To emphasize this, i t is worth noting that when the still image version o f t h e model is applied to these</p>
    <p>images, i t consistently identifies whichever circle is lower</p>
    <p>i n the image.</p>
    <p>In figures 5 and 6 are shown the results of the appli</p>
    <p>cation of the model to several stereo pairs and image se</p>
    <p>quences. The examples took about 5 to 20 minutes to r u n</p>
    <p>on stereo pairs of 135x 152, 148x 148, and 230x260 pix</p>
    <p>els and triples of images from motion sequences of 75 x 5 0</p>
    <p>and 5 5 x 7 0 pixels. The model successfully identifies cor</p>
    <p>responding regions within each image, and is consistent</p>
    <p>across consecutive triples of motion sequence images, even</p>
    <p>though no initialization was used to pass from one triple</p>
    <p>to the next. Note that although there is a tendency for the boundaries to lie on discontinuities, this tendency can be</p>
    <p>overruled by other propertics of the region model, i n this</p>
    <p>case the tendency to find boundaries lying on high intensity</p>
    <p>Figure 5. The results, shown on the right, of</p>
    <p>applying the algorithm to some stereo pairs, shown on the left. The algorithm was iterated</p>
    <p>on the images, the numbers showing the order in which the regions were found.</p>
    <p>gradients. This is to be expected: a sharp intensity gradi</p>
    <p>ent may signal the boundary of an object even though there</p>
    <p>is no discontinuity present. Both are indicators of such a</p>
    <p>boundary.</p>
    <p>We have presented a method for the extraction of regions</p>
    <p>from multiple images simultaneously with their correspon</p>
    <p>dences. This method falls within the category of methods</p>
    <p>that search for regions in images possessing certain proper</p>
    <p>ties directly, without performing dense computations, a par</p>
    <p>ticularly relevantexample being active contours. The model</p>
    <p>allowsa broad range of possibilities for the description both</p>
    <p>of regions i n the individual images and of their correspondences. For any of these possibilities, the optimal regions</p>
    <p>and boundary correspondences can be found i n polynomial</p>
    <p>time. We have illustrated the model using the simplest (and</p>
    <p>hence most likely to be broadly useful) choices for the terms</p>
    <p>in the energy. In addition, we have introduced an energy</p>
    <p>term based on a novel heuristic that favours boundaries ly</p>
    <p>ing on discontinuities i n the disparity or optical flow. This</p>
    <p>energy should be useful beyond the specific model used i n</p>
    <p>this paper.</p>
    <p>The principle drawback of the method lies in the nature</p>
    <p>of the object models. Object recognition i n images is a</p>
    <p>hard problem, and although equation 2.1 can incorporate</p>
    <p>a great variety of different information, i t is all in the form</p>
    <p>of summations over the region or boundary. The same crit</p>
    <p>icism applies to active contours and segmentation by parti</p>
    <p>tion methods. It is clear that using this type of information</p>
    <p>Authorized licensed use limited to: MIT Libraries. Downloaded on December 25, 2008 at 13:09 from IEEE Xplore. Restrictions apply.</p>
  </div>
  <div class="page">
    <p>Related Work General graphs:  Dijkstra (non-negative lengths) - O (n log n + m)  Bellman-Ford - O(nm)</p>
    <p>Planar graphs:  O(n3/2) - [Lipton, Rose and Tarjan 1979]  O(n4/3 log2/3 D) - [Henzinger, Klein, Rao, Subramanian 1994]</p>
    <p>also, O(n) for non-negative lengths  O(n log3 n) time O(n log n) space - [Fakcharoenphol and</p>
    <p>Rao 2001]</p>
    <p>Our Contribution:  O(n log2 n) time, O(n) space</p>
  </div>
  <div class="page">
    <p>Rerooting</p>
    <p>r s</p>
  </div>
  <div class="page">
    <p>Rerooting</p>
    <p>r s</p>
    <p>We want distances from s  It suffices to find distances</p>
    <p>from any node r</p>
  </div>
  <div class="page">
    <p>Price Functions, Reduced Lengths</p>
    <p>Price function: (v)  Reduced length: l(uv) = (u) + l(uv) - (v)</p>
  </div>
  <div class="page">
    <p>Price Functions, Reduced Lengths</p>
    <p>Price function: (v)  Reduced length: l(uv) = (u) + l(uv) - (v)</p>
    <p>u v w</p>
  </div>
  <div class="page">
    <p>Price Functions, Reduced Lengths</p>
    <p>Price function: (v)  Reduced length: l(uv) = (u) + l(uv) - (v)</p>
    <p>u v w</p>
  </div>
  <div class="page">
    <p>Price Functions, Reduced Lengths</p>
    <p>Price function: (v)  Reduced length: l(uv) = (u) + l(uv) - (v)</p>
    <p>u v w</p>
  </div>
  <div class="page">
    <p>Price Functions, Reduced Lengths</p>
    <p>Price function: (v)  Reduced length: l(uv) = (u) + l(uv) - (v)</p>
    <p>u v w</p>
  </div>
  <div class="page">
    <p>Price Functions, Reduced Lengths</p>
    <p>Price function: (v)  Reduced length: l(uv) = (u) + l(uv) - (v)</p>
    <p>u v w</p>
  </div>
  <div class="page">
    <p>Price Functions, Reduced Lengths</p>
    <p>Price function: (v)  Reduced length: l(uv) = (u) + l(uv) - (v)</p>
    <p>u v w</p>
  </div>
  <div class="page">
    <p>Price Functions, Reduced Lengths</p>
    <p>Price function: (v)  Reduced length: l(uv) = (u) + l(uv) - (v)</p>
    <p>u v w</p>
    <p>Length of any s-t path changes by (s)-(t)</p>
  </div>
  <div class="page">
    <p>Price Functions, Reduced Lengths</p>
    <p>Price function: (v)  Reduced length: l(uv) = (u) + l(uv) - (v)</p>
    <p>u v w</p>
    <p>Length of any s-t path changes by (s)-(t)  (v) preserves shortest paths</p>
  </div>
  <div class="page">
    <p>Price Functions, Reduced Lengths</p>
    <p>Price function: (v)  Reduced length: l(uv) = (u) + l(uv) - (v)  Length of any s-t path changes by (s)-(t)  (v) preserves shortest paths</p>
  </div>
  <div class="page">
    <p>Price Functions, Reduced Lengths</p>
    <p>Price function: (v)  Reduced length: l(uv) = (u) + l(uv) - (v)  Length of any s-t path changes by (s)-(t)  (v) preserves shortest paths</p>
  </div>
  <div class="page">
    <p>Price Functions, Reduced Lengths</p>
    <p>Price function: (v)  Reduced length: l(uv) = (u) + l(uv) - (v)  Length of any s-t path changes by (s)-(t)  (v) preserves shortest paths</p>
    <p>Price function is feasible if l is non-negative  Converts a problem with negative lengths to</p>
    <p>non-negative lengths</p>
  </div>
  <div class="page">
    <p>Price Functions, Reduced Lengths</p>
    <p>Price function: (v)  Reduced length: l(uv) = (u) + l(uv) - (v)  Length of any s-t path changes by (s)-(t)  (v) preserves shortest paths</p>
    <p>Price function is feasible if l is non-negative  Converts a problem with negative lengths to</p>
    <p>non-negative lengths  Single source distances form a feasible price</p>
    <p>function because (u) + l(uv)  (v)</p>
  </div>
  <div class="page">
    <p>Rerooting</p>
    <p>r s</p>
    <p>We want distances from s  It suffices to find distances from</p>
    <p>any node r</p>
  </div>
  <div class="page">
    <p>Rerooting</p>
    <p>r s</p>
    <p>We want distances from s  It suffices to find distances from</p>
    <p>any node r</p>
    <p>- Use distances from r as a feasible price function</p>
  </div>
  <div class="page">
    <p>Rerooting</p>
    <p>r s</p>
    <p>We want distances from s  It suffices to find distances from</p>
    <p>any node r</p>
    <p>- Use distances from r as a feasible price function</p>
    <p>- Run Dijkstras algorithm from s</p>
  </div>
  <div class="page">
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>G1</p>
    <p>G0</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>High-Level View</p>
    <p>G1</p>
    <p>G0</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
  </div>
  <div class="page">
    <p>High-Level View</p>
    <p>G1</p>
    <p>G0</p>
    <p>r</p>
    <p>r</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
  </div>
  <div class="page">
    <p>High-Level View</p>
    <p>G1</p>
    <p>G0</p>
    <p>r</p>
    <p>r</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
  </div>
  <div class="page">
    <p>r</p>
    <p>G1</p>
    <p>G0</p>
    <p>r I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>r</p>
    <p>G1</p>
    <p>G0</p>
    <p>r I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>1</p>
    <p>r</p>
    <p>G1</p>
    <p>G0</p>
    <p>r I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>1</p>
    <p>r</p>
    <p>G1</p>
    <p>G0 0</p>
    <p>r I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>1</p>
    <p>r</p>
    <p>G1</p>
    <p>G0 0</p>
    <p>r</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>1</p>
    <p>G1G0</p>
    <p>0</p>
    <p>r</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>G1G0</p>
    <p>1 0</p>
    <p>r</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>1 0</p>
    <p>r</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>1 0</p>
    <p>r</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>r</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>r</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>r</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>r</p>
    <p>r</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>G1</p>
    <p>r</p>
    <p>G0</p>
    <p>r</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>G1</p>
    <p>r</p>
    <p>G0</p>
    <p>r</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>G1</p>
    <p>G0</p>
    <p>r</p>
    <p>r</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>r</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>r s</p>
    <p>I. recursion II. boundary to boundary</p>
    <p>distances in Gi</p>
    <p>III. r-to-boundary distances in G</p>
    <p>IV. distances from r in G V. rerooting</p>
    <p>High-Level View</p>
  </div>
  <div class="page">
    <p>Planar Separator:</p>
    <p>boundary nodes  At most 2n/3 nodes in each part  Can be found in O (n) time</p>
    <p>[Lipton-Tarjan 79, Miller 86]</p>
    <p>I. Recursive Step</p>
    <p>G O</p>
    <p>!! n &quot;</p>
  </div>
  <div class="page">
    <p>Planar Separator:</p>
    <p>boundary nodes  At most 2n/3 nodes in each part  Can be found in O (n) time</p>
    <p>[Lipton-Tarjan 79, Miller 86]</p>
    <p>I. Recursive Step</p>
    <p>G O</p>
    <p>!! n &quot;</p>
  </div>
  <div class="page">
    <p>Planar Separator:</p>
    <p>boundary nodes  At most 2n/3 nodes in each part  Can be found in O (n) time</p>
    <p>[Lipton-Tarjan 79, Miller 86]</p>
    <p>G1</p>
    <p>I. Recursive Step</p>
    <p>G0</p>
    <p>G O</p>
    <p>!! n &quot;</p>
  </div>
  <div class="page">
    <p>I. Recursive Step</p>
    <p>G1</p>
    <p>G0</p>
  </div>
  <div class="page">
    <p>I. Recursive Step</p>
    <p>G1</p>
    <p>G0</p>
  </div>
  <div class="page">
    <p>I. Recursive Step</p>
    <p>Choose an arbitrary boundary node r</p>
    <p>G1</p>
    <p>G0</p>
    <p>r</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>I. Recursive Step</p>
    <p>Choose an arbitrary boundary node r</p>
    <p>Recursively compute distances from r within G0</p>
    <p>G1</p>
    <p>G0</p>
    <p>r</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>I. Recursive Step</p>
    <p>Choose an arbitrary boundary node r</p>
    <p>Recursively compute distances from r within G0</p>
    <p>Recursively compute distances from r within G1</p>
    <p>G1</p>
    <p>G0</p>
    <p>r</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>Compute all boundary-to-boundary distances within G1</p>
    <p>O (n) pairs of boundary nodes  algorithm: multiple-source shortest</p>
    <p>paths [Klein 2005] in O (n log n) time</p>
    <p>Uses from-r distances in G1  Repeat for G0</p>
    <p>II. Boundary-to-Boundary Distances in Gi</p>
    <p>G1</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>Compute all boundary-to-boundary distances within G1</p>
    <p>O (n) pairs of boundary nodes  algorithm: multiple-source shortest</p>
    <p>paths [Klein 2005] in O (n log n) time</p>
    <p>Uses from-r distances in G1  Repeat for G0</p>
    <p>II. Boundary-to-Boundary Distances in Gi</p>
    <p>G1</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>Compute all boundary-to-boundary distances within G1</p>
    <p>O (n) pairs of boundary nodes  algorithm: multiple-source shortest</p>
    <p>paths [Klein 2005] in O (n log n) time</p>
    <p>Uses from-r distances in G1  Repeat for G0</p>
    <p>II. Boundary-to-Boundary Distances in Gi</p>
    <p>1 G1</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>Compute all boundary-to-boundary distances within G1</p>
    <p>O (n) pairs of boundary nodes  algorithm: multiple-source shortest</p>
    <p>paths [Klein 2005] in O (n log n) time</p>
    <p>Uses from-r distances in G1  Repeat for G0</p>
    <p>II. Boundary-to-Boundary Distances in Gi</p>
    <p>1 G1</p>
    <p>r</p>
    <p>0</p>
  </div>
  <div class="page">
    <p>r</p>
    <p>III. r-to-boundary Distances in G</p>
    <p>10</p>
    <p>G1G0</p>
  </div>
  <div class="page">
    <p>Compute distances from r to all boundary nodes</p>
    <p>r</p>
    <p>III. r-to-boundary Distances in G</p>
    <p>10</p>
    <p>G1G0</p>
  </div>
  <div class="page">
    <p>Compute distances from r to all boundary nodes  Shortest path in G consists of</p>
    <p>alternating boundary-to-boundary shortest paths in G0 and G1</p>
    <p>r</p>
    <p>III. r-to-boundary Distances in G</p>
    <p>10</p>
    <p>G1G0</p>
  </div>
  <div class="page">
    <p>Compute distances from r to all boundary nodes  Shortest path in G consists of</p>
    <p>alternating boundary-to-boundary shortest paths in G0 and G1</p>
    <p>Bellman-Ford using just boundary-to-boundary distances</p>
    <p>r</p>
    <p>III. r-to-boundary Distances in G</p>
    <p>10</p>
    <p>G1G0</p>
    <p>!v ej [v] := min w</p>
    <p>{ej!1[w] + !i[w, v]}</p>
  </div>
  <div class="page">
    <p>10</p>
    <p>All iterations in [Lipton-Rose-Tarjan 1979]   has a Monge non-crossing property [Fakcharoenphol</p>
    <p>Rao 2001]  O (n log2 n) time  We show: O (n(n)) time</p>
    <p>III. r-to-boundary Distances in G</p>
    <p>!v ej [v] := min w</p>
    <p>{ej!1[w] + !i[w, v]} O</p>
    <p>! n3/2</p>
    <p>&quot;</p>
  </div>
  <div class="page">
    <p>10</p>
    <p>Think of a matrix whose w,v element is  We want to find all column minima of this matrix</p>
    <p>III. r-to-boundary Distances in G</p>
    <p>!v ej [v] := min w</p>
    <p>{ej!1[w] + !i[w, v]}</p>
  </div>
  <div class="page">
    <p>Monge Matrices</p>
    <p>i</p>
    <p>j</p>
    <p>k l</p>
  </div>
  <div class="page">
    <p>Monge Matrices  A matrix is Monge if for any i  j,k  l (i,k) +(j,l)  (i,l) +(j,k)</p>
    <p>i</p>
    <p>j</p>
    <p>k l</p>
  </div>
  <div class="page">
    <p>Monge Matrices  A matrix is Monge if for any i  j,k  l (i,k) +(j,l)  (i,l) +(j,k)</p>
    <p>All column minima of an n x n Monge matrix can be found in O(n) time [SMAWK 1989]</p>
    <p>i</p>
    <p>j</p>
    <p>k l</p>
  </div>
  <div class="page">
    <p>10</p>
    <p>Think of a matrix whose w,v element is  We want to find all column minima of this matrix  Show that this matrix is Monge</p>
    <p>III. r-to-boundary Distances in G</p>
    <p>!v ej [v] := min w</p>
    <p>{ej!1[w] + !i[w, v]}</p>
  </div>
  <div class="page">
    <p>i</p>
    <p>j k</p>
    <p>l</p>
    <p>Crossings and the Monge Property</p>
  </div>
  <div class="page">
    <p>i</p>
    <p>j k</p>
    <p>l w</p>
    <p>Crossings and the Monge Property</p>
    <p>(i,k) + (j,l)</p>
  </div>
  <div class="page">
    <p>i</p>
    <p>j k</p>
    <p>l w</p>
    <p>Crossings and the Monge Property</p>
    <p>(i,k) + (j,l)  (i,l) + (j,k)</p>
  </div>
  <div class="page">
    <p>Crossings and the Monge Property</p>
    <p>i</p>
    <p>l i</p>
    <p>j</p>
    <p>k l</p>
    <p>k j</p>
    <p>(i,k) + (j,l)  (i,l) + (j,k)</p>
  </div>
  <div class="page">
    <p>Crossings and the Monge Property</p>
    <p>i</p>
    <p>l i</p>
    <p>j</p>
    <p>k l</p>
    <p>k j (i,k) + (j,l)  (i,l) + (j,k)</p>
  </div>
  <div class="page">
    <p>Crossings and the Monge Property</p>
    <p>i</p>
    <p>l i</p>
    <p>j</p>
    <p>k l</p>
    <p>k j</p>
    <p>(i,k) + (j,l)  (i,l) + (j,k)</p>
  </div>
  <div class="page">
    <p>Crossings and the Monge Property</p>
    <p>i</p>
    <p>j k</p>
    <p>li</p>
    <p>j</p>
    <p>k l</p>
  </div>
  <div class="page">
    <p>Crossings and the Monge Property</p>
    <p>i</p>
    <p>j k</p>
    <p>li</p>
    <p>j</p>
    <p>k l</p>
  </div>
  <div class="page">
    <p>Crossings and the Monge Property</p>
    <p>i</p>
    <p>j k</p>
    <p>li</p>
    <p>j</p>
    <p>k l</p>
  </div>
  <div class="page">
    <p>Partial Monge Matrices  Column Minima of a triangular Monge</p>
    <p>matrix can be found in O(n(n)) time [Klawe-Kleitman 1990] i</p>
    <p>j</p>
    <p>k l</p>
  </div>
  <div class="page">
    <p>i is partially Monge even when adding ej-1[w] to row w  Each iteration takes  iterations</p>
    <p>All iterations in O(n(n)) time</p>
    <p>10</p>
    <p>III. r-to-boundary Distances in G</p>
    <p>!v ej [v] := min w</p>
    <p>{ej!1[w] + !i[w, v]}!v ej [v] := min w</p>
    <p>{ej!1[w] + !i[w, v]}</p>
    <p>O !!</p>
    <p>n &quot; O(</p>
    <p>! n!( !</p>
    <p>n))</p>
  </div>
  <div class="page">
    <p>So Far We Have:  r-to-boundary distances in G</p>
    <p>r-to-all distances in Gi</p>
    <p>G1</p>
    <p>G0</p>
    <p>r r</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>IV. From-r Distances in G</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>Add r-to-boundary edges. Use distances in G as edge lengths  Distances from r in this graph are equal to distances in G</p>
    <p>IV. From-r Distances in G</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>Add r-to-boundary edges. Use distances in G as edge lengths  Distances from r in this graph are equal to distances in G  Distances from r in G1 are almost feasible price function</p>
    <p>IV. From-r Distances in G</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>Add r-to-boundary edges. Use distances in G as edge lengths  Distances from r in this graph are equal to distances in G  Distances from r in G1 are almost feasible price function  Setting (r) to a sufficiently large value makes it feasible</p>
    <p>IV. From-r Distances in G</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>Add r-to-boundary edges. Use distances in G as edge lengths  Distances from r in this graph are equal to distances in G  Distances from r in G1 are almost feasible price function  Setting (r) to a sufficiently large value makes it feasible</p>
    <p>IV. From-r Distances in G</p>
    <p>r r</p>
  </div>
  <div class="page">
    <p>Analysis step techniques time</p>
    <p>I</p>
    <p>II</p>
    <p>III</p>
    <p>IV</p>
    <p>V</p>
    <p>recursion planar separator</p>
    <p>boundary to boundary distances in Gi</p>
    <p>multiple-source planar shortest paths [Klein 2005]</p>
    <p>|G| log(|G|)</p>
    <p>r-to-boundary distances in G</p>
    <p>Bellman-Ford, partial Monge searching [Klawe-Kleitman 1990]</p>
    <p>|G| (|G|)</p>
    <p>distances from r in G augmented graph, feasible price function, Dijkstra</p>
    <p>|G| log(|G|) (can be done in O(|G|))</p>
    <p>rerooting distances from s in G</p>
    <p>feasible price function, Dijkstra |G| log(|G|) (can be done in O(|G|))</p>
    <p>O(log n) levels  O(n log2 n) time O(n) space</p>
  </div>
  <div class="page">
    <p>s</p>
    <p>i</p>
    <p>i'</p>
    <p>j</p>
    <p>j'</p>
    <p>t</p>
    <p>z</p>
    <p>Monge in Other Planar Problems</p>
    <p>Use of efficient Monge searching may be applicable in other planar graphs problem</p>
    <p>Example: improvement on the running time of an algorithm for the replacement path problem [Emek, Peleg, Roditty SODA08]</p>
  </div>
  <div class="page">
    <p>Thank You!</p>
  </div>
</Presentation>
