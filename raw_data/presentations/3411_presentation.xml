<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>CLKSCREW Exposing the Perils of Security-Oblivious Energy Management</p>
    <p>USENIX Security 2017</p>
    <p>Adrian Tang, Simha Sethumadhavan, Salvatore Stolfo</p>
  </div>
  <div class="page">
    <p>Energy Management Todays systems cannot exist without</p>
    <p>Source: Adapted from S. Borkar (Intel)</p>
    <p>power density</p>
    <p>functionalities</p>
    <p>i386 i486</p>
    <p>Pentium Pentium Pro</p>
    <p>Pentium II</p>
    <p>Pentium III</p>
    <p>Hot plate</p>
    <p>Nuclear reactor</p>
    <p>Rocket nozzle Suns surface</p>
  </div>
  <div class="page">
    <p>Energy Management Todays systems cannot exist without</p>
    <p>AcademiaIndustry</p>
    <p>frequency</p>
    <p>power energy</p>
    <p>voltage</p>
    <p>Source: Word-cloud from ISCA, ASPLOS, MICRO, HPCA (2000 - 2016)</p>
  </div>
  <div class="page">
    <p>Energy Management Todays systems cannot exist without</p>
    <p>Complicated</p>
    <p>Pervasive</p>
    <p>Essential</p>
  </div>
  <div class="page">
    <p>Energy Management Todays systems cannot exist without</p>
    <p>stay secure with</p>
  </div>
  <div class="page">
    <p>Energy Management Exploiting software interfaces to</p>
    <p>Software-based attacker</p>
    <p>Stretch operational limits</p>
    <p>fr eq</p>
    <p>ue nc</p>
    <p>y</p>
    <p>voltage</p>
    <p>Induce faults</p>
    <p>decryption</p>
    <p>key</p>
  </div>
  <div class="page">
    <p>Energy Management Exploiting software interfaces to</p>
    <p>Software-based attacker</p>
    <p>Stretch operational limits</p>
    <p>fr eq</p>
    <p>ue nc</p>
    <p>y</p>
    <p>voltage</p>
    <p>Induce faults</p>
    <p>decryption</p>
    <p>key</p>
    <p>Traditional fault attacks Need physical proximity</p>
    <p>Need separate equipment Soldering, crocodile clips, wire, etc</p>
  </div>
  <div class="page">
    <p>Energy Management CLKSCREW: Exposing the perils of security-oblivious</p>
    <p>New attack vector that exploits energy management</p>
    <p>Practical attack on trusted computing on ARM devices</p>
    <p>Impacts hundreds of millions of deployed devices</p>
    <p>Lessons for future energy management designs to be security-conscious</p>
  </div>
  <div class="page">
    <p>I. DVFS and Regulators</p>
    <p>II. The CLKSCREW Attack</p>
    <p>III. Attacking ARM Trustzone</p>
    <p>IV. Concluding Remarks</p>
  </div>
  <div class="page">
    <p>Dynamic Voltage and Frequency Scaling (DVFS)</p>
    <p>Energy consumption</p>
    <p>Frequency</p>
    <p>Voltage</p>
    <p>DVFS</p>
  </div>
  <div class="page">
    <p>Hardware &amp; Software Support for DVFS</p>
    <p>Software</p>
    <p>Hardware</p>
    <p>DVFS</p>
    <p>Frequency Regulator</p>
    <p>Voltage Regulator</p>
    <p>Power Governor</p>
    <p>Vendor Device Driver</p>
    <p>Memory-Mapped Registers</p>
  </div>
  <div class="page">
    <p>Hardware Regulators and Software Interfaces</p>
    <p>SoC Processor (Nexus 6)</p>
    <p>SPM (All cores)Core 0</p>
    <p>Voltage Control</p>
    <p>Voltage Domain (All cores)</p>
    <p>PMA8084 PMIC</p>
    <p>Voltage output to cores</p>
    <p>Input</p>
    <p>Voltage output to other peripherals</p>
    <p>Core 0Core 0Core 0 Clock MUX Core</p>
    <p>Clock Domain (per-core)</p>
    <p>PLL (fixed rate)</p>
    <p>HFPLL (variable rate)</p>
    <p>Half Divider</p>
    <p>N * 19.2 MHz</p>
    <p>N/2 * 19.2 MHz</p>
    <p>N Multiplier Source Selector</p>
    <p>SoC Processor (Nexus 6)</p>
    <p>Operating frequency and voltage can be configured via memory-mapped registers from software</p>
    <p>Frequency regulators Voltage regulators</p>
  </div>
  <div class="page">
    <p>Do hardware regulators impose limits to frequency/voltage changes?</p>
  </div>
  <div class="page">
    <p>Frequency / Voltage Operating Point Pairs (OPPs)</p>
    <p>Vendor-recommended Legend:</p>
    <p>Nexus 6</p>
    <p>) rH</p>
    <p>q u</p>
    <p>H n</p>
    <p>F y (</p>
    <p>G H</p>
    <p>z )</p>
    <p>Voltage (V)</p>
    <p>Fr eq</p>
    <p>ue nc</p>
    <p>y (G</p>
    <p>H z)</p>
  </div>
  <div class="page">
    <p>Lower voltage Lower minimum required frequency to induce instability</p>
    <p>No safeguard hardware limits</p>
    <p>Max OPP reached before instability</p>
    <p>Legend: Vendor-recommended</p>
    <p>Frequency / Voltage Operating Point Pairs (OPPs)</p>
    <p>) rH</p>
    <p>q u</p>
    <p>H n</p>
    <p>F y (</p>
    <p>G H</p>
    <p>z )</p>
    <p>Voltage (V)</p>
    <p>Fr eq</p>
    <p>ue nc</p>
    <p>y (G</p>
    <p>H z)</p>
  </div>
  <div class="page">
    <p>) rH</p>
    <p>q u</p>
    <p>H n</p>
    <p>F y (</p>
    <p>G H</p>
    <p>z )</p>
    <p>) rH</p>
    <p>q u</p>
    <p>H n</p>
    <p>F y (</p>
    <p>G H</p>
    <p>z )</p>
    <p>Frequency / Voltage Operating Point Pairs (OPPs) Fr</p>
    <p>eq ue</p>
    <p>nc y</p>
    <p>(G H</p>
    <p>z)</p>
    <p>Fr eq</p>
    <p>ue nc</p>
    <p>y (G</p>
    <p>H z)</p>
    <p>Voltage (V) Voltage (V)</p>
    <p>Device A Device B</p>
  </div>
  <div class="page">
    <p>Does DVFS operate across security boundaries?</p>
    <p>Trusted Execution Environments (TEE)</p>
  </div>
  <div class="page">
    <p>Is DVFS Trustzone-Aware?</p>
    <p>CPU Core</p>
    <p>Trustzone Trusted code</p>
    <p>Normal Untrusted code</p>
    <p>Hardware-enforced isolation</p>
    <p>Frequency &amp; Voltage Regulators</p>
    <p>Regulator HW-SW interface</p>
    <p>Frequency and voltage changes</p>
    <p>No!</p>
  </div>
  <div class="page">
    <p>I. DVFS and Regulators</p>
    <p>II. The CLKSCREW Attack</p>
    <p>III. Attacking ARM Trustzone</p>
    <p>IV. Concluding Remarks</p>
  </div>
  <div class="page">
    <p>Can we attack Trustzone code execution using software-only control of the regulators?</p>
  </div>
  <div class="page">
    <p>Induce timing faults</p>
    <p>confidentiality integrity</p>
    <p>availability</p>
  </div>
  <div class="page">
    <p>How do faults occur (due to over-raising frequency)?</p>
    <p>input output input output</p>
    <p>CLK signal</p>
  </div>
  <div class="page">
    <p>How do faults occur (due to over-raising frequency)?</p>
    <p>flip-flop flip-flop input output input output</p>
    <p>CLK signal</p>
    <p>intermediate logic path input output</p>
    <p>higher frequency</p>
    <p>less time for data to propagate 1</p>
    <p>timing violation 0</p>
  </div>
  <div class="page">
    <p>How do faults occur (due to over-raising frequency)?</p>
    <p>Expected:  a777511b</p>
    <p>Faulty output:  a7775151</p>
  </div>
  <div class="page">
    <p>CLKSCREW Challenges &amp; Solutions</p>
    <p>#1: Regulator operating limits</p>
    <p>#2: Self-containment within same device</p>
    <p>#3: Noisy complex OS environment</p>
    <p>#4: Precise timing</p>
    <p>#5: Fine-grained timing resolution</p>
  </div>
  <div class="page">
    <p>#1: Regulator operating limits</p>
    <p>#2: Self-containment within same device</p>
    <p>#3: Noisy complex OS environment</p>
    <p>#4: Precise timing</p>
    <p>#5: Fine-grained timing resolution</p>
    <p>Addressed earlier in DVFS regulators</p>
    <p>) rH</p>
    <p>q u</p>
    <p>H n</p>
    <p>F y (</p>
    <p>G H</p>
    <p>z )</p>
    <p>CLKSCREW Challenges &amp; Solutions</p>
  </div>
  <div class="page">
    <p>#1: Regulator operating limits</p>
    <p>#2: Self-containment within same device</p>
    <p>#3: Noisy complex OS environment</p>
    <p>#4: Precise timing</p>
    <p>#5: Fine-grained timing resolution</p>
    <p>Cores have different frequency regulators</p>
    <p>Core pinning</p>
    <p>Coretarget</p>
    <p>Coreattack</p>
    <p>attack thread</p>
    <p>victim thread</p>
    <p>start fault</p>
    <p>end fault</p>
    <p>code execution to inject fault</p>
    <p>CLKSCREW Challenges &amp; Solutions</p>
  </div>
  <div class="page">
    <p>#1: Regulator operating limits</p>
    <p>#2: Self-containment within same device</p>
    <p>#3: Noisy complex OS environment</p>
    <p>#4: Precise timing</p>
    <p>#5: Fine-grained timing resolution</p>
    <p>Disable interrupts during attack</p>
    <p>Core pinning</p>
    <p>Coretarget</p>
    <p>Coreattack</p>
    <p>attack thread</p>
    <p>victim thread</p>
    <p>start fault</p>
    <p>end fault</p>
    <p>code execution to inject fault</p>
    <p>disable interrupts</p>
    <p>enable interrupts</p>
    <p>CLKSCREW Challenges &amp; Solutions</p>
  </div>
  <div class="page">
    <p>#1: Regulator operating limits</p>
    <p>#2: Self-containment within same device</p>
    <p>#3: Noisy complex OS environment</p>
    <p>#4: Precise timing</p>
    <p>#5: Fine-grained timing resolution Cache-based execution timing profiling</p>
    <p>High-precision timing loops in attack architecture</p>
    <p>Victim thread</p>
    <p>~1,100,000,000,000 clock cycles</p>
    <p>~65,000 clock cycles</p>
    <p>asm volatile(&quot;1: subs %0, %0, #1 \n&quot; &quot; bhi 1b \n&quot;::&quot;r&quot; (loops));</p>
    <p>CLKSCREW Challenges &amp; Solutions</p>
  </div>
  <div class="page">
    <p>I. DVFS and Regulators</p>
    <p>II. The CLKSCREW Attack</p>
    <p>III. Attacking ARM Trustzone</p>
    <p>IV. Concluding Remarks</p>
  </div>
  <div class="page">
    <p>Subverting Trustzone Isolation with CLKSCREW</p>
    <p>Trustzone Normal</p>
    <p>secret key ciphertext</p>
    <p>plaintext</p>
    <p>Confidentiality Attack infer secret AES key stored within Trustzone</p>
    <p>AES decryption</p>
    <p>I. Trustzone Normal</p>
    <p>RSA decryption</p>
    <p>plaintext hash</p>
    <p># SHA-256</p>
    <p>hash verify &amp;</p>
    <p>load app</p>
    <p>== signed app</p>
    <p>Integrity Attack load self-signed app into TrustzoneII.</p>
    <p>app binary</p>
    <p>digital signature</p>
    <p>public key</p>
    <p>(More details in the paper)</p>
  </div>
  <div class="page">
    <p>Key Inference Attack: Threat Model</p>
    <p>Victim app: AES decryption app executing in Trustzone</p>
    <p>Trustzone Normal</p>
    <p>secret key</p>
    <p>AES Decryptor ciphertext</p>
    <p>plaintext</p>
    <p>Attackers goal: Get secret AES key from outside Trustzone</p>
    <p>Attackers capabilities: 1) Can repeatedly invoke the decryption app 2) Has software access to hardware regulators</p>
    <p>CLKSCR EW</p>
  </div>
  <div class="page">
    <p>Trustzone Normal</p>
    <p>secret key ciphertext</p>
    <p>AES decryption</p>
    <p>Faulty</p>
    <p>Differential Fault Analysis [1]</p>
    <p>Key Inference Attack: Summary</p>
    <p>faulty plaintext</p>
    <p>Idea: Induce a fault during the AES decryption Infer key from a pair of correct and faulty plaintext</p>
    <p>Trustzone Normal</p>
    <p>secret key ciphertext</p>
    <p>correct plaintext</p>
    <p>AES decryption</p>
    <p>Correct</p>
    <p>CLKSCR EW</p>
    <p>[1] Tunstall et al. Differential Fault Analysis of the Advanced Encryption Standard using a Single Fault. In IFIP International Workshop on Information Security Theory and Practices (2011).</p>
    <p>secret key</p>
  </div>
  <div class="page">
    <p>Key Inference Attack: CLKSCREW Parameters</p>
    <p>Differential Fault Analysis needs CLKSCREW to deliver a one-byte fault to the 7th AES round</p>
    <p>Base voltage:</p>
    <p>Low frequency:</p>
    <p>High frequency:</p>
    <p>Fault injection duration:</p>
  </div>
  <div class="page">
    <p>Key Inference Attack: Timing Profiling</p>
    <p>Execution timing of Trustzone code can be profiled with hardware cycle counters that are accessible outside of Trustzone</p>
  </div>
  <div class="page">
    <p>How varied is the execution timing of the victim decryption app? Victim AES Thread</p>
    <p>Execution time (in clock cycles)</p>
    <p>N or</p>
    <p>m ali</p>
    <p>ze d</p>
    <p>fre qu</p>
    <p>en cy</p>
    <p>Not too much variability in terms of execution time</p>
    <p>Key Inference Attack: Timing Profiling</p>
  </div>
  <div class="page">
    <p>Can we effectively control the timing of the fault delivery with no-op loops? Attack Thread</p>
    <p>Number of no-op loops is a good proxy to control timing of fault delivery</p>
    <p>Key Inference Attack: Timing Profiling</p>
  </div>
  <div class="page">
    <p>Our fault model requires our attack to inject fault</p>
    <p>Exactly one AES round at the 7th round</p>
    <p>Corruption of exactly one byte</p>
    <p>Key Inference Attack: Fault Model</p>
  </div>
  <div class="page">
    <p>a li z e d</p>
    <p>f re</p>
    <p>q u</p>
    <p>e n</p>
    <p>c y</p>
    <p>a li z e d</p>
    <p>f re</p>
    <p>q u</p>
    <p>e n</p>
    <p>c y</p>
    <p>Precision: How likely can we inject fault in exactly one AES round?</p>
    <p>More than 60% of the resulting faults are precise enough to corrupt exactly one AES round</p>
    <p>Key Inference Attack: Fault Model</p>
  </div>
  <div class="page">
    <p>a li z e d</p>
    <p>f re</p>
    <p>q u</p>
    <p>e n</p>
    <p>c y</p>
    <p>a li z e d</p>
    <p>f re</p>
    <p>q u</p>
    <p>e n</p>
    <p>c y</p>
    <p>Transience: How likely can we corrupt exactly one byte?</p>
    <p>Out of the above faults that affect one AES round, more than half are transient enough to corrupt exactly one byte</p>
    <p>Key Inference Attack: Fault Model</p>
  </div>
  <div class="page">
    <p>Controlling Fpdelay allows us to precisely time the delivery of the fault to the targeted AES round</p>
    <p>Cycle length ratio: ggNTattack/ggNTtarget</p>
    <p>C o rr</p>
    <p>u S</p>
    <p>te d</p>
    <p>A E</p>
    <p>o u</p>
    <p>n d</p>
    <p>Statistics: ~20 faulting attempts to induce one-byte fault to desired AES round. ~12 min on a 2.7GHz quad core CPU to generate 3650 key hypotheses</p>
    <p>Key Inference Attack: Results</p>
  </div>
  <div class="page">
    <p>I. DVFS and Regulators</p>
    <p>II. The CLKSCREW Attack</p>
    <p>III. Attacking ARM Trustzone</p>
    <p>IV. Concluding Remarks</p>
  </div>
  <div class="page">
    <p>Attack Applicability to Other Platforms</p>
    <p>Energy management mechanisms in the industry is trending towards finer-grained and increasingly heterogeneous designs</p>
    <p>v8</p>
    <p>Cloud computing providers</p>
  </div>
  <div class="page">
    <p>Possible Defenses</p>
    <p>Hardware-Level Operating limits in hardware Separate cross-boundary regulators Microarchitectural Redundancy</p>
    <p>Software-Level Randomization Code execution redundancy</p>
  </div>
  <div class="page">
    <p>Energy Management CLKSCREW: Exposing the perils of security-oblivious</p>
    <p>New attack surface via energy management software interfaces</p>
    <p>Not a hardware or software bug Fundamental design flaw in energy management mechanisms</p>
    <p>Future energy management designs must take security into consideration</p>
    <p>Adrian Tang - @0x0atang Simha Sethumadhavan, Salvatore Stolfo</p>
    <p>USENIX Security 2017</p>
  </div>
</Presentation>
