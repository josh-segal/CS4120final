<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>DCV: A Causality Detection Approach for</p>
    <p>Large-scale Dynamic Collaboration</p>
    <p>Environments</p>
    <p>Jiang-Ming Yang Microsoft Research Asia</p>
    <p>Ning Gu, Qi-Wei Zhang, Jiang-Ming Yang and Wei Ye</p>
    <p>Fudan University</p>
  </div>
  <div class="page">
    <p>Agenda</p>
    <p>Introduction  Direct Causal Vector Timestamp (DCV)  Causality Detection Algorithms  Discussion  Future Work</p>
  </div>
  <div class="page">
    <p>Agenda</p>
    <p>Introduction  Direct Causal Vector Timestamp (DCV)  Causality Detection Algorithms  Discussion  Future Work</p>
  </div>
  <div class="page">
    <p>Group Editors</p>
    <p>Enable a group of users to view and edit a same document simultaneously from geographically dispersed sites connected by communication networks</p>
  </div>
  <div class="page">
    <p>Wiki</p>
    <p>A wiki is such a website  every visitor is allowed and able to add new pages to it, remove existing pages, or otherwise edit and change the content of existing pages</p>
    <p>Wiki is becoming more and more popular, as a novel and convenient collaboration medium</p>
    <p>Samples: Wikipedia, WikiNews, WikiTravel, etc</p>
    <p>Adapting existing single-user wiki page editors to fullreplicated group editors.</p>
  </div>
  <div class="page">
    <p>Realtime group editing in Wiki: The Problems  The collaborative environments in wikis are typically</p>
    <p>large-scale and dynamic collaboration environments.</p>
    <p>Large number of participants</p>
    <p>Highly dynamic</p>
    <p>Unreliable</p>
  </div>
  <div class="page">
    <p>Existing solutions : Vector timestamp</p>
    <p>Traditional vector logical clock timestamp</p>
    <p>Each item corresponds to a collaboration participant, and records the number of operations generated by that participant that are causally preceding O.</p>
    <p>causal relationship between any two operations can be easily determined</p>
    <p>Size of vector logical clock linearly depends on the number of participants</p>
  </div>
  <div class="page">
    <p>Existing solutions : Dynamic timestamp</p>
    <p>Using associative vectors indexed by participant identifier, thus allowing the system to dynamically add new timestamp items or discard old timestamp items during the collaboration session.</p>
    <p>Creating vector items just for those participants who have written.</p>
    <p>if some participants midway leave the collaboration session, watching their corresponding timestamp items and removing them once they have become insignificant.</p>
  </div>
  <div class="page">
    <p>Existing solutions : Vector compression</p>
    <p>Related Works  Sun-Cai approach, NICE approach</p>
    <p>Single-point failure. Have an adverse impact on conflict handle.</p>
    <p>SOCK4, TIBOT  Cooperating sites must be well-connected. The communication channels</p>
    <p>among them must be stable and reliable.  Also have adverse impacts on conflict handle.</p>
  </div>
  <div class="page">
    <p>Agenda</p>
    <p>Introduction  Direct Causal Vector Timestamp (DCV)  Causality Detection Algorithms  Discussion  Future Work</p>
  </div>
  <div class="page">
    <p>Causal Vector</p>
    <p>Causal Relation (-&gt;)  Given two operations Oa and Ob, Oa-&gt;Ob iff:</p>
    <p>Oa and Ob are generated at a same site, and the generation of Oa happened before Ob</p>
    <p>Oa and Ob are generated at different sites i and j, and the execution of Oa at site j happened before the generation of Ob</p>
    <p>There exists an operation Ox, such that Oa-&gt;Ox and Ox-&gt;Ob</p>
  </div>
  <div class="page">
    <p>Causality Preservation</p>
    <p>o11, o21 and o31 are concurrent with each other.</p>
    <p>o12 is causally dependent on three operations o11, o21 and o31.</p>
    <p>o22 is causally dependent on four operations o11, o21, o31 and o12.</p>
    <p>o32 is only causally dependent on o31</p>
  </div>
  <div class="page">
    <p>Direct Causal Relation</p>
    <p>Direct Causal Relation ()  Given two operations Oa and Ob, Oa  Ob iff:</p>
    <p>Oa -&gt; Ob  And there exists no operation Ox satisfying Oa-&gt;Ox and Ox-&gt;Ob</p>
  </div>
  <div class="page">
    <p>Causality Preservation</p>
    <p>o12 is direct causally dependent on three operations o11, o21 and o31.</p>
    <p>o22 is direct causally dependent on o12.</p>
    <p>o32 is direct causally dependent on o31</p>
  </div>
  <div class="page">
    <p>Direct Causal Vector(DCV)</p>
    <p>Direct Causal Vector (DCV)  Given an operation O  {O1, O2, , Ok}O  O1(s1, n1), ,</p>
    <p>Ok(sk, nk), DCV(O)=[(s1, n1), (s2, n2), , (sk, nk)]</p>
    <p>The direct causal vector of o11, o21, o31, o12, o22 and o32 is [ ], [ ], [ ], [(1, 1), (2, 1), (3, 1)], [(1, 2)] and [(1, 3)] respectively.</p>
    <p>Given two operations, their direct causal relationship can be determined directly from their direct causal vectors  Give two operations Oa and Ob, Oa  Ob iff there exists an item</p>
    <p>for Oa in DCV(Ob)</p>
  </div>
  <div class="page">
    <p>Agenda</p>
    <p>Introduction  Direct Causal Vector Timestamp (DCV)  Causality Detection Algorithms  Discussion  Future Work</p>
  </div>
  <div class="page">
    <p>Agenda</p>
    <p>Introduction  Direct Causal Vector Timestamp (DCV)  Causality Detection Algorithms</p>
    <p>Causality Preservation  Concurrent Separation  Causality Cache</p>
    <p>Discussion  Future Work</p>
  </div>
  <div class="page">
    <p>Agenda</p>
    <p>Introduction  Direct Causal Vector Timestamp (DCV)  Causality Detection Algorithms</p>
    <p>Causality Preservation  Concurrent Separation  Causality Cache</p>
    <p>Discussion  Future Work</p>
  </div>
  <div class="page">
    <p>Causality Preservation</p>
    <p>Problem Description:  Given an unexecuted remote operation, how to determine</p>
    <p>whether all the operations causally preceding it have already been executed?</p>
    <p>Solution:  Given a remote operation O, suppose all the operations</p>
    <p>executed before respect their causal order. O is causally ready iff all the operations causally precede o directly have already been executed.</p>
  </div>
  <div class="page">
    <p>Agenda</p>
    <p>Introduction  Direct Causal Vector Timestamp (DCV)  Causality Detection Algorithms</p>
    <p>Causality Preservation  Concurrent Separation  Causality Cache</p>
    <p>Discussion  Future Work</p>
  </div>
  <div class="page">
    <p>Concurrent Separation</p>
    <p>Problem Description:  Given an unexecuted remote operation Or that is causally ready,</p>
    <p>how to separate all the history operations that are concurrent to it from the operation history?</p>
    <p>Solution:  Suppose there are two operation Oa and Ob in history, Oa-&gt;Ob, it</p>
    <p>will not check Oa until Ob is proved to be concurrent with Or  do not check a history operation until all the history operations that</p>
    <p>are causally dependent on it have been proved to be concurrent with Or</p>
    <p>When checking a operation Oh, Oh is concurrent to Or iff not OhOr  There is no operation Ox, which satisfy Oh-&gt;Ox-&gt;Or</p>
  </div>
  <div class="page">
    <p>Concurrent Separation</p>
    <p>Suppose a remote operation O41 is received at site 3 shortly after the execution of o22 on that site. DCV(O41)= [(1, 1), (3, 2)] .  O32 and O22 is checked first,</p>
    <p>because there is no other history operation causally depends on them. O22 is proved to be concurrent with O41.</p>
  </div>
  <div class="page">
    <p>Concurrent Separation</p>
    <p>Suppose a remote operation O41 is received at site 3 shortly after the execution of o22 on that site. DCV(O41)= [(1, 1), (3, 2)] .  O32 and O22 is checked first,</p>
    <p>because there is no other history operation causally depends on them. O22 is proved to be concurrent with O41.</p>
    <p>O12 is checked in the second round, it is proved to be concurrent with O41.</p>
  </div>
  <div class="page">
    <p>Concurrent Separation</p>
    <p>Suppose a remote operation O41 is received at site 3 shortly after the execution of o22 on that site. DCV(O41)= [(1, 1), (3, 2)] .  O32 and O22 is checked first, because</p>
    <p>there is no other history operation causally depends on them. O22 is proved to be concurrent with O41.</p>
    <p>O12 is checked in the second round, it is proved to be concurrent with O41.</p>
    <p>Now, O11 and O21 is ready to be checked, and O21 can be determined concurrent with O41</p>
  </div>
  <div class="page">
    <p>Concurrent Separation</p>
    <p>Suppose a remote operation O41 is received at site 3 shortly after the execution of o22 on that site. DCV(O41)= [(1, 1), (3, 2)] .</p>
  </div>
  <div class="page">
    <p>Agenda</p>
    <p>Introduction  Direct Causal Vector Timestamp (DCV)  Causality Detection Algorithms</p>
    <p>Causality Preservation  Concurrent Separation  Causality Cache</p>
    <p>Discussion  Future Work</p>
  </div>
  <div class="page">
    <p>Causality Cache</p>
    <p>Problem Description:  How to determine the causal relationship between two arbitrary</p>
    <p>operations in the operation history?</p>
    <p>Solution:  Every time before executing a remote operation Or, all the earlier</p>
    <p>executed operations that are concurrent with it are separated out in set SCr in advance. Cache this result for future use.</p>
    <p>If there are more than one operations in SCr that are generated at a same cooperating site, just keep the earliest generated one.</p>
  </div>
  <div class="page">
    <p>Causality Cache</p>
    <p>Suppose a remote operation O41 is received at site 3 shortly after the execution of o22 on that site. DCV(O41)= [(1, 1), (3, 2)] .  There are three operations</p>
    <p>concurrent with O41</p>
    <p>O12, O21, O22</p>
  </div>
  <div class="page">
    <p>Causality Cache</p>
    <p>Suppose a remote operation O41 is received at site 3 shortly after the execution of o22 on that site. DCV(O41)= [(1, 1), (3, 2)] .  Two Groups based on their site</p>
    <p>Site-1 : O12</p>
    <p>Site-2 : O21, O22</p>
  </div>
  <div class="page">
    <p>Causality Cache</p>
    <p>Suppose a remote operation O41 is received at site 3 shortly after the execution of o22 on that site. DCV(O41)= [(1, 1), (3, 2)] .  Catch={O12, O21}</p>
    <p>Site-1 : O12</p>
    <p>Site-2 : O21, O22</p>
    <p>O21 Catch</p>
    <p>=&gt; O21||O41 =&gt; O22||O41</p>
  </div>
  <div class="page">
    <p>Agenda</p>
    <p>Introduction  Direct Causal Vector Timestamp (DCV)  Causality Detection Algorithms  Discussion  Future Work</p>
  </div>
  <div class="page">
    <p>Disscussion</p>
    <p>After a person leave the collaboration session, the size of direct causal vector timestamp of later generated operations will automatically shrink.</p>
  </div>
  <div class="page">
    <p>Disscussion</p>
    <p>Feature of DCV approach  The size of direct causal vector timestamp of an operation O</p>
    <p>approximates the number of participants active at editing the shared object recently before the generation of operation O.  It is not pre-allocated for each potential participants an item in the direct</p>
    <p>causal vector timestamp.  After a person leave the collaboration session, the size of direct causal</p>
    <p>vector timestamp of later generated operations will automatically shrink.</p>
    <p>The time complexity, storage complexity of our algorithms also just linearly depends on the number of collaboration participants that are currently active at editing.</p>
    <p>DCV approach is much more scalable. It is not rely on a stable network. And it has no constraint on users collaboration mode.</p>
  </div>
  <div class="page">
    <p>Agenda</p>
    <p>Introduction  Direct Causal Vector Timestamp (DCV)  Causality Detection Algorithms  Discussion  Future Work</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Compression of Direct Causal Vector in highly active largescale collaboration environments</p>
    <p>Experiments of the effects</p>
  </div>
  <div class="page">
    <p>Thanks!</p>
  </div>
</Presentation>
