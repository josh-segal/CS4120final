<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Effects for Funargs</p>
    <p>Jeremy G. Siek1 M. Vitousek1 J. Turner1</p>
    <p>HOPE 2012</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 1 / 33</p>
  </div>
  <div class="page">
    <p>Chapels Goals: Productivity and Parallelism</p>
    <p>ZPL Java/C# C++</p>
    <p>Chapel</p>
    <p>arrays data-parallelism</p>
    <p>stack allocation templates</p>
    <p>value and reference objects</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 2 / 33</p>
  </div>
  <div class="page">
    <p>Higher-order Functions and Lexical Scope</p>
    <p>var my state = read(string); var addresses in my state = new Vector(Address);</p>
    <p>copy if(addresses, back inserter(addresses in my state), fun (a:Address) {</p>
    <p>return a.state == my state; });</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 3 / 33</p>
  </div>
  <div class="page">
    <p>Lexical Scope and Stack Allocation, Danger!</p>
    <p>proc deriv(f: floatfloat, d:float) { return fun(x:float) {</p>
    <p>return f(x + d)  f(x  d); };</p>
    <p>}</p>
    <p>proc square(x:float) { return x  x; }</p>
    <p>var line = deriv(square, 0.01); // Kaboom! writeln(line(5.0));</p>
    <p>The function of FUNCTION in LISP or why the FUNARG problem should be called the environment problem. J. Moses, SIGSAM Bull., 1970.</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 4 / 33</p>
  </div>
  <div class="page">
    <p>Representatives of Prior Work</p>
    <p>Research Industry</p>
    <p>Effects: Talpin &amp; Jouvelot GCd languages (H) ML  Regions: Toft &amp; Talpin Blocks in Objective C (V, H) Cyclone: Grossman et al. Lambda in C++ (V, R) RT Java: Boyapati et al. Inner Classes in Java (V)</p>
    <p>H: heap V: value R: reference</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 5 / 33</p>
  </div>
  <div class="page">
    <p>Design Considerations</p>
    <p>Efficient</p>
    <p>Safe</p>
    <p>Simple (Programmer)Simple (Compiler)</p>
    <p>Expressive</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 6 / 33</p>
  </div>
  <div class="page">
    <p>Capture by reference or by value</p>
    <p>By Reference By Value</p>
    <p>+Always Fast Sometimes slow +Downard funargs ok +Downward funargs ok No upward funargs +Upward funargs ok</p>
    <p>No mutation</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 7 / 33</p>
  </div>
  <div class="page">
    <p>Our Approach</p>
    <p>I Here we show by-reference as the default. I The default could also be by-value or neither.</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 8 / 33</p>
  </div>
  <div class="page">
    <p>Example 1 Revisited</p>
    <p>I No annotations</p>
    <p>I Capture by reference is the default</p>
    <p>var my state = read(string); var addresses in my state = new Vector(Address);</p>
    <p>copy if(addresses, back inserter(addresses in my state), fun (a:Address) {</p>
    <p>return a.state == my state; });</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 9 / 33</p>
  </div>
  <div class="page">
    <p>Example 2 with capture by-value</p>
    <p>I Annotate capture by-value</p>
    <p>I Upward funarg is ok</p>
    <p>proc deriv(f: floatfloat, d:float) { return fun(x:float) f, d {</p>
    <p>return f(x + d)  f(x  d); };</p>
    <p>}</p>
    <p>proc square(x:float) { return x  x; }</p>
    <p>var times two = deriv(square, 0.5); writeln(times two(5.0)); &gt; 10.0</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 10 / 33</p>
  </div>
  <div class="page">
    <p>Example 2 with capture by-reference</p>
    <p>I Type system detects escaping references</p>
    <p>proc deriv(f: floatfloat, d:float) { return fun(x:float) {</p>
    <p>return f(x + d)  f(x  d); };</p>
    <p>} Error: f and d escape from deriv</p>
    <p>proc square(x:float) { return x  x; }</p>
    <p>var times two = deriv(square, 0.5); writeln(times two(5.0));</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 11 / 33</p>
  </div>
  <div class="page">
    <p>Inferred Effect Polymorphism</p>
    <p>proc deriv(f: floatfloat, d:float) { return fun(x:float) f,d { return f(x + d)  f(x  d); }; } // deriv : . (float  float, float)  float  float var pi = 3.14159;</p>
    <p>proc times pi(x:float) { return pi  x; } // float pi  float</p>
    <p>var almost pi = deriv(times pi, 0.5); // float pi  float</p>
    <p>writeln(almost pi(1.0)); &gt; 3.14158999999</p>
    <p>Region-based memory management in Cyclone. Grossman et al. PLDI 2002</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 12 / 33</p>
  </div>
  <div class="page">
    <p>The Core Language</p>
    <p>ground effects  ::= {x} |  effects  ::=  |  |  types T ::= int | T  T | . T expressions e ::= n | x | f | e&lt;&gt; abstractions f ::= fun(x:T )</p>
    <p>T y =e{s} | . f</p>
    <p>statements s ::= x=e(e); s | ret e(e) | ret e</p>
    <p>I Function parameters (x ) are bound to stack locations.</p>
    <p>I Function-local variables (y ) reside in the function.</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 13 / 33</p>
  </div>
  <div class="page">
    <p>Evaluation of Expressions</p>
    <p>stack locations `  N ground effects  ::= . . . | {`T} expressions e ::= . . . | `T values v ::= n | fun(x:T )T y = v{s} stack o values  ::= [] | v ::</p>
    <p>JeK = v</p>
    <p>J`T K = n1` where n = || Jfun(x:T1)</p>
    <p>T2</p>
    <p>y =e{s}K = fun(x:T1)  T2</p>
    <p>y =v{s} if JeK = v J. f K = . f Je&lt;&gt;K = J[:=]eK if JeK = . e</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 14 / 33</p>
  </div>
  <div class="page">
    <p>Abstract Machine Transitions</p>
    <p>Stacks  ::= [] | (x:T,s,n) ::  States  ::= s,,,n</p>
    <p>(x=e1(e2); s1),,,n (Call) [y:=`T1,z:=v]s2, (x:T2,s1,n) :: , Je2K :: , 1</p>
    <p>where Je1K = fun(y:T1)  T2 z=v{s2} and ` = ||</p>
    <p>ret e1(e2),,,n (TailCall) [y:=`T1 ]s,, Je2K :: drop(n,), 1</p>
    <p>where Je1K = fun(y:T1)  T2 {s} and ` = ||n</p>
    <p>ret e, (x:T,s,n2) :: ,,n1 (Return) [x:=`T ]s,, JeK :: drop(n1,),n2 + 1</p>
    <p>where ` = ||n1 Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 15 / 33</p>
  </div>
  <div class="page">
    <p>Type System, Expressions</p>
    <p>::=  | ,x:T | ,x:ref(T ) | ,</p>
    <p>;  ` e : T</p>
    <p>x:ref(T )   {x}</p>
    <p>;  ` x : T x:T</p>
    <p>;  ` x : T {`T}</p>
    <p>;  ` `T : T</p>
    <p>; ` T1 2 T2 ; 1 ` e : T</p>
    <p>,y : T,x:ref(T1); 2 {x};{x} ` s : T2 ; 1 ` fun(x:T1)</p>
    <p>2 T2 y = e{s} : T1</p>
    <p>2 T2</p>
    <p>,; ` f : T ;  ` . f : .T</p>
    <p>; 1 ` e : .T ; ` 2 ; 1 ` e&lt;2&gt; : [:=2]T</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 16 / 33</p>
  </div>
  <div class="page">
    <p>Type System, Statements</p>
    <p>; 1 ` e1 : T1 3 T2 ; 1 ` e2 : T1</p>
    <p>, x :ref(T2); 1 {x}; 2 {x} ` s : T3 3  1 ; 1; 2 ` x=e1(e2); s : T3</p>
    <p>; 1 ` e1 : T1 3 T2 ; 1 ` e2 : T1</p>
    <p>3  1 2 FV(T2) 2 =  ; 1; 2 ` ret e1(e2) : T2</p>
    <p>; 1 ` e : T FV(T ) 2 =  ; 1; 2 ` ret e : T</p>
    <p>Lemma (Locals not in Return Type)</p>
    <p>If ; 1; 2 ` s : T , then FV(T ) 2 = . Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 17 / 33</p>
  </div>
  <div class="page">
    <p>Type System, Abstract Machine</p>
    <p>`  : T</p>
    <p>; 1; 2 ` s : T1 ;  ` 1 ; take(n, ) ` 2 ; drop(n, ) ` 1 2</p>
    <p>`  :  drop(n, ) `  : T1  T2 ` s,,, n : T2</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 18 / 33</p>
  </div>
  <div class="page">
    <p>Type System, Abstract Machine</p>
    <p>`  :</p>
    <p>`  :  ; ` v : T `  :  ` v ::  : T ::</p>
    <p>`  : T  T</p>
    <p>`  : T  T</p>
    <p>;  ` 1 ; take(n, ) ` 2 ; drop(n, ) ` 1 2</p>
    <p>, x :T1; 1 {x}; 2 {x} ` s : T2  ` T1 drop(n, ) `  : T2  T3</p>
    <p>` (x :T1, s, n) ::  : T1  T3</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 19 / 33</p>
  </div>
  <div class="page">
    <p>Evaluation is Safe</p>
    <p>Lemma (Evaluation Safety)</p>
    <p>If ;  ` e : T , ;  ` , and `  : , then ; ` JeK : T .</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 20 / 33</p>
  </div>
  <div class="page">
    <p>The Machine is Safe</p>
    <p>Theorem If `  : T , then either  is a final state or    and `  : T .</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 21 / 33</p>
  </div>
  <div class="page">
    <p>Abstract Syntax of</p>
    <p>Featherweight Functional Chapel (F2C)</p>
    <p>variables x, y, z  Var integers n  Z effect variables   EVar effects  ::=  | {x, . . .} |  types T ::= int | T  T | T  T | . T expressions e ::= n | x | fun&lt;&gt;(x :T )y{s} statements s ::= x=e(e); s | ret e | ret e(e)</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 22 / 33</p>
  </div>
  <div class="page">
    <p>Effect Variable is the default for Function Types</p>
    <p>` Int Int,</p>
    <p>` T1 T 1; 1 ` T2 T 2; 2  fresh</p>
    <p>` T1  T2 T 1  T 2; (12)</p>
    <p>` T1 T 1; 1 ` T2 T 2; 2</p>
    <p>` T1  T2 T 1</p>
    <p>T 2; 1 2</p>
    <p>` T T ;  `. T . T ;</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 23 / 33</p>
  </div>
  <div class="page">
    <p>Type System and Elaboration, Expressions</p>
    <p>` e e : T !</p>
    <p>` n n : T !</p>
    <p>x :ref(T )    ` x x : T !{x}</p>
    <p>x :T    ` x x : T !</p>
    <p>` T1 T 1; 2  ` y y : T ; 3 12, x :ref(T</p>
    <p>1), y :T ; x ` s s : T2 ! 1 2 = 1 {x}</p>
    <p>` fun&lt;1&gt;(x :T1)y{s} : (12. T 1 2 T2) ! 3</p>
    <p>12. fun(x:T  1) 2 T2</p>
    <p>y =y{s}</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 24 / 33</p>
  </div>
  <div class="page">
    <p>Type System and Elaboration, Statements</p>
    <p>; z ` s s : T !</p>
    <p>` e1 e1 : . T1 4 T2 ! 1  ` e2 e2 : T3 ! 2</p>
    <p>match(T3, [:=u]T1) = {u 7 } , x :ref(T2); x z ` s s : T3 ! 3</p>
    <p>; z ` x=e1(e2); s x=e1&lt;&gt;(e</p>
    <p>2); s</p>
    <p>: T3 ! [:=]4  3</p>
    <p>i=1 i</p>
    <p>` e e : T !  FV(T )  z =  ; z ` ret e ret e : T !</p>
    <p>` e1 e1 : . T1 3 T2 ! 1  ` e2 e2 : T3 ! 2</p>
    <p>match(T3, [:=u]T1) = {u 7 } FV(T2)  z =  ; z ` ret e1(e2) ret e1&lt;&gt;(e2) : T2 ! [:=]3 1 2</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 25 / 33</p>
  </div>
  <div class="page">
    <p>Effect Argument Inference, Types</p>
    <p>match(Int,Int, ) =</p>
    <p>match(T1 1 T2, T3</p>
    <p>2 T4, ) = 3 where 1 = match(T3, T1, )</p>
    <p>2 = match(1,2, 1)</p>
    <p>3 = match(T2, T4, 2)</p>
    <p>match(. T1,. T2, ) = match(T1, T2, )</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 26 / 33</p>
  </div>
  <div class="page">
    <p>Effect Argument Inference, Effects</p>
    <p>match(, u, ) = [u:=]</p>
    <p>if u / dom() match(u,, ) = [u:=]</p>
    <p>if u / dom() match(1,2, ) =</p>
    <p>if ` (1)  (2)</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 27 / 33</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>I Effects are sets of variables.</p>
    <p>I Type system prevents escaping references to the stack.</p>
    <p>I Programmer controls capture by reference or by value.</p>
    <p>Questions?</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 28 / 33</p>
  </div>
  <div class="page">
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 29 / 33</p>
  </div>
  <div class="page">
    <p>Effect Subset</p>
    <p>`</p>
    <p>`   `</p>
    <p>` 1  3 ` 2  3 ` 1 2  3</p>
    <p>`   1 or `   2 `   1 2</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 30 / 33</p>
  </div>
  <div class="page">
    <p>Effect Union</p>
    <p>d</p>
    <p>d =  d =</p>
    <p>(1 2) d3 = (1 d3) d (2 d3)  d (1 2) = ( d1) d ( d2)</p>
    <p>1 d2 =</p>
    <p>{ 1 if 1 = 2</p>
    <p>1 2 otherwise</p>
    <p>[:=3](1 d2) = [:=3]1 d [:=3]2</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 31 / 33</p>
  </div>
  <div class="page">
    <p>Effect Intersection</p>
    <p>(1 2) 3 = (1 3) d (2 3)   (2 3) = ( 2) d ( 3)</p>
    <p>1 2 =</p>
    <p>{ 1 if 1 = 2</p>
    <p>if 1 6= 2  =   =</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 32 / 33</p>
  </div>
  <div class="page">
    <p>Effect Difference</p>
    <p>(1 2) 3 = (1 3) d (2 3)   (2 3) = ( 2) 3</p>
    <p>1 2 =</p>
    <p>{  if 1 = 2 1 otherwise</p>
    <p>=   =</p>
    <p>Jeremy G. Siek, M. Vitousek, J. Turner Effects for Funargs, HOPE 2012 33 / 33</p>
  </div>
</Presentation>
