<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>The benefits and costs of writing a POSIX kernel in a high-level language</p>
    <p>Cody Cutler, M. Frans Kaashoek, Robert T. Morris</p>
    <p>MIT CSAIL</p>
  </div>
  <div class="page">
    <p>Should we use high-level languages to build OS kernels?</p>
  </div>
  <div class="page">
    <p>HLL Benefits</p>
    <p>Easier to program Simpler concurrency with GC Prevents classes of kernel bugs</p>
  </div>
  <div class="page">
    <p>Kernel memory safety matters</p>
    <p>Inspected Linux kernel execute code CVEs for 2017</p>
    <p>HLL would have prevented code execution</p>
  </div>
  <div class="page">
    <p>Kernel memory safety matters</p>
    <p>Inspected Linux kernel execute code CVEs for 2017</p>
    <p>HLL would have prevented code execution</p>
  </div>
  <div class="page">
    <p>HLL downside: safety costs performance</p>
    <p>Bounds, cast, nil-pointer checks Reflection Garbage collection</p>
  </div>
  <div class="page">
    <p>Goal: measure HLL impact</p>
    <p>Pros: Reduction of bugs Simpler code</p>
    <p>Cons: HLL safety tax GC CPU and memory overhead GC pause times</p>
  </div>
  <div class="page">
    <p>Methodology</p>
    <p>Build new HLL kernel, compare with Linux</p>
    <p>Isolate HLL impact:</p>
    <p>Same apps, POSIX interface, and monolithic organization</p>
  </div>
  <div class="page">
    <p>Previous work</p>
    <p>Taos(ASPLOS87), Spin(SOSP95), Singularity(SOSP07), Tock(SOSP17), J-kernel(ATC98), KaffeOS(ATC00), House(ICFP05),...</p>
    <p>Explore new ideas Different architectures</p>
    <p>Several studies of HLL versus C for user programs Kernels different from user programs</p>
    <p>None measure HLL impact in a monolithic POSIX kernel</p>
  </div>
  <div class="page">
    <p>Previous work</p>
    <p>Taos(ASPLOS87), Spin(SOSP95), Singularity(SOSP07), Tock(SOSP17), J-kernel(ATC98), KaffeOS(ATC00), House(ICFP05),...</p>
    <p>Explore new ideas Different architectures</p>
    <p>Several studies of HLL versus C for user programs Kernels different from user programs</p>
    <p>None measure HLL impact in a monolithic POSIX kernel</p>
  </div>
  <div class="page">
    <p>Contributions</p>
    <p>BISCUIT, new x86-64 Go kernel Runs unmodified Linux applications with good performance</p>
    <p>Measurements of HLL costs for NGINX, Redis, and CMailbench</p>
    <p>Description of qualitative ways HLL helped</p>
    <p>New scheme to deal with heap exhaustion</p>
  </div>
  <div class="page">
    <p>Which HLL?</p>
    <p>Go is a good choice: Easy to call asm Compiled to machine code w/good compiler Easy concurrency Easy static analysis GC</p>
  </div>
  <div class="page">
    <p>Gos GC</p>
    <p>Concurrent mark and sweep</p>
    <p>Stop-the-world pauses of 10s of  s</p>
  </div>
  <div class="page">
    <p>BISCUIT overview</p>
  </div>
  <div class="page">
    <p>Features</p>
    <p>Multicore Threads Journaled FS (7k LOC) Virtual memory (2k LOC) TCP/IP stack (5k LOC) Drivers: AHCI and Intel 10G NIC (3k LOC)</p>
  </div>
  <div class="page">
    <p>No fundamental challenges due to HLL</p>
    <p>But many implementation puzzles Interrupts Kernel threads are lightweight Runtime on bare-metal ...</p>
    <p>Surprising puzzle: heap exhaustion</p>
  </div>
  <div class="page">
    <p>No fundamental challenges due to HLL</p>
    <p>But many implementation puzzles Interrupts Kernel threads are lightweight Runtime on bare-metal ...</p>
    <p>Surprising puzzle: heap exhaustion</p>
  </div>
  <div class="page">
    <p>Puzzle: Heap exhaustion</p>
  </div>
  <div class="page">
    <p>Puzzle: Heap exhaustion</p>
  </div>
  <div class="page">
    <p>Puzzle: Heap exhaustion</p>
  </div>
  <div class="page">
    <p>Puzzle: Heap exhaustion</p>
  </div>
  <div class="page">
    <p>Puzzle: Heap exhaustion</p>
    <p>Cant allocate heap memory = nothing works All kernels face this problem</p>
  </div>
  <div class="page">
    <p>How to recover?</p>
    <p>Strawman 1: Wait for memory in allocator?</p>
    <p>May deadlock!</p>
    <p>Strawman 2: Check/handle allocation failure, like C kernels?</p>
    <p>Difficult to get right Cant! Go doesnt expose failed allocations and implicitly allocates</p>
    <p>Both cause problems for Linux; see too small to fail rule</p>
  </div>
  <div class="page">
    <p>How to recover?</p>
    <p>Strawman 1: Wait for memory in allocator?</p>
    <p>May deadlock!</p>
    <p>Strawman 2: Check/handle allocation failure, like C kernels?</p>
    <p>Difficult to get right Cant! Go doesnt expose failed allocations and implicitly allocates</p>
    <p>Both cause problems for Linux; see too small to fail rule</p>
  </div>
  <div class="page">
    <p>How to recover?</p>
    <p>Strawman 1: Wait for memory in allocator?</p>
    <p>May deadlock!</p>
    <p>Strawman 2: Check/handle allocation failure, like C kernels?</p>
    <p>Difficult to get right Cant! Go doesnt expose failed allocations and implicitly allocates</p>
    <p>Both cause problems for Linux; see too small to fail rule</p>
  </div>
  <div class="page">
    <p>How to recover?</p>
    <p>Strawman 1: Wait for memory in allocator?</p>
    <p>May deadlock!</p>
    <p>Strawman 2: Check/handle allocation failure, like C kernels?</p>
    <p>Difficult to get right</p>
    <p>Cant! Go doesnt expose failed allocations and implicitly allocates</p>
    <p>Both cause problems for Linux; see too small to fail rule</p>
  </div>
  <div class="page">
    <p>How to recover?</p>
    <p>Strawman 1: Wait for memory in allocator?</p>
    <p>May deadlock!</p>
    <p>Strawman 2: Check/handle allocation failure, like C kernels?</p>
    <p>Difficult to get right Cant! Go doesnt expose failed allocations and implicitly allocates</p>
    <p>Both cause problems for Linux; see too small to fail rule</p>
  </div>
  <div class="page">
    <p>BISCUIT solution: reserve memory</p>
    <p>To execute syscall...</p>
  </div>
  <div class="page">
    <p>BISCUIT solution: reserve memory</p>
    <p>To execute syscall...</p>
  </div>
  <div class="page">
    <p>BISCUIT solution: reserve memory</p>
    <p>To execute syscall...</p>
  </div>
  <div class="page">
    <p>BISCUIT solution: reserve memory</p>
    <p>To execute syscall...</p>
  </div>
  <div class="page">
    <p>BISCUIT solution: reserve memory</p>
    <p>To execute syscall...</p>
  </div>
  <div class="page">
    <p>BISCUIT solution: reserve memory</p>
    <p>To execute syscall...</p>
    <p>No checks, no error handling code, no deadlock</p>
  </div>
  <div class="page">
    <p>Reservations</p>
    <p>HLL easy to analyze</p>
    <p>Tool computes reservation via escape analysis Using Gos static analysis packages</p>
    <p>three days of expert effort to apply tool</p>
  </div>
  <div class="page">
    <p>Building BISCUIT was similar to other kernels</p>
    <p>BISCUIT adopted many Linux optimizations: large pages for kernel text per-CPU NIC transmit queues RCU-like directory cache concurrent FS transactions pad structs to remove false sharing</p>
    <p>Good OS performance more about optimizations, less about HLL</p>
  </div>
  <div class="page">
    <p>Building BISCUIT was similar to other kernels</p>
    <p>BISCUIT adopted many Linux optimizations: large pages for kernel text per-CPU NIC transmit queues RCU-like directory cache concurrent FS transactions pad structs to remove false sharing</p>
    <p>Good OS performance more about optimizations, less about HLL</p>
  </div>
  <div class="page">
    <p>Eval questions</p>
    <p>Should we use high-level languages to build OS kernels?</p>
    <p>More experiments in paper</p>
  </div>
  <div class="page">
    <p>Simpler code with:</p>
    <p>GCed allocation defer</p>
    <p>multi-valued return closures maps</p>
  </div>
  <div class="page">
    <p>HLL example benefits</p>
    <p>Example 1: Memory safety</p>
    <p>Example 2: Simpler concurrency</p>
  </div>
  <div class="page">
    <p>Inspected fixes for all publicly-available execute code CVEs in Linux kernel for 2017</p>
    <p>Category # Outcome in Go</p>
    <p>11 unknown logic 14 same use-after-free/double-free 8 disappear due to GC out-of-bounds 32 panic or disappear due to GC</p>
    <p>panic likely better than malicious code execution</p>
  </div>
  <div class="page">
    <p>Generally, concurrency with GC simpler</p>
    <p>Particularly, GC greatly simplifies read-lock-free data structures</p>
    <p>Challenge: In C, how to determine when last reader is done?</p>
    <p>Main purpose of read-copy update (RCU) (PDCS98) Linux uses RCU, but its not easy</p>
    <p>Code to start and end RCU sections No sleeping/scheduling in RCU sections ...</p>
    <p>In Go, no extra code  GC takes care of it</p>
  </div>
  <div class="page">
    <p>Experimental setup</p>
    <p>Hardware: 4 core 2.8Ghz Xeon-X3460 16 GB RAM Hyperthreads disabled</p>
    <p>Eval application:</p>
    <p>NGINX (1.11.5)  webserver Redis (3.0.5)  key/value store CMailbench  mail-server benchmark</p>
  </div>
  <div class="page">
    <p>Applications are kernel intensive</p>
    <p>No idle time</p>
    <p>In-memory FS</p>
    <p>Run for a minute</p>
  </div>
  <div class="page">
    <p>Debian 9.4, Linux 4.9.82</p>
    <p>Disabled expensive features:</p>
    <p>page-table isolation retpoline kernel address space layout randomization transparent huge-pages ...</p>
  </div>
  <div class="page">
    <p>BISCUIT ops/s Linux ops/s Ratio</p>
    <p>CMailbench (mem) 15,862 17,034 1.07 NGINX 88,592 94,492 1.07 Redis 711,792 775,317 1.09</p>
  </div>
  <div class="page">
    <p>BISCUIT ops/s Linux ops/s Ratio</p>
    <p>CMailbench (mem) 15,862 17,034 1.07 NGINX 88,592 94,492 1.07 Redis 711,792 775,317 1.09</p>
  </div>
  <div class="page">
    <p>HLL cost unclear from comparison</p>
    <p>May understate Linux performance due to features: NUMA awareness Optimizations for large number of cores (&gt;4) ...</p>
    <p>Focus on HLL costs:</p>
    <p>Measure CPU cycles BISCUIT pays for HLL tax Compare code paths that differ only by language</p>
  </div>
  <div class="page">
    <p>Measure HLL tax: GC cycles Prologue cycles Write barrier cycles Safety cycles</p>
  </div>
  <div class="page">
    <p>GC GCs Prologue Write barrier Safety cycles cycles cycles cycles</p>
    <p>CMailbench 3% 42 6% &lt; 1% 3% NGINX 2% 32 6% &lt; 1% 2% Redis 1% 30 4% &lt; 1% 2%</p>
  </div>
  <div class="page">
    <p>GC GCs Prologue Write barrier Safety cycles cycles cycles cycles</p>
    <p>CMailbench 3% 42 6% &lt; 1% 3% NGINX 2% 32 6% &lt; 1% 2% Redis 1% 30 4% &lt; 1% 2%</p>
  </div>
  <div class="page">
    <p>GC GCs Prologue Write barrier Safety cycles cycles cycles cycles</p>
    <p>CMailbench 3% 42 6% &lt; 1% 3% NGINX 2% 32 6% &lt; 1% 2% Redis 1% 30 4% &lt; 1% 2%</p>
  </div>
  <div class="page">
    <p>GC GCs Prologue Write barrier Safety cycles cycles cycles cycles</p>
    <p>CMailbench 3% 42 6% &lt; 1% 3% NGINX 2% 32 6% &lt; 1% 2% Redis 1% 30 4% &lt; 1% 2%</p>
  </div>
  <div class="page">
    <p>GC GCs Prologue Write barrier Safety cycles cycles cycles cycles</p>
    <p>CMailbench 3% 42 6% &lt; 1% 3% NGINX 2% 32 6% &lt; 1% 2% Redis 1% 30 4% &lt; 1% 2%</p>
    <p>Benchmarks allocate kernel heap rapidly but have little persistent kernel heap data</p>
    <p>Cycles used by GC increase with size of live kernel heap Dedicate 2 or 3 memory  low GC cycles</p>
  </div>
  <div class="page">
    <p>Make code paths same in BISCUIT and Linux</p>
    <p>Two code paths in paper pipe ping-pong (systems calls, context switching) page-fault handler (exceptions, VM)</p>
    <p>Focus on pipe ping-pong: LOC: 1.2k Go, 1.8k C No allocation; no GC Top-10 most expensive instructions match</p>
  </div>
  <div class="page">
    <p>C Go (ops/s) (ops/s) Ratio</p>
    <p>Prologue/safety-checks  16% more instructions</p>
  </div>
  <div class="page">
    <p>Should one use HLL for a new kernel?</p>
    <p>The HLL worked well for kernel development</p>
    <p>Performance is paramount  use C (up to 15%)</p>
    <p>Minimize memory use  use C ( mem. budget,  GC cost)</p>
    <p>Safety is paramount  use HLL (40 CVEs stopped)</p>
    <p>Performance merely important  use HLL (pay 15%, memory)</p>
  </div>
  <div class="page">
    <p>Questions?</p>
    <p>The HLL worked well for kernel development</p>
    <p>Performance is paramount  use C (up to 15%)</p>
    <p>Minimize memory use  use C ( mem. budget,  GC cost)</p>
    <p>Safety is paramount  use HLL (40 CVEs stopped)</p>
    <p>Performance merely important  use HLL (pay 15%, memory)</p>
    <p>git clone https://github.com/mit-pdos/biscuit.git 35 / 38</p>
  </div>
  <div class="page"/>
</Presentation>
