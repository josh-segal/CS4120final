<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Application Crash Consistency and Performance with CCFS</p>
    <p>Thanumalayan Sankaranarayana Pillai, Ramnatthan Alagappan, Lanyue Lu, Vijay Chidambaram, Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau</p>
  </div>
  <div class="page">
    <p>Storage must be robust even with system crashes - Power loss (2016 UPS issues: Github outage, Internet outage across UK) - Kernel bugs</p>
    <p>Application-Level Crash Consistency</p>
    <p>[source:www.datacenterknowledge.com]</p>
    <p>[Lu et al., OSDI 2014, Palix et al., ASPLOS 2011, Chou et al., SOSP 2001]</p>
  </div>
  <div class="page">
    <p>Storage must be robust even with system crashes - Power loss (2016 UPS issues: Github outage, Internet outage across UK) - Kernel bugs</p>
    <p>Applications need to implement crash consistency - E.g., Database applications ensure transactions are atomic</p>
    <p>Application-Level Crash Consistency</p>
    <p>[source:www.datacenterknowledge.com]</p>
    <p>[Lu et al., OSDI 2014, Palix et al., ASPLOS 2011, Chou et al., SOSP 2001]</p>
  </div>
  <div class="page">
    <p>Storage must be robust even with system crashes - Power loss (2016 UPS issues: Github outage, Internet outage across UK) - Kernel bugs</p>
    <p>Applications need to implement crash consistency - E.g., Database applications ensure transactions are atomic</p>
    <p>Applications implement crash consistency wrongly - Pillai et al., OSDI 2014 (11 applications) and Zhou et al., OSDI 2014 (8 databases) - Conclusion: All applications had some form of incorrectness</p>
    <p>Application-Level Crash Consistency</p>
    <p>[source:www.datacenterknowledge.com]</p>
    <p>[Lu et al., OSDI 2014, Palix et al., ASPLOS 2011, Chou et al., SOSP 2001]</p>
  </div>
  <div class="page">
    <p>App crash consistency depends on FS behavior - E.g., Bad FS behavior: 60 vulnerabilities in 11 applications - Good FS behavior: 10 vulnerabilities in 11 applications</p>
    <p>Ordering and Application Consistency</p>
    <p>[Pillai et al., OSDI 2014]</p>
  </div>
  <div class="page">
    <p>App crash consistency depends on FS behavior - E.g., Bad FS behavior: 60 vulnerabilities in 11 applications - Good FS behavior: 10 vulnerabilities in 11 applications</p>
    <p>FS-level ordering is important for applications - All writes should (logically) be persisted in their issued order - Major factor affecting application crash consistency</p>
    <p>Ordering and Application Consistency</p>
    <p>[Pillai et al., OSDI 2014]</p>
  </div>
  <div class="page">
    <p>App crash consistency depends on FS behavior - E.g., Bad FS behavior: 60 vulnerabilities in 11 applications - Good FS behavior: 10 vulnerabilities in 11 applications</p>
    <p>FS-level ordering is important for applications - All writes should (logically) be persisted in their issued order - Major factor affecting application crash consistency</p>
    <p>Few FS configurations provide FS-level ordering - Ordering is considered bad for performance</p>
    <p>Ordering and Application Consistency</p>
    <p>[Pillai et al., OSDI 2014]</p>
  </div>
  <div class="page">
    <p>Stream abstraction - Allows FS-level ordering with little performance overhead - Needs a single, backward-compatible change to user code - Flexible: More code changes improve performance</p>
    <p>In this paper ...</p>
  </div>
  <div class="page">
    <p>Stream abstraction - Allows FS-level ordering with little performance overhead - Needs a single, backward-compatible change to user code - Flexible: More code changes improve performance</p>
    <p>Crash-Consistent File System (CCFS) - Efficient implementation of stream abstraction on ext4 - High performance similar to ext4 - Noticeably higher crash consistency for applications</p>
    <p>In this paper ...</p>
  </div>
  <div class="page">
    <p>Introduction Background Stream API Crash-Consistent File System Evaluation Conclusion</p>
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Each file system behaves differently across a crash - Little standardization of behavior across crashes</p>
    <p>File-System Behavior</p>
  </div>
  <div class="page">
    <p>Each file system behaves differently across a crash - Little standardization of behavior across crashes</p>
    <p>File-System Behavior</p>
    <p>FS Crash Behavior</p>
    <p>Atomicity Ordering</p>
  </div>
  <div class="page">
    <p>Each file system behaves differently across a crash - Little standardization of behavior across crashes</p>
    <p>File-System Behavior</p>
    <p>FS Crash Behavior</p>
    <p>Atomicity</p>
    <p>Effects of a write() system call atomic on a</p>
    <p>system crash?</p>
    <p>Ordering creat(A);</p>
    <p>creat(B);</p>
    <p>Possible after crash that B exists, but A does not?</p>
  </div>
  <div class="page">
    <p>Each file system behaves differently across a crash - Little standardization of behavior across crashes</p>
    <p>File-System Behavior</p>
    <p>FS Crash Behavior</p>
    <p>Atomicity Ordering</p>
    <p>Directory operations E.g., rename() atomic?</p>
    <p>File writes Entire system call?</p>
    <p>Sector-level?</p>
    <p>......</p>
  </div>
  <div class="page">
    <p>Previous work: App crash consistency vs FS behavior</p>
    <p>Vulnerabilities Study</p>
    <p>[Pillai et al., OSDI 2014]</p>
  </div>
  <div class="page">
    <p>Previous work: App crash consistency vs FS behavior</p>
    <p>Vulnerability: Place in application source code that can lead to inconsistency, depending on FS behavior</p>
    <p>Vulnerabilities Study</p>
    <p>[Pillai et al., OSDI 2014]</p>
  </div>
  <div class="page">
    <p>Vulnerabilities Study: Results</p>
    <p>Ext2-like FS Btrfs Ext3-DJ LevelDB-1.10 10 4 1 LevelDB-1.15 6 3 1 LMDB 1 GDBM 5 4 2 HSQLDB 10 4 SQLite-Roll 1 1 1 SQLite-WAL 0 PostgreSQL 1 Git 9 5 2 Mercurial 10 8 3 VMWare 1 HDFS 2 1 ZooKeeper 4 1</p>
    <p>Total _______________</p>
  </div>
  <div class="page">
    <p>Vulnerabilities Study: Results</p>
    <p>Ext2-like FS Btrfs Ext3-DJ LevelDB-1.10 10 4 1 LevelDB-1.15 6 3 1 LMDB 1 GDBM 5 4 2 HSQLDB 10 4 SQLite-Roll 1 1 1 SQLite-WAL 0 PostgreSQL 1 Git 9 5 2 Mercurial 10 8 3 VMWare 1 HDFS 2 1 ZooKeeper 4 1</p>
    <p>Total _______________</p>
    <p>File systems</p>
    <p>Vulnerabilities under safest application configurationA</p>
    <p>pp lic</p>
    <p>at io</p>
    <p>ns</p>
  </div>
  <div class="page">
    <p>Vulnerabilities Study: Results</p>
    <p>Ext2-like FS Btrfs Ext3-DJ LevelDB-1.10 10 4 1 LevelDB-1.15 6 3 1 LMDB 1 GDBM 5 4 2 HSQLDB 10 4 SQLite-Roll 1 1 1 SQLite-WAL 0 PostgreSQL 1 Git 9 5 2 Mercurial 10 8 3 VMWare 1 HDFS 2 1 ZooKeeper 4 1</p>
    <p>Total _______________</p>
    <p>Ordering    Atomicity</p>
    <p>File-system behavior</p>
  </div>
  <div class="page">
    <p>Vulnerabilities Study: Results</p>
    <p>Ext2-like FS Btrfs Ext3-DJ LevelDB-1.10 10 4 1 LevelDB-1.15 6 3 1 LMDB 1 GDBM 5 4 2 HSQLDB 10 4 SQLite-Roll 1 1 1 SQLite-WAL 0 PostgreSQL 1 Git 9 5 2 Mercurial 10 8 3 VMWare 1 HDFS 2 1 ZooKeeper 4 1</p>
    <p>Total _______________</p>
    <p>Ordering    Atomicity    Under FS with few guarantees</p>
    <p>of atomicity and ordering, 60 vulnerabilities are exposed</p>
    <p>- Serious consequences: unavailability, data loss</p>
  </div>
  <div class="page">
    <p>Vulnerabilities Study: Results</p>
    <p>Ext2-like FS Btrfs Ext3-DJ LevelDB-1.10 10 4 1 LevelDB-1.15 6 3 1 LMDB 1 GDBM 5 4 2 HSQLDB 10 4 SQLite-Roll 1 1 1 SQLite-WAL 0 PostgreSQL 1 Git 9 5 2 Mercurial 10 8 3 VMWare 1 HDFS 2 1 ZooKeeper 4 1</p>
    <p>Total _______________</p>
    <p>Ordering    Atomicity    Under btrfs, with atomicity</p>
    <p>but lots of re-ordering, 31 vulnerabilities</p>
    <p>- Serious consequences</p>
    <p>Repository corruption</p>
    <p>Unavailability</p>
  </div>
  <div class="page">
    <p>Vulnerabilities Study: Results</p>
    <p>Ext2-like FS Btrfs Ext3-DJ LevelDB-1.10 10 4 1 LevelDB-1.15 6 3 1 LMDB 1 GDBM 5 4 2 HSQLDB 10 4 SQLite-Roll 1 1 1 SQLite-WAL 0 PostgreSQL 1 Git 9 5 2 Mercurial 10 8 3 VMWare 1 HDFS 2 1 ZooKeeper 4 1</p>
    <p>Total _______________</p>
    <p>Ordering    Atomicity    Under data-journaled ext3,</p>
    <p>with both atomicity and ordering, 10 vulnerabilities</p>
    <p>- Minor consequences</p>
    <p>Dirstate corruption</p>
    <p>Documentation error</p>
  </div>
  <div class="page">
    <p>Ideal behavior: Ordering, weak atomicity - All file system updates should be persisted in-order - Writes can split at sector boundary; everything else atomic</p>
    <p>Real-world vs Ideal FS behavior</p>
  </div>
  <div class="page">
    <p>Ideal behavior: Ordering, weak atomicity - All file system updates should be persisted in-order - Writes can split at sector boundary; everything else atomic</p>
    <p>Modern file systems already provide weak atomicity - E.g.: Default modes of ext4, btrfs, xfs</p>
    <p>Real-world vs Ideal FS behavior</p>
  </div>
  <div class="page">
    <p>Ideal behavior: Ordering, weak atomicity - All file system updates should be persisted in-order - Writes can split at sector boundary; everything else atomic</p>
    <p>Modern file systems already provide weak atomicity - E.g.: Default modes of ext4, btrfs, xfs</p>
    <p>Only rarely used FS configurations provide ordering - E.g.: Data-journaling mode of ext4, ext3</p>
    <p>Real-world vs Ideal FS behavior</p>
  </div>
  <div class="page">
    <p>File-system behavior affects application consistency - Behavior is not standardized - 60 vulnerabilities with ext2-like FS; 10 with well-behaved FS</p>
    <p>Desired behavior: Ordering and weak atomicity - Weak atomicity already provided by modern file systems - Ordering provided only by rarely-used FS configurations</p>
    <p>Background: Summary</p>
  </div>
  <div class="page">
    <p>Introduction Background Stream API Crash-Consistent File System Evaluation Conclusion</p>
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Some existing file systems preserve order - Example: ext3 and ext4 under data-journaling mode - Performance overhead?</p>
    <p>Why not use an order-preserving FS?</p>
  </div>
  <div class="page">
    <p>Some existing file systems preserve order - Example: ext3 and ext4 under data-journaling mode - Performance overhead?</p>
    <p>New techniques are efficient in maintaining order - CoW, optimized forms of journaling - Ordering doesnt require disk-level seeks</p>
    <p>Why not use an order-preserving FS?</p>
  </div>
  <div class="page">
    <p>Some existing file systems preserve order - Example: ext3 and ext4 under data-journaling mode - Performance overhead?</p>
    <p>New techniques are efficient in maintaining order - CoW, optimized forms of journaling - Ordering doesnt require disk-level seeks</p>
    <p>Reason: False ordering dependencies - Inherent overhead of ordering, irrespective of technique used</p>
    <p>Why not use an order-preserving FS?</p>
  </div>
  <div class="page">
    <p>Application A Application B</p>
    <p>False Ordering Dependencies</p>
  </div>
  <div class="page">
    <p>Application A</p>
    <p>pwrite(f1, 0, 150 MB);</p>
    <p>Application B</p>
    <p>Time</p>
    <p>False Ordering Dependencies</p>
  </div>
  <div class="page">
    <p>Application A</p>
    <p>pwrite(f1, 0, 150 MB);</p>
    <p>Application B</p>
    <p>write(f2, hello); write(f3, world);</p>
    <p>Time</p>
    <p>False Ordering Dependencies</p>
  </div>
  <div class="page">
    <p>Application A</p>
    <p>pwrite(f1, 0, 150 MB);</p>
    <p>Application B</p>
    <p>write(f2, hello); write(f3, world); fsync(f3);</p>
    <p>Time</p>
    <p>False Ordering Dependencies</p>
  </div>
  <div class="page">
    <p>Application A</p>
    <p>pwrite(f1, 0, 150 MB);</p>
    <p>Application B</p>
    <p>write(f2, hello); write(f3, world); fsync(f3);</p>
    <p>Time</p>
    <p>write(f1) has to be sent to disk before write(f2)</p>
    <p>False Ordering Dependencies</p>
    <p>In a globally ordered file system ...</p>
  </div>
  <div class="page">
    <p>Application A</p>
    <p>pwrite(f1, 0, 150 MB);</p>
    <p>Application B</p>
    <p>write(f2, hello); write(f3, world); fsync(f3);</p>
    <p>Time</p>
    <p>False Ordering Dependencies</p>
    <p>In a globally ordered file system ...</p>
  </div>
  <div class="page">
    <p>Problem: Ordering between independent applications</p>
    <p>Application A</p>
    <p>pwrite(f1, 0, 150 MB);</p>
    <p>Application B</p>
    <p>write(f2, hello); write(f3, world); fsync(f3);</p>
    <p>Time</p>
    <p>False Ordering Dependencies</p>
    <p>In a globally ordered file system ...</p>
  </div>
  <div class="page">
    <p>Problem: Ordering between independent applications</p>
    <p>Solution: Order only within each application - Avoids performance overhead, provides app consistency</p>
    <p>Application A</p>
    <p>pwrite(f1, 0, 150 MB);</p>
    <p>Application B</p>
    <p>write(f2, hello); write(f3, world); fsync(f3);</p>
    <p>Time</p>
    <p>False Ordering Dependencies</p>
  </div>
  <div class="page">
    <p>New abstraction: Order only within a stream - Each application is usually put into a separate stream</p>
    <p>Application A</p>
    <p>pwrite(f1, 0, 150 MB);</p>
    <p>Application B</p>
    <p>write(f2, hello); write(f3, world); fsync(f3);</p>
    <p>Time</p>
    <p>Stream Abstraction</p>
    <p>stream-B</p>
    <p>stream-A</p>
  </div>
  <div class="page">
    <p>New set_stream() call - All updates after set_stream(X) associated with stream X - When process forks, previous stream is adopted</p>
    <p>Application A set_stream(A) pwrite(f1, 0, 150 MB);</p>
    <p>Application B set_stream(B)</p>
    <p>write(f2, hello); write(f3, world); fsync(f3);</p>
    <p>Time</p>
    <p>Stream API: Normal Usage</p>
  </div>
  <div class="page">
    <p>New set_stream() call - All updates after set_stream(X) associated with stream X - When process forks, previous stream is adopted</p>
    <p>Using streams is easy - Add a single set_stream() call in beginning of application - Backward-compatible: set_stream() is no-op in older FSes</p>
    <p>Stream API: Normal Usage</p>
  </div>
  <div class="page">
    <p>set_stream() is versatile - Many applications can be assigned the same stream - Threads within an application can use different streams - Single thread can keep switching between streams</p>
    <p>Stream API: Extended Usage</p>
  </div>
  <div class="page">
    <p>set_stream() is versatile - Many applications can be assigned the same stream - Threads within an application can use different streams - Single thread can keep switching between streams</p>
    <p>Ordering vs durability: stream_sync(), IGNORE_FSYNC flag - Applications use fsync() for both ordering and durability - IGNORE_FSYNC ignores fsync(), respects stream_sync()</p>
    <p>Stream API: Extended Usage</p>
    <p>[Chidambaram et al., SOSP2013]</p>
  </div>
  <div class="page">
    <p>In an ordered FS, false dependencies cause overhead - Inherent overhead, independent of technique used</p>
    <p>Streams provide order only within application - Writes across applications can be re-ordered for performance - For consistency, ordering required only within application</p>
    <p>Easy to use!</p>
    <p>Streams: Summary</p>
  </div>
  <div class="page">
    <p>Introduction Background Stream API Crash-Consistent File System Evaluation Conclusion</p>
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Crash consistent file system - Efficient implementation of stream abstraction</p>
    <p>CCFS: Design</p>
  </div>
  <div class="page">
    <p>Crash consistent file system - Efficient implementation of stream abstraction</p>
    <p>Basic design: Based on ext4 with data-journaling - Ext4 data-journaling guarantees global ordering - Ordering across all applications: false dependencies - CCFS uses separate transactions for each stream</p>
    <p>CCFS: Design</p>
  </div>
  <div class="page">
    <p>Crash consistent file system - Efficient implementation of stream abstraction</p>
    <p>Basic design: Based on ext4 with data-journaling - Ext4 data-journaling guarantees global ordering - Ordering across all applications: false dependencies - CCFS uses separate transactions for each stream</p>
    <p>Multiple challenges</p>
    <p>CCFS: Design</p>
  </div>
  <div class="page">
    <p>Ext4 has 1) main-memory structure, running transaction, 2) on-disk journal structure</p>
    <p>Ext4 Journaling: Global Order</p>
    <p>Main memory</p>
    <p>On-disk journal</p>
    <p>Running transaction</p>
  </div>
  <div class="page">
    <p>Ext4 Journaling: Global Order</p>
    <p>On-disk journal</p>
    <p>Application modifications recorded in main-memory running transaction</p>
    <p>Application A Modify blocks #1,#3</p>
    <p>Running transaction</p>
    <p>Application B</p>
    <p>Modify blocks #2,#4</p>
  </div>
  <div class="page">
    <p>Application A Modify blocks #1,#3</p>
    <p>Running transaction</p>
    <p>Main memory</p>
    <p>On-disk journal</p>
    <p>On fsync() call, running transaction committed to on-disk journal</p>
    <p>Application B</p>
    <p>Modify blocks #2,#4 fsync()</p>
    <p>Ext4 Journaling: Global Order</p>
  </div>
  <div class="page">
    <p>Application A Modify blocks #1,#3</p>
    <p>Running transaction</p>
    <p>Main memory</p>
    <p>On-disk journal</p>
    <p>On fsync() call, running transaction committed to on-disk journal</p>
    <p>Application B</p>
    <p>Modify blocks #2,#4 fsync()</p>
    <p>Ext4 Journaling: Global Order</p>
    <p>be gi</p>
    <p>n</p>
    <p>en d</p>
  </div>
  <div class="page">
    <p>Application A Modify blocks #1,#3</p>
    <p>Modify blocks #5,#6</p>
    <p>Running transaction</p>
    <p>Main memory</p>
    <p>On-disk journal</p>
    <p>Further application writes recorded in new running transaction and committed</p>
    <p>Application B</p>
    <p>Modify blocks #2,#4 fsync()</p>
    <p>Ext4 Journaling: Global Order</p>
    <p>be gi</p>
    <p>n</p>
    <p>en d</p>
  </div>
  <div class="page">
    <p>Application A Modify blocks #1,#3</p>
    <p>Modify blocks #5,#6</p>
    <p>Running transaction</p>
    <p>Main memory</p>
    <p>On-disk journal</p>
    <p>Further application writes recorded in new running transaction and committed</p>
    <p>Application B</p>
    <p>Modify blocks #2,#4 fsync()</p>
    <p>Ext4 Journaling: Global Order</p>
    <p>be gi</p>
    <p>n</p>
    <p>en d</p>
  </div>
  <div class="page">
    <p>Application A Modify blocks #1,#3</p>
    <p>Modify blocks #5,#6</p>
    <p>Running transaction</p>
    <p>Main memory</p>
    <p>On-disk journal</p>
    <p>Further application writes recorded in new running transaction and committed</p>
    <p>Application B</p>
    <p>Modify blocks #2,#4 fsync()</p>
    <p>Ext4 Journaling: Global Order</p>
    <p>be gi</p>
    <p>n</p>
    <p>en d 5 6</p>
    <p>be gi</p>
    <p>n</p>
    <p>en d</p>
  </div>
  <div class="page">
    <p>Running transaction</p>
    <p>Main memory</p>
    <p>On-disk journal</p>
    <p>On system crash, on-disk journal transactions recovered atomically, in sequential order</p>
    <p>Ext4 Journaling: Global Order</p>
    <p>be gi</p>
    <p>n</p>
    <p>en d 5 6</p>
    <p>be gi</p>
    <p>n</p>
    <p>en d</p>
  </div>
  <div class="page">
    <p>Running transaction</p>
    <p>Main memory</p>
    <p>On-disk journal</p>
    <p>On system crash, on-disk journal transactions recovered atomically, in sequential order Global ordering is maintained!</p>
    <p>Ext4 Journaling: Global Order</p>
    <p>be gi</p>
    <p>n</p>
    <p>en d 5 6</p>
    <p>be gi</p>
    <p>n</p>
    <p>en d</p>
  </div>
  <div class="page">
    <p>Application A set_stream(A) Modify blocks #1,#3</p>
    <p>stream-B transaction</p>
    <p>Main memory</p>
    <p>On-disk journal</p>
    <p>CCFS maintains separate running transaction per stream</p>
    <p>Application B set_stream(B)</p>
    <p>Modify blocks #2,#4</p>
    <p>CCFS: Stream Order</p>
    <p>stream-A transaction</p>
  </div>
  <div class="page">
    <p>Application A set_stream(A) Modify blocks #1,#3</p>
    <p>stream-B transaction</p>
    <p>Main memory</p>
    <p>On-disk journal</p>
    <p>On fsync(), only that stream is committed</p>
    <p>Application B set_stream(B)</p>
    <p>Modify blocks #2,#4 fsync()</p>
    <p>CCFS: Stream Order</p>
    <p>stream-A transaction</p>
  </div>
  <div class="page">
    <p>Application A set_stream(A) Modify blocks #1,#3</p>
    <p>stream-B transaction</p>
    <p>Main memory</p>
    <p>On-disk journal</p>
    <p>On fsync(), only that stream is committed</p>
    <p>Application B set_stream(B)</p>
    <p>Modify blocks #2,#4 fsync()</p>
    <p>CCFS: Stream Order</p>
    <p>stream-A transaction</p>
    <p>be gi</p>
    <p>n</p>
    <p>en d</p>
  </div>
  <div class="page">
    <p>Application A set_stream(A) Modify blocks #1,#3</p>
    <p>stream-B transaction</p>
    <p>Main memory</p>
    <p>On-disk journal</p>
    <p>Ordering maintained within stream, re-order across streams!</p>
    <p>Application B set_stream(B)</p>
    <p>Modify blocks #2,#4 fsync()</p>
    <p>CCFS: Stream Order</p>
    <p>stream-A transaction</p>
    <p>be gi</p>
    <p>n</p>
    <p>en d</p>
  </div>
  <div class="page">
    <p>Example: Two streams updating adjoining dir-entries</p>
    <p>CCFS: Multiple Challenges</p>
    <p>Application A set_stream(A) create(/X/A)</p>
    <p>Application B set_stream(B)</p>
    <p>create(/X/B)</p>
  </div>
  <div class="page">
    <p>Example: Two streams updating adjoining dir-entries</p>
    <p>CCFS: Multiple Challenges</p>
    <p>Application A set_stream(A) create(/X/A)</p>
    <p>Application B set_stream(B)</p>
    <p>create(/X/B)Entry-A Entry-B</p>
    <p>Block-1 (belonging to directory X)</p>
  </div>
  <div class="page">
    <p>Challenge #1: Block-Level Journaling</p>
    <p>Entry-A Entry-B</p>
    <p>Block-1</p>
    <p>stream-B transaction</p>
    <p>Main memory</p>
    <p>stream-A transaction</p>
    <p>? ?</p>
    <p>Two independent streams can update same block!</p>
    <p>Application A set_stream(A) create(/X/A)</p>
    <p>Application B set_stream(B)</p>
    <p>create(/X/B)</p>
  </div>
  <div class="page">
    <p>Challenge #1: Block-Level Journaling</p>
    <p>Entry-A Entry-B</p>
    <p>Block-1</p>
    <p>stream-B transaction</p>
    <p>Main memory</p>
    <p>stream-A transaction</p>
    <p>? ?</p>
    <p>Two independent streams can update same block!</p>
    <p>Application A set_stream(A) create(/X/A)</p>
    <p>Application B set_stream(B)</p>
    <p>create(/X/B)</p>
    <p>Faulty solution: Perform journaling at byte-granularity - Disables optimizations, complicates disk updates</p>
  </div>
  <div class="page">
    <p>Challenge #1: Block-Level Journaling</p>
    <p>stream-B transaction</p>
    <p>Main memory</p>
    <p>stream-A transaction</p>
    <p>CCFS solution: Record running transactions at byte granularity</p>
    <p>Application A set_stream(A) create(/X/A)</p>
    <p>Application B set_stream(B)</p>
    <p>create(/X/B)</p>
    <p>Entry-A Entry-B</p>
  </div>
  <div class="page">
    <p>Challenge #1: Block-Level Journaling</p>
    <p>stream-B transaction</p>
    <p>Main memory</p>
    <p>stream-A transaction</p>
    <p>Application A set_stream(A) create(/X/A)</p>
    <p>Application B set_stream(B)</p>
    <p>create(/X/B)</p>
    <p>Entry-A Entry-B</p>
    <p>CCFS solution: Record running transactions at byte granularity Commit at block granularity</p>
    <p>On-disk journal</p>
  </div>
  <div class="page">
    <p>Challenge #1: Block-Level Journaling</p>
    <p>stream-B transaction</p>
    <p>Main memory</p>
    <p>stream-A transaction</p>
    <p>Application A set_stream(A) create(/X/A)</p>
    <p>Application B set_stream(B)</p>
    <p>create(/X/B)</p>
    <p>Entry-A Entry-B</p>
    <p>CCFS solution: Record running transactions at byte granularity Commit at block granularity</p>
    <p>On-disk journal beg in</p>
    <p>en d</p>
    <p>Entry-B Entry-A</p>
    <p>Entire block-1 committed</p>
    <p>Old version of entry-A</p>
  </div>
  <div class="page">
    <p>More Challenges ...</p>
  </div>
  <div class="page">
    <p>More Challenges ...</p>
  </div>
  <div class="page">
    <p>More Challenges ...</p>
  </div>
  <div class="page">
    <p>More Challenges ...</p>
  </div>
  <div class="page">
    <p>More Challenges ...</p>
  </div>
  <div class="page">
    <p>More Challenges ...</p>
  </div>
  <div class="page">
    <p>Introduction Background Stream API Crash-Consistent File System Evaluation Conclusion</p>
    <p>Outline</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Evaluation</p>
  </div>
  <div class="page">
    <p>Vulnerabilities</p>
    <p>Application ext4 ccfs</p>
    <p>LevelDB 1 0</p>
    <p>SQLite-Roll 0 0</p>
    <p>Git 2 0</p>
    <p>Mercurial 5 2</p>
    <p>ZooKeeper 1 0</p>
  </div>
  <div class="page">
    <p>Ext4: 9 Vulnerabilities - Consistency lost in LevelDB - Repository corrupted in Git, Mercurial - ZooKeeper becomes unavailable</p>
    <p>Vulnerabilities</p>
    <p>Application ext4 ccfs</p>
    <p>LevelDB 1 0</p>
    <p>SQLite-Roll 0 0</p>
    <p>Git 2 0</p>
    <p>Mercurial 5 2</p>
    <p>ZooKeeper 1 0</p>
  </div>
  <div class="page">
    <p>Ext4: 9 Vulnerabilities - Consistency lost in LevelDB - Repository corrupted in Git, Mercurial - ZooKeeper becomes unavailable</p>
    <p>CCFS: 2 vulnerabilities in Mercurial - Dirstate corruption</p>
    <p>Vulnerabilities</p>
    <p>Application ext4 ccfs</p>
    <p>LevelDB 1 0</p>
    <p>SQLite-Roll 0 0</p>
    <p>Git 2 0</p>
    <p>Mercurial 5 2</p>
    <p>ZooKeeper 1 0</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut : n</p>
    <p>or m</p>
    <p>al iz</p>
    <p>ed to</p>
    <p>e xt</p>
    <p>ig he</p>
    <p>r is</p>
    <p>b et</p>
    <p>te r)</p>
    <p>ext4 ccfs</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut : n</p>
    <p>or m</p>
    <p>al iz</p>
    <p>ed to</p>
    <p>e xt</p>
    <p>ig he</p>
    <p>r is</p>
    <p>b et</p>
    <p>te r)</p>
    <p>ext4 ccfs</p>
    <p>Real applicationsStandard benchmarks</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut : n</p>
    <p>or m</p>
    <p>al iz</p>
    <p>ed to</p>
    <p>e xt</p>
    <p>ig he</p>
    <p>r is</p>
    <p>b et</p>
    <p>te r)</p>
    <p>ext4 ccfs</p>
    <p>Standard workloads: Similar performance for ext4, ccfs</p>
    <p>But ext4 re-orders!</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut : n</p>
    <p>or m</p>
    <p>al iz</p>
    <p>ed to</p>
    <p>e xt</p>
    <p>ig he</p>
    <p>r is</p>
    <p>b et</p>
    <p>te r)</p>
    <p>ext4 ccfs</p>
    <p>Git under ext4 is slow because of safer configuration needed for correctness</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut : n</p>
    <p>or m</p>
    <p>al iz</p>
    <p>ed to</p>
    <p>e xt</p>
    <p>ig he</p>
    <p>r is</p>
    <p>b et</p>
    <p>te r)</p>
    <p>ext4 ccfs</p>
    <p>SQLite and LevelDB : Similar performance for ext4, ccfs</p>
  </div>
  <div class="page">
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut : n</p>
    <p>or m</p>
    <p>al iz</p>
    <p>ed to</p>
    <p>e xt</p>
    <p>ig he</p>
    <p>r is</p>
    <p>b et</p>
    <p>te r)</p>
    <p>ext4 ccfs ext4 ccfs ccfs+</p>
    <p>But, performance can be improved with IGNORE_FSYNC and stream_sync()!</p>
  </div>
  <div class="page">
    <p>Crash consistency: Better than ext4 - 9 vulnerabilities in ext4, 2 minor in CCFS</p>
    <p>Performance: Like ext4 with little programmer overhead - Much better with additional programmer effort</p>
    <p>More results in paper!</p>
    <p>Evaluation: Summary</p>
  </div>
  <div class="page">
    <p>FS crash behavior is currently not standardized</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>FS crash behavior is currently not standardized</p>
    <p>Ideal FS behavior can improve application consistency</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>FS crash behavior is currently not standardized</p>
    <p>Ideal FS behavior can improve application consistency</p>
    <p>Ideal FS behavior is considered bad for performance</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>FS crash behavior is currently not standardized</p>
    <p>Ideal FS behavior can improve application consistency</p>
    <p>Ideal FS behavior is considered bad for performance</p>
    <p>Stream abstraction and CCFS solve this dilemma</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>FS crash behavior is currently not standardized</p>
    <p>Ideal FS behavior can improve application consistency</p>
    <p>Ideal FS behavior is considered bad for performance</p>
    <p>Stream abstraction and CCFS solve this dilemma</p>
    <p>Thank you! Questions?</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>Examples</p>
    <p>i. Unable to open the database b. write(file1, kv1); write(file1, kv2); --&gt; creat(file2, kv3);</p>
    <p>i. kv1 and kv2 might disappear, while kv3 still exists 2. Git:</p>
    <p>a. append(index.lock) --&gt; rename(index.lock, index) i. Corruption  returned by various Git commands</p>
    <p>b. write(tmp); link(tmp, object) --&gt; rename(master.lock, master) i. Corruption  returned by various Git commands</p>
    <p>rename(md5.tmp, md5); --&gt; rename(ckpt, fsimage); i. Unable to boot the server and use the data</p>
  </div>
  <div class="page">
    <p>One sector overwrite: Atomic because of device characteristics</p>
    <p>Appends: Garbage in some file systems</p>
    <p>File systems do not usually provide atomicity for big writes</p>
    <p>File System Study: Results</p>
    <p>File system configuration</p>
    <p>Atomicity One sector overwrite</p>
    <p>One sector append</p>
    <p>Many sector write</p>
    <p>Directory operation</p>
    <p>ext2 async    sync</p>
    <p>ext3 writeback   ordered</p>
    <p>data-journal</p>
    <p>ext4</p>
    <p>writeback   ordered</p>
    <p>no-delalloc  data-journal  btrfs</p>
    <p>xfs default  wsync</p>
  </div>
  <div class="page">
    <p>One sector overwrite: Atomic because of device characteristics</p>
    <p>Appends: Garbage in some file systems</p>
    <p>File systems do not usually provide atomicity for big writes</p>
    <p>Directory operations are usually atomic</p>
    <p>File System Study: Results</p>
    <p>File system configuration</p>
    <p>Atomicity One sector overwrite</p>
    <p>One sector append</p>
    <p>Many sector write</p>
    <p>Directory operation</p>
    <p>ext2 async    sync</p>
    <p>ext3 writeback   ordered</p>
    <p>data-journal</p>
    <p>ext4</p>
    <p>writeback   ordered</p>
    <p>no-delalloc  data-journal  btrfs</p>
    <p>xfs default  wsync</p>
  </div>
  <div class="page">
    <p>Collecting System Call Trace</p>
    <p>git add file1 Application Workload</p>
    <p>Record strace, memory accesses (for mmap writes), initial state of datastore</p>
    <p>creat(index.lock) creat(tmp) append(tmp, data, 4K) fsync(tmp) link(tmp, permanent) append(index.lock) rename(index.lock, index)</p>
    <p>Trace Initial state .git/...</p>
  </div>
  <div class="page">
    <p>Calculating Intermediate States</p>
    <p>a. Convert system calls into atomic modifications</p>
    <p>creat(index.lock) creat(tmp) append(tmp, 4K)</p>
    <p>fsync(tmp) link(tmp, permanent) ...</p>
    <p>creat(inode=1, dentry=index.lock) creat(inode=2, dentry=tmp) truncate(inode=2, 1) truncate(inode=2, 2) ... truncate(inode=2, 4K) write(inode=2, garbage) write(inode=2, actual data) ...</p>
    <p>link(inode=2, dentry=permanent) ...</p>
  </div>
  <div class="page">
    <p>Calculating Intermediate States</p>
    <p>b. Find ordering dependencies</p>
    <p>creat(index.lock) creat(tmp) append(tmp, 4K)</p>
    <p>fsync(tmp) link(tmp, permanent) ...</p>
    <p>creat(inode=1, dentry=index.lock) creat(inode=2, dentry=tmp) truncate(inode=2, 1) truncate(inode=2, 2) ... truncate(inode=2, 4K) write(inode=2, garbage) write(inode=2, actual data) ...</p>
    <p>link(inode=2, dentry=permanent) ...</p>
  </div>
  <div class="page">
    <p>Calculating Intermediate States</p>
    <p>c. Choose a few sets of modifications obeying dependencies</p>
    <p>creat(inode=1, dentry=index.lock) creat(inode=2, dentry=tmp) truncate(inode=2, 1) truncate(inode=2, 2) ... truncate(inode=2, 4K) write(inode=2, garbage) write(inode=2, actual data) ...</p>
    <p>link(inode=2, dentry=permanent) ...</p>
    <p>Set 1: creat(inode=1, dentry=index.lock) &lt;all truncates and writes to inode 2&gt;</p>
    <p>Set 2: creat(inode=1, dentry=index.lock) &lt;all truncates and writes to inode 2&gt; link(inode=2, dentry=permanent)</p>
    <p>Set 3: creat(inode=1, dentry=index.lock) creat(inode=2, dentry=tmp) truncate(inode=2, 1)</p>
    <p>... more sets</p>
  </div>
  <div class="page">
    <p>Calculating Crash States from a Trace</p>
    <p>d. Reconstruct states from sets of modifications</p>
    <p>Set 1: creat(inode=1, dentry=index.lock) &lt;all truncates and writes to inode 2&gt;</p>
    <p>Set 2: creat(inode=1, dentry=index.lock) &lt;all truncates and writes to inode 2&gt; link(inode=2, dentry=permanent)</p>
    <p>Set 3: creat(inode=1, dentry=index.lock) creat(inode=2, dentry=tmp) truncate(inode=2, 1)</p>
    <p>... more sets</p>
    <p>.git/index.lock (0)</p>
    <p>.git/index.lock (0)</p>
    <p>.git/permanent (4K)</p>
    <p>.git/index.lock (0)</p>
    <p>.git/tmp (1)</p>
  </div>
  <div class="page">
    <p>Checking ALC on Intermediate States</p>
    <p>.git/tmp (4K)</p>
    <p>.git/index (1K) .git/tmp (4K:garbage) .git/index.lock (1K)</p>
    <p>.git/permanent (4K)</p>
    <p>.git/tmp (4K)</p>
    <p>.git/index (0K)</p>
    <p>Multiple Possible Intermediate States</p>
    <p>git status; git fsck;</p>
    <p>ERROR CORRECT OUTPUT CORRECT OUTPUT</p>
  </div>
  <div class="page">
    <p>Applications implement complex update protocols  Aiming for both correctness and performance  Each protocol is different</p>
    <p>Update protocols hard to implement and test Applications many and varied</p>
    <p>Little effort to test each</p>
    <p>Unfortunately, file systems make ALC more difficult</p>
    <p>Why is ALC problematic?</p>
  </div>
  <div class="page">
    <p>Persistence models used by us to find vulnerabilites But, persistence models can be complex</p>
    <p>Example: write() ordered before unlink() iff they act on the same directory and write() is more than 4KB</p>
    <p>Useful for verifying ALC atop a file system</p>
    <p>Persistence models not suitable to discuss ALC  Is fsync() required after writes to log file in ext3?  Or, do write() calls persist in-order?</p>
    <p>Persistence Models: Too Complex</p>
  </div>
  <div class="page">
    <p>Does FS obey a particular interesting behavior?  Example: Do write() calls persist in-order?  Are write() calls atomic?</p>
    <p>Applications typically depend on some properties  Forgot an fsync(): depends on ordering properties  Forgot checksum verification: depends on atomic write()</p>
    <p>Persistence Properties</p>
  </div>
  <div class="page">
    <p>Content-Atomicity of Appends Does an append result in garbage?</p>
    <p>Persistence Properties: Example #1</p>
    <p>Impossible Intermediate StateSystem call sequence</p>
    <p>lseek(file1, End of file)</p>
    <p>write(file1, hello)</p>
    <p>/file1 he#@!</p>
    <p>/file1 he</p>
    <p>Allowed Intermediate State</p>
  </div>
  <div class="page">
    <p>Ordered Writes Are the effects of write() sent to disk in-order?</p>
    <p>Persistence Properties: Example #2</p>
    <p>Impossible Intermediate State /file1  /file2 world</p>
    <p>/file1 hello /file2</p>
    <p>Allowed Intermediate State</p>
    <p>System call sequence write(file1, hello)</p>
    <p>write(file2, world)</p>
  </div>
  <div class="page">
    <p>creat(index.lock) (i) store object</p>
    <p>append(index.lock) rename(index.lock,index)</p>
    <p>stdout(finished add)</p>
    <p>Example: Git</p>
    <p>(i) store object</p>
    <p>(ii) git add</p>
    <p>(iii) git commit</p>
    <p>(i) store object creat(branch.lock)</p>
    <p>append(branch.lock) append(branch.lock) append(logs/branch) append(logs/HEAD)</p>
    <p>rename(branch.lock,x/branch) stdout(finished commit)</p>
    <p>mkdir(o/x) creat(o/x/tmp_y)</p>
    <p>append(o/x/tmp_y) fsync(o/x/tmp_y)</p>
    <p>link(o/x/tmp_y, o/x/y) unlink(o/x/tmp_y)</p>
  </div>
  <div class="page">
    <p>Atomicity</p>
    <p>Example: Git</p>
    <p>creat(index.lock) (i) store object</p>
    <p>append(index.lock) rename(index.lock,index)</p>
    <p>stdout(finished add)</p>
    <p>(i) store object</p>
    <p>(ii) git add</p>
    <p>(iii) git commit</p>
    <p>(i) store object creat(branch.lock)</p>
    <p>append(branch.lock) append(branch.lock) append(logs/branch) append(logs/HEAD)</p>
    <p>rename(branch.lock,x/branch) stdout(finished commit)</p>
    <p>mkdir(o/x) creat(o/x/tmp_y)</p>
    <p>append(o/x/tmp_y) fsync(o/x/tmp_y)</p>
    <p>link(o/x/tmp_y, o/x/y) unlink(o/x/tmp_y)</p>
  </div>
  <div class="page">
    <p>Ordering</p>
    <p>Example: Git</p>
    <p>(i) 0, (i)</p>
    <p>creat(index.lock) (i) store object</p>
    <p>append(index.lock) rename(index.lock,index)</p>
    <p>stdout(finished add)</p>
    <p>(i) store object</p>
    <p>(ii) git add</p>
    <p>(iii) git commit</p>
    <p>(i) store object creat(branch.lock)</p>
    <p>append(branch.lock) append(branch.lock) append(logs/branch) append(logs/HEAD)</p>
    <p>rename(branch.lock,x/branch) stdout(finished commit)</p>
    <p>mkdir(o/x) creat(o/x/tmp_y)</p>
    <p>append(o/x/tmp_y) fsync(o/x/tmp_y)</p>
    <p>link(o/x/tmp_y, o/x/y) unlink(o/x/tmp_y)</p>
  </div>
  <div class="page">
    <p>Durability</p>
    <p>Example: Git</p>
    <p>d</p>
    <p>d</p>
    <p>creat(index.lock) (i) store object</p>
    <p>append(index.lock) rename(index.lock,index)</p>
    <p>stdout(finished add)</p>
    <p>(i) store object</p>
    <p>(ii) git add</p>
    <p>(iii) git commit</p>
    <p>(i) store object creat(branch.lock)</p>
    <p>append(branch.lock) append(branch.lock) append(logs/branch) append(logs/HEAD)</p>
    <p>rename(branch.lock,x/branch) stdout(finished commit)</p>
    <p>mkdir(o/x) creat(o/x/tmp_y)</p>
    <p>append(o/x/tmp_y) fsync(o/x/tmp_y)</p>
    <p>link(o/x/tmp_y, o/x/y) unlink(o/x/tmp_y)</p>
  </div>
  <div class="page">
    <p>Vulnerability Study: Patterns</p>
  </div>
  <div class="page">
    <p>Across syscall atomicity: Few, minor consequences</p>
    <p>Vulnerability Study: Patterns</p>
  </div>
  <div class="page">
    <p>Garbage during appends cause 4 vulnerabilities File writes seemingly need only sector-level atomicity</p>
    <p>Vulnerability Study: Patterns</p>
  </div>
  <div class="page">
    <p>A separate fsync() on parent directory: 6 vulnerabilities</p>
    <p>Vulnerability Study: Patterns</p>
  </div>
  <div class="page">
    <p>Six applications do not fsync() directory operations</p>
    <p>Vulnerability Study: Patterns</p>
  </div>
  <div class="page">
    <p>Solution: 1. User supplies application workload 2. Record a system-call trace from workload 3. Use Abstract Persistence Model and reconstruct</p>
    <p>targeted intermediate states 4. Run user-given checker on reconstructed states</p>
    <p>ALICE: Solution</p>
    <p>git add file1</p>
    <p>creat(index.lock) creat(tmp) append(tmp, 4K) fsync(tmp) link(tmp, perm) ...</p>
    <p>.git/index.lock (0)</p>
    <p>.git/index.lock (0)</p>
    <p>.git/permanent (4K)</p>
    <p>.git/index.lock (0)</p>
    <p>.git/tmp (1)</p>
    <p>CORRECT</p>
    <p>ERROR</p>
    <p>ERROR</p>
    <p>git status git fsck</p>
  </div>
  <div class="page">
    <p>ALICE: Intermediate States #1</p>
    <p>Does application need atomicity across system calls? Method: Crash after each system call</p>
    <p>creat(index.lock). creat(tmp) append(tmp, 4K) fsync(tmp) link(tmp, perm) ...</p>
  </div>
  <div class="page">
    <p>ALICE: Intermediate States #1</p>
    <p>Does application need atomicity across system calls? Method: Crash after each system call</p>
    <p>creat(index.lock). creat(tmp) append(tmp, 4K) fsync(tmp) link(tmp, perm) ...</p>
    <p>Crash here</p>
  </div>
  <div class="page">
    <p>ALICE: Intermediate States #1</p>
    <p>Does application need atomicity across system calls? Method: Crash after each system call</p>
    <p>creat(index.lock). creat(tmp) . append(tmp, 4K) fsync(tmp) link(tmp, perm) ...</p>
    <p>Crash here ...</p>
  </div>
  <div class="page">
    <p>Does application need atomicity of an individual system call? Method:</p>
    <p>creat(tmp) append(tmp, 4K) fsync(tmp) link(tmp, perm) ...</p>
    <p>ALICE: Intermediate States #2</p>
    <p>System call examined</p>
  </div>
  <div class="page">
    <p>Does application need atomicity of an individual system call? Method:</p>
    <p>creat(tmp) . append(tmp, 4K) fsync(tmp) link(tmp, perm) ...</p>
    <p>ALICE: Intermediate States #2</p>
    <p>System call examined</p>
    <p>Apply these calls</p>
  </div>
  <div class="page">
    <p>Does application need atomicity of an individual system call? Method:</p>
    <p>creat(tmp) . append(tmp, 4K) fsync(tmp) link(tmp, perm) ...</p>
    <p>ALICE: Intermediate States #2</p>
    <p>System call examined</p>
    <p>Apply these calls append(tmp, 2K) (or)</p>
    <p>append(tmp, #@!%^)</p>
    <p>(or) append(tmp, 1K)</p>
    <p>Apply one of these</p>
  </div>
  <div class="page">
    <p>Does application need ordering of a system call? Method:</p>
    <p>creat(index.lock) creat(tmp) append(tmp, 4K) fsync(tmp) link(tmp, perm) ...</p>
    <p>ALICE: Intermediate States #3</p>
    <p>System call examined</p>
  </div>
  <div class="page">
    <p>Does application need ordering of a system call? Method:</p>
    <p>creat(index.lock). creat(tmp) append(tmp, 4K) . fsync(tmp) link(tmp, perm) ...</p>
    <p>ALICE: Intermediate States #3</p>
    <p>System call examined</p>
    <p>Ordering examined</p>
  </div>
  <div class="page">
    <p>Does application need ordering of a system call? Method:</p>
    <p>creat(index.lock). creat(tmp) append(tmp, 4K) . fsync(tmp) . link(tmp, perm) . ...</p>
    <p>ALICE: Intermediate States #3</p>
    <p>System call examined Ordering</p>
    <p>examined</p>
  </div>
  <div class="page">
    <p>File System Study: Results File system</p>
    <p>configuration</p>
    <p>Atomicity Ordering One sector overwrite</p>
    <p>Append content</p>
    <p>Many sector overwrite</p>
    <p>Directory operation</p>
    <p>Overwrite  Any op</p>
    <p>Append  Any op</p>
    <p>Dir-op  Any op</p>
    <p>Append  Rename</p>
    <p>ext2 async  sync</p>
    <p>ext3 writeback    ordered</p>
    <p>data-journal</p>
    <p>ext4</p>
    <p>writeback    ordered</p>
    <p>no-delalloc       data-journal</p>
    <p>btrfs</p>
    <p>xfs default      wsync</p>
    <p>One-sector-overwrite atomicity is due to current hardware, might change with NVMs</p>
  </div>
  <div class="page">
    <p>File System Study: Results File system</p>
    <p>configuration</p>
    <p>Atomicity Ordering One sector overwrite</p>
    <p>Append content</p>
    <p>Many sector overwrite</p>
    <p>Directory operation</p>
    <p>Overwrite  Any op</p>
    <p>Append  Any op</p>
    <p>Dir-op  Any op</p>
    <p>Append  Rename</p>
    <p>ext2 async  sync</p>
    <p>ext3 writeback    ordered</p>
    <p>data-journal</p>
    <p>ext4</p>
    <p>writeback    ordered</p>
    <p>no-delalloc       data-journal</p>
    <p>btrfs</p>
    <p>xfs default      wsync</p>
    <p>File systems patched to obey a particular property</p>
  </div>
  <div class="page">
    <p>Does FS behavior affect applications?</p>
    <p>What FS behaviors are important?</p>
    <p>Is testing for crash vulnerabilities generally helpful?</p>
    <p>Not a goal: Comparing correctness among applications</p>
    <p>Vulnerability Study: Goals</p>
  </div>
  <div class="page">
    <p>ALICE: Technique Application Workload</p>
    <p>System-call Trace</p>
    <p>Explorer</p>
    <p>Crash state #1 (Violates atomicity</p>
    <p>of syscall-1)</p>
    <p>Crash state #2 (Violates ordering of syscall-1 and 2) ...</p>
    <p>Application Checker</p>
    <p>Correct Incorrect</p>
    <p>Crash vulnerability: Re-ordering syscall-1 and 2</p>
    <p>ALICE APM: Abstract Persistence</p>
    <p>Model</p>
  </div>
  <div class="page">
    <p>File systems vary in persistence properties</p>
    <p>Application correctness can vary among file systems!</p>
    <p>Challenge: Validating application correctness without assuming a particular underlying file system</p>
    <p>File System Study: Conclusion</p>
  </div>
  <div class="page">
    <p>Challenge #2: Space Reuse</p>
    <p>File1 Inode</p>
    <p>Data</p>
    <p>Data</p>
    <p>Data Stream 2 (Application 2)</p>
    <p>creat(file2); write(file2, hello); fsync(file2)</p>
  </div>
  <div class="page">
    <p>Challenge #2: Space Reuse</p>
    <p>File1 Inode</p>
    <p>Data</p>
    <p>Data</p>
    <p>Data Stream 1 (Application 1) write(file3,150MB); truncate(file1);</p>
    <p>Stream 2 (Application 2)</p>
  </div>
  <div class="page">
    <p>Challenge #2: Space Reuse</p>
    <p>File1 Inode</p>
    <p>Data</p>
    <p>Data</p>
    <p>Data Inode</p>
    <p>File2 Stream 1 (Application 1) write(file3,150MB); truncate(file1);</p>
    <p>Stream 2 (Application 2)</p>
    <p>creat(file2); 134</p>
  </div>
  <div class="page">
    <p>Challenge #2: Space Reuse</p>
    <p>File1 Inode</p>
    <p>Data</p>
    <p>Data</p>
    <p>Data Inode</p>
    <p>File2 Stream 1 (Application 1) write(file3,150MB); truncate(file1);</p>
    <p>Stream 2 (Application 2)</p>
    <p>creat(file2); write(file2, hello);135</p>
  </div>
  <div class="page">
    <p>Challenge #2: Space Reuse</p>
    <p>File1 Inode</p>
    <p>Data</p>
    <p>Data</p>
    <p>Data Inode</p>
    <p>File2</p>
    <p>Block pointer manipulation shown so far occurs in memory</p>
    <p>Stream 1 (Application 1) write(file3,150MB); truncate(file1);</p>
    <p>Stream 2 (Application 2)</p>
    <p>creat(file2); write(file2, hello);136</p>
  </div>
  <div class="page">
    <p>Challenge #2: Space Reuse</p>
    <p>File1 Inode</p>
    <p>Data</p>
    <p>Data</p>
    <p>Data Inode</p>
    <p>File2</p>
    <p>What if pointer manipulation occurs in different streams?</p>
    <p>Stream 1 (Application 1) write(file3,150MB); truncate(file1);</p>
    <p>Stream 2 (Application 2)</p>
    <p>creat(file2); write(file2, hello);137</p>
  </div>
  <div class="page">
    <p>Challenge #2: Space Reuse</p>
    <p>If only one stream commits, FS consistency will be affectedFile1</p>
    <p>Inode</p>
    <p>Data</p>
    <p>Data</p>
    <p>DataFile2 Inode</p>
    <p>Possible crash state</p>
    <p>Stream 1 (Application 1) write(file3,150MB); truncate(file1);</p>
    <p>Stream 2 (Application 2)</p>
    <p>creat(file2); write(file2, hello); fsync(file2)</p>
  </div>
  <div class="page">
    <p>Each file system behaves differently across a crash - Behavior across crashes are not standardized - Behavior can be divided into atomicity and ordering</p>
    <p>Atomicity of updates might not be maintained - Atomicity of file writes - Other operations: Renaming a file, deleting a file etc.</p>
    <p>Ordering of updates might not be maintained - Writes may reach disk out-of-order</p>
    <p>File-System Behavior</p>
  </div>
</Presentation>
