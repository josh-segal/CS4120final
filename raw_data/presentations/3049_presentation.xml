<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>ASAP: Fast, Approximate Graph Pattern Mining at Scale</p>
    <p>Anand Iyer , Zaoxing Liu , Xin Jin , Shivaram Venkataraman , Vladimir Braverman , Ion Stoica</p>
    <p>UC Berkeley Johns Hopkins University University of Wisconsin &amp; Microsoft</p>
    <p>OSDI, October 10, 2018</p>
  </div>
  <div class="page">
    <p>Graphs popular in big data analytics</p>
    <p>Social networks</p>
  </div>
  <div class="page">
    <p>Graphs popular in big data analytics</p>
    <p>Metabolic network of a single cell organismSocial networks</p>
  </div>
  <div class="page">
    <p>Graphs popular in big data analytics</p>
    <p>Metabolic network of a single cell organismSocial networks</p>
    <p>Tuberculosis</p>
  </div>
  <div class="page">
    <p>Graphs popular in big data analytics</p>
    <p>*The Ubiquity of Large Graphs and Surprising Challenges of Graph Processing ,Sahu et. al, VLDB 2018 (best paper)</p>
    <p>Also popular in traditional enterprises*</p>
  </div>
  <div class="page">
    <p>Graphs popular in big data analytics</p>
    <p>Products and customers</p>
    <p>*The Ubiquity of Large Graphs and Surprising Challenges of Graph Processing ,Sahu et. al, VLDB 2018 (best paper)</p>
    <p>Also popular in traditional enterprises*</p>
    <p>P</p>
    <p>P</p>
    <p>P</p>
    <p>P P</p>
  </div>
  <div class="page">
    <p>Graphs popular in big data analytics</p>
    <p>Products and customers</p>
    <p>*The Ubiquity of Large Graphs and Surprising Challenges of Graph Processing ,Sahu et. al, VLDB 2018 (best paper)</p>
    <p>Transactions and involved entities</p>
    <p>Also popular in traditional enterprises*</p>
    <p>P</p>
    <p>P</p>
    <p>P</p>
    <p>P P</p>
    <p>D</p>
    <p>D</p>
    <p>D</p>
    <p>D D</p>
    <p>W</p>
    <p>W</p>
    <p>D</p>
  </div>
  <div class="page">
    <p>Graphs popular in big data analytics</p>
    <p>Products and customers Which (classes of) products are frequently bought together?</p>
    <p>*The Ubiquity of Large Graphs and Surprising Challenges of Graph Processing ,Sahu et. al, VLDB 2018 (best paper)</p>
    <p>Transactions and involved entities</p>
    <p>Also popular in traditional enterprises*</p>
    <p>P</p>
    <p>P</p>
    <p>P</p>
    <p>P P</p>
    <p>D</p>
    <p>D</p>
    <p>D</p>
    <p>D D</p>
    <p>W</p>
    <p>W</p>
    <p>D</p>
  </div>
  <div class="page">
    <p>Graphs popular in big data analytics</p>
    <p>Products and customers Which (classes of) products are frequently bought together?</p>
    <p>*The Ubiquity of Large Graphs and Surprising Challenges of Graph Processing ,Sahu et. al, VLDB 2018 (best paper)</p>
    <p>Transactions and involved entities</p>
    <p>Also popular in traditional enterprises*</p>
    <p>Small deposits followed by large withdrawal</p>
    <p>P</p>
    <p>P</p>
    <p>P</p>
    <p>P P</p>
    <p>D</p>
    <p>D</p>
    <p>D</p>
    <p>D D</p>
    <p>W</p>
    <p>W</p>
    <p>D</p>
  </div>
  <div class="page">
    <p>Graphs popular in big data analytics</p>
    <p>Products and customers Which (classes of) products are frequently bought together?</p>
    <p>*The Ubiquity of Large Graphs and Surprising Challenges of Graph Processing ,Sahu et. al, VLDB 2018 (best paper)</p>
    <p>Transactions and involved entities</p>
    <p>Also popular in traditional enterprises*</p>
    <p>Small deposits followed by large withdrawal</p>
    <p>P</p>
    <p>P</p>
    <p>P</p>
    <p>P P</p>
    <p>P</p>
    <p>P</p>
    <p>D</p>
    <p>D</p>
    <p>D</p>
    <p>D D</p>
    <p>W</p>
    <p>W</p>
    <p>D</p>
  </div>
  <div class="page">
    <p>Graphs popular in big data analytics</p>
    <p>Products and customers Which (classes of) products are frequently bought together?</p>
    <p>*The Ubiquity of Large Graphs and Surprising Challenges of Graph Processing ,Sahu et. al, VLDB 2018 (best paper)</p>
    <p>Transactions and involved entities</p>
    <p>Also popular in traditional enterprises*</p>
    <p>Small deposits followed by large withdrawal</p>
    <p>P</p>
    <p>P</p>
    <p>P</p>
    <p>P P</p>
    <p>P</p>
    <p>P</p>
    <p>D</p>
    <p>D</p>
    <p>D</p>
    <p>D D</p>
    <p>W</p>
    <p>W</p>
    <p>D</p>
  </div>
  <div class="page">
    <p>Graph Pattern Mining</p>
    <p>Discover structural patterns in the underlying graph</p>
  </div>
  <div class="page">
    <p>Graph Pattern Mining</p>
    <p>Motifs Cliques</p>
    <p>Discover structural patterns in the underlying graph</p>
    <p>Frequent Subgraphs</p>
  </div>
  <div class="page">
    <p>Graph Pattern Mining</p>
    <p>Motifs Cliques</p>
    <p>Discover structural patterns in the underlying graph</p>
    <p>Frequent Subgraphs</p>
    <p>Standard approach: Iterative expansion</p>
  </div>
  <div class="page">
    <p>Graph Pattern Mining</p>
    <p>Motifs Cliques</p>
    <p>Discover structural patterns in the underlying graph</p>
    <p>Frequent Subgraphs</p>
    <p>Standard approach: Iterative expansion</p>
  </div>
  <div class="page">
    <p>Graph Pattern Mining</p>
    <p>Motifs Cliques</p>
    <p>Discover structural patterns in the underlying graph</p>
    <p>Frequent Subgraphs</p>
    <p>Standard approach: Iterative expansion</p>
  </div>
  <div class="page">
    <p>Graph Pattern Mining</p>
    <p>Motifs Cliques</p>
    <p>Discover structural patterns in the underlying graph</p>
    <p>Frequent Subgraphs</p>
    <p>Standard approach: Iterative expansion</p>
  </div>
  <div class="page">
    <p>Graph Pattern Mining</p>
    <p>Motifs Cliques</p>
    <p>Discover structural patterns in the underlying graph</p>
    <p>Frequent SubgraphsHuge intermediate data Quickly intractable in large graphs</p>
    <p>Standard approach: Iterative expansion</p>
  </div>
  <div class="page">
    <p>Graph Pattern Mining</p>
    <p>Motifs Cliques</p>
    <p>Discover structural patterns in the underlying graph</p>
    <p>Frequent SubgraphsHuge intermediate data Quickly intractable in large graphs</p>
    <p>Standard approach: Iterative expansion</p>
    <p>Challenging to mine patterns in large graphs</p>
  </div>
  <div class="page">
    <p>Graph Pattern Mining Lo</p>
    <p>g sc</p>
    <p>al e</p>
    <p># Edges Computation Time</p>
  </div>
  <div class="page">
    <p>Graph Pattern Mining Lo</p>
    <p>g sc</p>
    <p>al e</p>
    <p># Edges Computation Time</p>
    <p>Arabesque (SOSP 15)</p>
  </div>
  <div class="page">
    <p>Graph Pattern Mining</p>
    <p>~1 b</p>
    <p>ill io</p>
    <p>n</p>
    <p>ou rs</p>
    <p>Motifs with size = 3</p>
    <p>Lo g</p>
    <p>sc al</p>
    <p>e</p>
    <p># Edges Computation Time</p>
    <p>Arabesque (SOSP 15)</p>
  </div>
  <div class="page">
    <p>Graph Pattern Mining</p>
    <p>s</p>
    <p>bi lli</p>
    <p>on</p>
    <p>~1 b</p>
    <p>ill io</p>
    <p>n</p>
    <p>ou rs</p>
    <p>Motifs with size = 3</p>
    <p>This work:</p>
    <p>Lo g</p>
    <p>sc al</p>
    <p>e</p>
    <p># Edges Computation Time</p>
    <p>Arabesque (SOSP 15)</p>
  </div>
  <div class="page">
    <p>Graph Pattern Mining</p>
    <p>s</p>
    <p>bi lli</p>
    <p>on</p>
    <p>~1 b</p>
    <p>ill io</p>
    <p>n</p>
    <p>ou rs</p>
    <p>Motifs with size = 3</p>
    <p>This work:</p>
    <p>Lo g</p>
    <p>sc al</p>
    <p>e</p>
    <p># Edges Computation Time</p>
    <p>Arabesque (SOSP 15)</p>
  </div>
  <div class="page">
    <p>Graph Pattern Mining</p>
    <p>s</p>
    <p>bi lli</p>
    <p>on</p>
    <p>~1 b</p>
    <p>ill io</p>
    <p>n</p>
    <p>ou rs</p>
    <p>Motifs with size = 3</p>
    <p>This work:</p>
    <p>Lo g</p>
    <p>sc al</p>
    <p>e</p>
    <p># Edges Computation Time</p>
    <p>Arabesque (SOSP 15)</p>
  </div>
  <div class="page">
    <p>Graph Pattern Mining</p>
    <p>s</p>
    <p>bi lli</p>
    <p>on</p>
    <p>~1 b</p>
    <p>ill io</p>
    <p>n</p>
    <p>ou rs</p>
    <p>Motifs with size = 3</p>
    <p>This work:</p>
    <p>Lo g</p>
    <p>sc al</p>
    <p>e</p>
    <p># Edges Computation Time</p>
    <p>Arabesque (SOSP 15)</p>
  </div>
  <div class="page">
    <p>Many mining tasks do not need exact answers</p>
  </div>
  <div class="page">
    <p>Leverage approximation for pattern mining</p>
    <p>Many mining tasks do not need exact answers</p>
  </div>
  <div class="page">
    <p>General approach: Apply algorithm on subset(s) (sample) of the input data</p>
    <p>Approximate Analytics</p>
  </div>
  <div class="page">
    <p>General approach: Apply algorithm on subset(s) (sample) of the input data</p>
    <p>Approximate Analytics</p>
    <p>graph</p>
  </div>
  <div class="page">
    <p>General approach: Apply algorithm on subset(s) (sample) of the input data</p>
    <p>Approximate Analytics</p>
    <p>edge sampling (p=0.5)</p>
    <p>graph</p>
  </div>
  <div class="page">
    <p>General approach: Apply algorithm on subset(s) (sample) of the input data</p>
    <p>Approximate Analytics</p>
    <p>edge sampling (p=0.5)</p>
    <p>graph</p>
    <p>e = 1</p>
    <p>triangle counting</p>
  </div>
  <div class="page">
    <p>General approach: Apply algorithm on subset(s) (sample) of the input data</p>
    <p>Approximate Analytics</p>
    <p>edge sampling (p=0.5)</p>
    <p>graph</p>
    <p>e = 1</p>
    <p>triangle counting</p>
    <p>result</p>
    <p>$ % 2 = 2</p>
  </div>
  <div class="page">
    <p>Answer: 10</p>
    <p>General approach: Apply algorithm on subset(s) (sample) of the input data</p>
    <p>Approximate Analytics</p>
    <p>edge sampling (p=0.5)</p>
    <p>graph</p>
    <p>e = 1</p>
    <p>triangle counting</p>
    <p>result</p>
    <p>$ % 2 = 2</p>
  </div>
  <div class="page">
    <p>Answer: 10</p>
    <p>General approach: Apply algorithm on subset(s) (sample) of the input data</p>
    <p>Approximate Analytics</p>
    <p>edge sampling (p=0.5)</p>
    <p>graph</p>
    <p>e = 1</p>
    <p>triangle counting</p>
    <p>result</p>
    <p>$ % 2 = 2</p>
    <p>Sp ee du p</p>
    <p>EdgesDropped (%)</p>
    <p>Error Speedup</p>
  </div>
  <div class="page">
    <p>Answer: 10</p>
    <p>General approach: Apply algorithm on subset(s) (sample) of the input data</p>
    <p>Approximate Analytics</p>
    <p>edge sampling (p=0.5)</p>
    <p>graph</p>
    <p>e = 1</p>
    <p>triangle counting</p>
    <p>result</p>
    <p>$ % 2 = 2</p>
    <p>Applying exact algorithm on sampled graph(s) not the right approach for pattern mining</p>
  </div>
  <div class="page">
    <p>ASAP leverages existing work in graph approximation theory and makes it practical</p>
  </div>
  <div class="page">
    <p>Graph Pattern Mining Theory Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>Graph Pattern Mining Theory</p>
    <p>graph</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>E0</p>
    <p>Graph Pattern Mining Theory</p>
    <p>graph</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>E0</p>
    <p>Graph Pattern Mining Theory</p>
    <p>graph</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>E0</p>
    <p>Graph Pattern Mining Theory</p>
    <p>graph</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>E0</p>
    <p>Graph Pattern Mining Theory</p>
    <p>graph</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>E0</p>
    <p>Graph Pattern Mining Theory</p>
    <p>graph</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>E0</p>
    <p>Graph Pattern Mining Theory</p>
    <p>graph</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>E0</p>
    <p>Graph Pattern Mining Theory</p>
    <p>graph</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>E0</p>
    <p>Graph Pattern Mining Theory</p>
    <p>graph</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>E0</p>
    <p>Graph Pattern Mining Theory</p>
    <p>graph</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>E0</p>
    <p>Graph Pattern Mining Theory</p>
    <p>graph</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>E0</p>
    <p>Graph Pattern Mining Theory</p>
    <p>graph</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>! = 1 10</p>
    <p>E0</p>
    <p>Graph Pattern Mining Theory</p>
    <p>graph</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>! = 1 10</p>
    <p>E0</p>
    <p>Graph Pattern Mining Theory</p>
    <p>graph</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>'( = 40</p>
    <p>Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>! = 1 10</p>
    <p>E0</p>
    <p>Graph Pattern Mining Theory</p>
    <p>graph</p>
    <p>E1</p>
    <p>E2</p>
    <p>E3</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>'( = 40</p>
    <p>Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>! = 1 10</p>
    <p>E0</p>
    <p>Graph Pattern Mining Theory</p>
    <p>graph</p>
    <p>E1</p>
    <p>E2</p>
    <p>E3</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>'( = 40</p>
    <p>result</p>
    <p>-./ '+ = 10</p>
    <p>'/ = 0</p>
    <p>'0 = 0</p>
    <p>'1 = 0</p>
    <p>Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>! = 1 10</p>
    <p>E0</p>
    <p>Graph Pattern Mining Theory</p>
    <p>estimator (r=4)</p>
    <p>neighborhood sampling</p>
    <p>graph</p>
    <p>E1</p>
    <p>E2</p>
    <p>E3</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>'( = 40</p>
    <p>result</p>
    <p>-./ '+ = 10</p>
    <p>'/ = 0</p>
    <p>'0 = 0</p>
    <p>'1 = 0</p>
    <p>Pavan et al. Counting and sampling triangles from a graph stream, VLDB 2013</p>
    <p>Sample instances of the pattern from the graph stream</p>
  </div>
  <div class="page">
    <p>A Swift Approximate Pattern miner</p>
  </div>
  <div class="page">
    <p>graphA.patterns(a-&gt;b-&gt;c, 100s) graphB.fourClique(5.0%,95.0%)</p>
  </div>
  <div class="page">
    <p>G ra</p>
    <p>ph s</p>
    <p>st or</p>
    <p>ed o</p>
    <p>n di</p>
    <p>sk</p>
    <p>or m</p>
    <p>ai n</p>
    <p>m em</p>
    <p>or y</p>
    <p>graphA.patterns(a-&gt;b-&gt;c, 100s) graphB.fourClique(5.0%,95.0%)</p>
    <p>Apache Spark</p>
    <p>Generalized Approximate Pattern Mining</p>
    <p>A Swift Approximate Pattern miner</p>
  </div>
  <div class="page">
    <p>G ra</p>
    <p>ph s</p>
    <p>st or</p>
    <p>ed o</p>
    <p>n di</p>
    <p>sk</p>
    <p>or m</p>
    <p>ai n</p>
    <p>m em</p>
    <p>or y</p>
    <p>graphA.patterns(a-&gt;b-&gt;c, 100s) graphB.fourClique(5.0%,95.0%)</p>
    <p>Estimator Count Selection 3 Apache Spark</p>
    <p>Generalized Approximate Pattern Mining</p>
    <p>A Swift Approximate Pattern miner</p>
  </div>
  <div class="page">
    <p>G ra</p>
    <p>ph s</p>
    <p>st or</p>
    <p>ed o</p>
    <p>n di</p>
    <p>sk</p>
    <p>or m</p>
    <p>ai n</p>
    <p>m em</p>
    <p>or y</p>
    <p>graphA.patterns(a-&gt;b-&gt;c, 100s) graphB.fourClique(5.0%,95.0%)</p>
    <p>Estimator Count Selection 3</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a te</p>
    <p>( %</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a</p>
    <p>te (</p>
    <p>% )</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>Apache Spark</p>
    <p>Generalized Approximate Pattern Mining</p>
    <p>A Swift Approximate Pattern miner</p>
  </div>
  <div class="page">
    <p>G ra</p>
    <p>ph s</p>
    <p>st or</p>
    <p>ed o</p>
    <p>n di</p>
    <p>sk</p>
    <p>or m</p>
    <p>ai n</p>
    <p>m em</p>
    <p>or y</p>
    <p>graphA.patterns(a-&gt;b-&gt;c, 100s) graphB.fourClique(5.0%,95.0%)</p>
    <p>Estimator Count Selection 3</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a te</p>
    <p>( %</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a</p>
    <p>te (</p>
    <p>% )</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>rr or</p>
    <p>-L at</p>
    <p>en cy</p>
    <p>P ro</p>
    <p>fil e</p>
    <p>(E LP</p>
    <p>)</p>
    <p>Apache Spark</p>
    <p>Generalized Approximate Pattern Mining</p>
    <p>A Swift Approximate Pattern miner</p>
  </div>
  <div class="page">
    <p>G ra</p>
    <p>ph s</p>
    <p>st or</p>
    <p>ed o</p>
    <p>n di</p>
    <p>sk</p>
    <p>or m</p>
    <p>ai n</p>
    <p>m em</p>
    <p>or y</p>
    <p>graphA.patterns(a-&gt;b-&gt;c, 100s) graphB.fourClique(5.0%,95.0%)</p>
    <p>Estimator Count Selection 3</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a te</p>
    <p>( %</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a</p>
    <p>te (</p>
    <p>% )</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>Estimates:{error: &lt;5%, time: 95s} Estimates:{error: &lt;5%, time: 60s}</p>
    <p>E rr</p>
    <p>or -L</p>
    <p>at en</p>
    <p>cy P</p>
    <p>ro fil</p>
    <p>e (E</p>
    <p>LP )</p>
    <p>Apache Spark</p>
    <p>Generalized Approximate Pattern Mining</p>
    <p>A Swift Approximate Pattern miner</p>
  </div>
  <div class="page">
    <p>G ra</p>
    <p>ph s</p>
    <p>st or</p>
    <p>ed o</p>
    <p>n di</p>
    <p>sk</p>
    <p>or m</p>
    <p>ai n</p>
    <p>m em</p>
    <p>or y</p>
    <p>graphA.patterns(a-&gt;b-&gt;c, 100s) graphB.fourClique(5.0%,95.0%)</p>
    <p>Estimator Count Selection 3</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a te</p>
    <p>( %</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a</p>
    <p>te (</p>
    <p>% )</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>Estimates:{error: &lt;5%, time: 95s} Estimates:{error: &lt;5%, time: 60s}</p>
    <p>count: 21453 +/- 14 confidence: 95%,</p>
    <p>time: 92s</p>
    <p>Embeddings (optional)</p>
    <p>E rr</p>
    <p>or -L</p>
    <p>at en</p>
    <p>cy P</p>
    <p>ro fil</p>
    <p>e (E</p>
    <p>LP )</p>
    <p>Apache Spark</p>
    <p>Generalized Approximate Pattern Mining</p>
    <p>A Swift Approximate Pattern miner</p>
  </div>
  <div class="page">
    <p>Graph updates</p>
    <p>G ra</p>
    <p>ph s</p>
    <p>st or</p>
    <p>ed o</p>
    <p>n di</p>
    <p>sk</p>
    <p>or m</p>
    <p>ai n</p>
    <p>m em</p>
    <p>or y</p>
    <p>graphA.patterns(a-&gt;b-&gt;c, 100s) graphB.fourClique(5.0%,95.0%)</p>
    <p>Estimator Count Selection 3</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a te</p>
    <p>( %</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a</p>
    <p>te (</p>
    <p>% )</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>Estimates:{error: &lt;5%, time: 95s} Estimates:{error: &lt;5%, time: 60s}</p>
    <p>count: 21453 +/- 14 confidence: 95%,</p>
    <p>time: 92s</p>
    <p>Embeddings (optional)</p>
    <p>E rr</p>
    <p>or -L</p>
    <p>at en</p>
    <p>cy P</p>
    <p>ro fil</p>
    <p>e (E</p>
    <p>LP )</p>
    <p>Apache Spark</p>
    <p>Generalized Approximate Pattern Mining</p>
    <p>A Swift Approximate Pattern miner</p>
  </div>
  <div class="page">
    <p>E rr</p>
    <p>or -L</p>
    <p>at en</p>
    <p>cy P</p>
    <p>ro fil</p>
    <p>e (E</p>
    <p>LP )</p>
    <p>Apache Spark</p>
    <p>Generalized Approximate Pattern Mining</p>
    <p>graphA.patterns(a-&gt;b-&gt;c, 100s) graphB.fourClique(5.0%,95.0%)</p>
    <p>Estimator Count Selection</p>
    <p>G ra</p>
    <p>ph s</p>
    <p>st or</p>
    <p>ed o</p>
    <p>n di</p>
    <p>sk</p>
    <p>or m</p>
    <p>ai n</p>
    <p>m em</p>
    <p>or y</p>
    <p>Estimates:{error: &lt;5%, time: 95s} Estimates:{error: &lt;5%, time: 60s}</p>
    <p>Graph updates</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a te</p>
    <p>( %</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a</p>
    <p>te (</p>
    <p>% )</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>count: 21453 +/- 14 confidence: 95%,</p>
    <p>time: 92s</p>
    <p>Embeddings (optional)</p>
  </div>
  <div class="page">
    <p>E rr</p>
    <p>or -L</p>
    <p>at en</p>
    <p>cy P</p>
    <p>ro fil</p>
    <p>e (E</p>
    <p>LP )</p>
    <p>Apache Spark</p>
    <p>Generalized Approximate Pattern Mining</p>
    <p>graphA.patterns(a-&gt;b-&gt;c, 100s) graphB.fourClique(5.0%,95.0%)</p>
    <p>Estimator Count Selection</p>
    <p>G ra</p>
    <p>ph s</p>
    <p>st or</p>
    <p>ed o</p>
    <p>n di</p>
    <p>sk</p>
    <p>or m</p>
    <p>ai n</p>
    <p>m em</p>
    <p>or y</p>
    <p>Estimates:{error: &lt;5%, time: 95s} Estimates:{error: &lt;5%, time: 60s}</p>
    <p>Graph updates</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a te</p>
    <p>( %</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a</p>
    <p>te (</p>
    <p>% )</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>count: 21453 +/- 14 confidence: 95%,</p>
    <p>time: 92s</p>
    <p>Embeddings (optional)</p>
    <p>Contributions:  Extends neighborhood sampling to general patterns  Provides a unified API  Applies approximate pattern mining in distributed settings</p>
  </div>
  <div class="page">
    <p>Generalized Approximate Pattern Mining</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
    <p>Developers write a single estimator using ASAPs API</p>
  </div>
  <div class="page">
    <p>Generalized Approximate Pattern Mining</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
    <p>Developers write a single estimator using ASAPs API</p>
  </div>
  <div class="page">
    <p>Generalized Approximate Pattern Mining</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
    <p>Developers write a single estimator using ASAPs API</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
    <p>!&quot; = 40</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
    <p>Sampling phase fixes the vertices for a particular instance of a pattern and closing phase waits for remaining edges</p>
    <p>!&quot; = 40</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
    <p>Sampling phase fixes the vertices for a particular instance of a pattern and closing phase waits for remaining edgesASAP computes the right expectations, runs many</p>
    <p>instances of the estimator and aggregates results</p>
    <p>!&quot; = 40</p>
  </div>
  <div class="page">
    <p>Using ASAPs API</p>
    <p>edge stream: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)</p>
    <p>Under submission. Please do not distribute.</p>
    <p>API Description</p>
    <p>sampleVertex: ()!(v,p) Uniformly sample one vertex from the graph. SampleEdge: ()!(e,p) Uniformly sample one edge from the graph. ConditionalSampleVertex: (subgraph)!(v,p) Uniformly sample a vertex that appears after a sampled</p>
    <p>subgraph. ConditionalSampleEdge: (subgraph)!(e,p) Uniformly sample an edge that is adjacent to the given</p>
    <p>subgraph and comes after the subgraph in the order. ConditionalClose: (subgraph, subgraph)!bool ean Given a sampled subgraph, check if another subgraph</p>
    <p>that appears later in the order can be formed.</p>
    <p>Table 1: ASAPs Approximate Pattern Mining API. SampleThreeNodeChain</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0</p>
    <p>else return 1/(p1.p2)</p>
    <p>SampleTriangle</p>
    <p>SampleFourCliqueType1</p>
    <p>(e1, p1) = SampleEdge() (e2, p2) = ConditionalSampleEdge(Subgraph(e1)) if (!e2) return 0 (e3, p3) = ConditionalSampleEdge(Subgraph(e1, e2)) if (!e3) return 0 subgraph1 = Subgraph(e1,e2,e3) subgraph2 = FourClique(e1,e2,e3)-subgraph1 if (ConditionalClose(subgraph1,subgraph2)) return 1/(p1.p2.p3)</p>
    <p>else return 0</p>
    <p>SampleFourCliqueType2</p>
    <p>The programming API provides five functions as shown in Table 1. We describe each function in detail and illustrate how to use these functions to sample patterns:  SampleVertex uniformly samples one vertex from the</p>
    <p>graph. It takes no input, and outputs v and p, where v is the sampled vertex, and p is the probability that sampled v, which is the inverse of the number of vertices of the graph.</p>
    <p>SampleEdge uniformly samples one edge from the graph. Similarly to SampleVertex, it also takes no input, and outputs e and p, where e is the sampled edge, and p is the sampling probability, which is the inverse of the number of edges of the graph.</p>
    <p>ConditionalSampleVertex conditionally samples one vertex from the graph, given subgr aph as input. It outputs v and p, where v is the sampled vertex and p is the probability to sample v given that subgr aph is already sampled.</p>
    <p>ConditionalSampleEdge(subgraph) conditionally samples one edge adjacent to subgr aph from the graph, given that subgr aph is already sampled. It outputs e and p, where e is the sampled edge and p is the probability to sample e given subgr aph.</p>
    <p>ConditionalClose(subgraph, subgraph) waits for edges that appear after the first subgr aph to form the second subgr aph. It takes the two subgraphs as input and output yes/no, which is a boolean value indicating whether the second subgr aph can be formed. This function is usually used as the final step to sample a pattern where all nodes of a possible instance have been fixed and the sampling process only awaits the additional edges to form the pattern.</p>
    <p>Developers use the programming API to write approximation algorithms for graph pattern mining. We describe a few use cases to illustrate the usage of the programming API, which is shown in Figure 7. The use cases include three representative graph patterns: three node chain, triangle, and four clique.</p>
    <p>Chain. Using our API to write a sampling function for counting three node chains is straightforward. It only includes two steps. In the first step, we use SampleEdge () to uniformly sample one edge from the graph (line 1). In the second step, given the first sampled edge, we use ConditionalSampleEdge (subgraph) to find the second</p>
    <p>See paper for more examples &amp; proof</p>
    <p>Sampling phase fixes the vertices for a particular instance of a pattern and closing phase waits for remaining edgesASAP computes the right expectations, runs many</p>
    <p>instances of the estimator and aggregates results</p>
    <p>!&quot; = 40</p>
  </div>
  <div class="page">
    <p>Applying to Distributed Settings</p>
    <p>graph</p>
  </div>
  <div class="page">
    <p>Applying to Distributed Settings</p>
    <p>graph</p>
    <p>subgraph 0</p>
    <p>partial count c0 (using r estimators)</p>
    <p>subgraph 1</p>
    <p>partial count c1 (using r estimators)</p>
    <p>subgraph 2</p>
    <p>partial count c2 (using r estimators)</p>
  </div>
  <div class="page">
    <p>Applying to Distributed Settings</p>
    <p>graph</p>
    <p>map: w(=3) workers</p>
    <p>subgraph 0</p>
    <p>partial count c0 (using r estimators)</p>
    <p>subgraph 1</p>
    <p>partial count c1 (using r estimators)</p>
    <p>subgraph 2</p>
    <p>partial count c2 (using r estimators)</p>
  </div>
  <div class="page">
    <p>Applying to Distributed Settings</p>
    <p>graph</p>
    <p>map: w(=3) workers</p>
    <p>subgraph 0</p>
    <p>partial count c0 (using r estimators)</p>
    <p>subgraph 1</p>
    <p>partial count c1 (using r estimators)</p>
    <p>subgraph 2</p>
    <p>partial count c2 (using r estimators)</p>
  </div>
  <div class="page">
    <p>Applying to Distributed Settings</p>
    <p>graph ! &quot;#$</p>
    <p>%&amp;' (&quot;</p>
    <p>map: w(=3) workers</p>
    <p>subgraph 0</p>
    <p>partial count c0 (using r estimators)</p>
    <p>subgraph 1</p>
    <p>partial count c1 (using r estimators)</p>
    <p>subgraph 2</p>
    <p>partial count c2 (using r estimators)</p>
  </div>
  <div class="page">
    <p>Applying to Distributed Settings</p>
    <p>graph ! &quot;#$</p>
    <p>%&amp;' (&quot;</p>
    <p>map: w(=3) workers reduce</p>
    <p>subgraph 0</p>
    <p>partial count c0 (using r estimators)</p>
    <p>subgraph 1</p>
    <p>partial count c1 (using r estimators)</p>
    <p>subgraph 2</p>
    <p>partial count c2 (using r estimators)</p>
  </div>
  <div class="page">
    <p>Applying to Distributed Settings</p>
    <p>graph ! &quot;#$</p>
    <p>%&amp;' (&quot;</p>
    <p>map: w(=3) workers reduce</p>
    <p>subgraph 0</p>
    <p>partial count c0 (using r estimators)</p>
    <p>subgraph 1</p>
    <p>partial count c1 (using r estimators)</p>
    <p>subgraph 2</p>
    <p>partial count c2 (using r estimators)</p>
    <p>Random Vertex-cut Partitioning</p>
  </div>
  <div class="page">
    <p>Applying to Distributed Settings</p>
    <p>graph ! &quot;#$</p>
    <p>%&amp;' (&quot;</p>
    <p>map: w(=3) workers reduce</p>
    <p>subgraph 0</p>
    <p>partial count c0 (using r estimators)</p>
    <p>subgraph 1</p>
    <p>partial count c1 (using r estimators)</p>
    <p>subgraph 2</p>
    <p>partial count c2 (using r estimators)</p>
    <p>)(+)</p>
    <p>Random Vertex-cut Partitioning</p>
  </div>
  <div class="page">
    <p>Applying to Distributed Settings</p>
    <p>graph ! &quot;#$</p>
    <p>%&amp;' (&quot;</p>
    <p>map: w(=3) workers reduce</p>
    <p>subgraph 0</p>
    <p>partial count c0 (using r estimators)</p>
    <p>subgraph 1</p>
    <p>partial count c1 (using r estimators)</p>
    <p>subgraph 2</p>
    <p>partial count c2 (using r estimators)</p>
    <p>Upper bounds on f(w) can be proved using Hajnal-Szemerdi theorem</p>
    <p>)(+)</p>
    <p>Random Vertex-cut Partitioning</p>
  </div>
  <div class="page">
    <p>E rr</p>
    <p>or -L</p>
    <p>at en</p>
    <p>cy P</p>
    <p>ro fil</p>
    <p>e (E</p>
    <p>LP )</p>
    <p>Apache Spark</p>
    <p>Generalized Approximate Pattern Mining</p>
    <p>graphA.patterns(a-&gt;b-&gt;c, 100s) graphB.fourClique(5.0%,95.0%)</p>
    <p>Estimator Count Selection</p>
    <p>G ra</p>
    <p>ph s</p>
    <p>st or</p>
    <p>ed o</p>
    <p>n di</p>
    <p>sk</p>
    <p>or m</p>
    <p>ai n</p>
    <p>m em</p>
    <p>or y</p>
    <p>Estimates:{error: &lt;5%, time: 95s} Estimates:{error: &lt;5%, time: 60s}</p>
    <p>Graph updates</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a te</p>
    <p>( %</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a</p>
    <p>te (</p>
    <p>% )</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>count: 21453 +/- 14 confidence: 95%,</p>
    <p>time: 92s</p>
    <p>Embeddings (optional)</p>
  </div>
  <div class="page">
    <p>E rr</p>
    <p>or -L</p>
    <p>at en</p>
    <p>cy P</p>
    <p>ro fil</p>
    <p>e (E</p>
    <p>LP )</p>
    <p>Apache Spark</p>
    <p>Generalized Approximate Pattern Mining</p>
    <p>graphA.patterns(a-&gt;b-&gt;c, 100s) graphB.fourClique(5.0%,95.0%)</p>
    <p>Estimator Count Selection</p>
    <p>G ra</p>
    <p>ph s</p>
    <p>st or</p>
    <p>ed o</p>
    <p>n di</p>
    <p>sk</p>
    <p>or m</p>
    <p>ai n</p>
    <p>m em</p>
    <p>or y</p>
    <p>Estimates:{error: &lt;5%, time: 95s} Estimates:{error: &lt;5%, time: 60s}</p>
    <p>Graph updates</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a te</p>
    <p>( %</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>R u</p>
    <p>n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a</p>
    <p>te (</p>
    <p>% )</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
    <p>count: 21453 +/- 14 confidence: 95%,</p>
    <p>time: 92s</p>
    <p>Embeddings (optional)</p>
    <p>Contribution:  Novel way to build ELP very fast without the need to know</p>
    <p>the ground truth or running mining on the full graph.</p>
  </div>
  <div class="page">
    <p>Building Error-Latency Profile Given a time / error bound, how many estimators should ASAP use?</p>
  </div>
  <div class="page">
    <p>Building Error-Latency Profile Given a time / error bound, how many estimators should ASAP use?</p>
    <p>Number of estimators</p>
    <p>Ti m</p>
    <p>e</p>
    <p>Time vs Estimators</p>
  </div>
  <div class="page">
    <p>Building Error-Latency Profile Given a time / error bound, how many estimators should ASAP use?</p>
    <p>Number of estimators</p>
    <p>Ti m</p>
    <p>e</p>
    <p>Time vs Estimators</p>
    <p>Er ro</p>
    <p>r</p>
    <p>Number of estimators</p>
    <p>Error vs Estimators</p>
  </div>
  <div class="page">
    <p>Building Estimators vs Time Profile Time complexity linear in number of estimators</p>
  </div>
  <div class="page">
    <p>Building Estimators vs Time Profile</p>
    <p>R u n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph</p>
    <p>Time complexity linear in number of estimators</p>
  </div>
  <div class="page">
    <p>Building Estimators vs Time Profile</p>
    <p>R u n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph</p>
    <p>Time complexity linear in number of estimators</p>
    <p>ASAP sets a profiling cost and picks maximum points within the budget</p>
  </div>
  <div class="page">
    <p>Building Estimators vs Time Profile</p>
    <p>R u n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph</p>
    <p>Time complexity linear in number of estimators</p>
    <p>R u n ti m</p>
    <p>e (</p>
    <p>m in</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
  </div>
  <div class="page">
    <p>Building Estimators vs Error Profile</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a te</p>
    <p>( %</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph</p>
    <p>Error complexity non-linear in number of estimators</p>
  </div>
  <div class="page">
    <p>Building Estimators vs Error Profile</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a te</p>
    <p>( %</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph</p>
    <p>Error complexity non-linear in number of estimators</p>
    <p>Key idea: Use a very small sample of the graph to build the ELP  Chernoff analysis provides a loose upper bound on the</p>
    <p>number of estimators.  In small graphs, a large number of estimators can get us very</p>
    <p>close to ground truth.</p>
  </div>
  <div class="page">
    <p>Building Estimators vs Error Profile</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a te</p>
    <p>( %</p>
    <p>)</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph</p>
    <p>Error complexity non-linear in number of estimators</p>
    <p>E rr</p>
    <p>o r</p>
    <p>R a</p>
    <p>te (</p>
    <p>% )</p>
    <p>No. of Estimators</p>
    <p>Twitter Graph Profiling</p>
  </div>
  <div class="page">
    <p>Advanced Mining Predicate Matching  Find patterns where vertices are of type electronics  ASAP allows simple edge and vertex predicates</p>
    <p>Motif Mining  Some patterns are building blocks for other patterns  ASAP caches state of the estimators and reuses them</p>
    <p>Accuracy Refinement  Users may require more accurate answer later  ASAP can checkpoint and reuse estimators</p>
    <p>More details in the paper</p>
  </div>
  <div class="page">
    <p>Implementation &amp; Evaluation  Implemented on Apache Spark</p>
    <p>Not limited to it, only relies on simple dataflow operators</p>
    <p>Evaluated in a 16 node cluster  Twitter: 1.47B edges  Friendster: 1.8B edges  UK: 3.73B edges</p>
    <p>Comparison using representative patterns:  3 (2 patterns), 4 (6 patterns) and 5 motifs (21 patterns)</p>
  </div>
  <div class="page">
    <p>Performance on Small Graphs</p>
    <p>CiteSeer Mico Youtube LiveJournal</p>
    <p>Ti m</p>
    <p>e (s</p>
    <p>)</p>
    <p>Arabesque ASAP</p>
  </div>
  <div class="page">
    <p>Performance on Small Graphs</p>
    <p>CiteSeer Mico Youtube LiveJournal</p>
    <p>Ti m</p>
    <p>e (s</p>
    <p>)</p>
    <p>Arabesque ASAP</p>
  </div>
  <div class="page">
    <p>Performance on Small Graphs</p>
    <p>CiteSeer Mico Youtube LiveJournal</p>
    <p>Ti m</p>
    <p>e (s</p>
    <p>)</p>
    <p>Arabesque ASAP</p>
  </div>
  <div class="page">
    <p>Large Graphs &amp; Simple Patterns</p>
    <p>Ti m</p>
    <p>e (m</p>
    <p>in )</p>
    <p># Edges (Billions)</p>
    <p>Arabesque ASAP</p>
  </div>
  <div class="page">
    <p>Large Graphs &amp; Simple Patterns</p>
    <p>Ti m</p>
    <p>e (m</p>
    <p>in )</p>
    <p># Edges (Billions)</p>
    <p>Proprietary graph, 20 machines (256GB each)</p>
    <p>Arabesque ASAP</p>
  </div>
  <div class="page">
    <p>Large Graphs &amp; Simple Patterns</p>
    <p>Ti m</p>
    <p>e (m</p>
    <p>in )</p>
    <p># Edges (Billions)</p>
    <p>Proprietary graph, 20 machines (256GB each)</p>
    <p>Twitter Friendster UK</p>
    <p>Arabesque ASAP</p>
  </div>
  <div class="page">
    <p>Large Graphs &amp; Simple Patterns</p>
    <p>Ti m</p>
    <p>e (m</p>
    <p>in )</p>
    <p># Edges (Billions)</p>
    <p>Proprietary graph, 20 machines (256GB each)</p>
    <p>Twitter Friendster UK</p>
    <p>Arabesque ASAP</p>
  </div>
  <div class="page">
    <p>Large Graphs &amp; Complex Patterns</p>
    <p>Twitter UK</p>
    <p>Ti m</p>
    <p>e (m</p>
    <p>in )</p>
  </div>
  <div class="page">
    <p>Large Graphs &amp; Complex Patterns</p>
    <p>Twitter UK Ti</p>
    <p>m e</p>
    <p>(m in</p>
    <p>)</p>
    <p>Twitter UK</p>
    <p>Ti m</p>
    <p>e (m</p>
    <p>in )</p>
  </div>
  <div class="page">
    <p>Summary  Pattern mining important &amp; challenging problem</p>
    <p>Applications in many domains</p>
    <p>ASAP uses approximation for fast pattern mining  Leverages graph mining theory &amp; makes it practical  Simple API for developers</p>
    <p>ASAP outperforms existing solutions  Can handle much larger graphs with fewer resources</p>
    <p>http://www.cs.berkeley.edu/~api api@cs.berkeley.edu</p>
  </div>
</Presentation>
