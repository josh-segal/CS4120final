<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>POKING HOLES IN INFORMATION HIDING</p>
    <p>Angelos Oikonomopoulos Elias Athanasopoulos</p>
    <p>Herbert Bos Cristiano Giuffrida</p>
    <p>Vrije Universiteit Amsterdam</p>
  </div>
  <div class="page">
    <p>Teaser</p>
    <p>Break ideal information hiding in seconds</p>
    <p>Few probes, typically no crashes</p>
    <p>Primitives pervasive in server programs</p>
  </div>
  <div class="page">
    <p>ASLR today  No longer a strong defense by itself  Plays a pivotal role in powerful new defenses:</p>
    <p>Shadow stacks  Secure heap allocators  CPI (OSDI 14)  StackArmor (NDSS 15)  ASLRguard (CCS 15)  SafeStack (clang/llvm)</p>
  </div>
  <div class="page">
    <p>ASLR 2001</p>
    <p>Finegrained ASLR 2006</p>
    <p>Pointerfree Information hiding</p>
    <p>Thread spraying 2016</p>
  </div>
  <div class="page">
    <p>Ideal information hiding</p>
    <p>The hidden area:  Has no pointers in memory referring to it  Is as small as possible  Does not grow during the execution</p>
  </div>
  <div class="page">
    <p>Ideal information hiding</p>
    <p>The hidden area:  Has no pointers in memory referring to it  Is as small as possible  Does not grow during the execution</p>
    <p>Threat model: arbitrary RW is okay!</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Lets have a look</p>
    <p>at a Linux (PIE)</p>
    <p>Address Space</p>
  </div>
  <div class="page">
    <p>code</p>
    <p>PC</p>
    <p>stack</p>
    <p>SP</p>
    <p>heap Holes</p>
    <p>mmap</p>
  </div>
  <div class="page">
    <p>code</p>
    <p>PC</p>
    <p>stack</p>
    <p>SP</p>
    <p>heap Holes</p>
    <p>mmap</p>
    <p>Hidden area</p>
  </div>
  <div class="page">
    <p>code</p>
    <p>PC</p>
    <p>stack</p>
    <p>SP</p>
    <p>heap</p>
    <p>mmap</p>
    <p>A</p>
    <p>B</p>
    <p>C</p>
  </div>
  <div class="page">
    <p>Lets not look for the hidden area</p>
    <p>but for the holes!</p>
  </div>
  <div class="page">
    <p>Even if we remove all pointers There is one pointer left:</p>
    <p>Then:  Leak size of the largest hole  Infer hidden area location</p>
    <p>Not stored in user memory  Cant leak directly</p>
    <p>However, we can sidechannel the kernel to spill the beans!</p>
    <p>the size of the hole itself.</p>
  </div>
  <div class="page">
    <p>So look for the holes</p>
    <p>Intuition:  repeatedly allocate large chunks of memory of size L until we find the right size</p>
    <p>Succeeds! Sizeof(Hole)  L</p>
  </div>
  <div class="page">
    <p>So look for the holes</p>
    <p>Intuition:  repeatedly allocate large chunks of memory of size L until we find the right size</p>
    <p>Too large, alloc fails! Sizeof(Hole) &lt; L</p>
  </div>
  <div class="page">
    <p>So look for the holes</p>
    <p>Intuition:  repeatedly allocate large chunks of memory of size L until we find the right size</p>
    <p>Succeeds! Sizeof(Hole)  L</p>
  </div>
  <div class="page">
    <p>So look for the holes</p>
    <p>Intuition:  repeatedly allocate large chunks of memory of size L until we find the right size</p>
    <p>Too large, alloc fails! Sizeof(Hole) &lt; L</p>
  </div>
  <div class="page">
    <p>So look for the holes</p>
    <p>Intuition:  repeatedly allocate large chunks of memory of size L until we find the right size</p>
    <p>Nailed it!</p>
    <p>Binary search</p>
  </div>
  <div class="page">
    <p>Ephemeral Allocation Primitive</p>
    <p>For each probe (i.e., server request):</p>
    <p>Strategy: allocation+deallocation, repeat</p>
    <p>ptr = malloc(size); ...</p>
    <p>free(ptr); reply(result);</p>
  </div>
  <div class="page">
    <p>Ephemeral Allocation Primitive</p>
    <p>Say: Single hidden area is in A (*) Hidden area splits A in two L is the largest hole in AS We can find L via binary search</p>
    <p>L</p>
    <p>S H</p>
    <p>* See paper for generalization</p>
  </div>
  <div class="page">
    <p>Of course we still miss 1 bit of entropy dont know if large hole is above or below area</p>
    <p>S</p>
    <p>L</p>
    <p>L</p>
    <p>S</p>
  </div>
  <div class="page">
    <p>Would be great if we could solve this</p>
  </div>
  <div class="page">
    <p>Persistent Allocation Primitive</p>
    <p>For each request:</p>
    <p>Pure persistent primitives rare  But we can often turn ephemeral into persistent  Keep the connection open  Do not complete the reqreply</p>
    <p>ptr = malloc(size); ...</p>
    <p>reply(result);</p>
  </div>
  <div class="page">
    <p>Ephemeral + persistent yields final bit</p>
    <p>and find either hidden area or 0s:</p>
    <p>hole_bottom_addr + L</p>
    <p>L</p>
    <p>S</p>
    <p>S</p>
    <p>L</p>
  </div>
  <div class="page">
    <p>So we need</p>
    <p>A way to effect large allocations repeatedly  A way to detect whether they failed</p>
    <p>Note: we want to attack info hiding  Assume arbitrary read/write primitives</p>
  </div>
  <div class="page">
    <p>Here is what we do</p>
    <p>A way to effect large allocations repeatedly  A way to detect whether they failed</p>
    <p>When server is in quiescent state  Taint all memory  See which bytes end up in allocation size</p>
  </div>
  <div class="page">
    <p>Here is what we do</p>
    <p>A way to effect large allocations repeatedly  A way to detect whether they failed</p>
    <p>Options  Direct observation (most common)</p>
    <p>E.g., HTTP 200 vs. 500  Fault side channels</p>
    <p>E.g., HTTP 200 vs. crash  Timing side channels</p>
    <p>E.g., VMA cache hit vs. miss</p>
  </div>
  <div class="page">
    <p>Examples</p>
    <p>Nginx  Failed allocation: Connection close.</p>
    <p>Lighttpd  We crash both when</p>
    <p>allocation fails (too large) and  succeeds (but allocation &gt; than physical memory)</p>
    <p>But in former case: crash immediately  In latter case, many page faults, takes a long time</p>
  </div>
  <div class="page">
    <p>Discovered primitives</p>
    <p>Program # Ephemeral Persistent Crash free</p>
    <p>bind 2    lighttpd 3    mysql 3    nginx 5</p>
  </div>
  <div class="page">
    <p>How fast is it?</p>
    <p>Pretty fast  Allocations/deallocations are cheap  Endtoend attack is O( log[ sizeof(AS) ] )  37 probes in the worst case on nginx  Crashfree, completes in a few seconds</p>
    <p>Existing memory scanning primitives  Remote side channels, CROP, etc.  Endtoend attack is O( sizeof(AS) )  2^35 probes in the worst case</p>
  </div>
  <div class="page">
    <p>Memory overcommit:  OS should allow (virtual) allocations beyond available physical memory  Common in server settings  Required by some applications:</p>
    <p>Reddis, Hadoop, virtualization, etc.</p>
    <p>However, even when disabled:  Allocation oracles still possible  But attacker has to bypass overcommit restrictions</p>
    <p>Assumption</p>
  </div>
  <div class="page">
    <p>Mitigations</p>
    <p>strict overcommit + reduces attack surface  compatibility issues</p>
    <p>RLIMIT_AS + stops attacks  requires perapplication policies</p>
    <p>APM + preserves compatibility  probabilistic</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Allocation oracles, new primitives against ASLR:  Efficient  Layoutagnostic  Pervasive</p>
    <p>Can bypass all information hidingbased defenses  Even ideal information hiding is insufficient  Time for better (meta)data protection techniques</p>
    <p>More info: https://www.vusec.net/nowheretohide</p>
    <p>Vrije Universiteit Amsterdam</p>
  </div>
</Presentation>
