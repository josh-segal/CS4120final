<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Detecting Covert Timing Channels with Time-deterministic Replay</p>
    <p>Ang Chen* W. Brad Moore+ Hanjun Xiao*</p>
    <p>Andreas Haeberlen* Linh Thi Xuan Phan* Micah Sherr + Wenchao Zhou +</p>
    <p>University of Pennsylvania* Georgetown University +</p>
  </div>
  <div class="page">
    <p>Motivation: Detecting covert timing channels</p>
    <p>Secretary</p>
    <p>President</p>
    <p>Launch code</p>
  </div>
  <div class="page">
    <p>Motivation: Detecting covert timing channels</p>
    <p>Secretary</p>
    <p>President</p>
    <p>Launch code: 1011</p>
  </div>
  <div class="page">
    <p>Motivation: Detecting covert timing channels</p>
    <p>Secretary</p>
    <p>President</p>
    <p>Launch code: 1011</p>
    <p>Attacker</p>
  </div>
  <div class="page">
    <p>Motivation: Detecting covert timing channels</p>
    <p>Secretary</p>
    <p>President</p>
    <p>Launch code: 1011</p>
    <p>Code is 1011</p>
    <p>Attacker</p>
  </div>
  <div class="page">
    <p>Motivation: Detecting covert timing channels</p>
    <p>Secretary</p>
    <p>President</p>
    <p>Launch code: 1011</p>
    <p>H E L L O</p>
    <p>Attacker</p>
  </div>
  <div class="page">
    <p>Motivation: Detecting covert timing channels</p>
    <p>Secretary</p>
    <p>President</p>
    <p>Launch code: 1011</p>
    <p>Ah! 1011</p>
    <p>H E L L O</p>
    <p>Attacker</p>
    <p>Covert timing channel: Leaks secrets by changing the timing of network outputs</p>
  </div>
  <div class="page">
    <p>State of the art: Statistics-based detection</p>
    <p>Current approaches look for specific statistical deviations</p>
  </div>
  <div class="page">
    <p>State of the art: Statistics-based detection</p>
    <p>H E L L O</p>
    <p>H E L L O</p>
    <p>Normal traffic:</p>
    <p>With channel:</p>
    <p>Current approaches look for specific statistical deviations</p>
  </div>
  <div class="page">
    <p>State of the art: Statistics-based detection</p>
    <p>H E L L O</p>
    <p>H E L L O</p>
    <p>Normal traffic:</p>
    <p>With channel:</p>
    <p>Small gaps</p>
    <p>Large gaps</p>
    <p>Distribution of inter-packet delays</p>
    <p>Current approaches look for specific statistical deviations</p>
  </div>
  <div class="page">
    <p>Problem: Making a new channel is easy!</p>
    <p>Existing detectors are channel-specific:</p>
  </div>
  <div class="page">
    <p>Problem: Making a new channel is easy!</p>
    <p>Existing detectors are channel-specific:</p>
  </div>
  <div class="page">
    <p>Problem: Making a new channel is easy!</p>
    <p>Admin</p>
    <p>Existing detectors are channel-specific:</p>
  </div>
  <div class="page">
    <p>Problem: Making a new channel is easy!</p>
    <p>Admin</p>
    <p>Existing detectors are channel-specific:</p>
  </div>
  <div class="page">
    <p>Problem: Making a new channel is easy!</p>
    <p>Admin</p>
    <p>Existing detectors are channel-specific:</p>
    <p>Using detector A for channel B doesnt work</p>
  </div>
  <div class="page">
    <p>Problem: Making a new channel is easy!</p>
    <p>Admin</p>
    <p>Existing detectors are channel-specific:</p>
    <p>Using detector A for channel B doesnt work</p>
    <p>Attacker can always invent a new modulation</p>
  </div>
  <div class="page">
    <p>Problem: Making a new channel is easy!</p>
    <p>Admin</p>
    <p>Existing detectors are channel-specific:</p>
    <p>Using detector A for channel B doesnt work</p>
    <p>Attacker can always invent a new modulation</p>
  </div>
  <div class="page">
    <p>Problem: Making a new channel is easy!</p>
    <p>Admin</p>
    <p>Needle in a haystack</p>
    <p>Existing detectors are channel-specific:</p>
    <p>Using detector A for channel B doesnt work</p>
    <p>Attacker can always invent a new modulation</p>
  </div>
  <div class="page">
    <p>Problem: Making a new channel is easy!</p>
    <p>Admin</p>
    <p>Needle in a haystack</p>
    <p>? Existing detectors are channel-specific:</p>
    <p>Using detector A for channel B doesnt work</p>
    <p>Attacker can always invent a new modulation</p>
    <p>Low-rate channels (&quot;Needle in a haystack&quot;) are hard to detect</p>
  </div>
  <div class="page">
    <p>Is there a different way?</p>
  </div>
  <div class="page">
    <p>Is there a different way?</p>
    <p>Existing approaches detect specific anomalies</p>
  </div>
  <div class="page">
    <p>Is there a different way?</p>
    <p>Observed</p>
    <p>Expected</p>
    <p>Existing approaches detect specific anomalies  Our approach: Compare the observed timing to</p>
    <p>the expected timing</p>
  </div>
  <div class="page">
    <p>Is there a different way?</p>
    <p>Observed</p>
    <p>Expected</p>
    <p>Existing approaches detect specific anomalies  Our approach: Compare the observed timing to</p>
    <p>the expected timing</p>
    <p>Works for covert timing channels in general  Can detect both known and unknown/novel channels!</p>
  </div>
  <div class="page">
    <p>Is there a different way?</p>
    <p>Observed</p>
    <p>Expected</p>
    <p>Existing approaches detect specific anomalies  Our approach: Compare the observed timing to</p>
    <p>the expected timing</p>
    <p>Works for covert timing channels in general  Can detect both known and unknown/novel channels!</p>
    <p>But how do we know what timing we should expect?</p>
  </div>
  <div class="page">
    <p>How can we find the expected timing?</p>
    <p>It would be difficult to predict the timing up front</p>
  </div>
  <div class="page">
    <p>How can we find the expected timing?</p>
    <p>It would be difficult to predict the timing up front</p>
    <p>See, e.g., WCET analysis in real-time systems</p>
  </div>
  <div class="page">
    <p>How can we find the expected timing?</p>
    <p>It would be difficult to predict the timing up front</p>
    <p>See, e.g., WCET analysis in real-time systems  And WCET would only give us an upper bound</p>
    <p>but we would need the exact timing!</p>
  </div>
  <div class="page">
    <p>How can we find the expected timing?</p>
    <p>It would be difficult to predict the timing up front</p>
    <p>See, e.g., WCET analysis in real-time systems  And WCET would only give us an upper bound</p>
    <p>but we would need the exact timing!</p>
    <p>Key insight: We only need to reproduce the timing!</p>
    <p>We can record the inputs of the machine and then replay them on a different machine!</p>
  </div>
  <div class="page">
    <p>How can we find the expected timing?</p>
    <p>It would be difficult to predict the timing up front</p>
    <p>See, e.g., WCET analysis in real-time systems  And WCET would only give us an upper bound</p>
    <p>but we would need the exact timing!</p>
    <p>Key insight: We only need to reproduce the timing!</p>
    <p>We can record the inputs of the machine and then replay them on a different machine!</p>
    <p>Can we use deterministic replay to do this?</p>
  </div>
  <div class="page">
    <p>Why Deterministic Replay is not enough</p>
    <p>Deterministic replay records and replays non-deterministic events</p>
  </div>
  <div class="page">
    <p>Why Deterministic Replay is not enough</p>
    <p>Deterministic replay records and replays non-deterministic events</p>
    <p>e1</p>
    <p>log</p>
    <p>e2</p>
    <p>e3</p>
    <p>p1 p2 p3</p>
  </div>
  <div class="page">
    <p>Why Deterministic Replay is not enough</p>
    <p>Deterministic replay records and replays non-deterministic events</p>
    <p>e1</p>
    <p>log</p>
    <p>e2</p>
    <p>e3</p>
    <p>p1 p2 p3</p>
  </div>
  <div class="page">
    <p>Why Deterministic Replay is not enough</p>
    <p>Deterministic replay records and replays non-deterministic events</p>
    <p>p1 p2 p3</p>
    <p>e1</p>
    <p>log</p>
    <p>e2</p>
    <p>e3</p>
  </div>
  <div class="page">
    <p>Why Deterministic Replay is not enough</p>
    <p>Deterministic replay records and replays non-deterministic events</p>
    <p>p1 p2 p3</p>
    <p>log</p>
    <p>p1 p2 p3</p>
  </div>
  <div class="page">
    <p>Why Deterministic Replay is not enough</p>
    <p>Deterministic replay records and replays non-deterministic events This reproduces the outputs - but not the timing!</p>
    <p>p1 p2 p3</p>
    <p>log</p>
    <p>p1 p2 p3</p>
  </div>
  <div class="page">
    <p>Time-deterministic replay (TDR)</p>
    <p>Goal: Reproduce both the outputs and the timing</p>
  </div>
  <div class="page">
    <p>Time-deterministic replay (TDR)</p>
    <p>Goal: Reproduce both the outputs and the timing</p>
    <p>With this, we can detect covert timing channels as follows:</p>
    <p>T</p>
    <p>D R</p>
    <p>H E L L O</p>
  </div>
  <div class="page">
    <p>Time-deterministic replay (TDR)</p>
    <p>Goal: Reproduce both the outputs and the timing</p>
    <p>With this, we can detect covert timing channels as follows:</p>
    <p>(1) Reproduce the timing of every network output</p>
    <p>T</p>
    <p>D R</p>
    <p>H E L L O</p>
    <p>H E L L O</p>
  </div>
  <div class="page">
    <p>Time-deterministic replay (TDR)</p>
    <p>Goal: Reproduce both the outputs and the timing</p>
    <p>With this, we can detect covert timing channels as follows:</p>
    <p>(1) Reproduce the timing of every network output</p>
    <p>(2) Compare the observed timing to the reproduced timing</p>
    <p>T</p>
    <p>D R</p>
    <p>H E L L O</p>
    <p>H E L L O</p>
  </div>
  <div class="page">
    <p>Time-deterministic replay (TDR)</p>
    <p>Goal: Reproduce both the outputs and the timing</p>
    <p>With this, we can detect covert timing channels as follows:</p>
    <p>(1) Reproduce the timing of every network output</p>
    <p>(2) Compare the observed timing to the reproduced timing</p>
    <p>(3) Raise the alarm if there is any discrepancy</p>
    <p>T</p>
    <p>D R</p>
    <p>H E L L O</p>
    <p>H E L L O</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>- Motivation</p>
    <p>- Challenge</p>
    <p>- Time-deterministic replay (TDR) -Deterministic replay vs. Time-deterministic replay</p>
    <p>-Time noise, and how to reduce it</p>
    <p>-Aligning play and replay</p>
    <p>- Sanity: A TDR prototype</p>
    <p>-Design &amp; Implementation</p>
    <p>- Evaluation</p>
    <p>-Reducing time noise</p>
    <p>-Aligning play and replay</p>
    <p>-Detecting timing channels</p>
    <p>- Conclusion</p>
  </div>
  <div class="page">
    <p>Deterministic Replay is not enough</p>
    <p>Experiment: Record and replay an HTTP server in an existing VMM with deterministic replay (XenTT)</p>
  </div>
  <div class="page">
    <p>Deterministic Replay is not enough</p>
    <p>Experiment: Record and replay an HTTP server in an existing VMM with deterministic replay (XenTT)</p>
  </div>
  <div class="page">
    <p>Deterministic Replay is not enough</p>
    <p>Experiment: Record and replay an HTTP server in an existing VMM with deterministic replay (XenTT)</p>
    <p>Time during replay (s)</p>
  </div>
  <div class="page">
    <p>Deterministic Replay is not enough</p>
    <p>Experiment: Record and replay an HTTP server in an existing VMM with deterministic replay (XenTT)</p>
    <p>Time during replay (s)</p>
    <p>Ideal</p>
  </div>
  <div class="page">
    <p>Deterministic Replay is not enough</p>
    <p>Experiment: Record and replay an HTTP server in an existing VMM with deterministic replay (XenTT)</p>
    <p>Time during replay (s)</p>
    <p>Ideal</p>
    <p>Actual</p>
  </div>
  <div class="page">
    <p>Deterministic Replay is not enough</p>
    <p>Experiment: Record and replay an HTTP server in an existing VMM with deterministic replay (XenTT)</p>
    <p>Time during replay (s)</p>
    <p>Ideal</p>
    <p>Actual</p>
    <p>Replay is slower</p>
  </div>
  <div class="page">
    <p>Deterministic Replay is not enough</p>
    <p>Experiment: Record and replay an HTTP server in an existing VMM with deterministic replay (XenTT)</p>
    <p>Time during replay (s)</p>
    <p>Ideal</p>
    <p>Actual</p>
    <p>Replay is slower</p>
    <p>Replay is faster</p>
  </div>
  <div class="page">
    <p>Deterministic Replay is not enough</p>
    <p>Experiment: Record and replay an HTTP server in an existing VMM with deterministic replay (XenTT)</p>
    <p>Result: Play and replay take widely different amounts of time</p>
    <p>Time during replay (s)</p>
    <p>Ideal</p>
    <p>Actual</p>
    <p>Replay is slower</p>
    <p>Replay is faster</p>
  </div>
  <div class="page">
    <p>What is causing this discrepancy?</p>
    <p>Different memory allocations and cache behavior</p>
    <p>IRQs and system calls take different amounts of time</p>
    <p>Disk accesses take different amounts of time</p>
    <p>Kernel may interfere with execution or cache content</p>
    <p>CPU features, such as frequency scaling and speculation</p>
    <p>Non-deterministic scheduling decisions</p>
    <p>There are many different sources of timing variation (&quot;time noise&quot;), such as:</p>
    <p>S e</p>
    <p>e p</p>
    <p>a p</p>
    <p>e r fo</p>
    <p>r d e</p>
    <p>ta ils</p>
  </div>
  <div class="page">
    <p>What is causing this discrepancy?</p>
    <p>Different memory allocations and cache behavior</p>
    <p>IRQs and system calls take different amounts of time</p>
    <p>Disk accesses take different amounts of time</p>
    <p>Kernel may interfere with execution or cache content</p>
    <p>CPU features, such as frequency scaling and speculation</p>
    <p>Non-deterministic scheduling decisions</p>
    <p>There are many different sources of timing variation (&quot;time noise&quot;), such as:</p>
    <p>S e</p>
    <p>e p</p>
    <p>a p</p>
    <p>e r fo</p>
    <p>r d e</p>
    <p>ta ils</p>
  </div>
  <div class="page">
    <p>Example: Controlling time noise from memory</p>
    <p>Problem: Different cache behaviors and memory locations during play and replay.</p>
  </div>
  <div class="page">
    <p>Example: Controlling time noise from memory</p>
    <p>Problem: Different cache behaviors and memory locations during play and replay.</p>
    <p>Cache Memory</p>
    <p>var</p>
  </div>
  <div class="page">
    <p>Example: Controlling time noise from memory</p>
    <p>Problem: Different cache behaviors and memory locations during play and replay.</p>
    <p>Cache Memory</p>
    <p>var</p>
  </div>
  <div class="page">
    <p>Example: Controlling time noise from memory</p>
    <p>Problem: Different cache behaviors and memory locations during play and replay.</p>
    <p>Cache Memory</p>
    <p>var</p>
  </div>
  <div class="page">
    <p>Example: Controlling time noise from memory</p>
    <p>Problem: Different cache behaviors and memory locations during play and replay.</p>
    <p>Cache Memory</p>
    <p>var</p>
  </div>
  <div class="page">
    <p>Example: Controlling time noise from memory</p>
    <p>Problem: Different cache behaviors and memory locations during play and replay.</p>
    <p>Solution: (1) Manage all memory allocations</p>
    <p>Cache Memory</p>
    <p>var</p>
  </div>
  <div class="page">
    <p>Example: Controlling time noise from memory</p>
    <p>Problem: Different cache behaviors and memory locations during play and replay.</p>
    <p>Solution: (1) Manage all memory allocations</p>
    <p>(2) Flush cache before execution</p>
    <p>Cache Memory</p>
    <p>var</p>
  </div>
  <div class="page">
    <p>Techniques for mitigating time noise</p>
  </div>
  <div class="page">
    <p>Techniques for mitigating time noise</p>
  </div>
  <div class="page">
    <p>Techniques for mitigating time noise</p>
  </div>
  <div class="page">
    <p>Techniques for mitigating time noise</p>
    <p>Not all sources of time noise can be eliminated on commodity hardware (e.g., speculation)</p>
  </div>
  <div class="page">
    <p>Techniques for mitigating time noise</p>
    <p>Not all sources of time noise can be eliminated on commodity hardware (e.g., speculation)</p>
    <p>But we can still achieve a very low noise level</p>
  </div>
  <div class="page">
    <p>Problem: Play and replay have different logic</p>
    <p>Would deterministic hardware, e.g., a PRET machine (Edwards and Lee, 2007), solve all our problems?</p>
  </div>
  <div class="page">
    <p>Problem: Play and replay have different logic</p>
    <p>Would deterministic hardware, e.g., a PRET machine (Edwards and Lee, 2007), solve all our problems?</p>
    <p>Problem: Play and replay involve different operations</p>
  </div>
  <div class="page">
    <p>Problem: Play and replay have different logic</p>
    <p>Would deterministic hardware, e.g., a PRET machine (Edwards and Lee, 2007), solve all our problems?</p>
    <p>Problem: Play and replay involve different operations</p>
    <p>void accessInt(int *value, int *buf) {</p>
    <p>if (isPlay)</p>
    <p>*buf = *value;</p>
    <p>else</p>
    <p>*value = *buf;</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Problem: Play and replay have different logic</p>
    <p>Would deterministic hardware, e.g., a PRET machine (Edwards and Lee, 2007), solve all our problems?</p>
    <p>Problem: Play and replay involve different operations</p>
    <p>void accessInt(int *value, int *buf) {</p>
    <p>if (isPlay)</p>
    <p>*buf = *value;</p>
    <p>else</p>
    <p>*value = *buf;</p>
    <p>}</p>
    <p>Play</p>
  </div>
  <div class="page">
    <p>Problem: Play and replay have different logic</p>
    <p>Would deterministic hardware, e.g., a PRET machine (Edwards and Lee, 2007), solve all our problems?</p>
    <p>Problem: Play and replay involve different operations</p>
    <p>void accessInt(int *value, int *buf) {</p>
    <p>if (isPlay)</p>
    <p>*buf = *value;</p>
    <p>else</p>
    <p>*value = *buf;</p>
    <p>} Replay</p>
    <p>Play</p>
  </div>
  <div class="page">
    <p>Problem: Play and replay have different logic</p>
    <p>Would deterministic hardware, e.g., a PRET machine (Edwards and Lee, 2007), solve all our problems?</p>
    <p>Problem: Play and replay involve different operations</p>
    <p>void accessInt(int *value, int *buf) {</p>
    <p>if (isPlay)</p>
    <p>*buf = *value;</p>
    <p>else</p>
    <p>*value = *buf;</p>
    <p>}</p>
    <p>Different memory access patterns</p>
    <p>Different branches taken</p>
    <p>Replay</p>
    <p>Play</p>
  </div>
  <div class="page">
    <p>Problem: Play and replay have different logic</p>
    <p>Would deterministic hardware, e.g., a PRET machine (Edwards and Lee, 2007), solve all our problems?</p>
    <p>Problem: Play and replay involve different operations</p>
    <p>Solution: Carefully design the code to align play and replay</p>
    <p>void accessInt(int *value, int *buf) {</p>
    <p>if (isPlay)</p>
    <p>*buf = *value;</p>
    <p>else</p>
    <p>*value = *buf;</p>
    <p>}</p>
    <p>Different memory access patterns</p>
    <p>Different branches taken</p>
    <p>Replay</p>
    <p>Play</p>
  </div>
  <div class="page">
    <p>Problem: Play and replay have different logic</p>
    <p>Would deterministic hardware, e.g., a PRET machine (Edwards and Lee, 2007), solve all our problems?</p>
    <p>Problem: Play and replay involve different operations</p>
    <p>Solution: Carefully design the code to align play and replay</p>
    <p>void accessInt(int *value, int *buf) {</p>
    <p>int temp = (*value) &amp; playMask;</p>
    <p>temp = temp | (*buf &amp; playMask);</p>
    <p>*value = *buf = temp;</p>
    <p>}</p>
    <p>void accessInt(int *value, int *buf) {</p>
    <p>if (isPlay)</p>
    <p>*buf = *value;</p>
    <p>else</p>
    <p>*value = *buf;</p>
    <p>}</p>
    <p>Different memory access patterns</p>
    <p>Different branches taken</p>
    <p>Replay</p>
    <p>Play</p>
  </div>
  <div class="page">
    <p>Problem: Play and replay have different logic</p>
    <p>Would deterministic hardware, e.g., a PRET machine (Edwards and Lee, 2007), solve all our problems?</p>
    <p>Problem: Play and replay involve different operations</p>
    <p>Solution: Carefully design the code to align play and replay</p>
    <p>void accessInt(int *value, int *buf) {</p>
    <p>int temp = (*value) &amp; playMask;</p>
    <p>temp = temp | (*buf &amp; playMask);</p>
    <p>*value = *buf = temp;</p>
    <p>}</p>
    <p>void accessInt(int *value, int *buf) {</p>
    <p>if (isPlay)</p>
    <p>*buf = *value;</p>
    <p>else</p>
    <p>*value = *buf;</p>
    <p>}</p>
    <p>Different memory access patterns</p>
    <p>Different branches taken</p>
    <p>Replay</p>
    <p>Play</p>
    <p>Play</p>
  </div>
  <div class="page">
    <p>Problem: Play and replay have different logic</p>
    <p>Would deterministic hardware, e.g., a PRET machine (Edwards and Lee, 2007), solve all our problems?</p>
    <p>Problem: Play and replay involve different operations</p>
    <p>Solution: Carefully design the code to align play and replay</p>
    <p>void accessInt(int *value, int *buf) {</p>
    <p>int temp = (*value) &amp; playMask;</p>
    <p>temp = temp | (*buf &amp; playMask);</p>
    <p>*value = *buf = temp;</p>
    <p>}</p>
    <p>void accessInt(int *value, int *buf) {</p>
    <p>if (isPlay)</p>
    <p>*buf = *value;</p>
    <p>else</p>
    <p>*value = *buf;</p>
    <p>}</p>
    <p>Different memory access patterns</p>
    <p>Different branches taken</p>
    <p>Replay</p>
    <p>Play Replay</p>
    <p>Play</p>
  </div>
  <div class="page">
    <p>Problem: Play and replay have different logic</p>
    <p>Would deterministic hardware, e.g., a PRET machine (Edwards and Lee, 2007), solve all our problems?</p>
    <p>Problem: Play and replay involve different operations</p>
    <p>Solution: Carefully design the code to align play and replay</p>
    <p>void accessInt(int *value, int *buf) {</p>
    <p>int temp = (*value) &amp; playMask;</p>
    <p>temp = temp | (*buf &amp; playMask);</p>
    <p>*value = *buf = temp;</p>
    <p>}</p>
    <p>void accessInt(int *value, int *buf) {</p>
    <p>if (isPlay)</p>
    <p>*buf = *value;</p>
    <p>else</p>
    <p>*value = *buf;</p>
    <p>}</p>
    <p>Different memory access patterns</p>
    <p>Different branches taken</p>
    <p>Same memory access pattern</p>
    <p>No branches taken</p>
    <p>Replay</p>
    <p>Play Replay</p>
    <p>Play</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>- Motivation</p>
    <p>- Challenge</p>
    <p>- Time-deterministic replay (TDR)</p>
    <p>-Deterministic replay vs. Time-deterministic replay</p>
    <p>-Time noise, and how to reduce it</p>
    <p>-Aligning play and replay</p>
    <p>- Sanity: A TDR prototype</p>
    <p>-Design &amp; Implementation</p>
    <p>- Evaluation</p>
    <p>-Reducing time noise</p>
    <p>-Aligning play and replay</p>
    <p>-Detecting timing channels</p>
    <p>- Conclusion</p>
  </div>
  <div class="page">
    <p>Prototype implementation: Sanity</p>
    <p>Ideal: Implement TDR in an existing VMM, such as Xen</p>
  </div>
  <div class="page">
    <p>Prototype implementation: Sanity</p>
    <p>Ideal: Implement TDR in an existing VMM, such as Xen</p>
    <p>But time-determinism is difficult to add to existing codebases</p>
    <p>Reason: Complex interactions between unrelated functions, e.g., through the cache</p>
  </div>
  <div class="page">
    <p>Prototype implementation: Sanity</p>
    <p>Ideal: Implement TDR in an existing VMM, such as Xen</p>
    <p>But time-determinism is difficult to add to existing codebases</p>
    <p>Reason: Complex interactions between unrelated functions, e.g., through the cache</p>
    <p>Our approach: Build a VMM from scratch</p>
    <p>Chose Java VM because of its simplicity</p>
  </div>
  <div class="page">
    <p>Prototype implementation: Sanity</p>
    <p>Ideal: Implement TDR in an existing VMM, such as Xen</p>
    <p>But time-determinism is difficult to add to existing codebases</p>
    <p>Reason: Complex interactions between unrelated functions, e.g., through the cache</p>
    <p>Our approach: Build a VMM from scratch</p>
    <p>Chose Java VM because of its simplicity</p>
    <p>No advanced features yet (e.g., no JIT)  Can't expect to compete with Oracle JVM</p>
  </div>
  <div class="page">
    <p>Prototype implementation: Sanity</p>
    <p>Ideal: Implement TDR in an existing VMM, such as Xen</p>
    <p>But time-determinism is difficult to add to existing codebases</p>
    <p>Reason: Complex interactions between unrelated functions, e.g., through the cache</p>
    <p>Our approach: Build a VMM from scratch</p>
    <p>Chose Java VM because of its simplicity</p>
    <p>No advanced features yet (e.g., no JIT)  Can't expect to compete with Oracle JVM</p>
    <p>We rely on the Linux kernel for device I/O (e.g., network)</p>
    <p>Sanity is implemented as a kernel module</p>
  </div>
  <div class="page">
    <p>How Sanity shields itself from the kernel</p>
  </div>
  <div class="page">
    <p>How Sanity shields itself from the kernel</p>
    <p>Timed core Support core</p>
    <p>To avoid interference from the kernel, we run the TDR engine on a separate core</p>
  </div>
  <div class="page">
    <p>How Sanity shields itself from the kernel</p>
    <p>Timed core Support core</p>
    <p>To avoid interference from the kernel, we run the TDR engine on a separate core</p>
  </div>
  <div class="page">
    <p>How Sanity shields itself from the kernel</p>
    <p>Timed core Support core</p>
    <p>Commands</p>
    <p>To avoid interference from the kernel, we run the TDR engine on a separate core</p>
  </div>
  <div class="page">
    <p>How Sanity shields itself from the kernel</p>
    <p>Timed core Support core</p>
    <p>Commands</p>
    <p>Results</p>
    <p>To avoid interference from the kernel, we run the TDR engine on a separate core</p>
  </div>
  <div class="page">
    <p>How Sanity shields itself from the kernel</p>
    <p>Timed core Support core</p>
    <p>Commands</p>
    <p>Results</p>
    <p>To avoid interference from the kernel, we run the TDR engine on a separate core</p>
    <p>Limitation: Need two cores to do the work of one</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>- Motivation</p>
    <p>- Challenge</p>
    <p>- Time-deterministic replay (TDR)</p>
    <p>-Deterministic replay vs. Time-deterministic replay</p>
    <p>-Time noise, and how to reduce it</p>
    <p>-Aligning play and replay</p>
    <p>- Sanity: A TDR prototype</p>
    <p>-Design &amp; Implementation</p>
    <p>- Evaluation</p>
    <p>-Reducing time noise</p>
    <p>-Aligning play and replay</p>
    <p>-Detecting timing channels</p>
    <p>- Conclusion</p>
  </div>
  <div class="page">
    <p>Evaluation: Overview</p>
    <p>Q1: How well can Sanity reduce time noise?</p>
    <p>Q2: How well can Sanity align play and replay? Q3: How fast is Sanity?</p>
    <p>Q4: How large is Sanitys log?</p>
    <p>Q5: How well can Sanity detect covert timing channels?</p>
  </div>
  <div class="page">
    <p>Evaluation: Overview</p>
    <p>Q1: How well can Sanity reduce time noise?</p>
    <p>Q2: How well can Sanity align play and replay? Q3: How fast is Sanity?</p>
    <p>Q4: How large is Sanitys log?</p>
    <p>Q5: How well can Sanity detect covert timing channels?</p>
  </div>
  <div class="page">
    <p>Experimental setup</p>
    <p>Experiments were run on a Dell Optiplex 9020 workstation (3.4GHz Intel i7-4770 CPU, 16 GB RAM, 128GB Vector ZDO SSD, Linux 3.12)</p>
    <p>We use two applications:  SciMark2 (computation-intensive benchmark)  nfsj: Open-source NFS server</p>
    <p>Baseline: Oracles SE 7u51 JVM</p>
  </div>
  <div class="page">
    <p>How well can Sanity reduce time noise?</p>
    <p>Experiment: Run SciMark2 for 100 times in Oracles JVM and Sanity</p>
  </div>
  <div class="page">
    <p>How well can Sanity reduce time noise?</p>
    <p>SOR SMM MC LU FFT</p>
    <p>Timing Variance (%) 80</p>
    <p>Experiment: Run SciMark2 for 100 times in Oracles JVM and Sanity</p>
  </div>
  <div class="page">
    <p>How well can Sanity reduce time noise?</p>
    <p>SOR SMM MC LU FFT</p>
    <p>Timing Variance (%) 80</p>
    <p>Dirty (with GUI and other programs)</p>
    <p>Experiment: Run SciMark2 for 100 times in Oracles JVM and Sanity</p>
  </div>
  <div class="page">
    <p>How well can Sanity reduce time noise?</p>
    <p>SOR SMM MC LU FFT</p>
    <p>Timing Variance (%) 80</p>
    <p>Dirty (with GUI and other programs)</p>
    <p>Experiment: Run SciMark2 for 100 times in Oracles JVM and Sanity</p>
  </div>
  <div class="page">
    <p>How well can Sanity reduce time noise?</p>
    <p>SOR SMM MC LU FFT</p>
    <p>Timing Variance (%) 80</p>
    <p>Dirty (with GUI and other programs) Clean (single-user mode)</p>
    <p>Experiment: Run SciMark2 for 100 times in Oracles JVM and Sanity</p>
  </div>
  <div class="page">
    <p>How well can Sanity reduce time noise?</p>
    <p>SOR SMM MC LU FFT</p>
    <p>Timing Variance (%) 80</p>
    <p>Dirty (with GUI and other programs) Clean (single-user mode)</p>
    <p>Experiment: Run SciMark2 for 100 times in Oracles JVM and Sanity</p>
  </div>
  <div class="page">
    <p>How well can Sanity reduce time noise?</p>
    <p>SOR SMM MC LU FFT</p>
    <p>Timing Variance (%) 80</p>
    <p>Dirty (with GUI and other programs) Clean (single-user mode)</p>
    <p>Sanity</p>
    <p>Experiment: Run SciMark2 for 100 times in Oracles JVM and Sanity</p>
  </div>
  <div class="page">
    <p>How well can Sanity reduce time noise?</p>
    <p>SOR SMM MC LU FFT</p>
    <p>Timing Variance (%) 80</p>
    <p>Dirty (with GUI and other programs) Clean (single-user mode)</p>
    <p>Sanity</p>
    <p>Experiment: Run SciMark2 for 100 times in Oracles JVM and Sanity</p>
  </div>
  <div class="page">
    <p>How well can Sanity reduce time noise?</p>
    <p>SOR SMM MC LU FFT</p>
    <p>Timing Variance (%) 80</p>
    <p>Dirty (with GUI and other programs) Clean (single-user mode)</p>
    <p>Sanity</p>
    <p>Experiment: Run SciMark2 for 100 times in Oracles JVM and Sanity  Sanitys time-determinism is orders of magnitude better than</p>
    <p>that of a standard JVM!</p>
  </div>
  <div class="page">
    <p>How well can Sanity reproduce timing?</p>
    <p>Experiment: Run nfsj and serve 30 files, then replay.</p>
    <p>Data points Perfect accuracy</p>
  </div>
  <div class="page">
    <p>How well can Sanity reproduce timing?</p>
    <p>Experiment: Run nfsj and serve 30 files, then replay.</p>
    <p>Data points Perfect accuracy</p>
  </div>
  <div class="page">
    <p>How well can Sanity reproduce timing?</p>
    <p>Experiment: Run nfsj and serve 30 files, then replay.</p>
    <p>Data points Perfect accuracy</p>
  </div>
  <div class="page">
    <p>How well can Sanity reproduce timing?</p>
    <p>Experiment: Run nfsj and serve 30 files, then replay.  Sanity can almost perfectly reproduce the timing of</p>
    <p>network outputs during replay</p>
    <p>Data points Perfect accuracy</p>
  </div>
  <div class="page">
    <p>How well can Sanity detect timing channels?</p>
  </div>
  <div class="page">
    <p>How well can Sanity detect timing channels?</p>
    <p>We implemented three known channels:</p>
    <p>IP covert timing channel (IPCTC) [CBS-CCS04]  Traffic replay covert timing channel (TRCTC) [Cabuk-thesis06]  Model-based covert timing channel (MBCTC) [GWWJ-RAID08]</p>
  </div>
  <div class="page">
    <p>How well can Sanity detect timing channels?</p>
    <p>We implemented three known channels:</p>
    <p>IP covert timing channel (IPCTC) [CBS-CCS04]  Traffic replay covert timing channel (TRCTC) [Cabuk-thesis06]  Model-based covert timing channel (MBCTC) [GWWJ-RAID08]</p>
    <p>Plus one new channel:</p>
    <p>&quot;Needle in a haystack&quot; (worst case for detector)</p>
  </div>
  <div class="page">
    <p>How well can Sanity detect timing channels?</p>
    <p>We implemented three known channels:</p>
    <p>IP covert timing channel (IPCTC) [CBS-CCS04]  Traffic replay covert timing channel (TRCTC) [Cabuk-thesis06]  Model-based covert timing channel (MBCTC) [GWWJ-RAID08]</p>
    <p>Plus one new channel:</p>
    <p>&quot;Needle in a haystack&quot; (worst case for detector)</p>
    <p>We used four known detectors:</p>
    <p>Shape test [CBS-CCS04]  KS test [PNR-S&amp;P06]  Regularity test [CBS-CCS04]  Corrected conditional entropy test [GW-CCS02]</p>
  </div>
  <div class="page">
    <p>How well can Sanity detect timing channels?</p>
    <p>We implemented three known channels:</p>
    <p>IP covert timing channel (IPCTC) [CBS-CCS04]  Traffic replay covert timing channel (TRCTC) [Cabuk-thesis06]  Model-based covert timing channel (MBCTC) [GWWJ-RAID08]</p>
    <p>Plus one new channel:</p>
    <p>&quot;Needle in a haystack&quot; (worst case for detector)</p>
    <p>We used four known detectors:</p>
    <p>Shape test [CBS-CCS04]  KS test [PNR-S&amp;P06]  Regularity test [CBS-CCS04]  Corrected conditional entropy test [GW-CCS02]</p>
    <p>Plus our new Sanity-based detector</p>
  </div>
  <div class="page">
    <p>How to measure the quality of a detector</p>
    <p>True positive rate</p>
    <p>False positive rate 0 1</p>
  </div>
  <div class="page">
    <p>How to measure the quality of a detector</p>
    <p>True positive rate</p>
    <p>False positive rate 0 1</p>
    <p>Perfect accuracy</p>
  </div>
  <div class="page">
    <p>How to measure the quality of a detector</p>
    <p>True positive rate</p>
    <p>False positive rate 0 1</p>
    <p>Perfect accuracy</p>
  </div>
  <div class="page">
    <p>How to measure the quality of a detector</p>
    <p>True positive rate</p>
    <p>False positive rate 0 1</p>
    <p>Perfect accuracy</p>
    <p>Area under the curve</p>
  </div>
  <div class="page">
    <p>How well can Sanity detect timing channels?</p>
    <p>Experiment: Run each channel against each detector</p>
  </div>
  <div class="page">
    <p>How well can Sanity detect timing channels?</p>
    <p>Shape test KS test</p>
    <p>RT test CCE test</p>
    <p>IPCTC 0 1</p>
    <p>Experiment: Run each channel against each detector</p>
  </div>
  <div class="page">
    <p>How well can Sanity detect timing channels?</p>
    <p>Shape test KS test</p>
    <p>RT test CCE test</p>
    <p>IPCTC 0 1</p>
    <p>Experiment: Run each channel against each detector  Observations:</p>
    <p>All detectors can detect IPCTC with perfect accuracy</p>
  </div>
  <div class="page">
    <p>How well can Sanity detect timing channels?</p>
    <p>Shape test KS test</p>
    <p>RT test CCE test</p>
    <p>IPCTC MBCTC TRCTC 0 1</p>
    <p>Experiment: Run each channel against each detector  Observations:</p>
    <p>All detectors can detect IPCTC with perfect accuracy</p>
  </div>
  <div class="page">
    <p>How well can Sanity detect timing channels?</p>
    <p>Shape test KS test</p>
    <p>RT test CCE test</p>
    <p>IPCTC MBCTC TRCTC 0 1</p>
    <p>Experiment: Run each channel against each detector  Observations:</p>
    <p>All detectors can detect IPCTC with perfect accuracy  Existing detectors do worse for more sophisticated channels</p>
  </div>
  <div class="page">
    <p>How well can Sanity detect timing channels?</p>
    <p>Shape test KS test</p>
    <p>RT test CCE test</p>
    <p>IPCTC MBCTC TRCTC Needle 0 1</p>
    <p>Experiment: Run each channel against each detector  Observations:</p>
    <p>All detectors can detect IPCTC with perfect accuracy  Existing detectors do worse for more sophisticated channels</p>
  </div>
  <div class="page">
    <p>How well can Sanity detect timing channels?</p>
    <p>Shape test KS test</p>
    <p>RT test CCE test</p>
    <p>IPCTC MBCTC TRCTC Needle 0 1</p>
    <p>Experiment: Run each channel against each detector  Observations:</p>
    <p>All detectors can detect IPCTC with perfect accuracy  Existing detectors do worse for more sophisticated channels  Existing detectors cannot detect &quot;Needle in a haystack&quot; well</p>
  </div>
  <div class="page">
    <p>How well can Sanity detect timing channels?</p>
    <p>Shape test KS test</p>
    <p>RT test CCE test Sanity</p>
    <p>IPCTC MBCTC TRCTC Needle 0 1</p>
    <p>Experiment: Run each channel against each detector  Observations:</p>
    <p>All detectors can detect IPCTC with perfect accuracy  Existing detectors do worse for more sophisticated channels  Existing detectors cannot detect &quot;Needle in a haystack&quot; well  Sanity detects all channels with perfect accuracy! (no false positives, no false negatives)</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Goal: Detect covert timing channels</p>
    <p>Existing detectors look for signs of specific, known channels</p>
    <p>Result: &quot;Cat-and-mouse game&quot; with the attacker</p>
    <p>Our approach: Compare the observed timing to what it 'should be' if the machine is not compromised</p>
    <p>Works for all timing channels, including novel ones</p>
    <p>Key challenge: How do we know what the timing should be?</p>
    <p>We introduce time-deterministic replay (TDR)</p>
    <p>We have built a TDR prototype called Sanity</p>
    <p>Reproduces timing to within 2% (on commodity hardware)</p>
    <p>Can be used to detect a variety of existing and novel covert timing channels with perfect accuracy</p>
  </div>
</Presentation>
