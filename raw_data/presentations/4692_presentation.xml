<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>The Optimal-Location Query</p>
    <p>Donghui Zhang Northeastern University</p>
    <p>Coauthors: Yang Du, Tian Xia</p>
  </div>
  <div class="page">
    <p>Motivation</p>
    <p>What is the optimal location in Boston area to build a new McDonalds store?</p>
    <p>Optimality: maximize the number of customers who think the new store is closer to them.</p>
  </div>
  <div class="page">
    <p>Formal Definition</p>
    <p>Given a set S of sites, a set O of weighted objects, and a query range Q ,</p>
    <p>Find a location l  Q which maximizes</p>
    <p>oO o.weight s.t. sS, d(o, l)  d(o,s).</p>
    <p>We consider the L1 distance:</p>
    <p>|x1 - x2|+|y1 - y2|</p>
  </div>
  <div class="page">
    <p>Formal Definition</p>
    <p>Given a set S of sites, a set O of weighted objects, and a query range Q ,</p>
    <p>Find a location l  Q which maximizes</p>
    <p>oO o.weight s.t. sS, d(o, l)  d(o,s).</p>
    <p>We consider the L1 distance:</p>
    <p>|x1 - x2|+|y1 - y2|</p>
  </div>
  <div class="page">
    <p>Example</p>
    <p>o :3 2</p>
    <p>o :4 1 o :5 3</p>
    <p>o :6 4</p>
    <p>Q</p>
  </div>
  <div class="page">
    <p>Example</p>
    <p>l1</p>
    <p>s2</p>
    <p>o :3 2</p>
    <p>o :4 1</p>
    <p>o :6 4</p>
    <p>s</p>
    <p>Q</p>
    <p>The Influence of l1 is 5+6=11.</p>
  </div>
  <div class="page">
    <p>Example</p>
    <p>l1</p>
    <p>s2</p>
    <p>o :3 2</p>
    <p>o :4 1</p>
    <p>o :6 4</p>
    <p>s</p>
    <p>Q 19</p>
    <p>The Influence of l1 is 5+6=11.</p>
    <p>l2</p>
    <p>The Influence of l2 is 5.</p>
  </div>
  <div class="page">
    <p>Content</p>
    <p>Problem Definition  Straightforward Solution  Problem Transformation  The R-tree-based solution  The OL-tree  The VOL-tree  Performance</p>
  </div>
  <div class="page">
    <p>Using the RNN Algorithm</p>
    <p>l1</p>
    <p>s2</p>
    <p>o :3 2</p>
    <p>o :4 1</p>
    <p>o :6 4</p>
    <p>s</p>
    <p>The RNNs of l1 are O3 and O4.</p>
  </div>
  <div class="page">
    <p>Straightforward Solution</p>
    <p>s2</p>
    <p>o :3 2</p>
    <p>o :4 1</p>
    <p>o :6 4</p>
    <p>s</p>
    <p>o :5 3</p>
    <p>Compute the influence for every location in Q.</p>
    <p>Problematic: infinite number of candidates!.</p>
  </div>
  <div class="page">
    <p>Content</p>
    <p>Problem Definition  Straightforward Solution  Problem Transformation  The R-tree-based Solution  The OL-tree  The VOL-tree  Performance</p>
  </div>
  <div class="page">
    <p>nn_buffer of an Object</p>
    <p>Any location within the nn_buffer is a closer site if built.</p>
    <p>nn_buffer is a diamond.</p>
    <p>O1:4</p>
    <p>O2:3</p>
    <p>O3:5 O4:6</p>
    <p>S1 S2</p>
    <p>nn_buffer of O4.</p>
  </div>
  <div class="page">
    <p>Problem Transformation</p>
    <p>Find a location with maximum overlap among objects nn_buffer.</p>
    <p>O1:4</p>
    <p>O2:3</p>
    <p>O3:5 O4:6</p>
    <p>S1 S2</p>
    <p>Q Any location here is an optimal</p>
    <p>location!</p>
  </div>
  <div class="page">
    <p>The Rotated Coodinate</p>
    <p>Rotate the coordinate 45.  All nn_buffers become axis-parallel squares.</p>
    <p>Focus on the rotated coordinate.</p>
    <p>o X</p>
    <p>'</p>
    <p>X</p>
    <p>Y</p>
    <p>Y '</p>
    <p>x</p>
    <p>y x'</p>
    <p>y'</p>
  </div>
  <div class="page">
    <p>Content</p>
    <p>Problem Definition  Straightforward Solution  Problem Transformation  The R-tree-based Solution  The OL-tree  The VOL-tree  Performance</p>
  </div>
  <div class="page">
    <p>The R-tree-based Solution</p>
    <p>Store the objects in an R-tree.  Retrieve the objects whose nn_buffers</p>
    <p>intersect Q.  Plane sweep to find a region which has</p>
    <p>maximum overlap.</p>
  </div>
  <div class="page">
    <p>Two Contributions</p>
    <p>lower X.</p>
  </div>
  <div class="page">
    <p>Best-first Retrieval  Keep a heap of index entries + objects.  Sorted in increasing order of nn_buffers lower X.</p>
    <p>While heap is not empty, pop an entry.  If pop an object, send it to plane sweep.  If pop an index entry, push its children</p>
    <p>(intersecting Q).</p>
    <p>t t</p>
  </div>
  <div class="page">
    <p>Nave Plane Sweep</p>
    <p>X</p>
    <p>Y</p>
    <p>O1:4 O2:3</p>
    <p>O3:5 2</p>
    <p>O4:6</p>
    <p>- 2 5 8 9 12 + 0 5 12 7 3 0</p>
  </div>
  <div class="page">
    <p>Not Efficient! O(n2)</p>
    <p>- 2 5 8 9 12 + 0 5 12 7 3 0</p>
    <p>Suppose next insertion: add 2 to the Y-range [2,11].</p>
    <p>+2</p>
    <p>- 2 5 8 9 12 + 0 7 14 9 3 0</p>
  </div>
  <div class="page">
    <p>The aSB-tree</p>
    <p>- 2 5 8 9 12 + 0 5 12 7 3 0</p>
    <p>- 5 9 + 0 0 0</p>
    <p>Extended from the SB-tree [YW01]:  keeps max overlap information at index entries.  handle a query range Q.</p>
  </div>
  <div class="page">
    <p>- 2 5 8 9 12 + 0 5 12 7 3 0</p>
    <p>Suppose next insertion: add 2 to the Y range [2,11].</p>
    <p>+2</p>
    <p>- 5 9 + 0 0 0</p>
    <p>The aSB-tree</p>
  </div>
  <div class="page">
    <p>- 2 5 8 9 12 + 0 5 12 7 3 0</p>
    <p>Suppose next insertion: add 2 to the Y range [2,11].</p>
    <p>- 5 9 + 0 2 0</p>
    <p>+2 +2</p>
    <p>The aSB-tree</p>
  </div>
  <div class="page">
    <p>- 2 5 8 9 12 + 0 7 12 7 3 0</p>
    <p>Suppose next insertion: add 2 to the Y range [2,11].</p>
    <p>- 5 9 + 0 2 0</p>
    <p>The aSB-tree</p>
  </div>
  <div class="page">
    <p>Content</p>
    <p>Problem Definition  Straightforward Solution  Problem Transformation  The R-tree-based Solution  The OL-tree  The VOL-tree  Performance</p>
  </div>
  <div class="page">
    <p>The OL-tree</p>
    <p>Idea: partition the space, and keep max overlapped region for each partition!</p>
    <p>Like a k-d-B-tree.</p>
    <p>An nn_buffer may have multiple copies.</p>
    <p>Stores nn_buffers. 1 2</p>
  </div>
  <div class="page">
    <p>Index entry has, besides range:  fullcover: total weight of nn_buffers fully</p>
    <p>covering the whole area;  localmax: among the nn_buffers inserted into the</p>
    <p>sub-tree, max overlap.  maxrange: the region where localmax occurred.</p>
    <p>Leaf entry:  A rectangle and its weight.</p>
    <p>Stored Information</p>
  </div>
  <div class="page">
    <p>r1 , 0, 4)(</p>
    <p>r2 , 1, 4)(</p>
    <p>r 3 , 2, 7)(</p>
    <p>r32( , 2, 3) r31, 4, 3)(</p>
    <p>r33( , 1, 2)</p>
    <p>rroot( , 0, 9)</p>
    <p>sub-trees omitted</p>
  </div>
  <div class="page">
    <p>r1 , 0, 4)(</p>
    <p>r2 , 1, 4)(</p>
    <p>r 3 , 2, 7)(</p>
    <p>r32( , 2, 3) r31, 4, 3)(</p>
    <p>r33( , 1, 2)</p>
    <p>rroot( , 0, 9)</p>
    <p>sub-trees omitted</p>
    <p>fullcover: 2 nn_buffers fully cover r3</p>
    <p>localmax: Among those inserted,</p>
    <p>max overlap is 7</p>
    <p>maxrange: where localmax occurred</p>
  </div>
  <div class="page">
    <p>Query Processing  Start with root, insert index entries into heap.</p>
    <p>Sorting key: upper bound of real max overlap in the sub-tree.  localmax +  fullcovers of ancestor entries.  Accurate if Q intersects with maxrange.</p>
  </div>
  <div class="page">
    <p>r1 , 0, 4)(</p>
    <p>r2 , 1, 4)(</p>
    <p>r 3 , 2, 7)(</p>
    <p>r32( , 2, 3) r31, 4, 3)(</p>
    <p>r33( , 1, 2)</p>
    <p>rroot( , 0, 9)</p>
    <p>sub-trees omitted</p>
    <p>localmax</p>
    <p>Real max overlap = 0+2+1 +localmax = 5</p>
  </div>
  <div class="page">
    <p>Query Processing  Start with root, insert index entries into heap.</p>
    <p>Sorting key: upper bound of real max overlap in the sub-tree.  localmax +  fullcovers of ancestor entries.  Accurate if Q intersects with maxrange.</p>
    <p>Keep a running value: max overlap M.</p>
    <p>Pruning 1: Q intersects with maxrange.</p>
    <p>Pruning 2: upper bound of max overlap &lt; M.</p>
  </div>
  <div class="page">
    <p>r1 , 0, 4)(</p>
    <p>r2 , 1, 4)(</p>
    <p>r 3 , 2, 7)(</p>
    <p>r32( , 2, 3) r31, 4, 3)(</p>
    <p>r33( , 1, 2)</p>
    <p>rroot( , 0, 9)</p>
    <p>sub-trees omitted</p>
    <p>Q  r2 is pruned since Q intersects r2.maxrange. M = 0+1+4=5.</p>
    <p>r1 is pruned since the upper bound of overlap = 4 &lt; M.</p>
  </div>
  <div class="page">
    <p>r1 , 0, 4)(</p>
    <p>r2 , 1, 4)(</p>
    <p>r 3 , 2, 7)(</p>
    <p>r32( , 2, 3) r31, 4, 3)(</p>
    <p>r33( , 1, 2)</p>
    <p>rroot( , 0, 9)</p>
    <p>sub-trees omitted</p>
    <p>Sometimes, we need to examine a leaf node. Plane sweep it!</p>
  </div>
  <div class="page">
    <p>OL-tree  VOL-tree</p>
    <p>OL-tree is not practical  worst-case space complexity O(n2)  complex re-organization</p>
    <p>How to improve?  Only keep a few top levels of the OL-tree.</p>
    <p>==&gt; Virtual OL-tree!</p>
  </div>
  <div class="page">
    <p>VOL-tree</p>
  </div>
  <div class="page">
    <p>Example</p>
    <p>If Q is here, perform range search on the R-tree.</p>
  </div>
  <div class="page">
    <p>Comparison with R-tree Approach</p>
    <p>The R-tree approach examines all nn_buffers intersecting with Q.</p>
    <p>By using a small, in-memory VOLtree, the new approach can prune the search space.</p>
  </div>
  <div class="page">
    <p>Challenge</p>
    <p>With dynamic updates, to keep localmax and maxrange is expensive.</p>
    <p>To insert an nn_buffer</p>
    <p>here, recompute!</p>
  </div>
  <div class="page">
    <p>Index entry (range, fullcover, maxrange, localmax)</p>
    <p>lowermax, uppermax</p>
    <p>lowermax  localmax  uppermax</p>
    <p>Solution</p>
  </div>
  <div class="page">
    <p>Index entry (range, fullcover, maxrange, localmax)</p>
    <p>lowermax, uppermax</p>
    <p>lowermax  localmax  uppermax  Any location in maxrange has overlap =</p>
    <p>lowermax.  At a location outside maxrange, the overlap</p>
    <p>can be more than lowermax, but &lt; uppermax.</p>
    <p>Solution</p>
  </div>
  <div class="page">
    <p>Update</p>
    <p>Case 1: the new nn_buffer does not intersect with maxrange.</p>
    <p>Case 2: intersects.</p>
    <p>Case 1: increase</p>
    <p>uppermax.</p>
    <p>Case 2: increase uppermax and</p>
    <p>lowermax.</p>
  </div>
  <div class="page">
    <p>Query</p>
    <p>Similar to the OL-tree.  To compute upper bound of max</p>
    <p>overlap, use uppermax.  When Q intersects maxrange, may or</p>
    <p>may not prune.</p>
  </div>
  <div class="page">
    <p>Content</p>
    <p>Problem Definition  Straightforward Solution  Problem Transformation  The R-tree-based Solution  The OL-tree  The VOL-tree  Performance</p>
  </div>
  <div class="page">
    <p>Setup</p>
    <p>Digital Chart from the R-tree Portal.  O: 24,493 populated places.  S: 9,203 cultural landmarks.</p>
    <p>Pagesize: 1KB. Buffersize: 256 pages.  Object R-tree: 753 pages.  Pentium IV Dell PC, 3.2GHz.  Java.  Measure total I/O of 100 random queries.</p>
  </div>
  <div class="page">
    <p>Size of the VOL-tree</p>
  </div>
  <div class="page">
    <p>Small Query Area</p>
  </div>
  <div class="page">
    <p>Large Query Area</p>
  </div>
  <div class="page">
    <p>Varying Buffer Size</p>
  </div>
  <div class="page">
    <p>Effect of Update</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>Introduced the optimal-location query.  Proposed three solutions.  The VOL-tree approach is the best.  More improvement with larger query area.</p>
    <p>(5% query area = 6 times improvement.)  More updates decreases the improvement.</p>
    <p>(50% updates = no improvement.) But can bulk-load.</p>
  </div>
</Presentation>
