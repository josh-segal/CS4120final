<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Shuffler: Fast and Deployable Continuous Code Re-Randomization</p>
    <p>David Williams-King, Graham Gobieski, Kent Williams-King, James P. Blake,</p>
    <p>Xinhao Yuan, Patrick Colp, Michelle Zheng, Vasileios P. Kemerlis, Junfeng Yang, William Aiello</p>
    <p>OSDI 2016</p>
  </div>
  <div class="page">
    <p>Software Remains Vulnerable</p>
    <p>High-profile server breaches are commonplace</p>
  </div>
  <div class="page">
    <p>Software Remains Vulnerable</p>
    <p>High-profile server breaches are commonplace  90% of todays attacks utilize ROP [1]</p>
  </div>
  <div class="page">
    <p>Return-Oriented Programming</p>
    <p>Reuse fragments of legitimate code (gadgets)</p>
    <p>func_3</p>
    <p>func_2</p>
    <p>func_1</p>
    <p>func_3</p>
    <p>func_2</p>
    <p>func_1</p>
    <p>Program code</p>
    <p>ret addr</p>
    <p>Stack</p>
  </div>
  <div class="page">
    <p>Return-Oriented Programming</p>
    <p>Reuse fragments of legitimate code (gadgets)</p>
    <p>Program code</p>
    <p>ret addr</p>
    <p>Stack</p>
  </div>
  <div class="page">
    <p>Return-Oriented Programming</p>
    <p>Reuse fragments of legitimate code (gadgets)</p>
    <p>Stack</p>
    <p>ret addr ret addr</p>
    <p>ret addr data</p>
    <p>Buffer Overrun</p>
    <p>ret addr</p>
    <p>Program code</p>
  </div>
  <div class="page">
    <p>Return-Oriented Programming</p>
    <p>Reuse fragments of legitimate code (gadgets)</p>
    <p>ROP gadget chain</p>
    <p>Stack</p>
    <p>ret addr ret addr</p>
    <p>ret addr data</p>
    <p>Buffer Overrun</p>
    <p>ret addr</p>
    <p>Program code</p>
  </div>
  <div class="page">
    <p>Modern ROP Attacks</p>
    <p>JIT-ROP [2]: iteratively read code at runtime</p>
  </div>
  <div class="page">
    <p>Modern ROP Attacks</p>
    <p>JIT-ROP [2]: iteratively read code at runtime</p>
    <p>func_3</p>
    <p>func_2</p>
    <p>func_1</p>
    <p>Target program Attacker</p>
    <p>func_3</p>
    <p>func_2</p>
    <p>func_1</p>
  </div>
  <div class="page">
    <p>Modern ROP Attacks</p>
    <p>JIT-ROP [2]: iteratively read code at runtime Target program Attacker</p>
    <p>func_3</p>
    <p>func_2</p>
    <p>func_1</p>
  </div>
  <div class="page">
    <p>Modern ROP Attacks</p>
    <p>JIT-ROP [2]: iteratively read code at runtime</p>
    <p>ROP gadget chain</p>
    <p>Target program Attacker</p>
    <p>Inject exploit</p>
    <p>func_3</p>
    <p>func_2</p>
    <p>func_1</p>
  </div>
  <div class="page">
    <p>Modern ROP Attacks</p>
    <p>JIT-ROP [2]: iteratively read code at runtime</p>
    <p>ROP gadget chain</p>
    <p>Target program Attacker</p>
    <p>Inject exploit</p>
    <p>func_3</p>
    <p>func_2</p>
    <p>func_1</p>
  </div>
  <div class="page">
    <p>The Shuffler Idea</p>
    <p>What if we re-randomize code more rapidly than an attacker discovers gadgets?</p>
    <p>func_3</p>
    <p>func_2</p>
    <p>func_1</p>
    <p>func_3</p>
    <p>func_2</p>
    <p>func_1</p>
  </div>
  <div class="page">
    <p>The Shuffler Idea</p>
    <p>What if we re-randomize code more rapidly than an attacker discovers gadgets?</p>
    <p>func_3</p>
    <p>func_2</p>
    <p>func_1</p>
  </div>
  <div class="page">
    <p>The Shuffler Idea</p>
    <p>What if we re-randomize code more rapidly than an attacker discovers gadgets?</p>
    <p>func_3</p>
    <p>func_2</p>
    <p>func_1</p>
    <p>func_3</p>
    <p>func_2</p>
    <p>func_1</p>
  </div>
  <div class="page">
    <p>The Shuffler Idea</p>
    <p>What if we re-randomize code more rapidly than an attacker discovers gadgets?</p>
    <p>ROP gadget chain</p>
    <p>Inject exploit</p>
    <p>func_3</p>
    <p>func_2</p>
    <p>func_1</p>
    <p>??</p>
  </div>
  <div class="page">
    <p>The Shuffler Idea</p>
    <p>What if we re-randomize code more rapidly than an attacker discovers gadgets?</p>
    <p>ROP gadget chain</p>
    <p>Inject exploit</p>
  </div>
  <div class="page">
    <p>How Is This Possible?</p>
    <p>Re-randomize code before an attacker uses it</p>
  </div>
  <div class="page">
    <p>How Is This Possible?</p>
    <p>Re-randomize code before an attacker uses it  faster than disclosure vulnerability execution time;</p>
    <p>faster than gadget chain computation time;</p>
    <p>or, faster than network communication time</p>
  </div>
  <div class="page">
    <p>How Is This Possible?</p>
    <p>Re-randomize code before an attacker uses it  faster than disclosure vulnerability execution time;</p>
    <p>faster than gadget chain computation time;</p>
    <p>or, faster than network communication time</p>
  </div>
  <div class="page">
    <p>How Is This Possible?</p>
    <p>Re-randomize code before an attacker uses it  faster than disclosure vulnerability execution time;</p>
    <p>faster than gadget chain computation time;</p>
    <p>or, faster than network communication time  one memory disclosure can only travel 820 miles!</p>
  </div>
  <div class="page">
    <p>What Is Shuffler?</p>
    <p>Defense based on continuous re-randomization  Defeats all known code reuse attacks</p>
    <p>20-50 millisecond shuffling, scales to 24 threads</p>
    <p>Fast: bounds attackers available time  Defeats even attackers with zero network latency</p>
    <p>Deployable:  Binary analysis w/o modifying kernel, compiler, ...</p>
    <p>Egalitarian:  Shuffler runs in same address space, defends itself</p>
  </div>
  <div class="page">
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Outline</p>
  </div>
  <div class="page">
    <p>func_1</p>
    <p>... call func_2 ...</p>
    <p>Continuous Re-Randomization</p>
    <p>Easy to copy code &amp; fix direct references</p>
    <p>func_2</p>
    <p>func_2</p>
  </div>
  <div class="page">
    <p>func_1</p>
    <p>... call func_2 ...</p>
    <p>Continuous Re-Randomization</p>
    <p>Easy to copy code &amp; fix direct references</p>
    <p>(deleted)</p>
    <p>func_2</p>
  </div>
  <div class="page">
    <p>Continuous Re-Randomization</p>
    <p>Easy to copy code &amp; fix direct references  What about code pointers?</p>
  </div>
  <div class="page">
    <p>func_1</p>
    <p>... mov $func_2, ptr ... call *ptr ...</p>
    <p>Continuous Re-Randomization</p>
    <p>Easy to copy code &amp; fix direct references  What about code pointers?</p>
    <p>func_2</p>
    <p>ptr:</p>
  </div>
  <div class="page">
    <p>func_1</p>
    <p>... mov $func_2, ptr ... call *ptr ...</p>
    <p>Continuous Re-Randomization</p>
    <p>Easy to copy code &amp; fix direct references  What about code pointers?</p>
    <p>func_2</p>
    <p>&amp;func_2ptr:</p>
  </div>
  <div class="page">
    <p>func_1</p>
    <p>... mov $func_2, ptr ... call *ptr ...</p>
    <p>Continuous Re-Randomization</p>
    <p>Easy to copy code &amp; fix direct references  What about code pointers?</p>
    <p>func_2(deleted) func_2</p>
    <p>&amp;func_2ptr:</p>
  </div>
  <div class="page">
    <p>func_1</p>
    <p>... mov $func_2, ptr ... call *ptr ...</p>
    <p>Continuous Re-Randomization</p>
    <p>Easy to copy code &amp; fix direct references  What about code pointers?</p>
    <p>&amp;func_2ptr:</p>
    <p>(deleted) func_2</p>
  </div>
  <div class="page">
    <p>Continuous Re-Randomization</p>
    <p>Easy to copy code &amp; fix direct references  What about code pointers?</p>
    <p>How to update all propagated pointers?</p>
    <p>&amp;func_2ptr:</p>
    <p>func_2(deleted)</p>
    <p>&amp;func_2&amp;func_2</p>
    <p>&amp;func_2</p>
    <p>&amp;func_2</p>
    <p>&amp;func_2</p>
    <p>&amp;func_2 &amp;func_2</p>
    <p>func_2</p>
  </div>
  <div class="page">
    <p>Continuous Re-Randomization</p>
    <p>Solution: add extra level of indirection</p>
    <p>f_2_idxptr:</p>
    <p>func_2</p>
    <p>f_2_idxf_2_idxf_2_idx f_2_idx</p>
    <p>...</p>
    <p>%gs: (table)</p>
    <p>...</p>
    <p>&amp;func_2</p>
    <p>...</p>
  </div>
  <div class="page">
    <p>Continuous Re-Randomization</p>
    <p>Solution: add extra level of indirection</p>
    <p>f_2_idxptr:</p>
    <p>func_2</p>
    <p>f_2_idxf_2_idxf_2_idx f_2_idx</p>
    <p>...</p>
    <p>%gs: (table)</p>
    <p>...</p>
    <p>&amp;func_2</p>
    <p>...</p>
    <p>f_2_idx</p>
    <p>f_2_idx</p>
    <p>f_2_idx</p>
  </div>
  <div class="page">
    <p>Continuous Re-Randomization</p>
    <p>Solution: add extra level of indirection</p>
    <p>f_2_idxptr:</p>
    <p>func_2</p>
    <p>f_2_idxf_2_idxf_2_idx f_2_idx</p>
    <p>...</p>
    <p>%gs: (table)</p>
    <p>...</p>
    <p>&amp;func_2</p>
    <p>...</p>
    <p>f_2_idx</p>
    <p>f_2_idx</p>
    <p>f_2_idx</p>
    <p>func_2</p>
  </div>
  <div class="page">
    <p>Continuous Re-Randomization</p>
    <p>Solution: add extra level of indirection</p>
    <p>f_2_idxptr: f_2_idxf_2_idxf_2_idx</p>
    <p>f_2_idx</p>
    <p>...</p>
    <p>%gs: (table)</p>
    <p>...</p>
    <p>&amp;func_2</p>
    <p>...</p>
    <p>f_2_idx</p>
    <p>f_2_idx</p>
    <p>f_2_idx</p>
    <p>func_2</p>
    <p>(deleted)</p>
  </div>
  <div class="page">
    <p>Code Pointer Abstraction</p>
    <p>Transforming *code_ptr into **code_ptr  Correctness: pointer updates sound &amp; precise</p>
    <p>Disclosure-resilience: code ptr table is hidden</p>
  </div>
  <div class="page">
    <p>Code Pointer Abstraction</p>
    <p>Transforming *code_ptr into **code_ptr  Correctness: pointer updates sound &amp; precise</p>
    <p>Disclosure-resilience: code ptr table is hidden</p>
    <p>f_2_idxptr: func_2</p>
    <p>func_2</p>
    <p>...%gs:</p>
    <p>...</p>
  </div>
  <div class="page">
    <p>Code Pointer Abstraction</p>
    <p>Transforming *code_ptr into **code_ptr  Correctness: pointer updates sound &amp; precise</p>
    <p>Disclosure-resilience: code ptr table is hidden</p>
    <p>f_2_idxptr: func_2</p>
    <p>func_2</p>
    <p>...%gs:</p>
    <p>...</p>
    <p>mov $0x40054d, %rax</p>
    <p>=&gt; mov $0x20, %rax</p>
    <p>Rewrite initialization pointsRewrite call sites callq *%rax</p>
    <p>=&gt; callq *%gs:(%rax)</p>
  </div>
  <div class="page">
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Return Address Encryption</p>
    <p>Return addresses are code pointers too  Could use code pointer table, but inefficient</p>
    <p>call/ret instructions highly optimized</p>
  </div>
  <div class="page">
    <p>Return Address Encryption</p>
    <p>Return addresses are code pointers too  Could use code pointer table, but inefficient</p>
    <p>call/ret instructions highly optimized</p>
    <p>Alternative mechanism  correct and hidden  Use normal call instructions</p>
    <p>Encrypt return addresses with XOR key</p>
  </div>
  <div class="page">
    <p>Return Address Encryption</p>
    <p>Prevent return address disclosure</p>
  </div>
  <div class="page">
    <p>Return Address Encryption</p>
    <p>Prevent return address disclosure</p>
    <p>Thread Stack</p>
    <p>ret addr</p>
    <p>func_2</p>
    <p>func_1</p>
    <p>ret addr</p>
    <p>ret addr</p>
    <p>func_3</p>
  </div>
  <div class="page">
    <p>Return Address Encryption</p>
    <p>Prevent return address disclosure</p>
    <p>Thread Stack</p>
    <p>(encrypted)</p>
    <p>func_2</p>
    <p>func_1</p>
    <p>(encrypted)</p>
    <p>(encrypted)</p>
    <p>func_3</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>XOR key</p>
  </div>
  <div class="page">
    <p>Return Address Encryption</p>
    <p>Prevent return address disclosure</p>
    <p>func:</p>
    <p>; original code</p>
    <p>ret</p>
    <p>Thread Stack</p>
    <p>(encrypted)</p>
    <p>func_2</p>
    <p>func_1</p>
    <p>(encrypted)</p>
    <p>(encrypted)</p>
    <p>func_3</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>XOR key</p>
  </div>
  <div class="page">
    <p>Return Address Encryption</p>
    <p>Prevent return address disclosure  We use binary rewriting (expand basic blocks)</p>
    <p>func: mov %fs:0x28,%r11 xor %r11,(%rsp) ; original code mov %fs:0x28,%r11 xor %r11,(%rsp) ret</p>
    <p>Thread Stack</p>
    <p>(encrypted)</p>
    <p>func_2</p>
    <p>func_1</p>
    <p>(encrypted)</p>
    <p>(encrypted)</p>
    <p>func_3</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>XOR key</p>
  </div>
  <div class="page">
    <p>Return Address Migration</p>
    <p>Unwind stack and re-encrypt new addresses</p>
    <p>Thread Stack</p>
    <p>(encrypted)</p>
    <p>func_2 func_1</p>
    <p>(encrypted)</p>
    <p>(encrypted)</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>XOR key</p>
    <p>func_3</p>
  </div>
  <div class="page">
    <p>Return Address Migration</p>
    <p>Unwind stack and re-encrypt new addresses</p>
    <p>Thread Stack</p>
    <p>func_2 func_1</p>
    <p>func_2</p>
    <p>func_1 +</p>
    <p>+</p>
    <p>+</p>
    <p>XOR key</p>
    <p>func_3</p>
    <p>func_3</p>
    <p>(encrypted)</p>
    <p>(encrypted)</p>
    <p>(encrypted)</p>
  </div>
  <div class="page">
    <p>Return Address Migration</p>
    <p>Unwind stack and re-encrypt new addresses</p>
    <p>Thread Stack</p>
    <p>(deleted) (deleted)</p>
    <p>func_2</p>
    <p>func_1 +</p>
    <p>+</p>
    <p>+</p>
    <p>XOR key</p>
    <p>(deleted)</p>
    <p>func_3</p>
    <p>(encrypted)</p>
    <p>(encrypted)</p>
    <p>(encrypted)</p>
  </div>
  <div class="page">
    <p>Asynchronous Randomization</p>
  </div>
  <div class="page">
    <p>Asynchronous Randomization</p>
    <p>Computations</p>
    <p>Creating new code copies takes time</p>
  </div>
  <div class="page">
    <p>Asynchronous Randomization</p>
    <p>Creating new code copies takes time</p>
    <p>Computations Generate</p>
    <p>permutation Make new code copy</p>
    <p>Fix call instructions</p>
    <p>Update code pointer table</p>
    <p>Stack unwind</p>
  </div>
  <div class="page">
    <p>Asynchronous Randomization</p>
    <p>Creating new code copies takes time  Shuffler prepares new code asynchronously</p>
    <p>Generate permutation</p>
    <p>Make new code copy</p>
    <p>Fix call instructions</p>
    <p>Update code pointer table</p>
    <p>Stack unwind</p>
    <p>Computations</p>
  </div>
  <div class="page">
    <p>Asynchronous Randomization</p>
    <p>Creating new code copies takes time  Shuffler prepares new code asynchronously</p>
    <p>Stack unwind</p>
    <p>Stack unwind</p>
    <p>Computations Computations</p>
    <p>Generate permutation</p>
    <p>Make new code copy</p>
    <p>Fix call instructions</p>
    <p>Update code pointer table</p>
  </div>
  <div class="page">
    <p>Asynchronous Randomization</p>
    <p>Creating new code copies takes time  Shuffler prepares new code asynchronously  Each thread unwinds its own stack in parallel</p>
    <p>Computations</p>
    <p>Generate permutation</p>
    <p>Make new code copy</p>
    <p>Fix call instructions</p>
    <p>Update code pointer table</p>
    <p>Stack unwind</p>
    <p>Stack unwind</p>
    <p>Computations</p>
  </div>
  <div class="page">
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Augmented Binary Analysis</p>
    <p>Use additional info from unmodified compilers  Symbols, to distinguish code and data (no -s)</p>
    <p>Relocations, to find all code pointers (--emit-relocs)</p>
  </div>
  <div class="page">
    <p>Augmented Binary Analysis</p>
    <p>Use additional info from unmodified compilers  Symbols, to distinguish code and data (no -s)</p>
    <p>Relocations, to find all code pointers (--emit-relocs)</p>
    <p>.section .rodata: .quad 0x400620</p>
    <p>.section .text: mov $0x400620, %rax</p>
    <p>Code pointer, or integer?</p>
  </div>
  <div class="page">
    <p>Augmented Binary Analysis</p>
    <p>Use additional info from unmodified compilers  Symbols, to distinguish code and data (no -s)</p>
    <p>Relocations, to find all code pointers (--emit-relocs)</p>
    <p>.section .rodata: .quad 0x400620</p>
    <p>.section .text: mov $0x400620, %rax</p>
    <p>.section .rodata: .quad 4195872</p>
    <p>.section .text: mov $4195872, %rax</p>
    <p>Code pointer, or integer?</p>
  </div>
  <div class="page">
    <p>Augmented Binary Analysis</p>
    <p>Use additional info from unmodified compilers  Symbols, to distinguish code and data (no -s)</p>
    <p>Relocations, to find all code pointers (--emit-relocs)</p>
    <p>.section .rodata: .quad 0x400620</p>
    <p>.section .text: mov $0x400620, %rax</p>
    <p>Code pointer, or integer?</p>
    <p>Relocations (meta-data)</p>
    <p>.section .rodata: .quad 4195872</p>
    <p>.section .text: mov $4195872, %rax</p>
  </div>
  <div class="page">
    <p>Augmented Binary Analysis</p>
    <p>Use additional info from unmodified compilers  Symbols, to distinguish code and data (no -s)</p>
    <p>Relocations, to find all code pointers (--emit-relocs)  ask linker to preserve relocations</p>
    <p>.section .rodata: .quad 0x400620</p>
    <p>.section .text: mov $0x400620, %rax</p>
    <p>Code pointer, or integer?</p>
    <p>Relocations (meta-data)</p>
    <p>.section .rodata: .quad 4195872</p>
    <p>.section .text: mov $4195872, %rax</p>
  </div>
  <div class="page">
    <p>Augmented Binary Analysis</p>
    <p>Allows accurate and complete disassembly</p>
  </div>
  <div class="page">
    <p>Augmented Binary Analysis</p>
    <p>Allows accurate and complete disassembly  Many special cases, but we handle them</p>
  </div>
  <div class="page">
    <p>Where to Re-Randomize From</p>
    <p>Most defenses operate at higher privilege level  i.e. kernel, hypervisor, hardware</p>
    <p>Or else declare their own code trusted</p>
  </div>
  <div class="page">
    <p>Where to Re-Randomize From</p>
    <p>Most defenses operate at higher privilege level  i.e. kernel, hypervisor, hardware</p>
    <p>Or else declare their own code trusted</p>
    <p>Shuffler is egalitarian  Same level of privilege, no system modifications</p>
    <p>Defends itself from attack</p>
  </div>
  <div class="page">
    <p>Egalitarian Bootstrapping</p>
    <p>Problem: transformations break original code  e.g. memcpy uses code pointers</p>
  </div>
  <div class="page">
    <p>Egalitarian Bootstrapping</p>
    <p>Problem: transformations break original code  e.g. memcpy uses code pointers</p>
    <p>mov 0x400620(,%rax,8),%rax jmpq *%rax</p>
    <p>memcpys code</p>
  </div>
  <div class="page">
    <p>Egalitarian Bootstrapping</p>
    <p>Problem: transformations break original code  e.g. memcpy uses code pointers</p>
    <p>Rewrite main, printf, ..., memcpy, ...</p>
    <p>mov 0x400620(,%rax,8),%rax jmpq *%rax</p>
    <p>memcpys code</p>
  </div>
  <div class="page">
    <p>Egalitarian Bootstrapping</p>
    <p>Problem: transformations break original code  e.g. memcpy uses code pointers</p>
    <p>Rewrite main, printf, ..., memcpy, ...</p>
    <p>mov 0x400620(,%rax,8),%rax jmpq *%rax</p>
    <p>memcpys code mov 0x400620(,%rax,8),%rax jmpq *%gs:(%rax)</p>
    <p>New memcpy code</p>
    <p>Invalidates memcpy jump table</p>
    <p>But rewrite process uses (old) memcpy</p>
  </div>
  <div class="page">
    <p>Egalitarian Bootstrapping</p>
    <p>Problem: transformations break original code  e.g. memcpy uses code pointers</p>
    <p>Rewrite main, printf, ..., memcpy, ...</p>
    <p>mov 0x400620(,%rax,8),%rax jmpq *%rax</p>
    <p>memcpys code mov 0x400620(,%rax,8),%rax jmpq *%gs:(%rax)</p>
    <p>New memcpy code</p>
    <p>??</p>
    <p>Invalidates memcpy jump table</p>
    <p>But rewrite process uses (old) memcpy</p>
  </div>
  <div class="page">
    <p>Egalitarian Bootstrapping</p>
    <p>Problem: transformations break original code  e.g. memcpy uses code pointers</p>
    <p>Solution: use two copies of Shuffler</p>
  </div>
  <div class="page">
    <p>Egalitarian Bootstrapping</p>
    <p>Problem: transformations break original code  e.g. memcpy uses code pointers</p>
    <p>Solution: use two copies of Shuffler</p>
    <p>Shuffler stage 1</p>
    <p>Shuffler stage 2</p>
    <p>Other libraries</p>
    <p>C library</p>
    <p>Program</p>
    <p>Loader loads</p>
    <p>rewrites</p>
  </div>
  <div class="page">
    <p>Egalitarian Bootstrapping</p>
    <p>Problem: transformations break original code  e.g. memcpy uses code pointers</p>
    <p>Solution: use two copies of Shuffler</p>
    <p>Shuffler stage 1</p>
    <p>Shuffler stage 2</p>
    <p>Other libraries</p>
    <p>C library</p>
    <p>Program</p>
    <p>Loader</p>
    <p>invokes</p>
  </div>
  <div class="page">
    <p>Egalitarian Bootstrapping</p>
    <p>Problem: transformations break original code  e.g. memcpy uses code pointers</p>
    <p>Solution: use two copies of Shuffler</p>
    <p>Shuffler stage 1</p>
    <p>Shuffler stage 2</p>
    <p>Other libraries</p>
    <p>C library</p>
    <p>Program</p>
    <p>Loader</p>
    <p>erases erases</p>
  </div>
  <div class="page">
    <p>Egalitarian Bootstrapping</p>
    <p>Problem: transformations break original code  e.g. memcpy uses code pointers</p>
    <p>Solution: use two copies of Shuffler  Make new copies</p>
    <p>Shuffler stage 2</p>
    <p>Other libraries</p>
    <p>C library</p>
    <p>Program</p>
    <p>Shuffler stage 2</p>
    <p>Other libraries</p>
    <p>C library</p>
    <p>Program</p>
  </div>
  <div class="page">
    <p>Egalitarian Bootstrapping</p>
    <p>Problem: transformations break original code  e.g. memcpy uses code pointers</p>
    <p>Solution: use two copies of Shuffler  Make new copies</p>
    <p>Shuffler stage 2</p>
    <p>Other libraries</p>
    <p>C library</p>
    <p>Program</p>
  </div>
  <div class="page">
    <p>Egalitarian Bootstrapping</p>
    <p>Problem: transformations break original code  e.g. memcpy uses code pointers</p>
    <p>Solution: use two copies of Shuffler  Make new copies</p>
    <p>Shuffler stage 2</p>
    <p>Other libraries</p>
    <p>C library</p>
    <p>Program</p>
    <p>Shuffler stage 2</p>
    <p>Other libraries</p>
    <p>C library</p>
    <p>Program</p>
  </div>
  <div class="page">
    <p>Egalitarian Bootstrapping</p>
    <p>Problem: transformations break original code  e.g. memcpy uses code pointers</p>
    <p>Solution: use two copies of Shuffler  Make new copies</p>
    <p>Shuffler stage 2</p>
    <p>Other libraries</p>
    <p>C library</p>
    <p>Program</p>
  </div>
  <div class="page">
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Performance Evaluation</p>
    <p>SPEC CPU overhead at 50ms = 14.9%</p>
  </div>
  <div class="page">
    <p>Performance Evaluation</p>
    <p>SPEC CPU overhead at 50ms = 14.9%  Multiprocess Nginx up to 24 workers</p>
  </div>
  <div class="page">
    <p>Security Evaluation</p>
    <p>Two disclosure-based attack methodologies:  Scan many pages for the desired gadgets</p>
    <p>impacted by disclosure time, network latency</p>
    <p>Explore gadget space in small number of pages  impacted by ROP chain computation time (&gt; 40 seconds)</p>
  </div>
  <div class="page">
    <p>Security Evaluation</p>
    <p>Two disclosure-based attack methodologies:  Scan many pages for the desired gadgets</p>
    <p>impacted by disclosure time, network latency</p>
    <p>Explore gadget space in small number of pages  impacted by ROP chain computation time (&gt; 40 seconds)</p>
    <p>Published JIT-ROP takes 2300-378000 ms  We can re-randomize typically every 20-50 ms</p>
  </div>
  <div class="page">
    <p>Demo</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Conclusion</p>
    <p>Continuous re-randomization every 20-50 ms</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Continuous re-randomization every 20-50 ms  Fast:</p>
    <p>Defeats all known code reuse attacks</p>
    <p>Asynchronous shuffling offloads overhead</p>
    <p>Deployable:  Binary analysis w/o modifying kernel, compiler, ...</p>
    <p>Egalitarian:  No additional privileges required</p>
    <p>Shuffler defends its own code</p>
  </div>
  <div class="page">
    <p>Questions?</p>
    <p>Demo website: http://shuffled.elfery.net:8000</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>JIT-ROP, SOSP 2013  Oxymoron, Usenix Sec 2014  Code Pointer Integrity, OSDI 2014  Stabilizer, SIGARCH 2013  Remix, CODASPY 2016  TASR, CCS 2015  ...more related work in our paper</p>
    <p>[1] https://securityintelligence.com/anti-rop-a-moving-target-defense/ [2] http://www.ieee-security.org/TC/SP2013/papers/4977a574.pdf</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Translating stack unwind information  Breaks C++ exceptions, pthread_cancel, etc.</p>
    <p>Cannot shuffle the loader currently  Breaks dlopen</p>
    <p>If shuffling takes too long, no mechanism to pause target program</p>
  </div>
  <div class="page">
    <p>Shuffler Thread Performance</p>
    <p>Asynchronous shuffling runs quickly  Synchronous runtime is 0.3% of total runtime</p>
  </div>
  <div class="page">
    <p>Scalability</p>
    <p>Tradeoff for server workers  Multithreaded =&gt; better performance overhead</p>
    <p>Multiprocess =&gt; no disclosures across workers</p>
    <p>Both techniques scale well in practice (up to 24x)</p>
    <p>unw</p>
    <p>unwComputations</p>
    <p>unwComputations</p>
    <p>unwComputations</p>
    <p>Multithreaded program</p>
    <p>unw</p>
    <p>unwComputations</p>
    <p>unwComputations</p>
    <p>Multiprocess program</p>
    <p>unw</p>
    <p>n Shuffler threads1 common Shuffler thread</p>
  </div>
</Presentation>
