<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>PLOVER: Fast, Multi-core Scalable Virtual Machine Fault-tolerance</p>
    <p>Cheng Wang, Xusheng Chen, Weiwei Jia, Boxuan Li, Haoran Qiu, Shixiong Zhao, and Heming Cui</p>
    <p>The University of Hong Kong</p>
  </div>
  <div class="page">
    <p>Virtual machines are pervasive in datacenters Physical machine</p>
    <p>Guest VM Guest VM</p>
    <p>VMM</p>
    <p>VM fault tolerance is crucial! 2</p>
    <p>Physical machine</p>
    <p>Guest VM Guest VM</p>
    <p>VMM</p>
    <p>Hardware Failure</p>
  </div>
  <div class="page">
    <p>Classic VM replication primary/backup approach</p>
    <p>Remus [NSDI08]</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>client</p>
  </div>
  <div class="page">
    <p>Classic VM replication primary/backup approach</p>
    <p>Remus [NSDI08]</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>backup</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>client</p>
  </div>
  <div class="page">
    <p>Classic VM replication primary/backup approach</p>
    <p>Remus [NSDI08]</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>backup</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>client</p>
  </div>
  <div class="page">
    <p>Classic VM replication primary/backup approach</p>
    <p>Remus [NSDI08]</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>backup</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>client</p>
    <p>Synchronize primary/backup every 25ms 1. Pause primary VM (every 25ms) and</p>
    <p>transmit all changed state (e.g., memory pages) to backup.</p>
  </div>
  <div class="page">
    <p>Classic VM replication primary/backup approach</p>
    <p>Remus [NSDI08]</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>backup</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>client</p>
    <p>Synchronize primary/backup every 25ms 1. Pause primary VM (every 25ms) and</p>
    <p>transmit all changed state (e.g., memory pages) to backup.</p>
  </div>
  <div class="page">
    <p>Classic VM replication primary/backup approach</p>
    <p>Remus [NSDI08]</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>backup</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>client</p>
    <p>Synchronize primary/backup every 25ms 1. Pause primary VM (every 25ms) and</p>
    <p>transmit all changed state (e.g., memory pages) to backup.</p>
  </div>
  <div class="page">
    <p>Classic VM replication primary/backup approach</p>
    <p>Remus [NSDI08]</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>Output buffer</p>
    <p>memory pages</p>
    <p>backup</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>client</p>
    <p>Synchronize primary/backup every 25ms 1. Pause primary VM (every 25ms) and</p>
    <p>transmit all changed state (e.g., memory pages) to backup.</p>
  </div>
  <div class="page">
    <p>Classic VM replication primary/backup approach</p>
    <p>Remus [NSDI08]</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>Output buffer</p>
    <p>memory pages</p>
    <p>backup</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>client</p>
    <p>Synchronize primary/backup every 25ms 1. Pause primary VM (every 25ms) and</p>
    <p>transmit all changed state (e.g., memory pages) to backup.</p>
  </div>
  <div class="page">
    <p>Classic VM replication primary/backup approach</p>
    <p>Remus [NSDI08]</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>Output buffer</p>
    <p>memory pages</p>
    <p>backup</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>client</p>
    <p>Synchronize primary/backup every 25ms 1. Pause primary VM (every 25ms) and</p>
    <p>transmit all changed state (e.g., memory pages) to backup.</p>
  </div>
  <div class="page">
    <p>Classic VM replication primary/backup approach</p>
    <p>Remus [NSDI08]</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>Output buffer</p>
    <p>memory pages</p>
    <p>backup</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>client</p>
    <p>Synchronize primary/backup every 25ms 1. Pause primary VM (every 25ms) and</p>
    <p>transmit all changed state (e.g., memory pages) to backup.</p>
  </div>
  <div class="page">
    <p>Classic VM replication primary/backup approach</p>
    <p>Remus [NSDI08]</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>Output buffer</p>
    <p>memory pages</p>
    <p>backup</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>client</p>
    <p>ACK</p>
    <p>Synchronize primary/backup every 25ms 1. Pause primary VM (every 25ms) and</p>
    <p>transmit all changed state (e.g., memory pages) to backup.</p>
  </div>
  <div class="page">
    <p>Classic VM replication primary/backup approach</p>
    <p>Remus [NSDI08]</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>Output buffer</p>
    <p>memory pages</p>
    <p>backup</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>client</p>
    <p>ACK</p>
    <p>Synchronize primary/backup every 25ms 1. Pause primary VM (every 25ms) and</p>
    <p>transmit all changed state (e.g., memory pages) to backup.</p>
  </div>
  <div class="page">
    <p>Classic VM replication primary/backup approach</p>
    <p>Remus [NSDI08]</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>Output buffer</p>
    <p>memory pages</p>
    <p>backup</p>
    <p>Guest VM</p>
    <p>service</p>
    <p>VMM</p>
    <p>memory pages</p>
    <p>client</p>
    <p>ACK</p>
    <p>Synchronize primary/backup every 25ms 1. Pause primary VM (every 25ms) and</p>
    <p>transmit all changed state (e.g., memory pages) to backup.</p>
  </div>
  <div class="page">
    <p>Two limitations of primary/backup approach (1)</p>
    <p>Too many memory pages have to be copied and transferred, greatly ballooned client-perceived latency</p>
    <p># of concurrent clients Page transfer size (MB) 16 20.9</p>
    <p>La te</p>
    <p>nc y</p>
    <p>(u s)</p>
    <p>Number of concurrent clients</p>
    <p>Redis latency with varied # of clients (4 vCPUs per VM) unreplicated Remus (25ms synchronization interval)</p>
  </div>
  <div class="page">
    <p>Two limitations of primary/backup approach (2)</p>
    <p>The split-brain problem</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>KVS</p>
    <p>VMM</p>
    <p>Output buffer</p>
    <p>page</p>
    <p>Backup</p>
    <p>Guest VM</p>
    <p>KVS</p>
    <p>VMM</p>
    <p>page</p>
    <p>client1 client2</p>
  </div>
  <div class="page">
    <p>Two limitations of primary/backup approach (2)</p>
    <p>The split-brain problem</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>KVS</p>
    <p>VMM</p>
    <p>Output buffer</p>
    <p>page</p>
    <p>Backup</p>
    <p>Guest VM</p>
    <p>KVS</p>
    <p>VMM</p>
    <p>page</p>
    <p>client1 client2</p>
  </div>
  <div class="page">
    <p>Two limitations of primary/backup approach (2)</p>
    <p>The split-brain problem</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>KVS</p>
    <p>VMM</p>
    <p>Output buffer</p>
    <p>page</p>
    <p>Backup</p>
    <p>Guest VM</p>
    <p>KVS</p>
    <p>VMM</p>
    <p>page</p>
    <p>client1 client2</p>
    <p>Outdated primary New primary</p>
  </div>
  <div class="page">
    <p>Two limitations of primary/backup approach (2)</p>
    <p>The split-brain problem</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>KVS</p>
    <p>VMM</p>
    <p>Output buffer</p>
    <p>page</p>
    <p>Backup</p>
    <p>Guest VM</p>
    <p>KVS</p>
    <p>VMM</p>
    <p>page</p>
    <p>client1 client2</p>
    <p>X=5 x=7</p>
    <p>Outdated primary New primary</p>
  </div>
  <div class="page">
    <p>Two limitations of primary/backup approach (2)</p>
    <p>The split-brain problem</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>KVS</p>
    <p>VMM</p>
    <p>Output buffer</p>
    <p>page</p>
    <p>Backup</p>
    <p>Guest VM</p>
    <p>KVS</p>
    <p>VMM</p>
    <p>page</p>
    <p>client1 client2</p>
    <p>X=5 x=7</p>
    <p>Outdated primary New primary</p>
  </div>
  <div class="page">
    <p>Two limitations of primary/backup approach (2)</p>
    <p>The split-brain problem</p>
    <p>ACK Primary</p>
    <p>Guest VM</p>
    <p>KVS</p>
    <p>VMM</p>
    <p>Output buffer</p>
    <p>page</p>
    <p>Backup</p>
    <p>Guest VM</p>
    <p>KVS</p>
    <p>VMM</p>
    <p>page</p>
    <p>client1 client2</p>
    <p>x =5 x =7</p>
    <p>X=5 x=7</p>
    <p>Outdated primary New primary</p>
  </div>
  <div class="page">
    <p>State Machine Replication (SMR): Powerful</p>
    <p>service</p>
    <p>backup</p>
    <p>client1 client2</p>
    <p>service</p>
    <p>primary</p>
    <p>service</p>
    <p>backup</p>
    <p>consensus log consensus logconsensus log</p>
  </div>
  <div class="page">
    <p>State Machine Replication (SMR): Powerful</p>
    <p>service</p>
    <p>backup</p>
    <p>client1 client2</p>
    <p>service</p>
    <p>primary</p>
    <p>service</p>
    <p>backup</p>
    <p>consensus log consensus logconsensus log</p>
  </div>
  <div class="page">
    <p>State Machine Replication (SMR): Powerful</p>
    <p>service</p>
    <p>backup</p>
    <p>client1 client2</p>
    <p>service</p>
    <p>primary</p>
    <p>service</p>
    <p>backup</p>
    <p>consensus log consensus logconsensus log</p>
  </div>
  <div class="page">
    <p>State Machine Replication (SMR): Powerful</p>
    <p>service</p>
    <p>backup</p>
    <p>client1 client2</p>
    <p>service</p>
    <p>primary</p>
    <p>service</p>
    <p>backup</p>
    <p>consensus log consensus logconsensus log</p>
    <p>SMR systems: Chubby, Zookeeper, Raft [ATC14], Consensus in a box [NSDI15], NOPaxos[OSDI16], APUS [SoCC17]</p>
    <p>Ensure same execution states</p>
  </div>
  <div class="page">
    <p>State Machine Replication (SMR): Powerful</p>
    <p>service</p>
    <p>backup</p>
    <p>client1 client2</p>
    <p>service</p>
    <p>primary</p>
    <p>service</p>
    <p>backup</p>
    <p>consensus log consensus logconsensus log</p>
    <p>SMR systems: Chubby, Zookeeper, Raft [ATC14], Consensus in a box [NSDI15], NOPaxos[OSDI16], APUS [SoCC17]</p>
    <p>Ensure same execution states  Strong fault tolerance guarantee without split-brain problem</p>
  </div>
  <div class="page">
    <p>State Machine Replication (SMR): Powerful</p>
    <p>service</p>
    <p>backup</p>
    <p>client1 client2</p>
    <p>service</p>
    <p>primary</p>
    <p>service</p>
    <p>backup</p>
    <p>consensus log consensus logconsensus log</p>
    <p>SMR systems: Chubby, Zookeeper, Raft [ATC14], Consensus in a box [NSDI15], NOPaxos[OSDI16], APUS [SoCC17]</p>
    <p>Ensure same execution states  Strong fault tolerance guarantee without split-brain problem</p>
    <p>Need to handle non-determinism  Deterministic multithreading (e.g., CRANE [SOSP15]) - slow  Manually annotate service code to capture non-determinism (e.g., Eve [OSDI12]) - error prone</p>
  </div>
  <div class="page">
    <p>Making a choice</p>
    <p>Primary/backup approach Pros:  Automatically handle non-determinism</p>
    <p>Cons:  Unsatisfactory performance due to transferring</p>
    <p>large amount of state  Have the split-brain problem</p>
    <p>State machine replication Pros:  Good performance by ensuring the same</p>
    <p>execution states  Solve the split-brain problem</p>
    <p>Cons:  Hard to handle non-determinism</p>
  </div>
  <div class="page">
    <p>PLOVER: Combining SMR and primary/backup</p>
    <p>Simple to achieve by carefully designing the consensus protocol  Step 1: Use Paxos to ensure the same total order of requests for replicas  Step 2: Invoke VM synchronization periodically and then release replies</p>
    <p>Combines the benefits of SMR and primary/backup  Step 1 makes primary/backup have mostly the same memory (up to 97%), then</p>
    <p>PLOVER need only copy and transfer a small portion of the memory  Step 2 automatically addresses non-determinism and ensures external consistency</p>
    <p>Challenges:  How to achieve consensus and synchronize VM efficiently?  When to do the VM synchronization for primary/backup to maximize the same</p>
    <p>memory pages?</p>
  </div>
  <div class="page">
    <p>PLOVER architecture</p>
    <p>Primary Backup Witness</p>
    <p>VM Sync VM</p>
    <p>consensusOutput buffer</p>
    <p>VMM</p>
    <p>service</p>
    <p>Sync VM VM</p>
    <p>service</p>
    <p>Client</p>
    <p>log log</p>
    <p>page page</p>
    <p>consensus Output buffer consensus</p>
    <p>VMM</p>
  </div>
  <div class="page">
    <p>PLOVER architecture</p>
    <p>Primary Backup Witness</p>
    <p>VM Sync VM</p>
    <p>consensusOutput buffer</p>
    <p>VMM</p>
    <p>service</p>
    <p>Sync VM VM</p>
    <p>service</p>
    <p>Client</p>
    <p>log log</p>
    <p>page page</p>
    <p>consensus Output buffer consensus</p>
    <p>VMM</p>
  </div>
  <div class="page">
    <p>PLOVER architecture</p>
    <p>Primary Backup Witness</p>
    <p>VM Sync VM</p>
    <p>consensusOutput buffer</p>
    <p>VMM</p>
    <p>service</p>
    <p>Sync VM VM</p>
    <p>service</p>
    <p>Client</p>
    <p>log log</p>
    <p>page page</p>
    <p>consensus Output buffer consensus</p>
    <p>RDMA-based input consensus:  Primary: propose request and execute  Backup: agree on request and execute  Witness: agree on request and ignore</p>
    <p>VMM</p>
  </div>
  <div class="page">
    <p>PLOVER architecture</p>
    <p>Primary Backup Witness</p>
    <p>VM Sync VM</p>
    <p>consensusOutput buffer</p>
    <p>VMM</p>
    <p>service</p>
    <p>Sync VM VM</p>
    <p>service</p>
    <p>Client</p>
    <p>log log</p>
    <p>page page</p>
    <p>consensus Output buffer consensus</p>
    <p>RDMA (&lt;10us)</p>
    <p>RDMA-based input consensus:  Primary: propose request and execute  Backup: agree on request and execute  Witness: agree on request and ignore</p>
    <p>VMM</p>
  </div>
  <div class="page">
    <p>PLOVER architecture</p>
    <p>Primary Backup Witness</p>
    <p>VM Sync VM</p>
    <p>consensusOutput buffer</p>
    <p>VMM</p>
    <p>service</p>
    <p>Sync VM VM</p>
    <p>service</p>
    <p>Client</p>
    <p>log log</p>
    <p>page page</p>
    <p>consensus Output buffer consensus</p>
    <p>RDMA (&lt;10us)</p>
    <p>RDMA-based input consensus:  Primary: propose request and execute  Backup: agree on request and execute  Witness: agree on request and ignore</p>
    <p>VMM</p>
  </div>
  <div class="page">
    <p>PLOVER architecture</p>
    <p>Primary Backup Witness</p>
    <p>VM Sync VM</p>
    <p>consensusOutput buffer</p>
    <p>VMM</p>
    <p>service</p>
    <p>Sync VM VM</p>
    <p>service</p>
    <p>Client</p>
    <p>log log</p>
    <p>page page</p>
    <p>consensus Output buffer consensus</p>
    <p>RDMA (&lt;10us)</p>
    <p>RDMA-based input consensus:  Primary: propose request and execute  Backup: agree on request and execute  Witness: agree on request and ignore</p>
    <p>VMM</p>
  </div>
  <div class="page">
    <p>PLOVER architecture</p>
    <p>Primary Backup Witness</p>
    <p>VM Sync VM</p>
    <p>consensusOutput buffer</p>
    <p>VMM</p>
    <p>service</p>
    <p>Sync VM VM</p>
    <p>service</p>
    <p>Client</p>
    <p>log log</p>
    <p>page page</p>
    <p>RDMA-based VM synchronization:</p>
    <p>consensus Output buffer consensus</p>
    <p>RDMA (&lt;10us)</p>
    <p>RDMA-based input consensus:  Primary: propose request and execute  Backup: agree on request and execute  Witness: agree on request and ignore</p>
    <p>VMM</p>
  </div>
  <div class="page">
    <p>PLOVER architecture</p>
    <p>Primary Backup Witness</p>
    <p>VM Sync VM</p>
    <p>consensusOutput buffer</p>
    <p>VMM</p>
    <p>service</p>
    <p>Sync VM VM</p>
    <p>service</p>
    <p>Client</p>
    <p>log log</p>
    <p>page page</p>
    <p>RDMA-based VM synchronization: 1. Exchange and union dirty page bitmap 2. Compute hash of each dirty page 3. Compare hashes 4. Transfer divergent pages</p>
    <p>consensus Output buffer consensus</p>
    <p>RDMA (&lt;10us)</p>
    <p>RDMA RDMA-based input consensus:  Primary: propose request and execute  Backup: agree on request and execute  Witness: agree on request and ignore</p>
    <p>VMM</p>
  </div>
  <div class="page">
    <p>PLOVER architecture</p>
    <p>Primary Backup Witness</p>
    <p>VM Sync VM</p>
    <p>consensusOutput buffer</p>
    <p>VMM</p>
    <p>service</p>
    <p>Sync VM VM</p>
    <p>service</p>
    <p>Client</p>
    <p>log log</p>
    <p>page page</p>
    <p>RDMA-based VM synchronization: 1. Exchange and union dirty page bitmap 2. Compute hash of each dirty page 3. Compare hashes 4. Transfer divergent pages</p>
    <p>consensus Output buffer consensus</p>
    <p>RDMA (&lt;10us)</p>
    <p>RDMA RDMA-based input consensus:  Primary: propose request and execute  Backup: agree on request and execute  Witness: agree on request and ignore</p>
    <p>VMM</p>
  </div>
  <div class="page">
    <p>PLOVER architecture</p>
    <p>Primary Backup Witness</p>
    <p>VM Sync VM</p>
    <p>consensusOutput buffer</p>
    <p>VMM</p>
    <p>service</p>
    <p>Sync VM VM</p>
    <p>service</p>
    <p>Client</p>
    <p>log log</p>
    <p>page page</p>
    <p>RDMA-based VM synchronization: 1. Exchange and union dirty page bitmap 2. Compute hash of each dirty page 3. Compare hashes 4. Transfer divergent pages</p>
    <p>consensus Output buffer consensus</p>
    <p>RDMA (&lt;10us)</p>
    <p>RDMA RDMA-based input consensus:  Primary: propose request and execute  Backup: agree on request and execute  Witness: agree on request and ignore</p>
    <p>VMM</p>
  </div>
  <div class="page">
    <p>When to decide VM synchronization period?</p>
    <p>Primary Backup</p>
    <p>VM Sync VM</p>
    <p>VMM</p>
    <p>service</p>
    <p>Sync VM VM</p>
    <p>service</p>
    <p>page page</p>
    <p>VMM</p>
  </div>
  <div class="page">
    <p>When to decide VM synchronization period?</p>
    <p>Primary Backup</p>
    <p>VM Sync VM</p>
    <p>VMM</p>
    <p>service</p>
    <p>Sync VM VM</p>
    <p>service</p>
    <p>page page</p>
    <p>VMM</p>
  </div>
  <div class="page">
    <p>When to decide VM synchronization period?</p>
    <p>Primary Backup</p>
    <p>VM Sync VM</p>
    <p>VMM</p>
    <p>service</p>
    <p>Sync VM VM</p>
    <p>service</p>
    <p>page page</p>
    <p>VMM</p>
  </div>
  <div class="page">
    <p>When to decide VM synchronization period?</p>
    <p>Primary Backup</p>
    <p>VM Sync VM</p>
    <p>VMM</p>
    <p>service</p>
    <p>Sync VM VM</p>
    <p>service</p>
    <p>page page</p>
    <p>VMM</p>
    <p>Issue of not choosing synchronization timing carefully  Large amount of divergent state</p>
    <p>Synchronize when processing is almost finished!  CPU and disk usage is almost zero when service finishes</p>
    <p>processing  Non-intrusive scheme to monitor service state  Invoke synchronization when CPU and disk usage is</p>
    <p>nearly zero</p>
  </div>
  <div class="page">
    <p>PLOVER addressed other practical challenges</p>
    <p>Concurrent hash computation of dirty pages  Fast consensus without interrupting the VMMs I/O event loop  Collect service running state from VMM without hurting performance  Full integration with KVM-QEMU</p>
  </div>
  <div class="page">
    <p>Evaluation setup</p>
    <p>Three replica machines  Dell R430 server  Connected with 40Gbps network  Guest VM configured with 4 vCPU and 16GB memory</p>
    <p>Metrics: measured both throughput and latency with 95% percentile</p>
    <p>Compared with three state-of-the-art VM fault tolerance systems  Remus (NSDI08): use its latest KVM-based implementation developed by KVM  STR (DSN09) and COLO (SoCC13): various optimizations of Remus. E.g., COLO skips</p>
    <p>synchronization if network outputs from two VMs are the same</p>
  </div>
  <div class="page">
    <p>Evaluated PLOVER on 12 programs, grouped into 8 services</p>
    <p>service Program type Benchmark Workload</p>
    <p>Redis Key value store self 50% SET, 50% GET</p>
    <p>SSDB Key value store self 50% SET, 50% GET</p>
    <p>MediaTomb Multimedia storage server ApacheBench Transcoding videos</p>
    <p>pgSQL Database server pgbench TPC-B</p>
    <p>DjCMS (Nginx, Python, MySQL)</p>
    <p>Content management system ApacheBench Web requests on a dashboard page</p>
    <p>Tomcat HTTP web server ApacheBench Web requests on a shopping store page</p>
    <p>lighttpd HTTP web server ApacheBench Watermark image with PHP</p>
    <p>Node.js HTTP web server ApacheBench Web requests on a messenger bot</p>
  </div>
  <div class="page">
    <p>Evaluation questions</p>
    <p>How does PLOVER compare to unreplicated VM and state-of-the-art VM fault tolerance systems?</p>
    <p>How does PLOVER scale to multi-core?  What is PLOVERs CPU footprint?  How robust is PLOVER to failures?</p>
    <p>Handle network partition, leader failure, etc, efficiently  Comparison of PLOVER and other three systems on different</p>
    <p>parameter settings?  PLOVER is still much faster than the three systems</p>
  </div>
  <div class="page">
    <p>Throughput on four services</p>
  </div>
  <div class="page">
    <p>Throughput on the other four services</p>
  </div>
  <div class="page">
    <p>Lighttpd+PHP performance analysis</p>
    <p>Interval Dirty Page Same Transfer 86ms 33.9K 97% 2.8ms</p>
    <p>Sync-interval Dirty Page Transfer 25ms (Remus-Xen default) 33.3K 53.5ms</p>
    <p>PLOVER:</p>
    <p>Remus:</p>
    <p>Analysis: PLOVER needs to transfer only 33.9k * 3% = 1.0K pages, But Remus, STR, and COLO need to transfer all or most of the 33K dirty pages. E.g., since most network outputs from two VMs differ, COLO has to do synchronizations for almost every output packet.</p>
    <p>lighttpd + PHP</p>
  </div>
  <div class="page">
    <p>pgSQL performance analysis</p>
    <p>PLOVER is slower than COLO on pgSQL  COLO safely skips synchronization because</p>
    <p>most network outputs from two VMs are the same</p>
  </div>
  <div class="page">
    <p>Performance Summary (4 vCPU per VM)</p>
    <p>PLOVERs throughput is 21% lower than unreplicated, 0.9X higher than Remus, 1.0X higher than COLO, 1.4X higher than STR  72% ~ 97% dirty memory pages between PLOVERs primary and backup are the same  PLOVERs TCP implementation throughput is still 0.9X higher the three systems on</p>
    <p>average 19</p>
  </div>
  <div class="page">
    <p>Multi-core Scalability (4vCPU - 16vCPU per VM)</p>
    <p>Redis, DjCMS, pgSQL, and Node.js are not listed because they dont need many vCPUs per VM to improve throughput  E.g., Redis is single-threaded</p>
  </div>
  <div class="page">
    <p>CPU footprint</p>
  </div>
  <div class="page">
    <p>Conclusion and Ongoing Work</p>
    <p>PLOVER: efficiently replicate VM with strong fault tolerance  Low performance overhead, scalable to multi-core, robust to replica failures</p>
    <p>Collaborating with Huawei for technology transfer  Funded by Huawei Innovation Research Program 2017  Submitted a patent (Patent Cooperation Treaty ID: 85714660PCT01)</p>
    <p>https://github.com/hku-systems/plover</p>
  </div>
</Presentation>
