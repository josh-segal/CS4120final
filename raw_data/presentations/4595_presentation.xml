<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Finding Optimal Probabilistic Generators for XML Collections</p>
    <p>Serge Abiteboul, Yael Amsterdamer, Daniel Deutch, Tova Milo, Pierre Senellart</p>
  </div>
  <div class="page">
    <p>Adding probabilities to an XML Schema</p>
    <p>Given a collection of XML documents, we sometimes have a schema the documents conform to.  E.g., DTD or XSD</p>
    <p>Restricts the structure, mostly parent-child node relations (using regular expressions)</p>
    <p>The schema may be very general (e.g., xhtml, RSS)</p>
    <p>We want to add probabilities that reflect the likelihood of different parts of the schema  We will use the probabilities to turn the schema into a probabilistic</p>
    <p>generative model for XML documents</p>
    <p>In particular, we want them to maximize the likelihood of a given XML document or document collection</p>
    <p>- 2</p>
    <p>Motivation</p>
  </div>
  <div class="page">
    <p>One Application: XML AutoCompletion [SIGMOD 2012]</p>
    <p>Based on previous document versions / corpus of example documents</p>
    <p>Suggest nodes / sub-trees / node values to the user</p>
    <p>For example:</p>
    <p>Challenges:</p>
    <p>Allow editing in every part of the document</p>
    <p>What kind of completion to suggest?</p>
    <p>Finding the top-k best completions</p>
    <p>- 3</p>
    <p>Motivation</p>
    <p>&lt;MyPapers&gt; &lt;Paper&gt;</p>
    <p>&lt;title&gt;XML for Beginners&lt;/title&gt; &lt;author&gt;M. Jones&lt;author&gt; &lt;author&gt;H. Q. David&lt;/author&gt; &lt;author&gt;L. Martin&lt;/author&gt; &lt;author&gt;S. Smith&lt;/author&gt;</p>
    <p>&lt;/Paper&gt; &lt;Paper&gt;</p>
    <p>&lt;title&gt;Advanced XML&lt;/title&gt; &lt;author&gt;M. Jones&lt;/author&gt; &lt;author&gt;J. E. Peterson&lt;/author&gt; &lt;author&gt;G. L. Williams&lt;/author&gt;</p>
    <p>&lt;/Paper&gt; &lt;Paper&gt;</p>
    <p>&lt;title&gt; &lt;/title&gt; &lt;author&gt; &lt;/author&gt; &lt;author&gt; &lt;/author&gt; &lt;author&gt; &lt;/author&gt;</p>
    <p>&lt;/Paper&gt; &lt;/MyPapers&gt;</p>
  </div>
  <div class="page">
    <p>Many Other Usages for a Probabilistic Schema</p>
    <p>Testing  e.g., generating many XML messages to simulate network load and test system performance.</p>
    <p>Explaining  e.g., a probabilistic schema for DBLP may show which types of publications are rarely used, which kinds of attributes are not filled for BibTex, etc.</p>
    <p>Schema Evaluation  how well a given schema describes a given corpus.</p>
    <p>- 4</p>
    <p>Motivation</p>
  </div>
  <div class="page">
    <p>Our solution - An Outline</p>
    <p>Preliminaries  Tree Automata</p>
    <p>Generators for Schemas without Constraints</p>
    <p>Restart Generators</p>
    <p>Continuation-Test Generators</p>
    <p>Leaf Values</p>
    <p>Adding Constraints</p>
  </div>
  <div class="page">
    <p>Schema as a Deterministic Tree Automaton</p>
    <p>- 6</p>
    <p>Preliminari es</p>
    <p>q 0</p>
    <p>q 1</p>
    <p>q 2</p>
    <p>b</p>
    <p>a c</p>
    <p>$</p>
    <p>An XML document is modeled as an ordered tree.</p>
    <p>Document d0:</p>
    <p>Schema validation: the children of an a-labeled node are accepted by DFA Aa</p>
    <p>Automaton Ar: (L(Ar) = a*bc*$)</p>
    <p>Validation is performed for the children of every inner node.</p>
    <p>abcd abcd532</p>
    <p>$</p>
    <p>r</p>
    <p>a b c</p>
  </div>
  <div class="page">
    <p>Using the Schema as a Generator</p>
    <p>Recall that we want to turn the schema from an acceptor into a probabilistic generative model.</p>
    <p>Straightforward nondeterministic generator: repeatedly choose an accepting run for a node's automaton, and generate children accordingly.</p>
    <p>Adding probabilities: we consider two problem settings</p>
    <p>- 7</p>
    <p>Preliminari es</p>
  </div>
  <div class="page">
    <p>Probabilistic Generator</p>
    <p>Each transition is assigned a probability</p>
    <p>We assume independent choices, (a Markovian process) thus the document probability is the product.</p>
    <p>In this case, Pr(d)=pa p a p b p $  The schema and generator ignore leaf values (for now!)</p>
    <p>- 8</p>
    <p>Without Constraints</p>
    <p>b a c</p>
    <p>$ pa pc</p>
    <p>pb p$ q 0</p>
    <p>q 1</p>
    <p>q 2</p>
    <p>$</p>
    <p>r</p>
    <p>a a b</p>
  </div>
  <div class="page">
    <p>Formal Problem Definition</p>
    <p>Given a corpus D of documents ,  and a deterministic schema S that accepts every</p>
    <p>document in D  We want to find an optimal generator based on S:</p>
    <p>Find probabilities for the transitions of S that maximize the probability of generating D,</p>
    <p>i.e., the maximum likelihood estimator (MLE).</p>
    <p>- 9</p>
    <p>Without Constraints</p>
  </div>
  <div class="page">
    <p>A Learning Algorithm</p>
    <p>- 10</p>
    <p>Without Constraints</p>
    <p>b</p>
    <p>a c</p>
    <p>$</p>
    <p>$</p>
    <p>The frequency of using each transition during the corpus verification process is recorded.</p>
    <p>(q0, a)</p>
    <p>(q0, b)</p>
    <p>(q1, c)</p>
    <p>(q1, $)</p>
    <p>q 0</p>
    <p>q 1</p>
    <p>q 2</p>
    <p>r</p>
    <p>a b c</p>
  </div>
  <div class="page">
    <p>An Algorithm for Probabilities Learning (Cont.)</p>
    <p>This is repeated for every node in every corpus document. We set the probability of each transition to be its relative frequency.</p>
    <p>- 11</p>
    <p>Without Constraints</p>
    <p>(q0, a) 1 (q0, b) 1 (q1, c) 1 (q1, $) 1</p>
    <p>/2 /2</p>
    <p>/2 /2</p>
    <p>Theorem: This efficient algorithm learns the MLE probabilities  finds an optimal probabilistic generator</p>
  </div>
  <div class="page">
    <p>An Additional Result</p>
    <p>Theorem: generation terminates with probability 1.</p>
    <p>Guaranteed only because of the choice of probabilities according to the corpus.</p>
    <p>- 12</p>
    <p>Without Constraints</p>
  </div>
  <div class="page">
    <p>Integrity Constraints</p>
    <p>We want to support integrity constraints, which are used in XML schema languages.</p>
    <p>Key Constraint: the leaves of a-labeled leaves have unique values (unary key)</p>
    <p>Inclusion Constraint: the values of a-labeled leaves are contained in those of b-labeled leaves</p>
    <p>Domain Constraint: the values of a-labeled leaves belong to some (finite or infinite) domain</p>
    <p>Different types are considered in the literature [Fan &amp; Libkin 2001; David Libkin &amp; Tan 2011]</p>
    <p>- 13</p>
    <p>Adding Constraints</p>
  </div>
  <div class="page">
    <p>New Problem</p>
    <p>We want to find optimal generators for XML schemas with constraints.</p>
    <p>Valid generator output: an XML document, which 1. is a accepted by the schema, and</p>
    <p>Example: each of a, b, c is unique, and contained the others</p>
    <p>- 14</p>
    <p>Adding Constraints</p>
    <p>$</p>
    <p>r</p>
    <p>a a bc</p>
    <p>r</p>
    <p>a b</p>
    <p>b</p>
    <p>c</p>
    <p>b</p>
  </div>
  <div class="page">
    <p>Restart Generators  A simple idea:</p>
    <p>Use a probabilistic generator to generate a document</p>
    <p>Check if it has a value assignment valid w.r.t. the constraints</p>
    <p>If not, 'restart' and try again until a valid document is generated</p>
    <p>Problem definition -- same as in the case without constraints (but now the schema includes constraints)</p>
    <p>Proposition: Given a document with no values, checking for the existence of a valid value assignment is in PTIME  Proof: By translating the constraints to bounds on the number of unique</p>
    <p>values for each leaf label</p>
    <p>Bad news: number of restarts can be unboundedly large in an optimal generator</p>
    <p>- 15</p>
    <p>Adding Constraints</p>
  </div>
  <div class="page">
    <p>Continuation-test Generators</p>
    <p>Never make choices that lead to a 'dead end', thus always generate a valid document.</p>
    <p>We use a binary test to check if a choice has a continuation.  Example: add to the schema of d0 the constraints:</p>
    <p>c is included in a  c is unique</p>
    <p>The generation process:</p>
    <p>- 16</p>
    <p>Adding Constraints</p>
    <p>b a c</p>
    <p>$ $</p>
    <p>pa pc</p>
    <p>pb p$ q 0</p>
    <p>q 1</p>
    <p>q 2</p>
    <p>r</p>
    <p>a b c</p>
    <p>Pr(d) = pa p b p c1</p>
    <p>Perform a continuation-test before taking the</p>
    <p>transition</p>
    <p>Implies | c||a|</p>
  </div>
  <div class="page">
    <p>Learning Algorithm for Continuation-test Generators</p>
    <p>The probabilities are again relative frequencies, but  only in cases where there was an alternative choice.</p>
    <p>The learned generator will generate as many c-s as a-s</p>
    <p>Adding Constraints</p>
    <p>(q0, a) 1 (q0, b) 1 (q1, c) 1 (q1, $) 0</p>
    <p>/2 /2 /1 /1</p>
    <p>(q1, $) was chosen only when (q1, c) was not available.</p>
    <p>- 17</p>
  </div>
  <div class="page">
    <p>Results for Continuation-test Generators</p>
    <p>Theorem: The algorithm learns an optimal continuation-test generator, for automata with binary choices.  Extensions to non-binary are discussed in the paper</p>
    <p>Theorem: Continuation-test is NP-Complete  But only in the size of the schema; it is polynomial in the document size</p>
    <p>Both generation and finding the optimal generator are exponential in the schema size unless P=NP.</p>
    <p>Based on schema satisfiability test [David et al. 2011]</p>
    <p>Theorem: probability of termination for a continuation-test generator may be arbitrarily small!  Proof  by construction of a simple, non-recursive schema</p>
    <p>Can be handled by adding a constraint on the document size.</p>
    <p>Sub-classes of schemas that guarantee termination?</p>
    <p>- 18</p>
    <p>Adding Constraints</p>
  </div>
  <div class="page">
    <p>Adding Values to the Structure</p>
    <p>So far our generators were used only for the document structure</p>
    <p>Leaf values may also have a distribution according to which they can be generated  The distribution may be learned from the same</p>
    <p>document collection  We will focus on the interesting case</p>
    <p>generating leaf values for a schema with constraints</p>
    <p>- 19</p>
    <p>Leaf Values</p>
  </div>
  <div class="page">
    <p>Suggested Algorithm  We start with a valid document skeleton</p>
    <p>Order labels by inclusion constraints (e.g., c, b, a)  Choose a leaf from the 'smallest' (most included) label, and including leaves  Draw a value (from the domain) according to a given distribution.  Use PTIME test to verify validity, if not revert the step  Improvements presented in the paper</p>
    <p>- 20</p>
    <p>Leaf Values</p>
    <p>$</p>
    <p>r</p>
    <p>a b c</p>
    <p>abcdabcd efg</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>Schema Satisfiability tests [Fan &amp; Libkin 2001; David, Libkin &amp; Tan 2011]</p>
    <p>Probabilistic XML and Probabilistic Schemas [e.g., Benedikt, Kharlamov, Olteanu &amp; Senellart 2010]</p>
    <p>Probabilistic XML generation [e.g., Antonopoulos, Geerts, Martens &amp; Neven 2011]</p>
    <p>Schema Inference [e.g., Bex, Gelade, Neven &amp; Vansummeren 2008]</p>
    <p>AXML [Abiteboul, Benjelloun &amp; Milo 2008]</p>
    <p>PCFGs [e.g., Chi &amp; Geman 1998]</p>
    <p>- 22</p>
    <p>Summary</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>A model for a probabilistic XML generators  Unconstrained case</p>
    <p>Generation and learning optimal generators can be done efficiently  Termination is guaranteed</p>
    <p>Constrained case  Restart generator</p>
    <p># of restarts is unbounded</p>
    <p>Continuation-test generators  Generation and learning optimal generators are expensive  Termination is not guaranteed</p>
    <p>Leaf Value generation</p>
    <p>In the talk labels and states are coupled (as in a DTD), but all the results hold when they are uncoupled.</p>
    <p>Future work  Efficient combinations of restart and continuation-test generators  Experimental study</p>
    <p>- 23</p>
    <p>Summary</p>
  </div>
  <div class="page">
    <p>Thank You!Thank You!</p>
    <p>Q&amp;A</p>
  </div>
</Presentation>
