<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Eiffel: Efficient and Flexible Software Packet Scheduling</p>
    <p>Ahmed Saeed, Yimeng Zhao, Nandita Dukkipati, Mostafa Ammar, Ellen Zegura, Khaled Harras, and Amin Vahdat</p>
    <p>!1</p>
  </div>
  <div class="page">
    <p>!2</p>
  </div>
  <div class="page">
    <p>!4</p>
  </div>
  <div class="page">
    <p>!6</p>
    <p>WAN/Internet</p>
    <p>WAN Link</p>
    <p>Datacenter Network</p>
  </div>
  <div class="page">
    <p>!7</p>
    <p>WAN/Internet</p>
    <p>Competition for Bandwidth at premium links between WAN traffic</p>
    <p>Competition for Bandwidth</p>
    <p>at the source between all traffic</p>
    <p>Competition in the datacenter LAN</p>
    <p>between all traffic</p>
  </div>
  <div class="page">
    <p>!7</p>
    <p>WAN/Internet</p>
    <p>Large number of flows (&gt; 10k flows per machine)</p>
    <p>High speed links (10-100 Gbps)</p>
    <p>Diversity in traffic (WAN vs LAN and</p>
    <p>High vs Low priority)</p>
  </div>
  <div class="page">
    <p>Packet Scheduling  Scheduling determines the relative ordering as well</p>
    <p>as transmission time of packets in a queuing data structure with respect to some ranking function</p>
    <p>Packet scheduling implements policies to solve such problems  Traffic Isolation  Flow Completion Time Optimization  Congestion Control</p>
    <p>!8</p>
  </div>
  <div class="page">
    <p>Scheduler Implementation  Hardware schedulers in ASICs, FPGAs, or NPUs  Preprogrammed policies in switches or NICs  Programmable schedulers</p>
    <p>Software schedulers at end hosts or middleboxes  Kernel Queuing Disciplines (Qdiscs)  Userspace networking stacks</p>
    <p>!9</p>
  </div>
  <div class="page">
    <p>Software vs Hardware</p>
    <p>Hardware lags behind network needs</p>
    <p>Software serves as a good experimental environment before hardware deployment</p>
    <p>Software provides a build once, deploy many</p>
    <p>!10 End host</p>
    <p>Middlebox</p>
  </div>
  <div class="page">
    <p>Challenges of Network Scheduling</p>
    <p>Accurate scheduling</p>
    <p>Efficient CPU and memory implementation</p>
    <p>Diversity of requirements</p>
    <p>!11</p>
    <p>Time</p>
    <p>Rate Bursty</p>
    <p>Time</p>
    <p>Rate Paced</p>
    <p>O(log(n)) O(1)</p>
    <p>Strict Priority</p>
    <p>Hierarchical Weighted Fair Queuing</p>
    <p>Rate Limiting</p>
    <p>Shortest Remaining Time First</p>
  </div>
  <div class="page">
    <p>Objective: Design an accurate, efficient, and programmable</p>
    <p>software scheduler</p>
    <p>!12</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Eiffel Overview  Characteristics of Packet Ranks  Efficient Packet Ordering: Integer Priority Queues  Scheduler Programmability  Evaluation</p>
    <p>!13</p>
  </div>
  <div class="page">
    <p>Eiffel Overview</p>
    <p>!14</p>
    <p>To NIC</p>
    <p>Queuing Data Structure</p>
    <p>A nn</p>
    <p>ot at</p>
    <p>or</p>
    <p>Enqueue Dequeue</p>
    <p>Scheduler Controller</p>
    <p>Scheduling Policy Desc.</p>
  </div>
  <div class="page">
    <p>Eiffel Overview</p>
    <p>Efficient building block for packet sorting operating at line rate  Expressive abstraction that can capture a wide range of policies</p>
    <p>!15</p>
    <p>To NIC</p>
    <p>Queuing Data Structure</p>
    <p>A nn</p>
    <p>ot at</p>
    <p>or Enqueue Dequeue</p>
    <p>Scheduler Controller</p>
    <p>Scheduling Policy Desc.</p>
  </div>
  <div class="page">
    <p>Characteristics of Packet Ranks</p>
    <p>!16</p>
  </div>
  <div class="page">
    <p>Ranks are Integers</p>
    <p>Packet carry limited precision integer priorities of width w bits  QoS-based priority  Time-based priority  Flow size-based priority</p>
    <p>!17</p>
  </div>
  <div class="page">
    <p>Ranks have Known Ranges  Semantics of priority values typical have limited</p>
    <p>ranges within the whole range of integer representation</p>
    <p>Time-based priorities: from now to a few seconds in the future</p>
    <p>Flow size-based priorities: values are known from typical application behavior</p>
    <p>Strict priority ranges: policy/network operator defined !18</p>
    <p>Values of Interest</p>
  </div>
  <div class="page">
    <p>Application Application</p>
    <p>Processing Speed</p>
    <p>Network Processing</p>
    <p>NIC (20Gbps)</p>
    <p>!21</p>
    <p>Packets are Processed in Batches</p>
  </div>
  <div class="page">
    <p>Application Application</p>
    <p>Processing Speed</p>
    <p>Network Processing</p>
    <p>NIC (20Gbps)</p>
    <p>Processing delay is in 100s of ns</p>
    <p>!22</p>
    <p>Packets are Processed in Batches</p>
  </div>
  <div class="page">
    <p>Application Application</p>
    <p>Processing Speed</p>
    <p>Network Processing</p>
    <p>NIC (20Gbps)</p>
    <p>Processing delay is in 100s of ns</p>
    <p>Packets have to be processed in batches, rendering all packets in a batch to have virtually the same rank</p>
    <p>!23</p>
    <p>Packets are Processed in Batches</p>
  </div>
  <div class="page">
    <p>Bucketed Data Structure +</p>
    <p>Limited number of buckets +</p>
    <p>Algorithm to find min/max non-empty bucket</p>
    <p>= Integer Priority Queues</p>
    <p>!27</p>
    <p>Eiffel Building Block</p>
  </div>
  <div class="page">
    <p>Efficient Packet Ordering: Integer Priority Queues</p>
    <p>!28</p>
  </div>
  <div class="page">
    <p>Priority Queues 101</p>
    <p>Binary trees, Binomial Heap, Fibonacci Heap  Support ExtractMin/ExtractMax  Overhead of O(log n) on insertion or</p>
    <p>extraction</p>
    <p>Requires definition of a comparison operator: Comparison-based Priority Queues</p>
    <p>!29</p>
  </div>
  <div class="page">
    <p>Integer Priority Queue</p>
    <p>Bucketed queues of N buckets  Bucket index is the priority of</p>
    <p>elements in the bucket</p>
    <p>O(1) insertion and change priority</p>
    <p>O(Logw N) ExtractMin/ExtractMax</p>
    <p>P0 P1   PN</p>
    <p>!30</p>
  </div>
  <div class="page">
    <p>Integer Priority Queue</p>
    <p>Bucketed queues of N buckets  Bucket index is the priority of</p>
    <p>elements in the bucket</p>
    <p>O(1) insertion and change priority</p>
    <p>O(Logw N) ExtractMin/ExtractMax</p>
    <p>P0 P1   PN</p>
    <p>Packets have known priority range and can be grouped into coarse granularity buckets</p>
    <p>Packets have integer priority are captured in limited precision integers</p>
    <p>!31</p>
  </div>
  <div class="page">
    <p>FFS-based Integer Priority Queue</p>
    <p>!32</p>
  </div>
  <div class="page">
    <p>FFS-based Integer Priority Queue</p>
    <p>FindFirstSet (FFS) in a 64-bit word in 3 CPU cycles  Every bucket is represented by a bit  Bit is set iff bucket is not empty</p>
    <p>O(1) Integer Priority Queue in for N=64  Linux Real Time Process Scheduler  Quick Fair Queuing (QFQ)</p>
    <p>[F. Checconi et al. INFOCOM 13]</p>
    <p>!33</p>
  </div>
  <div class="page">
    <p>Hierarchical FFS-based Queue</p>
    <p>Queue</p>
    <p>Bitmap Meta Data1 0 1 0</p>
    <p>Packets</p>
    <p>Root</p>
    <p>Leaf</p>
    <p>!34</p>
  </div>
  <div class="page">
    <p>Circular Hierarchical FFS-based Queue</p>
    <p>Queue</p>
    <p>Bitmap Meta Data0 1 1 0</p>
    <p>Primary Secondary Packets</p>
    <p>!35</p>
  </div>
  <div class="page">
    <p>Circular Hierarchical FFS-based Queue</p>
    <p>Queue</p>
    <p>Bitmap Meta Data0 1 1 0</p>
    <p>Primary Secondary Packets</p>
    <p>!36</p>
    <p>cFFS-based queues has a small memory footprint and requires O(logw N) steps for ExtractMin operating over a small N</p>
  </div>
  <div class="page">
    <p>Scheduler Programmability</p>
    <p>!37</p>
  </div>
  <div class="page">
    <p>PIFO Programming Model</p>
    <p>Eiffel extends Push In First Out (PIFO) model  PIFO model capture hierarchical policies using tress of</p>
    <p>priority queues [Sivaraman et. al SIGCOMM 16]  Packet ranking is performed on enqueue  Scheduling and shaping are tightly coupled in a single transaction  Implemented in hardware through parallel comparisons</p>
    <p>!38</p>
  </div>
  <div class="page">
    <p>Eiffel Programming Model</p>
    <p>Eiffel model extends the PIFO model  Packets can be ordered based on flow ranking  Flows and packets can be ranked on enqueue and dequeue  Shaping and scheduling are decoupled for efficiency</p>
    <p>!39</p>
  </div>
  <div class="page">
    <p>Eiffel Example: pFabric</p>
    <p>!40</p>
    <p>Each packet is tagged with Remaining Processing Time</p>
    <p>Packets are transmitted with Shortest Remaining Processing Time First (SRPTF)</p>
    <p>To avoid starvation, earliest packet from the highest priority flow is transmitted</p>
    <p>pFabric requires prioritizing flows based on ranks of packets</p>
  </div>
  <div class="page">
    <p>Eiffel Example: pFabric</p>
    <p>!40</p>
    <p>Each packet is tagged with Remaining Processing Time</p>
    <p>Packets are transmitted with Shortest Remaining Processing Time First (SRPTF)</p>
    <p>To avoid starvation, earliest packet from the highest priority flow is transmitted</p>
    <p>pFabric requires prioritizing flows based on ranks of packets</p>
  </div>
  <div class="page">
    <p>Eiffel Example: pFabric</p>
    <p>!40</p>
    <p>Each packet is tagged with Remaining Processing Time</p>
    <p>Packets are transmitted with Shortest Remaining Processing Time First (SRPTF)</p>
    <p>To avoid starvation, earliest packet from the highest priority flow is transmitted</p>
    <p>pFabric requires prioritizing flows based on ranks of packets</p>
  </div>
  <div class="page">
    <p>Eiffel Example: Implementation</p>
    <p>Data structures  Priority Queue per policy that ranks flows  FIFO queue per-flow</p>
    <p>On packet enqueue  Check packet tag and update flow rank  Update flow position in priority queue</p>
    <p>!41</p>
    <p>Rank 80 Rank 60</p>
  </div>
  <div class="page">
    <p>Eiffel Example: Implementation</p>
    <p>Data structures  Priority Queue per policy that ranks flows  FIFO queue per-flow</p>
    <p>On packet enqueue  Check packet tag and update flow rank  Update flow position in priority queue</p>
    <p>!41</p>
    <p>Rank 60</p>
    <p>Rank 40</p>
  </div>
  <div class="page">
    <p>Eiffel Example: Implementation</p>
    <p>Data structures  Priority Queue per policy that ranks flows  FIFO queue per-flow</p>
    <p>On packet enqueue  Check packet tag and update flow rank  Update flow position in priority queue</p>
    <p>!41</p>
    <p>Rank 60</p>
    <p>Rank 40</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>!42</p>
  </div>
  <div class="page">
    <p>Evaluation Setup</p>
    <p>Two servers with Intel X520-SR2 dual port NICs</p>
    <p>Eiffel implemented in Berkeley Extensible Software Switch (BESS)</p>
    <p>BESS runs on a single dedicated core  Traffic generated using BESS</p>
    <p>FlowGen with varying number of flows and fixed 1500B packets</p>
    <p>!43</p>
    <p>Measurements</p>
    <p>NIC</p>
    <p>BESS</p>
    <p>FlowGen</p>
    <p>NIC</p>
    <p>BESS</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>!44</p>
    <p>a te</p>
    <p>( M</p>
    <p>b p s )</p>
    <p>Number of flows</p>
    <p>pFabric - Eiffel pFabric - Binary Heap</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>!45</p>
    <p>a te</p>
    <p>( M</p>
    <p>b p s )</p>
    <p>Number of flows</p>
    <p>pFabric - Eiffel pFabric - Binary Heap</p>
    <p>Eiffel improves capacity by 5x in terms of number of flows that can be handled at line rate</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Eiffel network operators to deploy complex scheduling policies at end hosts and middle boxes</p>
    <p>Eiffel advantages make a strong case for rethinking the building blocks of packet in scheduling in hardware</p>
    <p>!46</p>
  </div>
  <div class="page">
    <p>Questions?</p>
    <p>!47</p>
  </div>
</Presentation>
