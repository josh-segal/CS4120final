<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Strato: A Retargetable Framework for Low-Level Inlined Reference Monitors</p>
    <p>Bin Zeng, Gang Tan, lfar Erlingsson Lehigh University Google Inc.</p>
    <p>USENIX Security 2013 @Washington DC, USA</p>
  </div>
  <div class="page">
    <p>ASacks</p>
    <p>How aSacks happen  Arrive as user input through a communicaVon channel</p>
    <p>Trigger pre-exisVng bugs  Take over program execuVons</p>
    <p>ASack vector  Mobile code, untrusted extensions  Memory corrupVon aSacks [StackSmash]  Return Oriented Programming [ROP]</p>
  </div>
  <div class="page">
    <p>ExisVng Countermeasures</p>
    <p>Data ExecuVon ProtecVon [DEP]  Address Space Layout RandomizaVon [PaX]  Program Shepherding [Shepherding]  Inlined Reference Monitors [IRM]  Control Flow Integrity [CFI, XFI, HyperSafe]  So]ware-based Fault IsolaVon [PiSsfield, NaVve Client]</p>
  </div>
  <div class="page">
    <p>Inlined Reference Monitors (IRMs)</p>
    <p>IRM: embed security checks in programs</p>
    <p>Well-established against various aSacks  E.g., buffer overflows, Return-Oriented Programming aSacks</p>
  </div>
  <div class="page">
    <p>Inlined Reference Monitors (IRMs)</p>
    <p>CFI (Control-Flow Integrity): checks control flow</p>
    <p>SFI (So]ware-based Fault IsolaVon) also checks memory reads and writes</p>
    <p>Example: Googles NaVve Client  Verifiable machine code plugins for browsers</p>
  </div>
  <div class="page">
    <p>However, Most IRM ImplementaVons are Low-Level</p>
    <p>Binary rewriVng, assembly instrumentaVon,  ImplementaVons  Tightly coupled with architectures  Hard to reuse</p>
    <p>For example, NaVve Client (NaCl) has mulVple implementaVons  x86-32; x86-64</p>
  </div>
  <div class="page">
    <p>Our General Idea</p>
    <p>Perform IRM rewriVng at an Intermediate- RepresentaVon (IR) level  Use an IR that is largely architecture-independent (in parVcular, LLVM IR)</p>
    <p>Benefits  Reuse transformaVons among architectures  IR is amenable to opVmizaVons</p>
    <p>Retain verifiability of low-level code</p>
  </div>
  <div class="page">
    <p>Challenges of IR-level RewriVng</p>
    <p>Compiler transformaVons a]er the IR can invalidate security assumpVons</p>
    <p>Have to trust the compiler back-end from IR to low-level code  TCB Bloat</p>
  </div>
  <div class="page">
    <p>Are Compilers Trustworthy?</p>
    <p>Compiler</p>
    <p>Source Code</p>
    <p>Binary Code</p>
  </div>
  <div class="page">
    <p>Compilers are Buggy</p>
    <p>Compiler</p>
    <p>Source Code</p>
    <p>Binary Code</p>
  </div>
  <div class="page">
    <p>Compilers are Buggy</p>
    <p>Compilers have a huge code base  GCC 4.8 has more than 7.3 million lines of code</p>
    <p>Csmith found 300+ unknown bugs [PLDI 11]  LLVM has a steady bug rate</p>
  </div>
  <div class="page">
    <p>Buggy Compiler OpVmizaVons</p>
    <p>Any sufficiently opVmizing compiler is indisVnguishable from magic.</p>
    <p>-- Paraphrasing Arthur C. Clarke</p>
  </div>
  <div class="page">
    <p>Compiler OpVmizaVons</p>
    <p>Compiler opVmizaVons invalidate security assumpVons</p>
    <p>They only care about funcVonal semanVcs  Security properVes are o]en non-funcVonal</p>
  </div>
  <div class="page">
    <p>Research QuesVon</p>
    <p>How to do IRM rewriVng at the IR level, and preserve low-level security?</p>
    <p>Our papers contribuVon:  Strato: a IRM-implementaVon framework that performs IR-level rewriVng and preserves low- level security</p>
  </div>
  <div class="page">
    <p>Key Challenge</p>
    <p>Challenge: a]er checks are inserted at the IR level, backend transformaVons may invalidate security  if all data memory is untrusted</p>
    <p>ptr.safe = check(ptr) tmp = load *ptr.safe store ptr.safe, *stack_loc ptr.safe2 = load *stack_loc store v, *ptr.safe2</p>
    <p>ptr.safe = check(ptr) tmp = load *ptr.safe store v, *ptr.safe</p>
    <p>Before register allocaVon A]er register allocaVon</p>
    <p>Register spilling</p>
  </div>
  <div class="page">
    <p>ASack Model</p>
    <p>Anything from memory is untrusted</p>
    <p>Guard region is mprotected</p>
  </div>
  <div class="page">
    <p>Our Idea for Addressing the Problem</p>
    <p>Insert more-than-enough checks at the IR level  ASach constraints to checks to encode condiVons that might be invalidated by the compiler</p>
    <p>A]er compiler transformaVons, perform constraint checking at the low level  Remove checks iff constraints are sVll valid  If a compiler transformaVon invalidates a constraint, then the check is le] intact for security</p>
    <p>Lets go through an example next</p>
  </div>
  <div class="page">
    <p>Uninstrumented IR Code</p>
    <p>entry: tmp = 0 if(v &gt; 47) goto then else: tmp = load *ptr goto end then: store v, *ptr end: ret tmp</p>
  </div>
  <div class="page">
    <p>Instrumented and OpVmized IR entry: ptr.safe = check(ptr) // check1 tmp = 0 if(v &gt; 47) goto then else: ptr.safe1 = check(ptr.safe) // check2 # noSpill(ptr.safe, check1, check2) tmp = load *ptr.safe1 goto end then: ptr.safe2 = call check(ptr.safe) // check3 # noSpill(ptr.safe, check1, check3) store v, *ptr.safe2 end: ret tmp</p>
    <p>Redundant Check EliminaVon 19</p>
    <p>Security checks</p>
    <p>Constraints</p>
    <p>Original code</p>
  </div>
  <div class="page">
    <p>A]er Constraint Checking</p>
    <p>Assume ptr.safe not spilled between check1 and check2, but spilled between check2 and check3</p>
    <p>entry: ptr.safe = check(ptr) // check1 tmp = 0 if(v &gt; 47) goto then else: ptr.safe1 = check(ptr.safe) // check2 # noSpill(ptr.safe, check1, check2) tmp = load *ptr.safe goto end then: ptr.safe2 = call check(ptr.safe) // check3 # noSpill(ptr.safe, check1, check3) store v, *ptr.safe2 end: ret tmp</p>
  </div>
  <div class="page">
    <p>Another Example: Uninstrumented IR Code</p>
    <p>x = gep p, 0, 0 tmp1 = load *x y = gep p, 0, 1 tmp2 = load *y sum = add tmp1, tmp2 ret sum</p>
  </div>
  <div class="page">
    <p>Instrumented and OpVmized IR p.safe = check(p) // check1 x = gep p.safe, 0, 0 x.safe = check(x) // check2 # noSpill(p.safe, check1, check2) # sizeof(struct s)*0 + sizeof(long)*0 &lt; GZSize tmp1 = load *x.safe y = gep p.safe, 0, 1 y.safe = check(y) // check3 # noSpill(p.safe, check1, check3) # sizeof(struct s)*0 + sizeof(long)*1 &lt; GZSize tmp2 = load *y.safe sum = add tmp1, tmp2 ret sum SequenVal Memory Access OpVmizaVon 22</p>
  </div>
  <div class="page">
    <p>A]er Constraint Checking</p>
    <p>Assume (1) ptr.safe not spilled between check1 and check2, or check1 and check3 (2) offsets less than guard-zone size</p>
    <p>p.safe = check(p) // check1 x = gep p.safe, 0, 0 x.safe = check(x) // check2 # noSpill(p.safe, check1, check2) # sizeof(struct s)*0 + sizeof(long)*0 &lt; GSize tmp1 = load *x.safe y = gep p.safe, 0, 1 y.safe = check(y) // check3 # noSpill(p.safe, check1, check3) # sizeof(struct s)*0 + sizeof(long)*1 &lt; GSize tmp2 = load *y.safe sum = add tmp1, tmp2 ret sum</p>
  </div>
  <div class="page">
    <p>Strato: Retargetable IRMs  InstrumentaVon at intermediate representaVon level, i.e. LLVM IR  IR-level checks</p>
    <p>OpVmizaVons of security checks and aSach constraints</p>
    <p>Constraint-checking before lowering  If a constraint holds, remove the check  Otherwise, lower the IR-level check to machine code</p>
    <p>VerificaVon at the low level  Remove everything else outside the TCB (including constraint checking)</p>
  </div>
  <div class="page">
    <p>The Architecture of Strato</p>
    <p>IR</p>
    <p>Secured IR</p>
    <p>x64 ASM</p>
    <p>Compiler Optimizations</p>
    <p>Check Instrumentation</p>
    <p>Secured IR</p>
    <p>Check Optimizations</p>
    <p>Code Gen</p>
    <p>x32 ASM  ASM</p>
    <p>Constraint Checking</p>
    <p>x64 ASM x32 ASM  ASM</p>
    <p>x64 ASM x32 ASM  ASM</p>
    <p>Check Lowering</p>
    <p>Verification</p>
    <p>IR</p>
    <p>Source Compiler Frontend</p>
  </div>
  <div class="page">
    <p>Benefits</p>
    <p>Retargetable  Easy to port to other architectures</p>
    <p>Enable opVmizaVons  Structured informaVon at the IR level  StaVc Single Assignment form</p>
    <p>Code reuse  InstrumentaVon and opVmizaVons can be shared among various architectures</p>
  </div>
  <div class="page">
    <p>The ImplementaVon of Strato  Two policies: CFI &amp; SFI  InstrumentaVon  FuncVon passes into the end LLVM pipeline</p>
    <p>OpVmizaVons  Redundant Check EliminaVon  SequenVal Memory Access OpVmizaVon  Loop-based Check OpVmizaVon  OpVmizaVons aSach constraints</p>
    <p>Constraint checking  Range analysis (interval analysis) based verifier</p>
  </div>
  <div class="page">
    <p>VerificaVon</p>
    <p>Based on CCS paper [CCS 11]  A]er all the opVmizaVons, constraint checking, a verifier verifies the final result in assembly code</p>
    <p>Removes everything before out of TCB  Based on range analysis  Found a few bugs in our implementaVon</p>
  </div>
  <div class="page">
    <p>Performance EvaluaVon</p>
    <p>LLVM 2.9  To demonstrate retargetability:  x86-32  x86-64 (small changes on x86-32)</p>
  </div>
  <div class="page">
    <p>CFI Overhead on SPEC2k</p>
    <p>x86-32 x86-64</p>
    <p>gzip vpr gcc mcf</p>
    <p>crafty parser</p>
    <p>eon perlbmk</p>
    <p>gap vortex bzip2 twolf avg</p>
    <p>x86-32: ~6% x86-64: ~8%</p>
  </div>
  <div class="page">
    <p>Overhead of CFI with Data Sandboxing for Both Reads and Writes on SPEC2K</p>
    <p>x86-32 x86-64</p>
    <p>gzip vpr gcc mcf</p>
    <p>crafty parser</p>
    <p>eon perlbmk</p>
    <p>gap vortex bzip2 twolf avg</p>
    <p>x86-32: ~20% x86-64: ~25%</p>
  </div>
  <div class="page">
    <p>Compare with Previous works performance</p>
    <p>Even though our framework is retargetable and trustworthy, the performance is compeVVve</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>A retargetable framework for IRMs  OpVmizaVons on checks  CompeVVve performance</p>
    <p>Constraint language  Range analysis based verifier</p>
  </div>
  <div class="page">
    <p>References</p>
    <p>[CFI] Abadi et al. Control-Flow Integrity  Principles, ImplementaVons, and ApplicaVons, ACM CCS 2005 [csmith] Yang et al. Finding and Understanding Bugs in C Compilers, PLDI 2011 [HyperSafe] Wang et al. HyperSafe: A Lightweight Approach to Provide LifeVme Hypervisor Control-Flow Integrity, IEEE S&amp;P 2010 [IRM] Erlingsson et al. The Inlined Reference Monitor Approach to Security Policy Enforcement, doctoral dissertaVon, 2004 [NaVve Client] Yee et al. NaVve Client: A Sandbox for Portable, Untrusted x86 NaVve Code, IEEE S&amp;P 2009 [PiSsfield] McCamant et al. EvaluaVng SFI for a CISCI Architecture, USENIX Security 2006 [ROP] Roemer et al. Return-oriented Programming: Systems, Languages, and ApplicaVons, ACM TISSEC 2012 [Shepherding] Kiriansky et al. Secure ExecuVon Via Program Shepherding, USENIX Security 2002 [SmashStack] Aleph One. Smashing the stack for fun and profit, Phrack Magazine, 1996 [XFI] Erlingsson et al. XFI: So]ware Guards for System Address Spaces, OSDI 2006</p>
  </div>
  <div class="page">
    <p>Strato: A Retargetable Framework for Low-Level Inlined-Reference Monitors</p>
    <p>Thank you! QuesVons?</p>
    <p>Bin Zeng zeb209@lehigh.edu</p>
    <p>Gang Tan gtan@cse.lehigh.edu</p>
    <p>lfar Erlingsson ulfar@google.com</p>
  </div>
</Presentation>
