<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>On the use of guards for logics with data</p>
    <p>Thomas Colcombet, Clemens Ley and Gabriele Puppis</p>
    <p>MFCS 2011</p>
  </div>
  <div class="page">
    <p>What is this talk about?</p>
    <p>Generalizations of classical results about regular languages from finite-alphabet case to infinite-alphabet case:</p>
    <p>correspondence between logics, automata, and monoids</p>
    <p>characterizations of first-order definability</p>
    <p>decidability of logics</p>
    <p>Applications of languages over infinite alphabets (data languages):</p>
    <p>Databases: XML documents with text/attributes</p>
    <p>Verification: programs with variables over an infinite domain</p>
  </div>
  <div class="page">
    <p>A data language is a set of words/trees over a fixed infinite alphabet D (e.g. D = {0, 1, 2, . . .}).</p>
    <p>To make life easier, we enforce some restrictions:</p>
    <p>(e.g. 1|D| 2|D| 1|D| 1|D| 3|D|  L iff 5|D| 3|D| 5|D| 5|D| 7|D|  L )</p>
    <p>we focus on properties concerning equalities of data values</p>
    <p>An example of data language</p>
    <p>L = {w  D  at most 2 distinct values in w}</p>
    <p>= {, #|D|, #|D|, #|D| #|D|, #|D| #|D|, #|D| #|D| #|D|, #|D| #|D| #|D| #|D|, . . .}</p>
  </div>
  <div class="page">
    <p>Languages over finite alphabets:</p>
    <p>MSO logic</p>
    <p>X. first  X  last  X   y. (y  X  y+ 1  X)</p>
    <p>automata</p>
    <p>q</p>
    <p>finite monoids</p>
    <p>s t= s t s= t</p>
    <p>Languages over infinite alphabets:</p>
    <p>MSO logic with data tests</p>
    <p>X. first  X  last  X   y. (y  X  y+ 1  X)   y,z. (y,z  X  y  z)</p>
    <p>register automata</p>
    <p>#|D| #|D| #|D| #|D| |DD| #|D| #|D|</p>
    <p>q+ #|D| #|D|</p>
    <p>orbit finite data monoids</p>
    <p>s( #, #) t( #)= s( #, #) t( #) s( #, #)= t( #)</p>
  </div>
  <div class="page">
    <p>Languages over finite alphabets:</p>
    <p>MSO logic</p>
    <p>X. first  X  last  X   y. (y  X  y+ 1  X)</p>
    <p>automata</p>
    <p>q</p>
    <p>finite monoids</p>
    <p>s t= s t s= t</p>
    <p>Languages over infinite alphabets:</p>
    <p>MSO logic with data tests</p>
    <p>X. first  X  last  X   y. (y  X  y+ 1  X)   y,z. (y,z  X  y  z)</p>
    <p>register automata</p>
    <p>#|D| #|D| #|D| #|D| |DD| #|D| #|D|</p>
    <p>q+ #|D| #|D|</p>
    <p>orbit finite data monoids</p>
    <p>s( #, #) t( #)= s( #, #) t( #) s( #, #)= t( #)</p>
  </div>
  <div class="page">
    <p>Expressiveness of logics, automata, monoids over</p>
    <p>in</p>
    <p>finite alphabets:</p>
    <p>all languagesclassical</p>
    <p>MSO logic</p>
    <p>non-d eterministic automata</p>
    <p>determ inistic automata</p>
    <p>finite m onoids</p>
  </div>
  <div class="page">
    <p>Expressiveness of logics, automata, monoids over</p>
    <p>in</p>
    <p>finite alphabets:</p>
    <p>all languagesclassical</p>
    <p>MSO logic</p>
    <p>non-d eterministic automata</p>
    <p>determ inistic automata</p>
    <p>finite m onoids</p>
    <p>FO logic counter-free de</p>
    <p>term inis</p>
    <p>tic au</p>
    <p>to m</p>
    <p>at a</p>
    <p>aperiodic finite m ono</p>
    <p>ids</p>
  </div>
  <div class="page">
    <p>Expressiveness of logics, automata, monoids over infinite alphabets:</p>
    <p>all languagesdataclassical</p>
    <p>MSO logic with</p>
    <p>non-d eterministic re automatadeter</p>
    <p>ministic re automata</p>
    <p>o fin ite d monoids</p>
    <p>FO logic with</p>
    <p>counter-free deter min</p>
    <p>isti c a</p>
    <p>ut om</p>
    <p>at a</p>
    <p>aperiodic fin da mon oids</p>
  </div>
  <div class="page">
    <p>Expressiveness of logics, automata, monoids over infinite alphabets:</p>
    <p>all languagesclassicaldata</p>
    <p>MSO logic with data</p>
    <p>non-d eterministic regis autom</p>
    <p>ata</p>
    <p>dete rministic regis automata</p>
    <p>orb finite</p>
    <p>da monoids</p>
    <p>FO logic with d ata</p>
    <p>counter-free determ inis</p>
    <p>tic au</p>
    <p>to m</p>
    <p>at a</p>
    <p>aperiodic f. data mon oid</p>
    <p>s</p>
  </div>
  <div class="page">
    <p>Expressiveness of logics, automata, monoids over infinite alphabets:</p>
    <p>all languagesdata</p>
    <p>MSO logic with data tests</p>
    <p>non-d eterministic register autom</p>
    <p>ata</p>
    <p>det ermin</p>
    <p>istic register autom ataor</p>
    <p>bit finite</p>
    <p>data monoids</p>
    <p>FO logic with d ata</p>
    <p>tes ts</p>
    <p>aperiodic o.f. data m on</p>
    <p>oid s</p>
  </div>
  <div class="page">
    <p>Expressiveness of logics, automata, monoids over infinite alphabets:</p>
    <p>all languagesdata</p>
    <p>MSO logic with data tests</p>
    <p>non-d eterministic register autom</p>
    <p>ata</p>
    <p>det ermin</p>
    <p>istic register autom ataor</p>
    <p>bit finite</p>
    <p>data monoids</p>
    <p>FO logic with d ata</p>
    <p>tes ts</p>
    <p>aperiodic o.f. data m on</p>
    <p>oid s</p>
    <p>Logical characterizations of:</p>
    <p>non-deterministic register automata</p>
    <p>orbit finite data monoids</p>
    <p>aperiodic o.f. data monoids</p>
  </div>
  <div class="page">
    <p>What is an orbit finite data monoid?</p>
    <p>Consider the syntactic monoid of the language L = {w  D  at most 2 distinct values in w}:</p>
    <p>D ML h</p>
    <p>(empty word)</p>
    <p># #... # (words with one data value)</p>
    <p># # #... # (words with two data values)</p>
    <p>(words with more than</p>
    <p>two data values)</p>
    <p>The product of ML is the union of sets, up to cardinality 2.</p>
    <p>Each permutation  on D induces a permutation  on ML e.g., if  = { # #}, then ({ #, #}) = { #, #}.</p>
  </div>
  <div class="page">
    <p>What is an orbit finite data monoid?</p>
    <p>Consider the syntactic monoid of the language L = {w  D  at most 2 distinct values in w}:</p>
    <p>D MLML hh</p>
    <p>(empty word)</p>
    <p># #... # (words with one data value)</p>
    <p># # #... # (words with two data values)</p>
    <p>(words with more than</p>
    <p>two data values)</p>
    <p>{ #}{ #}{ #}</p>
    <p>{ #, #}{ #, #}{ #, #}</p>
    <p>The product of ML is the union of sets, up to cardinality 2.</p>
    <p>Each permutation  on D induces a permutation  on ML e.g., if  = { # #}, then ({ #, #}) = { #, #}.</p>
  </div>
  <div class="page">
    <p>What is an orbit finite data monoid?</p>
    <p>Consider the syntactic monoid of the language L = {w  D  at most 2 distinct values in w}:</p>
    <p>D MLML hh</p>
    <p>(empty word)</p>
    <p># #... # (words with one data value)</p>
    <p># # #... # (words with two data values)</p>
    <p>(words with more than</p>
    <p>two data values)</p>
    <p>{ #}{ #}{ #}</p>
    <p>{ #, #}{ #, #}{ #, #}</p>
    <p>The product of ML is the union of sets, up to cardinality 2.</p>
    <p>Each permutation  on D induces a permutation  on ML e.g., if  = { # #}, then ({ #, #}) = { #, #}.</p>
  </div>
  <div class="page">
    <p>Examples of languages recognized by orbit finite data monoids:</p>
    <p>Exactly two/three/... distinct values</p>
    <p>Any two consecutive values are different</p>
    <p>First value equals last value</p>
    <p>Lifting by permutations of any classical regular language</p>
    <p>First value reappears</p>
    <p>Some value appears twice</p>
    <p>All values appears at most once</p>
    <p>Closure under all boolean operations!</p>
  </div>
  <div class="page">
    <p>Consider some languages recognized by orbit finite data monoids:</p>
    <p>words where first value equals last value:</p>
    <p>x,y.</p>
    <p>(x = first  y = last)(x = first  y = last)(x = first  y = last)</p>
    <p>(x = first  y = last)  (x  y)</p>
    <p>words with at least two distinct values (e.g. ... # #...):</p>
    <p>x,y.</p>
    <p>(y = x+ 1)(y = x+ 1)(y = x+ 1)</p>
    <p>(y = x+ 1)  (x  y)</p>
    <p>words with at least three distinct values (e.g. ... # # # # #...):</p>
    <p>x,y.</p>
    <p>((x  x+1)  (y  y+1)   z. (x&lt;z&lt;yz  z+1))((x  x+1)  (y  y+1)   z. (x&lt;z&lt;yz  z+1))((x  x+1)  (y  y+1)   z. (x&lt;z&lt;yz  z+1))</p>
    <p>((x  x+1)  (y  y+1)   z. (x&lt;z&lt;yz  z+1))  (x  y+1)</p>
    <p>...and some languages not recognized by orbit finite data monoids:</p>
    <p>words where first value reappears:</p>
    <p>x,y.</p>
    <p>(x = first  x &lt; y)(x = first  x &lt; y)(x = first  x &lt; y)</p>
    <p>(x = first  x &lt; y)  (x  y)</p>
    <p>words where all values appear at most once:</p>
    <p>x,y.</p>
    <p>(x &lt; y)(x &lt; y)(x &lt; y)</p>
    <p>(x &lt; y)  (x  y)</p>
  </div>
  <div class="page">
    <p>Consider some languages recognized by orbit finite data monoids:</p>
    <p>words where first value equals last value:</p>
    <p>x,y. (x = first  y = last)(x = first  y = last)(x = first  y = last)</p>
    <p>(x = first  y = last)</p>
    <p>(x  y)</p>
    <p>words with at least two distinct values (e.g. ... # #...):</p>
    <p>x,y. (y = x+ 1)(y = x+ 1)(y = x+ 1)</p>
    <p>(y = x+ 1)</p>
    <p>(x  y)</p>
    <p>words with at least three distinct values (e.g. ... # # # # #...):</p>
    <p>x,y. ((x  x+1)  (y  y+1)   z. (x&lt;z&lt;yz  z+1))((x  x+1)  (y  y+1)   z. (x&lt;z&lt;yz  z+1))((x  x+1)  (y  y+1)   z. (x&lt;z&lt;yz  z+1))</p>
    <p>((x  x+1)  (y  y+1)   z. (x&lt;z&lt;yz  z+1))</p>
    <p>(x  y+1)</p>
    <p>...and some languages not recognized by orbit finite data monoids:</p>
    <p>words where first value reappears:</p>
    <p>x,y. (x = first  x &lt; y)(x = first  x &lt; y)(x = first  x &lt; y)</p>
    <p>(x = first  x &lt; y)</p>
    <p>(x  y)</p>
    <p>words where all values appear at most once:</p>
    <p>x,y. (x &lt; y)(x &lt; y)(x &lt; y)</p>
    <p>(x &lt; y)</p>
    <p>(x  y)</p>
  </div>
  <div class="page">
    <p>Consider some languages recognized by orbit finite data monoids:</p>
    <p>words where first value equals last value:</p>
    <p>x,y. (x = first  y = last)(x = first  y = last)(x = first  y = last)</p>
    <p>(x = first  y = last)</p>
    <p>(x  y)</p>
    <p>words with at least two distinct values (e.g. ... # #...):</p>
    <p>x,y. (y = x+ 1)(y = x+ 1)(y = x+ 1)</p>
    <p>(y = x+ 1)</p>
    <p>(x  y)</p>
    <p>words with at least three distinct values (e.g. ... # # # # #...):</p>
    <p>x,y. ((x  x+1)  (y  y+1)   z. (x&lt;z&lt;yz  z+1))((x  x+1)  (y  y+1)   z. (x&lt;z&lt;yz  z+1))((x  x+1)  (y  y+1)   z. (x&lt;z&lt;yz  z+1))</p>
    <p>((x  x+1)  (y  y+1)   z. (x&lt;z&lt;yz  z+1))</p>
    <p>(x  y+1)</p>
    <p>...and some languages not recognized by orbit finite data monoids:</p>
    <p>words where first value reappears:</p>
    <p>x,y. (x = first  x &lt; y)(x = first  x &lt; y)(x = first  x &lt; y)</p>
    <p>(x = first  x &lt; y)</p>
    <p>(x  y)</p>
    <p>words where all values appear at most once:</p>
    <p>x,y. (x &lt; y)(x &lt; y)(x &lt; y)</p>
    <p>(x &lt; y)</p>
    <p>(x  y)</p>
  </div>
  <div class="page">
    <p>Definition</p>
    <p>Rigidly guarded MSO is the fragment of MSO with data tests, defined by the following grammar:</p>
    <p>= x &lt; y  x  Y         x.    Y.   rigid(x,y)  x  y</p>
    <p>where rigid(x,y) is a rigid guard (generated by the same grammar)</p>
    <p>((x,y) is rigid if, in every word, x determines y and vice versa).</p>
    <p>Rigidity is a semantical restriction.</p>
    <p>However, it can be enforced syntactically, e.g.,</p>
    <p>rigid = (x,y)</p>
    <p>( x,y. [x,y]  [x,y]  (x,y))( x,y. [x,y]  [x,y]  (x,y))( x,y. [x,y]  [x,y]  (x,y))</p>
    <p>( x,y. [x,y]  [x,y]  (x,y))</p>
    <p>Is rigid(x,y)  x</p>
    <p>y needed? No: rigid(x,y)</p>
    <p>(rigid(x,y)  xy)(rigid(x,y)  xy)(rigid(x,y)  xy)</p>
    <p>(rigid(x,y)  xy)</p>
  </div>
  <div class="page">
    <p>Definition</p>
    <p>Rigidly guarded MSO is the fragment of MSO with data tests, defined by the following grammar:</p>
    <p>= x &lt; y  x  Y         x.    Y.   rigid(x,y)  x  y</p>
    <p>where rigid(x,y) is a rigid guard (generated by the same grammar)</p>
    <p>((x,y) is rigid if, in every word, x determines y and vice versa).</p>
    <p>Rigidity is a semantical restriction.</p>
    <p>However, it can be enforced syntactically, e.g.,</p>
    <p>rigid = (x,y)  ( x,y. [x,y]  [x,y]  (x,y))( x,y. [x,y]  [x,y]  (x,y))( x,y. [x,y]  [x,y]  (x,y))</p>
    <p>( x,y. [x,y]  [x,y]  (x,y))</p>
    <p>Is rigid(x,y)  x</p>
    <p>y needed?</p>
    <p>No: rigid(x,y)  (rigid(x,y)  xy)(rigid(x,y)  xy)(rigid(x,y)  xy)</p>
    <p>(rigid(x,y)  xy)</p>
  </div>
  <div class="page">
    <p>Main theorem (1)</p>
    <p>Languages defined in rigidly guarded MSO</p>
    <p>=</p>
    <p>Languages recognized by orbit finite data monoids.</p>
    <p>...and as in the Schutzenberger-McNaughton-Paperts theorem:</p>
    <p>Main theorem (2)</p>
    <p>Languages defined in rigidly guarded FO</p>
    <p>=</p>
    <p>Languages recognized by aperiodic orbit finite data monoids.</p>
    <p>(A data monoid is aperiodic if all its sub-groups are trivial)</p>
  </div>
  <div class="page">
    <p>Main theorem (1)</p>
    <p>Languages defined in rigidly guarded MSO</p>
    <p>=</p>
    <p>Languages recognized by orbit finite data monoids.</p>
    <p>...and as in the Schutzenberger-McNaughton-Paperts theorem:</p>
    <p>Main theorem (2)</p>
    <p>Languages defined in rigidly guarded FO =</p>
    <p>Languages recognized by aperiodic orbit finite data monoids.</p>
    <p>(A data monoid is aperiodic if all its sub-groups are trivial)</p>
  </div>
  <div class="page">
    <p>Proof idea (rigidly guarded MSO  orbit finite data monoid) By induction on formulas, using closure properties of data monoids:</p>
    <p>negation of a formula  easy, by definition of recognizability</p>
    <p>conjunction of formulas  product of orbit finite data monoids</p>
    <p>existential quantification  powerset of an orbit finite data monoid</p>
    <p>Given a formula (X) construct  X. (X)</p>
    <p>Given a morphism h  (D {0, 1}) M construct h  D  2M</p>
    <p>where h(w) = {h(w,X)  X  dom(w)}</p>
    <p>Given a monoid M = (M, , ) construct 2M = (2M, , ) where ST = {s t  s  S, t  T}</p>
    <p>(S) = {(s)  s  S}</p>
    <p>Technical problem: this does not preserve orbit finiteness...</p>
  </div>
  <div class="page">
    <p>Proof idea (rigidly guarded MSO  orbit finite data monoid) By induction on formulas, using closure properties of data monoids:</p>
    <p>negation of a formula  easy, by definition of recognizability</p>
    <p>conjunction of formulas  product of orbit finite data monoids</p>
    <p>existential quantification  powerset of an orbit finite data monoid</p>
    <p>Given a formula (X) construct  X. (X)</p>
    <p>Given a morphism h  (D {0, 1}) M construct h  D  2M</p>
    <p>where h(w) = {h(w,X)  X  dom(w)}</p>
    <p>Given a monoid M = (M, , ) construct 2M = (2M, , ) where ST = {s t  s  S, t  T}</p>
    <p>(S) = {(s)  s  S}</p>
    <p>Technical problem: this does not preserve orbit finiteness...</p>
  </div>
  <div class="page">
    <p>Proof idea (rigidly guarded MSO  orbit finite data monoid) By induction on formulas, using closure properties of data monoids:</p>
    <p>negation of a formula  easy, by definition of recognizability</p>
    <p>conjunction of formulas  product of orbit finite data monoids</p>
    <p>existential quantification  powerset of an orbit finite data monoid</p>
    <p>Given a formula (X) construct  X. (X)</p>
    <p>Given a morphism h  (D {0, 1}) M construct h  D  2M</p>
    <p>where h(w) = {h(w,X)  X  dom(w)}</p>
    <p>Given a monoid M = (M, , ) construct 2M = (2M, , ) where ST = {s t  s  S, t  T}</p>
    <p>(S) = {(s)  s  S}</p>
    <p>Technical problem: this does not preserve orbit finiteness...</p>
  </div>
  <div class="page">
    <p>Proof idea (rigidly guarded MSO  orbit finite data monoid) By induction on formulas, using closure properties of data monoids:</p>
    <p>negation of a formula  easy, by definition of recognizability</p>
    <p>conjunction of formulas  product of orbit finite data monoids</p>
    <p>existential quantification  powerset of an orbit finite data monoid</p>
    <p>Given a formula (X) construct  X. (X)</p>
    <p>Given a morphism h  (D {0, 1}) M construct h  D  2M</p>
    <p>where h(w) = {h(w,X)  X  dom(w)}</p>
    <p>Given a monoid M = (M, , ) construct 2M = (2M, , ) where ST = {s t  s  S, t  T}</p>
    <p>(S) = {(s)  s  S}</p>
    <p>Technical problem: this does not preserve orbit finiteness...</p>
  </div>
  <div class="page">
    <p>Proof idea (rigidly guarded MSO  orbit finite data monoid) By induction on formulas, using closure properties of data monoids:</p>
    <p>negation of a formula  easy, by definition of recognizability</p>
    <p>conjunction of formulas  product of orbit finite data monoids</p>
    <p>existential quantification  powerset of an orbit finite data monoid</p>
    <p>Given a formula (X) construct  X. (X)</p>
    <p>Given a morphism h  (D {0, 1}) M construct h  D  2M</p>
    <p>where h(w) = {h(w,X)  X  dom(w)}</p>
    <p>Given a monoid M = (M, , ) construct 2M = (2M, , ) where ST = {s t  s  S, t  T}</p>
    <p>(S) = {(s)  s  S}</p>
    <p>Technical problem: this does not preserve orbit finiteness...</p>
  </div>
  <div class="page">
    <p>Proof idea (aperiodic o.f. data monoid  rigidly guarded FO) Follow the same induction as in the Schutzenbergers proof:</p>
    <p>Given a morphism h  D  M, construct formulas computing h(w[x,y]) for larger and larger infixes w[x,y] of words.</p>
    <p>Technical problem: in order to let the induction go through, we need to simulate products of the monoid with formulas...</p>
    <p>h(w[x,y])</p>
    <p>#|D| #|D| #|D| |DD| #|D| #|D|</p>
    <p>h(w[y+1,z])  #|D| #|D| #|D| |DD| #|D| #|D|</p>
    <p>? Positions with memorable values must be compared in a rigid way!</p>
    <p>If we drop the assumption of aperiodicity, we need MSO formulas to compute elements of the monoid.</p>
    <p>Unlike in the classical case, we cannot simulate runs of automata (instad, we need to further generalize Schutzenbergers proof).</p>
  </div>
  <div class="page">
    <p>Proof idea (aperiodic o.f. data monoid  rigidly guarded FO) Follow the same induction as in the Schutzenbergers proof:</p>
    <p>Given a morphism h  D  M, construct formulas computing h(w[x,y]) for larger and larger infixes w[x,y] of words.</p>
    <p>Technical problem: in order to let the induction go through, we need to simulate products of the monoid with formulas...</p>
    <p>h(w[x,y])</p>
    <p>#|D| #|D| #|D| |DD| #|D| #|D|</p>
    <p>h(w[y+1,z])  #|D| #|D| #|D| |DD| #|D| #|D|</p>
    <p>? Positions with memorable values must be compared in a rigid way!</p>
    <p>If we drop the assumption of aperiodicity, we need MSO formulas to compute elements of the monoid.</p>
    <p>Unlike in the classical case, we cannot simulate runs of automata (instad, we need to further generalize Schutzenbergers proof).</p>
  </div>
  <div class="page">
    <p>Proof idea (aperiodic o.f. data monoid  rigidly guarded FO) Follow the same induction as in the Schutzenbergers proof:</p>
    <p>Given a morphism h  D  M, construct formulas computing h(w[x,y]) for larger and larger infixes w[x,y] of words.</p>
    <p>Technical problem: in order to let the induction go through, we need to simulate products of the monoid with formulas...</p>
    <p>h(w[x,y])</p>
    <p>#|D| #|D| #|D| |DD| #|D| #|D|</p>
    <p>h(w[y+1,z])  #|D| #|D| #|D| |DD| #|D| #|D|</p>
    <p>? Positions with memorable values must be compared in a rigid way!</p>
    <p>If we drop the assumption of aperiodicity, we need MSO formulas to compute elements of the monoid.</p>
    <p>Unlike in the classical case, we cannot simulate runs of automata (instad, we need to further generalize Schutzenbergers proof).</p>
  </div>
  <div class="page">
    <p>Proof idea (////////////aperiodic o.f. data monoid  rigidly guarded /////FO MSO) Follow the same induction as in the Schutzenbergers proof:</p>
    <p>Given a morphism h  D  M, construct formulas computing h(w[x,y]) for larger and larger infixes w[x,y] of words.</p>
    <p>Technical problem: in order to let the induction go through, we need to simulate products of the monoid with formulas...</p>
    <p>h(w[x,y])</p>
    <p>#|D| #|D| #|D| |DD| #|D| #|D|</p>
    <p>h(w[y+1,z])  #|D| #|D| #|D| |DD| #|D| #|D|</p>
    <p>? Positions with memorable values must be compared in a rigid way!</p>
    <p>If we drop the assumption of aperiodicity, we need MSO formulas to compute elements of the monoid.</p>
    <p>Unlike in the classical case, we cannot simulate runs of automata (instad, we need to further generalize Schutzenbergers proof).</p>
  </div>
  <div class="page">
    <p>We also considered a relaxation of the rigidity constraints:</p>
    <p>Definition</p>
    <p>Semi-rigidly guarded MSO is defined by the grammar</p>
    <p>=  Z1, ...,Zk. (Z1, ...,Zk)</p>
    <p>(Z1, ...,Zk) = x &lt; y  x  Y  x  Zi         x.    Y.   semi-rigid(Z1,...,Zk,x,y)  x  y</p>
    <p>where semi-rigid(Z1,...,Zk,x,y) determines y from Z1, ...,Zk,x.</p>
    <p>Example</p>
    <p>The formula below defines the language of all words where some value reappears at the last even position:</p>
    <p>=  Z.  z. (z  Z  Even(z))   x,y. (x &lt; y  y = last(Z))  x  y.</p>
  </div>
  <div class="page">
    <p>Theorem (3)</p>
    <p>Languages of data words defined in semi-rigidly guarded MSO</p>
    <p>=</p>
    <p>Languages recognized by non-deterministic register word automata.</p>
    <p>Corollary</p>
    <p>Satisfiability of semi-rigidly guarded MSO is decidable.</p>
  </div>
  <div class="page">
    <p>Theorem (3)</p>
    <p>trees Languages of data ////////words defined in semi-rigidly guarded MSO</p>
    <p>=</p>
    <p>Languages recognized by non-deterministic register //////word automata. tree</p>
    <p>Corollary</p>
    <p>Satisfiability of semi-rigidly guarded MSO is decidable.</p>
  </div>
  <div class="page">
    <p>Theorem (3)</p>
    <p>trees Languages of data ////////words defined in semi-rigidly guarded MSO</p>
    <p>=</p>
    <p>Languages recognized by non-deterministic register //////word automata. tree</p>
    <p>Corollary</p>
    <p>Satisfiability of semi-rigidly guarded MSO is decidable.</p>
  </div>
  <div class="page">
    <p>Back to our picture...</p>
    <p>all languagesdata</p>
    <p>MSO logic with data tests</p>
    <p>non-d eterministic register autom</p>
    <p>ata</p>
    <p>det ermin</p>
    <p>istic register autom ataor</p>
    <p>bit finite</p>
    <p>data monoids</p>
    <p>FO logic with d ata</p>
    <p>tes ts</p>
    <p>?</p>
    <p>aperiodic o.f. data m on</p>
    <p>oid s</p>
    <p>----------- no effective characteri zati</p>
    <p>on po</p>
    <p>ss ib</p>
    <p>le -</p>
    <p>--</p>
    <p>= Semi-rigidly guarded MSO</p>
    <p>= Rigidly guarded MSO</p>
    <p>= Rigidly guarded FO</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>A data monoid with infinitely many orbits</p>
    <p>Consider the syntactic monoid of the language L = {w  D  first value of w reappears}:</p>
    <p>D ML h</p>
    <p>(empty word)</p>
    <p># # #... # (words with one data value)</p>
    <p># # #... # # # #... # (words with two data values)</p>
    <p># # #... # # # # #... # # (words with three data values)</p>
    <p>L cannot be recognized with finitely many orbits</p>
    <p>(but it is recognized by a deterministic register automaton).</p>
  </div>
  <div class="page">
    <p>A data monoid with infinitely many orbits</p>
    <p>Consider the syntactic monoid of the language L = {w  D  first value of w reappears}:</p>
    <p>D MLML hh</p>
    <p>(empty word)</p>
    <p># # #... # (words with one data value)</p>
    <p># # #... # # # #... # (words with two data values)</p>
    <p># # #... # # # # #... # # (words with three data values)</p>
    <p>{ #} { #}</p>
    <p>{ #, #} { #, #}</p>
    <p>{ #, #, #} { #, #, #}</p>
    <p>L cannot be recognized with finitely many orbits</p>
    <p>(but it is recognized by a deterministic register automaton).</p>
  </div>
  <div class="page">
    <p>A data monoid with infinitely many orbits</p>
    <p>Consider the syntactic monoid of the language L = {w  D  first value of w reappears}:</p>
    <p>D MLML hh</p>
    <p>(empty word)</p>
    <p># # #... # (words with one data value)</p>
    <p># # #... # # # #... # (words with two data values)</p>
    <p># # #... # # # # #... # # (words with three data values)</p>
    <p>{ #} { #}</p>
    <p>{ #, #} { #, #}</p>
    <p>{ #, #, #} { #, #, #}</p>
    <p>L cannot be recognized with finitely many orbits</p>
    <p>(but it is recognized by a deterministic register automaton).</p>
  </div>
</Presentation>
