<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>To Reserve or Not to Reserve: Op.mal Online Mul.-Instance Acquisi.on in IaaS Clouds</p>
    <p>Wei Wang, Baochun Li, Ben Liang Department of Electrical and Computer Engineering</p>
    <p>University of Toronto</p>
  </div>
  <div class="page">
    <p>Growing Cloud-Compu.ng Costs</p>
    <p>Dras.c increase in enterprise spending on Infrastructure-as-a-Service (IaaS) clouds  41.7% annual growth rate by 2016 [Cloud Times12]</p>
    <p>IaaS cloud is the fastest-growing segment</p>
  </div>
  <div class="page">
    <p>Tradeoffs in Cloud Pricing Op.ons  On-demand Instances  No commitment  Pay-as-you-go</p>
    <p>Reserved Instances  Reserva.on fee + discounted price  Suitable for long-term usage commitment</p>
    <p>To Reserve or Not to Reserve: Optimal Online Multi-Instance Acquisition in IaaS Clouds</p>
    <p>Wei Wang, Baochun Li, and Ben Liang Department of Electrical and Computer Engineering</p>
    <p>University of Toronto</p>
    <p>AbstractInfrastructure-as-a-Service (IaaS) clouds offer diverse instance purchasing options. A user can either run instances on demand and pay only for what it uses, or it can prepay to reserve instances for a long period, during which a usage discount is entitled. An important problem facing a user is how these two instance options can be dynamically combined to serve time-varying demands at minimum cost. Existing strategies in the literature, however, require either exact knowledge or the distribution of demands in the long-term future, which significantly limits their use in practice. Unlike existing works, we propose two practical online algorithms, one deterministic and another randomized, that dynamically combine the two instance options online without any knowledge of the future. We show that the proposed deterministic (resp., randomized) algorithm incurs no more than 2   (resp., e/(e  1 + )) times the minimum cost obtained by an optimal offline algorithm that knows the exact future a priori, where  is the entitled discount after reservation. Our online algorithms achieve the best possible competitive ratios in both the deterministic and randomized cases, and can be easily extended to cases when short-term predictions are reliable. Simulations driven by a large volume of real-world traces show that significant cost savings can be achieved with prevalent IaaS prices.</p>
    <p>I. INTRODUCTION</p>
    <p>Enterprise spending on Infrastructure-as-a-Service (IaaS) cloud is on a rapid growth path. According to [1], the public cloud services market is expected to expand from $109 billion in 2012 to $207 billion by 2016, during which IaaS is the fastest-growing segment with a 41.7% annual growing rate [2]. IaaS cost management therefore receives significant attention and has become a primary concern for IT enterprises.</p>
    <p>Maintaining optimal cost management is especially challenging, given the complex pricing options offered in todays IaaS services market. IaaS cloud vendors, such as Amazon EC2, ElasticHosts, GoGrid, etc., apply diverse instance (i.e., virtual machine) pricing models at different commitment levels. At the lowest level, cloud users launch on-demand instances and pay only for the incurred instance-hours, without making any long-term usage commitments, e.g., [3], [4], [5]. At a higher level, there are reserved instances wherein users prepay a one-time upfront fee and then reserve an instance for months or years, during which the usage is either free, e.g., [4], [5], or is priced under a significant discount, e.g., [3]. Table I gives a pricing example of on-demand and reserved instances in Amazon EC2.</p>
    <p>Acquiring instances at the cost-optimal commitment level plays a central role for cost management. Simply operating the entire load with on-demand instances can be highly inefficient.</p>
    <p>TABLE I PRICING OF ON-DEMAND AND RESERVED INSTANCES (LIGHT</p>
    <p>UTILIZATION, LINUX, US EAST) IN AMAZON EC2, AS OF FEB. 10, 2013.</p>
    <p>Instance Type Pricing Option Upfront Hourly</p>
    <p>Standard Small On-Demand $0 $0.081-Year Reserved $69 $0.039</p>
    <p>Standard Medium On-Demand $0 $0.161-Year Reserved $138 $0.078</p>
    <p>For example, in Amazon EC2, three years of continuous ondemand service cost 3 times more than reserving instances for the same period [3]. On the other hand, naively switching to a long-term commitment incurs a huge amount of upfront payment (more than 1,000 times the on-demand rate in EC2 [3]), making reserved instances extremely expensive for sporadic workload. In particular, with time-varying loads, a user needs to answer two important questions: (1) when should I reserve instances (timing), and (2) how many instances should I reserve (quantity)?</p>
    <p>Recently proposed instance reservation strategies, e.g., [6], [7], [8], heavily rely on long-term predictions of future demands, with historic workloads as references. These approaches, however, suffer from several significant limitations in practice. First, historic workloads might not be available, especially for startup companies who have just switched to IaaS services. In addition, not all workloads are amenable to prediction. In fact, it is observed in real production applications that workload is highly variable and statistically nonstationary [9], [10], and as a result, history may reveal very little information about the future. Moreover, due to the long span of a reservation period (e.g., 1 to 3 years in Amazon EC2), workload predictions are usually required over a very long period of time, say, years. It would be very challenging, if not impossible, to make sufficiently accurate predictions over such a long term. For all these reasons, instance reservations are usually made conservatively in practice, based on empirical experiences [11] or professional recommendations, e.g., [12], [13], [14].</p>
    <p>In this paper, we are motivated by a practical yet fundamental question: Is it possible to reserve instances in an online manner, with limited or even no a priori knowledge of the future workload, while still incurring near-optimal instance acquisition costs? To our knowledge, this paper represents the first attempt to answer this question, as we make the following contributions.</p>
    <p>With dynamic programming, we first characterize the optimal offline reservation strategy as a benchmark algorithm</p>
  </div>
  <div class="page">
    <p>Mul.-Instance Acquisi.on Problem</p>
    <p>Workload (demand) is .me-varying</p>
    <p>When should I reserve an instance?  How many instances should I reserve?</p>
    <p>it is possible to have a demand prediction window that is weeks into the future. Both our online algorithms can be easily extended to utilize these knowledge of future demands when making reservation decisions.</p>
    <p>We begin by formulating the instance reservation problem with limited information of future demands. Let w be the prediction window. That is, at any time t, a user can predict its future demands d</p>
    <p>t+1, . . . , dt+w in the next w hours. Since only short-term predictions are reliable, one can safely assume that the prediction window is less than a reservation period, i.e., w &lt;  . The instance reservation problem resembles the online reservation problem (1), except that the instance purchase decisions made at each time t, i.e., the number of reserved instances (r</p>
    <p>t</p>
    <p>) and on-demand instances (o t</p>
    <p>), are based on both history and future demands predicted, i.e., d1, . . . , dt+w. The competitive analysis (Definition 1) remains valid in this case.</p>
    <p>The Deterministic Algorithm: We extend our deterministic online algorithm as follows. As before, all workloads are by default served by on-demand instances. At time t, we can predict the demands up to time t+w. Unlike the online deterministic algorithm, we check the use of on-demand instances in a reservation period across both history and future, starting from time t+w +1 to t+w. A new instance is reserved at time t whenever we see an on-demand instance incurring more costs than the break-even point  and the currently effective reservations are less than the current demand d</p>
    <p>t</p>
    <p>. Algorithm 3, also denoted by Aw</p>
    <p>, shows the details.</p>
    <p>Algorithm 3 Deterministic Algorithm Aw</p>
    <p>with Prediction Window w</p>
    <p>be the number of reserved instances at time i, Initially, x</p>
    <p>i</p>
    <p>t</p>
    <p>, loop as follows: 3. while p</p>
    <p>P t+w i=t+w+1 I(di &gt; xi) &gt;  and xt &lt; dt do</p>
    <p>r t</p>
    <p>+ 1. 5. Update the number of reservations that can be used in</p>
    <p>the future: x i</p>
    <p>x i</p>
    <p>+ 1 for i = t, . . . , t +  1. 6. Add a phantom reservation to the history, indicating</p>
    <p>that the history has already been processed: x i</p>
    <p>x</p>
    <p>i</p>
    <p>+ 1 for i = t + w   + 1, . . . , t1. 7. end while 8. Launch on-demand instances: o</p>
    <p>t</p>
    <p>(d t</p>
    <p>x t</p>
    <p>)+. 9. t t + 1, repeat from 2.</p>
    <p>The Randomized Algorithm: The randomized algorithm can also be constructed as a random distribution over a family of deterministic algorithms similar to Aw</p>
    <p>. In particular, let A</p>
    <p>w</p>
    <p>z</p>
    <p>be similarly defined as algorithm Aw</p>
    <p>with  replaced by z 2 [0, ] in line 3 of Algorithm 3. The value of z reflects the aggressiveness of instance reservation. The smaller the z, the more aggressive the reservation strategy. Similar to the online randomized, we introduce randomness to strike a good balance between reserving aggressively and conservatively. Our algorithm randomly picks z 2 [0, ] according to the same density function f(z) defined by (21), and runs the resulting algorithm Aw</p>
    <p>z</p>
    <p>. Algorithm 4 formalizes the description above.</p>
    <p>Algorithm 4 Randomized Algorithm with Prediction Window w</p>
    <p>Time (hour)</p>
    <p>In s ta</p>
    <p>n c e</p>
    <p>User 552</p>
    <p>Fig. 2. The demand curve of User 552 in Google cluster-usage traces [16], over 1 month.</p>
    <p>It is easy to see that both the deterministic and the randomized algorithms presented above improve the cost performance of their online counterparts, due to the knowledge of future demands. Therefore, we have Proposition 5 below. We will quantify their performance gains via trace-driven simulations in the next section.</p>
    <p>Proposition 5: Algorithm 3 is (2  )-competitive, and Algorithm 4 is e/(e1 + )-competitive.</p>
    <p>VII. TRACE-DRIVEN SIMULATIONS So far, we have analyzed the cost performance of the</p>
    <p>proposed algorithms in a view of competitive analysis. In this section, we evaluate their performance for practical cloud users via simulations driven by a large volume of real-world traces.</p>
    <p>A. Dataset Description and Preprocessing</p>
    <p>Long-term user demand data in public IaaS clouds are often confidential: no cloud provider has released such information so far. For this reason, we turn to Google cluster-usage traces that were recently released in [16]. Although Google is not a public IaaS cloud, its cluster-usage traces record the computing demands of its cloud services and Google engineers, which can represent the computing demands of IaaS users to some degree. The dataset contains 40 GB of workload resource requirements (e.g., CPU, memory, disk, etc.) of 933 users over 29 days in May 2011, on a cluster of more than 11K Google machines.</p>
    <p>Demand Curve: Given the workload traces of each user, we ask the question: How many computing instances would this user require if it were to run the same workload in a public IaaS cloud? For simplicity, we set an instance to have the same computing capacity as a cluster machine, which enables us to accurately estimate the run time of computational tasks by learning from the original traces. We then schedule these tasks onto instances with sufficient resources to accommodate their requirements. Computational tasks that cannot run on the same server in the traces (e.g., tasks of MapReduce) are scheduled to different instances. In the end, we obtain a demand curve for each user, indicating how many instances this user requires in each hour. Fig. 2 illustrates such a demand curve for a user.</p>
    <p>User Classification: To investigate how our online algorithms perform under different demand patterns, we classify</p>
  </div>
  <div class="page">
    <p>Predict the Future?</p>
    <p>Exis.ng works rely on predic.on of future demand  [Hong SIGMETRICS11, Bodenstein ICIS11, Vermeersch Thesis11, Wang ICDCS13]</p>
    <p>However  Predic.on is needed for long-term future</p>
    <p>Instance reserva.on period is typically months to years  Precise predic.on not possible  Demand history may be limited</p>
    <p>E.g., startup companies, new services</p>
  </div>
  <div class="page">
    <p>How well can we make instance reserva.on decisions online, without any a priori informa.on about the</p>
    <p>future demand?</p>
  </div>
  <div class="page">
    <p>Our Main Contribu.ons</p>
    <p>Propose two online reserva.on algorithms that offer the best provable cost guarantees  Determinis.c: (2-)-compe..ve  Randomized: e/(e-1+)-compe..ve</p>
    <p>: normalized discounted price under reserva.on (0    1)</p>
    <p>Study prac.cal performance gains using Google cluster workload traces</p>
  </div>
  <div class="page">
    <p>Problem Formula.on</p>
  </div>
  <div class="page">
    <p>Pricing of On-Demand and Reserved Instances</p>
    <p>On-demand Instances  Fixed hourly price: p  Cost of running for h hours: ph</p>
    <p>Reserved Instances  Upfront reserva.on fee + discounted price  Normalized reserva.on fee: 1  Reserva.on period:  hours  Cost of running for h hours: 1 + ph</p>
    <p>: normalized discounted price under reserva.on (0    1)</p>
  </div>
  <div class="page">
    <p>User Demand and Reserva.on</p>
    <p>At .me t (discrete .me), the user  Has demand for dt instances (.me-varying)  Newly reserves rt instances  Available reserved instances:</p>
    <p>Launches ot on-demand instances  Total available instances:</p>
    <p>and those cloud users whose workloads are highly variable and non-stationary  in both cases reliable predictions are unavailable. We postpone the discussions for cases when shortterm demand predictions are reliable in Sec. VI.</p>
    <p>Since IaaS instances are billed in an hourly manner, we slot the time to a sequence of hours indexed by t = 0, 1, 2, . . . At each time t, demand d</p>
    <p>t</p>
    <p>arrives, meaning that a user requests d t</p>
    <p>instances, d t</p>
    <p>= 0, 1, 2, . . . To accommodate this demand, the user decides to use o</p>
    <p>t</p>
    <p>on-demand instances and d t</p>
    <p>o t</p>
    <p>reserved instances. If the previously reserved instances that remain available at time t are fewer than d</p>
    <p>t</p>
    <p>o t</p>
    <p>, then new instances need to be reserved. Let r</p>
    <p>t</p>
    <p>be the number of instances that are newly reserved at time t, r</p>
    <p>t</p>
    <p>= 0, 1, 2, . . . The overall cost incurred at time t is the on-demand cost o</p>
    <p>t</p>
    <p>p plus the reservation cost r</p>
    <p>t</p>
    <p>+ p(d t</p>
    <p>o t</p>
    <p>), where r t</p>
    <p>is the upfront payments due to new reservations, and p(d</p>
    <p>t</p>
    <p>o t</p>
    <p>) is the cost of running d</p>
    <p>t</p>
    <p>o t</p>
    <p>reserved instances. The cost management problem is to make instance purchase</p>
    <p>decisions online, i.e., r t</p>
    <p>and o t</p>
    <p>at each time t, before seeing future demands d</p>
    <p>t+1, dt+2, . . . The objective is to minimize the overall instance acquisition costs. Suppose demands last for an arbitrary time T (counted by the number of hours). We have the following online instance reservation problem:</p>
    <p>min {rt,ot}</p>
    <p>C = TX</p>
    <p>t=1</p>
    <p>(o t</p>
    <p>p + r t</p>
    <p>+ p(d t</p>
    <p>o t</p>
    <p>)) ,</p>
    <p>s.t. o t</p>
    <p>+</p>
    <p>tX</p>
    <p>i=t+1 r</p>
    <p>i</p>
    <p>d t</p>
    <p>,</p>
    <p>o</p>
    <p>t</p>
    <p>, r</p>
    <p>t</p>
    <p>(1)</p>
    <p>Here, the first constraint ensures that all d t</p>
    <p>instances demanded at time t are accommodated, with o</p>
    <p>t</p>
    <p>on-demand instances andP t</p>
    <p>i=t+1 ri reserved instances that remain active at time t. Note that instances that are reserved before time t   + 1 have all expired at time t, where  is the reservation period. For convenience, we set r</p>
    <p>t</p>
    <p>= 0 for all t  0. The main challenge of problem (1) lies in its online setting.</p>
    <p>Without knowledge of future demands, the online strategy may make purchase decisions that turn out later not to be optimal. Below we clarify the performance metrics to measure how far away an online strategy may deviate from the optimal solution.</p>
    <p>C. Measure of Competitiveness</p>
    <p>To measure the cost performance of an online strategy, we adopt the standard competitive analysis [18]. The idea is to bound the gap between the cost of an interested online algorithm and that of the optimal offline strategy. The latter is obtained by solving problem (1) with the exact future demands d1, . . . , dT given a priori. Formally, we have</p>
    <p>Definition 1 (Competitive analysis): A deterministic online reservation algorithm A is c-competitive (c is a constant) if for all possible demand sequences d = {d1, . . . , dT }, we have</p>
    <p>C</p>
    <p>A</p>
    <p>(d)  c  COPT(d) , (2)</p>
    <p>where C A</p>
    <p>(d) is the instance acquisition cost incurred by algorithm A given input d, and COPT(d) is the optimal instance acquisition cost given input d. Here, COPT(d) is obtained by solving the instance reservation problem (1) offline, where the exact demand sequence d is assumed to know a priori.</p>
    <p>A similar definition of the competitive analysis also extends to the randomized online algorithm A, where the decision making is drawn from a random distribution. In this case, the LHS of (2) is simply replaced by E[C</p>
    <p>A</p>
    <p>(d)], the expected cost of randomized algorithm A given input d. (See [18] for a detailed discussion.)</p>
    <p>Competitive analysis takes an optimal offline algorithm as a benchmark to measure the cost performance of an online strategy. Intuitively, the smaller the competitive ratio c is, the more closely the online algorithm A approaches the optimal solution. Our objective is to design optimal online algorithms with the smallest competitive ratio.</p>
    <p>We note that the instance reservation problem (1) captures the Bahncard problem [19] as a special case when a user demands no more than one instance at a time, i.e., d</p>
    <p>t</p>
    <p>1 for all t. The Bahncard problem models online ticket purchasing on the German Federal Railway, where one can opt to buy a Bahncard (reserve an instance) and to receive a discount on all trips within one year of the purchase date. It has been shown in [19], [20] that the lower bound of the competitive ratio is 2   and e/(e  1 + ) for the deterministic and randomized Bahncard algorithms, respectively. Because the Bahncard problem is a special case of our problem (1), we have</p>
    <p>Lemma 1: The competitive ratio of problem (1) is at least 2 for deterministic online algorithms, and is at least e/(e 1 + ) for randomized online algorithms.</p>
    <p>However, we show in the following that the instance reserving problem (1) is by no means a trivial extension to the Bahncard problem, mainly due to the time-multiplexing nature of reserved instances.</p>
    <p>D. Bahncard Extension and Its Inefficiency</p>
    <p>A natural way to extend the Bahncard solutions in [19] is to decompose problem (1) into separate Bahncard problems. To do this, we introduce a set of virtual users indexed by 1, 2, . . . Whenever demand d</p>
    <p>t</p>
    <p>arises at time t, we view the original user as d</p>
    <p>t</p>
    <p>virtual users 1, 2, . . . , d t</p>
    <p>, each requiring one instance at that time. Each virtual user then reserves instances (i.e., buy a Bahncard) separately to minimize its cost, which is exactly a Bahncard problem.</p>
    <p>However, such an extension is highly inefficient. An instance reserved by one virtual user, even idle, can never be multiplexed with another, who still needs to pay for its own demand. For a real user, this implies that it has to acquire additional instances, either on-demand or reserved, even if the user has already reserved sufficient amount of instances to serve its demand, which inevitably incurs a large amount of unnecessary cost.</p>
    <p>We learn from the above failure that instances must be reserved jointly and time multiplexed appropriately. These</p>
    <p>and those cloud users whose workloads are highly variable and non-stationary  in both cases reliable predictions are unavailable. We postpone the discussions for cases when shortterm demand predictions are reliable in Sec. VI.</p>
    <p>Since IaaS instances are billed in an hourly manner, we slot the time to a sequence of hours indexed by t = 0, 1, 2, . . . At each time t, demand d</p>
    <p>t</p>
    <p>arrives, meaning that a user requests d t</p>
    <p>instances, d t</p>
    <p>= 0, 1, 2, . . . To accommodate this demand, the user decides to use o</p>
    <p>t</p>
    <p>on-demand instances and d t</p>
    <p>o t</p>
    <p>reserved instances. If the previously reserved instances that remain available at time t are fewer than d</p>
    <p>t</p>
    <p>o t</p>
    <p>, then new instances need to be reserved. Let r</p>
    <p>t</p>
    <p>be the number of instances that are newly reserved at time t, r</p>
    <p>t</p>
    <p>= 0, 1, 2, . . . The overall cost incurred at time t is the on-demand cost o</p>
    <p>t</p>
    <p>p plus the reservation cost r</p>
    <p>t</p>
    <p>+ p(d t</p>
    <p>o t</p>
    <p>), where r t</p>
    <p>is the upfront payments due to new reservations, and p(d</p>
    <p>t</p>
    <p>o t</p>
    <p>) is the cost of running d</p>
    <p>t</p>
    <p>o t</p>
    <p>reserved instances. The cost management problem is to make instance purchase</p>
    <p>decisions online, i.e., r t</p>
    <p>and o t</p>
    <p>at each time t, before seeing future demands d</p>
    <p>t+1, dt+2, . . . The objective is to minimize the overall instance acquisition costs. Suppose demands last for an arbitrary time T (counted by the number of hours). We have the following online instance reservation problem:</p>
    <p>min {rt,ot}</p>
    <p>C = TX</p>
    <p>t=1</p>
    <p>(o t</p>
    <p>p + r t</p>
    <p>+ p(d t</p>
    <p>o t</p>
    <p>)) ,</p>
    <p>s.t. o t</p>
    <p>+</p>
    <p>tX</p>
    <p>i=t+1 r</p>
    <p>i</p>
    <p>d t</p>
    <p>,</p>
    <p>o</p>
    <p>t</p>
    <p>, r</p>
    <p>t</p>
    <p>(1)</p>
    <p>Here, the first constraint ensures that all d t</p>
    <p>instances demanded at time t are accommodated, with o</p>
    <p>t</p>
    <p>on-demand instances andP t</p>
    <p>i=t+1 ri reserved instances that remain active at time t. Note that instances that are reserved before time t   + 1 have all expired at time t, where  is the reservation period. For convenience, we set r</p>
    <p>t</p>
    <p>= 0 for all t  0. The main challenge of problem (1) lies in its online setting.</p>
    <p>Without knowledge of future demands, the online strategy may make purchase decisions that turn out later not to be optimal. Below we clarify the performance metrics to measure how far away an online strategy may deviate from the optimal solution.</p>
    <p>C. Measure of Competitiveness</p>
    <p>To measure the cost performance of an online strategy, we adopt the standard competitive analysis [18]. The idea is to bound the gap between the cost of an interested online algorithm and that of the optimal offline strategy. The latter is obtained by solving problem (1) with the exact future demands d1, . . . , dT given a priori. Formally, we have</p>
    <p>Definition 1 (Competitive analysis): A deterministic online reservation algorithm A is c-competitive (c is a constant) if for all possible demand sequences d = {d1, . . . , dT }, we have</p>
    <p>C</p>
    <p>A</p>
    <p>(d)  c  COPT(d) , (2)</p>
    <p>where C A</p>
    <p>(d) is the instance acquisition cost incurred by algorithm A given input d, and COPT(d) is the optimal instance acquisition cost given input d. Here, COPT(d) is obtained by solving the instance reservation problem (1) offline, where the exact demand sequence d is assumed to know a priori.</p>
    <p>A similar definition of the competitive analysis also extends to the randomized online algorithm A, where the decision making is drawn from a random distribution. In this case, the LHS of (2) is simply replaced by E[C</p>
    <p>A</p>
    <p>(d)], the expected cost of randomized algorithm A given input d. (See [18] for a detailed discussion.)</p>
    <p>Competitive analysis takes an optimal offline algorithm as a benchmark to measure the cost performance of an online strategy. Intuitively, the smaller the competitive ratio c is, the more closely the online algorithm A approaches the optimal solution. Our objective is to design optimal online algorithms with the smallest competitive ratio.</p>
    <p>We note that the instance reservation problem (1) captures the Bahncard problem [19] as a special case when a user demands no more than one instance at a time, i.e., d</p>
    <p>t</p>
    <p>1 for all t. The Bahncard problem models online ticket purchasing on the German Federal Railway, where one can opt to buy a Bahncard (reserve an instance) and to receive a discount on all trips within one year of the purchase date. It has been shown in [19], [20] that the lower bound of the competitive ratio is 2   and e/(e  1 + ) for the deterministic and randomized Bahncard algorithms, respectively. Because the Bahncard problem is a special case of our problem (1), we have</p>
    <p>Lemma 1: The competitive ratio of problem (1) is at least 2 for deterministic online algorithms, and is at least e/(e 1 + ) for randomized online algorithms.</p>
    <p>However, we show in the following that the instance reserving problem (1) is by no means a trivial extension to the Bahncard problem, mainly due to the time-multiplexing nature of reserved instances.</p>
    <p>D. Bahncard Extension and Its Inefficiency</p>
    <p>A natural way to extend the Bahncard solutions in [19] is to decompose problem (1) into separate Bahncard problems. To do this, we introduce a set of virtual users indexed by 1, 2, . . . Whenever demand d</p>
    <p>t</p>
    <p>arises at time t, we view the original user as d</p>
    <p>t</p>
    <p>virtual users 1, 2, . . . , d t</p>
    <p>, each requiring one instance at that time. Each virtual user then reserves instances (i.e., buy a Bahncard) separately to minimize its cost, which is exactly a Bahncard problem.</p>
    <p>However, such an extension is highly inefficient. An instance reserved by one virtual user, even idle, can never be multiplexed with another, who still needs to pay for its own demand. For a real user, this implies that it has to acquire additional instances, either on-demand or reserved, even if the user has already reserved sufficient amount of instances to serve its demand, which inevitably incurs a large amount of unnecessary cost.</p>
    <p>We learn from the above failure that instances must be reserved jointly and time multiplexed appropriately. These</p>
  </div>
  <div class="page">
    <p>Op.mal Offline Algorithm</p>
    <p>Make instance purchase decisions ot and rt with knowledge of all future demands dt+1, dt +2,</p>
    <p>Can be solved by dynamic programming, but is computa5onally prohibi5ve</p>
    <p>and those cloud users whose workloads are highly variable and non-stationary  in both cases reliable predictions are unavailable. We postpone the discussions for cases when shortterm demand predictions are reliable in Sec. VI.</p>
    <p>Since IaaS instances are billed in an hourly manner, we slot the time to a sequence of hours indexed by t = 0, 1, 2, . . . At each time t, demand d</p>
    <p>t</p>
    <p>arrives, meaning that a user requests d t</p>
    <p>instances, d t</p>
    <p>= 0, 1, 2, . . . To accommodate this demand, the user decides to use o</p>
    <p>t</p>
    <p>on-demand instances and d t</p>
    <p>o t</p>
    <p>reserved instances. If the previously reserved instances that remain available at time t are fewer than d</p>
    <p>t</p>
    <p>o t</p>
    <p>, then new instances need to be reserved. Let r</p>
    <p>t</p>
    <p>be the number of instances that are newly reserved at time t, r</p>
    <p>t</p>
    <p>= 0, 1, 2, . . . The overall cost incurred at time t is the on-demand cost o</p>
    <p>t</p>
    <p>p plus the reservation cost r</p>
    <p>t</p>
    <p>+ p(d t</p>
    <p>o t</p>
    <p>), where r t</p>
    <p>is the upfront payments due to new reservations, and p(d</p>
    <p>t</p>
    <p>o t</p>
    <p>) is the cost of running d</p>
    <p>t</p>
    <p>o t</p>
    <p>reserved instances. The cost management problem is to make instance purchase</p>
    <p>decisions online, i.e., r t</p>
    <p>and o t</p>
    <p>at each time t, before seeing future demands d</p>
    <p>t+1, dt+2, . . . The objective is to minimize the overall instance acquisition costs. Suppose demands last for an arbitrary time T (counted by the number of hours). We have the following online instance reservation problem:</p>
    <p>min {rt,ot}</p>
    <p>C = TX</p>
    <p>t=1</p>
    <p>(o t</p>
    <p>p + r t</p>
    <p>+ p(d t</p>
    <p>o t</p>
    <p>)) ,</p>
    <p>s.t. o t</p>
    <p>+</p>
    <p>tX</p>
    <p>i=t+1 r</p>
    <p>i</p>
    <p>d t</p>
    <p>,</p>
    <p>o</p>
    <p>t</p>
    <p>, r</p>
    <p>t</p>
    <p>(1)</p>
    <p>Here, the first constraint ensures that all d t</p>
    <p>instances demanded at time t are accommodated, with o</p>
    <p>t</p>
    <p>on-demand instances andP t</p>
    <p>i=t+1 ri reserved instances that remain active at time t. Note that instances that are reserved before time t   + 1 have all expired at time t, where  is the reservation period. For convenience, we set r</p>
    <p>t</p>
    <p>= 0 for all t  0. The main challenge of problem (1) lies in its online setting.</p>
    <p>Without knowledge of future demands, the online strategy may make purchase decisions that turn out later not to be optimal. Below we clarify the performance metrics to measure how far away an online strategy may deviate from the optimal solution.</p>
    <p>C. Measure of Competitiveness</p>
    <p>To measure the cost performance of an online strategy, we adopt the standard competitive analysis [18]. The idea is to bound the gap between the cost of an interested online algorithm and that of the optimal offline strategy. The latter is obtained by solving problem (1) with the exact future demands d1, . . . , dT given a priori. Formally, we have</p>
    <p>Definition 1 (Competitive analysis): A deterministic online reservation algorithm A is c-competitive (c is a constant) if for all possible demand sequences d = {d1, . . . , dT }, we have</p>
    <p>C</p>
    <p>A</p>
    <p>(d)  c  COPT(d) , (2)</p>
    <p>where C A</p>
    <p>(d) is the instance acquisition cost incurred by algorithm A given input d, and COPT(d) is the optimal instance acquisition cost given input d. Here, COPT(d) is obtained by solving the instance reservation problem (1) offline, where the exact demand sequence d is assumed to know a priori.</p>
    <p>A similar definition of the competitive analysis also extends to the randomized online algorithm A, where the decision making is drawn from a random distribution. In this case, the LHS of (2) is simply replaced by E[C</p>
    <p>A</p>
    <p>(d)], the expected cost of randomized algorithm A given input d. (See [18] for a detailed discussion.)</p>
    <p>Competitive analysis takes an optimal offline algorithm as a benchmark to measure the cost performance of an online strategy. Intuitively, the smaller the competitive ratio c is, the more closely the online algorithm A approaches the optimal solution. Our objective is to design optimal online algorithms with the smallest competitive ratio.</p>
    <p>We note that the instance reservation problem (1) captures the Bahncard problem [19] as a special case when a user demands no more than one instance at a time, i.e., d</p>
    <p>t</p>
    <p>1 for all t. The Bahncard problem models online ticket purchasing on the German Federal Railway, where one can opt to buy a Bahncard (reserve an instance) and to receive a discount on all trips within one year of the purchase date. It has been shown in [19], [20] that the lower bound of the competitive ratio is 2   and e/(e  1 + ) for the deterministic and randomized Bahncard algorithms, respectively. Because the Bahncard problem is a special case of our problem (1), we have</p>
    <p>Lemma 1: The competitive ratio of problem (1) is at least 2 for deterministic online algorithms, and is at least e/(e 1 + ) for randomized online algorithms.</p>
    <p>However, we show in the following that the instance reserving problem (1) is by no means a trivial extension to the Bahncard problem, mainly due to the time-multiplexing nature of reserved instances.</p>
    <p>D. Bahncard Extension and Its Inefficiency</p>
    <p>A natural way to extend the Bahncard solutions in [19] is to decompose problem (1) into separate Bahncard problems. To do this, we introduce a set of virtual users indexed by 1, 2, . . . Whenever demand d</p>
    <p>t</p>
    <p>arises at time t, we view the original user as d</p>
    <p>t</p>
    <p>virtual users 1, 2, . . . , d t</p>
    <p>, each requiring one instance at that time. Each virtual user then reserves instances (i.e., buy a Bahncard) separately to minimize its cost, which is exactly a Bahncard problem.</p>
    <p>However, such an extension is highly inefficient. An instance reserved by one virtual user, even idle, can never be multiplexed with another, who still needs to pay for its own demand. For a real user, this implies that it has to acquire additional instances, either on-demand or reserved, even if the user has already reserved sufficient amount of instances to serve its demand, which inevitably incurs a large amount of unnecessary cost.</p>
    <p>We learn from the above failure that instances must be reserved jointly and time multiplexed appropriately. These</p>
    <p>On-demand cost Reserva.on cost</p>
  </div>
  <div class="page">
    <p>Online Instance Reserva.on</p>
    <p>Make instance purchase decisions ot and rt without seeing future demands dt+1, dt+2,</p>
    <p>What is the best that one can do?</p>
    <p>and those cloud users whose workloads are highly variable and non-stationary  in both cases reliable predictions are unavailable. We postpone the discussions for cases when shortterm demand predictions are reliable in Sec. VI.</p>
    <p>Since IaaS instances are billed in an hourly manner, we slot the time to a sequence of hours indexed by t = 0, 1, 2, . . . At each time t, demand d</p>
    <p>t</p>
    <p>arrives, meaning that a user requests d t</p>
    <p>instances, d t</p>
    <p>= 0, 1, 2, . . . To accommodate this demand, the user decides to use o</p>
    <p>t</p>
    <p>on-demand instances and d t</p>
    <p>o t</p>
    <p>reserved instances. If the previously reserved instances that remain available at time t are fewer than d</p>
    <p>t</p>
    <p>o t</p>
    <p>, then new instances need to be reserved. Let r</p>
    <p>t</p>
    <p>be the number of instances that are newly reserved at time t, r</p>
    <p>t</p>
    <p>= 0, 1, 2, . . . The overall cost incurred at time t is the on-demand cost o</p>
    <p>t</p>
    <p>p plus the reservation cost r</p>
    <p>t</p>
    <p>+ p(d t</p>
    <p>o t</p>
    <p>), where r t</p>
    <p>is the upfront payments due to new reservations, and p(d</p>
    <p>t</p>
    <p>o t</p>
    <p>) is the cost of running d</p>
    <p>t</p>
    <p>o t</p>
    <p>reserved instances. The cost management problem is to make instance purchase</p>
    <p>decisions online, i.e., r t</p>
    <p>and o t</p>
    <p>at each time t, before seeing future demands d</p>
    <p>t+1, dt+2, . . . The objective is to minimize the overall instance acquisition costs. Suppose demands last for an arbitrary time T (counted by the number of hours). We have the following online instance reservation problem:</p>
    <p>min {rt,ot}</p>
    <p>C = TX</p>
    <p>t=1</p>
    <p>(o t</p>
    <p>p + r t</p>
    <p>+ p(d t</p>
    <p>o t</p>
    <p>)) ,</p>
    <p>s.t. o t</p>
    <p>+</p>
    <p>tX</p>
    <p>i=t+1 r</p>
    <p>i</p>
    <p>d t</p>
    <p>,</p>
    <p>o</p>
    <p>t</p>
    <p>, r</p>
    <p>t</p>
    <p>(1)</p>
    <p>Here, the first constraint ensures that all d t</p>
    <p>instances demanded at time t are accommodated, with o</p>
    <p>t</p>
    <p>on-demand instances andP t</p>
    <p>i=t+1 ri reserved instances that remain active at time t. Note that instances that are reserved before time t   + 1 have all expired at time t, where  is the reservation period. For convenience, we set r</p>
    <p>t</p>
    <p>= 0 for all t  0. The main challenge of problem (1) lies in its online setting.</p>
    <p>Without knowledge of future demands, the online strategy may make purchase decisions that turn out later not to be optimal. Below we clarify the performance metrics to measure how far away an online strategy may deviate from the optimal solution.</p>
    <p>C. Measure of Competitiveness</p>
    <p>To measure the cost performance of an online strategy, we adopt the standard competitive analysis [18]. The idea is to bound the gap between the cost of an interested online algorithm and that of the optimal offline strategy. The latter is obtained by solving problem (1) with the exact future demands d1, . . . , dT given a priori. Formally, we have</p>
    <p>Definition 1 (Competitive analysis): A deterministic online reservation algorithm A is c-competitive (c is a constant) if for all possible demand sequences d = {d1, . . . , dT }, we have</p>
    <p>C</p>
    <p>A</p>
    <p>(d)  c  COPT(d) , (2)</p>
    <p>where C A</p>
    <p>(d) is the instance acquisition cost incurred by algorithm A given input d, and COPT(d) is the optimal instance acquisition cost given input d. Here, COPT(d) is obtained by solving the instance reservation problem (1) offline, where the exact demand sequence d is assumed to know a priori.</p>
    <p>A similar definition of the competitive analysis also extends to the randomized online algorithm A, where the decision making is drawn from a random distribution. In this case, the LHS of (2) is simply replaced by E[C</p>
    <p>A</p>
    <p>(d)], the expected cost of randomized algorithm A given input d. (See [18] for a detailed discussion.)</p>
    <p>Competitive analysis takes an optimal offline algorithm as a benchmark to measure the cost performance of an online strategy. Intuitively, the smaller the competitive ratio c is, the more closely the online algorithm A approaches the optimal solution. Our objective is to design optimal online algorithms with the smallest competitive ratio.</p>
    <p>We note that the instance reservation problem (1) captures the Bahncard problem [19] as a special case when a user demands no more than one instance at a time, i.e., d</p>
    <p>t</p>
    <p>1 for all t. The Bahncard problem models online ticket purchasing on the German Federal Railway, where one can opt to buy a Bahncard (reserve an instance) and to receive a discount on all trips within one year of the purchase date. It has been shown in [19], [20] that the lower bound of the competitive ratio is 2   and e/(e  1 + ) for the deterministic and randomized Bahncard algorithms, respectively. Because the Bahncard problem is a special case of our problem (1), we have</p>
    <p>Lemma 1: The competitive ratio of problem (1) is at least 2 for deterministic online algorithms, and is at least e/(e 1 + ) for randomized online algorithms.</p>
    <p>However, we show in the following that the instance reserving problem (1) is by no means a trivial extension to the Bahncard problem, mainly due to the time-multiplexing nature of reserved instances.</p>
    <p>D. Bahncard Extension and Its Inefficiency</p>
    <p>A natural way to extend the Bahncard solutions in [19] is to decompose problem (1) into separate Bahncard problems. To do this, we introduce a set of virtual users indexed by 1, 2, . . . Whenever demand d</p>
    <p>t</p>
    <p>arises at time t, we view the original user as d</p>
    <p>t</p>
    <p>virtual users 1, 2, . . . , d t</p>
    <p>, each requiring one instance at that time. Each virtual user then reserves instances (i.e., buy a Bahncard) separately to minimize its cost, which is exactly a Bahncard problem.</p>
    <p>However, such an extension is highly inefficient. An instance reserved by one virtual user, even idle, can never be multiplexed with another, who still needs to pay for its own demand. For a real user, this implies that it has to acquire additional instances, either on-demand or reserved, even if the user has already reserved sufficient amount of instances to serve its demand, which inevitably incurs a large amount of unnecessary cost.</p>
    <p>We learn from the above failure that instances must be reserved jointly and time multiplexed appropriately. These</p>
    <p>On-demand cost Reserva.on cost</p>
  </div>
  <div class="page">
    <p>Measure of Op.mality</p>
    <p>Compare an online reserva.on algorithm with the op.mal offline reserva.on</p>
    <p>An online algorithm A is -compe55ve if it incurs at most  .mes the op.mal offline cost  For any demand sequence d = d1,d2,</p>
    <p>CA(d)   COPT(d)  Aims to minimize the compe..ve ra.o</p>
  </div>
  <div class="page">
    <p>The Best Possible Outcome</p>
    <p>Lemma 1: The best achievable compe..ve ra.o is 2- for determinis5c online algorithms, and is e/ (e-1+ ) for randomized online algorithms. Bahncard problem [Fleischer TCS01]:  Goal: reduce cost of using the Deutsche Bahn  User may buy .ckets on-demand or buy an annual Bahncard to enjoy discounted .ckets</p>
    <p>No knowledge about users travel plans or travel frequency</p>
  </div>
  <div class="page">
    <p>Is the op.mal compe..ve ra.o achievable with mul.ple instances?</p>
    <p>Mul.-Bahncard problem  Nave extension: separate Bahncards  Does not work</p>
  </div>
  <div class="page">
    <p>Op.mal Determinis.c Online Algorithm</p>
  </div>
  <div class="page">
    <p>Demand and Reserva.on Curves</p>
    <p>t Time</p>
    <p>D em</p>
    <p>an d</p>
    <p>dDemand curve xReservation curve</p>
    <p>Served by on-demand instances</p>
    <p>Wasted reserva.ons</p>
  </div>
  <div class="page">
    <p>Break-Even Point</p>
    <p>Let c be the cost of one on-demand instance to serve workload that spans a reserva.on period.</p>
    <p>Using a reserved instance instead, the cost is 1+c</p>
    <p>Break-even point: c = 1+c  Let =1/(1- )  c =  : Break even  c &lt;  : On-demand is bener  c &gt;  : Reserva.on is bener</p>
  </div>
  <div class="page">
    <p>Regret and Compensa.on</p>
    <p>One reserva.on period</p>
    <p>At .me t, look back for one reserva.on period.  If the incurred on-demand cost &gt; , reserve a new instance: rt = rt+1.</p>
    <p>Shaded demand should have been served by a reserved instance</p>
  </div>
  <div class="page">
    <p>Update Reserva.on Curve</p>
    <p>tt- +1 Time</p>
    <p>D em</p>
    <p>an d</p>
    <p>dDemand curve xReservation curve</p>
    <p>If a new instance is reserved, update the reserva.on curve, both forward and backward.</p>
  </div>
  <div class="page">
    <p>Repeat un.l No Regret</p>
    <p>Repeat to reserve more new instances, un.l the (virtual) incurred on-demand cost &lt; .</p>
  </div>
  <div class="page">
    <p>Proposi.on 1: The determinis.c online algorithm is (2-)-compe..ve, and hence is op5mal among all determinis.c online algorithms.</p>
  </div>
  <div class="page">
    <p>Op.mal Randomized Online Algorithm</p>
  </div>
  <div class="page">
    <p>Basic Idea</p>
    <p>Can use different thresholds z (other than the break-even point ) to decide whether to reserve an instance  A family of determinis.c algorithms {Az}</p>
    <p>The smaller z, the more aggressive the reserva.on strategy  z = 0: All-reserved  z = +: All-on-demand</p>
  </div>
  <div class="page">
    <p>Basic Idea (Contd)  Randomly choose from the family of determinis.c algorithms {Az}  Strike balance between reserving too aggressively and too conserva.vely</p>
    <p>Randomly pick threshold z according to the following density func.on</p>
    <p>Make instance reserva.on decisions based on determinis.c algorithm Az</p>
    <p>Let S = P</p>
    <p>T</p>
    <p>t=1 dtp be the cost of serving all demands with on-demand instances. We bound the cost of OPT as follows:</p>
    <p>COPT = Od(OPT) + nOPT + (S  Od(OPT)) (14)  Od(OPT) + nOPT + nOPT (15)  nOPT/(1  ) . (16)</p>
    <p>Here, (15) holds because in OPT, demands that are served by the same reserved instance incur at least a break-even cost  when priced at an on-demand rate p.</p>
    <p>With (13) and (16), we bound the cost of A</p>
    <p>as follows:</p>
    <p>C</p>
    <p>A = Od(A</p>
    <p>) + n</p>
    <p>+ (S  Od(A</p>
    <p>))</p>
    <p>(1  )Od(A</p>
    <p>) + nOPT + S (17)  (1  )(Od(OPT) + nOPT) + S + nOPT (18) = COPT + nOPT (19)  (2  )COPT . (20)</p>
    <p>Here, (17) holds because n</p>
    <p>nOPT (Lemma 2). Inequality (18) follows from (13), while (20) is derived from (16).</p>
    <p>By Lemma 1, we see that 2 is already the best possible competitive ratio for deterministic online algorithms, which implies that Algorithm 1 is optimal in a view of competitive analysis.</p>
    <p>Proposition 2: Among all online deterministic algorithms of problem (1), Algorithm 1 is optimal with the smallest competitive ratio of 2  .</p>
    <p>As a direct application, in Amazon EC2 with reservation discount  = 0.49 (see Table I), algorithm A</p>
    <p>will lead to no more than 1.51 times the optimal instance purchase cost.</p>
    <p>Despite the already satisfactory cost performance offered by the proposed deterministic algorithm, we show in the next section that the competitive ratio may be further improved if randomness is introduced.</p>
    <p>V. OPTIMAL RANDOMIZED ONLINE STRATEGY</p>
    <p>In this section, we construct a randomized online strategy that is a random distribution over a family of deterministic online algorithms similar to A</p>
    <p>. We show that such randomization improves the competitive ratio to e/(e  1 + ) and hence leads to a better cost performance. As indicated by Lemma 1, this is the best that one can expect without knowledge of future demands.</p>
    <p>We start by defining a family of algorithms similar to the deterministic algorithm A</p>
    <p>. Let A z</p>
    <p>be a similar deterministic algorithm to A</p>
    <p>with  in line 4 of Algorithm 1 replaced by z 2 [0, ]. That is, A</p>
    <p>z</p>
    <p>reserves an instance whenever it sees an on-demand instance incurring more costs than z in the recent reservation period. Intuitively, the value of z reflects the aggressiveness of a reservation strategy. The smaller the z, the more aggressive the strategy. As an extreme, a user will always reserve when z = 0. Another extreme goes to z =  (Algorithm 1), in which the user is very conservative in reserving new instances.</p>
    <p>Our randomized online algorithm picks a z 2 [0, ] according to a density function f(z) and runs the resulting algorithm</p>
    <p>A</p>
    <p>z</p>
    <p>. Specifically, the density function f(z) is defined as</p>
    <p>f(z) =</p>
    <p>(1  )e(1)z/(e  1 + ), z 2 [0, ), (z  )  /(e  1 + ), o.w., (21)</p>
    <p>where () is the Dirac delta function. That is, we pick z =  with probability /(e  1 + ). It is interesting to point out that in other online rent-or-buy problems, e.g., [22], [20], [23], the density function of a randomized algorithm is usually continuous1. However, we note that a continuous density function does not lead to the minimum competitive ratio in our problem. Algorithm 2 formalizes the descriptions above.</p>
    <p>Algorithm 2 Randomized Online Algorithm 1. Randomly pick z 2 [0, ] according to a density function</p>
    <p>f(z) defined by (21) 2. Run A</p>
    <p>z</p>
    <p>The rationale behind Algorithm 2 is to strike a suitable balance between reserving aggressively and conservatively. Intuitively, being aggressive is cost efficient when future demands are long-lasting and stable, while being conservative is efficient for sporadic demands. Given the unknown future, the algorithm randomly chooses a strategy A</p>
    <p>z</p>
    <p>, with an expectation that the incurred cost will closely approach the ex post minimum cost. The following theorem shows that the choice of f(z) in (21) leads to the optimal competitive ratio e/(e  1 + ). The proof is given in [21].</p>
    <p>Proposition 3: Algorithm 2 is e/(e  1 + )-competitive. Formally, for any demand sequence,</p>
    <p>E[C Az</p>
    <p>]  e</p>
    <p>e  1 +  COPT , (22)</p>
    <p>where the expectation is over z between 0 and  according to density function f(z) defined in (21).</p>
    <p>By Lemma 1, we see that no online randomized algorithm is better than Algorithm 2 in terms of the competitive ratio.</p>
    <p>Proposition 4: Among all online randomized algorithms of problem (1), Algorithm 2 is optimal with the smallest competitive ratio e/(e  1 + ).</p>
    <p>As a direct application, in Amazon EC2 with reservation discount  = 0.49 (see Table I), the randomized algorithm will lead to a competitive ratio of 1.23, compared with the 1.51-competitiveness of the deterministic alternative.</p>
    <p>VI. COST MANAGEMENT WITH SHORT-TERM DEMAND PREDICTIONS</p>
    <p>In the previous sections, our discussions focus on the extreme cases, with either full future demand information (i.e., the offline case in Sec. III) or no a priori knowledge of the future (i.e., the online case in Sec. IV and V). In this section, we consider the middle ground in which short-term demand predictions are reliable. For example, websites typically see diurnal patterns exhibited on their workloads, based on which</p>
  </div>
  <div class="page">
    <p>Proposi.on 2: The randomized online algorithm is e/(e-1+)-compe..ve, and hence is op5mal among all online algorithms.</p>
  </div>
  <div class="page">
    <p>Trace-Driven Simula.ons</p>
  </div>
  <div class="page">
    <p>Dataset and Preprocessing</p>
    <p>Google cluster traces  900+ users usage traces in 1 month  We convert users compu.ng demand data to IaaS instance demands</p>
    <p>Time (hour)</p>
    <p>In s ta</p>
    <p>n c e</p>
    <p>User 552</p>
    <p>Fig. 6. The demand curve of User 552 in Google clusterusage traces [17], over 1 month.</p>
    <p>Demand Mean</p>
    <p>D e m</p>
    <p>a n d S</p>
    <p>td !</p>
    <p>= 5  =</p>
    <p>Fig. 7. User demand statistics and group division.</p>
    <p>days in May 2011, on a cluster of more than 11K Google machines.</p>
    <p>Demand Curve: Given the workload traces of each user, we ask the question: How many computing instances would this user require if it were to run the same workload in a public IaaS cloud? For simplicity, we set an instance to have the same computing capacity as a cluster machine, which enables us to accurately estimate the run time of computational tasks by learning from the original traces. We then schedule these tasks onto instances with sufficient resources to accommodate their requirements. Computational tasks that cannot run on the same server in the traces (e.g., tasks of MapReduce) are scheduled to different instances. In the end, we obtain a demand curve for each user, indicating how many instances this user requires in each hour. Fig. 6 illustrates such a demand curve for a user.</p>
    <p>User Classification: To investigate how our online algorithms perform under different demand patterns, we classify all 933 users into three groups by the demand fluctuation level measured as the ratio between the standard deviation  and the mean .</p>
    <p>Specifically, Group 1 consists of users whose demands are highly fluctuating, with /  5. As shown in Fig. 7 (circle o), these demands usually have small means, which implies that they are highly sporadic and are best served with on-demand instances. Group 2 includes users whose demands are less fluctuating, with 1  / &lt; 5. As shown in Fig. 7 (cross x), these demands cannot be simply served by on-demand or reserved instances alone. Group 3 includes all remaining users with relatively stable demands (0  / &lt; 1). As shown in Fig. 7 (plus +), these demands have large means and are best served with reserved instances. Our evaluations are carried out for each user group.</p>
    <p>Pricing: Throughout the simulation, we adopt the pricing of Amazon EC2 standard small instances with the on-demand rate $0.08, the reservation fee $69, and the</p>
    <p>discount rate $0.039 (Linux, US East, 1-year light utilization). Since the Google traces only span one month, we proportionally shorten the on-demand billing cycle from one hour to one minute, and the reservation period from 1 year to 6 days (i.e., 24  365 = 8760 minutes = 6 days) as well.</p>
    <p>Benchmark Online Algorithms: We compare our online deterministic and randomized algorithms with three benchmark online strategies. The first is All-ondemand, in which a user never reserves and operates all workloads with on-demand instances. This algorithm, though simple, is the most common strategy in practice, especially for those users with time-varying workloads [12]. The second algorithm is All-reserved, in which all computational demands are served via reservations. The third online algorithm is the simple extension to the Bahncard algorithm proposed in [20] (see Sec. 2.4), and is referred to as Separate because instances are reserved separately. All three benchmark algorithms, as well as the two proposed online algorithms, are carried out for each user in the Google traces. All the incurred costs are normalized to All-on-demand.</p>
    <p>Cost Performance: We present the simulation results in Fig. 8, where the CDF of the normalized costs are given, grouped by users with different demand fluctuation levels. We see in Fig. 8a that when applied to all 933 users, both the deterministic and randomized online algorithms realize significant cost savings compared with all three benchmarks. In particular, when switching from All-on-demand to the proposed online algorithms, more than 60% users cut their costs. About 50% users save more than 40%. Only 2% incur slightly more costs than before. For users who switch from All-reserved to our randomized online algorithms, the improvement is even more substantial. As shown in Fig. 8a, cost savings are almost guaranteed, with 30% users saving more than 50%. We also note that Separate, though generally outperforms All-on-demand and All-reserved, incurs more costs than our online algorithms, mainly due to its ignorance of reservation correlations.</p>
    <p>We next compare the cost performance of all five algorithms at different demand fluctuation levels. As expected, when it comes to the extreme cases, All-ondemand is the best fit for Group 1 users whose demands are known to be highly busty and sporadic (Fig. 8b), while All-reserved incurs the least cost for Group 3 users with stable workloads (Fig. 8d). These two groups of users, should they know their demand patterns, would have the least incentive to adopt advanced instance reserving strategies, as naively switching to one option is already optimal. However, even in these extreme cases, our online algorithms, especially the randomized one, remain highly competitive, incurring only slightly higher cost.</p>
  </div>
  <div class="page">
    <p>Users are classified into 3 groups based on demand fluctua.on level  Standard devia.on vs. mean in hourly demand</p>
    <p>Time (hour) In</p>
    <p>s ta</p>
    <p>n c e</p>
    <p>User 552</p>
    <p>Fig. 6. The demand curve of User 552 in Google clusterusage traces [17], over 1 month.</p>
    <p>Demand Mean</p>
    <p>D e</p>
    <p>m a</p>
    <p>n d</p>
    <p>S td</p>
    <p>!</p>
    <p>= 5  =</p>
    <p>Fig. 7. User demand statistics and group division.</p>
    <p>days in May 2011, on a cluster of more than 11K Google machines.</p>
    <p>Demand Curve: Given the workload traces of each user, we ask the question: How many computing instances would this user require if it were to run the same workload in a public IaaS cloud? For simplicity, we set an instance to have the same computing capacity as a cluster machine, which enables us to accurately estimate the run time of computational tasks by learning from the original traces. We then schedule these tasks onto instances with sufficient resources to accommodate their requirements. Computational tasks that cannot run on the same server in the traces (e.g., tasks of MapReduce) are scheduled to different instances. In the end, we obtain a demand curve for each user, indicating how many instances this user requires in each hour. Fig. 6 illustrates such a demand curve for a user.</p>
    <p>User Classification: To investigate how our online algorithms perform under different demand patterns, we classify all 933 users into three groups by the demand fluctuation level measured as the ratio between the standard deviation  and the mean .</p>
    <p>Specifically, Group 1 consists of users whose demands are highly fluctuating, with /  5. As shown in Fig. 7 (circle o), these demands usually have small means, which implies that they are highly sporadic and are best served with on-demand instances. Group 2 includes users whose demands are less fluctuating, with 1  / &lt; 5. As shown in Fig. 7 (cross x), these demands cannot be simply served by on-demand or reserved instances alone. Group 3 includes all remaining users with relatively stable demands (0  / &lt; 1). As shown in Fig. 7 (plus +), these demands have large means and are best served with reserved instances. Our evaluations are carried out for each user group.</p>
    <p>Pricing: Throughout the simulation, we adopt the pricing of Amazon EC2 standard small instances with the on-demand rate $0.08, the reservation fee $69, and the</p>
    <p>discount rate $0.039 (Linux, US East, 1-year light utilization). Since the Google traces only span one month, we proportionally shorten the on-demand billing cycle from one hour to one minute, and the reservation period from 1 year to 6 days (i.e., 24  365 = 8760 minutes = 6 days) as well.</p>
    <p>Benchmark Online Algorithms: We compare our online deterministic and randomized algorithms with three benchmark online strategies. The first is All-ondemand, in which a user never reserves and operates all workloads with on-demand instances. This algorithm, though simple, is the most common strategy in practice, especially for those users with time-varying workloads [12]. The second algorithm is All-reserved, in which all computational demands are served via reservations. The third online algorithm is the simple extension to the Bahncard algorithm proposed in [20] (see Sec. 2.4), and is referred to as Separate because instances are reserved separately. All three benchmark algorithms, as well as the two proposed online algorithms, are carried out for each user in the Google traces. All the incurred costs are normalized to All-on-demand.</p>
    <p>Cost Performance: We present the simulation results in Fig. 8, where the CDF of the normalized costs are given, grouped by users with different demand fluctuation levels. We see in Fig. 8a that when applied to all 933 users, both the deterministic and randomized online algorithms realize significant cost savings compared with all three benchmarks. In particular, when switching from All-on-demand to the proposed online algorithms, more than 60% users cut their costs. About 50% users save more than 40%. Only 2% incur slightly more costs than before. For users who switch from All-reserved to our randomized online algorithms, the improvement is even more substantial. As shown in Fig. 8a, cost savings are almost guaranteed, with 30% users saving more than 50%. We also note that Separate, though generally outperforms All-on-demand and All-reserved, incurs more costs than our online algorithms, mainly due to its ignorance of reservation correlations.</p>
    <p>We next compare the cost performance of all five algorithms at different demand fluctuation levels. As expected, when it comes to the extreme cases, All-ondemand is the best fit for Group 1 users whose demands are known to be highly busty and sporadic (Fig. 8b), while All-reserved incurs the least cost for Group 3 users with stable workloads (Fig. 8d). These two groups of users, should they know their demand patterns, would have the least incentive to adopt advanced instance reserving strategies, as naively switching to one option is already optimal. However, even in these extreme cases, our online algorithms, especially the randomized one, remain highly competitive, incurring only slightly higher cost.</p>
  </div>
  <div class="page">
    <p>CDF of Cost Normalized to All-On-Demand</p>
    <p>Separate: stack demands and treat each layer as a virtual user, each individualy solving the Bahncard problem.</p>
    <p>High demand fluctua.on</p>
  </div>
  <div class="page">
    <p>CDF of Cost Normalized to All-On-Demand</p>
    <p>Separate: stack demands and treat each layer as a virtual user, each individually solving the Bahncard problem.</p>
    <p>Low demand fluctua.on</p>
  </div>
  <div class="page">
    <p>CDF of Cost Normalized to All-On-Demand</p>
    <p>Separate: stack demands and treat each layer as a virtual user, each individually solving the Bahncard problem.</p>
    <p>Medium demand fluctua.on</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>Determinis.c and randomized online mul.- instance reserva.on algorithms without future demand informa.on  Op.mal compe..ve ra.o vs. op.mal offline algorithm  Substan.al performance gain over a wide range of demand fluctua.on levels</p>
    <p>Extension to cases where short-term predic.ons are reliable</p>
    <p>Open problem: mul.ple reserva.on op.ons</p>
  </div>
</Presentation>
