<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>APISan: Sanitizing API Usages through</p>
    <p>Semantic Cross-checking</p>
    <p>Insu Yun, Changwoo Min, Xujie Si, Yeongjin Jang, Taesoo Kim, Mayur Naik</p>
    <p>Georgia Institute of Technology</p>
  </div>
  <div class="page">
    <p>APIs in todays software are plentiful yet complex</p>
    <p>Example: OpenSSL - 3841 APIs in [v1.0.2h] - 3718 in [v1.0.1t] -&gt; 3841 in [v1.0.2h] (+123 APIs) - OpenSSH uses 158 APIs of OpenSSL</p>
  </div>
  <div class="page">
    <p>Complex APIs result in programmers mistakes</p>
    <p>Problems in documentation - Incomplete: e.g., low details in hostname verification - Long: e.g., 43K lines in OpenSSL documentation - Lack: e.g., internal APIs</p>
    <p>Lack of automatic tool support - e.g., missing formal specification and precise semantics</p>
  </div>
  <div class="page">
    <p>Problem: API misuse can cause security problems</p>
  </div>
  <div class="page">
    <p>Problem: API misuse can cause security problems</p>
    <p>MITM</p>
  </div>
  <div class="page">
    <p>Problem: API misuse can cause security problems</p>
    <p>Code execution</p>
  </div>
  <div class="page">
    <p>Problem: API misuse can cause security problems</p>
  </div>
  <div class="page">
    <p>Todays practices to help programmers</p>
    <p>Formal method - Problem: lack of specification</p>
    <p>Model checking - Problem: manual, lack of semantic context</p>
    <p>Symbolic execution - Problem : failed to scale for large software</p>
  </div>
  <div class="page">
    <p>Promising approach: finding bugs by using existing code</p>
    <p>Bugs as deviant behavior[OSDI01] - Syntactic template: e.g., check NULL on malloc()</p>
    <p>Juxta[SOSP15] -Inferring correct semantics from multiple of implementations -File system specific bug finding tool</p>
  </div>
  <div class="page">
    <p>Promising approach: finding bugs by using existing code</p>
    <p>Bugs as deviant behavior[OSDI01] - Syntactic template: e.g., check NULL on malloc()</p>
    <p>Juxta[SOSP15] -Inferring correct semantics from multiple of implementations -File system specific bug finding tool</p>
    <p>Research goal: can we apply this method to any kind of software without manual efforts?</p>
  </div>
  <div class="page">
    <p>Our idea: comparing API usages in various implementation</p>
    <p>Example: finding OpenSSL API misuses</p>
    <p>APISan</p>
    <p>Majority uses ( Likely correct )</p>
    <p>Deviant uses ( Likely bug)</p>
    <p>curlcurlcurl nmapcurlnginx nginxcurlnmap nginxcurlhexchat</p>
  </div>
  <div class="page">
    <p>Our idea: comparing API usages in various implementation</p>
    <p>Example: finding OpenSSL API misuses</p>
    <p>APISan</p>
    <p>Majority uses ( Likely correct )</p>
    <p>Deviant uses ( Likely bug)</p>
    <p>curlcurlcurl nmapcurlnginx nginxcurlnmap nginxcurlhexchat</p>
  </div>
  <div class="page">
    <p>Our idea: comparing API usages in various implementation</p>
    <p>Example: finding OpenSSL API misuses</p>
    <p>APISan</p>
    <p>Majority uses ( Likely correct )</p>
    <p>Deviant uses ( Likely bug)</p>
    <p>curlcurlcurl nmapcurlnginx nginxcurlnmap nginxcurlhexchat</p>
  </div>
  <div class="page">
    <p>Our idea: comparing API usages in various implementation</p>
    <p>Example: finding OpenSSL API misuses</p>
    <p>APISan</p>
    <p>Majority uses ( Likely correct )</p>
    <p>Deviant uses ( Likely bug)</p>
    <p>curlcurlcurl nmapcurlnginx nginxcurlnmap nginxcurlhexchat</p>
  </div>
  <div class="page">
    <p>Our approach is very promising</p>
    <p>Effective in finding API misuses -76 new bugs</p>
    <p>Scale to large, complex software -Linux kernel, OpenSSL, PHP, Python, etc. -Debian packages</p>
  </div>
  <div class="page">
    <p>Technical Challenges</p>
    <p>API uses are too different from impl. to impl.</p>
    <p>Subtle semantics of the correct API uses</p>
    <p>Large, complex code using APIs</p>
  </div>
  <div class="page">
    <p>Example: OpenSSL API uses</p>
    <p>SSL_get_verify_result() -Get result of peer certificate verification</p>
    <p>if (SSL_get_verify_result() == X509_V_OK) {  }</p>
  </div>
  <div class="page">
    <p>Example: OpenSSL API uses</p>
    <p>SSL_get_verify_result() -Get result of peer certificate verification -no peer certificate  always returns X509_V_OK</p>
    <p>if (SSL_get_verify_result() == X509_V_OK) {  }</p>
  </div>
  <div class="page">
    <p>Example: OpenSSL API uses</p>
    <p>SSL_get_verify_result() -Get result of peer certificate verification -no peer certificate  always returns X509_V_OK</p>
    <p>if (SSL_get_verify_result() == X509_V_OK &amp;&amp; SSL_get_peer_certificate() != NULL ) {  }</p>
  </div>
  <div class="page">
    <p>Example: a correct implementation using OpenSSL API</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
  </div>
  <div class="page">
    <p>Example: a correct implementation using OpenSSL API</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
  </div>
  <div class="page">
    <p>Example: a correct implementation using OpenSSL API</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
  </div>
  <div class="page">
    <p>Example: a correct implementation using OpenSSL API</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
  </div>
  <div class="page">
    <p>Example: a correct implementation using OpenSSL API</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
  </div>
  <div class="page">
    <p>Example: a correct implementation using OpenSSL API</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
    <p>Semantically same with correct usage</p>
    <p>if (SSL_get_verify_result() == X509_V_OK &amp;&amp; SSL_get_peer_certificate() != NULL ) {  }</p>
  </div>
  <div class="page">
    <p>Example: a correct implementation using OpenSSL API</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
    <p>Correct</p>
  </div>
  <div class="page">
    <p>Example: providing various implementations using OpenSSL</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
    <p>if (SSL_get_verify_result(conn) != X509_V_OK) return NGX_OK;</p>
    <p>cert = SSL_get_peer_certificate(conn); if (cert) {  }</p>
    <p>nginx</p>
    <p>cert = SSL_get_peer_certificate(ssl); if (cert == NULL) return 0;</p>
    <p>if (SSL_get_verify_result(ssl) != X509_V_OK) {}</p>
    <p>nmap</p>
    <p>err = SSL_get_verify_result(ssl); switch(err) { case X509_V_OK: cert = SSL_get_peer_certificate(ssl);</p>
    <p>hexchat</p>
    <p>Correct</p>
  </div>
  <div class="page">
    <p>Example: providing various implementations using OpenSSL</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
    <p>if (SSL_get_verify_result(conn) != X509_V_OK) return NGX_OK;</p>
    <p>cert = SSL_get_peer_certificate(conn); if (cert) {  }</p>
    <p>nginx</p>
    <p>cert = SSL_get_peer_certificate(ssl); if (cert == NULL) return 0;</p>
    <p>if (SSL_get_verify_result(ssl) != X509_V_OK) {}</p>
    <p>nmap</p>
    <p>err = SSL_get_verify_result(ssl); switch(err) { case X509_V_OK: cert = SSL_get_peer_certificate(ssl);</p>
    <p>hexchat</p>
    <p>Correct</p>
  </div>
  <div class="page">
    <p>Example: providing various implementations using OpenSSL</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
    <p>if (SSL_get_verify_result(conn) != X509_V_OK) return NGX_OK;</p>
    <p>cert = SSL_get_peer_certificate(conn); if (cert) {  }</p>
    <p>nginx</p>
    <p>cert = SSL_get_peer_certificate(ssl); if (cert == NULL) return 0;</p>
    <p>if (SSL_get_verify_result(ssl) != X509_V_OK) {}</p>
    <p>nmap</p>
    <p>err = SSL_get_verify_result(ssl); switch(err) { case X509_V_OK: cert = SSL_get_peer_certificate(ssl);</p>
    <p>hexchat</p>
    <p>Correct Correct</p>
  </div>
  <div class="page">
    <p>Example: providing various implementations using OpenSSL</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
    <p>if (SSL_get_verify_result(conn) != X509_V_OK) return NGX_OK;</p>
    <p>cert = SSL_get_peer_certificate(conn); if (cert) {  }</p>
    <p>nginx</p>
    <p>cert = SSL_get_peer_certificate(ssl); if (cert == NULL) return 0;</p>
    <p>if (SSL_get_verify_result(ssl) != X509_V_OK) {}</p>
    <p>nmap</p>
    <p>err = SSL_get_verify_result(ssl); switch(err) { case X509_V_OK: cert = SSL_get_peer_certificate(ssl);</p>
    <p>hexchat</p>
    <p>Correct Correct</p>
  </div>
  <div class="page">
    <p>Example: providing various implementations using OpenSSL</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
    <p>if (SSL_get_verify_result(conn) != X509_V_OK) return NGX_OK;</p>
    <p>cert = SSL_get_peer_certificate(conn); if (cert) {  }</p>
    <p>nginx</p>
    <p>cert = SSL_get_peer_certificate(ssl); if (cert == NULL) return 0;</p>
    <p>if (SSL_get_verify_result(ssl) != X509_V_OK) {}</p>
    <p>nmap</p>
    <p>err = SSL_get_verify_result(ssl); switch(err) { case X509_V_OK: cert = SSL_get_peer_certificate(ssl);</p>
    <p>hexchat</p>
    <p>Correct</p>
    <p>Correct</p>
    <p>Correct</p>
  </div>
  <div class="page">
    <p>Example: providing various implementations using OpenSSL</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
    <p>if (SSL_get_verify_result(conn) != X509_V_OK) return NGX_OK;</p>
    <p>cert = SSL_get_peer_certificate(conn); if (cert) {  }</p>
    <p>nginx</p>
    <p>cert = SSL_get_peer_certificate(ssl); if (cert == NULL) return 0;</p>
    <p>if (SSL_get_verify_result(ssl) != X509_V_OK) {}</p>
    <p>nmap</p>
    <p>err = SSL_get_verify_result(ssl); switch(err) { case X509_V_OK: cert = SSL_get_peer_certificate(ssl);</p>
    <p>hexchat</p>
    <p>Correct</p>
    <p>Correct</p>
    <p>Correct</p>
    <p>// if (cert) is missed</p>
  </div>
  <div class="page">
    <p>Example: providing various implementations using OpenSSL</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
    <p>if (SSL_get_verify_result(conn) != X509_V_OK) return NGX_OK;</p>
    <p>cert = SSL_get_peer_certificate(conn); if (cert) {  }</p>
    <p>nginx</p>
    <p>cert = SSL_get_peer_certificate(ssl); if (cert == NULL) return 0;</p>
    <p>if (SSL_get_verify_result(ssl) != X509_V_OK) {}</p>
    <p>nmap</p>
    <p>err = SSL_get_verify_result(ssl); switch(err) { case X509_V_OK: cert = SSL_get_peer_certificate(ssl);</p>
    <p>hexchat</p>
    <p>Correct</p>
    <p>Correct</p>
    <p>Correct</p>
    <p>Incorrect</p>
    <p>// if (cert) is missed</p>
  </div>
  <div class="page">
    <p>Example: providing various implementations using OpenSSL</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
    <p>if (SSL_get_verify_result(conn) != X509_V_OK) return NGX_OK;</p>
    <p>cert = SSL_get_peer_certificate(conn); if (cert) {  }</p>
    <p>nginx</p>
    <p>cert = SSL_get_peer_certificate(ssl); if (cert == NULL) return 0;</p>
    <p>if (SSL_get_verify_result(ssl) != X509_V_OK) {}</p>
    <p>nmap</p>
    <p>err = SSL_get_verify_result(ssl); switch(err) { case X509_V_OK: cert = SSL_get_peer_certificate(ssl);</p>
    <p>hexchat</p>
    <p>Correct</p>
    <p>Correct</p>
    <p>Correct</p>
    <p>Incorrect</p>
    <p>// if (cert) is missed</p>
    <p>Can we distinguish between correct implementations and buggy implementations?</p>
  </div>
  <div class="page">
    <p>Challenge 1: API usages are different from each other</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
    <p>if (SSL_get_verify_result(conn) != X509_V_OK) return NGX_OK;</p>
    <p>cert = SSL_get_peer_certificate(conn); if (cert) {  }</p>
    <p>nginx</p>
    <p>cert = SSL_get_peer_certificate(ssl); if (cert == NULL) return 0;</p>
    <p>if (SSL_get_verify_result(ssl) != X509_V_OK) {}</p>
    <p>nmap</p>
    <p>err = SSL_get_verify_result(ssl); switch(err) { case X509_V_OK: cert = SSL_get_peer_certificate(ssl);</p>
    <p>hexchat</p>
    <p>// if (cert) is missed</p>
    <p>Correct</p>
    <p>Correct</p>
    <p>Correct</p>
    <p>Incorrect</p>
  </div>
  <div class="page">
    <p>Challenge 2: subtle semantics of the correct API usages</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
    <p>if (SSL_get_verify_result(conn) != X509_V_OK) return NGX_OK;</p>
    <p>cert = SSL_get_peer_certificate(conn); if (cert) {  }</p>
    <p>nginx</p>
    <p>cert = SSL_get_peer_certificate(ssl); if (cert == NULL) return 0;</p>
    <p>if (SSL_get_verify_result(ssl) != X509_V_OK) {}</p>
    <p>nmap</p>
    <p>err = SSL_get_verify_result(ssl); switch(err) { case X509_V_OK: cert = SSL_get_peer_certificate(ssl);</p>
    <p>hexchat</p>
    <p>// if (cert) is missed</p>
    <p>Correct</p>
    <p>Correct</p>
    <p>Correct</p>
    <p>Incorrect</p>
  </div>
  <div class="page">
    <p>Challenge3 : Large, complex code using APIs</p>
    <p>On average, more than 100K LoC -curl : 110K LoC -nginx : 127K LoC -nmap: 169K LoC -hexchat: 61K LoC</p>
    <p>Linux : &gt; 1M LoC</p>
  </div>
  <div class="page">
    <p>Challenge3 : Large, complex code using APIs</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} ... len = BIO_get_mem_data(mem, (char **) &amp;ptr); infof(data, &quot; start date: %.*s\n&quot;, len, ptr); rc = BIO_reset(mem);  err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>curl (simplified)</p>
  </div>
  <div class="page">
    <p>Overview of APISan</p>
    <p>Source codeSource code Source code</p>
  </div>
  <div class="page">
    <p>Overview of APISan</p>
    <p>Source codeSource code Source code</p>
    <p>APIs Arguments</p>
    <p>Constraints</p>
    <p>Symbolic execution database</p>
    <p>Relaxed Symbolic Execution</p>
  </div>
  <div class="page">
    <p>Overview of APISan</p>
    <p>Return value checker</p>
    <p>Argument checker</p>
    <p>Causality checker</p>
    <p>Condition checker</p>
    <p>Source codeSource code Source code</p>
    <p>APIs Arguments</p>
    <p>Constraints</p>
    <p>Symbolic execution database</p>
    <p>Relaxed Symbolic Execution</p>
  </div>
  <div class="page">
    <p>Overview of APISan</p>
    <p>Return value checker</p>
    <p>Argument checker</p>
    <p>Causality checker</p>
    <p>Condition checker</p>
    <p>Source codeSource code Source code</p>
    <p>APIs Arguments</p>
    <p>Constraints</p>
    <p>Symbolic execution database</p>
    <p>Relaxed Symbolic Execution</p>
    <p>: minor, but not bug</p>
    <p>: minor and bug</p>
    <p>Minority uses</p>
  </div>
  <div class="page">
    <p>Overview of APISan</p>
    <p>Return value checker</p>
    <p>Argument checker</p>
    <p>Causality checker</p>
    <p>Condition checker</p>
    <p>Source codeSource code Source code</p>
    <p>APIs Arguments</p>
    <p>Constraints</p>
    <p>Symbolic execution database</p>
    <p>Relaxed Symbolic Execution</p>
    <p>: minor, but not bug</p>
    <p>: minor and bug</p>
    <p>Minority uses</p>
    <p>... Ranked minority uses</p>
  </div>
  <div class="page">
    <p>Overview of APISan</p>
    <p>Return value checker</p>
    <p>Argument checker</p>
    <p>Causality checker</p>
    <p>Condition checker</p>
    <p>Source codeSource code Source code</p>
    <p>APIs Arguments</p>
    <p>Constraints</p>
    <p>Symbolic execution database</p>
    <p>Relaxed Symbolic Execution</p>
    <p>: minor, but not bug</p>
    <p>: minor and bug</p>
    <p>Minority uses</p>
    <p>... Ranked minority uses</p>
  </div>
  <div class="page">
    <p>Symbolic execution can be relaxed in finding API contexts</p>
    <p>Symbolic execution is not scalable -Path explosion -SMT is expensive, naturally NP-complete</p>
    <p>Methods to relax symbolic execution -Limiting inter-procedural analysis -Removing back edges -Range-based</p>
  </div>
  <div class="page">
    <p>Method 1: Limiting inter-procedural analysis</p>
    <p>How APIs are used O How APIs are implemented X</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err != X509_V_OK) {  }</p>
  </div>
  <div class="page">
    <p>Method 2: Removing back edges API contexts can be captured within loops -e.g., malloc() and free() are matched inside a loop</p>
    <p>for() { cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err != X509_V_OK) {  } }</p>
  </div>
  <div class="page">
    <p>Method 3: Range-based Most of arguments &amp; return values are integer</p>
    <p>Clang uses range-based symbolic execution</p>
    <p>cert != NULL  err == X509_V_OK</p>
    <p>cert = {[-MAX, -1] , [1, MAX]} err = {[X509_V_OK, X509_V_OK]}</p>
  </div>
  <div class="page">
    <p>Building per-path symbolic abstractions</p>
    <p>Path-sensitive, context-sensitive</p>
    <p>Record symbolic abstractions -API calls -Symbolic expression of arguments -Constraints</p>
  </div>
  <div class="page">
    <p>Examples: Building per-path symbolic abstractions from source code</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>Source code</p>
    <p>Symbolic abstractions</p>
  </div>
  <div class="page">
    <p>Examples: Building per-path symbolic abstractions from source code</p>
    <p>Call SSL_get_peer_certificate(handle) cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>Source code</p>
    <p>Symbolic abstractions</p>
  </div>
  <div class="page">
    <p>Examples: Building per-path symbolic abstractions from source code</p>
    <p>Call SSL_get_peer_certificate(handle)</p>
    <p>Constraint SSL_get_peer_certificate(handle)</p>
    <p>= {[-MAX, -1], [1, MAX]}</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>Source code</p>
    <p>Symbolic abstractions</p>
  </div>
  <div class="page">
    <p>Examples: Building per-path symbolic abstractions from source code</p>
    <p>Call SSL_get_peer_certificate(handle)</p>
    <p>Constraint SSL_get_peer_certificate(handle)</p>
    <p>= {[-MAX, -1], [1, MAX]}</p>
    <p>Call SSL_get_verify_result(handle)</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>Source code</p>
    <p>Symbolic abstractions</p>
  </div>
  <div class="page">
    <p>Examples: Building per-path symbolic abstractions from source code</p>
    <p>Call SSL_get_peer_certificate(handle)</p>
    <p>Constraint SSL_get_peer_certificate(handle)</p>
    <p>= {[-MAX, -1], [1, MAX]}</p>
    <p>Call SSL_get_verify_result(handle)</p>
    <p>Constraint SSL_get_verify_result(handle) = {[X509_V_OK, X509_V_OK]}</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>Source code</p>
    <p>Symbolic abstractions</p>
  </div>
  <div class="page">
    <p>Examples: Building per-path symbolic abstractions from source code</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>Source code</p>
  </div>
  <div class="page">
    <p>Examples: Building per-path symbolic abstractions from source code</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>Source code</p>
    <p>Symbolic Abstractions #1</p>
  </div>
  <div class="page">
    <p>Examples: Building per-path symbolic abstractions from source code</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>Source code</p>
    <p>Symbolic Abstractions #1</p>
    <p>Symbolic Abstractions #2</p>
  </div>
  <div class="page">
    <p>Examples: Building per-path symbolic abstractions from source code</p>
    <p>cert = SSL_get_peer_certificate(handle); if (!cert) {} err = SSL_get_verify_result(handle); if (err == X509_V_OK) {  }</p>
    <p>Source code</p>
    <p>Symbolic Abstractions #1</p>
    <p>.</p>
    <p>Symbolic Abstractions #2</p>
    <p>Symbolic Abstractions #3</p>
  </div>
  <div class="page">
    <p>Overview of APISan</p>
    <p>Return value checker</p>
    <p>Argument checker</p>
    <p>Causality checker</p>
    <p>Condition checker</p>
    <p>Source codeSource code Source code</p>
    <p>APIs Arguments</p>
    <p>Constraints</p>
    <p>Symbolic execution database</p>
    <p>Relaxed Symbolic Execution</p>
    <p>: minor, but not bug</p>
    <p>: minor and bug</p>
    <p>Minority uses</p>
    <p>... Ranked minority uses</p>
  </div>
  <div class="page">
    <p>Four semantic contexts have security implications</p>
    <p>Orthogonal, essential, security-related contexts -Return value -Arguments -Causality -Condition</p>
  </div>
  <div class="page">
    <p>Context 1: Return value</p>
    <p>Return computation result or execution status</p>
    <p>NULL dereference Privilege escalation -e.g, Windows, CVE-2014-4113</p>
    <p>ptr = malloc(size) if (!ptr){  }</p>
  </div>
  <div class="page">
    <p>Context 2: Arguments</p>
    <p>Inputs for calling APIs and their relationship</p>
    <p>Format string bug Memory corruption</p>
    <p>printf(buf);</p>
    <p>ptr = malloc(size1); memcpy(ptr, src, size2);</p>
  </div>
  <div class="page">
    <p>Context 3: Causality</p>
    <p>Causal relationship between APIs</p>
    <p>Deadlock Memory leak</p>
    <p>lock(); unlock();</p>
    <p>malloc(); free();</p>
  </div>
  <div class="page">
    <p>Context 4: Condition</p>
    <p>Implicit pre- and post condition for calling APIs</p>
    <p>MITM</p>
    <p>if (SSL_get_verify_result() == X509_V_OK &amp;&amp; SSL_get_peer_certificate() != NULL)</p>
  </div>
  <div class="page">
    <p>Extract contexts from symbolic abstractions</p>
    <p>Symbolic abstractions contains {APIs, Arguments, Constraints}</p>
    <p>Return value  Constraints Arguments  Arguments Causality  APIs Condition  Constraints + APIs</p>
  </div>
  <div class="page">
    <p>Extract contexts from symbolic abstractions</p>
    <p>Symbolic abstractions contains {APIs, Arguments, Constraints}</p>
    <p>Return value  Constraints Arguments  Arguments Causality  APIs Condition  Constraints + APIs</p>
  </div>
  <div class="page">
    <p>Example: extract condition contexts from symbolic abstractions</p>
    <p>Call SSL_get_peer_certificate(handle)</p>
    <p>Constraint SSL_get_peer_certificate(handle)</p>
    <p>= {[-MAX, -1], [1, MAX]}</p>
    <p>Call SSL_get_verify_result(handle)</p>
    <p>Constraint SSL_get_verify_result(handle) = {[X509_V_OK, X509_V_OK]}</p>
    <p>curl</p>
    <p>Event Line</p>
    <p>SSL_get_verify_result = {[X509_V_OK, X509_V_OK]}</p>
    <p>{curl}</p>
    <p>Constraint Line</p>
    <p>SSL_get_peer_certificate = {[-MAX, -1], [1, MAX]}</p>
    <p>{curl}</p>
    <p>.</p>
    <p>Any constraint or call</p>
    <p>Line numbers when event is called</p>
  </div>
  <div class="page">
    <p>Example: extract condition contexts from symbolic abstractions</p>
    <p>Event Line</p>
    <p>SSL_get_verify_result = {[X509_V_OK, X509_V_OK]}</p>
    <p>{curl, nginx}</p>
    <p>Constraint Line</p>
    <p>SSL_get_peer_certificate = {[-MAX, -1], [1, MAX]}</p>
    <p>{curl, nginx}</p>
    <p>.</p>
    <p>Call SSL_get_verify_result(conn)</p>
    <p>Constraint SSL_get_verify_result(handle) == {[X509_V_OK, X509_V_OK]}</p>
    <p>Call SSL_get_peer_certificate(conn)</p>
    <p>Constraint SSL_get_peer_certificate(conn)</p>
    <p>!= {[-MAX, -1], [1, MAX]}</p>
    <p>nginx</p>
  </div>
  <div class="page">
    <p>Example: extract condition contexts from symbolic abstractions</p>
    <p>Call SSL_get_peer_certificate(ssl)</p>
    <p>Constraint SSL_get_peer_certificate(ssl)</p>
    <p>= {[-MAX, -1], [1, MAX]}</p>
    <p>Call SSL_get_verify_result(ssl)</p>
    <p>Constraint SSL_get_verify_result(ssl)</p>
    <p>= {[X509_V_OK, X509_V_OK]}</p>
    <p>nmap</p>
    <p>Event Line</p>
    <p>SSL_get_verify_result = {[X509_V_OK, X509_V_OK]}</p>
    <p>{curl, nginx, nmap}</p>
    <p>Constraint Line</p>
    <p>SSL_get_peer_certificate = {[-MAX, -1], [1, MAX]}</p>
    <p>{curl, nginx, nmap}</p>
    <p>.</p>
  </div>
  <div class="page">
    <p>Example: extract condition contexts from symbolic abstractions</p>
    <p>Call SSL_get_verify_result(ssl)</p>
    <p>Constraint SSL_get_verify_result(ssl)</p>
    <p>= {[X509_V_OK, X509_V_OK]}</p>
    <p>Call SSL_get_peer_certificate(ssl)</p>
    <p>hexchat</p>
    <p>Event Line</p>
    <p>SSL_get_verify_result = {[X509_V_OK, X509_V_OK]}</p>
    <p>{curl, nginx, nmap, hexchat}</p>
    <p>Constraint Line</p>
    <p>SSL_get_peer_certificate = {[-MAX, -1], [1, MAX]}</p>
    <p>{curl, nginx, nmap}</p>
    <p>.</p>
  </div>
  <div class="page">
    <p>Example: find majority &amp; minority usages from contexts</p>
    <p>Event Line</p>
    <p>SSL_get_verify_result = {[X509_V_OK, X509_V_OK]}</p>
    <p>{curl, nginx, nmap, hexchat, }</p>
    <p>Constraint Line</p>
    <p>SSL_get_peer_certificate = {[-MAX, -1], [1, MAX]}</p>
    <p>{curl, nginx, nmap, }</p>
    <p>.</p>
  </div>
  <div class="page">
    <p>Example: find majority &amp; minority usages from contexts</p>
    <p>Event Line</p>
    <p>SSL_get_verify_result = {[X509_V_OK, X509_V_OK]}</p>
    <p>{curl, nginx, nmap, hexchat, }</p>
    <p>Constraint Line</p>
    <p>SSL_get_peer_certificate = {[-MAX, -1], [1, MAX]}</p>
    <p>{curl, nginx, nmap, }</p>
    <p>.</p>
    <p>Majority uses ( Likely correct )</p>
  </div>
  <div class="page">
    <p>Example: find majority &amp; minority usages from contexts</p>
    <p>Event Line</p>
    <p>SSL_get_verify_result = {[X509_V_OK, X509_V_OK]}</p>
    <p>{curl, nginx, nmap, hexchat, }</p>
    <p>Constraint Line</p>
    <p>SSL_get_peer_certificate = {[-MAX, -1], [1, MAX]}</p>
    <p>{curl, nginx, nmap, }</p>
    <p>.</p>
    <p>Majority uses ( Likely correct )</p>
    <p>Deviant uses ( Likely bug) = total_event  majority_use = {hexchat, }</p>
  </div>
  <div class="page">
    <p>Overview of APISan</p>
    <p>Return value checker</p>
    <p>Argument checker</p>
    <p>Causality checker</p>
    <p>Condition checker</p>
    <p>Source codeSource code Source code</p>
    <p>APIs Arguments</p>
    <p>Constraints</p>
    <p>Symbolic execution database</p>
    <p>Relaxed Symbolic Execution</p>
    <p>: minor, but not bug</p>
    <p>: minor and bug</p>
    <p>Minority uses</p>
    <p>... Ranked minority uses</p>
  </div>
  <div class="page">
    <p>False positives can be happened in majority analysis</p>
    <p>Lack of inter-procedural analysis -e.g., check a return value of malloc() inside a function</p>
    <p>Correlation  Causation -e.g., fprintf() is used for printing debug messages when open() is failed</p>
    <p>Correct minor uses -e.g., strcmp() == 0, strcmp() &gt; 0</p>
  </div>
  <div class="page">
    <p>Ranking can mitigate false positives</p>
    <p>More majority pattern repeated, more bug-likely -e.g., 999 majority, 1 minority &gt; 10 majority, 1 minority</p>
    <p>General information -e.g., most of allocation functions have alloc in their names and are required to check their return values</p>
    <p>Domain specific knowledge -e.g., SSL APIs start with a string SSL</p>
  </div>
  <div class="page">
    <p>Our approach is formalized as a general framework</p>
  </div>
  <div class="page">
    <p>Implementation of APISan</p>
    <p>9K LoC in total -Symbolic database generation : 6K LoC of C/C++ (Clang 3.6) -APISan library : 2K LoC of Python</p>
    <p>Checkers : 1K LoC of Python -Return value checker : 131 LoC -Argument checker : 251 LoC -</p>
  </div>
  <div class="page">
    <p>Evaluation questions</p>
    <p>How effective is APISan in finding new bugs?</p>
    <p>How easy to use and easy to extend?</p>
    <p>How effective is APISans ranking system?</p>
  </div>
  <div class="page">
    <p>APISan is effective in finding bugs</p>
    <p>Found 76 new bugs in large, complex software -Linux kernel, OpenSSL, PHP, Python, and Debian packages</p>
    <p>Security implication -e.g., CVE-2016-5636: Python zipimporter heap overflow (Code execution in Google App Engine)</p>
  </div>
  <div class="page">
    <p>APISan is easy to use without any manual annotation</p>
    <p>To generate symbolic context database $ apisan make # use existing build command</p>
    <p>Run a checker $ apisan --checker=cpair # cpair : causality checker</p>
    <p>Run a checker (inter-application) $apisan --checker=cpair --db=app1, app2</p>
  </div>
  <div class="page">
    <p>APISan is easy to extend</p>
    <p>e.g., Integer overflow check Integer overflow sensitive APIs -Have security implications when integer overflow happens -e.g., memory allocation functions</p>
    <p>Integer overflow  Arguments + Constraints -If arguments contains binary operators  check integer overflow within given constraints</p>
  </div>
  <div class="page">
    <p>Check integer overflow with APISan</p>
    <p>Collect all integer overflows Ranking strategy -More integer overflow prevented by constraints  APIs are likely integer overflow sensitive</p>
    <p>-Incorrect constraints &gt; Missing constraints ; Missing constraints can be caused by limited analysis</p>
    <p>Found 6 integer overflows (167 LoC)</p>
  </div>
  <div class="page">
    <p>APISans ranking system is effective</p>
    <p>Linux Kernel with Return Value Checker</p>
    <p>Total 2,776 reports  Audited 445 reports  Found 54 bugs</p>
  </div>
  <div class="page">
    <p>APISans ranking system is effective</p>
    <p>Linux Kernel with Return Value Checker</p>
    <p>Total 2,776 reports  Audited 445 reports  Found 54 bugs</p>
  </div>
  <div class="page">
    <p>APISans ranking system is effective</p>
    <p>Linux Kernel with Return Value Checker</p>
    <p>Total 2,776 reports  Audited 445 reports  Found 54 bugs</p>
  </div>
  <div class="page">
    <p>Limitation No soundness &amp; No completeness High false positive rate : &gt; 80% Too slow to frequently analyze -32-core Xeon server with 256GB RAM -For Linux kernel,</p>
    <p>Generating database : 8 hours Each checker: 6 hours</p>
    <p>Not fully resolve path explosion -stopped in functions which have path explosion</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>APISan: an automatic way for finding API misuse -Effective: Finding 76 new bugs -Scalable: Tested with Linux kernel, Debian packages, etc</p>
    <p>APISan *WILL* be released as open source -https://github.com/sslab-gatech</p>
  </div>
  <div class="page">
    <p>Thank you!</p>
    <p>Questions?</p>
  </div>
</Presentation>
