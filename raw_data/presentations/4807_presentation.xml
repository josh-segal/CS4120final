<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>(C) 2004 Daniel Sorin Duke Architecture</p>
    <p>Using Speculation to Simplify Multiprocessor Design</p>
    <p>Daniel J. Sorin1, Milo M. K. Martin2, Mark D. Hill3, David A. Wood3</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 2</p>
    <p>My Talk in One Slide</p>
    <p>Shared memory multiprocessors are complicated  Difficult to design for every possible corner case</p>
    <p>Proposal: Use speculation to target the common case  Speculate that corner cases wont happen</p>
    <p>Detect if they do occur and recover system  Ensure forward progress</p>
    <p>Case studies  Simplify cache coherence protocols</p>
    <p>Simplify the interconnection network</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 3</p>
    <p>Speculation for Simplicity</p>
    <p>Why we want to avoid complexity  Time and money for design and verification</p>
    <p>Design for the common case  But we have to make ALL cases work correctly</p>
    <p>Examples of this philosophy in uniprocessors  Trapping to software for infrequent/obsolescent instructions  Pentium4 recovers from edge case scheduler deadlocks</p>
    <p>But this idea hadnt been used for multiprocessors  Key: we now have efficient multiprocessor recovery</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 4</p>
    <p>Framework for Speculation</p>
    <p>Four keys to design simplification with speculation</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 5</p>
    <p>SafetyNet Checkpoint/Recovery</p>
    <p>We use SafetyNet [ISCA 2002] for system recovery  All-hardware checkpoint/recovery for shared memory</p>
    <p>multiprocessors  Periodically, takes logical checkpoints of system</p>
    <p>Including caches, coherence state, memory, directory state</p>
    <p>Implements checkpointing with incremental logging</p>
    <p>Consistent checkpoints using logical time coordination</p>
    <p>Can recover 100,000+ cycles  Negligible performance impact</p>
    <p>Incremental logging performed off critical path</p>
    <p>Small log buffers (512 KB) at caches &amp; memories</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 6</p>
    <p>The Need for Multiprocessor Recovery</p>
    <p>Assumption: multiprocessors will have system-wide recovery mechanisms for purposes of availability  As fault rates keep increasing, recovery is crucial</p>
    <p>Will be all-hardware (like SafetyNet) for performance  But many alternative designs are possible</p>
    <p>We leverage this recovery mechanism for recovering from mis-speculations</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 7</p>
    <p>Outline</p>
    <p>A Framework for Speculation</p>
    <p>Simplifying Cache Coherence Protocols</p>
    <p>Simplifying the Interconnection Network</p>
    <p>Evaluation</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 8</p>
    <p>Directory Protocol Complexity</p>
    <p>We want adaptive routing in interconnection network  Better performance and availability</p>
    <p>But adaptive routing precludes point-to-point ordering</p>
    <p>So what?  Point-to-point ordering simplifies protocol design</p>
    <p>Eliminates several potential corner case races</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 9</p>
    <p>Race Case in Directory Protocol</p>
    <p>Example race if no point-to-point ordering in network</p>
    <p>P1</p>
    <p>Dir</p>
    <p>P2</p>
    <p>RequestReadWrite</p>
    <p>Writeback</p>
    <p>RequestReadWrite arrives first at Dir, gets forwarded to P1</p>
    <p>Forwarded RequestReadWrite</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 10</p>
    <p>Race Case in Directory Protocol</p>
    <p>P1</p>
    <p>Dir</p>
    <p>P2</p>
    <p>RequestReadWrite</p>
    <p>Forwarded RequestReadWrite</p>
    <p>Writeback Ack Writeback</p>
    <p>Forwarded RequestReadWrite arrives after Writeback Ack</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 11</p>
    <p>Race Case in Directory Protocol</p>
    <p>Problem: P1 sees Forwarded Request in state Invalid</p>
    <p>P1</p>
    <p>Dir</p>
    <p>P2</p>
    <p>RequestReadWrite</p>
    <p>Forwarded RequestReadWrite</p>
    <p>Writeback Ack Writeback</p>
    <p>Not possible if point-to-point order in interconnection network</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 12</p>
    <p>Simplifying a Directory Protocol</p>
    <p>Speculate that adaptive network provides ordering</p>
    <p>Guarantees that this race cant keep recurring</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 13</p>
    <p>Simplifying a Snooping Coherence Protocol</p>
    <p>During design, we missed a corner case</p>
    <p>State M</p>
    <p>State trans1</p>
    <p>Writeback State trans2</p>
    <p>Request ReadWrite</p>
    <p>Request ReadWrite</p>
    <p>Solution: its rare, treat it as mis-speculation  Detect by seeing RequestReadWrite in state trans2  Recovery with SafetyNet</p>
    <p>Forward progress with slow-start after recovery</p>
    <p>???</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 14</p>
    <p>Outline</p>
    <p>A Framework for Speculation</p>
    <p>Simplifying Cache Coherence Protocols</p>
    <p>Simplifying the Interconnection Network  Deadlock</p>
    <p>Avoiding deadlock</p>
    <p>Evaluation</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 15</p>
    <p>Two Causes of Deadlock</p>
    <p>P1</p>
    <p>P2</p>
    <p>Response</p>
    <p>full of requests</p>
    <p>full of requests</p>
    <p>Response</p>
    <p>Message M1</p>
    <p>full of messages</p>
    <p>full of messages</p>
    <p>Message M2</p>
    <p>Endpoint</p>
    <p>Deadlock</p>
    <p>Switch</p>
    <p>Deadlock</p>
    <p>switch1</p>
    <p>switch2</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 16</p>
    <p>Avoiding Deadlock</p>
    <p>Simple but wasteful solution: full buffering  But its rare that we ever need full buffering</p>
    <p>More efficient solution: virtual channels (networks)</p>
    <p>For endpoint deadlock  Need a virtual network per type of message</p>
    <p>For switch deadlock  Need some number of virtual channels per virtual network</p>
    <p>Depends on network topology and routing scheme</p>
    <p>A major source of design complexity</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 17</p>
    <p>Simplifying Deadlock Avoidance</p>
    <p>Speculate that deadlock wont occur, despite using less than full buffering and no virtual channels</p>
    <p>Guarantees that deadlock cant keep recurring</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 18</p>
    <p>Outline</p>
    <p>A Framework for Speculation</p>
    <p>Simplifying Cache Coherence Protocols</p>
    <p>Simplifying the Interconnection Network</p>
    <p>Evaluation  Goals</p>
    <p>Methodology  Results</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 19</p>
    <p>Goals</p>
    <p>Discover the point at which mis-speculation recoveries impact performance  Determines whether our simplified snooping protocol and</p>
    <p>our simplified interconnection network are viable</p>
    <p>Determine whether our simplified directory protocol can usefully speculate on point-to-point ordering</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 20</p>
    <p>Methodology</p>
    <p>Full-system simulation  Simics provides full-system functionality</p>
    <p>We added detailed timing model for memory system</p>
    <p>Workloads  Online transaction processing (OLTP) with DB2  SPECjbb2000 java middleware</p>
    <p>Apache static web serving</p>
    <p>Slashcode dynamic web serving  Barnes-Hut scientific simulation</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 21</p>
    <p>How Rare Must Mis-speculation Be?</p>
    <p>We can tolerate high mis-speculation rates  these rates are much higher than what our simplified designs incur</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 22</p>
    <p>Adaptive Routing with Speculative Ordering</p>
    <p>Adaptive routing can provide better performance by routing around congestion, even with mis-speculations</p>
  </div>
  <div class="page">
    <p>IPDPS 2004  Daniel Sorinslide 23</p>
    <p>Conclusions</p>
    <p>Simplify multiprocessor design with speculation  Treat corner cases as mis-speculations &amp; recover from them</p>
    <p>Must be able to ensure that  Mis-speculations are sufficiently rare</p>
    <p>Can detect all mis-speculations</p>
    <p>Can recover from mis-speculations  Can provide forward progress in all cases</p>
    <p>Showed how to simplify  Cache coherence protocols</p>
    <p>Interconnection network deadlock avoidance</p>
    <p>Applicable to other complicated designs</p>
  </div>
</Presentation>
