<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>CellIQ: Real-Time Cellular Network Analytics at Scale</p>
    <p>Anand Iyer#, Li Erran Li+, Ion Stoica# #UC Berkeley +Bell Labs</p>
  </div>
  <div class="page">
    <p>Cellular Networks have been seeing exponential growth and become part of our lives</p>
  </div>
  <div class="page">
    <p>Image courtesy: Alcatel-Lucent</p>
  </div>
  <div class="page">
    <p>What is needed to solve these issues?</p>
    <p>Are some regions in the network hotspots? - Better load balancing</p>
    <p>How is user traffic moving in the network? - Better resource provisioning</p>
    <p>What are the popular handoff sequences? - Troubleshoot handoff related problems</p>
  </div>
  <div class="page">
    <p>Cellular Network Analytics Today</p>
  </div>
  <div class="page">
    <p>Cellular Network Analytics Today</p>
  </div>
  <div class="page">
    <p>Cellular Network Analytics Today</p>
  </div>
  <div class="page">
    <p>Problem</p>
    <p>Existing cellular network analytic systems do not</p>
    <p>support advanced analytic tasks in an efficient manner.</p>
  </div>
  <div class="page">
    <p>High Velocity Data Continuous Monitoring</p>
    <p>Advanced Tasks</p>
    <p>Timely Spatio-Temporal Analysis</p>
    <p>Challenges</p>
  </div>
  <div class="page">
    <p>CellIQ is a cellular network analytics system that supports rich analysis</p>
    <p>tasks efficiently by leveraging domain-specific optimizations</p>
  </div>
  <div class="page">
    <p>Cellular Data as Time-Evolving Graphs</p>
    <p>Tasks easily expressed in graphs: Hotspot computation  Connected components</p>
    <p>Handoff sequences &amp; User traffic  Pregel model</p>
    <p>Edge Property Vertex Property</p>
    <p>BS1</p>
    <p>UE2</p>
    <p>UE1 BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
  </div>
  <div class="page">
    <p>Why Not Use a Graph Parallel Framework?</p>
    <p>Fails to produce results!</p>
    <p>Domain specific optimizations key for efficient analysis</p>
  </div>
  <div class="page">
    <p>CellIQ Implementation</p>
    <p>*Gonzales. et.al. GraphX: Graph Processing in a Distributed Dataflow Framework, OSDI 2014</p>
    <p>Implemented as a layer on GraphX* Incorporates several domain specific optimizations</p>
    <p>GraphX</p>
    <p>Spark</p>
    <p>Pregel API</p>
    <p>PageRank Connected Comp. K-core Triangle Count</p>
    <p>LDA SVD++</p>
    <p>CellIQ</p>
  </div>
  <div class="page">
    <p>Computational Model</p>
    <p>BS1UE2</p>
    <p>UE1</p>
    <p>BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
  </div>
  <div class="page">
    <p>Computational Model</p>
    <p>BS1UE2</p>
    <p>UE1</p>
    <p>BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
    <p>BS1 UE2</p>
    <p>UE1</p>
    <p>BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
  </div>
  <div class="page">
    <p>Computational Model</p>
    <p>BS1UE2</p>
    <p>UE1</p>
    <p>BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
    <p>BS1 UE2</p>
    <p>UE1</p>
    <p>BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
    <p>BS1</p>
    <p>UE2</p>
    <p>UE1 BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
  </div>
  <div class="page">
    <p>Computational Model: GStreams</p>
    <p>BS1UE2</p>
    <p>UE1</p>
    <p>BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
    <p>BS1 UE2</p>
    <p>UE1</p>
    <p>BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
    <p>BS1</p>
    <p>UE2</p>
    <p>UE1 BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
    <p>Domain specific graph partitioning Spatial operations</p>
    <p>Window operations</p>
  </div>
  <div class="page">
    <p>Computational Model: GStreams</p>
    <p>BS1UE2</p>
    <p>UE1</p>
    <p>BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
    <p>BS1 UE2</p>
    <p>UE1</p>
    <p>BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
    <p>BS1</p>
    <p>UE2</p>
    <p>UE1 BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
    <p>Domain specific graph partitioning Spatial operations</p>
    <p>Window operations</p>
  </div>
  <div class="page">
    <p>Graph computation frameworks rely on partitioning to minimize communication &amp; balance computation</p>
    <p>B C</p>
    <p>A D</p>
    <p>F E</p>
    <p>A DD</p>
    <p>B C</p>
    <p>D</p>
    <p>E</p>
    <p>AA</p>
    <p>F Machine 1 Machine 2</p>
    <p>A</p>
    <p>B</p>
    <p>C</p>
    <p>D</p>
    <p>E</p>
    <p>F</p>
    <p>Graph Partitioning</p>
  </div>
  <div class="page">
    <p>Partition geographically close-by entities</p>
    <p>Machine 3 Machine 4</p>
    <p>B CB C</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>Machine 1 Machine 2</p>
    <p>CellIQ Graph Partitioning</p>
    <p>G H</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>B CB C</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>Machine 1 Machine 2</p>
    <p>A B</p>
    <p>C D</p>
    <p>E F</p>
    <p>Graph Partitioning</p>
    <p>G H G</p>
    <p>H</p>
    <p>Random (hashed) partitioning</p>
  </div>
  <div class="page">
    <p>B CB C</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>Machine 1 Machine 2</p>
    <p>A B</p>
    <p>C D</p>
    <p>E F</p>
    <p>Graph Partitioning</p>
    <p>G H G</p>
    <p>H</p>
    <p>Random (hashed) partitioning results in poor spatial locality</p>
  </div>
  <div class="page">
    <p>Machine 3 Machine 4</p>
    <p>B CB C</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>Machine 1 Machine 2</p>
    <p>CellIQ Graph Partitioning</p>
    <p>G H</p>
    <p>Uses Hilbert space-filling curves</p>
  </div>
  <div class="page">
    <p>Machine 3 Machine 4</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>Machine 1 Machine 2</p>
    <p>CellIQ Graph Partitioning</p>
    <p>G H</p>
    <p>Uses Hilbert space-filling curves Use curves distance as the 1-dimensional key</p>
  </div>
  <div class="page">
    <p>Machine 3 Machine 4</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>Machine 1 Machine 2</p>
    <p>A B C</p>
    <p>D</p>
    <p>EF</p>
    <p>CellIQ Graph Partitioning</p>
    <p>G H G H</p>
    <p>Uses Hilbert space-filling curves Use curves distance as the 1-dimensional key Range partition the key space</p>
  </div>
  <div class="page">
    <p>Machine 3 Machine 4</p>
    <p>B CB C</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>Machine 1 Machine 2</p>
    <p>A B C</p>
    <p>D</p>
    <p>EF</p>
    <p>CellIQ Graph Partitioning</p>
    <p>G H G H</p>
    <p>Uses Hilbert space-filling curves Use curves distance as the 1-dimensional key Range partition the key space</p>
  </div>
  <div class="page">
    <p>Computational Model: GStreams</p>
    <p>BS1UE2</p>
    <p>UE1</p>
    <p>BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
    <p>BS1 UE2</p>
    <p>UE1</p>
    <p>BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
    <p>BS1</p>
    <p>UE2</p>
    <p>UE1 BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
    <p>Domain specific graph partitioning Spatial operations Window operations</p>
  </div>
  <div class="page">
    <p>GeoGraph API</p>
    <p>class GeoGraph[V, E] { // Broadcast a message to all // vertices within a radius def sendMsg(radius) // Create a spatially aggregated // graph by combining vertices // and edges def spatialAG(reduceV: (V, V) =&gt; V, reduceE: (E, E) =&gt; E) }</p>
  </div>
  <div class="page">
    <p>Tracking user traffic gradients</p>
    <p>Goal: Detect and track direction of movement of user groups</p>
  </div>
  <div class="page">
    <p>B C</p>
    <p>A D</p>
    <p>F</p>
    <p>E</p>
    <p>A DD</p>
    <p>B C</p>
    <p>D</p>
    <p>E</p>
    <p>AA</p>
    <p>F</p>
    <p>Tracking user traffic gradients</p>
    <p>Base Station</p>
  </div>
  <div class="page">
    <p>B C</p>
    <p>A D</p>
    <p>F</p>
    <p>E</p>
    <p>A DD</p>
    <p>B C</p>
    <p>D</p>
    <p>E</p>
    <p>AA</p>
    <p>F</p>
    <p>Tracking user traffic gradients</p>
  </div>
  <div class="page">
    <p>B C</p>
    <p>A D</p>
    <p>F</p>
    <p>E</p>
    <p>A DD</p>
    <p>B C</p>
    <p>D</p>
    <p>E</p>
    <p>AA</p>
    <p>F</p>
    <p>Hop-by-hop propagation</p>
    <p>Tracking user traffic gradients</p>
  </div>
  <div class="page">
    <p>B C</p>
    <p>A D</p>
    <p>F</p>
    <p>E</p>
    <p>A DD</p>
    <p>B C</p>
    <p>D</p>
    <p>E</p>
    <p>AA</p>
    <p>F</p>
    <p>Hop-by-hop propagation is inefficient</p>
    <p>Tracking user traffic gradients</p>
  </div>
  <div class="page">
    <p>Tracking user traffic gradients</p>
    <p>B C</p>
    <p>A D</p>
    <p>F</p>
    <p>E</p>
    <p>A DD</p>
    <p>B C</p>
    <p>D</p>
    <p>E</p>
    <p>AA</p>
    <p>F</p>
    <p>Instead, CellIQ enables radius based broadcast</p>
  </div>
  <div class="page">
    <p>Part. 2</p>
    <p>Part. 1</p>
    <p>Vertex Table (RDD)</p>
    <p>B C</p>
    <p>A D</p>
    <p>F E</p>
    <p>A D</p>
    <p>Routing Table in GraphX enables Multicast</p>
    <p>D</p>
    <p>B C</p>
    <p>D</p>
    <p>E</p>
    <p>AA</p>
    <p>F</p>
    <p>M achine 1</p>
    <p>M achine 2</p>
    <p>Edge Table (RDD)</p>
    <p>A B</p>
    <p>A C</p>
    <p>C D</p>
    <p>B C</p>
    <p>A E</p>
    <p>A F</p>
    <p>E F</p>
    <p>E D</p>
    <p>B</p>
    <p>C</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>Routing Table</p>
    <p>(RDD)</p>
    <p>B</p>
    <p>C</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>Slide courtesy: Joey Gonzales</p>
  </div>
  <div class="page">
    <p>Routing Table</p>
    <p>(RDD)</p>
    <p>B</p>
    <p>C</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F</p>
    <p>Part. 1</p>
    <p>Vertex Table (RDD)</p>
    <p>B C</p>
    <p>A D</p>
    <p>F E</p>
    <p>A DD</p>
    <p>B C</p>
    <p>D</p>
    <p>E</p>
    <p>AA</p>
    <p>F</p>
    <p>M achine 1</p>
    <p>M achine 2</p>
    <p>Edge Table (RDD)</p>
    <p>A B</p>
    <p>A C</p>
    <p>C D</p>
    <p>B C</p>
    <p>A E</p>
    <p>A F</p>
    <p>E F</p>
    <p>E D</p>
    <p>B</p>
    <p>C</p>
    <p>D</p>
    <p>E</p>
    <p>A</p>
    <p>F Slide courtesy: Joey Gonzales</p>
    <p>Can compute destination partitions easily due to the use of geo-partitioner</p>
  </div>
  <div class="page">
    <p>GeoGraph API</p>
    <p>class GeoGraph[V, E] { // Broadcast a message to all // vertices within a radius def sendMsg(radius) // Create a spatially aggregated // graph by combining vertices // and edges def spatialAG(reduceV: (V, V) =&gt; V, reduceE: (E, E) =&gt; E) }</p>
  </div>
  <div class="page">
    <p>B C</p>
    <p>A D</p>
    <p>F</p>
    <p>E</p>
    <p>A DD</p>
    <p>B C</p>
    <p>D</p>
    <p>E</p>
    <p>AA</p>
    <p>F</p>
    <p>Spatial Clustering</p>
    <p>F E DDBF</p>
    <p>Goal: Combine spatially close-by vertices</p>
  </div>
  <div class="page">
    <p>Spatial Clustering Two ways to enable spatial aggregation: - Using a (supplied) field in properties - Leverage geo partitioner</p>
  </div>
  <div class="page">
    <p>Spatial Clustering Two ways to enable spatial aggregation: - Using a (supplied) field in properties - Leverage geo partitioner</p>
  </div>
  <div class="page">
    <p>Computational Model: GStreams</p>
    <p>BS1UE2</p>
    <p>UE1</p>
    <p>BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
    <p>BS1 UE2</p>
    <p>UE1</p>
    <p>BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
    <p>BS1</p>
    <p>UE2</p>
    <p>UE1 BS2</p>
    <p>UE3</p>
    <p>UE4</p>
    <p>UE5</p>
    <p>Domain specific graph partitioning Spatial operations</p>
    <p>Window operations</p>
  </div>
  <div class="page">
    <p>Tracking Persistent Hotspots</p>
    <p>Goal: Detect and track groups of base stations with high traffic volume</p>
    <p>Equivalent to finding connected components</p>
  </div>
  <div class="page">
    <p>Tracking Persistent Hotspots BS1</p>
    <p>BS2 BS3</p>
    <p>t1 t2 t3</p>
    <p>W</p>
    <p>Combining graphs at the end of the window results in many join operations (inefficient)</p>
    <p>BS1</p>
    <p>BS2</p>
    <p>BS1</p>
    <p>BS2</p>
  </div>
  <div class="page">
    <p>Tracking Persistent Hotspots BS1</p>
    <p>BS2 BS3</p>
    <p>t1 t2 t3</p>
    <p>W</p>
    <p>BS1</p>
    <p>BS2</p>
    <p>BS1</p>
    <p>BS2</p>
    <p>BS1</p>
    <p>BS2 BS3</p>
    <p>BS1</p>
    <p>BS2 BS3</p>
    <p>BS1</p>
    <p>BS2 BS3</p>
    <p>Apply incremental updates to a cumulative graph</p>
  </div>
  <div class="page">
    <p>Tracking Persistent Hotspots BS1</p>
    <p>BS2 BS3</p>
    <p>t1 t2 t3</p>
    <p>BS1</p>
    <p>BS2</p>
    <p>BS1</p>
    <p>BS2</p>
    <p>BS1</p>
    <p>BS2 BS3</p>
    <p>Apply differential updates to a cumulative graph</p>
    <p>BS1</p>
    <p>BS3</p>
    <p>t4</p>
    <p>BS1</p>
    <p>BS2 BS3</p>
    <p>BS1</p>
    <p>BS2 BS3</p>
    <p>BS1</p>
    <p>BS2 BS3</p>
  </div>
  <div class="page">
    <p>GStream API</p>
    <p>class GStream[V, E] { def graphReduceByWindow( reduceFunc(Graph[V, E], Graph[V, E], fv: (V, V) =&gt; V, fe: (E, E) =&gt; E): Graph[V, E], invReduceFunc(Graph[V, E], Graph[V, E], fv: (V, V) =&gt; V, fe: (E, E) =&gt; E): Graph[V, E], windowDuration, slideDuration) }</p>
  </div>
  <div class="page">
    <p>graphReduceByWindow</p>
    <p>Implemented using Sparks cogroupedRDD  Two default reduce functions: graph intersection and union  Further optimizations:  Co-partition graphs from multiple batches  Reuse indices and routing tables for graphs in the</p>
    <p>same window More details in the paper!</p>
  </div>
  <div class="page">
    <p>How does CellIQ perform?</p>
  </div>
  <div class="page">
    <p>Evaluation Setup</p>
    <p>LTE control plane data from a major cellular network operator  1 million+ subscribers, live network  2 TB data from 1 week  1 file per minute, 750k records, 100s of fields/line  10 collection points, 10 hours per day</p>
    <p>Implemented several analysis tasks</p>
  </div>
  <div class="page">
    <p>Benefits of Geo-partitioning</p>
  </div>
  <div class="page">
    <p>Benefits of Geo-partitioning</p>
    <p>Small amount of data, movement not noticeable</p>
    <p>Default practitioner fails to produce results</p>
  </div>
  <div class="page">
    <p>Benefits of Incremental Updates</p>
  </div>
  <div class="page">
    <p>Benefits of Incremental Updates</p>
  </div>
  <div class="page">
    <p>Benefits of Incremental Updates</p>
    <p>window size affects performance</p>
  </div>
  <div class="page">
    <p>Benefits of Differential Updates</p>
  </div>
  <div class="page">
    <p>Benefits of Differential Updates</p>
    <p>Larger windows see bigger benefits</p>
    <p>Graceful degradation in performance</p>
  </div>
  <div class="page">
    <p>Benefits of Radius-based Broadcast</p>
  </div>
  <div class="page">
    <p>Benefits of Radius-based Broadcast</p>
    <p>Larger datasets result in increase in messages exchanges per hop</p>
  </div>
  <div class="page">
    <p>CellIQ is a cellular network analytics system that uses domain-specific optimizations to achieve 2x to 5x</p>
    <p>improvements</p>
  </div>
  <div class="page">
    <p>CellIQ is a cellular network analytics system that uses domain-specific optimizations to achieve 2x to 5x</p>
    <p>improvements Ongoing Work:  Using techniques in CellIQ to perform root-cause</p>
    <p>analysis on operational LTE Networks  Generalized streaming graph analysis techniques</p>
  </div>
</Presentation>
