<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Screen After Previous Screens: Spatial-Temporal Recreation of Android</p>
    <p>App Displays from Memory Images</p>
    <p>Brendan Saltaformaggio, Rohit Bhatia, Xiangyu Zhang, Dongyan Xu, Golden G. Richard III*</p>
    <p>Purdue University *University of New Orleans</p>
  </div>
  <div class="page">
    <p>A Crime To Investigate</p>
    <p>Without access to the suspects password or breaking Telegrams</p>
    <p>fully encrypted storage!</p>
  </div>
  <div class="page">
    <p>GUI Tree</p>
    <p>Memory Forensics or Mission Impossible?</p>
    <p>Time:</p>
  </div>
  <div class="page">
    <p>State of the Art: GUITAR - GUI Tree ARchaeology [CCS 15, Best Paper]</p>
    <p>Alice</p>
    <p>Drawing-Content-Based Bipartite Graph Matching GUI Tree</p>
    <p>Remaining GUI Data Structures</p>
  </div>
  <div class="page">
    <p>The Screen 0 Limitation of GUITAR Screen -5 Screen -4 Screen -3 Screen -2 Screen -1</p>
    <p>In Memory GUI Data:</p>
    <p>Screen 0</p>
    <p>Time:</p>
  </div>
  <div class="page">
    <p>Are The Old Screens Really Gone? Screen -5 Screen -4 Screen -3 Screen -2 Screen -1 Screen 0</p>
    <p>App screen changes are highly dynamic</p>
    <p>How can every screen be fully rebuilt so fast?</p>
    <p>Some data must remain to bring the screens back</p>
  </div>
  <div class="page">
    <p>Screen -5 Screen -4 Screen -3 Screen -2 Screen -1 Screen 0</p>
    <p>D a</p>
    <p>ta S</p>
    <p>tr u</p>
    <p>ct u</p>
    <p>re C</p>
    <p>o u</p>
    <p>n t</p>
    <p>(T h</p>
    <p>o u</p>
    <p>sa n</p>
    <p>d s)</p>
    <p>Time (Relative to Screen Changes)</p>
    <p>Internal Data Screen -5 Screen -4 Screen -3 Screen -2 Screen -1 Screen 0</p>
    <p>GUI Screen Data</p>
    <p>GUITARs Target: GUI Tree,</p>
    <p>Draw Ops,</p>
    <p>App Internal Data</p>
    <p>Not for GUI drawing: Raw Chat Strings,</p>
    <p>Account Balance,</p>
    <p>Are The Old Screens Really Gone?  Yes and No</p>
  </div>
  <div class="page">
    <p>Android Asks The App To Draw A Screen</p>
    <p>Canvas</p>
    <p>Canvas</p>
    <p>Android sends a Redraw Command</p>
    <p>- Destroying the previous screen!</p>
  </div>
  <div class="page">
    <p>Idea: Ask The Memory Image To Draw A Screen</p>
    <p>Canvas</p>
    <p>Redraw Command</p>
    <p>?</p>
    <p>Previous Approaches:</p>
    <p>- Data structure signature scanning</p>
    <p>- App-specific reverse engineering</p>
    <p>Our Goal: Plug And Play App-Agnostic Recovery</p>
    <p>?? Challenges:</p>
    <p>- Screen-specific draw routines</p>
  </div>
  <div class="page">
    <p>RetroScope: Spatial-Temporal Display Recreation</p>
    <p>Canvas Redraw Command</p>
    <p>Screen -3 Screen -2 Screen -1 Screen 0</p>
    <p>Performs app-agnostic screen reconstruction from an apps internal data within a memory image</p>
    <p>Interleaved Re-Execution</p>
    <p>Engine</p>
  </div>
  <div class="page">
    <p>State Merger</p>
    <p>Step 1) Start the Symbiont App to host the memory image</p>
    <p>Step 2) Move the memory image state into the Symbiont App</p>
    <p>- Map memory segments - Merge Java runtimes - Register draw functions</p>
    <p>Symbiont App: Two Apps In One</p>
  </div>
  <div class="page">
    <p>Interleaved Re-Execution Engine Step 3) Initialize the Interleaved Re-Execution Engine (IRE)</p>
    <p>Formally modeled the interleaving of states as a finite automata</p>
    <p>Transition rules guided by executing instruction semantics</p>
    <p>obj.func( )</p>
    <p>obj'.func( )</p>
    <p>obj.* | Pass obj'.* | Pass</p>
    <p>obj.fld | Passobj'.fld | Pass</p>
    <p>o b j'.fld</p>
    <p>o b j.</p>
    <p>fl d</p>
    <p>obj.func | Pass obj'.func | Pass</p>
    <p>o b j' .f</p>
    <p>ld</p>
    <p>o b j.fld</p>
    <p>C o d e C</p>
    <p>o n</p>
    <p>te x t B</p>
    <p>a rrie</p>
    <p>r</p>
    <p>The Overly Simple Explanation: Live Code outputs to Live Environment &amp;</p>
    <p>Old Code reads from Old Environment</p>
  </div>
  <div class="page">
    <p>Interleaved Re-Execution Engine Step 3) Initialize the Interleaved Re-Execution Engine (IRE)</p>
    <p>Interleaved Re-Execution</p>
    <p>Engine</p>
    <p>obj.func( )</p>
    <p>obj'.func( )</p>
    <p>obj.* | Pass obj'.* | Pass</p>
    <p>obj.fld | Passobj'.fld | Pass</p>
    <p>o b j'.fld</p>
    <p>o b</p>
    <p>j. fl</p>
    <p>d</p>
    <p>obj.func | Pass obj'.func | Pass</p>
    <p>o b</p>
    <p>j' .f</p>
    <p>ld</p>
    <p>o b</p>
    <p>j.fld</p>
    <p>C o</p>
    <p>d e C</p>
    <p>o n</p>
    <p>te x t B</p>
    <p>a rrie</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>obj.func( )</p>
    <p>obj'.func( )</p>
    <p>obj.* | Pass obj'.* | Pass</p>
    <p>obj.fld | Passobj'.fld | Pass</p>
    <p>o b j'.fld</p>
    <p>o b</p>
    <p>j. fl</p>
    <p>d</p>
    <p>obj.func | Pass obj'.func | Pass</p>
    <p>o b</p>
    <p>j' .f</p>
    <p>ld</p>
    <p>o b</p>
    <p>j.fld</p>
    <p>C o</p>
    <p>d e C</p>
    <p>o n</p>
    <p>te x t B</p>
    <p>a rrie</p>
    <p>r</p>
    <p>Selective Reanimation Step 4) Redirect a redraw command to the Target App</p>
    <p>Canvas Redraw Command</p>
    <p>Interleaved Re-Execution</p>
    <p>Engine</p>
    <p>The IRE monitors the state transitions and</p>
    <p>corrects the execution</p>
  </div>
  <div class="page">
    <p>Selective Reanimation Memory image apps draw routines naturally accesses its internal data</p>
    <p>Canvas Redraw Command</p>
    <p>Interleaved Re-Execution</p>
    <p>Engine</p>
    <p>obj.func( )</p>
    <p>obj'.func( )</p>
    <p>obj.* | Pass obj'.* | Pass</p>
    <p>obj.fld | Passobj'.fld | Pass</p>
    <p>o b j'.fld</p>
    <p>o b</p>
    <p>j. fl</p>
    <p>d</p>
    <p>obj.func | Pass obj'.func | Pass</p>
    <p>o b</p>
    <p>j' .f</p>
    <p>ld</p>
    <p>o b</p>
    <p>j.fld</p>
    <p>C o</p>
    <p>d e C</p>
    <p>o n</p>
    <p>te x t B</p>
    <p>a rrie</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>Selective Reanimation Memory image apps draw routines naturally accesses its internal data</p>
    <p>Canvas Redraw Command</p>
    <p>Interleaved Re-Execution</p>
    <p>Engine</p>
    <p>obj.func( )</p>
    <p>obj'.func( )</p>
    <p>obj.* | Pass obj'.* | Pass</p>
    <p>obj.fld | Passobj'.fld | Pass</p>
    <p>o b j'.fld</p>
    <p>o b</p>
    <p>j. fl</p>
    <p>d</p>
    <p>obj.func | Pass obj'.func | Pass</p>
    <p>o b</p>
    <p>j' .f</p>
    <p>ld</p>
    <p>o b</p>
    <p>j.fld</p>
    <p>C o</p>
    <p>d e C</p>
    <p>o n</p>
    <p>te x t B</p>
    <p>a rrie</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>Selective Reanimation</p>
    <p>IRE ensures that function calls to the new canvas are directed to the live GUI system</p>
    <p>Canvas</p>
    <p>Interleaved Re-Execution</p>
    <p>Engine</p>
    <p>obj.func( )</p>
    <p>obj'.func( )</p>
    <p>obj.* | Pass obj'.* | Pass</p>
    <p>obj.fld | Passobj'.fld | Pass</p>
    <p>o b j'.fld</p>
    <p>o b</p>
    <p>j. fl</p>
    <p>d</p>
    <p>obj.func | Pass obj'.func | Pass</p>
    <p>o b</p>
    <p>j' .f</p>
    <p>ld</p>
    <p>o b</p>
    <p>j.fld</p>
    <p>C o</p>
    <p>d e C</p>
    <p>o n</p>
    <p>te x t B</p>
    <p>a rrie</p>
    <p>r</p>
    <p>o b</p>
    <p>j.fld</p>
  </div>
  <div class="page">
    <p>Selective Reanimation</p>
    <p>The newly filled Canvas is rendered by the live GUI system and saved</p>
    <p>Canvas</p>
    <p>Interleaved Re-Execution</p>
    <p>Engine</p>
    <p>obj.func( )</p>
    <p>obj'.func( )</p>
    <p>obj.* | Pass obj'.* | Pass</p>
    <p>obj.fld | Passobj'.fld | Pass</p>
    <p>o b j'.fld</p>
    <p>o b</p>
    <p>j. fl</p>
    <p>d</p>
    <p>obj.func | Pass obj'.func | Pass</p>
    <p>o b</p>
    <p>j' .f</p>
    <p>ld</p>
    <p>o b</p>
    <p>j.fld</p>
    <p>C o</p>
    <p>d e C</p>
    <p>o n</p>
    <p>te x t B</p>
    <p>a rrie</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>obj.func( )</p>
    <p>obj'.func( )</p>
    <p>obj.* | Pass obj'.* | Pass</p>
    <p>obj.fld | Passobj'.fld | Pass</p>
    <p>o b j'.fld</p>
    <p>o b</p>
    <p>j. fl</p>
    <p>d</p>
    <p>obj.func | Pass obj'.func | Pass</p>
    <p>o b</p>
    <p>j' .f</p>
    <p>ld</p>
    <p>o b</p>
    <p>j.fld</p>
    <p>C o</p>
    <p>d e C</p>
    <p>o n</p>
    <p>te x t B</p>
    <p>a rrie</p>
    <p>r</p>
    <p>Selective Reanimation</p>
    <p>This process repeats for each registered draw routine</p>
    <p>Canvas</p>
    <p>Interleaved Re-Execution</p>
    <p>Engine</p>
  </div>
  <div class="page">
    <p>Breaking The Case Wide Open!</p>
  </div>
  <div class="page">
    <p>Evaluation 15 Apps on 3 Suspect Devices: HTC One, LG G3, Samsung Galaxy S4</p>
    <p>H T</p>
    <p>C O</p>
    <p>n e</p>
    <p>(M o</p>
    <p>re In</p>
    <p>P a</p>
    <p>p e</p>
    <p>r)</p>
    <p>App Screens Recovered</p>
    <p>Ground Truth (lower bound)</p>
    <p>Byte Code Inst. Re-Executed</p>
    <p>New Java Objects</p>
    <p>New C/C++ Structures</p>
    <p>Calendar 6 6 197316 732 102642</p>
    <p>Chase Banking 11 11 584587 2091 266965</p>
    <p>Contacts 3 3 190847 723 71578</p>
    <p>Facebook 6 5 382522 1451 95516</p>
    <p>Gmail 6 6 235973 929 129804</p>
    <p>Instagram 3 3 86829 433 42037</p>
    <p>Messaging 4 4 93971 287 45085</p>
    <p>TextSecure 7 8 231891 924 98571</p>
    <p>WhatsApp 6 6 321229 1571 104216</p>
    <p>Average of: 41,078 Byte-Code Instructions,</p>
    <p>Per Screen</p>
  </div>
  <div class="page">
    <p>Case 1: WeChat (And Others) Deleted Messages</p>
    <p>Screen -4 Screen -3 Screen -2 Screen -1 Screen 0</p>
    <p>From LG G3 Device</p>
  </div>
  <div class="page">
    <p>Case 2: WhatsApp Background Update</p>
    <p>Screen -5 Screen -4 Screen -3 Screen -2 Screen -1 Screen 0 Screen +1</p>
    <p>From Samsung Galaxy S4 Device</p>
  </div>
  <div class="page">
    <p>Related Works B. Saltaformaggio, Z. Gu, X. Zhang, and D. Xu. DSCRETE: Automatic Rendering of Forensic Information from Memory Images via Application Logic Reuse. In Proc. USENIX Security, 2014. Best Student Paper.</p>
    <p>M. Carbone, W. Cui, L. Lu, W. Lee, M. Peinado, and X. Jiang. Mapping kernel objects to enable systematic integrity checking. In Proc. CCS, 2009.</p>
    <p>B. Dolan-Gavitt, A. Srivastava, P. Traynor, and J. Giffin. Robust signatures for kernel data structures. In Proc. CCS, 2009.</p>
    <p>J. Lee, T. Avgerinos, and D. Brumley. TIE: Principled reverse engineering of types in binary programs. In Proc. NDSS, 2011.</p>
    <p>A. Slowinska, T. Stancescu, and H. Bos. Howard: A dynamic excavator for reverse engineering data structures. In Proc. NDSS, 2011.</p>
    <p>R. Walls, B. N. Levine, and E. G. Learned-Miller. Forensic triage for mobile phones with DEC0DE. In Proc. USENIX Security, 2011.</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>RetroScope represents a new paradigm of spatial-temporal memory forensics for app GUI screens</p>
    <p>RetroScopes novel IRE selectively reanimates an apps screen redrawing functionality without any app-specific knowledge</p>
    <p>Recovers visually accurate, temporally ordered screens (ranging from 3 to 11 screens) for a wide variety of privacy-sensitive apps</p>
  </div>
  <div class="page">
    <p>Thank you! Questions?</p>
    <p>Brendan Saltaformaggio bsaltafo@cs.purdue.edu</p>
  </div>
  <div class="page">
    <p>Privacy Implications of RetroScope? The privacy-sensitive apps are not broken, per se</p>
    <p>- Unlike disk or network, memory is assumed private - Little incentive to protect memory - E.g., Malware in your apps memory = all bets are off</p>
    <p>RetroScope is just emulating the standard behavior of Android - To disrupt RetroScope would also hinder an apps ability to draw screens - Encrypting memory doesnt work because RetroScope would reanimate the decryption logic - Privacy vs. Usability</p>
    <p>- E.g., Zeroing data would require getting it back in order to redraw (slowing down the UI)</p>
    <p>Citizens privacy is protected by strict legal protocols and regulations (see [9,21]) - Search warrants &amp; strict chain of custody documentation prior to performing invasive forensics</p>
  </div>
</Presentation>
