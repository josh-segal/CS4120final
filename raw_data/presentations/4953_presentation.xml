<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Highly Scalable Algorithms for Robust String Barcoding</p>
    <p>Bhaskar DasGupta*</p>
    <p>Kishori M. Konwar</p>
    <p>Ion Mandoiu</p>
    <p>Alex Shavartsman</p>
    <p>Computer Science &amp; Engineering Department</p>
    <p>University of Connecticut</p>
    <p>Storrs, CT</p>
    <p>*Department of Computer Science University of Illinois at Chicago</p>
    <p>Chicago, IL</p>
  </div>
  <div class="page">
    <p>Motivation  There are many critical situations when one needs to rapidly identify an unknown genomic sequence from among a given set of known sequences</p>
    <p>Rapid identification of pathogens in epidemic outbreaks  Monitoring of microbial communities, e.g., in environmental studies  Fast database search</p>
  </div>
  <div class="page">
    <p>Possible Approaches</p>
    <p>Sequencing based: sequence the unknown DNA sequence, then use similarity search programs such as BLAST to identify the unknown virus sequence for pathogens in database  Sequencing is prohibitively expensive and time consuming</p>
    <p>Hybridization Based: identify the unknown sequence by testing for the presence of certain subsequences  Subsequence tests can be performed quickly and at low cost</p>
    <p>using a variety of hybridization based methods</p>
  </div>
  <div class="page">
    <p>Sequence Fingerprints  For each sequence, find a subsequence that appears</p>
    <p>in that sequence and only in that sequence</p>
    <p>GTTGC GTTC CAT</p>
    <p>CAGTTGC 1 0 0</p>
    <p>CAGTTC 0 1 0</p>
    <p>CATGGA 0 0 1</p>
    <p>Sequence barcodes: 0/1 vectors  When using fingerprints, barcode length = #sequences</p>
  </div>
  <div class="page">
    <p>String Barcoding</p>
    <p>(Borneman et al.01, Rash &amp; Gusfield02): Unique occurrence of tested subsequences not needed, as long as 0/1 barcodes are unique</p>
    <p>TG CAGT</p>
    <p>CAGTTGC 1 1</p>
    <p>CAGTTC 0 1</p>
    <p>CATGGA 1 0</p>
    <p>When using non-unique subsequences, barcode length can be much smaller than #sequences</p>
  </div>
  <div class="page">
    <p>Overview  Problem Formulation and Previous Work</p>
    <p>Greedy Setcover Algorithm</p>
    <p>Experimental Results</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Given:</p>
    <p>Genomic sequences g1,, gn Find:</p>
    <p>Minimum number of distinguisher strings t1,,tk</p>
    <p>Such that:</p>
    <p>For every gi  gj there exists a distinguisher tl which is a substring of gi or gj but not of both</p>
    <p>- At least log2n distinguishers needed</p>
    <p>- n distinguishers are always sufficient</p>
    <p>Problem Definition</p>
  </div>
  <div class="page">
    <p>Computational Complexity</p>
    <p>[Berman et al.04] Cannot be approximated within a factor of (1-)ln(n) unless NP=DTIME(nloglog(n))</p>
  </div>
  <div class="page">
    <p>A non-redundant set of candidate distinguishers is generated using a suffix tree  One variable vi for each candidate distinguisher xi</p>
    <p>vi = 1  xi is selected  vi = 0  xi is not selected</p>
    <p>}1,0{</p>
    <p>:Subject to</p>
    <p>: Minimize</p>
    <p>S' S, sequences ofpair every for S'S, of oneexactly</p>
    <p>in appears</p>
    <p>i</p>
    <p>v</p>
    <p>v</p>
    <p>v ix</p>
    <p>i</p>
    <p>i i</p>
    <p>Rash &amp; Gusfield Integer Program</p>
  </div>
  <div class="page">
    <p>Integer Program Example Minimize VVTGTG + V + VATGGAATGGA+ V+ VCAGTCAGT + V + VTTC +V +VGTGC #objective function</p>
    <p>Such that VVTGTG + VVTTC + VVGTGC &gt;= 1 #constraint to cover pair 1,2 VVATGGAATGGA + VVCAGTCAGT + VVGTGC &gt;= 1 #constraint to cover pair 1,3 VVTGTG + VVATGGAATGGA + VVCAGTCAGT + VVTTC &gt;= 1 #constraint to cover pair 2,3 Binaries #all variables are 0/1 VVTGTG V VATGGAATGGA VVCAGTCAGT VVTTC VVGTGC End</p>
    <p>TG ATGGA</p>
  </div>
  <div class="page">
    <p>Limitations of Integer Program Method</p>
    <p>Works only for moderately sized datasets 50-150 sequences Average sequence length ~1000 nucleotides Up to 4 hours needed to come within 20% of optimum</p>
  </div>
  <div class="page">
    <p>Information Content Heuristic</p>
    <p>[Berman et al. 2004] Keep track of the partition defined by distinguishers</p>
    <p>selected so far In every step, choose candidate that reduces partition</p>
    <p>entropy by largest amount</p>
    <p>Theorem: Information Content Heuristic is always finding a #distinguishers within 1+ln(n) of optimum</p>
  </div>
  <div class="page">
    <p>Limitations of ICH  Real genomic sequences contain degenerate nucleotides</p>
    <p>(e.g., N for any of {A,T,C,G}) due to sequencing errors and known single nucleotide polymorphisms</p>
    <p>Distinguisher-to-sequence matches:  Perfect matches  Perfect mismatches  Uncertain matches</p>
    <p>Information Content cannot be defined in the presence of uncertain matches</p>
    <p>ATCNAT</p>
    <p>ATC 1</p>
    <p>CCC 0</p>
    <p>CCA ?</p>
  </div>
  <div class="page">
    <p>Other Heuristics</p>
    <p>(Cazalis et al 2004): greedy setcover, simulated annealing, and genetic algorithms for distinguisher selection</p>
    <p>To achieve practical running time, only a small random subset (2000 candidates) of all candidate distinguishers is considered No data provided on the loss of solution quality due</p>
    <p>to this restriction</p>
  </div>
  <div class="page">
    <p>Overview  Problem Formulation and Previous work</p>
    <p>Greedy Setcover Algorithm</p>
    <p>Experimental Results</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Setcover Greedy Heuristic</p>
    <p>Phase I: Candidate Generation  Generate a representative set of candidate</p>
    <p>distinguishers from the source sequences</p>
    <p>Phase II: Greedy Distinguisher Selection In every step, choose candidate that distinguishes the</p>
    <p>largest number of not yet distinguished pairs</p>
  </div>
  <div class="page">
    <p>Candidate Generation</p>
    <p>A set of candidate distinguishers guaranteed to contain an optimum solution is generated from the sequences</p>
    <p>We do not generate certain redundant candidates  A candidate is redundant if there is another candidate</p>
    <p>that appears exactly in the same set of sequences  For every sequence we generate only one of the</p>
    <p>substrings that appear exclusively in that sequence</p>
  </div>
  <div class="page">
    <p>Efficient Candidate Generation  Our implementation uses simple array datastructures</p>
    <p>We generate candidates in increasing order of length  Exact match positions for candidates of length l-1 used to</p>
    <p>generate the exact matches for candidates of length l</p>
    <p>Candidates that do not satisfy individual given biochemical constraints, such as minimum/maximum length, GC content, melting temperature, are discarded</p>
  </div>
  <div class="page">
    <p>Setcover Greedy Heuristic</p>
    <p>Phase I: Candidate Generation  Generate a set of candidate distinguishers from the</p>
    <p>source sequences</p>
    <p>Phase II: Greedy Distinguisher Selection In every step, choose candidate that distinguishes the</p>
    <p>largest number of not yet distinguished pairs</p>
  </div>
  <div class="page">
    <p>Distinguisher Selection as Set Cover</p>
    <p>Set Cover Problem: given a universal set U and a family of subsets, find a minimum number of subsets covering U</p>
    <p>Distinguisher selection is a special case of set cover:  Elements to be covered are the pairs of sequences  Each candidate distinguisher defines a set of pairs that it separates</p>
    <p>By a classical result, the greedy algorithm has an approximation factor of 1+ln(|U|) Setcover greedy has approximation factor of 2*ln(n) for</p>
    <p>distinguisher selection with n sequences</p>
  </div>
  <div class="page">
    <p>Distinguisher Selection  Start with an empty set D of distinguishers</p>
    <p>While there are pairs of sequences not yet distinguished, do:</p>
    <p>Compute for each remaining candidate c its coverage gain (c, D)  the number of not yet distinguished pairs of sequences that are distinguished by c</p>
    <p>Add the candidate with maximum coverage gain to D</p>
    <p>Return D</p>
  </div>
  <div class="page">
    <p>Computation of (c, D):</p>
    <p>CATCAGA</p>
    <p>TTCAGT</p>
    <p>TAT</p>
    <p>AATAG</p>
    <p>AATCAG</p>
    <p>D = { }</p>
  </div>
  <div class="page">
    <p>Computation of (c, D):</p>
    <p>CATCAGA</p>
    <p>TTCAGT</p>
    <p>TAT</p>
    <p>AATAG</p>
    <p>AATCAG</p>
    <p>c=TCAG</p>
    <p>D = { }</p>
  </div>
  <div class="page">
    <p>Computation of (c, D):</p>
    <p>CATCAGA</p>
    <p>TTCAGT</p>
    <p>TAT</p>
    <p>AATAG</p>
    <p>AATCAG</p>
    <p>c=TCAG</p>
    <p>D = { }</p>
    <p>(c, D)= 3 x (5 3) = 6</p>
  </div>
  <div class="page">
    <p>Computation of (c, D):</p>
    <p>CATCAGA</p>
    <p>TTCAGT</p>
    <p>TAT</p>
    <p>AATAG</p>
    <p>AATCAG</p>
    <p>D = {TCAG}</p>
  </div>
  <div class="page">
    <p>Computation of (c, D):</p>
    <p>CATCAGA</p>
    <p>TTCAGT</p>
    <p>TAT</p>
    <p>AATAG</p>
    <p>AATCAG</p>
    <p>D = {TCAG}</p>
    <p>c=AAT</p>
  </div>
  <div class="page">
    <p>Computation of (c, D):</p>
    <p>CATCAGA</p>
    <p>TTCAGT</p>
    <p>TAT</p>
    <p>AATAG</p>
    <p>AATCAG</p>
    <p>D = {TCAG}</p>
    <p>c=AAT</p>
    <p>(c,D)= 1 x (2-1) + 1 x (3-1) = 3</p>
  </div>
  <div class="page">
    <p>Computation of (c, D):</p>
    <p>CATCAGA</p>
    <p>TTCAGT</p>
    <p>TAT</p>
    <p>AATAG</p>
    <p>AATCAG</p>
    <p>D = {TCAG,AAT}</p>
  </div>
  <div class="page">
    <p>Computation of (c, D)</p>
    <p>|\|||),( 1</p>
    <p>cic</p>
    <p>k</p>
    <p>i i MSMSDc</p>
    <p>S1, S2, , Sk are the subsets in the partition defined by D</p>
    <p>Mc is the set of matches of candidate c</p>
    <p>Using simple datastructures, computation can be done in linear time (in the number of sequences)</p>
  </div>
  <div class="page">
    <p>Lazy Update of Gains</p>
    <p>Coverage gains are monotonically non-increasing during the algorithm</p>
    <p>Re-compute coverage gain for a candidate only if last saved gain is higher than the gain of current best candidate</p>
    <p>In practice this speeds-up the selection algorithm by a factor of ~2</p>
  </div>
  <div class="page">
    <p>Degenerate bases  A pair of sequences is separated by candidate c if</p>
    <p>c has at least one perfect match with one of the sequences, and c has perfect mismatches at all positions of the other sequence</p>
    <p>Gain computation done in O(n2) time using a simple coverage matrix data-structure</p>
    <p>Redundancy r  A pair of sequences is counted in the gain function until r</p>
    <p>distinguishers separate it</p>
    <p>Distinguisher cross-hybridization  Minimum edit distance, or maximum common substring weight,</p>
    <p>bound for every pair of selected distinguishers  Candidates incompatible with a selected distinguisher removed</p>
    <p>from candidate list</p>
    <p>Algorithm Extensions</p>
  </div>
  <div class="page">
    <p>Overview  Problem Formulation and Previous work</p>
    <p>Greedy Setcover Algorithm</p>
    <p>Experimental Results</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Randomly generated instances Equal probabilities assigned to each of the four</p>
    <p>nucleotides</p>
    <p>Microbial genomes extracted from NCBI databases Sequence lengths between 490 Kbases to 4.75</p>
    <p>Mbases Small number of degenerate bases</p>
    <p>Testcases</p>
  </div>
  <div class="page">
    <p>Selection time, L=10k, r=1</p>
    <p>basic  O(n2) computation of gains using matrix datastructure</p>
    <p>partition  O(n) computation of gains using partition-based datastructure</p>
  </div>
  <div class="page">
    <p>Candidate Sampling, n=1000, L=10k, r=1</p>
  </div>
  <div class="page">
    <p>Comparison to ICH, L=10k, r=1</p>
    <p>Algo n</p>
    <p>log2n</p>
    <p>ICH</p>
    <p>SGA</p>
  </div>
  <div class="page">
    <p>Varying Redundancy, L=10k</p>
    <p>Redundancy</p>
    <p># D</p>
    <p>is ti</p>
    <p>n g</p>
    <p>u is</p>
    <p>h e rs</p>
    <p>n=10 n=20 n=50 n=100</p>
    <p>n=200 n=500 n=1000</p>
  </div>
  <div class="page">
    <p>20 NCBI microbial genomic sequences</p>
    <p>Distinguisher melting temperature range of 5560 oC</p>
    <p>GC content range of 40-60%</p>
    <p>Max common subsequence weight bound of 5  weight(A)=weight(T)=1, weight(C)=weight(G)=2</p>
    <p>NCBI testcase</p>
  </div>
  <div class="page">
    <p>CAC GAC</p>
    <p>GTT CTG</p>
    <p>AA</p>
    <p>GAT TCG</p>
    <p>AAC CCC</p>
    <p>CGA</p>
    <p>GTG GAT</p>
    <p>GCC TTG</p>
    <p>GCA</p>
    <p>GG ACT</p>
    <p>ACC AGG</p>
    <p>GTA TCT</p>
    <p>AAT CCT</p>
    <p>G</p>
    <p>AAA GA</p>
    <p>AG ATA</p>
    <p>GA GC</p>
    <p>AG CA</p>
    <p>GC T</p>
    <p>AAG CGC</p>
    <p>GTC GCA</p>
    <p>AA</p>
    <p>CAC AAG</p>
    <p>GA GTG</p>
    <p>AGT GTT</p>
    <p>GC</p>
    <p>CGG TTT</p>
    <p>TGT GC</p>
    <p>TTC ATG</p>
    <p>G</p>
    <p>CC ATT</p>
    <p>GA CA</p>
    <p>ATT TCA</p>
    <p>AC AC</p>
    <p>C</p>
    <p>Organism Mb Barcode Nanoarchaeum equitans Kin4-M 0.49 0 0 0 0 0 0 0 0 1 Mycobacterium tuberculosis CDC1551 4.40 0 0 0 0 0 0 1 0 0 Brucella suis 1330 chromosome 1 2.11 0 0 0 0 1 1 0 1 0 Leifsonia xyli subsp. xyli str. CTCB07 2.58 0 0 0 0 0 0 1 0 1 Mannheimia succiniciproducens MBEL55E 2.31 0 0 0 0 1 1 1 0 0 Geobacter sulfurreducens PCA 3.81 0 0 0 1 0 0 0 0 0 Rickettsia typhi str. Wilmington 1.11 0 0 0 0 0 1 1 0 1 Picrophilus torridus DSM 9790 1.55 0 1 0 0 0 0 0 0 1 Mesoplasma florum L1 0.79 0 0 0 0 0 0 0 1 1 Methylococcus capsulatus str. Bath 3.30 0 0 0 0 0 1 0 0 1 Propionibacterium acnes KPA171202 2.56 0 0 0 0 0 0 1 1 0 Mycoplasma mobile 163K 0.78 0 0 0 0 0 1 0 1 1 Mycoplasma hyopneumoniae 232 0.89 1 0 0 0 0 1 0 1 1 Bacillus licheniformis DSM 13 4.22 0 0 0 0 0 1 1 1 0 Legionella pneumophila subsp. pneumophila str. Philadelphia 1</p>
    <p>Onion yellows phytoplasma OY-M DNA 0.86 0 0 0 0 1 1 1 1 0 Staphylococcus aureus subsp. Aureus strain MRSA252</p>
    <p>Staphylococcus aureus strain MSSA476 2.80 0 0 0 0 0 1 1 1 1 Burkholderia pseudomallei strain K96243 chromosome 1</p>
    <p>Bartonella henselae strain Houston-1 1.93 0 0 0 0 0 1 0 1 0 GC (%) 60.0 45.5 60.0 50.0 57.1 50.0 52.6 42.9 40.0 Tm (oC) 55.6 59.6 55.4 59.3 56.9 58.6 55.1 55.4 56.3</p>
    <p>NCBI testcase, r=1</p>
  </div>
  <div class="page">
    <p>Results on 29 Microbial Sequences (76 Mb)</p>
    <p>Redun lmin lmax MinEdit Select Time #Distinguishers</p>
  </div>
  <div class="page">
    <p>Overview  Problem Formulation and Previous work</p>
    <p>Greedy Setcover Algorithm</p>
    <p>Experimental Results</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>We provided highly scalable algorithms for the robust string barcoding problem, capable of handling whole genomic sequences of up to bacterial size</p>
    <p>Distinguisher selection based whole genomic sequences results in a number of distinguishers nearly matching the information theoretic lower bounds for the problem</p>
    <p>The software can be used online at http://dna.engr.uconn.edu/~software/DNA-BAR/</p>
    <p>Conclusions</p>
  </div>
</Presentation>
