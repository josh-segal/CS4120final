<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>EC-Cache: Load-balanced, Low-latency Cluster Caching with</p>
    <p>Online Erasure Coding</p>
    <p>Joint work with</p>
    <p>Mosharaf Chowdhury, Jack Kosaian (U Michigan) Ion Stoica, Kannan Ramchandran (UC Berkeley)</p>
    <p>Rashmi'Vinayak'</p>
    <p>UC#Berkeley</p>
  </div>
  <div class="page">
    <p>Caching'for'data4intensive'clusters</p>
    <p>Data.intensive#clusters#rely#on#distributed, in-memory# caching#for#high#performance#</p>
    <p>. Reading#from#memory#orders#of#magnitude#faster#than#from# disk/ssd#</p>
    <p>. Example:##Alluxio#(formerly#Tachyon)</p>
    <p>Li#et#al.#SOCC#2014# 2</p>
  </div>
  <div class="page">
    <p>Imbalances'prevalent'in'clusters'</p>
    <p>Sources#of#imbalance:#</p>
    <p>Skew#in#object#popularity#</p>
    <p>Background#network#imbalance#</p>
    <p>Failures/unavailabiliRes</p>
  </div>
  <div class="page">
    <p>Sources#of#imbalance:#</p>
    <p>Skew#in#object#popularity#</p>
    <p>Background#network#imbalance#</p>
    <p>Failures/unavailabilites</p>
    <p>Small#fracRon#of#objects#highly#popular# . Zipf.like#distribuRon## . Top#5%#of#objects#7x#more#popular#than#boWom#75%#</p>
    <p>(Facebook#and#MicrosoY#producRon#cluster#traces)</p>
    <p>Ananthanarayanan#et#al.#NSDI#2012#</p>
    <p>Imbalances'prevalent'in'clusters'</p>
  </div>
  <div class="page">
    <p>Sources#of#imbalance:#</p>
    <p>Skew#in#object#popularity#</p>
    <p>Background#network#imbalance#</p>
    <p>Failures/unavailabilites</p>
    <p>Some#parts#of#the#network#more#congested#than#others# . RaRo#of#maximum#to#average#uRlizaRon#more#than#4.5x#</p>
    <p>with#&gt;#50%#uRlizaRon##</p>
    <p>(Facebook#data.analyRcs#cluster)</p>
    <p>Imbalances'prevalent'in'clusters'</p>
  </div>
  <div class="page">
    <p>Sources#of#imbalance:#</p>
    <p>Skew#in#object#popularity#</p>
    <p>Background#network#imbalance#</p>
    <p>Failures/unavailabilites</p>
    <p>Some#parts#of#the#network#more#congested#than#others# . RaRo#of#maximum#to#average#uRlizaRon#more#than#4.5x#</p>
    <p>with#&gt;#50%#uRlizaRon##</p>
    <p>(Facebook#data.analyRcs#cluster)</p>
    <p>Imbalances'prevalent'in'clusters'</p>
    <p>#Chowdhury#et#al.#SIGCOMM#2013#</p>
    <p>. Similar#observaRons#from#other#producRon#clusters</p>
  </div>
  <div class="page">
    <p>Sources#of#imbalance:#</p>
    <p>Skew#in#object#popularity#</p>
    <p>Background#load#imbalance#</p>
    <p>Failures/unavailabilites</p>
    <p>Norm#rather#than#the#excepRon# . median#&gt;#50#machine#unavailability#events#every#day#in#a#</p>
    <p>cluster#of#several#thousand#servers#</p>
    <p>(Facebook#data#analyRcs#cluster)</p>
    <p>Imbalances'prevalent'in'clusters'</p>
    <p>Rashmi#et#al.#HotStorage#2013 6</p>
  </div>
  <div class="page">
    <p>Adverse#effects:# 4 load#imbalance'</p>
    <p>. high#read#latency</p>
    <p>Imbalances'prevalent'in'cluster'</p>
    <p>Sources#of#imbalance:#</p>
    <p>Skew#in#object#popularity#</p>
    <p>Background#network#imbalance#</p>
    <p>Failures/unavailabiliRes</p>
  </div>
  <div class="page">
    <p>Adverse#effects:# 4 load#imbalance'</p>
    <p>. high#read#latency</p>
    <p>Imbalances'prevalent'in'cluster'</p>
    <p>Sources#of#imbalance:#</p>
    <p>Skew#in#object#popularity#</p>
    <p>Background#network#imbalance#</p>
    <p>Failures/unavailabiliRes</p>
    <p>Single#copy#in#memory#oYen#not#sufficient#to#get#good#performance</p>
  </div>
  <div class="page">
    <p>Popular'approach:'Selec?ve'Replica?on</p>
    <p>Uses#some#memory#overhead#to#cache#replicas#of#objects# based#on#their#popularity# . more#replicas#for#more#popular#objects</p>
  </div>
  <div class="page">
    <p>Popular'approach:'Selec?ve'Replica?on</p>
    <p>Uses#some#memory#overhead#to#cache#replicas#of#objects# based#on#their#popularity# . more#replicas#for#more#popular#objects</p>
    <p>A B</p>
    <p>GET A GET B</p>
    <p>Server 1 Server 2 Server 3</p>
  </div>
  <div class="page">
    <p>Popular'approach:'Selec?ve'Replica?on</p>
    <p>Uses#some#memory#overhead#to#cache#replicas#of#objects# based#on#their#popularity# . more#replicas#for#more#popular#objects</p>
    <p>A B A</p>
    <p>GET A GET AGET B</p>
    <p>Server 1 Server 2 Server 3</p>
  </div>
  <div class="page">
    <p>Popular'approach:'Selec?ve'Replica?on</p>
    <p>Uses#some#memory#overhead#to#cache#replicas#of#objects# based#on#their#popularity# . more#replicas#for#more#popular#objects</p>
    <p>A B A</p>
    <p>GET A GET AGET B</p>
    <p>Used#in#data.intensive#clusters#as#well#as#widely#used#in# key.value#stores#for#many#web.services#such#as#Facebook# Tao</p>
    <p>Server 1 Server 2 Server 3</p>
    <p>Ananthanarayanan#et#al.#NSDI#2011,##Bronson#et#al.#ATC!2013 8</p>
  </div>
  <div class="page">
    <p>Memory'Overhead</p>
    <p>Read'performance''</p>
    <p>&amp;'Load'balance''</p>
  </div>
  <div class="page">
    <p>Memory'Overhead</p>
    <p>Read'performance''</p>
    <p>&amp;'Load'balance''</p>
    <p>Single'copy''</p>
    <p>in'memory</p>
  </div>
  <div class="page">
    <p>Memory'Overhead</p>
    <p>Read'performance''</p>
    <p>&amp;'Load'balance''</p>
    <p>Single'copy''</p>
    <p>in'memory</p>
    <p>Selec?ve'</p>
    <p>replica?on</p>
  </div>
  <div class="page">
    <p>Memory'Overhead</p>
    <p>Read'performance''</p>
    <p>&amp;'Load'balance''</p>
    <p>Single'copy''</p>
    <p>in'memory</p>
    <p>Selec?ve'</p>
    <p>replica?on</p>
    <p>EC4Cache</p>
  </div>
  <div class="page">
    <p>Memory'Overhead</p>
    <p>Read'performance''</p>
    <p>&amp;'Load'balance''</p>
    <p>Single'copy''</p>
    <p>in'memory</p>
    <p>Selec?ve'</p>
    <p>replica?on</p>
    <p>EC4Cache</p>
    <p>Erasure'Coding</p>
  </div>
  <div class="page">
    <p>Quick'primer'on'erasure'coding</p>
  </div>
  <div class="page">
    <p>Quick'primer'on'erasure'coding</p>
    <p>Takes#in#k data units#and#creates#r##parity units</p>
  </div>
  <div class="page">
    <p>Quick'primer'on'erasure'coding</p>
    <p>Takes#in#k data units#and#creates#r##parity units</p>
    <p>Any$k#of#the#(k+r)#units#are#sufficient#to#decode#the#original# k#data#units</p>
  </div>
  <div class="page">
    <p>Quick'primer'on'erasure'coding</p>
    <p>Takes#in#k data units#and#creates#r##parity units</p>
    <p>k = 5  r = 4</p>
    <p>Any$k#of#the#(k+r)#units#are#sufficient#to#decode#the#original# k#data#units</p>
    <p>data units parity units</p>
    <p>d1 d2 d3 d4 d5 p1 p2 p3 p4</p>
  </div>
  <div class="page">
    <p>Quick'primer'on'erasure'coding</p>
    <p>Takes#in#k data units#and#creates#r##parity units</p>
    <p>k = 5  r = 4</p>
    <p>Any$k#of#the#(k+r)#units#are#sufficient#to#decode#the#original# k#data#units</p>
    <p>data units parity units</p>
    <p>Read</p>
    <p>d1 d2 d3 d4 d5 p1 p2 p3 p4</p>
  </div>
  <div class="page">
    <p>Quick'primer'on'erasure'coding</p>
    <p>Takes#in#k data units#and#creates#r##parity units</p>
    <p>k = 5  r = 4</p>
    <p>Any$k#of#the#(k+r)#units#are#sufficient#to#decode#the#original# k#data#units</p>
    <p>data units parity units</p>
    <p>Read</p>
    <p>Decode</p>
    <p>d1 d2 d3 d4 d5 p1 p2 p3 p4</p>
    <p>d1 d2 d3 d4 d5</p>
  </div>
  <div class="page">
    <p>Quick'primer'on'erasure'coding</p>
    <p>Takes#in#k data units#and#creates#r##parity units</p>
    <p>k = 5  r = 4</p>
    <p>Any$k#of#the#(k+r)#units#are#sufficient#to#decode#the#original# k#data#units</p>
    <p>data units parity units</p>
    <p>Read</p>
    <p>d1 d2 d3 d4 d5 p1 p2 p3 p4</p>
  </div>
  <div class="page">
    <p>Quick'primer'on'erasure'coding</p>
    <p>Takes#in#k data units#and#creates#r##parity units</p>
    <p>k = 5  r = 4</p>
    <p>Any$k#of#the#(k+r)#units#are#sufficient#to#decode#the#original# k#data#units</p>
    <p>data units parity units</p>
    <p>Read</p>
    <p>d1 d2 d3 d4 d5 p1 p2 p3 p4</p>
    <p>Decode</p>
    <p>d1 d2 d3 d4 d5</p>
  </div>
  <div class="page">
    <p>EC4Cache'birds'eye'view:'Writes</p>
  </div>
  <div class="page">
    <p>EC4Cache'birds'eye'view:'Writes</p>
    <p>XPut</p>
    <p>Caching#servers</p>
  </div>
  <div class="page">
    <p>EC4Cache'birds'eye'view:'Writes</p>
    <p>X</p>
    <p>k#=#2Split d2</p>
    <p>Put</p>
    <p>d1</p>
    <p>Object#split#into#k#data#units</p>
    <p>Caching#servers</p>
  </div>
  <div class="page">
    <p>EC4Cache'birds'eye'view:'Writes</p>
    <p>k#=#2# r#=#1</p>
    <p>X</p>
    <p>Encode</p>
    <p>p1</p>
    <p>k#=#2Split d2</p>
    <p>d1 d2</p>
    <p>Put</p>
    <p>d1</p>
    <p>Object#split#into#k#data#units</p>
    <p>Encoded#to#generate#r#parity# units</p>
    <p>Caching#servers</p>
  </div>
  <div class="page">
    <p>EC4Cache'birds'eye'view:'Writes</p>
    <p>k#=#2# r#=#1</p>
    <p>X</p>
    <p>Encode</p>
    <p>p1</p>
    <p>k#=#2Split d2</p>
    <p>d1 d2</p>
    <p>p1d1 d2</p>
    <p>Put</p>
    <p>d1</p>
    <p>Object#split#into#k#data#units</p>
    <p>Encoded#to#generate#r#parity# units</p>
    <p>(k+r)#units#cached#on#disRnct# servers#chosen#uniformly#at# random Caching#servers</p>
  </div>
  <div class="page">
    <p>EC4Cache'birds'eye'view:'Reads</p>
  </div>
  <div class="page">
    <p>EC4Cache'birds'eye'view:'Reads</p>
    <p>Read#from#(k#+#)#units#of#the# object#chosen#uniformly#at# random#</p>
    <p>. AddiRonal#reads</p>
    <p>Use#the#first#k#units#that#arrive</p>
  </div>
  <div class="page">
    <p>EC4Cache'birds'eye'view:'Reads</p>
    <p>k#=#2# r#=#1</p>
    <p>p1d1 d2</p>
    <p>Get X</p>
    <p>Read#from#(k#+#)#units#of#the# object#chosen#uniformly#at# random#</p>
    <p>. AddiRonal#reads</p>
    <p>Use#the#first#k#units#that#arrive</p>
    <p>Caching#servers</p>
  </div>
  <div class="page">
    <p>EC4Cache'birds'eye'view:'Reads</p>
    <p>k#=#2# r#=#1</p>
    <p>#=#1# k#+##=#3</p>
    <p>Read units</p>
    <p>p1d1 d2</p>
    <p>Get X</p>
    <p>Read#from#(k#+#)#units#of#the# object#chosen#uniformly#at# random#</p>
    <p>. AddiRonal#reads</p>
    <p>Use#the#first#k#units#that#arrive</p>
    <p>Caching#servers</p>
  </div>
  <div class="page">
    <p>EC4Cache'birds'eye'view:'Reads</p>
    <p>k#=#2# r#=#1</p>
    <p>#=#1# k#+##=#3</p>
    <p>Read units</p>
    <p>p1d1 d2</p>
    <p>Get X</p>
    <p>Read#from#(k#+#)#units#of#the# object#chosen#uniformly#at# random#</p>
    <p>. AddiRonal#reads</p>
    <p>Use#the#first#k#units#that#arrive</p>
    <p>Caching#servers</p>
  </div>
  <div class="page">
    <p>EC4Cache'birds'eye'view:'Reads</p>
    <p>k#=#2# r#=#1</p>
    <p>#=#1# k#+##=#3</p>
    <p>Read units</p>
    <p>p1d1 d2</p>
    <p>d2</p>
    <p>Get X</p>
    <p>p1</p>
    <p>Read#from#(k#+#)#units#of#the# object#chosen#uniformly#at# random#</p>
    <p>. AddiRonal#reads</p>
    <p>Use#the#first#k#units#that#arrive</p>
    <p>Caching#servers</p>
  </div>
  <div class="page">
    <p>EC4Cache'birds'eye'view:'Reads</p>
    <p>k#=#2# r#=#1</p>
    <p>#=#1# k#+##=#3</p>
    <p>Read units</p>
    <p>p1d1 d2</p>
    <p>d2</p>
    <p>Get X</p>
    <p>p1</p>
    <p>Read#from#(k#+#)#units#of#the# object#chosen#uniformly#at# random#</p>
    <p>. AddiRonal#reads</p>
    <p>Use#the#first#k#units#that#arrive</p>
    <p>Caching#servers</p>
  </div>
  <div class="page">
    <p>EC4Cache'birds'eye'view:'Reads</p>
    <p>k#=#2# r#=#1</p>
    <p>Decode</p>
    <p>#=#1# k#+##=#3</p>
    <p>Read units</p>
    <p>d1 d2</p>
    <p>p1d1 d2</p>
    <p>d2</p>
    <p>Get X</p>
    <p>p1</p>
    <p>Read#from#(k#+#)#units#of#the# object#chosen#uniformly#at# random#</p>
    <p>. AddiRonal#reads</p>
    <p>Use#the#first#k#units#that#arrive</p>
    <p>Decode#the#data#units</p>
    <p>Caching#servers</p>
  </div>
  <div class="page">
    <p>EC4Cache'birds'eye'view:'Reads</p>
    <p>k#=#2# r#=#1</p>
    <p>Decode</p>
    <p>#=#1# k#+##=#3</p>
    <p>Read units</p>
    <p>d1 d2</p>
    <p>p1d1 d2</p>
    <p>d2</p>
    <p>X</p>
    <p>Get X</p>
    <p>p1</p>
    <p>Combine</p>
    <p>Read#from#(k#+#)#units#of#the# object#chosen#uniformly#at# random#</p>
    <p>. AddiRonal#reads</p>
    <p>Use#the#first#k#units#that#arrive</p>
    <p>Decode#the#data#units</p>
    <p>Combine#the#decoded#units</p>
    <p>Caching#servers</p>
  </div>
  <div class="page">
    <p>Erasure'coding:'How'does'it'help?</p>
  </div>
  <div class="page">
    <p>Erasure'coding:'How'does'it'help?</p>
    <p>. SelecRve#replicaRon#allows#only#integer#control#</p>
    <p>. Erasure#coding#allows#fracRonal#control#</p>
    <p>. E.g.,#k#=#10#allows#control#in#of#mulRples#of#0.1</p>
  </div>
  <div class="page">
    <p>Erasure'coding:'How'does'it'help?</p>
    <p>. SelecRve#replicaRon#allows#only#integer#control#</p>
    <p>. Erasure#coding#allows#fracRonal#control#</p>
    <p>. E.g.,#k#=#10#allows#control#in#of#mulRples#of#0.1</p>
    <p>. Smaller#granularity#reads#help#to#smoothly#spread#load#</p>
    <p>. Analysis#on#a#certain#simplified#model:Theorem 1 For the setting described above:</p>
    <p>Var(LEC-Cache) Var(LSelective Replication)</p>
    <p>= 1</p>
    <p>k .</p>
    <p>Proof: Let w &gt; 0 denote the popularity of each of the files. The random variable LSelective Replication is distributed as a Binomial random variable with F trials and success probability 1</p>
    <p>S , scaled by w. On the other hand, LEC-Cache</p>
    <p>is distributed as a Binomial random variable with kF trials and success probability 1</p>
    <p>S , scaled by w</p>
    <p>k . Thus we have</p>
    <p>Var(LEC-Cache) Var(LSelective Replication)</p>
    <p>=</p>
    <p>w k</p>
    <p>2</p>
    <p>(kF) 1 S</p>
    <p>1  1</p>
    <p>S</p>
    <p>w2F 1 S</p>
    <p>1  1</p>
    <p>S</p>
    <p>= 1</p>
    <p>k ,</p>
    <p>thereby proving our claim.  Intuitively, the splitting action of EC-Cache leads to</p>
    <p>a smoother load distribution in comparison to selective replication. One can further extend Theorem 1 to accommodate a skew in the popularity of the objects. Such an extension leads to an identical result on the ratio of the variances. Additionally, the fact that each split of an object in EC-Cache is placed on a unique server further helps in evenly distributing the load, leading to even better load balancing.</p>
    <p>Next, we focus on how object splitting impacts read latencies. Under selective replication, a read request for an object is served by reading the object from a server. We first consider naive EC-Cache without any additional reads. Under naive EC-Cache, a read request for an object is served by reading k of its splits in parallel from k servers and performing a decoding operation. Let us also assume that the time taken for decoding is negligible compared to the time taken to read the splits.</p>
    <p>Intuitively, one may expect that reading splits in parallel from different servers will reduce read latencies due to the parallelism. While this reduction indeed occurs for the average/median latencies, the tail latencies behave in an opposite manner due to the presence of stragglers  one slow split read delays the completion of the entire read request.</p>
    <p>In order to obtain a better understanding of the aforementioned phenomenon, let us consider the following simplified model. Consider a parameter p 2 [0, 1] and assume that for any request, a server becomes a straggler with probability p, independent of all else. There are two primary contributing factors to the distributions of the latencies under selective replication and EC-Cache:</p>
    <p>(a) Proportion of stragglers: Under selective replication, the fraction of requests that hit stragglers is p. On the other hand, under EC-Cache, a read request for an object will face a straggler if any of the k servers from where splits are being read becomes a straggler. Hence,</p>
    <p>a higher fraction  1  (1  p)k</p>
    <p>of read requests can hit</p>
    <p>stragglers under naive EC-Cache. (b) Latency conditioned on absence/presence of strag</p>
    <p>glers: If a read request does not face stragglers, the time taken for serving a read request is significantly smaller under EC-Cache as compared to selective replication because splits can be read in parallel. On the other hand, in the presence of a straggler in the two scenarios, the time taken for reading under EC-Cache is about as large as that under selective replication.</p>
    <p>Putting the aforementioned two factors together we get that the relatively higher likelihood of a straggler under EC-Cache increases the number of read requests incurring a higher latency. The read requests that do not encounter any straggler incur a lower latency as compared to selective replication. These two factors explain the decrease in the median and mean latencies, and the increase in the tail latencies.</p>
    <p>In order to alleviate the impact on tail latencies, we use additional reads and late binding in EC-Cache. ReedSolomon codes have the property that any k of the collection of all splits of an object suffice to decode the object. We exploit this property by reading more than k splits in parallel, and using the k splits that are read first. It is well known that such additional reads help in mitigating the straggler problem and alleviate the affect on tail latencies [36, 82].</p>
    <p>We evaluated EC-Cache through a series of experiments on Amazon EC2 [1] clusters using synthetic workloads and traces from Facebook production clusters. The highlights of the evaluation results are:  For skewed popularity distributions, EC-Cache im</p>
    <p>proves load balancing over selective replication by 3.3 while using the same amount of memory. ECCache also decreases the median latency by 2.64 and the 99.9th percentile latency by 1.79 (6.2).</p>
    <p>For skewed popularity distributions and in the presence of background load imbalance, EC-Cache decreases the 99.9th percentile latency w.r.t. selective replication by 2.56 while maintaining the same benefits in median latency and load balancing as in the case without background load imbalance (6.3).</p>
    <p>For skewed popularity distributions and in the presence of server failures, EC-Cache provides a graceful degradation as opposed to the significant degradation in tail latency faced by selective replication. Specifically, EC-Cache decreases the 99.9th percentile latency w.r.t. selective replication by 2.8 (6.4).</p>
    <p>EC-Caches improvements over selective replication increase as object sizes increase in production traces;</p>
  </div>
  <div class="page">
    <p>Erasure'coding:'How'does'it'help?</p>
    <p>latency'</p>
    <p>. Read#parallelism#helps#reduce#median#latency#</p>
    <p>. Straggler#effect#hurts#tail#latency#(if#no#addiRonal#reads)</p>
  </div>
  <div class="page">
    <p>Erasure'coding:'How'does'it'help?</p>
    <p>latency'</p>
    <p>. Read#parallelism#helps#reduce#median#latency#</p>
    <p>. Straggler#effect#hurts#tail#latency#(if#no#addiRonal#reads)</p>
    <p>. Read#from#(k#+#)#and#use#the#first#k#that#arrive##</p>
    <p>. #=#1#oYen#sufficient#to#reign#in#tail#latency</p>
  </div>
  <div class="page">
    <p>Design'considera?ons</p>
  </div>
  <div class="page">
    <p>Design'considera?ons</p>
    <p>Storage#systems EC.Cache</p>
    <p>Space.efficient#fault#tolerance  Reduce#read#latency#</p>
    <p>Load#balance</p>
  </div>
  <div class="page">
    <p>Design'considera?ons</p>
    <p>Storage#systems EC.Cache</p>
  </div>
  <div class="page">
    <p>Design'considera?ons</p>
    <p>Storage#systems EC.Cache</p>
    <p>Rashmi#et#al.#SIGCOMM#2014,##Sathiamoorthy#et#al.#VLDB#2013,#Huang#et#al.#ATC!2012</p>
    <p>OpRmize#resource#usage# during#reconstrucRon# operaRons#</p>
    <p>Some#codes#do#not#have### any#k#out#of#(k+r)#property</p>
  </div>
  <div class="page">
    <p>Design'considera?ons</p>
    <p>Storage#systems EC.Cache</p>
    <p>Rashmi#et#al.#SIGCOMM#2014,##Sathiamoorthy#et#al.#VLDB#2013,#Huang#et#al.#ATC!2012</p>
    <p>No#reconstrucRon#operaRons# in#caching#layer;#data# persisted#in#underlying# storage#</p>
    <p>Any#k#out#of#(k+r)#property# helps#in#load#balancing#and# reducing#latency#when# reading#objects</p>
    <p>OpRmize#resource#usage# during#reconstrucRon# operaRons#</p>
    <p>Some#codes#do#not#have### any#k#out#of#(k+r)#property</p>
  </div>
  <div class="page">
    <p>Design'considera?ons</p>
    <p>Storage#systems EC.Cache</p>
  </div>
  <div class="page">
    <p>Design'considera?ons</p>
    <p>Storage#systems EC.Cache</p>
    <p>Some#systems#encode#across# objects#(e.g.,#HDFS.RAID);# some#within#(e.g.,#Ceph)#</p>
    <p>Does#not#affect#fault#tolerance#</p>
  </div>
  <div class="page">
    <p>Design'considera?ons</p>
    <p>Storage#systems EC.Cache</p>
    <p>Need#to#encode#within#objects# . To#spread#load#across#both# data#&amp;#parity#</p>
    <p>Encoding#across:#Very#high#BW# overhead#for#reading#object# using#pariRes</p>
    <p>Some#systems#encode#across# objects#(e.g.,#HDFS.RAID);# some#within#(e.g.,#Ceph)#</p>
    <p>Does#not#affect#fault#tolerance#</p>
    <p>Rashmi#et#al.#SIGCOMM#2014,##HotStorage#2013 17</p>
  </div>
  <div class="page">
    <p>Implementa?on</p>
    <p>EC.Cache#on#top#of#Alluxio#(formerly#Tachyon)#</p>
    <p>. Backend#caching#servers:#cache#data##unaware#of#erasure#coding##</p>
    <p>. EC.Cache#client#library:#all#read/write#logic#handled</p>
  </div>
  <div class="page">
    <p>Implementa?on</p>
    <p>EC.Cache#on#top#of#Alluxio#(formerly#Tachyon)#</p>
    <p>. Backend#caching#servers:#cache#data##unaware#of#erasure#coding##</p>
    <p>. EC.Cache#client#library:#all#read/write#logic#handled</p>
    <p>Reed.Solomon#code#</p>
    <p>. Any#k#out#of#(k+r)#property</p>
  </div>
  <div class="page">
    <p>Implementa?on</p>
    <p>EC.Cache#on#top#of#Alluxio#(formerly#Tachyon)#</p>
    <p>. Backend#caching#servers:#cache#data##unaware#of#erasure#coding##</p>
    <p>. EC.Cache#client#library:#all#read/write#logic#handled</p>
    <p>Reed.Solomon#code#</p>
    <p>. Any#k#out#of#(k+r)#property</p>
    <p>Intel#ISA.L#hardware#acceleraRon#library##</p>
    <p>. Fast#encoding#and#decoding</p>
  </div>
  <div class="page">
    <p>Evalua?on'set4up</p>
  </div>
  <div class="page">
    <p>Evalua?on'set4up</p>
    <p>Amazon#EC2</p>
    <p>25#backend#caching#servers#and#30#client#servers#</p>
  </div>
  <div class="page">
    <p>Evalua?on'set4up</p>
    <p>Amazon#EC2</p>
    <p>25#backend#caching#servers#and#30#client#servers#</p>
    <p>Object#popularity:#Zipf#distribuRon#with#high#skew</p>
  </div>
  <div class="page">
    <p>Evalua?on'set4up</p>
    <p>Amazon#EC2</p>
    <p>25#backend#caching#servers#and#30#client#servers#</p>
    <p>Object#popularity:#Zipf#distribuRon#with#high#skew</p>
    <p>EC.Cache#uses#k#=#10,###=#1#</p>
    <p>. BW#overhead#=#10%</p>
  </div>
  <div class="page">
    <p>Evalua?on'set4up</p>
    <p>Amazon#EC2</p>
    <p>25#backend#caching#servers#and#30#client#servers#</p>
    <p>Object#popularity:#Zipf#distribuRon#with#high#skew</p>
    <p>EC.Cache#uses#k#=#10,###=#1#</p>
    <p>. BW#overhead#=#10%</p>
    <p>Varying#object#sizes</p>
  </div>
  <div class="page">
    <p>Load'balancing</p>
    <p>D at</p>
    <p>a R</p>
    <p>ea d</p>
    <p>(G B</p>
    <p>)</p>
    <p>Servers Sorted by Load 0 50</p>
    <p>D at</p>
    <p>a R</p>
    <p>ea d</p>
    <p>(G B</p>
    <p>)</p>
    <p>Servers Sorted by Load</p>
    <p>SelecRve#ReplicaRon EC.Cache</p>
  </div>
  <div class="page">
    <p>Load'balancing</p>
    <p>D at</p>
    <p>a R</p>
    <p>ea d</p>
    <p>(G B</p>
    <p>)</p>
    <p>Servers Sorted by Load 0 50</p>
    <p>D at</p>
    <p>a R</p>
    <p>ea d</p>
    <p>(G B</p>
    <p>)</p>
    <p>Servers Sorted by Load</p>
    <p>SelecRve#ReplicaRon EC.Cache</p>
    <p>Percent#imbalance#metric:</p>
    <p>e.g., 5.5 at median for 100 MB objects with an upward trend (6.5).</p>
    <p>EC-Cache outperforms selective replication across a wide range of values of k, r, and  (6.6).</p>
    <p>Cluster Unless otherwise specified, our experiments use 55c4.8xlarge EC2 instances. 25 of these machines act as the backend servers for EC-Cache, each with 8 GB cache space, and 30 machines generate thousands of read requests to EC-Cache. All machines were in the same Amazon Virtual Private Cloud (VPC) with 10 Gbps enhanced networking enabled; we observed around 45 Gbps bandwidth between machines in the VPC using iperf.</p>
    <p>As mentioned earlier, we implemented EC-Cache on Alluxio [56], which, in turn, used Amazon S3 [2] as its persistence layer and runs on the 25 backend servers. We used DFS-Perf [5] to generate the workload on the 30 client machines.</p>
    <p>Metrics Our primary metrics for comparison are latency in reading objects and load imbalance across the backend servers.</p>
    <p>Given a workload, we consider mean, median, and high-percentile latencies. We measure improvements in latency as:</p>
    <p>Latency Improvement = Latency w/ Compared Scheme</p>
    <p>Latency w/ EC-Cache</p>
    <p>If the value of this latency improvement is greater (or smaller) than one, EC-Cache is better (or worse).</p>
    <p>We measure load imbalance using the percent imbalance metric  defined as follows:</p>
    <p>=</p>
    <p>L max</p>
    <p>Lavg?</p>
    <p>Lavg?</p>
    <p>100, (1)</p>
    <p>where L max</p>
    <p>is the load on the server which is maximally loaded and Lavg? is the load on any server under an oracle scheme, where the total load is equally distributed among all the servers without any overhead.  measures the percentage of additional load on the maximally loaded server as compared to the ideal average load. Because EC-Cache operates in the bandwidth-limited regime, the load on a server translates to the total amount of data read from that server. Lower values of  are better. Note that the percent imbalance metric takes into account the additional load introduced by EC-Cache due to additional reads.</p>
    <p>Setup We consider a Zipf distribution for the popularity of objects, which is common in many real-world object popularity distributions [20, 23, 56]. Specifically, we consider the Zipf parameter to be 0.9 (that is, high skew).</p>
    <p>Unless otherwise specified, we allow both selective replication and EC-Cache to use 15% memory overhead</p>
    <p>Mean Median 95th 99th 99.9th</p>
    <p>R ea</p>
    <p>d L</p>
    <p>at en</p>
    <p>cy (</p>
    <p>m s)</p>
    <p>Selective Replication</p>
    <p>EC-Cache</p>
    <p>Mean Median 95th 99th 99.9th</p>
    <p>R ea</p>
    <p>d L</p>
    <p>at en</p>
    <p>cy (</p>
    <p>m s)</p>
    <p>Selective Replication</p>
    <p>EC-Cache</p>
    <p>Figure 8: Read latencies under skewed popularity of objects.</p>
    <p>to handle the skew in the popularity of objects. Selective replication uses all the allowed memory overhead for handling popularity skew. Unless otherwise specified, EC-Cache uses k = 10 and  = 1. Thus, 10% of the allowed memory overhead is used to provide one parity to each object. The remaining 5% is used for handling popularity skew. Both schemes make use of the skew information to decide how to allocate the allowed memory among different objects in an identical manner: the number of replicas for an object under selective replication and the number of additional parities for an object under EC-Cache are calculated so as to flatten out the popularity skew to the extent possible starting from the most popular object, until the memory budget is exhausted.</p>
    <p>Moreover, both schemes use uniform random placement policy to evenly distribute objects (splits in case of EC-Cache) across memory servers.</p>
    <p>Unless otherwise specified, the size of each object considered in these experiments is 40 MB. We present results for varying object sizes observed in the Facebook trace in Section 6.5. In Section 6.6, we perform a sensitivity analysis with respect to all the above parameters.</p>
    <p>Furthermore, we note that while the evaluations presented here are for the setting of high skew in object popularity, EC-Cache outperforms selective replication in scenarios with low skew in object popularity as well. Under high skew, EC-Cache offers significant benefits in terms of load balancing and read latency. Under low skew, while there is not much to improve in load balancing, EC-Cache will still provide latency benefits.</p>
    <p>We begin by evaluating the performance of EC-Cache in the presence of skew in object popularity.</p>
    <p>Latency Characteristics Figure 8 compares the mean, median, and tail latencies of EC-Cache and selective replication. We observe that EC-Cache improves median and mean latencies by 2.64 and 2.52, respectively. EC-Cache outperforms selective replication at high per</p>
  </div>
  <div class="page">
    <p>Load'balancing</p>
    <p>D at</p>
    <p>a R</p>
    <p>ea d</p>
    <p>(G B</p>
    <p>)</p>
    <p>Servers Sorted by Load 0 50</p>
    <p>D at</p>
    <p>a R</p>
    <p>ea d</p>
    <p>(G B</p>
    <p>)</p>
    <p>Servers Sorted by Load</p>
    <p>SelecRve#ReplicaRon EC.Cache</p>
    <p>SR = 43.45% EC = 13.14%</p>
    <p>Percent#imbalance#metric:</p>
    <p>e.g., 5.5 at median for 100 MB objects with an upward trend (6.5).</p>
    <p>EC-Cache outperforms selective replication across a wide range of values of k, r, and  (6.6).</p>
    <p>Cluster Unless otherwise specified, our experiments use 55c4.8xlarge EC2 instances. 25 of these machines act as the backend servers for EC-Cache, each with 8 GB cache space, and 30 machines generate thousands of read requests to EC-Cache. All machines were in the same Amazon Virtual Private Cloud (VPC) with 10 Gbps enhanced networking enabled; we observed around 45 Gbps bandwidth between machines in the VPC using iperf.</p>
    <p>As mentioned earlier, we implemented EC-Cache on Alluxio [56], which, in turn, used Amazon S3 [2] as its persistence layer and runs on the 25 backend servers. We used DFS-Perf [5] to generate the workload on the 30 client machines.</p>
    <p>Metrics Our primary metrics for comparison are latency in reading objects and load imbalance across the backend servers.</p>
    <p>Given a workload, we consider mean, median, and high-percentile latencies. We measure improvements in latency as:</p>
    <p>Latency Improvement = Latency w/ Compared Scheme</p>
    <p>Latency w/ EC-Cache</p>
    <p>If the value of this latency improvement is greater (or smaller) than one, EC-Cache is better (or worse).</p>
    <p>We measure load imbalance using the percent imbalance metric  defined as follows:</p>
    <p>=</p>
    <p>L max</p>
    <p>Lavg?</p>
    <p>Lavg?</p>
    <p>100, (1)</p>
    <p>where L max</p>
    <p>is the load on the server which is maximally loaded and Lavg? is the load on any server under an oracle scheme, where the total load is equally distributed among all the servers without any overhead.  measures the percentage of additional load on the maximally loaded server as compared to the ideal average load. Because EC-Cache operates in the bandwidth-limited regime, the load on a server translates to the total amount of data read from that server. Lower values of  are better. Note that the percent imbalance metric takes into account the additional load introduced by EC-Cache due to additional reads.</p>
    <p>Setup We consider a Zipf distribution for the popularity of objects, which is common in many real-world object popularity distributions [20, 23, 56]. Specifically, we consider the Zipf parameter to be 0.9 (that is, high skew).</p>
    <p>Unless otherwise specified, we allow both selective replication and EC-Cache to use 15% memory overhead</p>
    <p>Mean Median 95th 99th 99.9th</p>
    <p>R ea</p>
    <p>d L</p>
    <p>at en</p>
    <p>cy (</p>
    <p>m s)</p>
    <p>Selective Replication</p>
    <p>EC-Cache</p>
    <p>Mean Median 95th 99th 99.9th</p>
    <p>R ea</p>
    <p>d L</p>
    <p>at en</p>
    <p>cy (</p>
    <p>m s)</p>
    <p>Selective Replication</p>
    <p>EC-Cache</p>
    <p>Figure 8: Read latencies under skewed popularity of objects.</p>
    <p>to handle the skew in the popularity of objects. Selective replication uses all the allowed memory overhead for handling popularity skew. Unless otherwise specified, EC-Cache uses k = 10 and  = 1. Thus, 10% of the allowed memory overhead is used to provide one parity to each object. The remaining 5% is used for handling popularity skew. Both schemes make use of the skew information to decide how to allocate the allowed memory among different objects in an identical manner: the number of replicas for an object under selective replication and the number of additional parities for an object under EC-Cache are calculated so as to flatten out the popularity skew to the extent possible starting from the most popular object, until the memory budget is exhausted.</p>
    <p>Moreover, both schemes use uniform random placement policy to evenly distribute objects (splits in case of EC-Cache) across memory servers.</p>
    <p>Unless otherwise specified, the size of each object considered in these experiments is 40 MB. We present results for varying object sizes observed in the Facebook trace in Section 6.5. In Section 6.6, we perform a sensitivity analysis with respect to all the above parameters.</p>
    <p>Furthermore, we note that while the evaluations presented here are for the setting of high skew in object popularity, EC-Cache outperforms selective replication in scenarios with low skew in object popularity as well. Under high skew, EC-Cache offers significant benefits in terms of load balancing and read latency. Under low skew, while there is not much to improve in load balancing, EC-Cache will still provide latency benefits.</p>
    <p>We begin by evaluating the performance of EC-Cache in the presence of skew in object popularity.</p>
    <p>Latency Characteristics Figure 8 compares the mean, median, and tail latencies of EC-Cache and selective replication. We observe that EC-Cache improves median and mean latencies by 2.64 and 2.52, respectively. EC-Cache outperforms selective replication at high per</p>
    <p>&gt;'3x'reduc?on'in'load'imbalance'metric 20</p>
  </div>
  <div class="page">
    <p>Read'latency</p>
    <p>Mean Median 95th 99th 99.9th</p>
    <p>R ea</p>
    <p>d L</p>
    <p>at en</p>
    <p>cy (</p>
    <p>m s)</p>
    <p>Selective Replication</p>
    <p>EC-Cache</p>
  </div>
  <div class="page">
    <p>Read'latency</p>
    <p>Median:#2.64x#improvement#</p>
    <p>99th#and#99.9th:#~1.75x#improvement</p>
    <p>Mean Median 95th 99th 99.9th</p>
    <p>R ea</p>
    <p>d L</p>
    <p>at en</p>
    <p>cy (</p>
    <p>m s)</p>
    <p>Selective Replication</p>
    <p>EC-Cache</p>
  </div>
  <div class="page">
    <p>Varying'object'sizes</p>
    <p>More'improvement'for'larger'object'sizes</p>
    <p>R ea</p>
    <p>d L</p>
    <p>at en</p>
    <p>cy (m</p>
    <p>s)</p>
    <p>Object Size (MB)</p>
    <p>EC-Cache (Median) Selective Replication (Median)</p>
    <p>Median#latency</p>
    <p>R ea</p>
    <p>d L</p>
    <p>at en</p>
    <p>cy (m</p>
    <p>s)</p>
    <p>Object Size (MB)</p>
    <p>EC-Cache (99th) Selective Replication (99th)</p>
    <p>Tail#latency</p>
  </div>
  <div class="page">
    <p>C D</p>
    <p>F</p>
    <p>Read Latency (ms)</p>
    <p>EC-Cache, =0 EC-Cache, =1 Selective Replication</p>
    <p>Role'of'addi?onal'reads'()</p>
  </div>
  <div class="page">
    <p>C D</p>
    <p>F</p>
    <p>Read Latency (ms)</p>
    <p>EC-Cache, =0 EC-Cache, =1 Selective Replication</p>
    <p>Significant degradation in tail latency without additional reads (i.e.,  = 0)</p>
    <p>Role'of'addi?onal'reads'()</p>
  </div>
  <div class="page">
    <p>Addi?onal'evalua?ons'in'the'paper</p>
    <p>With#background#network#imbalance##</p>
    <p>With#server#failures#</p>
    <p>Write#performance#</p>
    <p>SensiRvity#analysis#for#all#parameters</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>EC.Cache#</p>
    <p>. Cluster#cache#employing#erasure#coding#for#load#balancing#and# reducing#read#latencies#</p>
    <p>. Demonstrates#new#applicaRon#and#new#goals#for#which#erasure# coding#is#highly#effecRve</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>EC.Cache#</p>
    <p>. Cluster#cache#employing#erasure#coding#for#load#balancing#and# reducing#read#latencies#</p>
    <p>. Demonstrates#new#applicaRon#and#new#goals#for#which#erasure# coding#is#highly#effecRve</p>
    <p>ImplementaRon#on#Alluxio#</p>
    <p>EvaluaRon# . Load#balancing:#&gt;#3x#improvement# . Median#latency:#&gt;#5x#improvement## . Tail#latency:##&gt;#3x#improvement</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>EC.Cache#</p>
    <p>. Cluster#cache#employing#erasure#coding#for#load#balancing#and# reducing#read#latencies#</p>
    <p>. Demonstrates#new#applicaRon#and#new#goals#for#which#erasure# coding#is#highly#effecRve</p>
    <p>ImplementaRon#on#Alluxio#</p>
    <p>EvaluaRon# . Load#balancing:#&gt;#3x#improvement# . Median#latency:#&gt;#5x#improvement## . Tail#latency:##&gt;#3x#improvement</p>
    <p>Thanks!</p>
  </div>
</Presentation>
