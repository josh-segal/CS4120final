<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>R.P. Spillane, S. Gaikwad. M. Chinni,</p>
    <p>C.P. Wright, E. Zadok</p>
    <p>Stony Brook University</p>
    <p>http://www.fsl.cs.sunysb.edu/</p>
    <p>Enabling System Transactions</p>
    <p>via Lightweight Kernel Extensions</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>What is the design complexity of system</p>
    <p>transactions implemented in the VFS?</p>
    <p>Low</p>
    <p>100 lines of code added to page writeback</p>
    <p>4000 lines of module code (log implementation)</p>
    <p>What is the performance?</p>
    <p>Valor: 35% overhead on top of theoretical</p>
    <p>best, compared to</p>
    <p>104% overhead for an efficient user-level</p>
    <p>alternative</p>
  </div>
  <div class="page">
    <p>System Transaction</p>
    <p>Process 1</p>
    <p>TIDsys_tbegin(...)</p>
    <p>write(TID,...)</p>
    <p>unlink(TID,...)</p>
    <p>sys_tabort(TID) f1</p>
    <p>/</p>
    <p>f2</p>
    <p>/</p>
    <p>f1 f2</p>
    <p>FS State: foo FS State: foo</p>
    <p>System Calls</p>
  </div>
  <div class="page">
    <p>Design Feasibility</p>
    <p>Transparency &amp;</p>
    <p>Performance</p>
    <p>Quicksilver,</p>
    <p>TxF</p>
    <p>Berkeley DB,</p>
    <p>Stasis</p>
    <p>The Design Spectrum</p>
    <p>Valor side-steps the traditional trade-off</p>
    <p>by working with the Kernels page cache</p>
    <p>in a general way.</p>
    <p>Valor</p>
    <p>Amino</p>
    <p>KBDB</p>
  </div>
  <div class="page">
    <p>Valors Process Txn Model</p>
    <p>Transactional Model</p>
    <p>Supported Operations:</p>
    <p>dirtying a page</p>
    <p>appending to a file, modifying an inode</p>
    <p>modifying a directory</p>
    <p>Locking:</p>
    <p>directory locks, inode locks</p>
    <p>page range locks for overwrites</p>
    <p>intent locks for directory renames</p>
  </div>
  <div class="page">
    <p>Asynchronous By Default</p>
    <p>ACI (no D w/o tsync)</p>
    <p>Similar to asynchronous write(2) with</p>
    <p>fsync(2)</p>
    <p>Same purpose (performance increase)</p>
    <p>Requires page cache for files updated</p>
    <p>transactionally</p>
  </div>
  <div class="page">
    <p>Valor Design</p>
    <p>Modify page writeback to support simple</p>
    <p>write ordering</p>
    <p>Implement an ARIES style undo/redo</p>
    <p>log module for FS-operations</p>
  </div>
  <div class="page">
    <p>write(TID, )</p>
    <p>Page Dirtying: No Txns</p>
    <p>Process 1</p>
    <p>write(TID, )</p>
    <p>OK bad Old Page</p>
    <p>New Page</p>
    <p>LEGEND:</p>
    <p>Uh-oh</p>
  </div>
  <div class="page">
    <p>log_append(TID, )</p>
    <p>write(TID, )</p>
    <p>log_append(TID, )</p>
    <p>write(TID, )</p>
    <p>Page Dirtying: With Txns</p>
    <p>Process 1 Old Page</p>
    <p>New Page</p>
    <p>LEGEND:</p>
    <p>U/R Page</p>
  </div>
  <div class="page">
    <p>Current Kernel Design</p>
    <p>Ext3</p>
    <p>Ext2</p>
    <p>XFS</p>
    <p>ZFS</p>
    <p>Page CacheOld Page</p>
    <p>New Page</p>
    <p>U/R Page</p>
    <p>LEGEND:</p>
    <p>Uh-oh</p>
    <p>Process 2</p>
    <p>write(TID,)</p>
    <p>log_append(TID,)</p>
    <p>Page Writeback</p>
  </div>
  <div class="page">
    <p>Page Cache</p>
    <p>What DBs Do</p>
    <p>Ext2</p>
    <p>XFS</p>
    <p>ZFS</p>
    <p>Page Cache II: The Wrath of Khan</p>
    <p>(fsync)</p>
    <p>Disk Cache Flush</p>
  </div>
  <div class="page">
    <p>Simple Write Ordering</p>
    <p>FS1</p>
    <p>FS2</p>
    <p>FS3</p>
    <p>FS4</p>
    <p>Page Cache Old Page</p>
    <p>New Page</p>
    <p>U/R Page</p>
    <p>LEGEND:</p>
    <p>Valor</p>
  </div>
  <div class="page">
    <p>Log Module</p>
    <p>Log File</p>
    <p>U/R Page 1</p>
    <p>U/R Page 5</p>
    <p>U/R Page 4</p>
    <p>U/R Page 3</p>
    <p>U/R Page 21 2 3</p>
    <p>State File</p>
    <p>U/R,1 U/R,1 U/R,1</p>
    <p>U/R,1 U/R,1 C,1</p>
    <p>U/R,1 U/R,1 U/R,1</p>
    <p>U/R,1 U/R,1 C,1</p>
    <p>Process 2</p>
    <p>tbegin(TID,)</p>
    <p>tlog(TID,)</p>
    <p>write(TID,)</p>
    <p>page writeback</p>
    <p>tlog(TID,)</p>
    <p>write(TID,)</p>
    <p>tresolve(TID,)</p>
    <p>page writeback</p>
    <p>page writeback</p>
    <p>Disk</p>
    <p>Valor Module</p>
    <p>Record Maps</p>
  </div>
  <div class="page">
    <p>Atomicity Argument</p>
    <p>Transition from pre-writeback to post</p>
    <p>writeback disk state atomically iff</p>
    <p>All writes preceded by sys_log_append</p>
    <p>Simple write ordering is implemented</p>
    <p>writes to a single sector are atomic</p>
    <p>Valor satisfies the top 2 constraints</p>
    <p>A supported hard disk satisfies the third</p>
  </div>
  <div class="page">
    <p>Performing Recovery</p>
    <p>Two kinds of recovery are supported:</p>
    <p>System Recovery</p>
    <p>Application Recovery (per-process abort)</p>
    <p>Standard recovery process:</p>
    <p>Reconstruct RAM state from log</p>
    <p>In reverse LSN order commit/abort landed</p>
    <p>transactions</p>
    <p>Perform a page writeback</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>We must compare against traditional</p>
    <p>asynchronous FSes</p>
    <p>benchmark against asynchronous ext3</p>
    <p>do serial transfer benchmarks for large files</p>
    <p>We turn off synchronous transactions for</p>
    <p>two other controls (for fairness)</p>
    <p>FS built on top of Stasis</p>
    <p>FS built on top of Berkeley DB</p>
  </div>
  <div class="page">
    <p>Mock ARIES Benchmark</p>
    <p>Important lower bound (not tight)</p>
    <p>Log</p>
    <p>Disk</p>
    <p>MT-ow-noread</p>
    <p>Log</p>
    <p>Disk</p>
    <p>MT-ow</p>
    <p>Log</p>
    <p>Disk</p>
    <p>MT-ow-finite</p>
  </div>
  <div class="page">
    <p>Mock ARIES Benchmark</p>
    <p>E la</p>
    <p>p s e d</p>
    <p>T im</p>
    <p>e (</p>
    <p>s e c )</p>
    <p>Wait</p>
    <p>User</p>
    <p>System</p>
  </div>
  <div class="page">
    <p>Serial Overwrite</p>
    <p>E la</p>
    <p>p s e d</p>
    <p>T im</p>
    <p>e (</p>
    <p>s e c )</p>
    <p>Size of Serial Transfer (MiB)</p>
    <p>BDB</p>
    <p>Stasis</p>
    <p>Valor</p>
    <p>Ext3</p>
    <p>Transaction size: 16 pages</p>
  </div>
  <div class="page">
    <p>Transaction Throughput</p>
    <p>E la</p>
    <p>p s e d</p>
    <p>T im</p>
    <p>e (</p>
    <p>s e c )</p>
    <p>Size of Transaction (pages)</p>
    <p>BDB</p>
    <p>Stasis</p>
    <p>Valor</p>
    <p>Ext3Stasis Heel</p>
    <p>Valor Heel</p>
    <p>BDB Heel</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>System transactions are feasible</p>
    <p>Valor achieves good overhead</p>
    <p>Minimal changes to existing kernels</p>
  </div>
  <div class="page">
    <p>Limitations/Future Work</p>
    <p>Limitations</p>
    <p>Locking slows interleaved writes to the</p>
    <p>same page</p>
    <p>Some FSes/Disks do not fsync() when</p>
    <p>asked to</p>
    <p>Future Work</p>
    <p>Explore use of logging device as a</p>
    <p>coordinator in a transactional disk array</p>
  </div>
  <div class="page">
    <p>R.P. Spillane, S. Gaikwad. M. Chinni,</p>
    <p>C.P. Wright, E. Zadok</p>
    <p>Stony Brook University</p>
    <p>http://www.fsl.cs.sunysb.edu/</p>
    <p>Q&amp;A Enabling System Transactions via</p>
    <p>Lightweight Kernel Extensions</p>
  </div>
  <div class="page">
    <p>TxF</p>
    <p>TxF is Microsofts transactional file</p>
    <p>system</p>
    <p>Motivation: program installation, system</p>
    <p>updates, website updates</p>
    <p>Pros</p>
    <p>Backed by Microsoft</p>
    <p>Cons</p>
    <p>Specific to NTFS</p>
  </div>
  <div class="page">
    <p>Isolation</p>
    <p>Extended mandatory locking</p>
    <p>Allows locking of directories</p>
    <p>Do not have to set group exec/setgid bits</p>
    <p>Locking permissions</p>
    <p>Let users decide if a file can be locked</p>
    <p>All processes acquire locks</p>
    <p>Regular processes hold only for the syscall</p>
    <p>Lock inheritance</p>
    <p>Allow multi-process transactions</p>
  </div>
  <div class="page">
    <p>Valor != Journaling</p>
    <p>Journaling FSes good at fast recovery</p>
    <p>but are too special-purpose:</p>
    <p>No-Steal Caching</p>
    <p>all state modified by a txn. must remain in memory</p>
    <p>until commit/abort</p>
    <p>Non-Modular Design</p>
    <p>does not handle rollback of VFS and page caches,</p>
    <p>just disk-state on boot</p>
  </div>
</Presentation>
