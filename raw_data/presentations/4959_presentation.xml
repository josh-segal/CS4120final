<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Emmett Witchel Josh Cates Krste Asanovic MIT Lab for Computer Science</p>
    <p>Hig h Pe rf o rm an c e Swit c h in g a n d R o u tin g Te leco m C en ter Wo rksh op : S ep t 4, 19 97.</p>
    <p>Mondrian Memory Protection</p>
  </div>
  <div class="page">
    <p>Software Has Needs</p>
    <p>Plug-ins have won as the extensible system model.  Fast &amp; data sharing</p>
    <p>is convenient.</p>
    <p>Software is written for a model not directly supported by current hardware and OSes.  No protection.</p>
    <p>Single Address Space</p>
    <p>Kernel vfat.o</p>
    <p>RW</p>
    <p>RO</p>
    <p>EX</p>
    <p>NO</p>
  </div>
  <div class="page">
    <p>Plug-ins need access to different, small data structures.  Word level protection at</p>
    <p>word boundaries.</p>
    <p>Placing every possibly shared data on its own page is very difficult.  Some data structures</p>
    <p>imposed by hardware.</p>
    <p>Currently, Protection Is Not Provided</p>
    <p>Kernel vfat.o</p>
    <p>RW</p>
    <p>RO</p>
    <p>EX</p>
    <p>NO</p>
    <p>Single Address Space</p>
  </div>
  <div class="page">
    <p>Mondrian Memory Protection</p>
    <p>Single address space split into multiple protection domains.</p>
    <p>A domain owns a region of the address space and can export privileges to another domain  Similar to mprotect.</p>
    <p>Kernel (PD-ID=0) vfat.o (PD-ID=1)</p>
    <p>RW</p>
    <p>RO</p>
    <p>EX</p>
    <p>NO</p>
    <p>Single Address Space</p>
  </div>
  <div class="page">
    <p>Word Level Protection Is Not New</p>
    <p>Segmentation is a traditional solution.  + Provides word-level protection.  - Explicit segment registers [B5000,x86]  - Non-linear addressing</p>
    <p>Capability based machines.  + Fine-grained sharing.  - Revocation difficult [System/38, M</p>
    <p>machine].  - Different protection for different</p>
    <p>domains via shared capability is hard.</p>
  </div>
  <div class="page">
    <p>MMP is a New Solution</p>
    <p>Segmentation semantics without the problems.  MMP provides fine-grained protection</p>
    <p>and data sharing.  MMP uses linear addressing.  MMP is compatible with existing ISAs  MMP has no segment registers.  MMP has easy perm. revocation.  MMP does not have tagged pointers.</p>
    <p>MMP is all the fun of segmentation without the headaches.</p>
  </div>
  <div class="page">
    <p>Theres No Free Lunch</p>
    <p>MMP requires extra memory to store permissions tables.  Good engineering keeps tables small.</p>
    <p>MMP requires CPU &amp; memory system resources to access tables.  Good engineering provides an</p>
    <p>effective cache for permissions information so table access is infrequent.</p>
  </div>
  <div class="page">
    <p>Segmentation Timeline</p>
    <p>VA - constructed by processor.</p>
    <p>LA - post segmentation.</p>
    <p>PA - post TLB translation.</p>
    <p>Protection</p>
    <p>Fault</p>
    <p>Linear</p>
    <p>Addr.</p>
    <p>VA Seg.</p>
    <p>Regs TLB</p>
    <p>(opt.)</p>
    <p>PA</p>
  </div>
  <div class="page">
    <p>MMP Timeline</p>
    <p>MMP checks virtual addresses.  Protection check only needs to happen</p>
    <p>before instruction graduation (not in critical path).</p>
    <p>Protection</p>
    <p>Fault</p>
    <p>Linear</p>
    <p>Addr.</p>
    <p>VA TLB</p>
    <p>(opt.)</p>
    <p>PA</p>
    <p>MMP</p>
  </div>
  <div class="page">
    <p>MMP Implementation Tables</p>
    <p>Memory Permissions</p>
    <p>Table</p>
    <p>Refill  Lets look</p>
    <p>at the table in memory.</p>
    <p>CPU Protection</p>
    <p>Lookaside</p>
    <p>Buffer</p>
    <p>Domain ID (PD-ID)</p>
    <p>Perm. Table Base</p>
    <p>Permissions</p>
    <p>Table</p>
  </div>
  <div class="page">
    <p>Permission Table Requirements</p>
    <p>Entries should be compact.  2 bits of permissions data per word</p>
    <p>(none, read-only, read-write, executeread).</p>
    <p>Should represent different sized regions efficiently.  Any number of words at a word</p>
    <p>boundary.</p>
    <p>Organized like a hierarchical page table (trie).</p>
  </div>
  <div class="page">
    <p>Representing Large Regions Efficiently</p>
    <p>Upper level entries are typed, enabling large entries.</p>
    <p>P D</p>
    <p>D P</p>
    <p>D</p>
    <p>P D D</p>
    <p>D</p>
    <p>D</p>
    <p>P D</p>
    <p>D</p>
    <p>D P</p>
  </div>
  <div class="page">
    <p>Representing Large Regions Efficiently</p>
    <p>Upper level entries are typed, enabling large entries.</p>
    <p>P D</p>
    <p>D P</p>
    <p>D</p>
    <p>P D D</p>
    <p>D</p>
    <p>D</p>
    <p>D</p>
    <p>D</p>
    <p>D P</p>
    <p>D</p>
  </div>
  <div class="page">
    <p>Representing Large Regions Efficiently</p>
    <p>Upper level entries are typed, enabling large entries.</p>
    <p>P D</p>
    <p>D P</p>
    <p>D</p>
    <p>P D D</p>
    <p>D</p>
    <p>D</p>
    <p>D</p>
    <p>D</p>
    <p>D</p>
    <p>D D</p>
  </div>
  <div class="page">
    <p>Compressing The Entry Format</p>
    <p>Most words have same perm. as neighbor.  Compressed</p>
    <p>entries represent longer, overlapping regions.</p>
    <p>Compressed entries are the same size, but represent more information.</p>
    <p>Naive</p>
    <p>Entries</p>
    <p>Compressed</p>
    <p>Entries</p>
    <p>Memory</p>
    <p>Words</p>
  </div>
  <div class="page">
    <p>MMP Implementation  PLB</p>
    <p>Memory Permissions</p>
    <p>Table</p>
    <p>Refill  Lets look</p>
    <p>at the PLB.</p>
    <p>CPU Protection</p>
    <p>Lookaside</p>
    <p>BufferPerm. Table Base</p>
    <p>Protection</p>
    <p>Lookaside</p>
    <p>Buffer</p>
    <p>Domain ID (PD-ID)</p>
  </div>
  <div class="page">
    <p>PLB Requirements</p>
    <p>The PLB caches protection table entries tagged by Domain-ID.  Like a TLB but without translation.  Like a TLB but variable ranges, not just</p>
    <p>page sizes.</p>
  </div>
  <div class="page">
    <p>Instruction</p>
    <p>+</p>
    <p>RS IMM PLB</p>
    <p>Tag Perm Tab. Ent.</p>
    <p>OP</p>
    <p>Addr Regs</p>
    <p>CKRead/Write</p>
    <p>OK Fault</p>
    <p>Access</p>
    <p>Perm.</p>
    <p>Table in</p>
    <p>Memory</p>
    <p>Hit? NoYes</p>
    <p>PLB Permissions Check Flow</p>
    <p>PD-ID</p>
    <p>PC checked for execute permissions.</p>
  </div>
  <div class="page">
    <p>PLB Requirements</p>
    <p>PLB taskindex permissions data from different sized memory chunks.  Loads from different addresses can get</p>
    <p>permissions information from different levels in the table.</p>
    <p>D vs. 1st level or 2nd level</p>
  </div>
  <div class="page">
    <p>PLB index implemented by ternary CAM.  Like superpages in a TLB, but protection</p>
    <p>superpages are easy for OSthey dont require lots of contiguous physical memory.</p>
    <p>PLB index limited to power-of-two size.</p>
    <p>Protection Look aside Buffer (PLB)</p>
    <p>PLB (Xs are dont-care bits) Tag (26 bits) Perm. Table Ent.</p>
    <p>D</p>
    <p>D</p>
    <p>The compressed format has intermediate number of dont-care bits, and non power-of-two sized regions.</p>
    <p>PD-ID 0 0 0</p>
  </div>
  <div class="page">
    <p>MMP Implementation  Sidecars</p>
    <p>Memory Permissions</p>
    <p>Table</p>
    <p>Refill  Lets look</p>
    <p>at the the sidecars.</p>
    <p>CPU Protection</p>
    <p>Lookaside</p>
    <p>BufferPerm. Table Base</p>
    <p>Sidecarsrefill Sidecars</p>
    <p>Domain ID (PD-ID)</p>
  </div>
  <div class="page">
    <p>Register Sidecars  Sidecars allow permissions checks</p>
    <p>without accessing the PLB (register level cache).  Base, bounds and permissions</p>
    <p>information in sidecar.  Lower access energy for sidecar than</p>
    <p>PLB.</p>
    <p>Increased hit rate with compressed entry format because non power-oftwo sized regions are not fully indexed by PLB.  Fewer table accesses than PLB alone.</p>
  </div>
  <div class="page">
    <p>Instruction</p>
    <p>+</p>
    <p>RS IMMOP</p>
    <p>Addr Regs</p>
    <p>CKRead/Write</p>
    <p>OK Fault</p>
    <p>Access</p>
    <p>PLB</p>
    <p>Sidecar Permissions Check Flow</p>
    <p>Base Bound Perm</p>
    <p>Sidecar Regs</p>
    <p>Base  Addr.  Bound</p>
    <p>NoYes</p>
    <p>PC has its own sidecar.</p>
  </div>
  <div class="page">
    <p>Coarse-Grained Evaluation</p>
    <p>Coarse-grained protection equivalent to current UNIX semantics (text, rodata, data, bss, stack).  One protection domain.</p>
    <p>Application mix from SPEC2000, SPEC95, Java, Media bench, and Olden.  Compiled with gcc O3 (egcs-1.0.3)  Address traces fed to MMP simulator.</p>
  </div>
  <div class="page">
    <p>Coarse-Grained Protection Results</p>
    <p>Ref. to MMP tables</p>
    <p>Application refs 0.00-0.56% 0.00-2.59%</p>
    <p>Table size / App. data 0.04-0.62% 0.02-0.22%</p>
    <p>Sidecar miss rate 1-40%(12%) -</p>
    <p>Comparison with TLB is just for scale, a TLB is still useful with MMP.  MMP is 2 bits of protection, not 4</p>
    <p>bytes of translation + protection.</p>
  </div>
  <div class="page">
    <p>Fine-Grained Evaluation</p>
    <p>Fine-grained protection: Every malloc-ed region goes in its own protection region with inaccessible header words between regions.  malloc library is protected subsystem.</p>
    <p>Very demanding evaluation, almost worst case.  Protected subsystems will likely not</p>
    <p>have to export every region malloc-ed.  Functionality similar to purify.</p>
  </div>
  <div class="page">
    <p>Fine-Grained Protection Results 60 Entry PLB</p>
    <p>Ref. to MMP tables</p>
    <p>Application refs 0.0- 7.5% (0.1-19%)</p>
    <p>Table size / App. data 0.4- 8.3% Table references eliminated by sidecars</p>
    <p>Time and space overheads very small.  Results include table updates.  Minimal cache disturbance (study in</p>
    <p>paper).  Sidecar helps eliminate table references.  Paper compares different entry formats.</p>
  </div>
  <div class="page">
    <p>MMP Timeline With Translation</p>
    <p>MMP can add an offset to the VA, providing translation.  Protection check happens on pre</p>
    <p>translated address.  Address generation is 3-to-1 add on</p>
    <p>critical path.</p>
    <p>Protection</p>
    <p>Fault</p>
    <p>Linear</p>
    <p>Addr.</p>
    <p>VA TLB</p>
    <p>(opt.)</p>
    <p>PA</p>
    <p>MMP</p>
    <p>MMP</p>
    <p>Trans</p>
    <p>Unit</p>
  </div>
  <div class="page">
    <p>Kernel a user</p>
    <p>Implement zerocopy networking.</p>
    <p>Translation lets memory discontiguous in one domain appear contiguous in another.</p>
    <p>No cache aliasing problem, translation before cache access.</p>
    <p>Why Translation?</p>
    <p>Body 1</p>
    <p>Head 1</p>
    <p>Body 0</p>
    <p>Head 0</p>
    <p>Body 0</p>
    <p>Body 1</p>
    <p>Single Address Space</p>
  </div>
  <div class="page">
    <p>Implementing Translation  MMP entry format is flexible, allowing</p>
    <p>additional pointer types.  Pointer to permissions and byte-level</p>
    <p>translation offset.</p>
    <p>Translation information held in sidecar.</p>
    <p>Variable sized pool of translation</p>
    <p>records</p>
    <p>+0x9583F</p>
    <p>PT</p>
    <p>New ptr. type</p>
  </div>
  <div class="page">
    <p>MMP Networking Results  Simulated a zero-copy networking</p>
    <p>implementation that uses unmodified read system call.  Web client receiving 500KB.</p>
    <p>Eliminates 52% of memory references relative to a copying implementation.  Win includes references to update and</p>
    <p>read the permissions tables.  46% of reference time saved.</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>Capabilities [Dennis65, IBM AS400].</p>
    <p>Domain Pages [Koldinger ASPLOS92].</p>
    <p>Guarded pointers [Carter ASPLOS94].</p>
    <p>Guarded page tables [Liedke 94].</p>
    <p>IP longest prefix match [Waldvogel TOCS 01].</p>
  </div>
  <div class="page">
    <p>Possible Applications  Safe kernel modules.</p>
    <p>Safe plug-ins for apache and web browsers.</p>
    <p>Eliminate memory copying from kernel calls.  Provide specialized kernel entry points.</p>
    <p>Support millions of threads, each with a tiny stack.</p>
    <p>Implement C++ const.</p>
    <p>Use meta-data for cache coherence.</p>
    <p>Make each function its own protection domain.</p>
    <p>Buffer overrun much more difficult.</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Fine-grained protection is the solution for safe, extensible systems.</p>
    <p>Fine-grained protection can be provided efficiently.</p>
    <p>Mondrian Memory Protection will enable more robust software.  It matches the way we think about code.  It can be adopted incrementally (e.g., 1st</p>
    <p>just change malloc library).</p>
  </div>
</Presentation>
