<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Unstructuring User Preferences Efficient Non-parametric</p>
    <p>Utility Revelation</p>
    <p>Carmel Domshlak Thorsten Joachims (Technion) (Cornell)</p>
  </div>
  <div class="page">
    <p>Database</p>
    <p>Some preference information</p>
    <p>Evaluating alternatives in terms of user preferences.</p>
    <p>List of alternatives that suit users</p>
    <p>preference best.</p>
    <p>General scheme</p>
    <p>X = {X1, . . . , Xn}</p>
    <p>X = Dom(Xi)</p>
  </div>
  <div class="page">
    <p>Statements of ordinal preference</p>
    <p>DBMS</p>
    <p>S = {s1, . . . , sm}</p>
    <p>I prefer Continental to Delta ...</p>
    <p>In a mini-van I prefer automatic transmission ...</p>
    <p>Soup is more important to me than desert ...</p>
  </div>
  <div class="page">
    <p>High-order I prefer winter in Haifa to winter in Edinburgh more than I prefer summer in Edinburgh to summer in Haifa.</p>
    <p>S = {s1, . . . , sm}</p>
    <p>Classificatory - Winter is worst. - Haifa is gorgeous.</p>
    <p>Comparative Winter in Haifa is better than in Edinburgh.</p>
    <p>Statements of ordinal preference</p>
  </div>
  <div class="page">
    <p>S = {s1, . . . , sm}</p>
    <p>L is some logical language over X,</p>
    <p>i, i  L, and</p>
    <p>!i  {&quot;, #, }.</p>
    <p>S = {s1, . . . , sm}</p>
    <p>= {1 !1 1, 2 !2 2,    , m !m m}</p>
    <p>(x3  x8) &quot; (x3  x8)</p>
    <p>Statements of ordinal preference</p>
  </div>
  <div class="page">
    <p>Ordinal utility function</p>
    <p>Evaluating alternatives in terms of user preferences.</p>
    <p>List of alternatives that suit users</p>
    <p>preference best.</p>
    <p>DBMS</p>
    <p>S = {s1, . . . , sm}</p>
    <p>The ordinal preferences of the user can be viewed as a (possibly weak, possibly partial) binary preference relation P over .</p>
    <p>Our task is to provide the user with the content of DB, ordered consistently with P.</p>
    <p>Order DB using:</p>
    <p>x, x  X . U (x)  U (x)  P %|= x &amp; x</p>
    <p>U : X  R</p>
  </div>
  <div class="page">
    <p>X = {X1, . . . , Xn}</p>
    <p>Specifying such an ordinal utility function U can be expensive since its domain is exponential in the number of attributes .</p>
    <p>Previous works on ordinal utility revelation (in mathematical economics and AI) searched for special conditions under which U can be represented compactly.</p>
    <p>U : X  R</p>
    <p>The curse of dimensionality</p>
  </div>
  <div class="page">
    <p>Independence-based methodology</p>
  </div>
  <div class="page">
    <p>How can ordinal utility revelation be generalized to the case where user preferences</p>
    <p>pose no significant independence structure on X,</p>
    <p>or they do, but</p>
    <p>the system is not provided with any independence information?</p>
    <p>The very basic question</p>
  </div>
  <div class="page">
    <p>The utility revelation machinery should be completely non-parametric, that is free of the explicit assumptions about the structure of the user preferences.</p>
    <p>The user should be able to provide arbitrary qualitative preference expressions S over X.</p>
    <p>Both utility revelation and using the revealed function should be computationally efficient, even in cases where user preferences pose no significant independence structure on X whatsoever.</p>
    <p>I have a dream!</p>
    <p>In short, we show that this is not a hopeless goal!</p>
  </div>
  <div class="page">
    <p>Basic idea: Since no independence information in the original space X should be expected, may be we should work in a different space in which no such information is required?</p>
    <p>The desire for such a move was there before:</p>
    <p>Can one recast the underlying set [of attributed alternatives] in terms of a different span of dimensions such that the utility function becomes linear? If so, can one find new linearizing dimensions that also mean something to human interpreters?</p>
    <p>J. Doyle, Prospects for preferences, 2004.</p>
    <p>Escaping structure requirements</p>
  </div>
  <div class="page">
    <p>: X ! F = R 2 2n</p>
    <p>fi 11  val(fi)  {x1, x1,    , xn, xn}</p>
    <p>X1</p>
    <p>X2</p>
    <p>x1</p>
    <p>x2</p>
    <p>x2</p>
    <p>x1</p>
    <p>x1x2</p>
    <p>x1x2</p>
    <p>x1x2</p>
    <p>x1x2</p>
    <p>F = {f1,    , f22n}</p>
  </div>
  <div class="page">
    <p>x  X , fi  F :</p>
    <p>(x)[i] =</p>
    <p>{ 1, val(fi)  x</p>
    <p>X1</p>
    <p>X2</p>
    <p>x1</p>
    <p>x2</p>
    <p>x2</p>
    <p>x1</p>
    <p>x1x2</p>
    <p>x1x2</p>
    <p>x1x2</p>
    <p>x1x2</p>
    <p>x = x1x2</p>
  </div>
  <div class="page">
    <p>Generality of F</p>
    <p>Can one recast the underlying set [of attributed alternatives] in terms of a different span of dimensions such that the utility function becomes linear? If so, can one find new linearizing dimensions that also mean something to human interpreters?</p>
    <p>J. Doyle, Prospects for preferences, 2004.</p>
  </div>
  <div class="page">
    <p>U ((x)) = 2 2n</p>
    <p>i=1</p>
    <p>wi (x)[i]</p>
    <p>Theorem: Any preference ordering P over X is additively decomposable in F.</p>
    <p>Generality of F</p>
    <p>Can one recast the underlying set [of attributed alternatives] in terms of a different span of dimensions such that the utility function becomes linear? If so, can one find new linearizing dimensions that also mean something to human interpreters?</p>
    <p>J. Doyle, Prospects for preferences, 2004.</p>
    <p>But is it of any practical use?</p>
  </div>
  <div class="page">
    <p>Interpretation of human statements</p>
    <p>S = {s1, . . . , sm}</p>
    <p>L is some logical language over X,</p>
    <p>i, i  L, and</p>
    <p>!i  {&quot;, #, }.</p>
    <p>S = {s1, . . . , sm}</p>
    <p>= {1 !1 1, 2 !2 2,    , m !m m}</p>
    <p>(x3  x8) &quot; (x3  x8)</p>
  </div>
  <div class="page">
    <p>Statement interpretation in F</p>
    <p>!</p>
    <p>Variables of : X  X.</p>
    <p>Models of : M ()  Dom(X).</p>
    <p>(X1  X2) &quot; (</p>
    <p>X3)</p>
    <p>X = {X1, X2}, X = {X3}.</p>
    <p>M () = {x1x2, x1x2, x1x2}, M () = {x3}.</p>
  </div>
  <div class="page">
    <p>Statement interpretation in F</p>
    <p>!</p>
    <p>Variables of : X  X.</p>
    <p>Models of : M ()  Dom(X).</p>
    <p>(X1  X2) &quot; (</p>
    <p>X3)</p>
    <p>X = {X1, X2}, X = {X3}.</p>
    <p>M () = {x1x2, x1x2, x1x2}, M () = {x3}.</p>
    <p>For each m  M (), m  M ():</p>
    <p>fi:val(fi)2m</p>
    <p>wi &gt;</p>
    <p>fj :val(fj )2m</p>
    <p>wj</p>
    <p>wx1 + wx2 + wx1x2 &gt; wx3</p>
    <p>wx1 + wx2 + wx1x2 &gt; wx3</p>
    <p>wx1 + wx2 + wx1x2 &gt; wx3</p>
  </div>
  <div class="page">
    <p>From statements to utility function</p>
    <p>S = {s1, . . . , sm}</p>
    <p>C = {c1, . . . , ck}</p>
    <p>U</p>
  </div>
  <div class="page">
    <p>From statements to utility function</p>
    <p>S = {s1, . . . , sm}</p>
    <p>C = {c1, . . . , ck}</p>
    <p>U</p>
    <p>Good news:</p>
    <p>All the constraints in are linear.  Any solution of provides us with a</p>
    <p>valid ordinal utility function.</p>
    <p>The constraints in encode a least committing interpretation of the statements in S.</p>
    <p>C</p>
    <p>C</p>
    <p>C</p>
    <p>fi:val(fi)2m</p>
    <p>wi &gt;</p>
    <p>fj :val(fj )2m</p>
    <p>wj</p>
  </div>
  <div class="page">
    <p>From statements to utility function</p>
    <p>S = {s1, . . . , sm}</p>
    <p>C = {c1, . . . , ck}</p>
    <p>U</p>
    <p>Good news:</p>
    <p>All the constraints in are linear.  Any solution of provides us with a</p>
    <p>valid ordinal utility function.</p>
    <p>The constraints in encode a least committing interpretation of the statements in S.</p>
    <p>Bad news:</p>
    <p>The complexity of solving , and even the complexity of its description ...</p>
    <p>C</p>
    <p>C</p>
    <p>C</p>
    <p>C</p>
    <p>fi:val(fi)2m</p>
    <p>wi &gt;</p>
    <p>fj :val(fj )2m</p>
    <p>wj</p>
  </div>
  <div class="page">
    <p>Complexity of the constraint system</p>
    <p>For each m  M (), m  M ():</p>
    <p>fi:val(fi)2m</p>
    <p>wi &gt;</p>
    <p>fj :val(fj )2m</p>
    <p>wj !</p>
    <p>R 2 2n</p>
    <p>!</p>
    <p>!</p>
    <p>U</p>
  </div>
  <div class="page">
    <p>Both identifying a satisfactory utility function and using it can be done in time linear in n and polynomial in m.</p>
    <p>The computational machinery is based on certain tools from convex optimization and statistical learning:</p>
    <p>Theory of Support Vector Machines.  Mercer kernel functions.</p>
    <p>Summary of the results</p>
    <p>P d</p>
    <p>(1  d  n)</p>
    <p>Most general case</p>
    <p>d = nd = 1Additive models</p>
    <p>U</p>
  </div>
  <div class="page">
    <p>EachMovie data set  Ratings of 1628 movies by 72916 users.  Six point scale: 0 (worst) - 5 (best)  Movie attributes: Decade and 10 genre categories.</p>
    <p>(So far inherent) problem: No generalizing statements.</p>
    <p>Solution: Reveal these statements from the data.  Learn rules using C4.5 decision tree learning.  Pick probabilistically most significant rules.</p>
    <p>Empirical evaluation of effectiveness</p>
  </div>
  <div class="page">
    <p>Preference statements</p>
    <p>B_decade = 90s B_Art_Foreign = 1 B_Family = 0 B_Romance = 0 -&gt; user prefers movie A over movie B [100%]</p>
    <p>A_decade = 80s A_Thriller = 1 B_Classic = 0 B_Horror = 1 -&gt; user prefers movie A over movie B [96.2%]</p>
    <p>The user doesnt like foreign films from the 90s that are not romance or family movies.</p>
    <p>The user prefers thrillers from the 80s to non-classic horror movies.</p>
  </div>
  <div class="page">
    <p>Some test results</p>
    <p>MinError of 0.27 vs. 0.24 for C4.5 decision tree. But we reveal an ordering!</p>
  </div>
  <div class="page">
    <p>Both identifying a satisfactory utility function and using it can be done in time linear in n and polynomial in m.</p>
    <p>The computational machinery is based on certain tools from convex optimization and statistical learning:</p>
    <p>Theory of Support Vector Machines.  Mercer kernel functions.</p>
    <p>The identified utility function has interesting semantics.  Ability to deal with inconsistent information.  Experimental results show both empirical efficiency and</p>
    <p>effectiveness.</p>
    <p>Numerous directions for future work.</p>
    <p>Summary of results</p>
  </div>
</Presentation>
