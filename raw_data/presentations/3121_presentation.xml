<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Taking proof-based verified computation a few steps closer to practicality</p>
    <p>Srinath Setty, Victor Vu, Nikhil Panpalia, Benjamin Braun, Andrew J. Blumberg, and Michael Walfish</p>
    <p>The University of Texas at Austin</p>
  </div>
  <div class="page">
    <p>output, auxil iary informa</p>
    <p>tion</p>
    <p>process_image (input)</p>
    <p>use auxiliary information</p>
    <p>to quickly verify</p>
    <p>client server</p>
  </div>
  <div class="page">
    <p>Probabilistically checkable proofs (PCPs) can help</p>
    <p>Fast verification: client saves work (asymptotically)</p>
    <p>General-purpose: can outsource any computation</p>
    <p>Unconditional: no assumptions about the server</p>
    <p>output</p>
    <p>process_image (input)</p>
    <p>responses:</p>
    <p>queries to the proof , 1 , ...0</p>
    <p>proof 0</p>
    <p>accept/ reject</p>
    <p>client server</p>
  </div>
  <div class="page">
    <p>The theory provides strong security properties, but the costs are outrageous</p>
    <p>Verifying multiplication of 500500 matrices would take more than 500 trillion CPU years (seriously)</p>
    <p>Two efforts: PEPPER [HotOS11, NDSS12], Thaler et al. [ITCS12, HotCloud12]</p>
    <p>In some cases, PEPPER reduces costs by a factor of 1020 over a naive implementation of the theory</p>
    <p>There is a lot of renewed interest in reducing costs with built systems</p>
  </div>
  <div class="page">
    <p>But all of these recent works have notable limitations</p>
    <p>Example:</p>
    <p>Arithmetic circuits cannot concisely express conditional control flow or comparisons</p>
    <p>X</p>
    <p>X +</p>
    <p>output</p>
  </div>
  <div class="page">
    <p>GINGER addresses some of these limitations</p>
    <p>Reduces the clients work by several orders of magnitude</p>
    <p>Includes a massively parallel GPU-based implementation</p>
    <p>Supports a general-purpose programming model</p>
    <p>Concise conditionals, comparisons, efficient floatingpoint representation, etc.</p>
    <p>A compiler to go from high-level code to executables</p>
  </div>
  <div class="page">
    <p>The main takeaway</p>
    <p>GINGER and its predecessor (PEPPER) together reduce costs by a factor of 1023 using theory and systems techniques</p>
    <p>We still need a factor of 103 on the server for true practicality</p>
    <p>We think that proof-based verified computation could be practical in the near future</p>
  </div>
  <div class="page">
    <p>Rest of this talk</p>
    <p>Design of GINGER</p>
    <p>Experimental results</p>
  </div>
  <div class="page">
    <p>Theory that GINGER builds on</p>
    <p>circuit, input</p>
    <p>output 01 1 proof</p>
    <p>queries to the proof</p>
    <p>client server</p>
    <p>, ...,</p>
    <p>X</p>
    <p>X +</p>
    <p>accept/ reject</p>
    <p>clients tests</p>
  </div>
  <div class="page">
    <p>The server creates a proof by redundantly encoding the circuits wire values</p>
    <p>proof</p>
    <p>X</p>
    <p>X +</p>
    <p>output</p>
    <p>circuit for the computation</p>
    <p>values on wires of the</p>
    <p>circuit</p>
    <p>redundant encoding</p>
  </div>
  <div class="page">
    <p>circuit, input</p>
    <p>output 01 1 proof</p>
    <p>queries to the proof</p>
    <p>client server</p>
    <p>, ...,</p>
    <p>X</p>
    <p>X +</p>
    <p>accept/ reject</p>
    <p>clients tests</p>
  </div>
  <div class="page">
    <p>The client queries the servers proof and runs a set of tests</p>
    <p>proof at the server</p>
    <p>responses:</p>
    <p>queries to the proof , 9 , ...0</p>
    <p>tests at the client</p>
    <p>accept/ reject</p>
  </div>
  <div class="page">
    <p>circuit, input</p>
    <p>output 01 1 proof</p>
    <p>queries to the proof</p>
    <p>client server</p>
    <p>, ...,</p>
    <p>X</p>
    <p>X +</p>
    <p>accept/ reject</p>
    <p>clients tests</p>
    <p>There is some probability that the client accepts an incorrect proof</p>
    <p>The costs depend on the size of the circuit</p>
  </div>
  <div class="page">
    <p>GINGERs contributions include:</p>
    <p>Reducing the costs by revisiting the clients tests</p>
    <p>Broadening the space of computations</p>
    <p>Incorporating primitive floating-point numbers (in the paper)</p>
  </div>
  <div class="page">
    <p>Reducing the costs by revisiting the clients tests</p>
    <p>responses:</p>
    <p>queries to the proof , 1 , ...0</p>
    <p>server</p>
    <p>We prove: consistency test is stronger than linearity test</p>
    <p>Modifications:</p>
    <p>Eliminate linearity tests</p>
    <p>No need to repeat the verification to reduce error</p>
    <p>Benefit: savings in CPU cycles at the client</p>
    <p>clients tests</p>
  </div>
  <div class="page">
    <p>GINGERs contributions include:</p>
    <p>Reducing the costs by revisiting the clients tests</p>
    <p>Broadening the space of computations</p>
    <p>Incorporating primitive floating-point numbers (in the paper)</p>
  </div>
  <div class="page">
    <p>We change the model of computation from arithmetic circuits to systems of equations</p>
    <p>The new model can represent general-purpose programming constructs concisely</p>
    <p>End-to-end costs decrease by many orders of magnitude</p>
  </div>
  <div class="page">
    <p>An example</p>
    <p>increment(X) Y = X + 1</p>
    <p>If the output is 7</p>
    <p>There is a solution</p>
    <p>If the output is 8</p>
    <p>There is no solution</p>
    <p>Once the inputs are fixed, an incorrect output will result in an inconsistent system of equations</p>
    <p>Suppose the input is 6</p>
    <p>=</p>
  </div>
  <div class="page">
    <p>We can encode many program constructs</p>
    <p>For example, consider X != Y:</p>
    <p>Our equation is 1 = (X - Y) * M</p>
    <p>Observe: no solution if X = = Y</p>
  </div>
  <div class="page">
    <p>Another example with conditional control flow</p>
    <p>Y = M * 3 + (1-M) * 4</p>
    <p>function(bool X) if (X) Y = 3 else Y = 4</p>
    <p>=</p>
  </div>
  <div class="page">
    <p>Compiling code into a system of equations</p>
    <p>compiler based on Fairplay</p>
    <p>[Malkhi et al. USENIX</p>
    <p>Security04]</p>
    <p>function(bool X) if (X) Y = 3 else Y = 4</p>
    <p>Y = M * 3 + (1-M) * 4</p>
    <p>equations for &lt;, &gt;, !=, IF/ELSE, ...</p>
    <p>(in the paper)</p>
  </div>
  <div class="page">
    <p>The server creates a proof by redundantly encoding a solution to the system of equations</p>
    <p>proof</p>
    <p>X</p>
    <p>X +</p>
    <p>output</p>
    <p>circuit for the computation</p>
    <p>values on wires of the</p>
    <p>circuit</p>
    <p>redundant encoding</p>
    <p>solution to the system of</p>
    <p>equations</p>
  </div>
  <div class="page">
    <p>GINGERs contributions include:</p>
    <p>Reducing the costs by revisiting the clients tests</p>
    <p>Broadening the space of computations</p>
    <p>Incorporating primitive floating-point numbers (in the paper)</p>
  </div>
  <div class="page">
    <p>Implementation and experimental testbed</p>
    <p>Massively parallel implementation</p>
    <p>C++ code with OpenMP threads; HTTP/Open MPI to distribute servers work</p>
    <p>CUDA to offload work to GPUs</p>
    <p>Evaluation testbed</p>
    <p>A cluster at Texas Advanced Computing Center (TACC)</p>
    <p>Each machine runs Linux on an Intel Xeon 2.53 GHz with 48GB of RAM.</p>
    <p>For GPU experiments, we use NVIDIA Tesla M2070 GPUs (448 CUDA cores and 6GB of memory)</p>
  </div>
  <div class="page">
    <p>Evaluation questions</p>
    <p># instances</p>
    <p>CPU time</p>
    <p>computation costs</p>
    <p>verification costs</p>
    <p>break-even point</p>
  </div>
  <div class="page">
    <p>The break-even points and the clients work decrease by several orders of magnitude</p>
    <p>Consider outsourcing many instances of 500500 matrix multiplication</p>
    <p>PEPPER GINGER</p>
    <p>CPU break-even # instances 10,000 4100 CPU client verification time 6.3 hours 2.5 hours</p>
    <p>GPU for crypto break-even # instances 3200 20</p>
    <p>GPU for crypto client verification time 2.0 hours 44 sec</p>
  </div>
  <div class="page">
    <p>Evaluation questions</p>
    <p># instances</p>
    <p>CPU time</p>
    <p>computation costs</p>
    <p>verification costs break-even</p>
    <p>point</p>
  </div>
  <div class="page">
    <p>matrix mult polynomial eval Hamming distance root finding</p>
    <p>sp ee</p>
    <p>du p</p>
    <p>Parallelizing the server results in a near-linear speedup in most cases</p>
    <p>re 4</p>
    <p>co re</p>
    <p>s</p>
    <p>o re</p>
    <p>s 60</p>
    <p>c o re</p>
    <p>s (i de</p>
    <p>al )</p>
    <p>re 4</p>
    <p>co re</p>
    <p>s</p>
    <p>o re</p>
    <p>s 60</p>
    <p>c o re</p>
    <p>s (i de</p>
    <p>al )</p>
    <p>re 4</p>
    <p>co re</p>
    <p>s</p>
    <p>o re</p>
    <p>s 60</p>
    <p>c o re</p>
    <p>s (i de</p>
    <p>al )</p>
    <p>re 4</p>
    <p>co re</p>
    <p>s</p>
    <p>o re</p>
    <p>s 60</p>
    <p>c o re</p>
    <p>s (i de</p>
    <p>al )</p>
  </div>
  <div class="page">
    <p>Evaluation questions</p>
    <p># instances</p>
    <p>CPU time</p>
    <p>computation costs</p>
    <p>verification costs break-even</p>
    <p>point</p>
  </div>
  <div class="page">
    <p>GINGERs representation is many orders of magnitude shorter compared to Boolean circuits</p>
    <p>Benchmark</p>
    <p># gates in Boolean circuit</p>
    <p># variables in GINGERs</p>
    <p>representation</p>
    <p>root finding via bisection 2  103</p>
    <p>Hamming distance 2  104 3  108</p>
  </div>
  <div class="page">
    <p>Rest of this talk</p>
    <p>Design of GINGER</p>
    <p>Experimental results</p>
    <p>Limitations, related work, and outlook</p>
  </div>
  <div class="page">
    <p>Limitations of GINGER</p>
    <p>The client needs to outsource many instances to gain</p>
    <p>The servers resource costs are still high</p>
    <p>Also, the efficiency of the server sometimes relies on reducing the redundancy in the proofs encoding</p>
    <p>The number of iterations in a loop should be known at compile time</p>
  </div>
  <div class="page">
    <p>Prior work on verifying computations</p>
    <p>Make strong trust assumptions or give up being general-purpose:</p>
    <p>Replication [Castro &amp; Liskov TOCS02], trusted hardware [Chiesa &amp; Tromer ICS10, Sadeghi et al. TRUST10], and auditing [Monrose et al. NDSS99, Haeberlen et al. SOSP07]</p>
    <p>Special-purpose [Freivalds MFCS79, Golle &amp; Mironov RSA01, Sion VLDB05, Benabbas et al. CRYPTO11, Boneh &amp; Freeman EUROCRYPT11]</p>
    <p>Use fully homomorphic encryption [Gennaro et al. CRYPTO10, Chung et al. CRYPTO10]</p>
    <p>Proof-based verified computation [Ben-Or STOC88, Babai STOC91, Kilian STOC92, Blum et al. JACM95, Arora et al. JACM98, Ben-Sasson et al. 12, Gennaro et al. 12]</p>
    <p>Built systems:</p>
    <p>Toward practical interactive proofs [Cormode ITCS12, Thaler et al. HotCloud12] based on [Goldwasser et al. STOC08]</p>
    <p>Our prior work: PEPPER [HotOS11, NDSS12] based on [Ishai et al. CCC07]</p>
  </div>
  <div class="page">
    <p>Summary of GINGER</p>
    <p>Reduces the clients work by several orders of magnitude</p>
    <p>Includes a massively parallel GPU-based implementation</p>
    <p>Supports a general-purpose programming model</p>
  </div>
  <div class="page">
    <p>Looking back</p>
    <p>About two years ago, we set out to build a system for proof-based verified computation</p>
    <p>Then, the estimated costs were on the order of trillions of CPU years</p>
    <p>Main takeaway</p>
    <p>We combined theory and systems techniques to reduce costs by a factor of 1023</p>
    <p>We still need a factor of 103 on the server for true practicality</p>
    <p>But we think that proof-based verified computation could be practical for real in the near future</p>
  </div>
</Presentation>
