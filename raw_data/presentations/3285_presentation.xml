<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>An In-Depth Analysis of Disassembly on Full-Scale x86/x64 Binaries</p>
    <p>Dennis Andriesse, Xi Chen, Victor van der Veen, Asia Slowinska, Herbert Bos</p>
    <p>Vrije Universiteit Amsterdam Lastline, Inc.</p>
    <p>USENIX Security 2016</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Disassembly in Systems Security</p>
    <p>Disassembly is the backbone of all binary-level systems security work (and more)</p>
    <p>Control-Flow Integrity  Automatic Vulnerability/Bug Search  Lifting binaries to LLVM/IR (e.g., for reoptimization)  Malware Analysis  Binary Hardening  Binary Instrumentation  . . .</p>
    <p>An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 1 of 18</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Challenges in Disassembly</p>
    <p>Disassembly is undecidable, and disassemblers face many challenges</p>
    <p>Code interleaved with data  Overlapping basic blocks  Overlapping instructions (on variable-length ISAs)  Indirect jumps/calls  Alignment/padding bytes (such as nops)  Multi-entry functions  Tailcalls  . . .</p>
    <p>How much of a problem do these challenges cause in practice?</p>
    <p>An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 2 of 18</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Motivation of our Work</p>
    <p>Prior work explores corner cases, but no consensus on how common these really are in practice</p>
    <p>Pessimistic view of disassembly among reviewers and researchers  Underestimation of the potential of binary-based work</p>
    <p>We study the frequency of corner cases in real-world binaries, and measure how well disassemblers deal with them</p>
    <p>An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 3 of 18</p>
  </div>
  <div class="page">
    <p>Experiment Setup</p>
    <p>Binary Types</p>
    <p>We cover a wide range of commonly targeted binary types (981 tests)</p>
    <p>SPEC CPU2006 + real-world applications (C and C++)  Compiled with gcc, clang (ELF) and Visual Studio (PE)  Compiled for x86 and x64  Five optimization levels (O0-O3 and Os) + -flto  Dynamically and statically linked binaries  Stripped binaries and binaries with symbols  Library code with handwritten assembly (glibc)</p>
    <p>Focus on benign use cases, such as binary protection schemes (we already know obfuscated binaries can wreak havoc)</p>
    <p>An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 4 of 18</p>
  </div>
  <div class="page">
    <p>Experiment Setup</p>
    <p>Ground Truth</p>
    <p>Ground truth from DWARF/PDB, with source-level LLVM info</p>
    <p>Disassembly Primitives and Complex Cases</p>
    <p>We study five commonly used disassembly/binary analysis primitives</p>
    <p>1 Instructions, 2 Function starts, 3 Function signatures, 4 Control Flow Graph (CFG) accuracy, 5 Callgraph accuracy</p>
    <p>Measure prevalence of seven complex cases</p>
    <p>1 Overlapping BBs, 2 Overlapping instructions, 3 Inline data/jump tables, 4 Switches, 5 Padding bytes, 6 Multi-entry functions, 7 Tailcalls</p>
    <p>Disassemblers</p>
    <p>Tested nine popular industry and research disassemblers (details in paper and in results where needed)</p>
    <p>An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 5 of 18</p>
  </div>
  <div class="page">
    <p>Experiment Results</p>
    <p>More results</p>
    <p>Far too many results to fit in this presentation</p>
    <p>Focus on most interesting results here, see paper for more  Detailed results and ground truth publicly released https://www.vusec.net/projects/disassembly/</p>
    <p>An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 6 of 18</p>
  </div>
  <div class="page">
    <p>Experiment Results</p>
    <p>Instruction Accuracy</p>
    <p>Very high accuracy for best performing disassemblers</p>
    <p>IDA Pro 6.7: 96%99% TP (FNs due to padding, FPs rare)  Linear: 100% correct on ELF (no inline data)</p>
    <p>O0 O1 O2 O3</p>
    <p>% c</p>
    <p>or re</p>
    <p>ct (g</p>
    <p>eo m</p>
    <p>et ri</p>
    <p>c m</p>
    <p>ea n)</p>
    <p>gcc-5.1.1 x86</p>
    <p>angr 4.6.1.4 BAP 0.9.9</p>
    <p>ByteWeight 0.9.9 Dyninst 9.1.0</p>
    <p>Hopper 3.11.5 IDA Pro 6.7</p>
    <p>Jakstab 0.8.4 Linear</p>
    <p>SPEC (C) SPEC (C++)</p>
    <p>O0 O1 O2 O3</p>
    <p>gcc-5.1.1 x64</p>
    <p>O0 O1 O2 O3</p>
    <p>clang-3.7.0 x86</p>
    <p>O0 O1 O2 O3</p>
    <p>clang-3.7.0 x64</p>
    <p>O0 O1 O2 O3</p>
    <p>Visual Studio '15 x86</p>
    <p>O0 O1 O2 O3</p>
    <p>Visual Studio '15 x64</p>
    <p>Figure: Correctly disassembled instructions</p>
    <p>An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 7 of 18</p>
  </div>
  <div class="page">
    <p>Experiment Results</p>
    <p>CFG and Callgraph accuracy</p>
    <p>CFG and callgraph very accurate due to high instruction accuracy (see paper for details)</p>
    <p>An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 8 of 18</p>
  </div>
  <div class="page">
    <p>Experiment Results</p>
    <p>Function Signatures</p>
    <p>Only IDA Pro, important mostly for manual reverse engineering</p>
    <p>Poor accuracy, especially on x64  Acceptable for manual analysis, caution in automated analysis</p>
    <p>O0 O1 O2 O3</p>
    <p>% c</p>
    <p>or re</p>
    <p>ct (g</p>
    <p>eo m</p>
    <p>et ri</p>
    <p>c m</p>
    <p>ea n)</p>
    <p>gcc-5.1.1 x86</p>
    <p>O0 O1 O2 O3</p>
    <p>gcc-5.1.1 x64</p>
    <p>O0 O1 O2 O3</p>
    <p>clang-3.7.0 x86</p>
    <p>O0 O1 O2 O3</p>
    <p>clang-3.7.0 x64</p>
    <p>O0 O1 O2 O3</p>
    <p>Visual Studio '15 x86</p>
    <p>O0 O1 O2 O3</p>
    <p>Visual Studio '15 x64</p>
    <p>Figure: Correctly detected non-empty argument list (IDA Pro, argc only)</p>
    <p>An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 9 of 18</p>
  </div>
  <div class="page">
    <p>Experiment Results</p>
    <p>Function Detection</p>
    <p>Function detection currently the main disassembly challenge</p>
    <p>Even function start detection yields many FPs/FNs (20%+)  Complex cases: non-standard prologues, tailcalls, inlining, . . .  Binary analysis commonly requires function information</p>
    <p>O0 O1 O2 O3</p>
    <p>% c</p>
    <p>or re</p>
    <p>ct (g</p>
    <p>eo m</p>
    <p>et ri</p>
    <p>c m</p>
    <p>ea n)</p>
    <p>gcc-5.1.1 x86</p>
    <p>angr 4.6.1.4 BAP 0.9.9</p>
    <p>ByteWeight 0.9.9 Dyninst 9.1.0</p>
    <p>Hopper 3.11.5 IDA Pro 6.7</p>
    <p>Jakstab 0.8.4</p>
    <p>SPEC (C) SPEC (C++)</p>
    <p>O0 O1 O2 O3</p>
    <p>gcc-5.1.1 x64</p>
    <p>O0 O1 O2 O3</p>
    <p>clang-3.7.0 x86</p>
    <p>O0 O1 O2 O3</p>
    <p>clang-3.7.0 x64</p>
    <p>O0 O1 O2 O3</p>
    <p>Visual Studio '15 x86</p>
    <p>O0 O1 O2 O3</p>
    <p>Visual Studio '15 x64</p>
    <p>Figure: Correctly detected function start addresses An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 10 of 18</p>
  </div>
  <div class="page">
    <p>Experiment Results</p>
    <p>Function Detection: False Negative</p>
    <p>Listing: False negative indirectly called function for IDA Pro 6.7 (gcc compiled with gcc at O3 for x64 ELF)</p>
    <p>An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 11 of 18</p>
  </div>
  <div class="page">
    <p>Experiment Results</p>
    <p>Function Detection: False Positive</p>
    <p>Listing: False positive function (shaded) for Dyninst (perlbench compiled with gcc at O3 for x64 ELF)</p>
    <p>[...]</p>
    <p>[...]</p>
    <p>An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 12 of 18</p>
  </div>
  <div class="page">
    <p>Prevalence of Complex Cases</p>
    <p>Complex Cases in Application Code</p>
    <p>No inline data in ELF, even jump tables placed in .rodata  Inline data for PE (jump tables), well recognized by IDA Pro  No overlapping basic blocks, contrary to widespread belief  Tailcalls quite common (impact on function detection)</p>
    <p>O0 O1 O2 O3</p>
    <p># co</p>
    <p>m pl</p>
    <p>ex c</p>
    <p>as es</p>
    <p>(g eo</p>
    <p>m et</p>
    <p>ri c</p>
    <p>m ea</p>
    <p>n)</p>
    <p>gcc-5.1.1 x86</p>
    <p>BB overlap ins overlap</p>
    <p>multi-entry jmps multi-entry targets</p>
    <p>tailcall jmps tailcall targets</p>
    <p>SPEC (C) SPEC (C++)</p>
    <p>O0 O1 O2 O3</p>
    <p>gcc-5.1.1 x64</p>
    <p>O0 O1 O2 O3</p>
    <p>clang-3.7.0 x86</p>
    <p>O0 O1 O2 O3</p>
    <p>clang-3.7.0 x64</p>
    <p>O0 O1 O2 O3</p>
    <p>Visual Studio '15 x86</p>
    <p>O0 O1 O2 O3</p>
    <p>Visual Studio '15 x64</p>
    <p>Figure: Prevalence of complex constructs in SPEC CPU2006 binaries An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 13 of 18</p>
  </div>
  <div class="page">
    <p>Prevalence of Complex Cases</p>
    <p>Complex Cases in Library Code (glibc-2.22)</p>
    <p>Highly optimized library code (handwritten assembly) allows for more complex cases</p>
    <p>Surprisingly, no inline data in recent glibc versions (explicitly pushed into .rodata even in handwritten code)</p>
    <p>No overlapping basic blocks  Tailcalls again quite common  Some overlapping instructions (handwritten assembly)  Some multi-entry functions (well-defined)</p>
    <p>An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 14 of 18</p>
  </div>
  <div class="page">
    <p>Prevalence of Complex Cases</p>
    <p>Complex Cases in Library Code: Overlapping Instruction</p>
    <p>Listing: Overlapping instruction in glibc-2.22</p>
    <p>An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 15 of 18</p>
  </div>
  <div class="page">
    <p>Prevalence of Complex Cases</p>
    <p>Complex Cases in Library Code: Multi-Entry Function</p>
    <p>Listing: Multi-entry function in glibc-2.22</p>
    <p>e9a30 &lt;splice&gt;:</p>
    <p>e9a30: cmpl $0x0,0x2b9da9(%rip)</p>
    <p>e9a37: jne e9a4c &lt; splice nocancel+0x13&gt;</p>
    <p>e9a39 &lt; splice nocancel&gt;:</p>
    <p>e9a39: mov %rcx,%r10</p>
    <p>e9a3c: mov $0x113,%eax</p>
    <p>e9a41: syscall</p>
    <p>e9a43: cmp $0xfffffffffffff001,%rax</p>
    <p>e9a49: jae e9a7f &lt; splice nocancel+0x46&gt;</p>
    <p>e9a4b: retq</p>
    <p>e9a4c: sub $0x8,%rsp</p>
    <p>e9a50: callq f56d0 &lt; libc enable asynccancel&gt;</p>
    <p>[...]</p>
    <p>An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 16 of 18</p>
  </div>
  <div class="page">
    <p>Disassembly in the Literature</p>
    <p>Comparison of Results</p>
    <p>Compared our results to the requirements and expectations of disassembly-based security work published between 20132015</p>
    <p>Instructions/CFG information needed in nearly all papers  Function detection required by half of the papers  Linear disassembly rarely used, even when more accurate (ELF)  Only 30% of papers that use function detection discuss potential errors, despite its unreliability</p>
    <p>Errors in function detection are discussed less often than for any other primitive</p>
    <p>In 70% of papers, errors are fatal (unusable results or crashes)  Only 43% of papers handle errors in any primitive  Most papers that handle errors use overestimation (conservative</p>
    <p>analysis) or runtime fixes</p>
    <p>An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 17 of 18</p>
  </div>
  <div class="page">
    <p>Discussion and Conclusion</p>
    <p>Expectations of disassembly are mismatched with actual results</p>
    <p>Research focuses on extremely rare or nonexistent corner cases  Function detection currently biggest challenge, but errors</p>
    <p>discussed more rarely than any other primitive</p>
    <p>Few papers implement mechanisms for handling disassembly errors, even when these are fatal</p>
    <p>Real-world data on disassembly enables better judgement of directions for future work</p>
    <p>Many more results and details given in our paper  Detailed results and ground truth publicly released https://www.vusec.net/projects/disassembly/</p>
    <p>An In-Depth Analysis of Disassembly,on Full-Scale x86/x64 Binaries 18 of 18</p>
  </div>
</Presentation>
