<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>An Algorithm for Multi-Unit Combinatorial Auctions</p>
    <p>Kevin Leyton-Brown Yoav Shoham</p>
    <p>Moshe Tennenholtz</p>
    <p>Computer Science Dept. Stanford University</p>
    <p>thanks also to Shobha Venkataraman</p>
  </div>
  <div class="page">
    <p>Combinatorial Auctions Mechanisms that allow bidders to explicitly indicate complementarities and substitutabilities</p>
    <p>many goods are auctioned simultaneously bids name an arbitrary bundle and a price offer bidders may submit multiple bids</p>
    <p>if desired, some bids may be mutually exclusive otherwise, more than one of a bidders bids may win</p>
    <p>Benefit: less risk for bidders wont win a subset of a bundle for more than it is worth to them can request multiple mutually-exclusive bundles More efficient / higher revenue</p>
    <p>no need to hedge bids or restrict bidding to a single bundle</p>
  </div>
  <div class="page">
    <p>Multi-Unit CAs Sometimes a set of goods are identical</p>
    <p>traditionally, bidders have no way to compactly represent indifference between members of the set</p>
    <p>instead, they must enumerate bundles between which they are indifferent this can require a huge number of bids</p>
    <p>Multi-Unit CA set of identical goods: a single multi-unit good</p>
    <p>in general, consider all goods to have a fixed number of units</p>
    <p>bids specify goods, number of units for each good, a price offer for the whole package</p>
  </div>
  <div class="page">
    <p>Winner Determination Auctioneers task:</p>
    <p>given a set of bids, find the revenue-maximizing subset of these bids allocating no more than the maximum number of units for each good</p>
    <p>We can handle XOR with dummy goods unique virtual goods with one unit add a dummy good to every bid in an XOR set now at most one bid from each set can be satisfied</p>
    <p>Same winner-determination procedure used by: first-price combinatorial auction generalized Vickrey auction various ascending auction mechanisms</p>
  </div>
  <div class="page">
    <p>Computational Problem Unfortunately, winner determination is NP-Hard, even with only one unit per good</p>
    <p>Responses to intractability approximation restrict bids (tractable subcase) find optimal solution anyway</p>
    <p>Benefits of finding optimal solution constant-bounded approximation is still intractable bidders strategies affected by approximation restriction can prevent bidders from expressing full preferences</p>
  </div>
  <div class="page">
    <p>Finding Optimal Solution All previously-published work on CAs has concerned single-unit case A natural solution: mixed-integer programming</p>
    <p>rich history commercial packages (CPLEX)</p>
  </div>
  <div class="page">
    <p>CAMUS Combinatorial Auction Multi-Unit Search</p>
    <p>branch and bound search structure the search space</p>
    <p>avoid considering impossible allocations efficient upper-bound function for pruning</p>
    <p>enhancements preprocessing dominated bids dynamic programming caching to improve tightness of upper-bound</p>
    <p>heuristics maximize effectiveness of pruning: upper bound find good allocations quickly: lower bound</p>
    <p>A generalization of our CASS algorithm (1999)</p>
  </div>
  <div class="page">
    <p>First: CAMUS/CPLEX comparison Necessary to use artificial data for testing</p>
    <p>used a distribution from our new paper (to appear at EC-00) aims to model bidding in real-world domains</p>
    <p>Railroad Shipping Domain: Railroad Graph nodes: cities edges: railroad link between cities edge weights: link capacity</p>
  </div>
  <div class="page">
    <p>Railroad Distribution Randomly generate a graph</p>
    <p>random num units per edge: [1, max_units_per_good]</p>
    <p>Create a new bidder randomly choose start and end cities, number of units to ship valuation for route: random proportional to the distance, superadditive in number of units generate substitutable bids for all bundles of edges where valuation &gt; cost of shipping (c * distance) price offer: valuation  cost, rounded to integer</p>
  </div>
  <div class="page">
    <p>Railroad Distribution: Example</p>
    <p>Parameters: num_cities = 5.3 * goods + 3.5, initial_connections = 2, building_penalty = 2.7, num_building_paths = (num_cities)/4, shipping_cost_factor = 1.1,</p>
    <p>max_bid_set_size = 8, max_cap = 20, additivity = 0.2.</p>
  </div>
  <div class="page">
    <p>Number of Bids</p>
    <p>A ve</p>
    <p>ra ge</p>
    <p>o ve</p>
    <p>r 10</p>
    <p>T ri</p>
    <p>al s</p>
    <p>(s )</p>
    <p>CAMUS - 10 CPLEX - 10 Min - 10</p>
  </div>
  <div class="page">
    <p>Number of Bids</p>
    <p>A ve</p>
    <p>ra ge</p>
    <p>o ve</p>
    <p>r 10</p>
    <p>T ri</p>
    <p>al s</p>
    <p>(s )</p>
    <p>CAMUS - 12 CPLEX - 12 Min - 12</p>
  </div>
  <div class="page">
    <p>CAMUS Implementation: Search Depth-First Search on allocations</p>
    <p>begin with empty allocation add bids to current partial allocation until complete; backtrack</p>
    <p>Branch and Bound Search lower bound: best allocation observed so far upper bound: revenue of current partial allocation + overestimate of revenue from unallocated units when upper bound  lower bound, backtrack</p>
  </div>
  <div class="page">
    <p>Structure the Search Space Partition the bids into bins</p>
    <p>one bin for each good each bid belongs to the bin corresponding to its lowest-order good</p>
    <p>After adding a bid, move to the bin for the lowest-order good with unallocated units</p>
    <p>this may be the bin we just left (multi-unit!) create a subbin of the current bin and keep searching subbin: include only higher-order bids than the last bid chosen from this bin</p>
    <p>any bids that we skip are guaranteed to conflict with the current partial allocation</p>
  </div>
  <div class="page">
    <p>Upper Bound Function h(g,i,) An overestimate of the revenue that can be achieved from the remaining units of good g</p>
    <p>given that the search is in bin i and has partial allocation  precompute lists for all g, i:</p>
    <p>each list: all bids for units of good g in bin i or beyond sorted in descending order of average price per unit (APPU)</p>
    <p>Let b be first bid in list i that doesnt conflict with  bs contribution to the overestimate: APPU(b) * min(unitsi(b), units_neededi) if more units are still needed, keep moving down the list and find another non-conflicting bid; repeat</p>
    <p>Why does this work? Please see our paper</p>
  </div>
  <div class="page">
    <p>Dominated Bids For each pair of bids (b1, b2), where:</p>
    <p>price(b1)  price(b2) for all goods j, unitsj(b1)  unitsj (b2)</p>
    <p>b2 will not win unless b1 also wins store b2 as a child of b1</p>
    <p>only consider adding b2 after adding b1 if unitsj(b1) + unitsj (b2)  maxunitsj for any j</p>
    <p>we will never add b2: delete it</p>
  </div>
  <div class="page">
    <p>Dynamic Programming In some auctions, singleton bids will be relatively common</p>
    <p>Additionally, singleton bids can be computationally expensive to consider: can lead to deep searches</p>
    <p>Dynamic programming preprocessing: find the optimal set of singleton bids requesting from 1 to maxunitsj, for each good j in search, only ever consider the optimal singleton set that consumes all remaining units of a good</p>
  </div>
  <div class="page">
    <p>Caching It is possible to allocate the same number of units of the same goods in more than one way</p>
    <p>the search beyond this point is always the same store the results of search in a hash table, then reuse them if we get to the same point again</p>
    <p>most searches are pruned before they reach a full allocation, so we cant store the best allocation in the cache</p>
    <p>use the cache to store upper bounds only store the results that involved non-negligible cost to compute cache upper bounds often tighter than h( )</p>
    <p>cache can be seen as learning a better h( ) a tighter upper bound</p>
  </div>
  <div class="page">
    <p>Good-Ordering Heuristic designate as good #1 the good i that minimizes (numbidsi  maxunitsi) / (avgunitsi)</p>
    <p>minimize number of bids in low-order bins reduce branching</p>
    <p>minimize number of units of goods in low-order bins move quickly past the first bins, where the pruning function is least informative</p>
    <p>maximize total number of units requested by bids in low-order bins</p>
    <p>move quickly to high-order bins</p>
    <p>remove bids involving good #1 and repeat for good #2, etc.</p>
  </div>
  <div class="page">
    <p>Bid-Ordering Heuristic Order bids within bin so we encounter most promising bids first</p>
    <p>improve lower bound Sort bids b in descending order of APPU(b) + h(  b)</p>
    <p>APPU(b) is a measure of bs promise h( ) is a measure of how promising the unallocated units are, given partial allocation</p>
    <p>This ordering is dynamic, because h(  b) depends on the past search</p>
  </div>
  <div class="page">
    <p>CAMUS vs. CPLEX The jurys still out</p>
    <p>CAMUS outperforms CPLEX on the railroad distribution weve seen other cases where CPLEX is better what are the strengths of each approach?</p>
    <p>Choice of distribution is fundamental to testing can we agree on distributions that capture the patterns we expect from real-world bidding? Towards a Universal Test Suite for Combinatorial Auctions, http://robotics.stanford.edu/CATS wed love to get your feedback on this!</p>
  </div>
  <div class="page">
    <p>Conclusion CAMUS is a general-purpose algorithm for finding the winners of multi-unit combinatorial auctions A branch and bound search:</p>
    <p>structuring the search space preprocessing dynamic programming caching heuristics for ordering goods and bids</p>
    <p>Promising performance when compared to CPLEX on our railroad distribution</p>
    <p>more work needed to understand strengths and weaknesses of each approach on other real-world CA distributions</p>
  </div>
</Presentation>
