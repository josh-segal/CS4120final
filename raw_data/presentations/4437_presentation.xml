<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Dynamic Key-Updating: PrivacyPreserving Authentication for</p>
    <p>RFID Systems</p>
    <p>Li Lu, Lei Hu State Key Laboratory of Information</p>
    <p>Security, Graduate School of Chinese Academy of Sciences</p>
    <p>Jinsong Han, Yunhao Liu, and Lionel M. Ni Dept. of Computer Science and</p>
    <p>Engineering, Hong Kong University of Science and Technology</p>
  </div>
  <div class="page">
    <p>Why Privacy in RFID?</p>
    <p>RFID (Radio Frequency Identification) has been very popular</p>
    <p>Tag Reader</p>
    <p>Most important usage</p>
    <p>Identifying valid users or entities</p>
    <p>A tag is attached</p>
    <p>Bobs car</p>
  </div>
  <div class="page">
    <p>Basic Identification Procedure</p>
    <p>iTReader Tag(1) Request</p>
    <p>(2) ID iT</p>
  </div>
  <div class="page">
    <p>A tag is attached</p>
    <p>Bobs car</p>
    <p>However</p>
    <p>Automatic response</p>
    <p>Silent scanning</p>
    <p>I found Bob.</p>
  </div>
  <div class="page">
    <p>Motivation</p>
    <p>Concerns regarding RFID privacy An attacker cant determine which tag he is accessing and cant get any information about the tags owner.</p>
    <p>In Short Private authentication</p>
    <p>Keeping private information (ID, Name,)</p>
    <p>Authenticating valid users</p>
  </div>
  <div class="page">
    <p>Introducing Encryption into RFID</p>
    <p>iTReader Tag (1) {Request,</p>
    <p>P}</p>
    <p>(2) {ID , P}K iT</p>
    <p>K</p>
    <p>Key-Searching</p>
  </div>
  <div class="page">
    <p>Linear Key-Searching</p>
    <p>iT</p>
    <p>)(Pf ik</p>
    <p>-- keyed one-way function P -- a random number -- key shared by reader and tag</p>
    <p>Reader Tag</p>
    <p>ik</p>
    <p>(1) Request, P</p>
    <p>(2) )(, PfEP ik</p>
    <p>(3) searches the key space of all tags for a key</p>
    <p>jjkK }{ EPf</p>
    <p>jk )(</p>
    <p>Key-searching is linear search, O (n). Thus it is not practical in large scale systems.</p>
    <p>k1 k2 kn..</p>
  </div>
  <div class="page">
    <p>A binary key tree with eight tags</p>
    <p>, ),,( 4,32,21,1 kkk 4T</p>
    <p>Tree-based Key-searching</p>
  </div>
  <div class="page">
    <p>Authentication of Tree-based Protocols</p>
    <p>Reader Tag iT</p>
    <p>),,(),,,(),,,(, 2132122112 rrkhrrkhrrkhr iii</p>
    <p>Identification:</p>
    <p>Compute ),,( and ),,( 212,1211,1 rrkhrrkh</p>
    <p>),,( with comparethen 211 rrkh i</p>
    <p>Compute ),,( and ),,( 212,2211,2 rrkhrrkh</p>
    <p>),,( with comparethen 212 rrkh i</p>
    <p>Compute ),,( and ),,( 214,3213,3 rrkhrrkh</p>
    <p>),,( with comparethen 213 rrkh i</p>
    <p>O(logn)</p>
  </div>
  <div class="page">
    <p>Drawbacks: No forward security. Vulnerable to compromising attack.</p>
    <p>Requires Key Updating</p>
  </div>
  <div class="page">
    <p>Requirement of Key-Updating</p>
    <p>Challenging issues: No interruption during authentication Automatically updating keys</p>
    <p>We use two techniques to keep the consistency of key-updating: temporary key and state bit.</p>
  </div>
  <div class="page">
    <p>Our Protocol: SPA Temporary keys are used to store old</p>
    <p>keys. State bits are used to record the keyupdating status of nodes in the sub-trees.</p>
    <p>ls0 rs0</p>
    <p>ls 1,1 rs 1,1</p>
    <p>ls 2,1 rs 2,1</p>
    <p>For example: Temporary Key State bit</p>
  </div>
  <div class="page">
    <p>An Example of Key-Updating</p>
    <p>Using , and to identify</p>
    <p>)( 1,21,2 khk</p>
    <p>Using , and to identify</p>
    <p>The s second identification</p>
    <p>The s identification1TThe s identification</p>
    <p>)( 1,11,1</p>
    <p>khk</p>
    <p>ktk</p>
    <p>)( 2,22,2 khk</p>
    <p>Authentication: Basic tree-based identification Key updating</p>
    <p>Authentication sequence: T1, T2, T1</p>
  </div>
  <div class="page">
    <p>New Tag Joining</p>
  </div>
  <div class="page">
    <p>Tag Leaving</p>
    <p>T1 T2 T4</p>
    <p>ls 1,1 rs 1,1 12,1</p>
    <p>ls rs 2,1</p>
    <p>k2,1 k2,2 k2,3 k2,4</p>
    <p>k0, tk0</p>
    <p>k1,1, tk1,1 k1,2, tk1,2</p>
    <p>T5</p>
    <p>ls 3,1 rs 4,1</p>
    <p>k2,5 k2,6</p>
    <p>k1,3, tk1,3</p>
  </div>
  <div class="page">
    <p>Which key is used?</p>
    <p>Which keys is used?</p>
    <p>Compromising Attack Resistance</p>
  </div>
  <div class="page">
    <p>Security Analysis</p>
    <p>Property\Protocol Static tree</p>
    <p>based approaches</p>
    <p>Our design</p>
    <p>Privacy Yes Yes</p>
    <p>Untraceability Yes Yes</p>
    <p>Cloning resistance</p>
    <p>Yes Yes</p>
    <p>Forward security No Yes</p>
  </div>
  <div class="page">
    <p>Branching Factor</p>
    <p>C o</p>
    <p>rr e</p>
    <p>la te</p>
    <p>d -e</p>
    <p>xp o</p>
    <p>si n</p>
    <p>g p</p>
    <p>ro b</p>
    <p>a b</p>
    <p>ili ty t=20,Static tree</p>
    <p>t=20,SPA t=200,Static tree t=200,SPA</p>
    <p>Exposing Probability Comparison (Under Compromising Attack)</p>
    <p>Each non-leaf node has 2 keys (1 working key and 1 temporary keys).</p>
  </div>
  <div class="page">
    <p>Tag accessing Frequency</p>
    <p>K e</p>
    <p>yU</p>
    <p>p d</p>
    <p>a tin</p>
    <p>g L</p>
    <p>a te</p>
    <p>n cy</p>
    <p>(</p>
    <p>s )</p>
    <p>Upper bound SPA Lower bound</p>
    <p>Key-Updating Latency</p>
    <p>Each key updating needs less than 2 ms when the tag accessing frequency does not exceed 10 times per</p>
    <p>second.</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>By using dynamic key-updating scheme, SPA enhances the security of existing RFID private-authentication protocols. SPA is lightweight. The authentication efficiency is logarithmic and the keyupdating latency is acceptable. SPA can effectively defend against both passive and active attacks including compromising attack.</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Authentication</p>
    <p>To protect reader from forged tags.</p>
    <p>Only authorized reader can read valid tags.</p>
    <p>Is the tag which I am reading valid? Is the reader which scans tags authorized?</p>
  </div>
  <div class="page">
    <p>However</p>
    <p>Authorized reader may be cheated by forged tags. A cloning tag may insert into a system while not be notified. A malicious reader can read the content in a tag easily. The goal of authentication: only authorized readers can get the content in valid tags, while private information would not be leaked if there exist dishonest entities.</p>
  </div>
  <div class="page">
    <p>Private Authentication</p>
    <p>Tradeoff between privacy and authentication:</p>
    <p>Privacy is to hide the identity of RFID tag.</p>
    <p>Authentication needs to know the identity of tag before tag being authenticated.</p>
    <p>Private authentication is to hide the identity of a tag in authentication procedure:</p>
    <p>Reader identifies a tag at the end of authentication.</p>
  </div>
  <div class="page">
    <p>System Initialization</p>
    <p>The reader assigns the N tags to N leaf nodes in a balanced binary tree S. Each non-leaf node j in S is assigned with two keys, a working key and a temporary key . Initially, each key is generated randomly and independently by the reader, and for all non-leaf nodes. When a tag is introduced in the system, the reader distributes the keys from the root to a leaf node to this tag. for a non-leaf node j at the path, if , tag is assigned .</p>
    <p>jk jtk</p>
    <p>jj ktk</p>
    <p>jj ktk  jk</p>
  </div>
  <div class="page">
    <p>Mutual Authentication Procedure</p>
    <p>Reader iTTag 1 Request, r</p>
    <p>),,(),...,,,(),,,(, 212122102 rrkhrrkhrrkhr i d</p>
    <p>ii</p>
    <p>ationSynchroniz ,</p>
    <p>Updating keys</p>
    <p>Identifying iT</p>
    <p>Computing ),,( 21 rrkh</p>
    <p>i d</p>
    <p>Checking</p>
    <p>Updating keys</p>
  </div>
  <div class="page">
    <p>Tag Identification</p>
    <p>The tag identification procedure is similar to the previous tree-based approaches. The differences:</p>
    <p>For each non-leaf node included in the identification, t he reader uses not only the working key k, but also th e temporary key tk. If some of the keys stored in a tag are temporary keys , the reader will record the level information of these k eys in the synchronization message to inform the tag updating these keys.</p>
  </div>
  <div class="page">
    <p>Key-updating Rules</p>
    <p>Use hash function h to generating a new key. Let be the old key for node j A new key</p>
    <p>To remain consistent, the non-leaf node j uses tempo rary key to store js old key. Use state bits to note the key state of non-leaf node j s children nodes. 1 for having been updated, otherwis e 0. If keys in all js children have been updated, j updates itself.</p>
    <p>jk )(' jj khk</p>
    <p>jtk</p>
  </div>
  <div class="page">
    <p>Three Key Parameters</p>
    <p>the correlated-exposing probability is mainly dete rmined by three key parameters:</p>
    <p>t, the number of compromised tags; , the branching factor of the key tree;</p>
    <p>a, the number of keys belonging to each nonleaf node</p>
  </div>
  <div class="page">
    <p>A new tag joining</p>
  </div>
  <div class="page">
    <p>Tag leaving</p>
    <p>T1 T2 T4</p>
    <p>ls 1,1 rs 1,1 12,1</p>
    <p>ls rs 2,1</p>
    <p>k2,1 k2,2 k2,3 k2,4</p>
    <p>k0, tk0</p>
    <p>k1,1, tk1,1 k1,2, tk1,2</p>
    <p>T5</p>
    <p>ls 3,1 rs 4,1</p>
    <p>k2,5 k2,6</p>
    <p>k1,3, tk1,3</p>
  </div>
  <div class="page">
    <p>Linear Key-Searching</p>
    <p>iT</p>
    <p>)(Pf ik</p>
    <p>-- keyed one-way function P -- a nonce -- key shared by reader and tag</p>
    <p>Reader Tag</p>
    <p>ik</p>
    <p>(1)</p>
    <p>(1) Request, P</p>
    <p>(2)</p>
    <p>(2) )(, PfEP ik</p>
    <p>(3) searches the key sp ace of all tags for a key s.t.</p>
    <p>jjkK }{ EPf</p>
    <p>jk )(</p>
    <p>Key-searching is linear search, O (n). Thus it doesnt fit large scale systems.</p>
    <p>k1 k2 kn..</p>
  </div>
  <div class="page">
    <p>Prototype Implementation</p>
    <p>We have implemented the our design on 40 Mantis-series 303 MHz asset tags and a Mantis II reader manufactured by RF Code. The back-end database is implemented on a desktop PC with the following configurations: Pentium M 3.2G dual core CPU, 1GBytes memory, and 40G hard disk. We use the SHA-1 algorithm as the secure hash function the system is able to maintain up to tags</p>
  </div>
  <div class="page">
    <p>Branching Factor</p>
    <p>C o</p>
    <p>rr el</p>
    <p>a te</p>
    <p>d -e</p>
    <p>xp o</p>
    <p>si n</p>
    <p>g p</p>
    <p>ro ba</p>
    <p>b ili</p>
    <p>ty t=20,Static tree t=20,SPA t=200,Static tree t=200,SPA</p>
    <p>Comparison of Static Protocols (under compromising attack)</p>
    <p>Each none-leaf node has 2 keys (1 working key</p>
    <p>and 1 temporary keys).</p>
    <p>Branching Factor  C</p>
    <p>o rr</p>
    <p>e la</p>
    <p>te d -e</p>
    <p>xp o si</p>
    <p>n g p</p>
    <p>ro b a b</p>
    <p>ili ty t=20,Static tree</p>
    <p>t=20,SPA t=200,Static tree t=200,SPA</p>
    <p>Each none-leaf node has 5 keys (1 working key and 4</p>
    <p>temporary keys).</p>
  </div>
</Presentation>
