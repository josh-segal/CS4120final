<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Niklas Buescher, Stefan Katzenbeissser</p>
    <p>USENIX Security Symposium`15</p>
    <p>Faster Secure Computation through Automatic Parallelization</p>
    <p>? 1 x = 1</p>
  </div>
  <div class="page">
    <p>Preliminaries - Secure Two-party Computation (STC)</p>
    <p>Privacy-preserving fingerprint matching between mobile and server</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>Preliminaries - Secure Two-party Computation (STC)</p>
    <p>Privacy-preserving fingerprint matching between mobile and server</p>
    <p>?</p>
    <p>ff(x,y) x</p>
    <p>f(x,y)</p>
    <p>y</p>
  </div>
  <div class="page">
    <p>Preliminaries - Yaos Garbled Circuits</p>
    <p>Andrew Yao</p>
    <p>AND</p>
    <p>Outputs</p>
    <p>Inputs A Inputs B Idea</p>
    <p>Functionalities as Boolean circuits</p>
    <p>Bits  random wire labels</p>
    <p>Gates  garbled truth tables (GTT)</p>
    <p>1 1,1</p>
    <p>3 1,3</p>
  </div>
  <div class="page">
    <p>Preliminaries - Yaos Garbled Circuits</p>
    <p>Andrew Yao</p>
    <p>AND</p>
    <p>Outputs</p>
    <p>Inputs A Inputs B Idea</p>
    <p>Functionalities as Boolean circuits</p>
    <p>Bits  random wire labels</p>
    <p>Gates  garbled truth tables (GTT)</p>
    <p>1 1,1</p>
    <p>3 1,3</p>
    <p>1 1, 2</p>
    <p>1 1, 2</p>
    <p>1 0, 2</p>
  </div>
  <div class="page">
    <p>Preliminaries - Yaos Garbled Circuits</p>
    <p>Andrew Yao</p>
    <p>AND</p>
    <p>Outputs</p>
    <p>Inputs A Inputs B Idea</p>
    <p>Functionalities as Boolean circuits</p>
    <p>Bits  random wire labels</p>
    <p>Gates  garbled truth tables (GTT)</p>
    <p>Generator</p>
    <p>GTTs +</p>
    <p>Input Evaluator</p>
    <p>Secure in the semi-honest model</p>
    <p>1 1,1</p>
    <p>3 1,3</p>
    <p>1 1, 2</p>
    <p>1 1, 2</p>
    <p>1 0, 2</p>
  </div>
  <div class="page">
    <p>Motivation - Practical Yaos Garbled Circuits</p>
    <p>Proof: Lower bound on the number of ciphertexts</p>
    <p>Still a huge gap between STC and generic computation  This work: parallelization</p>
  </div>
  <div class="page">
    <p>Parallel Yao Garbled Circuits</p>
    <p>Parallel garbling: Independent gates or partitions</p>
    <p>of gates can be garbled and evaluated by any</p>
    <p>thread in any order.</p>
    <p>No impact on security [LIP09]</p>
  </div>
  <div class="page">
    <p>Parallelization - Circuit Decomposition</p>
    <p>Inputs</p>
    <p>Outputs</p>
  </div>
  <div class="page">
    <p>Parallelization - Circuit Decomposition</p>
    <p>Fine-grained parallelization (FGP)</p>
    <p>All gates within a level (circuit depth)</p>
    <p>are independent</p>
    <p>Synchronization is needed after</p>
    <p>every level</p>
    <p>Inputs</p>
    <p>Outputs</p>
  </div>
  <div class="page">
    <p>Parallelization - Circuit Decomposition</p>
    <p>Fine-grained parallelization (FGP)</p>
    <p>All gates within a level (circuit depth)</p>
    <p>are independent</p>
    <p>Synchronization is needed after</p>
    <p>every level</p>
    <p>Inputs</p>
    <p>Outputs</p>
    <p>Coarse grained parallelization (CGP)</p>
    <p>Larger coherent partitions</p>
    <p>NP-hard graph partitioning problem</p>
    <p>Our approach: Detect parallelism on</p>
    <p>source code level</p>
  </div>
  <div class="page">
    <p>ParCC - Parallel Circuit Compiler</p>
    <p>C Source with</p>
    <p>input annotations void millionaires() {</p>
    <p>int INPUT_A_wealth, INPUT_B_wealth;</p>
    <p>int OUPUT_res;</p>
    <p>if(INPUT_A_wealth &gt; INPUT_B_wealth)</p>
    <p>OUTPUT_res = 1;</p>
    <p>else</p>
    <p>OUTPUT_res = 0;</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>ParCC - Parallel Circuit Compiler</p>
    <p>C Source with</p>
    <p>input annotations</p>
    <p>Par4all [ACE12]</p>
    <p>ParCC</p>
    <p>source-to-source</p>
    <p>compiler</p>
    <p>void millionaires() {</p>
    <p>int INPUT_A_wealth, INPUT_B_wealth;</p>
    <p>int OUPUT_res;</p>
    <p>if(INPUT_A_wealth &gt; INPUT_B_wealth)</p>
    <p>OUTPUT_res = 1;</p>
    <p>else</p>
    <p>OUTPUT_res = 0;</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>ParCC - Parallel Circuit Compiler</p>
    <p>C Source with</p>
    <p>input annotations</p>
    <p>Par4all [ACE12]</p>
    <p>ParCC</p>
    <p>source-to-source</p>
    <p>compiler Sequential</p>
    <p>Sequential</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>Decomposition</p>
    <p>void millionaires() {</p>
    <p>int INPUT_A_wealth, INPUT_B_wealth;</p>
    <p>int OUPUT_res;</p>
    <p>if(INPUT_A_wealth &gt; INPUT_B_wealth)</p>
    <p>OUTPUT_res = 1;</p>
    <p>else</p>
    <p>OUTPUT_res = 0;</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>ParCC - Parallel Circuit Compiler</p>
    <p>C Source with</p>
    <p>input annotations</p>
    <p>Par4all [ACE12]</p>
    <p>CBMC-GC [HFK12]</p>
    <p>Circuit compiler</p>
    <p>ParCC</p>
    <p>source-to-source</p>
    <p>compiler Sequential</p>
    <p>Sequential</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>Decomposition</p>
    <p>void millionaires() {</p>
    <p>int INPUT_A_wealth, INPUT_B_wealth;</p>
    <p>int OUPUT_res;</p>
    <p>if(INPUT_A_wealth &gt; INPUT_B_wealth)</p>
    <p>OUTPUT_res = 1;</p>
    <p>else</p>
    <p>OUTPUT_res = 0;</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>ParCC - Parallel Circuit Compiler</p>
    <p>C Source with</p>
    <p>input annotations</p>
    <p>Par4all [ACE12]</p>
    <p>CBMC-GC [HFK12]</p>
    <p>Circuit compiler</p>
    <p>ParCC</p>
    <p>source-to-source</p>
    <p>compiler Sequential</p>
    <p>Sequential</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>Decomposition Circuits</p>
    <p>void millionaires() {</p>
    <p>int INPUT_A_wealth, INPUT_B_wealth;</p>
    <p>int OUPUT_res;</p>
    <p>if(INPUT_A_wealth &gt; INPUT_B_wealth)</p>
    <p>OUTPUT_res = 1;</p>
    <p>else</p>
    <p>OUTPUT_res = 0;</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Evaluation - Example Applications and Circuit Properties</p>
    <p>Biometric Matching (BioMatch):</p>
    <p>Database with n = 512 samples of</p>
    <p>degree d = 4; 64 bit integers</p>
    <p>=1  1,</p>
    <p>,   2</p>
    <p>Parallel Modular Exponentiation (MExp):</p>
    <p>Matrix-Vector Multiplication (MVMul):</p>
    <p>BioMatch MExp MVMul</p>
    <p>Circuit</p>
    <p>Size 66M 21.5M 3.3M</p>
    <p>%AND 25% 41% 37%</p>
    <p>Inputs bits 512 / 112K 1K / 1K 17K / 1K</p>
    <p>Offline</p>
    <p>garbling time 2.07s 1.136s 0.154s</p>
  </div>
  <div class="page">
    <p>Parallel Framework  Implementation and Testbed</p>
    <p>UltraSFE:</p>
    <p>Based on: JustGarble, ME_SFE (FastGC)</p>
    <p>Focus: Parallelization, low memory footprint</p>
    <p>Garbled row reduction, pipe-lining, fixed-key garbling with AES-NI, half-gates</p>
    <p>Written in C++, OpenMP and pthreads, SSE4.2</p>
    <p>Testbed:</p>
    <p>Amazon EC2  c3.8xlarge instance (report 16 physical cores)</p>
    <p>Serial garbling speed ~8M AND gates / s</p>
  </div>
  <div class="page">
    <p>Results  Circuit Garbling (offline)</p>
    <p>Speed-up of FGP for a different</p>
    <p>number of cores.</p>
  </div>
  <div class="page">
    <p>Results  Circuit Garbling (offline)</p>
    <p>Speed-up of FGP and CGP for a</p>
    <p>different number of cores.</p>
    <p>CGP significantly outperforms FGP</p>
  </div>
  <div class="page">
    <p>The Limits of Fine-Grained Parallelization</p>
    <p>Increasing input sizes should overcome limits of FGP  Not really:</p>
    <p>Distribution of level widths in number of non-linear gates</p>
    <p>when compiled with CBMC-GC</p>
  </div>
  <div class="page">
    <p>The Limits of Fine-Grained Parallelization</p>
    <p>Increasing input sizes should overcome limits of FGP  Not really:</p>
    <p>Distribution of level widths in number of non-linear gates</p>
    <p>when compiled with CBMC-GC</p>
    <p>Current high level compiler are</p>
    <p>optimized for Free-XOR but not width</p>
    <p>Examples:</p>
    <p>Array accesses compile to</p>
    <p>multiplexers with constant width</p>
    <p>Comparisons compile to circuits with</p>
    <p>constant width</p>
  </div>
  <div class="page">
    <p>Results - CGP in the Online Setting</p>
    <p>Security levels: 80bit and 128bit</p>
    <p>Throughput: ~7M AND gates</p>
    <p>Bandwidth req.: ~1  1.5 Gbit / core</p>
  </div>
  <div class="page">
    <p>Results - CGP in the Online Setting</p>
    <p>Security levels: 80bit and 128bit</p>
    <p>Throughput: ~7M AND gates</p>
    <p>Bandwidth req.: ~1  1.5 Gbit / core</p>
    <p>Can we overcome the boundary?</p>
  </div>
  <div class="page">
    <p>Results - CGP in the Online Setting</p>
    <p>Security levels: 80bit and 128bit</p>
    <p>Throughput: ~7M AND gates</p>
    <p>Bandwidth req.: ~1  1.5 Gbit / core</p>
    <p>Can we overcome the boundary?</p>
    <p>Yes! See next slides</p>
  </div>
  <div class="page">
    <p>Inter-Party Parallelization (IPP)</p>
    <p>a.) Yaos Garbled Circuits</p>
  </div>
  <div class="page">
    <p>Inter-Party Parallelization (IPP)</p>
    <p>a.) Yaos Garbled Circuits b.) Coarse-grained</p>
    <p>decomposition</p>
  </div>
  <div class="page">
    <p>Inter-Party Parallelization (IPP)</p>
    <p>a.) Yaos Garbled Circuits b.) Coarse-grained</p>
    <p>decomposition</p>
    <p>c.) Inter-party parallelization</p>
    <p>Similar computation power  Speed-up of 1.6 / 1.33</p>
  </div>
  <div class="page">
    <p>Inter-Party Parallelization (IPP) for Mixed Functionalities</p>
    <p>Sequential</p>
    <p>Sequential</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
  </div>
  <div class="page">
    <p>Inter-Party Parallelization (IPP) for Mixed Functionalities</p>
    <p>Sequential</p>
    <p>Sequential</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
  </div>
  <div class="page">
    <p>Inter-Party Parallelization (IPP) for Mixed Functionalities</p>
    <p>Sequential</p>
    <p>Sequential</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>P a ra</p>
    <p>lle l</p>
    <p>Transferring roles  secure state sharing</p>
    <p>P a ra</p>
    <p>lle l</p>
  </div>
  <div class="page">
    <p>Results  Inter-Party Parallelization</p>
    <p>High bandwidth environments (10Gbit)</p>
    <p>Cores BioMatch MExp</p>
    <p>Speed-up</p>
  </div>
  <div class="page">
    <p>Results  Inter-Party Parallelization</p>
    <p>High bandwidth environments (10Gbit)</p>
    <p>Cores BioMatch MExp</p>
    <p>Low bandwidth environments (100Mbit)</p>
    <p>Speed-up Time and speed-up</p>
    <p>BioMatch MExp</p>
    <p>raw 45.00.5s 24.10.2s</p>
    <p>IPP 29.90.3s 16.10.1s</p>
    <p>S 1.5 1.5</p>
  </div>
  <div class="page">
    <p>Conclusion &amp; Outlook</p>
    <p>Automatized toolchain for parallel circuits</p>
    <p>Yaos Garbled Circuits profits from automatic parallelization</p>
    <p>Network boundaries have been reached</p>
    <p>Outlook</p>
    <p>Open source releases of ParCC and UltraSFE</p>
    <p>IPP in other STC protocols</p>
  </div>
  <div class="page">
    <p>Questions and Answers</p>
    <p>Thank you!</p>
  </div>
  <div class="page">
    <p>References</p>
    <p>[ACE12] Amini, M., Creusillet, B., Even, S., Keryell, R., Goubier, O., Guelton, S.,  Villalon, P. (2012). Par4All: From Convex</p>
    <p>Array Regions to Heterogeneous Computing. In Workshop on Polyhedral Compilation Techniques.</p>
    <p>[BBL14] Barni, M., Bernaschi, M., Lazzeretti, R., Pignata, T., &amp; Sabellico, A. (2014). Parallel Implementation of GC-Based MPC</p>
    <p>Protocols in the Semi-Honest Setting. In Data Privacy Management and Autonomous Spontaneous Security.</p>
    <p>[BHK] Bellare, Mihir, et al. &quot;Efficient garbling from a fixed-key blockcipher.&quot; Security and Privacy (SP), 2013 IEEE Symposium</p>
    <p>on. IEEE, 2013.</p>
    <p>[FKN14] Frederiksen, T. K., Jakobsen, T. P., &amp; Nielsen, J. B. (2014). Faster maliciously secure two-party computation using the</p>
    <p>GPU. In Security and Cryptography for Networks SCN (pp. 358379).</p>
    <p>[HEK11] Huang, Y., Evans, D., Katz, J., &amp; Malka, L. (2011). Faster Secure Two-Party Computation Using Garbled Circuits. In</p>
    <p>USENIX Security Symposium (pp. 812).</p>
    <p>[HMS13] Husted, N., Myers, S., Shelat, A., &amp; Grubbs, P. (2013). GPU and CPU parallelization of honest-but-curious secure two</p>
    <p>party computation. In Annual Computer Security Applications Conference ACSAC.</p>
  </div>
  <div class="page">
    <p>References</p>
    <p>[HFK12] Holzer, A., Franz, M., Katzenbeisser, S., &amp; Veith, H. (2012). Secure Two-Party Computations in ANSI C. In ACM</p>
    <p>Conference on Computer and Communications Security CCS.</p>
    <p>[KS08] Kolesnikov, V., &amp; Schneider, T. (2008). Improved garbled circuit: Free XOR gates and applications. In International</p>
    <p>Conference on Automata, Languages and Programming ICALP.</p>
    <p>[MNP04] Malkhi, D., Nisan, N., Pinkas, B., &amp; Sella, Y. (2004). Fairplay-Secure Two-Party Computation System. In USENIX</p>
    <p>Security Symposium.</p>
    <p>[LIP09] Lindell, Y., &amp; Pinkas, B. (2009). A proof of security of yaos protocol for two-party computation. Journal of Cryptology.</p>
    <p>[NWI15] Nayak, K., Wang, X. S., Ioannidis, S., Weinsberg, U., Taft, N., &amp; Shi, E. (2015). GraphSC: Parallel Secure Computation</p>
    <p>Made Easy. In IEEE Symposium on Security and Privacy S&amp;P.</p>
    <p>[KSS12] Kreuter, B., Shelat, A., &amp; Shen, C. (2012). Billion-Gate Secure Computation with Malicious Adversaries. USENIX</p>
    <p>Security Symposium.</p>
    <p>[ZRE15] Zahur, S., Rosulek, M., &amp; Evans, D. (2015). Two halves make a whole. In Advances in Cryptology - EUROCRYPT.</p>
  </div>
</Presentation>
