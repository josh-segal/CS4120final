<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Black-Box Methods for Cost-Sharing Mechanism</p>
    <p>Design</p>
    <p>Chaitanya Swamy University of Waterloo</p>
    <p>Joint work with Konstantinos Georgiou</p>
    <p>University of Waterloo</p>
  </div>
  <div class="page">
    <p>Cost-sharing mechanism design</p>
    <p>A service provider has to decide which players to serve</p>
    <p>Provider incurs a publicly-known cost for serving a set of players</p>
    <p>Each payer has a private value for receiving the service</p>
    <p>Players are selfish  only care about maximizing their utility and will lie if that increases their utility</p>
  </div>
  <div class="page">
    <p>Cost-sharing mechanism design</p>
    <p>A service provider has to decide which players to serve Provider incurs a publicly-known cost for serving a set of</p>
    <p>players</p>
    <p>Each payer has a private value for receiving the service Players are selfish  only care about maximizing their</p>
    <p>utility and will lie if that increases their utility  Cannot assume service provider knows the true private values, but we seek solution that is good with respect to true input</p>
    <p>Cost-sharing mechanism = algorithm to compute a good solution</p>
    <p>+ prices that induce players to act truthfully AND recover the cost incurred by the provider</p>
  </div>
  <div class="page">
    <p>Cost-sharing mechanismdesign</p>
    <p>Formally, C(S) = cost-incurred for serving set S of players</p>
    <p>(assume C()=0, C(S)  C(T) if ST)</p>
    <p>vi = private value/type of player i</p>
    <p>Cost-sharing mechanism M = (f, {pi}i=1n)</p>
    <p>Players report types t1,,tn (let t=(t, ,tn))</p>
    <p>Mechanism computes solution S = f(t)  {1, ,n}, and charges price pi(t) to each player i (usually 0 if iS)</p>
    <p>utility of i = vi(S)  pi(t) (where vi(A) = vi if iA else 0)</p>
    <p>algorith m</p>
    <p>price charged to player i</p>
  </div>
  <div class="page">
    <p>Algorithms to compute solns. with near-opt. social welfare (i.e., approx. algorithms for social-costminimization)</p>
    <p>Truthful mechanisms</p>
    <p>Truthful, costrecovering mechanisms</p>
    <p>Goals and Objectives</p>
    <p>Want mechanisms lying here: seek to understand how the 3 objectives interact/conflict</p>
  </div>
  <div class="page">
    <p>Goals and Objectives</p>
    <p>Want to design M such that: a) M is truthful (strategyproof)  every i maximizes its utility by reporting its true value regardless of other players' bids b) S has good social welfare  quantify using social-cost objective [Roughgarden-Sundararajan]:</p>
    <p>SC(t, S) := C (S) + iS ti  minA SC(t, A)</p>
    <p>c) Cost-recovery  prices recover the cost: i pi(t)  C (S)</p>
    <p>Recall: M = (f, {pi}), t=(t1,,tn): reported input, S = f(t)</p>
    <p>Impossible to satisfy a)  c); C(.) is often NP-hard to compute, so we relax conditions suitably</p>
  </div>
  <div class="page">
    <p>Goals and Objectives</p>
    <p>Want to design M such that: a) M is truthful (strategyproof)  every i maximizes its utility by reporting its true value regardless of other players' bids b) S has good social welfare  quantify using social-cost objective [Roughgarden-Sundararajan (RS09)]:</p>
    <p>SC(t, S) := CM(S) + iS ti   minA SC(t, A)</p>
    <p>c) Cost-recovery  prices recover the cost: i pi(t)  CM(S) /</p>
    <p>Recall: M = (f, {pi}), t=(t1,,tn): reported input, S = f(t)</p>
    <p>Impossible to satisfy a)  c); also C(.) often NP-hard to compute, so we relax conditions suitably (Note: VCG satifies a), b), but gives poor revenue;</p>
    <p>Moulin mechanisms (in general) satisfy a), c) but sacrifice b)</p>
    <p>Truthful, approximation, cost-recovering mechanism</p>
    <p>Cost of solution computed by M for S</p>
  </div>
  <div class="page">
    <p>Algorithms to compute solns. with near-opt. social welfare (i.e., approx. algorithms for social-costminimization)</p>
    <p>Truthful mechanisms</p>
    <p>Truthful, costrecovering mechanismsVCG</p>
    <p>Moulin mechanisms</p>
    <p>Goals and Objectives</p>
    <p>Want mechanisms lying here: seek to understand how the 3 objectives interact/conflict</p>
  </div>
  <div class="page">
    <p>Example: Steiner-tree costsharing</p>
    <p>C(S) = opt. Steiner tree cost on S{r}</p>
    <p>Social-cost-minimization (SCM) problem  prize-collecting Steiner tree</p>
    <p>A truthful, -approximation, -cost-recovering mechanism outputs:  -approx. solution to SCM problem  prices that recover -fraction of cost of output tree</p>
    <p>: Terminals  Players: Root r : Node</p>
  </div>
  <div class="page">
    <p>Three types of objects</p>
    <p>(C) Approximation algorithms</p>
    <p>for SCM problem</p>
    <p>(B) Truthful, approximation mechanisms</p>
    <p>(A) Truthful, approximation, cost</p>
    <p>recovering mechanisms</p>
    <p>Very limited understanding: most results rely on constructing cost-shares with suitable properties, which can be very challenging (or impossible!)  constructions are quite problem-specific and often rather intricateBetter understanding: nice characterization (for 1D problems) of truthful mechanisms, allows one to leverage algorithmic techniques Good understanding: numerous techniques: LP rounding, primal-dual, ...</p>
  </div>
  <div class="page">
    <p>Are there reductions b/w A, B, C?</p>
    <p>(C) Approximation</p>
    <p>algorithms for SCM problem</p>
    <p>(B) Truthful, approximati</p>
    <p>on mechanism</p>
    <p>s</p>
    <p>(A) Truthful, approximati</p>
    <p>on, costrecovering</p>
    <p>mechanisms</p>
  </div>
  <div class="page">
    <p>Are there reductions b/w A, B, C?</p>
    <p>Our work: YES! (C) Approximation</p>
    <p>algorithms for SCM problem</p>
    <p>(B) Truthful, approximat</p>
    <p>ion mechanism</p>
    <p>s</p>
    <p>(A) Truthful, approximati</p>
    <p>on, costrecovering</p>
    <p>mechanisms</p>
    <p>Reduction (1): B  A Input: truthful, -approximation, no-bossy mechanism Output: truthful, O(.log n)-approx., costrecovering mechanism  can inject cost-recovery into any no-bossy mechanism (B)</p>
    <p>()</p>
    <p>i f(t), i  f(t'i, t-i)  f(t)= f(t'i, t-i)</p>
  </div>
  <div class="page">
    <p>Are there reductions b/w A, B, C?</p>
    <p>Our work: YES! (C) Approximation</p>
    <p>algorithms for SCM problem</p>
    <p>(B) Truthful, approximati</p>
    <p>on mechanism</p>
    <p>s</p>
    <p>(A) Truthful, approximati</p>
    <p>on, costrecovering</p>
    <p>mechanisms</p>
    <p>Reduction (): B  A (works for any cost f'n.) Input: truthful, -approximation, no-bossy mechanism Output: truthful, O(.log n)-approx., costrecovering mechanism  can inject cost-recovery into any no-bossy mechanism (B)  First reduction for general costs (subadditive C(.): Bleischwitz et al.)  log n factor matches the lower bound of Dobzinski et al. (D+08)</p>
    <p>()</p>
    <p>i f(t), i  f(t'i, t-i)  f(t)= f(t'i, t-i)</p>
  </div>
  <div class="page">
    <p>Approximation algorithms for socialcost-minimization</p>
    <p>Truthful mechanisms</p>
    <p>Truthful, costrecovering mechanismsVCG</p>
    <p>Truthful, nobossy mechanisms</p>
    <p>Nice application: taking input = VCG, get that for every cost-f'n., there is a truthful, O(log n)-approx., cost-recovering mechanism</p>
  </div>
  <div class="page">
    <p>Are there reductions b/w A, B, C?</p>
    <p>Our work: YES! (C) Approximation</p>
    <p>algorithms for SCM problem</p>
    <p>(B) Truthful, approximat</p>
    <p>ion mechanism</p>
    <p>s</p>
    <p>(A) Truthful, approximati</p>
    <p>on, costrecovering</p>
    <p>mechanisms</p>
    <p>Reduction (): B  A (works for any cost-f'n.) Input: truthful, -approximation, no-bossy mechanism Output: truthful, O(.log n)-approx., costrecovering mechanism</p>
    <p>Reduction (2): C  B Input: LP-relative -approx. algorithm for costminimization (CM) problem (find a min-cost solution for a given set of players) Output: truthful, ()-approximation, no bossy mechanism Works whenever LP-relaxation of CM problem is covering like</p>
    <p>() (2)</p>
  </div>
  <div class="page">
    <p>Approximation algorithms for socialcost-minimization</p>
    <p>Truthful mechanisms</p>
    <p>Truthful, costrecovering mechanisms</p>
    <p>Truthful, nobossy mechanisms</p>
    <p>+ 1</p>
    <p>So for a rich class of problems, can convert any LP-relative -approximation algorithm for CM problem to truthful, O(.log n)-approx., costrecovering mechanism</p>
  </div>
  <div class="page">
    <p>Reductions find numerous applications.  First guarantees for:</p>
    <p>{edge, vertex, element}-disjoint survivable network design: C(S) = cost of connecting set S of (si, ti) pairs (allow edges with multiplicity)</p>
    <p>makespan minimization on unrelated machines: C(S) = makespan for scheduling set S of jobs</p>
    <p>soft-capacitated facility location (FL): C(S) = cost of serving set S of clients</p>
    <p>Improved guarantees (approx. improves to O(log n)) for:  Steiner {tree, forest}  multicommodity connected FL</p>
    <p>For many problems, D+08 gives matching log n lower bound</p>
    <p>Previous work gives stronger notions of truthfulness: group-strategyproofness (GSP) and its variants</p>
  </div>
  <div class="page">
    <p>Two departures from earlier work</p>
    <p>Focus on truthfulness, so we are not considering the effect of coalitions</p>
    <p>Do not impose any upper bound on revenue (like i pi(t)  C(S)):  usual rationale for upper bound: otherwise players</p>
    <p>in S may collude and secede from the mechanism  We do not consider coalitions, so do not impose</p>
    <p>this; instead we project this condition to individual players and consider Individual Competitiveness (ICT): pi(t)  C({i}) i</p>
    <p>Makes sense to require ICT for subadditive C(.), in which case our constructions do ensure ICT</p>
  </div>
  <div class="page">
    <p>Related Work  Moulin and Moulin-Shenker introduced Moulin mechanisms</p>
    <p>show that cost-shares having certain properties yield GSP, cost-recovering mechanisms</p>
    <p>Roughgarden-Sundararajan (RS09) introduced social-cost objective, identified another property of cost-shares which yields good approximation for Moulin mechanisms</p>
    <p>Lots of work on devising suitable cost shares for various problems  methods are problem-specific and often intricate</p>
    <p>Immorlica et al. exposed an inherent limitation of this approach  designing suitable cost shares may be impossible</p>
    <p>Mehta et al. modified Moulin mechanisms  require weaker properties of cost-shares and yield weakly-GSP mechanisms</p>
  </div>
  <div class="page">
    <p>Related Work (contd.)</p>
    <p>Bleischwitz et al. (B+07), Brenner-Schafer propose some black-box reductions converting algorithms (C) to cost-recovering mechanisms (A)  both results require various conditions on the approximation algorithm and cost f'n., which seem</p>
    <p>much more restrictive (and slightly unnatural) compared to our condition of LP-relative approx.  B+07 also give a O(log n)-approx., cost-recovering</p>
    <p>weakly GSP mechanism for any subadditive C(.)</p>
  </div>
  <div class="page">
    <p>Some ingredients of our results</p>
    <p>Useful characterization of truthful mechanisms (Myerson) An algorithm f is monotone if</p>
    <p>i f(z, t-i) and z' &gt; z implies that i f(z', t-i)</p>
    <p>Suppose f is monotone. Set pi(ti, t-i) = min {z: i f(z, ti)} if i wins, and 0 otherwise, for every i. Then, (f, p) is a truthful mechanism and players' utilities are nonnegative (when they bid truthfully). So we concentrate on designing monotone algorithms with desirable properties (prices always set as above).</p>
    <p>i f(z, t-i)</p>
    <p>z i  f(z, t-i)</p>
  </div>
  <div class="page">
    <p>Reduction 1: injecting costrecovery</p>
    <p>Given: truthful, -approximation, no bossy mechanism M = (g, {qi})</p>
    <p>On input t, run Moulin mechanism initialized with output of M and with uniform cost shares. 1. Initialize k=0, S0 = g(t)</p>
    <p>k=k+1 3. Return f(t) = Sk (and prices pi(t) are set to threshold values)</p>
    <p>Why does this work? Truthfulness: Moulin construction preserves monotonicity if if(t), z' &gt; ti, then i g(z', t-i)  g(t) = g(z', t-i) (M truthful, no-bossy) so runs on t and (z', t-i) are identical  f(t) = f(z', t-i) (and i f(z', t-i))</p>
    <p>Threshold of each winner i is max {qi(t), C(S0)/|S0|, ... , C(Sk)/|Sk|}</p>
  </div>
  <div class="page">
    <p>Reduction : injecting costrecovery</p>
    <p>Given: truthful, -approximation, no bossy mechanism M = (g, {qi})</p>
    <p>On input t, 1. Initialize k=0, S0 = g(t)</p>
    <p>k=k+ 3. Return f(t) = Sk (and prices pi(t) are set to threshold values)</p>
    <p>Why does this work? Truthfulness: Moulin construction preserves monotonicity Threshold of each winner i is max {qi(t), C(S0)/|S0|, ... , C(Sk)/|Sk|}</p>
    <p>Cost-recovery: clear since each i  Sk pays at least C(Sk)/|Sk|</p>
    <p>Approximation: we know C(S0) + iS0 ti  (minA SC(t,</p>
    <p>A)) By our rule for rejecting players, iS0\Sk ti  O(log</p>
    <p>n)C(S0) so get O(.log n)-approximation</p>
  </div>
  <div class="page">
    <p>Reduction 2: main idea Consider Steiner-tree cost-sharing (for simplicity) Have LP-based =2-approximation for costminimization problem.</p>
    <p>Minimize e cexe + i vi zi (LP) subject to</p>
    <p>e(S) xe + zi  1 for all sets S: rS, all iS</p>
    <p>x, z  0</p>
    <p>Dual LP is of the form: Maximize i,S i,S s.t.  S: rS, iS i,S  vi for all i,   0</p>
    <p>So if z*i &gt; 0, then S: rS, iS  * i,S = vi  can reject all i s.t.</p>
    <p>z*i &gt; 0 at the expense of OPTLP ; serve all other i at cost  .OPTLP .</p>
    <p>No bossiness:  vi of winner leaves z * i=0; hence LP</p>
    <p>soln. unchanged.</p>
  </div>
  <div class="page">
    <p>To summarize,</p>
    <p>Give two black-box reductions to convert (1) Truthful, approximation, no-bossy mechanisms  cost-sharing mechanisms (2) LP-relative approximation algorithms  truthful, approximation, no-bossy mechanisms</p>
    <p>Reduce cost-sharing mechanism design to algorithm design</p>
    <p>Various applications: first / improved / matching guarantees for SNDP, FL, makespan-minimization, ...</p>
    <p>Also, have some extensions to multidimensional settings (players own multiple elements, or require multiple levels of service) but guarantees degrade with dimensionality</p>
  </div>
  <div class="page">
    <p>Open Questions</p>
    <p>Multidimensional cost-sharing problems  Better guarantees?  Are there similar black-box reductions? (We</p>
    <p>can show: a -LMP approximation algorithm can be exported to a truthful-in-expect., -approx. mechanism, but do not know how to inject cost recovery.)</p>
    <p>Can one avoid no-bossiness in first reduction?</p>
    <p>Black-box reductions with other notions of incentive-compatibility?</p>
  </div>
  <div class="page">
    <p>Thank You.</p>
  </div>
</Presentation>
