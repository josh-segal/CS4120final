<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Towards Formal Verification of Memory Management Properties</p>
    <p>using Separation Logic Reynald Affeldt</p>
    <p>AIST-RCIS Nicolas Marti University of Tokyo</p>
    <p>Akinori Yonezawa University of Tokyo</p>
    <p>AIST-RCIS</p>
  </div>
  <div class="page">
    <p>Research Project</p>
    <p>Verification of low-level software:  Specialized operating systems  Device drivers</p>
    <p>Difficulties:  Memory management  Hardware-dependent specifications</p>
    <p>Our approach:  Verification in the Coq proof assistant [INRIA, 1984-2005]  Using Separation Logic [Reynolds et al., 1999-2005]</p>
  </div>
  <div class="page">
    <p>This Presentation</p>
    <p>Use-case:  The Topsy operating system:</p>
    <p>Specialized o.s. for network cards [Ruf, ANTA 2003]  Also used for educational purpose (in Swiss)</p>
    <p>Verification of memory isolation:  Intuitively, user-level threads cannot access kernel-level</p>
    <p>memory [Bevier, IEEE Trans. 1988]  Obvious relation with security:</p>
    <p>E.g., a user application replacing the process descriptor of an authentication server</p>
    <p>Coq implementation overview</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Memory Isolation for Topsy  Specification Approach  Informal Specification</p>
    <p>Excerpt of Formal Verification  The Allocation Function  Formal Specification and Verification</p>
    <p>Coq Implementation  Related and Future Work</p>
  </div>
  <div class="page">
    <p>Memory Isolation for Topsy</p>
    <p>Reminder:  user-level threads cannot access kernel-level</p>
    <p>memory  In practice (for x86 processors):</p>
    <p>Each thread and segment is given a privilege level  The hardware guarantees that user-level threads can</p>
    <p>only access user-level segments under the hypothesis that the operating system correctly manages privilege levels!</p>
  </div>
  <div class="page">
    <p>Where do We Need to Look?</p>
    <p>Topsy control-flow:</p>
  </div>
  <div class="page">
    <p>What do We Need to Verify?</p>
    <p>Topsy source code:</p>
  </div>
  <div class="page">
    <p>Memory Isolation for Topsy  Informal specification:</p>
    <p>Boot loader and kernel initialization:  The boot loader builds the intended memory model and the</p>
    <p>processor runs in segmented mode</p>
    <p>Heap manager:  Newly allocated blocks do not override previously allocated</p>
    <p>blocks and only free blocks are marked as such</p>
    <p>Thread manager:  Thread descriptors for user-level threads are initialized with</p>
    <p>user privilege and context switching preserves this privilege</p>
    <p>Next slides</p>
    <p>See paper and website for details</p>
    <p>See paper and website for details</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Memory Isolation for Topsy  Specification Approach  Informal Specification</p>
    <p>Excerpt of Formal Verification  The Allocation Function  Formal Specification and Verification</p>
    <p>Coq Implementation  Related and Future Work</p>
  </div>
  <div class="page">
    <p>The Allocation Function</p>
    <p>Signature:</p>
    <p>The underlying data structure:  Blocks organized as a list</p>
    <p>E.g., a heap-list with two free blocks and one allocated block:</p>
    <p>The heap-list covers a fixed region of memory reserved by the kernel</p>
    <p>hmAlloc (y, sizey);</p>
  </div>
  <div class="page">
    <p>hmAlloc: Implementation</p>
    <p>if (y == 0) return ERROR;</p>
    <p>/* split the found block to the appropriate size */ split (y, sizey);</p>
    <p>/* if not found, compact and search again */ if (y == 0) {</p>
    <p>compact(); y = findFree (sizey);</p>
    <p>}</p>
    <p>Overall effect:</p>
    <p>hmAlloc (y, sizey);</p>
    <p>/* look for a large-enough block */ y = findFree (sizey);</p>
    <p>y sizey y</p>
  </div>
  <div class="page">
    <p>Potential Problems Relevant to Memory Isolation</p>
    <p>Unexpected situations:</p>
    <p>Separation logic [Reynolds et al., 1999-2005] provides convenient formulas for such specifications</p>
    <p>hmAlloc (y, sizey);</p>
    <p>y sizey</p>
    <p>hmAlloc (y, sizey);</p>
    <p>y sizey</p>
  </div>
  <div class="page">
    <p>Separation Logic Formulas</p>
    <p>Provides a symbolic representation of memory storage:  Atoms:</p>
    <p>E.g.,  Separating conjunction:</p>
    <p>P  Q holds when the storage can be split into two parts that respectively satisfy P and Q</p>
    <p>E.g., does not hold if lo=l1  Neutral: emp</p>
    <p>)()( 1100 elel aa</p>
    <p>)( 00 el a</p>
  </div>
  <div class="page">
    <p>The Heap-list Predicate</p>
    <p>The Array predicate:  An array is a set of</p>
    <p>contiguous locations  The Heap-list predicate:</p>
    <p>Inductively, a heap-list is either:</p>
    <p>An empty list, or  A free block followed by a</p>
    <p>heap-list, or  An allocated block</p>
    <p>followed by a heap-list )())2()2(( ),().(</p>
    <p>)())2()2( ),().(</p>
    <p>),.(</p>
    <p>nextlnextl nextallocatedlnilnextnext</p>
    <p>nextlnextl nextfreelnilnextnext</p>
    <p>nilstlst l</p>
    <p>list-Heap Array</p>
    <p>list-Heap (Array</p>
    <p>list-Heap</p>
    <p>+</p>
    <p>+</p>
    <p>=</p>
    <p>a</p>
    <p>a</p>
    <p>a</p>
    <p>))))1()1(().((0( )0(</p>
    <p>+&gt; =</p>
    <p>=</p>
    <p>szlelesz sz</p>
    <p>szl</p>
    <p>Array emp Array</p>
    <p>a</p>
    <p>Formal predicates:</p>
  </div>
  <div class="page">
    <p>The Heap-List Predicate (contd)</p>
    <p>Heap-lists with holes:  Heap-List A F x holds for a heap-list without</p>
    <p>the blocks in A or F  E.g.:</p>
    <p>Heap-List {} {} x holds for x</p>
    <p>x</p>
    <p>x</p>
    <p>f</p>
    <p>a</p>
    <p>Heap-List {} {f} x holds for</p>
    <p>Heap-List {a} {} x holds for</p>
  </div>
  <div class="page">
    <p>Formal Specification of hmAlloc</p>
    <p>{ }</p>
    <p>=</p>
    <p>x</p>
    <p>x</p>
    <p>y</p>
    <p>y</p>
    <p>x</p>
    <p>sizexbasehmxy</p>
    <p>sizeysizexbasehmyx</p>
    <p>sizesizesize sizey</p>
    <p>sizexbasehmx</p>
    <p>Array List-Heap</p>
    <p>Array Array List-Heap</p>
    <p>); ,(hmAlloc Array List-Heap</p>
    <p>_}{}{0</p>
    <p>_}{},{</p>
    <p>.</p>
    <p>_}{}{</p>
  </div>
  <div class="page">
    <p>Proof Overview (1/2)</p>
    <p>{ }</p>
    <p>=</p>
    <p>=</p>
    <p>==</p>
    <p>=</p>
    <p>x</p>
    <p>x</p>
    <p>y</p>
    <p>y</p>
    <p>y</p>
    <p>x</p>
    <p>sizexbasehmxy</p>
    <p>sizeysizexbasehmyx</p>
    <p>sizesizesize</p>
    <p>sizey</p>
    <p>y</p>
    <p>sizey sizexbasehmx</p>
    <p>Array List-Heap</p>
    <p>Array Array List-Heap</p>
    <p>} );( findFree</p>
    <p>(); compact { )( if</p>
    <p>);( findFree Array List-Heap</p>
    <p>_}{}{0</p>
    <p>_}}{{</p>
    <p>.</p>
    <p>_}{}{</p>
  </div>
  <div class="page">
    <p>Proof Overview (2/2)</p>
    <p>=</p>
    <p>==</p>
    <p>=</p>
    <p>x</p>
    <p>x</p>
    <p>y</p>
    <p>y</p>
    <p>x</p>
    <p>x</p>
    <p>y</p>
    <p>sizexbasehmxy</p>
    <p>sizeysizexbasehmyx</p>
    <p>sizesizesize sizey</p>
    <p>y</p>
    <p>sizexbasehmxy</p>
    <p>sizeysizexbasehmyx</p>
    <p>sizesizesize</p>
    <p>Array List-Heap</p>
    <p>Array Array List-Heap</p>
    <p>); ,( split }</p>
    <p>ERROR; return { )( if</p>
    <p>Array List-Heap</p>
    <p>Array Array List-Heap</p>
    <p>_}{}{0</p>
    <p>_}{},{</p>
    <p>.</p>
    <p>_}{}{0</p>
    <p>_}}{{</p>
    <p>.</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Memory Isolation for Topsy  Specification Approach  Informal Specification</p>
    <p>Excerpt of Formal Verification  The Allocation Function  Formal Specification and Verification</p>
    <p>Coq Implementation  Related and Future Work</p>
  </div>
  <div class="page">
    <p>Coq Implementation</p>
    <p>Reusable part (around 6500 lines):  Core separation logic</p>
    <p>[Reynolds, LICS 2002]</p>
    <p>Additional facilities  Data structures, lemmas, etc.</p>
    <p>Use-case part (around 4500 lines):  Translation of Topsy functions</p>
    <p>C and assembly code (around 300 lines)</p>
    <p>Specification and verification  In progress (some elementary steps left out for lack of time)</p>
    <p>Next slide</p>
    <p>Overview in previous slides</p>
  </div>
  <div class="page">
    <p>Coq Implementation (Reusable part)</p>
    <p>Core separation</p>
    <p>logic</p>
    <p>Additional facilities</p>
    <p>Commands</p>
    <p>Assignments pointer dereferences, destructive updates,</p>
    <p>loops, etc.</p>
    <p>States</p>
    <p>Variables and heap</p>
    <p>Formulas</p>
    <p>, , , , , =, etc.</p>
    <p>Satisfaction relation |=</p>
    <p>Operational semantics</p>
    <p>st  c st</p>
    <p>Hoare triples {P}c{Q}</p>
    <p>Data structures (arrays, lists), lemmas (split, concatenation, insertion, etc.), weakest preconditions generator (triples for backward reasoning), frame rule (for compositional reasoning), tactics for heap partitions</p>
    <p>Soundness</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Memory Isolation for Topsy  Specification Approach  Informal Specification</p>
    <p>Excerpt of Formal Verification  The Allocation Function  Formal Specification and Verification</p>
    <p>Coq Implementation  Related and Future Work</p>
  </div>
  <div class="page">
    <p>Related Work  Proof assistant-based verification:</p>
    <p>Verification of micro-kernels:  Delta-core [Zhu et al., O.S.Review 2001]</p>
    <p>Commercial o.s. verified in PowerEpsilon  Verification of error-recovery of system calls</p>
    <p>VFiasco [Hohmuth and Tews, ECOOP-PLOS 2005]  C++ translation into PVS</p>
    <p>Verification of C programs:  Schorr-Waite algorithm in Coq [Hubert and Marche, SEFM 2005]</p>
    <p>Separation logic encoding:  In Isabelle [Weber, CSL 2004]</p>
    <p>Verification using separation logic:  Decidable fragment [Berdine et al., FSTTCS 2004]  Symbolic evaluator [Berdine et al., APLAS 2005]</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Implementation in progress:  Complete libraries of lemmas for data structures  Polish verification of memory isolation for Topsy</p>
    <p>Automate verification:  Interface with the symbolic evaluator of [Berdine et al.,</p>
    <p>APLAS 2005]:  Verification of their implementation as a side-effect</p>
    <p>Semi-automatic generation of loop invariants  Interface with theorem provers for BI logic?</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>We have presented:  A reusable implementation of separation logic</p>
    <p>in the Coq proof assistant  A real-world use-case: memory isolation for</p>
    <p>the Topsy operating system  Overview of memory allocation, see the paper and</p>
    <p>the website for the rest of the verification (boot loader, memory and thread management)</p>
  </div>
</Presentation>
