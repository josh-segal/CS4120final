<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Page 1</p>
    <p>Evaluation of Static and Dynamic Scheduling for Media Processors</p>
    <p>Jason Fritts Assistant Professor</p>
    <p>Department of Computer Science Co-Author: Wayne Wolf</p>
    <p>Overview</p>
    <p>Media Processing  Present and Future</p>
    <p>Evaluation Environment</p>
    <p>Dynamic vs. Static Architectures</p>
    <p>Effects of High Frequency</p>
    <p>Conclusions</p>
    <p>Future Research</p>
  </div>
  <div class="page">
    <p>Page 2</p>
    <p>Multimedia Applications</p>
    <p>Wide range of applications  Communication</p>
    <p>video conferencing  World Wide Web  digital/video libraries  videophones</p>
    <p>Entertainment  video/computer games  movies  animation</p>
    <p>Computer Vision  image understanding  surveillance  tracking</p>
    <p>Education  interactive learning  virtual classrooms</p>
    <p>Art and Architecture</p>
    <p>Multimedia is primarily a</p>
    <p>communication media</p>
    <p>Multimedia is primarily a</p>
    <p>communication media</p>
    <p>Future of Multimedia</p>
    <p>Multimedia is moving towards</p>
    <p>advanced representations</p>
    <p>Multimedia is moving towards</p>
    <p>advanced representations</p>
    <p>Multimedia industry evolves with processor performance.</p>
    <p>Multimedia industry evolves with processor performance.</p>
    <p>Image Compression</p>
    <p>Video Compression</p>
    <p>Object-Based Multimedia</p>
    <p>Time</p>
    <p>P ro</p>
    <p>ce ss</p>
    <p>in g</p>
    <p>P er</p>
    <p>fo rm</p>
    <p>an ce</p>
  </div>
  <div class="page">
    <p>Page 3</p>
    <p>Current Media Processing Solutions</p>
    <p>Application-specific processors  high performance at low cost  very limited flexibility</p>
    <p>Multimedia extensions to general-purpose processors  good programmability at little added cost  some speedup with subword parallelism  optimized for general-purpose processing</p>
    <p>Current programmable media processors  good performance</p>
    <p>specialized hardware  subword parallelism  ILP</p>
    <p>good programmability (w/ special programming libraries)  moderate frequency</p>
    <p>Future Media Processors</p>
    <p>Increasing Performance  high frequency  improved ILP</p>
    <p>Cost is Major Barrier  high resource costs are primary barrier to using such mechanisms  smaller market for media processing prohibits high resource costs  media processors currently much more expensive per MIPS</p>
    <p>Diminishing Costs  increasing market for media processing  decreasing power per MIPS  demonstrated by recently announced TI C64x =&gt; frequencies up to 1.1 GHz</p>
    <p>E x e c u ti o n U n i ts</p>
    <p>P ro c e s s o r</p>
    <p>T I C 6 2 x</p>
    <p>I nte l P e ntiu m I I I 3 2 K B L 1 , 2 5 6 K B L 2</p>
    <p>P o w e r</p>
    <p>u p to 3 0 0 M H z u p to 2 W</p>
    <p>F re q u e n c y L 2 C a c h e V L S I</p>
    <p>T e c h n o lo g y</p>
    <p>varie s , w / up to 7 M b m e m</p>
  </div>
  <div class="page">
    <p>Page 4</p>
    <p>Evaluation Environment</p>
    <p>MediaBench Benchmark Suite</p>
    <p>Developed at UCLA</p>
    <p>[CLee97] MediaBench: A Tool for Evaluating and Synthesizing Multimedia Communication Systems, MICRO-30, 1997.</p>
    <p>Excellent combination of applications  video: MPEG-2  audio: ADPCM coder  graphics: Mesa  image: JPEG, EPIC, Ghostscript  security: PGP, Pegwit  speech: GSM, G.721, Rasta</p>
    <p>Augmented for greater representation of future multimedia  MPEG-4 object-oriented video  H.263 very-low bitrate video</p>
  </div>
  <div class="page">
    <p>Page 5</p>
    <p>IMPACT Environment</p>
    <p>Aggressive ILP research compiler  Three levels of optimizations</p>
    <p>Classical - classical optimizations only  Superscalar - adds loop unrolling and superblock formation  Hyperblock - adds hyperblock optimization</p>
    <p>Architecture-independent evaluation  large, generic instruction set  retargetable back-end</p>
    <p>Performance analysis tools  parameterizable simulator  statistical and cycle-accurate simulation  models VLIW and in-order superscalar architectures  expanded tools to include out-of-order superscalar architectures</p>
    <p>Dynamic vs. Static Architectures</p>
  </div>
  <div class="page">
    <p>Page 6</p>
    <p>Related Research</p>
    <p>Media processors currently statically-scheduled  TI C6x  TriMedia TM-1000, TM-2000  Equator/Hitachi MAP1000</p>
    <p>Research-based media processors</p>
    <p>[CLee97] MediaBench: A Tool for Evaluating and Synthesizing Multimedia Communications Systems, MICRO-30, 1997.</p>
    <p>[CLee98] Media Architecture: General Purpose vs. Multiple ApplicationSpecific Programmable Processors, DAC-35, 1998.</p>
    <p>[PPirsch97] On Implementation of Media Processors, IEEE Signal Processing Magazine, vol. 14, no. 4, July 1997.</p>
    <p>[SRixner99] Media Processors Using Streams, SPIE Photonics West  Media Processors 99, 1999.</p>
    <p>Static vs. dynamic scheduling</p>
    <p>[PChang91] Comparing Static and Dynamic Code Scheduling for MultipleInstruction Issue Processors, MICRO-24, 1991.</p>
    <p>Base Architecture Model</p>
    <p>Architecture model  8-issue media processor  operation latencies targeting 500 MHz to 1 GHz processor frequency  64 integer and floating-point registers  pipeline: 1 fetch, 2 decode, 1 write back, variable execute stages  1024-entry 2-bit branch predictor</p>
    <p>L1 Cache  16 KB direct-mapped L1 instruction</p>
    <p>cache w/ 256 byte lines  32 KB direct-mapped L1 data</p>
    <p>cache w/ 64 byte lines</p>
    <p>On-Chip L2 Cache  256 KB 4-way set associate</p>
    <p>w/ 64 byte lines</p>
    <p>External Memory  6:1 Processor to bus frequency ratio</p>
    <p>`</p>
    <p>L1 Data</p>
    <p>Cache</p>
    <p>Datapath</p>
    <p>L2 Cache</p>
    <p>L1 Instr</p>
    <p>Cache</p>
    <p>Bus frequency = 1/6 processor frequency</p>
  </div>
  <div class="page">
    <p>Page 7</p>
    <p>Static vs. Dynamic Scheduling</p>
    <p>Architectures for static and dynamic scheduling  VLIW and in-order superscalar perform comparably (5% difference)  out-of-order superscalar has 64% better performance on average</p>
    <p>out-of-order issue with 32-entry issue-reorder buffer  early branch evaluation  large degree of dynamic control speculation</p>
    <p>cj p</p>
    <p>e g</p>
    <p>d jp</p>
    <p>e g</p>
    <p>e p ic</p>
    <p>g 7 2 1 d e c</p>
    <p>g 7 2 1 e n c</p>
    <p>g s</p>
    <p>g sm</p>
    <p>d e co</p>
    <p>d e</p>
    <p>g sm</p>
    <p>e n co</p>
    <p>d e</p>
    <p>h 2 6 3 d e c</p>
    <p>h 2 6 3 e n c</p>
    <p>m ip</p>
    <p>m a p</p>
    <p>m p e g 2 d e c</p>
    <p>m p e g 2 e n c</p>
    <p>m p e g 4 d e c</p>
    <p>o sd</p>
    <p>e m</p>
    <p>o</p>
    <p>p e g w</p>
    <p>itd e c</p>
    <p>p e g w</p>
    <p>ite n c</p>
    <p>p g p d e co</p>
    <p>d e</p>
    <p>ra st</p>
    <p>a</p>
    <p>ra w</p>
    <p>ca u d io</p>
    <p>ra w</p>
    <p>d a u d io</p>
    <p>te xg</p>
    <p>e n</p>
    <p>u n e p ic</p>
    <p>A V</p>
    <p>E R</p>
    <p>A G</p>
    <p>E</p>
    <p>Application</p>
    <p>IP C</p>
    <p>VLIW in-order superscalar out-of-order s uperscalar</p>
    <p>Scheduling Variations across Compiler Methods</p>
    <p>Compared compilations models across architectures  hyperblock demonstrates best performance</p>
    <p>12% increase over superblock on out-of-order superscalar  only 2% increase over superblock otherwise  gain likely does not warrant resources for predication</p>
    <p>Classical Superscalar Hyperblock</p>
    <p>Compilation Method</p>
    <p>IP C</p>
    <p>VLIW</p>
    <p>in-order superscalar</p>
    <p>out-of-order superscalar</p>
    <p>VLIW w/ perfect caches</p>
    <p>in-order superscalar w/ perfect caches out-of-order superscalar w/ perfect caches</p>
  </div>
  <div class="page">
    <p>Page 8</p>
    <p>Scheduling Variations across Processor Widths</p>
    <p>Compared processor widths across architectures  performance gain minimizes after 4 issue slots  3-4 issue slots sufficient for these compiler methods  2-issue out-of-order superscalar outperforms 8-issue VLIW and</p>
    <p>IP C</p>
    <p>VLIW</p>
    <p>in-order superscalar</p>
    <p>out-of-order superscalar</p>
    <p>Effects of High Frequency</p>
  </div>
  <div class="page">
    <p>Page 9</p>
    <p>Impact of Higher Frequencies</p>
    <p>Increasing frequency  Causes greater wire delays and fewer levels of logic per cycle  Leads to:</p>
    <p>deeper pipelines  longer operation latencies  increased communication costs</p>
    <p>Compared three different processor frequency models</p>
    <p>Compared immediate vs. delayed bypassing</p>
    <p>I n s t ru c t io n M o d e l 1 M o d e l 2 (B a s e ) M o d e l 3</p>
    <p>F re q u e n c y R a n g e 2 5 0 -5 0 0 M H z 5 0 0 M H z  1 G H z 1 -2 G H z</p>
    <p>P ro c e s s o r-B u s F re q . R a t io 4 : 1 6 : 1 8 : 1</p>
    <p>A L U 1 1 1</p>
    <p>B ra n c h e s 1 1 1</p>
    <p>S t o re 1 2 3</p>
    <p>L o a d 2 3 4</p>
    <p>F lo a t in g -P o in t 3 4 5</p>
    <p>M u lt ip ly 3 5 7</p>
    <p>D ivid e 1 0 2 0 3 0</p>
    <p>Comparison of Frequency Models</p>
    <p>Results from doubling processor frequency  average IPC degradation of 15%</p>
    <p>2/3 of degradation from longer operation latencies  1/3 of degradation from longer memory latencies</p>
    <p>performance increase of 70% from doubling frequency  out-of-order superscalar and superscalar compilation least susceptible</p>
    <p>to IPC degradation at higher frequencies</p>
    <p>C. vli</p>
    <p>w</p>
    <p>C. su</p>
    <p>pe r.i</p>
    <p>C. su</p>
    <p>pe r.o</p>
    <p>S. vli</p>
    <p>w</p>
    <p>S. su</p>
    <p>pe r.i</p>
    <p>S. su</p>
    <p>pe r.o</p>
    <p>HS .v liw</p>
    <p>HS .s up</p>
    <p>er .i</p>
    <p>HS .s up</p>
    <p>er .o</p>
    <p>Compilation/Simulation Method</p>
    <p>IP C</p>
    <p>D iff</p>
    <p>e re</p>
    <p>n ce</p>
    <p>( %</p>
    <p>)</p>
    <p>m2 to m3</p>
    <p>m1 to m2</p>
  </div>
  <div class="page">
    <p>Page 10</p>
    <p>Impact of Delayed Bypassing</p>
    <p>Results from delaying bypassing one cycle  average IPC degradation of 32%  out-of-order superscalar and superscalar compilation least</p>
    <p>susceptible to IPC degradation</p>
    <p>Classical Superscalar Hyperblock</p>
    <p>Compilation Method</p>
    <p>IP C</p>
    <p>D iff</p>
    <p>e re</p>
    <p>n ce</p>
    <p>( %</p>
    <p>)</p>
    <p>VLIW</p>
    <p>in-order superscalar</p>
    <p>out-of-order supers calar</p>
    <p>Conclusions</p>
    <p>VLIW and in-order superscalar perform comparably  Only 5% average difference in performance</p>
    <p>Out-of-order superscalar has significantly higher performance  64% better average performance than VLIW  2-issue out-of-order superscalar outperforms both 8-issue VLIW and 8-issue</p>
    <p>in-order superscalar</p>
    <p>Compilation and Processor Width  Hyperblock compilation is best, but likely not worth overhead  Processor widths of 3-4 issue slots sufficient for these compilation methods</p>
    <p>Effects of High Frequency  Doubling processor frequency decreases IPC by 16%  Delayed bypassing decreases IPC by 32%  Out-of-order scheduling and superscalar compilation up to 30% less</p>
    <p>susceptible to high frequency effects</p>
  </div>
  <div class="page">
    <p>Page 11</p>
    <p>Areas for Future Work</p>
    <p>Advanced Compilation Methods  Software pipelining</p>
    <p>Impact of Subword Parallelism  Current work only evaluates scheduling mechanisms on ILP-based code  How does inclusion of subword parallelism affect performance?  Anticipate greater impact from dynamic aspects:</p>
    <p>Subword parallelism primarily used across loop iterations with regular control flow  Subword parallelism reduces regularity, giving dynamic aspects greater weight</p>
    <p>Evaluating DSP Features  DSP operations: multiply-accumulate, saturation arithmetic, etc.  Low-overhead looping</p>
    <p>Evaluate Performance with Specialized Functional Units  Motion estimation, DCT, variable-bit rate coding, etc.  Support specialized media functions with reconfigurable co-processor?</p>
  </div>
</Presentation>
