<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Proof</p>
    <p>General</p>
    <p>A Generic Tool for Proof Development</p>
    <p>David Aspinall</p>
    <p>LFCS, University of Edinburgh</p>
    <p>http://www.lfcs.informatics.ed.ac.uk/proofgen</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Background Why Proof General?</p>
    <p>What is Proof General?</p>
  </div>
  <div class="page">
    <p>Background</p>
    <p>Terminology: machine proof</p>
    <p>formal machine representation of mathematical/logical proof</p>
    <p>Machine proofs useful in</p>
    <p>specification, development, verification of software and hardware</p>
    <p>teaching mathematical proof and formal logic</p>
    <p>mathematical research</p>
    <p>Terminology: proof assistant (or prover )</p>
    <p>an interactive computerized helper for developing machine proofs</p>
    <p>Terminology: proof script</p>
    <p>user-level input to prover which constructs a machine proof</p>
    <p>may contain procedural proofs (LCF style), or declarative proofs (Mizar style)</p>
    <p>stored in a file, like a program</p>
  </div>
  <div class="page">
    <p>Why Proof General?</p>
    <p>Many proof assistants still have only a primitive interface</p>
    <p>Its easy to program!</p>
    <p>Experts unafraid of cryptic command language</p>
    <p>But a modern interface has advantages:</p>
    <p>Saves time for experts, providing short-cuts</p>
    <p>Helps novices, providing hints</p>
    <p>Opens the way to higher-level interactions</p>
    <p>A generic interface is attractive:</p>
    <p>Saves time for implementors, can concentrate on logical bits</p>
    <p>Helps users try different systems, using the same interactions</p>
  </div>
  <div class="page">
    <p>What is Proof General?</p>
    <p>A generic interface based on Emacs</p>
    <p>It provides many useful features, including:</p>
    <p>script centred development</p>
    <p>script management</p>
    <p>proof by pointing</p>
    <p>helpful toolbar and menus</p>
    <p>coloured output and special fonts for maths, . . .</p>
    <p>It presently has support for Isabelle(/Isar), Coq, LEGO, Plastic, HOL98</p>
    <p>More support and development is on the way . . .</p>
    <p>An idea: a generic tool to help proof development. An attitude: be useful both to novices and to experts.</p>
  </div>
  <div class="page">
    <p>Architecture</p>
    <p>Generic aspects of proof assistants Choose Emacs</p>
    <p>System architecture</p>
  </div>
  <div class="page">
    <p>Generic aspects of proof assistants</p>
    <p>Interaction has a common structure</p>
    <p>User makes declarations or definitions</p>
    <p>User enters proof dialogue</p>
    <p>? user gives proof step; system responds (e.g. subgoal list)</p>
    <p>? repeat</p>
    <p>Proof scripts have a common structure, similarly:</p>
    <p>declarations and definitions, and</p>
    <p>goal . . . save sequences</p>
    <p>Primitive interfaces have common structure:</p>
    <p>Command-line interface: proof assistant shell</p>
    <p>How can we build a system to exploit these common structures?</p>
  </div>
  <div class="page">
    <p>Choose Emacs</p>
    <p>The worlds best text editor also provides a user-interface toolkit!</p>
    <p>Choosing emacs has pros</p>
    <p>user familiarity: Emacs already used to write scripts</p>
    <p>portability: runs on MS Windows, Unix, Linux, . . .</p>
    <p>interpreted scripting language for development: Emacs Lisp</p>
    <p>extensive libraries, easy user-customization</p>
    <p>. . . and cons</p>
    <p>hard to learn and over complicated</p>
    <p>the original bloatware</p>
    <p>interoperability limited (live in Emacs!)</p>
    <p>single-threaded</p>
  </div>
  <div class="page">
    <p>System architecture</p>
    <p>Emacs Proof</p>
    <p>+-------------------------+ Engine</p>
    <p>| | +---------------+</p>
    <p>| | | |</p>
    <p>| |---&gt;| |</p>
    <p>| |&lt;---| |</p>
    <p>| | | |</p>
    <p>| | +---------------+</p>
    <p>+-------------------------+ ^</p>
    <p>^ | ^ | File</p>
    <p>| | | v System</p>
    <p>| v | +---------------+</p>
    <p>| | |</p>
    <p>USER +---&gt;| |</p>
    <p>+---------------+</p>
  </div>
  <div class="page">
    <p>User Features</p>
    <p>Script centered development Script management</p>
    <p>Proof by Pointing User friendliness</p>
    <p>Other Emacs features</p>
  </div>
  <div class="page">
    <p>Script centered development</p>
    <p>Hide irrelevant information</p>
    <p>shell hidden</p>
    <p>but still available for emergencies</p>
    <p>Buffer display model: two-of-three window panes</p>
    <p>script</p>
    <p>goals or response</p>
    <p>Script buffer centred around latest proof command</p>
    <p>Goals buffer centred around working subgoal</p>
    <p>Response buffer displays other relevant messages</p>
    <p>urgent messages</p>
    <p>result of non-proof step (search results, command feedback)</p>
    <p>Customizable to use three buffers and multiple windows</p>
  </div>
  <div class="page">
    <p>Script management</p>
    <p>Synchronizes editor with proof assistant</p>
    <p>Provides visual feedback</p>
    <p>blue background  processed text</p>
    <p>pink background  text being processed</p>
    <p>Highlighted text is locked to prevent accidental editing</p>
    <p>Connects with provers history mechanism, for retraction</p>
    <p>undo individual steps within a proof</p>
    <p>block-structure outside proof</p>
    <p>Connects with provers file handling</p>
    <p>extend synchronization to multiple files</p>
    <p>dependencies communicated or deduced automatically</p>
    <p>Avoids using cut-and-paste or load file commands</p>
  </div>
  <div class="page">
    <p>Proof by Pointing</p>
    <p>Click on subterm of goal</p>
    <p>generates proof command to simplify/solve goal</p>
    <p>inserts command into proof</p>
    <p>executes it</p>
    <p>Support from proof assistant required!</p>
    <p>annotations to markup term-structure</p>
    <p>communication of position in AST</p>
    <p>proof command generation</p>
    <p>Many possibilities</p>
    <p>context-sensitive menus</p>
    <p>other gestures (e.g. drag term to rearrange equation)</p>
    <p>not yet implemented</p>
  </div>
  <div class="page">
    <p>User friendliness</p>
    <p>Toolbar</p>
    <p>buttons to start proof, process step, undo step, finish proof, . . .</p>
    <p>Menus</p>
    <p>change display modes, start/stop proof assistant, . . .</p>
    <p>all commands available here</p>
    <p>Easy preference setting</p>
    <p>Online documentation</p>
    <p>variety of formats</p>
    <p>links to proof assistant documentation</p>
    <p>. . . and of course, speedy short-cut key sequences like C-c C-RET proof-goto-point</p>
  </div>
  <div class="page">
    <p>Other Emacs features</p>
    <p>Syntax highlighting</p>
    <p>decoration of proof scripts and prover output</p>
    <p>Symbol fonts</p>
    <p>glyphs for logical symbols, greek letters, etc</p>
    <p>instead of phi --&gt; psi</p>
    <p>Tags</p>
    <p>search for definitions and proofs amongst many files</p>
    <p>Item menu</p>
    <p>navigate to definitions and proofs in current window</p>
    <p>Remote proof assistant</p>
    <p>run prover on different machine using rsh or ssh</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Implementation notes Instantiation mechanism</p>
    <p>Example instantiation Development model</p>
  </div>
  <div class="page">
    <p>Implementation notes</p>
    <p>Main implementation in Emacs Lisp</p>
    <p>7000 loc for generic parts</p>
    <p>30  500 loc per assistant for prover specific parts</p>
    <p>Support in proof assistant (optional)</p>
    <p>output markup for robustness</p>
    <p>file loading messages</p>
    <p>proof by pointing machinery</p>
    <p>Emacs Lisp issues</p>
    <p>fairly primitive, but has some CL macros (and CLOS emulation)</p>
    <p>slow, but built-ins and byte-code compilation improve matters</p>
    <p>easy to learn and use, docstrings are wonderful</p>
  </div>
  <div class="page">
    <p>Instantiation mechanism</p>
    <p>80 configuration settings total; may only need half. Organized as:</p>
    <p>Regexps to recognize proof script</p>
    <p>Regexps to recognize prover messages</p>
    <p>Commands to control prover</p>
    <p>Hooks to configure behaviour</p>
    <p>Some important examples: proof-goal-command-regexp matches goal command in script</p>
    <p>proof-shell-start-goals-regexp matches start of goals output</p>
    <p>proof-prog-name command to start prover</p>
    <p>proof-shell-insert-hook hook to tweak prover input</p>
    <p>One line to add autoloads, name, customizations for new prover</p>
    <p>Use define-derived-mode for new script, goals, response, shell</p>
    <p>With new easy configure mechanism, no Elisp necessary!</p>
  </div>
  <div class="page">
    <p>Example instantiation</p>
    <p>(require proof-easy-config) ; easy configure mechanism</p>
    <p>(proof-easy-config</p>
    <p>demoisa &quot;Isabelle Demo&quot;</p>
    <p>proof-prog-name &quot;isabelle&quot;</p>
    <p>proof-terminal-char ?\;</p>
    <p>proof-comment-start &quot;(*&quot;</p>
    <p>proof-comment-end &quot;*)&quot;</p>
    <p>proof-goal-command-regexp &quot;^Goal&quot;</p>
    <p>proof-save-command-regexp &quot;^qed&quot;</p>
    <p>proof-goal-with-hole-regexp &quot;qed_goal \&quot;\\(\\(.*\\)\\)\&quot;&quot;</p>
    <p>proof-save-with-hole-regexp &quot;qed \&quot;\\(\\(.*\\)\\)\&quot;&quot;</p>
    <p>proof-non-undoables-regexp &quot;undo\\|back&quot;</p>
    <p>proof-goal-command &quot;Goal \&quot;%s\&quot;;&quot;</p>
    <p>proof-save-command &quot;qed \&quot;%s\&quot;;&quot;</p>
    <p>proof-kill-goal-command &quot;Goal \&quot;PROP no_goal_set\&quot;;&quot;</p>
    <p>proof-showproof-command &quot;pr()&quot;</p>
    <p>proof-undo-n-times-cmd &quot;pg_repeat undo %s;&quot;</p>
    <p>proof-auto-multiple-files t</p>
    <p>proof-shell-cd-cmd &quot;cd \&quot;%s\&quot;&quot;</p>
    <p>proof-shell-prompt-pattern &quot;[ML-=#&gt;]+&gt;? &quot;</p>
    <p>proof-shell-interrupt-regexp &quot;Interrupt&quot;</p>
    <p>proof-shell-start-goals-regexp &quot;Level [0-9]&quot;</p>
    <p>proof-shell-end-goals-regexp &quot;val it&quot;</p>
    <p>proof-shell-quit-cmd &quot;quit();&quot;</p>
    <p>proof-assistant-home-page</p>
    <p>&quot;http://www.cl.cam.ac.uk/Research/HVG/isabelle.html&quot;</p>
    <p>proof-shell-annotated-prompt-regexp &quot;^\\(val it = () : unit\n\\)?ML&gt;? &quot;</p>
    <p>proof-shell-error-regexp</p>
    <p>&quot;\\*\\*\\*\\|^.*Error:\\|^uncaught exception \\|^Exception- &quot;</p>
    <p>proof-shell-init-cmd</p>
    <p>&quot;fun pg_repeat f 0 = () | pg_repeat f n = (f(); pg_repeat f (n-1));&quot;</p>
    <p>proof-shell-proof-completed-regexp &quot;\\(\\(.\\|\n\\)*No subgoals!\n\\)&quot;</p>
    <p>proof-shell-eager-annotation-start &quot;^\\[opening \\|^###\\|^Reading&quot;)</p>
    <p>(provide demoisa)</p>
  </div>
  <div class="page">
    <p>Development model</p>
    <p>Successive generalization</p>
    <p>generalize as needed</p>
    <p>sometimes extend and redesign core, as needed</p>
    <p>LEGO mode  Proof Mode  Proof General</p>
    <p>Developer/maintainer in each camp</p>
    <p>Emacs and prover support for each prover</p>
    <p>adds specific features, generalizes if useful elsewhere</p>
    <p>serves as primary user/tester</p>
    <p>CVS server, access to whole repository for all developers</p>
    <p>Frequent pre-release versions, quick response to bugs</p>
    <p>Open source, user contributions welcomed</p>
  </div>
  <div class="page">
    <p>Appraisal</p>
    <p>Usage Comparison</p>
    <p>Benefits of Proof General</p>
  </div>
  <div class="page">
    <p>Usage</p>
    <p>Target users of currently supported proof assistants:</p>
    <p>User community Other interfaces?</p>
    <p>LEGO 30 no</p>
    <p>Coq 80 yes</p>
    <p>Isabelle 200 yes</p>
    <p>Isabelle/Isar 20 no</p>
    <p>Plastic 5 no</p>
    <p>HOL98 200 yes</p>
    <p>Other possible systems (HOL variants, Agda, VDM, ACL2, . . . )</p>
    <p>Use in teaching</p>
    <p>2000 EEF Foundations school in Deduction and Theorem Proving</p>
    <p>1999 Types Summer School: 50 learning LEGO, Coq, and Isabelle</p>
    <p>MSc/PhD course in formal reasoning at Edinburgh</p>
    <p>Current version is 3.1, about 100 registered users as of May 2000.</p>
  </div>
  <div class="page">
    <p>Comparison</p>
    <p>Theres more sophistication elsewhere:</p>
    <p>Graphical representations: proof-trees, direct manipulation</p>
    <p>Structure editing, integrated environments, . . .</p>
    <p>However, Proof General has complementary aspects:</p>
    <p>intended for day-to-day proof, not an experiment in HCI</p>
    <p>draws on familiarity (text editor), uniformity (between systems)</p>
    <p>scales to large proofs</p>
    <p>portable, easy to adapt and extend</p>
    <p>Proof General occupies a middle ground in interface technology</p>
  </div>
  <div class="page">
    <p>Benefits of Proof General</p>
    <p>A nice front-end for doing real work!</p>
    <p>Is being used by experts, doesnt get in their way (much)</p>
    <p>But is also used for teaching novices</p>
    <p>Replaying proofs is trivial</p>
    <p>By construction, it suggests a protocol for interactive proof</p>
    <p>New project to design standard extensible protocol . . .</p>
    <p>Very easy to install; self-configuring</p>
    <p>Very easy to adapt to new systems, to get basic features</p>
    <p>Proof General achieves a lightweight, useful interface at little cost</p>
  </div>
  <div class="page">
    <p>Future</p>
    <p>Evolutionary</p>
    <p>More features  completion, favourites, theory browser</p>
    <p>More proof assistants</p>
    <p>Revolutionary</p>
    <p>Factor out script management, use for programming languages</p>
    <p>Standardize markup mechanism (XML, MathML, OpenMath, ATerms)</p>
    <p>Focus on protocols, move away from purely Emacs</p>
    <p>Middleware layer connects proof engine to front-ends (CORBA)</p>
    <p>Imaginary</p>
    <p>Prover-independent syntax mechanisms</p>
    <p>Logic and theory mappings, standard taxonomies</p>
    <p>Working title of next project: Proof General Kit</p>
  </div>
  <div class="page">
    <p>The End</p>
    <p>New Users, Developers Welcome!</p>
    <p>Enjoy using Proof General  Add support for another prover  Undertake a project  Contribute to future design</p>
    <p>Credits :</p>
    <p>Thomas Kleymann,  Yyves Bertot and CtCoq  Dilip Sequeira,  Healfdene Goguen,  Markus Wenzel, David von Oheimb, . . .  Funding: LFCS, EPSRC LEGO, EC BRA Types</p>
    <p>For more, visit http://www.lfcs.informatics.ed.ac.uk/proofgen Version 1.15 of 2000/05/17 07:15:47, processed May 17, 2000.</p>
  </div>
</Presentation>
