<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Three steps is all you need fast, accurate, automatic scaling decisions</p>
    <p>for distributed streaming dataflows</p>
    <p>Vasiliki Kalavri, John Liagouris, Moritz Hoffmann, Desislava Dimitrova, Matthew Forshaw, Timothy Roscoe</p>
    <p>Support:</p>
    <p>Systems Group, Department of Computer Science, ETH Zrich, firstname.lastname@inf.ethz.ch</p>
    <p>Newcastle University, firstname.lastname@newcastle.ac.uk</p>
  </div>
  <div class="page">
    <p>Any streaming job will inevitably become over- or under-provisioned in the future</p>
  </div>
  <div class="page">
    <p>Any streaming job will inevitably become over- or under-provisioned in the future</p>
    <p>ev en</p>
    <p>ts /s</p>
    <p>time</p>
    <p>load shedding</p>
    <p>: input rate : throughput</p>
  </div>
  <div class="page">
    <p>ev en</p>
    <p>ts /s</p>
    <p>time</p>
    <p>idle resources</p>
    <p>Any streaming job will inevitably become over- or under-provisioned in the future</p>
    <p>ev en</p>
    <p>ts /s</p>
    <p>time</p>
    <p>load shedding</p>
    <p>: input rate : throughput</p>
  </div>
  <div class="page">
    <p>ev en</p>
    <p>ts /s</p>
    <p>time</p>
    <p>idle resources</p>
    <p>ev en</p>
    <p>ts /s</p>
    <p>time</p>
    <p>SLO violation</p>
    <p>Any streaming job will inevitably become over- or under-provisioned in the future</p>
    <p>ev en</p>
    <p>ts /s</p>
    <p>time</p>
    <p>load shedding</p>
    <p>: input rate : throughput</p>
  </div>
  <div class="page">
    <p>input streams</p>
    <p>parallel dataflow</p>
    <p>output stream</p>
    <p>CONFIGURING PARALLELISM FOR A STREAMING JOB</p>
  </div>
  <div class="page">
    <p>input streams</p>
    <p>parallel dataflow</p>
    <p>output stream</p>
    <p>until the target throughput is met</p>
    <p>CONFIGURING PARALLELISM FOR A STREAMING JOB</p>
  </div>
  <div class="page">
    <p>THE SCALING PROBLEM</p>
    <p>Given a logical dataflow with sources S1, S2,  Sn and rates 1, 2,  n identify the minimum parallelism i per operator i, such that the physical</p>
    <p>dataflow can sustain all source rates.</p>
    <p>S1</p>
    <p>S2</p>
    <p>1</p>
    <p>2</p>
    <p>S1</p>
    <p>S2</p>
    <p>=2</p>
    <p>=3</p>
    <p>logical dataflow physical dataflow</p>
  </div>
  <div class="page">
    <p>scaling controller</p>
    <p>metrics</p>
    <p>policy</p>
    <p>scaling action</p>
    <p>AUTOMATIC SCALING OVERVIEW</p>
  </div>
  <div class="page">
    <p>scaling controller</p>
    <p>metrics</p>
    <p>policy</p>
    <p>scaling action</p>
    <p>detect symptoms</p>
    <p>AUTOMATIC SCALING OVERVIEW</p>
  </div>
  <div class="page">
    <p>scaling controller</p>
    <p>metrics</p>
    <p>policy</p>
    <p>scaling action</p>
    <p>detect symptoms</p>
    <p>decide whether to scale</p>
    <p>AUTOMATIC SCALING OVERVIEW</p>
  </div>
  <div class="page">
    <p>scaling controller</p>
    <p>metrics</p>
    <p>policy</p>
    <p>scaling action</p>
    <p>detect symptoms</p>
    <p>decide whether to scale</p>
    <p>decide how much to scale</p>
    <p>AUTOMATIC SCALING OVERVIEW</p>
  </div>
  <div class="page">
    <p>policy scaling action Borealis</p>
    <p>StreamCloud</p>
    <p>Seep</p>
    <p>IBM Streams</p>
    <p>Spark Streaming</p>
    <p>Google Dataflow</p>
    <p>Dhalion</p>
    <p>Existing approaches metrics</p>
  </div>
  <div class="page">
    <p>policy scaling action</p>
    <p>CPU utilization backlog, tuples/s</p>
    <p>backpressure signal</p>
    <p>Borealis</p>
    <p>StreamCloud</p>
    <p>Seep</p>
    <p>IBM Streams</p>
    <p>Spark Streaming</p>
    <p>Google Dataflow</p>
    <p>Dhalion</p>
    <p>Existing approaches metrics</p>
  </div>
  <div class="page">
    <p>policy scaling action</p>
    <p>CPU utilization backlog, tuples/s</p>
    <p>backpressure signal</p>
    <p>threshold and rule-based if CPU &gt; 80% =&gt; scale</p>
    <p>Borealis</p>
    <p>StreamCloud</p>
    <p>Seep</p>
    <p>IBM Streams</p>
    <p>Spark Streaming</p>
    <p>Google Dataflow</p>
    <p>Dhalion</p>
    <p>Existing approaches metrics</p>
  </div>
  <div class="page">
    <p>policy scaling action</p>
    <p>CPU utilization backlog, tuples/s</p>
    <p>backpressure signal</p>
    <p>threshold and rule-based if CPU &gt; 80% =&gt; scale</p>
    <p>small changes, one operator at a time</p>
    <p>Borealis</p>
    <p>StreamCloud</p>
    <p>Seep</p>
    <p>IBM Streams</p>
    <p>Spark Streaming</p>
    <p>Google Dataflow</p>
    <p>Dhalion</p>
    <p>Existing approaches metrics</p>
  </div>
  <div class="page">
    <p>policy scaling action</p>
    <p>CPU utilization backlog, tuples/s</p>
    <p>backpressure signal</p>
    <p>threshold and rule-based if CPU &gt; 80% =&gt; scale</p>
    <p>small changes, one operator at a time</p>
    <p>problematic due to interference, multitenancy</p>
    <p>Borealis</p>
    <p>StreamCloud</p>
    <p>Seep</p>
    <p>IBM Streams</p>
    <p>Spark Streaming</p>
    <p>Google Dataflow</p>
    <p>Dhalion</p>
    <p>Existing approaches metrics</p>
  </div>
  <div class="page">
    <p>policy scaling action</p>
    <p>CPU utilization backlog, tuples/s</p>
    <p>backpressure signal</p>
    <p>threshold and rule-based if CPU &gt; 80% =&gt; scale</p>
    <p>small changes, one operator at a time</p>
    <p>problematic due to interference, multitenancy</p>
    <p>sensitive to noise, manual, hard to tune</p>
    <p>Borealis</p>
    <p>StreamCloud</p>
    <p>Seep</p>
    <p>IBM Streams</p>
    <p>Spark Streaming</p>
    <p>Google Dataflow</p>
    <p>Dhalion</p>
    <p>Existing approaches metrics</p>
  </div>
  <div class="page">
    <p>policy scaling action</p>
    <p>CPU utilization backlog, tuples/s</p>
    <p>backpressure signal</p>
    <p>threshold and rule-based if CPU &gt; 80% =&gt; scale</p>
    <p>small changes, one operator at a time</p>
    <p>problematic due to interference, multitenancy</p>
    <p>sensitive to noise, manual, hard to tune</p>
    <p>non-predictive, speculative steps</p>
    <p>Borealis</p>
    <p>StreamCloud</p>
    <p>Seep</p>
    <p>IBM Streams</p>
    <p>Spark Streaming</p>
    <p>Google Dataflow</p>
    <p>Dhalion</p>
    <p>Existing approaches metrics</p>
  </div>
  <div class="page">
    <p>policy scaling action</p>
    <p>CPU utilization backlog, tuples/s</p>
    <p>backpressure signal</p>
    <p>threshold and rule-based if CPU &gt; 80% =&gt; scale</p>
    <p>small changes, one operator at a time</p>
    <p>problematic due to interference, multitenancy</p>
    <p>sensitive to noise, manual, hard to tune</p>
    <p>non-predictive, speculative steps</p>
    <p>Borealis</p>
    <p>StreamCloud</p>
    <p>Seep</p>
    <p>IBM Streams</p>
    <p>Spark Streaming</p>
    <p>Google Dataflow</p>
    <p>Dhalion</p>
    <p>Existing approaches metrics</p>
    <p>oscillations</p>
  </div>
  <div class="page">
    <p>policy scaling action</p>
    <p>CPU utilization backlog, tuples/s</p>
    <p>backpressure signal</p>
    <p>threshold and rule-based if CPU &gt; 80% =&gt; scale</p>
    <p>small changes, one operator at a time</p>
    <p>problematic due to interference, multitenancy</p>
    <p>sensitive to noise, manual, hard to tune</p>
    <p>non-predictive, speculative steps</p>
    <p>Borealis</p>
    <p>StreamCloud</p>
    <p>Seep</p>
    <p>IBM Streams</p>
    <p>Spark Streaming</p>
    <p>Google Dataflow</p>
    <p>Dhalion</p>
    <p>Existing approaches metrics</p>
    <p>oscillations temporary overand underprovisioning</p>
  </div>
  <div class="page">
    <p>policy scaling action</p>
    <p>CPU utilization backlog, tuples/s</p>
    <p>backpressure signal</p>
    <p>threshold and rule-based if CPU &gt; 80% =&gt; scale</p>
    <p>small changes, one operator at a time</p>
    <p>problematic due to interference, multitenancy</p>
    <p>sensitive to noise, manual, hard to tune</p>
    <p>non-predictive, speculative steps</p>
    <p>Borealis</p>
    <p>StreamCloud</p>
    <p>Seep</p>
    <p>IBM Streams</p>
    <p>Spark Streaming</p>
    <p>Google Dataflow</p>
    <p>Dhalion</p>
    <p>Existing approaches metrics</p>
    <p>oscillations slow convergence</p>
    <p>temporary overand underprovisioning</p>
  </div>
  <div class="page">
    <p>effect of Dhalions scaling actions in an initially under-provisioned wordcount dataflow</p>
  </div>
  <div class="page">
    <p>effect of Dhalions scaling actions in an initially under-provisioned wordcount dataflow</p>
  </div>
  <div class="page">
    <p>externally observed</p>
    <p>threshold-based</p>
    <p>non-predictive, single-operator</p>
    <p>policy</p>
    <p>scaling action</p>
    <p>metrics</p>
  </div>
  <div class="page">
    <p>true rates through instrumentation</p>
    <p>dataflow dependency model</p>
    <p>predictive, dataflow-wide</p>
    <p>actions</p>
    <p>externally observed</p>
    <p>threshold-based</p>
    <p>non-predictive, single-operator</p>
    <p>policy</p>
    <p>scaling action</p>
    <p>metrics</p>
    <p>OUR APPROACH: DS2</p>
  </div>
  <div class="page">
    <p>no oscillations</p>
    <p>fast convergence</p>
    <p>true rates as bounds to avoid</p>
    <p>over/under-shoot</p>
    <p>true rates through instrumentation</p>
    <p>dataflow dependency model</p>
    <p>predictive, dataflow-wide</p>
    <p>actions</p>
    <p>externally observed</p>
    <p>threshold-based</p>
    <p>non-predictive, single-operator</p>
    <p>policy</p>
    <p>scaling action</p>
    <p>metrics</p>
    <p>OUR APPROACH: DS2</p>
  </div>
  <div class="page">
    <p>o1src o2</p>
    <p>backpressure target: 40 rec/s</p>
  </div>
  <div class="page">
    <p>o1src o2</p>
    <p>backpressure target: 40 rec/s</p>
    <p>observed view</p>
    <p>Which operator is the bottleneck?</p>
    <p>What if we scale 1 x 4?</p>
    <p>How much to scale 2?</p>
  </div>
  <div class="page">
    <p>o1src o2</p>
    <p>backpressure target: 40 rec/s</p>
    <p>observed view</p>
  </div>
  <div class="page">
    <p>o1src o2</p>
    <p>backpressure target: 40 rec/s</p>
    <p>observed view</p>
  </div>
  <div class="page">
    <p>src</p>
    <p>o1</p>
    <p>o2</p>
    <p>Time (s)</p>
    <p>instrumentation</p>
    <p>DS2 view</p>
    <p>o1src o2</p>
    <p>backpressure target: 40 rec/s</p>
    <p>observed view</p>
  </div>
  <div class="page">
    <p>src</p>
    <p>o1</p>
    <p>o2</p>
    <p>Time (s)</p>
    <p>instrumentation</p>
    <p>DS2 view</p>
    <p>o1src o2</p>
    <p>backpressure target: 40 rec/s</p>
    <p>observed view</p>
    <p>1 is the bottleneck</p>
  </div>
  <div class="page">
    <p>src</p>
    <p>o1</p>
    <p>o2</p>
    <p>Time (s)</p>
    <p>instrumentation</p>
    <p>DS2 view</p>
    <p>o1src o2</p>
    <p>backpressure target: 40 rec/s</p>
    <p>observed view</p>
    <p>1 is the bottleneck</p>
    <p>true rate = 200 rec/s</p>
    <p>of 4 1 instances</p>
  </div>
  <div class="page">
    <p>THE DS2 MODEL</p>
  </div>
  <div class="page">
    <p>THE DS2 MODEL Useful time: The time spent by an operator instance in deserialization, processing, and serialization activities.</p>
  </div>
  <div class="page">
    <p>THE DS2 MODEL Useful time: The time spent by an operator instance in deserialization, processing, and serialization activities.</p>
    <p>True processing (resp. output) rate: The number of records an operator instance can process (resp. output) per unit of useful time.</p>
  </div>
  <div class="page">
    <p>THE DS2 MODEL Useful time: The time spent by an operator instance in deserialization, processing, and serialization activities.</p>
    <p>True processing (resp. output) rate: The number of records an operator instance can process (resp. output) per unit of useful time.</p>
    <p>Optimal parallelism for oi</p>
    <p>aggregated true output rate of upstream ops average true processing rate of oi</p>
    <p>:</p>
  </div>
  <div class="page">
    <p>CONVERGENCE STEPS</p>
    <p>parallelism</p>
    <p>initial rate</p>
    <p>target no overshoot when scaling up: ideal rate is an upper bound</p>
    <p>no undershoot when scaling down: ideal rate is a lower bound</p>
    <p>if the actual scaling is linear, convergence takes one step</p>
    <p>p0</p>
    <p>x</p>
  </div>
  <div class="page">
    <p>CONVERGENCE STEPS</p>
    <p>parallelism</p>
    <p>initial rate</p>
    <p>target pre</p>
    <p>dic tio</p>
    <p>n</p>
    <p>no overshoot when scaling up: ideal rate is an upper bound</p>
    <p>no undershoot when scaling down: ideal rate is a lower bound</p>
    <p>if the actual scaling is linear, convergence takes one step</p>
    <p>p0</p>
    <p>x</p>
  </div>
  <div class="page">
    <p>CONVERGENCE STEPS</p>
    <p>parallelism</p>
    <p>initial rate</p>
    <p>target pre</p>
    <p>dic tio</p>
    <p>n</p>
    <p>no overshoot when scaling up: ideal rate is an upper bound</p>
    <p>no undershoot when scaling down: ideal rate is a lower bound</p>
    <p>if the actual scaling is linear, convergence takes one step</p>
    <p>p0 p1</p>
    <p>x</p>
    <p>x</p>
  </div>
  <div class="page">
    <p>CONVERGENCE STEPS</p>
    <p>parallelism</p>
    <p>initial rate</p>
    <p>target pre</p>
    <p>dic tio</p>
    <p>n</p>
    <p>no overshoot when scaling up: ideal rate is an upper bound</p>
    <p>no undershoot when scaling down: ideal rate is a lower bound</p>
    <p>ac tu</p>
    <p>al if the actual scaling is linear,</p>
    <p>convergence takes one step</p>
    <p>p0 p1</p>
    <p>x</p>
    <p>x</p>
  </div>
  <div class="page">
    <p>In practice, rates are commonly sub-linear due to other overheads (e.g. worker coordination).</p>
    <p>parallelism</p>
    <p>initial rate</p>
    <p>target</p>
    <p>x</p>
    <p>pre dic</p>
    <p>tio n</p>
    <p>x</p>
    <p>p0 p1</p>
    <p>CONVERGENCE STEPS</p>
  </div>
  <div class="page">
    <p>In practice, rates are commonly sub-linear due to other overheads (e.g. worker coordination).</p>
    <p>parallelism</p>
    <p>initial rate</p>
    <p>target</p>
    <p>x</p>
    <p>pre dic</p>
    <p>tio n</p>
    <p>x actu</p>
    <p>al</p>
    <p>p0 p1</p>
    <p>CONVERGENCE STEPS</p>
  </div>
  <div class="page">
    <p>In practice, rates are commonly sub-linear due to other overheads (e.g. worker coordination).</p>
    <p>parallelism</p>
    <p>initial rate</p>
    <p>target</p>
    <p>x</p>
    <p>pre dic</p>
    <p>tio n</p>
    <p>x actu</p>
    <p>al</p>
    <p>x error</p>
    <p>when the actual scaling is sub-linear, convergence takes more than one steps</p>
    <p>p0 p1</p>
    <p>CONVERGENCE STEPS</p>
  </div>
  <div class="page">
    <p>In practice, rates are commonly sub-linear due to other overheads (e.g. worker coordination).</p>
    <p>parallelism</p>
    <p>p0</p>
    <p>initial rate</p>
    <p>target</p>
    <p>p1</p>
    <p>pre dic</p>
    <p>tio n</p>
    <p>actu al</p>
    <p>x x</p>
    <p>p2 In our experiments, DS2 took</p>
    <p>up to three steps to converge for complex queries.</p>
    <p>x</p>
    <p>p3</p>
    <p>CONVERGENCE STEPS</p>
  </div>
  <div class="page">
    <p>DS2 operates online in a reactive setting</p>
    <p>Instrumented stream processor</p>
    <p>Scaling Manager Scaling Policy</p>
    <p>Metrics Repository</p>
    <p>invoke</p>
    <p>re-scale job</p>
    <p>report metrics</p>
    <p>mo nito</p>
    <p>r</p>
    <p>pull metrics</p>
    <p>decision</p>
    <p>Timely dataflow</p>
    <p>Apache Flink</p>
  </div>
  <div class="page">
    <p>EVALUATION</p>
  </div>
  <div class="page">
    <p>DS2 VS. DHALION ON HERON</p>
    <p>wordcount</p>
    <p>Target rate: 16.700 rec/s</p>
  </div>
  <div class="page">
    <p>DS2 VS. DHALION ON HERON</p>
    <p>wordcount</p>
    <p>DS2 converges in a single step for both operators</p>
    <p>Target rate: 16.700 rec/s</p>
  </div>
  <div class="page">
    <p>DS2 VS. DHALION ON HERON</p>
    <p>wordcount</p>
    <p>DS2 converges in a single step for both operators</p>
    <p>DS2 converges in 60s, i.e. as soon as it receives the Heron</p>
    <p>metrics</p>
    <p>Target rate: 16.700 rec/s</p>
  </div>
  <div class="page">
    <p>DS2 VS. DHALION ON HERON</p>
    <p>wordcount</p>
    <p>DS2 converges in a single step for both operators</p>
    <p>Dhalion scales one operator at a time, resulting to a total</p>
    <p>of six steps</p>
    <p>DS2 converges in 60s, i.e. as soon as it receives the Heron</p>
    <p>metrics</p>
    <p>Target rate: 16.700 rec/s</p>
  </div>
  <div class="page">
    <p>DS2 VS. DHALION ON HERON</p>
    <p>wordcount</p>
    <p>DS2 converges in a single step for both operators</p>
    <p>Dhalion scales one operator at a time, resulting to a total</p>
    <p>of six steps</p>
    <p>DS2 converges in 60s, i.e. as soon as it receives the Heron</p>
    <p>metrics</p>
    <p>Dhalion converges in 2000s</p>
    <p>Target rate: 16.700 rec/s</p>
  </div>
  <div class="page">
    <p>DS2 VS. DHALION ON HERON</p>
    <p>wordcount</p>
    <p>DS2 converges in a single step for both operators</p>
    <p>Dhalion scales one operator at a time, resulting to a total</p>
    <p>of six steps</p>
    <p>DS2 converges in 60s, i.e. as soon as it receives the Heron</p>
    <p>metrics</p>
    <p>Dhalion converges in 2000s</p>
    <p>+10 counts</p>
    <p>+12 mappers</p>
    <p>Target rate: 16.700 rec/s</p>
  </div>
  <div class="page">
    <p>DS2 ON APACHE FLINK</p>
    <p>wordcount</p>
    <p>Target rate: 2.000.000 rec/s</p>
  </div>
  <div class="page">
    <p>DS2 ON APACHE FLINK</p>
    <p>wordcount</p>
    <p>Apache Flink savepoint and</p>
    <p>reconfiguration takes ~30s</p>
    <p>Target rate: 2.000.000 rec/s</p>
  </div>
  <div class="page">
    <p>DS2 ON APACHE FLINK</p>
    <p>wordcount</p>
    <p>Apache Flink savepoint and</p>
    <p>reconfiguration takes ~30s</p>
    <p>DS2 converges in two steps for both operators Target rate: 2.000.000 rec/s</p>
  </div>
  <div class="page">
    <p>DS2 ON APACHE FLINK</p>
    <p>wordcount</p>
    <p>Apache Flink savepoint and</p>
    <p>reconfiguration takes ~30s</p>
    <p>DS2 converges in two steps for both operators</p>
    <p>DS2 reacts 3s after the target</p>
    <p>rate has changed</p>
    <p>Target rate: 2.000.000 rec/s</p>
  </div>
  <div class="page">
    <p>CONVERGENCE - NEXMARK</p>
    <p>initial parallelism</p>
    <p>Q1: flatmap</p>
    <p>Q2: filter</p>
    <p>Q3: incremental</p>
    <p>join</p>
    <p>Q5: tumbling window</p>
    <p>join</p>
    <p>Q8: sliding</p>
    <p>window</p>
    <p>Q11: session window</p>
    <p>=&gt; : scaling action</p>
  </div>
  <div class="page">
    <p>CONVERGENCE - NEXMARK</p>
    <p>initial parallelism</p>
    <p>Q1: flatmap</p>
    <p>Q2: filter</p>
    <p>Q3: incremental</p>
    <p>join</p>
    <p>Q5: tumbling window</p>
    <p>join</p>
    <p>Q8: sliding</p>
    <p>window</p>
    <p>Q11: session window</p>
    <p>=&gt; : scaling action</p>
    <p>scale-up</p>
  </div>
  <div class="page">
    <p>CONVERGENCE - NEXMARK</p>
    <p>initial parallelism</p>
    <p>Q1: flatmap</p>
    <p>Q2: filter</p>
    <p>Q3: incremental</p>
    <p>join</p>
    <p>Q5: tumbling window</p>
    <p>join</p>
    <p>Q8: sliding</p>
    <p>window</p>
    <p>Q11: session window</p>
    <p>=&gt; : scaling action</p>
    <p>scale-up</p>
    <p>scale-down</p>
  </div>
  <div class="page">
    <p>CONVERGENCE - NEXMARK</p>
    <p>initial parallelism</p>
    <p>Q1: flatmap</p>
    <p>Q2: filter</p>
    <p>Q3: incremental</p>
    <p>join</p>
    <p>Q5: tumbling window</p>
    <p>join</p>
    <p>Q8: sliding</p>
    <p>window</p>
    <p>Q11: session window</p>
    <p>a single step for many queries and initial configurations</p>
    <p>=&gt; : scaling action</p>
    <p>scale-up</p>
    <p>scale-down</p>
  </div>
  <div class="page">
    <p>CONVERGENCE - NEXMARK</p>
    <p>initial parallelism</p>
    <p>Q1: flatmap</p>
    <p>Q2: filter</p>
    <p>Q3: incremental</p>
    <p>join</p>
    <p>Q5: tumbling window</p>
    <p>join</p>
    <p>Q8: sliding</p>
    <p>window</p>
    <p>Q11: session window</p>
    <p>at most 3 steps</p>
    <p>a single step for many queries and initial configurations</p>
    <p>=&gt; : scaling action</p>
    <p>scale-up</p>
    <p>scale-down</p>
  </div>
  <div class="page">
    <p>RECAP</p>
    <p>Observed metrics thresholdbased policies can lead to</p>
    <p>oscillations, misconfiguration and slow convergence.</p>
    <p>DS2 uses instrumentation to measure true processing and</p>
    <p>output rates and estimate parallelism for all operators at once.</p>
    <p>Stream processor</p>
    <p>Scaling Manager Scaling Policy</p>
    <p>Metrics Repositor</p>
    <p>invoke</p>
    <p>re-scale job</p>
    <p>report metrics</p>
    <p>mo nito</p>
    <p>r</p>
    <p>pull metrics</p>
    <p>decision</p>
    <p>Timely dataflow</p>
    <p>DS2 makes fast and accurate scaling decisions and converges in up to three steps even for non</p>
    <p>linear, complex dataflows.</p>
    <p>https://github.com/strymon-system/ds2</p>
  </div>
  <div class="page">
    <p>Three steps is all you need fast, accurate, automatic scaling decisions</p>
    <p>for distributed streaming dataflows</p>
    <p>Vasiliki Kalavri, John Liagouris, Moritz Hoffmann, Desislava Dimitrova, Matthew Forshaw, Timothy Roscoe</p>
    <p>Support:</p>
    <p>Systems Group, Department of Computer Science, ETH Zrich, firstname.lastname@inf.ethz.ch</p>
    <p>Newcastle University, firstname.lastname@newcastle.ac.uk</p>
  </div>
</Presentation>
