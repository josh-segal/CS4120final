<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Hi, everyone! Thank you very much for coming!</p>
    <p>My name is Victor Costan, and I am here to talk about Sanctum.</p>
    <p>This work was done at MITs Computer Science and AI Laboratory, in collaboration with Ilia Lebedev and Prof. Srini Devadas.</p>
  </div>
  <div class="page">
    <p>Sanctums goal is trusted computing. In this respect, our work belongs to the same family as TPM, TXT, SGX, and TrustZone. However, Sanctum gives you unprecedented protection and unprecedented control over your computer.</p>
    <p>Most of Sanctums security logic is in software, not in hardware or microcode. Our software can be inspected by the computers owner, and is amenable to formal verification. Most of this software can even be replaced by the computers owner. This is an unprecedented level of control.</p>
    <p>Sanctums hardware extensions can be applied to any reasonably modern RISC processor core. In combination with Sanctums software, the hardware extensions protect against any practical software attacks, including cache timing attacks. This is an unprecedented level of protection.</p>
    <p>Our prototype targets the RISC-V architecture, and shows that Sanctum incurs acceptable performance overheads.</p>
  </div>
  <div class="page">
    <p>To get things started, let me give you a quick overview of trusted computing, which is the problem that were trying to solve.</p>
  </div>
  <div class="page">
    <p>So theres this dream, called secure remote computation. In this dream, you can package your code and data into a bundle, send that bundle over to a remote computer, have the computer run your software, and get the results back. The thing is, you dont own that remote computer, so you rely on magic to protect your code and data from the computers owner, and from the other software that might be running on that computer.</p>
    <p>Unfortunately, this is just a dream. The closest thing weve got is fully homomorphic encryption, and thats nowhere nearly practical.</p>
  </div>
  <div class="page">
    <p>Fortunately, we can approximate that dream, if were willing to trust a piece of hardware on the remote computer. The trusted hardware establishes a secure container on the remote computer, which protects our computation and data from untrusted third parties. So, our computation is safe, as long as we only send it to trusted hardware.</p>
  </div>
  <div class="page">
    <p>So, we have to make sure that we only talk to trusted hardware. We can use software attestation for this.</p>
  </div>
  <div class="page">
    <p>Very quickly, software attestation means that there is a hardware manufacturer that we trust, and the manufacturer acts as a certificate authority in a PKI.</p>
  </div>
  <div class="page">
    <p>Each piece of trusted hardware has an attestation key, and the manufacturer issues an endorsement certificate for the public attestation key. When we see that certificate, we know that we can trust signatures issued by the devices private attestation key, which is stored in secure hardware.</p>
  </div>
  <div class="page">
    <p>Now, when we want to send our code over to the remote computer, we will first ask the trusted hardware to create a secure container for us, and we will send a challenge message to that secure container.</p>
  </div>
  <div class="page">
    <p>Our loader code in the container will receive the challenge message and compute a response message, and then it will ask the trusted hardware to produce an attestation signature. The attestation signature covers the message produced by our container, as well as a measurement of the secure containers initial state. When we validate the attestation signature, we are assured that we are talking to a secure container that is initialized according to our instructions, and hosted by hardware we trust.</p>
  </div>
  <div class="page">
    <p>What Ive said so far applies to all trusted computing solutions. These solutions differ by the amount of software that goes into a secure container, by the security guarantees offered to the container, by the trusted hardware and software needed to enforce the systems security, and by the details of their software attestation process.</p>
    <p>The rest of this talk will hopefully clarify where Sanctum stands on all these aspects.</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Our secure containers are called enclaves, and they are conceptually extensions of application processes. Enclaves run at the lowest possible privilege level -- this is known as ring 3 in x86, or user mode anywhere else. This means enclaves cannot compromise the host computers OS or hypervisor. So we dont need to worry about restricting enclaves  the same mechanisms used to police user processes will work for enclaves.</p>
  </div>
  <div class="page">
    <p>Enclaves can access the memory space of their host applications, but they cannot perform syscalls directly. This is because we dont trust the OS kernel to not damage the enclaves execution context before returning from the syscall. To work around this, the enclave must rely on its host application to proxy syscalls to the OS. The syscall proxying requires code in the enclave, and in the host application. We expect this code to become a part of the runtime library. For example, if your enclave software uses libc, youd simply use an enclave-aware libc that proxies all the syscalls it makes.</p>
  </div>
  <div class="page">
    <p>Our enclaves arent new. SGXs enclaves operate in a very similar way. Something that _is_ new, and that Im really proud of  the vast majority our security logic is expressed in software. This isnt firmware or microcode. Its normal software that executes using the processors standard execution facilities. Its software that the computers owner can inspect and analyze.</p>
  </div>
  <div class="page">
    <p>The downside of not relying on firmware or microcode is that our software is not automatically isolated from rest of the code running on the machine, and we may be running alongside a malicious hypervisor or operating system. In order to be able to provide any sort of meaningful security guarantees, we assume that our software runs at a higher privilege level than anything else. The RISC-V architecture conveniently includes a machine level, and our prototype takes advantage of the existence of this machine level.</p>
    <p>We run two pieces of software at the machine level.</p>
  </div>
  <div class="page">
    <p>The central piece of software is the security monitor, which enforces Sanctums security policies. Our security monitor is tiny, so it can be amenable to formal verification. The key to keeping it so small is that we dont make any resource allocation decisions in the monitor. The operating system gets to make all the decisions, just like today. In Sanctum, the OS must submit its decisions to the security monitor in order to have them applied. This way, we can verify the OS decisions in the monitor, and we can reject decisions that would break Sanctums security guarantees.</p>
  </div>
  <div class="page">
    <p>The other piece of software that runs in machine mode is the measurement root. This code runs at boot time, and sets up the software attestation chain. It does not play any part after the boot process completes.</p>
  </div>
  <div class="page">
    <p>Lets see how Sanctum gives computer owners unprecedented control over their systems.</p>
  </div>
  <div class="page">
    <p>Before we go into attestation, lets talk a little bit about Sanctums boot process. One of the things that make Sanctum special is that the security monitor, which is most of our logic, is stored in flash memory, and can be replaced by the computers owner.</p>
  </div>
  <div class="page">
    <p>In order to keep things secure, we rely on the measurement root code, which is stored in the processors ROM, and cannot be modified.</p>
  </div>
  <div class="page">
    <p>When the computer powers up, the measurement root reads the security monitor and computes its cryptographic hash.</p>
  </div>
  <div class="page">
    <p>This hash is fed into some cryptographic machinery that eventually generates an RSA key pair, which becomes the monitors attestation key.</p>
  </div>
  <div class="page">
    <p>Finally, the measurement root uses the processors attestation key to issue a certificate that contains the monitors public attestation key and its measurement hash. After this happens, the measurement root hands control over to the security monitor. The key fact to note here is that the monitors certificate contains the monitors measurement. If the computer owner modifies the monitor, the changes will be reflected in the attestation certificate.</p>
  </div>
  <div class="page">
    <p>If youre horrified by the prospect of having to generate an RSA key on every boot, rest assured. We have a mechanism to securely cache the monitors RSA key in flash. This way, we only need to regenerate the RSA key when the computer owner replaces the security monitor, which shouldnt happen very often.</p>
  </div>
  <div class="page">
    <p>We borrowed SGXs general approach to enclave measurement. When an enclave is created, it is in a loading state, where it cannot be used. The application that created the enclave works with the OS to allocate resources to the enclave, and to load the initial pages of code and data into the enclave. The parameters of each loading operation are hashed and contribute to the enclaves measurement.</p>
    <p>When the loading stage is complete, the enclave is initialized. At this point, the enclaves measurement is finalized, and the security monitor will not allow the use of any loading API on the enclave. So, an enclaves measurement is an accurate representation of the enclaves initial memory state.</p>
  </div>
  <div class="page">
    <p>Now that you know how the boot process works, youll find the rest of the attestation to be pretty standard. Ill go through it quickly, so you can see the ideas Ive outlined come together.</p>
  </div>
  <div class="page">
    <p>First, you trust the Sanctum processor manufacturer, which has a root key.</p>
  </div>
  <div class="page">
    <p>Each Sanctum processor has a processor attestation key, and an endorsement certificate from the manufacturer.</p>
  </div>
  <div class="page">
    <p>When the computer powers up, the measurement root creates a monitor attestation key pair and issues an attestation certificate to the monitor.</p>
  </div>
  <div class="page">
    <p>Now, when you want to send your computation over to a Sanctum processor, you send the enclaves initial contents, and a challenge message. The enclave starts executing, reads the challenge message, and computes the response message. The enclave uses Sanctums secure inter-enclave communication primitives to send a hash of the challenge response to the Signing Enclave, which is a special enclave that the security monitor trusts.</p>
  </div>
  <div class="page">
    <p>In Sanctum, the security monitor does not perform any operations using the private attestation key. Instead, there is a special Signing Enclave, whose measurement hash is hard-coded into the security monitor. This is the only enclave that can receive the monitors private attestation key.</p>
  </div>
  <div class="page">
    <p>So, our enclave must use Sanctums secure inter-enclave communication primitives to send a hash of the response message to the Signing Enclave. The Signing Enclave creates an attestation signature that covers our enclaves measurement and the response message.</p>
  </div>
  <div class="page">
    <p>At this point, we can examine the attestation signature, and the monitor and processors attestation certificates, to convince ourselves that we are communicating with an enclave built according to our instructions, hosted on a Sanctum processor running a security monitor that we trust.</p>
  </div>
  <div class="page">
    <p>Now, lets talk a bit about protection.</p>
  </div>
  <div class="page">
    <p>Sanctum was designed for multi-core processors with a shared last-level cache. This matters because per-core caches can be protected pretty easily  whenever you enter or exit an enclave, flush the cores caches. This is a simple strategy, and we like simple, so this is exactly what we do to protect per-core caches.</p>
    <p>The shared LLC is more interesting, because an attacker thread could be attempting a timing attack at any time. Sanctum uses a very simple scheme, called page coloring, which I will outline soon.</p>
  </div>
  <div class="page">
    <p>Sanctum *almost* scales to a full-fledged Intel desktop system. The one aspect we dont support is hyper-threading. This is because with hyper-threading, theres just simply too much micro-architectural resource sharing. We couldnt come up with any sane way to protect an enclave thread from being attacked by a thread running on the same core. So Sanctum doesnt support hyperthreading.</p>
  </div>
  <div class="page">
    <p>Now, lets turn onto cache timing attacks. At a very high level, these attacks take advantage of the fact that a cache hit is much faster than a cache miss. Virtually all cache timing attacks require the attacker to access the same cache as the victim, so the memory access timing can be observed.</p>
    <p>Sanctum targets set-associative caches, which are the most commonly used caches. For the purpose of this talk, all that matters is that a set-associative cache is made up of multiple sets, and a memory location can only be cached in exactly one set, depending on its address. Conceptually, we can pretend that each set in a setassociative cache is a separate cache memory.</p>
  </div>
  <div class="page">
    <p>This is the insight behind cache partitioning. If we can ensure that memory owned by an enclave will never end up in the same cache set as memory owned by an attacker, we can consider that the enclave and the attacker are using different caches. This defeats cache timing attacks, because they require a shared cache.</p>
  </div>
  <div class="page">
    <p>Set-associative caches use physical memory addresses for set index computation.</p>
  </div>
  <div class="page">
    <p>This is convenient for us, because software uses address translation, which abstracts away physical addresses almost completely. We can ask the operating system to structure its page tables in any way that helps us achieve our security goal.</p>
  </div>
  <div class="page">
    <p>Page coloring essentially comes down to this observation that I just made. There are some physical address bits that belong to the cache set index, and are set by the page tables. These bits can be used to control cache placement.</p>
  </div>
  <div class="page">
    <p>The problem is, by default, the page color bits are at the bottom of an address physical page number. If you draw your DRAM and color each page, its going to look like the stack on the left.</p>
    <p>This is a problem because, in Sanctum, wed like to assign some colors exclusively to enclaves. At the same time, the operating system probably needs some large continuous chunks of DRAM for DMA. For example, if you have a graphics card or a high-performance network card, these things tend to like large DMA buffers.</p>
  </div>
  <div class="page">
    <p>We use a bit of hardware to munge the physical addresses as they enter the cache unit, and obtain the color map on the right.</p>
    <p>In Sanctum, the DRAM is effectively split into equally-sized DRAM regions, and each region maps to disjoint LLC sets.</p>
  </div>
  <div class="page">
    <p>Each DRAM region can be assigned to exactly one enclave, or to the operating system and its untrusted processes. Most of each enclaves virtual address space is mapped into the host applications memory, using the page tables prepared by the OS for the host application. However, one continuous range is used to map the enclaves own DRAM regions, using a separate set of page tables that is managed by the enclave.</p>
    <p>This gives us isolation at all levels. The data in an enclaves DRAM regions is not accessible to any other software. The page tables used to map the enclaves private memory are also isolated, so they dont leak memory access patterns.</p>
    <p>and this wraps up my high-level overview. The exciting details are in the paper!</p>
  </div>
  <div class="page"/>
  <div class="page"/>
  <div class="page"/>
  <div class="page"/>
  <div class="page"/>
  <div class="page"/>
  <div class="page"/>
  <div class="page"/>
  <div class="page"/>
  <div class="page"/>
  <div class="page"/>
  <div class="page"/>
  <div class="page"/>
  <div class="page"/>
  <div class="page"/>
  <div class="page"/>
</Presentation>
