<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>One&amp;Done: A Single-Decryption EM-Based Attack on OpenSSLs Constant-Time Blinded RSA</p>
    <p>Monjur Alam, Haider Adnan Khan, Moumita Dey, Nishith Sinha, Robert Callan, Alenka Zajic, and Milos Prvulovic</p>
  </div>
  <div class="page">
    <p>vMotivation</p>
    <p>Public key crypto is essential for modern security  Secure exchange of session keys  Verifying identity of systems and users  And a lot more</p>
    <p>Private keys are a highly valuable asset  So attackers want them  And we dont want attackers to get them</p>
  </div>
  <div class="page">
    <p>vPublic Key Crypto</p>
    <p>Good public key crypto (e.g. RSA)  Designed to make private keys very, very hard to recover</p>
    <p>RSA</p>
    <p>key</p>
  </div>
  <div class="page">
    <p>vAnalog Side-Channel Attacks</p>
    <p>But cryptographic implementation runs on real hardware  Logic gates switch, causing current flow  Currents flowing create changes in surrounding EM field</p>
    <p>RSA</p>
    <p>key</p>
    <p>Side-channel information helps recover the private key</p>
  </div>
  <div class="page">
    <p>vAnalog Side-Channel Attacks</p>
    <p>Message randomization (blinding)  Prevents chosen-plaintext and other message-dependent attacks</p>
    <p>But when message-independent operations use the key</p>
    <p>RSA</p>
    <p>key</p>
    <p>Side-channel information, alone, eventually enables efficient recovery of the private key</p>
  </div>
  <div class="page">
    <p>vAnalog Side-Channel Attacks</p>
    <p>One&amp;Done  Message does not matter (message blinding does not help)  Multiple traces not needed (exponent blinding does not help)</p>
    <p>RSA</p>
    <p>key</p>
    <p>Side-channel information alone, in a single encryption/signing, enables efficient recovery of the entire private key</p>
  </div>
  <div class="page">
    <p>vOpenSSLs RSA Implementation</p>
    <p>BN_mod_exp_montgomery_consttime()  Computes xd mod m, where d is the secret exponent</p>
    <p>For each fixed-size window</p>
    <p>For each bit in the window Square the result (v=v2) Look up one bit of d and add to wval</p>
    <p>Look up precomputed xwval Multiply result with xwval</p>
  </div>
  <div class="page">
    <p>vSide-Channel Attacks on OpenSSLs RSA</p>
    <p>BN_mod_exp_montgomery_consttime()  Computes xd mod m, where d is the secret exponent</p>
    <p>For each fixed-size window</p>
    <p>For each bit in the window Square the result (v=v2) Get bit from d, add to wval</p>
    <p>Look up precomputed xwval Multiply result with xwval</p>
    <p>Cache (e.g. Percival) Scatter-Gather</p>
    <p>Genkin et al., CHES15 Message Blinding</p>
    <p>One&amp;Done (new) Mitigation (new)</p>
  </div>
  <div class="page">
    <p>vMeasurement Setup</p>
    <p>Samsung Galaxy Centura</p>
    <p>SCH-S738C</p>
    <p>Alcatel Ideal A13-OLinuXino</p>
  </div>
  <div class="page">
    <p>vSide Channel Analysis  Recent advances in side-channel-based program monitoring</p>
    <p>Camelia, our DARPA LADS project  Uses analog signals to monitor computational activity</p>
    <p>to detect control flow deviation and/or execution of unknown code  Found that even a single-instruction control-flow can be detected  But</p>
    <p>Constant-time implementation  no key-dependent CF  Every encryption has the same CF sequence</p>
    <p>Cant use CF differences for attack  But can use the (very stable and predictable) signal features and timing</p>
    <p>to tell us exactly where in the signal BN_is_bit_set is executing</p>
  </div>
  <div class="page">
    <p>vAttack Approach Constant-time Montgomery Multiplication to square the result</p>
    <p>Window-value update</p>
    <p>Another Constant-time Montgomery Multiplication</p>
    <p>Easy to Find</p>
    <p>Const-Time</p>
  </div>
  <div class="page">
    <p>vRelevant Part Zoom-In</p>
    <p>Window Value Update</p>
  </div>
  <div class="page">
    <p>How well does this recover bits of &lt;dp,dq&gt;?</p>
    <p>Training on 15 private-key RSA decryptions  Recover bits of secret exponents using only one decryption</p>
    <p>Samsung Galaxy</p>
    <p>Centura Phone</p>
    <p>Alcatel Ideal Phone</p>
    <p>OLinuXino Board</p>
    <p>Max Median Min</p>
  </div>
  <div class="page">
    <p>vFull RSA Key Recovery</p>
    <p>We have dp and dq but with  Erasures  could not find where the bits signal is  Errors  found the bits signal, but misclassified it (0 vs. 1)</p>
    <p>Existing branch-and-prune algorithms  Prune partial solutions when group of bits has too many errors</p>
    <p>Assumes errors are uniformly distributed  Our errors often occur in bursts  Does not explicitly handle erasures</p>
    <p>Prune partial solutions that disagree with known bits of &lt;dp,dq&gt;  Cant handle errors (no bits truly known)</p>
  </div>
  <div class="page">
    <p>vFull RSA Key Recovery</p>
    <p>We have dp and dq but with  Erasures  could not find where the bits signal is  Errors  found the bits signal, but misclassified it (0 vs. 1)</p>
    <p>Our algorithm  Take partial solution with fewest disagreement overall</p>
    <p>Known-to-be-unknown bits (erasures) not counted  Expand that partial solution by one bit position</p>
    <p>Prune expansions that violate relationships between p,q,n,dp,and dq  Efficient implementation, nearly all checks use only scalars (not BNs)</p>
    <p>Repeat</p>
  </div>
  <div class="page">
    <p>vRecover RSA key from &lt;dp,dq&gt; with errors</p>
    <p>Errors Erasures 50% Mix</p>
    <p>K ey</p>
    <p>S ea</p>
    <p>rc h</p>
    <p>S te</p>
    <p>ps</p>
    <p>Our &lt;dp,dq&gt; results (errors+erasures)</p>
    <p>Key search using one i7 core: 500K steps / second!</p>
  </div>
  <div class="page">
    <p>vMore in the paper</p>
    <p>Train on one device, attack another  Only slightly worse than same-device (still 100% key recovery)</p>
    <p>Similar attack on sliding-window implementation  Used in prior versions of OpenSSL</p>
    <p>Prior attacks extract enough bits to sometimes allow full-key recovery  One&amp;Done recovers nearly all bits in one private-key encryption,</p>
    <p>recovered full key every time</p>
  </div>
  <div class="page">
    <p>vMitigation</p>
    <p>Fundamental enabler of the attack  Several instructions have very few possibilities for their operands</p>
    <p>BN_is_bit_set returns either 0 or 1</p>
    <p>No need to get bits one at a time  A 5-bit fixed window needs 5 consecutive bits</p>
    <p>Dont have to get them one at a time and shift into wval  So we take an entire words worth of bits each time,</p>
    <p>mask to window-size only before wval is needed  Takes only a little longer than getting one bit!  But done only once per window!</p>
  </div>
  <div class="page">
    <p>vResults after mitigation</p>
    <p>Samsung Galaxy Centura Phone</p>
    <p>Alcatel Ideal Phone OLinuXino Board</p>
    <p>Max Median Min</p>
    <p>Random Guessing</p>
    <p>Erasures Counted as Errors</p>
  </div>
  <div class="page">
    <p>vConclusions</p>
    <p>Analog side-channel attack on OpenSSLs constant-time modular exponentiation implementation  Precise timing thanks to constant-timeness of the implementation  Highly accurate thanks to one-secret-bit-at-a-time implementation</p>
    <p>Entire private key recovered from only one use of that key  Attack not affected by blinding</p>
    <p>Attack directly obtains exponent bits, message bits not relevant  Exponent blinding does not help agains single-trace attacks</p>
    <p>Mitigation: look up groups of secret bits, not individual bits</p>
  </div>
  <div class="page">
    <p>Thank you! Questions?</p>
  </div>
</Presentation>
