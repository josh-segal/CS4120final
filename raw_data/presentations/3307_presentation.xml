<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Aarhus University</p>
    <p>ZKBoo: Faster Zero-Knowledge for Boolean Circuits</p>
    <p>Irene Giacomelli, Jesper Madsen and Claudio Orlandi</p>
    <p>Usenix Security Symposium 2016</p>
  </div>
  <div class="page">
    <p>Zero-Knowledge (ZK) Arguments</p>
    <p>Alice</p>
    <p>...</p>
    <p>Private Input : x</p>
    <p>I know x such that y = C (x)</p>
    <p>(C and y public)</p>
    <p>Bob</p>
    <p>Output: yes! / no!</p>
  </div>
  <div class="page">
    <p>In theory...</p>
    <p>ZK protocols have many applications in designing several crypto primitives!</p>
    <p>signature schemes</p>
    <p>user identification protocols</p>
    <p>electronic voting systems</p>
    <p>verifiable delegation of computation</p>
    <p>electronic payment system</p>
    <p>... ... ...</p>
  </div>
  <div class="page">
    <p>In theory...</p>
    <p>ZK protocols have many applications in designing several crypto primitives!</p>
    <p>signature schemes</p>
    <p>user identification protocols</p>
    <p>electronic voting systems</p>
    <p>verifiable delegation of computation</p>
    <p>electronic payment system</p>
    <p>... ... ... 3 / 15</p>
  </div>
  <div class="page">
    <p>In practice...</p>
    <p>Real-world applications need practically efficient solutions for proving general statement</p>
  </div>
  <div class="page">
    <p>In practice...</p>
    <p>Real-world applications need practically efficient solutions for proving general statement</p>
    <p>SNARGs (Succinct Non-interactive ARGuments) [Gro10, Lip12, GGPR13, Lip 13, DFGK14, GRo 15]</p>
    <p>[PGHR13, BCGTV13, BCTV14, CTV15, CFH+15]</p>
    <p>- proofs of small size, fast in verifying :-) - large keys needed, slower in proving :-(</p>
    <p>ZKGC (zero-knowledge from garbled circuits) [Jawurek-Kerschbaum-Orlandi 2013]</p>
    <p>- proving time is decreased :-) - interaction is required :-(</p>
  </div>
  <div class="page">
    <p>In practice...</p>
    <p>Real-world applications need practically efficient solutions for proving general statement</p>
    <p>SNARGs (Succinct Non-interactive ARGuments) [Gro10, Lip12, GGPR13, Lip 13, DFGK14, GRo 15]</p>
    <p>[PGHR13, BCGTV13, BCTV14, CTV15, CFH+15]</p>
    <p>- proofs of small size, fast in verifying :-) - large keys needed, slower in proving :-(</p>
    <p>ZKGC (zero-knowledge from garbled circuits) [Jawurek-Kerschbaum-Orlandi 2013]</p>
    <p>- proving time is decreased :-) - interaction is required :-(</p>
  </div>
  <div class="page">
    <p>In practice...</p>
    <p>Real-world applications need practically efficient solutions for proving general statement</p>
    <p>SNARGs (Succinct Non-interactive ARGuments) [Gro10, Lip12, GGPR13, Lip 13, DFGK14, GRo 15]</p>
    <p>[PGHR13, BCGTV13, BCTV14, CTV15, CFH+15]</p>
    <p>- proofs of small size, fast in verifying :-) - large keys needed, slower in proving :-(</p>
    <p>ZKGC (zero-knowledge from garbled circuits) [Jawurek-Kerschbaum-Orlandi 2013]</p>
    <p>- proving time is decreased :-) - interaction is required :-(</p>
  </div>
  <div class="page">
    <p>In practice...</p>
    <p>Real-world applications need practically efficient solutions for proving general statement</p>
    <p>New!</p>
    <p>ZKBoo (Zero-Knowledge for Boolean circuits) - can be made non interactive :-) - fast in proving and verifying :-) - the size of the proof grows linearly with the circuit size :-|</p>
  </div>
  <div class="page">
    <p>Comparison for C = SHA-1</p>
    <p>I know x such that y = SHA-1(x)</p>
    <p>Preproc. (ms) Prover (ms) Verifier (ms) Proof size (B)</p>
    <p>ZKBoo 0 13 5 454840</p>
    <p>ZKGC 0 &gt; 19 &gt; 25 186880</p>
    <p>Pinocchio 9754 12059 8 288</p>
    <p>estimates for the proof size and lower-bounds for the runtime</p>
    <p>[Parno-Howell-Gentry-Raykova 2013]</p>
  </div>
  <div class="page">
    <p>In the rest of this talk:</p>
  </div>
  <div class="page">
    <p>-Protocol</p>
    <p>Public data: C : {0, 1}n {0, 1}m (boolean circuit) and y {0, 1}m</p>
    <p>Input: x s.t. C (x) = y</p>
    <p>Sample e {0, 1}e</p>
    <p>a</p>
    <p>e</p>
    <p>z</p>
    <p>Output: Y / N</p>
    <p>Complete: if Alice and Bob honest and C (x) = y, Pr[ Bob outputs Y ] = 1</p>
    <p>Soundness: from  2 accepting conversations (a, ei, zi ) with ei 6= ej we can efficiently compute x s.t. C (x) = y</p>
    <p>The protocol has soundness error : if Alice is cheating, then Pr[ Bob outputs Y ]  (Honest-Verifier) ZK property:</p>
    <p>the distribution of (a, e, z) does not reveal info on x</p>
    <p>It can be made non-interactive! (Fiat-Shamir heuristic)</p>
  </div>
  <div class="page">
    <p>-Protocol</p>
    <p>Public data: C : {0, 1}n {0, 1}m (boolean circuit) and y {0, 1}m</p>
    <p>Input: x s.t. C (x) = y</p>
    <p>Sample e {0, 1}e</p>
    <p>a</p>
    <p>e</p>
    <p>z</p>
    <p>Output: Y / N</p>
    <p>Complete: if Alice and Bob honest and C (x) = y, Pr[ Bob outputs Y ] = 1</p>
    <p>Soundness: from  2 accepting conversations (a, ei, zi ) with ei 6= ej we can efficiently compute x s.t. C (x) = y</p>
    <p>The protocol has soundness error : if Alice is cheating, then Pr[ Bob outputs Y ]  (Honest-Verifier) ZK property:</p>
    <p>the distribution of (a, e, z) does not reveal info on x</p>
    <p>It can be made non-interactive! (Fiat-Shamir heuristic)</p>
  </div>
  <div class="page">
    <p>-Protocol</p>
    <p>Public data: C : {0, 1}n {0, 1}m (boolean circuit) and y {0, 1}m</p>
    <p>Input: x s.t. C (x) = y</p>
    <p>Sample e {0, 1}e</p>
    <p>a</p>
    <p>e</p>
    <p>z</p>
    <p>Output: Y / N</p>
    <p>Complete: if Alice and Bob honest and C (x) = y, Pr[ Bob outputs Y ] = 1</p>
    <p>Soundness: from  2 accepting conversations (a, ei, zi ) with ei 6= ej we can efficiently compute x s.t. C (x) = y</p>
    <p>The protocol has soundness error : if Alice is cheating, then Pr[ Bob outputs Y ]  (Honest-Verifier) ZK property:</p>
    <p>the distribution of (a, e, z) does not reveal info on x</p>
    <p>It can be made non-interactive! (Fiat-Shamir heuristic)</p>
  </div>
  <div class="page">
    <p>-Protocol</p>
    <p>Public data: C : {0, 1}n {0, 1}m (boolean circuit) and y {0, 1}m</p>
    <p>Input: x s.t. C (x) = y</p>
    <p>Sample e {0, 1}e</p>
    <p>a</p>
    <p>e</p>
    <p>z</p>
    <p>Output: Y / N</p>
    <p>Complete: if Alice and Bob honest and C (x) = y, Pr[ Bob outputs Y ] = 1</p>
    <p>Soundness: from  2 accepting conversations (a, ei, zi ) with ei 6= ej we can efficiently compute x s.t. C (x) = y</p>
    <p>The protocol has soundness error : if Alice is cheating, then Pr[ Bob outputs Y ]  (Honest-Verifier) ZK property:</p>
    <p>the distribution of (a, e, z) does not reveal info on x</p>
    <p>It can be made non-interactive! (Fiat-Shamir heuristic)</p>
  </div>
  <div class="page">
    <p>-Protocol</p>
    <p>Public data: C : {0, 1}n {0, 1}m (boolean circuit) and y {0, 1}m</p>
    <p>Input: x s.t. C (x) = y</p>
    <p>Sample e {0, 1}e</p>
    <p>a</p>
    <p>e</p>
    <p>z</p>
    <p>Output: Y / N</p>
    <p>Complete: if Alice and Bob honest and C (x) = y, Pr[ Bob outputs Y ] = 1</p>
    <p>Soundness: from  2 accepting conversations (a, ei, zi ) with ei 6= ej we can efficiently compute x s.t. C (x) = y</p>
    <p>The protocol has soundness error : if Alice is cheating, then Pr[ Bob outputs Y ]</p>
    <p>(Honest-Verifier) ZK property: the distribution of (a, e, z) does not reveal info on x</p>
    <p>It can be made non-interactive! (Fiat-Shamir heuristic)</p>
  </div>
  <div class="page">
    <p>-Protocol</p>
    <p>Public data: C : {0, 1}n {0, 1}m (boolean circuit) and y {0, 1}m</p>
    <p>Input: x s.t. C (x) = y</p>
    <p>Sample e {0, 1}e</p>
    <p>a</p>
    <p>e</p>
    <p>z</p>
    <p>Output: Y / N</p>
    <p>Complete: if Alice and Bob honest and C (x) = y, Pr[ Bob outputs Y ] = 1</p>
    <p>Soundness: from  2 accepting conversations (a, ei, zi ) with ei 6= ej we can efficiently compute x s.t. C (x) = y</p>
    <p>The protocol has soundness error : if Alice is cheating, then Pr[ Bob outputs Y ]</p>
    <p>(Honest-Verifier) ZK property: the distribution of (a, e, z) does not reveal info on x</p>
    <p>It can be made non-interactive! (Fiat-Shamir heuristic)</p>
  </div>
  <div class="page">
    <p>-Protocol</p>
    <p>Public data: C : {0, 1}n {0, 1}m (boolean circuit) and y {0, 1}m</p>
    <p>Input: x s.t. C (x) = y</p>
    <p>Sample e {0, 1}e</p>
    <p>a</p>
    <p>e</p>
    <p>z</p>
    <p>Output: Y / N</p>
    <p>Complete: if Alice and Bob honest and C (x) = y, Pr[ Bob outputs Y ] = 1</p>
    <p>Soundness: from  2 accepting conversations (a, ei, zi ) with ei 6= ej we can efficiently compute x s.t. C (x) = y</p>
    <p>The protocol has soundness error : if Alice is cheating, then Pr[ Bob outputs Y ]  (Honest-Verifier) ZK property:</p>
    <p>the distribution of (a, e, z) does not reveal info on x</p>
    <p>It can be made non-interactive! (Fiat-Shamir heuristic)</p>
  </div>
  <div class="page">
    <p>-Protocol Recap</p>
    <p>x s.t.C (x) = y</p>
    <p>a</p>
    <p>e</p>
    <p>z</p>
    <p>Y / N</p>
    <p>Complete: if Alice honest, Pr[ Bob says Y ] = 1</p>
    <p>Soundness error: if Alice cheats, Pr[ Bob says Y ]</p>
    <p>ZK property: no info on x!</p>
    <p>3 rounds, public coin  non-interactive</p>
  </div>
  <div class="page">
    <p>Related work:</p>
    <p>IKOS Construction (or MPC-in-the-head)</p>
    <p>[Ishai-Kushilevitz-Ostrovsky-Sahai 2007]</p>
    <p>Input: x s.t. C (x) = y</p>
    <p>Output: Y / N</p>
    <p>a -protocol with error 2/3 (not implemented!)</p>
    <p>ZK protocol with asymptotically good complexity;</p>
  </div>
  <div class="page">
    <p>Related work:</p>
    <p>IKOS Construction (or MPC-in-the-head)</p>
    <p>[Ishai-Kushilevitz-Ostrovsky-Sahai 2007]</p>
    <p>Input: x s.t. C (x) = y</p>
    <p>Output: Y / N</p>
    <p>a -protocol with error 2/3 (not implemented!)</p>
    <p>ZK protocol with asymptotically good complexity;</p>
  </div>
  <div class="page">
    <p>Circuit decomposition:</p>
    <p>w01 w 0 2 w</p>
    <p>Share</p>
    <p>x</p>
    <p>f 11 f 1</p>
    <p>w11 w 1 2 w</p>
    <p>f 21 f 2</p>
    <p>... ...</p>
    <p>... wN1 w</p>
    <p>N 2 w</p>
    <p>N 3</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>y1 y2 y3</p>
    <p>Rec</p>
    <p>y</p>
    <p>w03</p>
    <p>w13</p>
    <p>wN3</p>
    <p>Goal: compute C (x) splitting the computation in 3 branches s.t. looking at</p>
    <p>any 2 consecutive branches gives no info on x</p>
    <p>Let N be a fixed integer, consider the following finite set of functions:</p>
    <p>Share, Rec and</p>
    <p>F = {f (j)1 , f (j) 2 , f</p>
    <p>(j) 3 }j=1,...,N</p>
    <p>correctness: y = C (x)</p>
    <p>2-privacy: e, j (wje, wje+1, ye+2) doesnt reveal info on x</p>
  </div>
  <div class="page">
    <p>Circuit decomposition:</p>
    <p>w01 w 0 2 w</p>
    <p>Share</p>
    <p>x</p>
    <p>f 11 f 1</p>
    <p>w11 w 1 2 w</p>
    <p>f 21 f 2</p>
    <p>... ...</p>
    <p>... wN1 w</p>
    <p>N 2 w</p>
    <p>N 3</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>y1 y2 y3</p>
    <p>Rec</p>
    <p>y</p>
    <p>w03</p>
    <p>w13</p>
    <p>wN3</p>
    <p>Goal: compute C (x) splitting the computation in 3 branches s.t. looking at</p>
    <p>any 2 consecutive branches gives no info on x</p>
    <p>Let N be a fixed integer, consider the following finite set of functions:</p>
    <p>Share, Rec and</p>
    <p>F = {f (j)1 , f (j) 2 , f</p>
    <p>(j) 3 }j=1,...,N</p>
    <p>correctness: y = C (x)</p>
    <p>2-privacy: e, j (wje, wje+1, ye+2) doesnt reveal info on x</p>
  </div>
  <div class="page">
    <p>Circuit decomposition:</p>
    <p>w01 w 0 2 w</p>
    <p>Share</p>
    <p>x</p>
    <p>f 11 f 1</p>
    <p>w11 w 1 2 w</p>
    <p>f 21 f 2</p>
    <p>... ...</p>
    <p>... wN1 w</p>
    <p>N 2 w</p>
    <p>N 3</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>y1 y2 y3</p>
    <p>Rec</p>
    <p>y</p>
    <p>w03</p>
    <p>w13</p>
    <p>wN3</p>
    <p>Goal: compute C (x) splitting the computation in 3 branches s.t. looking at</p>
    <p>any 2 consecutive branches gives no info on x</p>
    <p>Let N be a fixed integer, consider the following finite set of functions:</p>
    <p>Share, Rec and</p>
    <p>F = {f (j)1 , f (j) 2 , f</p>
    <p>(j) 3 }j=1,...,N</p>
    <p>correctness: y = C (x)</p>
    <p>2-privacy: e, j (wje, wje+1, ye+2) doesnt reveal info on x</p>
  </div>
  <div class="page">
    <p>Circuit decomposition:</p>
    <p>w01 w 0 2 w</p>
    <p>Share</p>
    <p>x</p>
    <p>f 11 f 1</p>
    <p>w11 w 1 2 w</p>
    <p>f 21 f 2</p>
    <p>... ...</p>
    <p>... wN1 w</p>
    <p>N 2 w</p>
    <p>N 3</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>y1 y2 y3</p>
    <p>Rec</p>
    <p>y</p>
    <p>w03</p>
    <p>w13</p>
    <p>wN3</p>
    <p>Goal: compute C (x) splitting the computation in 3 branches s.t. looking at</p>
    <p>any 2 consecutive branches gives no info on x</p>
    <p>Let N be a fixed integer, consider the following finite set of functions:</p>
    <p>Share, Rec and</p>
    <p>F = {f (j)1 , f (j) 2 , f</p>
    <p>(j) 3 }j=1,...,N</p>
    <p>correctness: y = C (x)</p>
    <p>2-privacy: e, j (wje, wje+1, ye+2) doesnt reveal info on x</p>
  </div>
  <div class="page">
    <p>Circuit decomposition:</p>
    <p>w01 w 0 2 w</p>
    <p>Share</p>
    <p>x</p>
    <p>f 11 f 1</p>
    <p>w11 w 1 2 w</p>
    <p>f 21 f 2</p>
    <p>... ...</p>
    <p>... wN1 w</p>
    <p>N 2 w</p>
    <p>N 3</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>y1 y2 y3</p>
    <p>Rec</p>
    <p>y</p>
    <p>w03</p>
    <p>w13</p>
    <p>wN3</p>
    <p>Goal: compute C (x) splitting the computation in 3 branches s.t. looking at</p>
    <p>any 2 consecutive branches gives no info on x</p>
    <p>Let N be a fixed integer, consider the following finite set of functions:</p>
    <p>Share, Rec and</p>
    <p>F = {f (j)1 , f (j) 2 , f</p>
    <p>(j) 3 }j=1,...,N</p>
    <p>correctness: y = C (x)</p>
    <p>2-privacy: e, j (wje, wje+1, ye+2) doesnt reveal info on x</p>
  </div>
  <div class="page">
    <p>Circuit decomposition:</p>
    <p>w01 w 0 2 w</p>
    <p>Share</p>
    <p>x</p>
    <p>f 11 f 1</p>
    <p>w11 w 1 2 w</p>
    <p>f 21 f 2</p>
    <p>... ...</p>
    <p>...</p>
    <p>wN1 w N 2 w</p>
    <p>N 3</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>y1 y2 y3</p>
    <p>Rec</p>
    <p>y</p>
    <p>w03</p>
    <p>w13</p>
    <p>wN3</p>
    <p>Goal: compute C (x) splitting the computation in 3 branches s.t. looking at</p>
    <p>any 2 consecutive branches gives no info on x</p>
    <p>Let N be a fixed integer, consider the following finite set of functions:</p>
    <p>Share, Rec and</p>
    <p>F = {f (j)1 , f (j) 2 , f</p>
    <p>(j) 3 }j=1,...,N</p>
    <p>correctness: y = C (x)</p>
    <p>2-privacy: e, j (wje, wje+1, ye+2) doesnt reveal info on x</p>
  </div>
  <div class="page">
    <p>Circuit decomposition:</p>
    <p>w01 w 0 2 w</p>
    <p>Share</p>
    <p>x</p>
    <p>f 11 f 1</p>
    <p>w11 w 1 2 w</p>
    <p>f 21 f 2</p>
    <p>... ...</p>
    <p>...</p>
    <p>wN1 w N 2 w</p>
    <p>N 3</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>y1 y2 y3</p>
    <p>Rec</p>
    <p>y</p>
    <p>w03</p>
    <p>w13</p>
    <p>wN3</p>
    <p>Goal: compute C (x) splitting the computation in 3 branches s.t. looking at</p>
    <p>any 2 consecutive branches gives no info on x</p>
    <p>Let N be a fixed integer, consider the following finite set of functions:</p>
    <p>Share, Rec and</p>
    <p>F = {f (j)1 , f (j) 2 , f</p>
    <p>(j) 3 }j=1,...,N</p>
    <p>correctness: y = C (x)</p>
    <p>2-privacy: e, j (wje, wje+1, ye+2) doesnt reveal info on x</p>
  </div>
  <div class="page">
    <p>Circuit decomposition:</p>
    <p>w01 w 0 2 w</p>
    <p>Share</p>
    <p>x</p>
    <p>f 11 f 1</p>
    <p>w11 w 1 2 w</p>
    <p>f 21 f 2</p>
    <p>... ...</p>
    <p>...</p>
    <p>wN1 w N 2 w</p>
    <p>N 3</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>... ...</p>
    <p>y1 y2 y3</p>
    <p>Rec</p>
    <p>y</p>
    <p>w03</p>
    <p>w13</p>
    <p>wN3</p>
    <p>Goal: compute C (x) splitting the computation in 3 branches s.t. looking at</p>
    <p>any 2 consecutive branches gives no info on x</p>
    <p>Let N be a fixed integer, consider the following finite set of functions:</p>
    <p>Share, Rec and</p>
    <p>F = {f (j)1 , f (j) 2 , f</p>
    <p>(j) 3 }j=1,...,N</p>
    <p>correctness: y = C (x)</p>
    <p>2-privacy: e, j (wje, wje+1, ye+2) doesnt reveal info on x</p>
  </div>
  <div class="page">
    <p>ZKBoo Protocol</p>
    <p>Public data: C : {0, 1}n  {0, 1}m (boolean circuit) and y  {0, 1}m</p>
    <p>Input: x s.t. C(x) = y</p>
    <p>w01 w 0 2 w</p>
    <p>x</p>
    <p>f 11 f 1 2 f</p>
    <p>w11 w 1 2 w</p>
    <p>f 21 f 2 2 f</p>
    <p>... ... ...</p>
    <p>wN1 w N 2 w</p>
    <p>N 3</p>
    <p>y1 y2 y3</p>
    <p>y</p>
    <p>w01 w 0 2 w</p>
    <p>w11 w 1 2 w</p>
    <p>... ... ...</p>
    <p>... ... ... w11 w</p>
    <p>y1 y2 y3</p>
    <p>e  {1, 2, 3}</p>
    <p>w01 w 0 2</p>
    <p>w03</p>
    <p>w11 w 1 2</p>
    <p>w13</p>
    <p>... ... ...</p>
    <p>... ... ... wN1 w</p>
    <p>N 2</p>
    <p>w13</p>
    <p>y1 y2 y3</p>
    <p>w01 w 0 2</p>
    <p>w03</p>
    <p>f 11 f 1 2</p>
    <p>w11 w 1 2</p>
    <p>w13</p>
    <p>f 21 f 2 2</p>
    <p>... ... ...</p>
    <p>wN1 w N 2</p>
    <p>w13</p>
    <p>y1 y2 y3</p>
    <p>y</p>
    <p>Check consistency Soundness error: 2/3</p>
  </div>
  <div class="page">
    <p>ZKBoo Protocol</p>
    <p>Public data: C : {0, 1}n  {0, 1}m (boolean circuit) and y  {0, 1}m</p>
    <p>Input: x s.t. C(x) = y</p>
    <p>w01 w 0 2 w</p>
    <p>x</p>
    <p>f 11 f 1 2 f</p>
    <p>w11 w 1 2 w</p>
    <p>f 21 f 2 2 f</p>
    <p>... ... ...</p>
    <p>wN1 w N 2 w</p>
    <p>N 3</p>
    <p>y1 y2 y3</p>
    <p>y</p>
    <p>w01 w 0 2 w</p>
    <p>w11 w 1 2 w</p>
    <p>... ... ...</p>
    <p>... ... ... w11 w</p>
    <p>y1 y2 y3</p>
    <p>e  {1, 2, 3}</p>
    <p>w01 w 0 2</p>
    <p>w03</p>
    <p>w11 w 1 2</p>
    <p>w13</p>
    <p>... ... ...</p>
    <p>... ... ... wN1 w</p>
    <p>N 2</p>
    <p>w13</p>
    <p>y1 y2 y3</p>
    <p>w01 w 0 2</p>
    <p>w03</p>
    <p>f 11 f 1 2</p>
    <p>w11 w 1 2</p>
    <p>w13</p>
    <p>f 21 f 2 2</p>
    <p>... ... ...</p>
    <p>wN1 w N 2</p>
    <p>w13</p>
    <p>y1 y2 y3</p>
    <p>y</p>
    <p>Check consistency Soundness error: 2/3</p>
  </div>
  <div class="page">
    <p>ZKBoo Protocol</p>
    <p>Public data: C : {0, 1}n  {0, 1}m (boolean circuit) and y  {0, 1}m</p>
    <p>Input: x s.t. C(x) = y</p>
    <p>w01 w 0 2 w</p>
    <p>x</p>
    <p>f 11 f 1 2 f</p>
    <p>w11 w 1 2 w</p>
    <p>f 21 f 2 2 f</p>
    <p>... ... ...</p>
    <p>wN1 w N 2 w</p>
    <p>N 3</p>
    <p>y1 y2 y3</p>
    <p>y</p>
    <p>w01 w 0 2 w</p>
    <p>w11 w 1 2 w</p>
    <p>... ... ...</p>
    <p>... ... ... w11 w</p>
    <p>y1 y2 y3</p>
    <p>e  {1, 2, 3}</p>
    <p>w01 w 0 2</p>
    <p>w03</p>
    <p>w11 w 1 2</p>
    <p>w13</p>
    <p>... ... ...</p>
    <p>... ... ... wN1 w</p>
    <p>N 2</p>
    <p>w13</p>
    <p>y1 y2 y3</p>
    <p>w01 w 0 2</p>
    <p>w03</p>
    <p>f 11 f 1 2</p>
    <p>w11 w 1 2</p>
    <p>w13</p>
    <p>f 21 f 2 2</p>
    <p>... ... ...</p>
    <p>wN1 w N 2</p>
    <p>w13</p>
    <p>y1 y2 y3</p>
    <p>y</p>
    <p>Check consistency Soundness error: 2/3</p>
  </div>
  <div class="page">
    <p>ZKBoo Protocol</p>
    <p>Public data: C : {0, 1}n  {0, 1}m (boolean circuit) and y  {0, 1}m</p>
    <p>Input: x s.t. C(x) = y</p>
    <p>w01 w 0 2 w</p>
    <p>x</p>
    <p>f 11 f 1 2 f</p>
    <p>w11 w 1 2 w</p>
    <p>f 21 f 2 2 f</p>
    <p>... ... ...</p>
    <p>wN1 w N 2 w</p>
    <p>N 3</p>
    <p>y1 y2 y3</p>
    <p>y</p>
    <p>w01 w 0 2 w</p>
    <p>w11 w 1 2 w</p>
    <p>... ... ...</p>
    <p>... ... ... w11 w</p>
    <p>y1 y2 y3</p>
    <p>e  {1, 2, 3}</p>
    <p>w01 w 0 2</p>
    <p>w03</p>
    <p>w11 w 1 2</p>
    <p>w13</p>
    <p>... ... ...</p>
    <p>... ... ... wN1 w</p>
    <p>N 2</p>
    <p>w13</p>
    <p>y1 y2 y3</p>
    <p>w01 w 0 2</p>
    <p>w03</p>
    <p>f 11 f 1 2</p>
    <p>w11 w 1 2</p>
    <p>w13</p>
    <p>f 21 f 2 2</p>
    <p>... ... ...</p>
    <p>wN1 w N 2</p>
    <p>w13</p>
    <p>y1 y2 y3</p>
    <p>y</p>
    <p>Check consistency Soundness error: 2/3</p>
  </div>
  <div class="page">
    <p>ZKBoo Protocol</p>
    <p>Public data: C : {0, 1}n  {0, 1}m (boolean circuit) and y  {0, 1}m</p>
    <p>Input: x s.t. C(x) = y</p>
    <p>w01 w 0 2 w</p>
    <p>x</p>
    <p>f 11 f 1 2 f</p>
    <p>w11 w 1 2 w</p>
    <p>f 21 f 2 2 f</p>
    <p>... ... ...</p>
    <p>wN1 w N 2 w</p>
    <p>N 3</p>
    <p>y1 y2 y3</p>
    <p>y</p>
    <p>w01 w 0 2 w</p>
    <p>w11 w 1 2 w</p>
    <p>... ... ...</p>
    <p>... ... ... w11 w</p>
    <p>y1 y2 y3</p>
    <p>e  {1, 2, 3}</p>
    <p>w01 w 0 2</p>
    <p>w03</p>
    <p>w11 w 1 2</p>
    <p>w13</p>
    <p>... ... ...</p>
    <p>... ... ... wN1 w</p>
    <p>N 2</p>
    <p>w13</p>
    <p>y1 y2 y3</p>
    <p>w01 w 0 2</p>
    <p>w03</p>
    <p>f 11 f 1 2</p>
    <p>w11 w 1 2</p>
    <p>w13</p>
    <p>f 21 f 2 2</p>
    <p>... ... ...</p>
    <p>wN1 w N 2</p>
    <p>w13</p>
    <p>y1 y2 y3</p>
    <p>y</p>
    <p>Check consistency Soundness error: 2/3</p>
  </div>
  <div class="page">
    <p>ZKBoo Protocol</p>
    <p>Public data: C : {0, 1}n  {0, 1}m (boolean circuit) and y  {0, 1}m</p>
    <p>Input: x s.t. C(x) = y</p>
    <p>w01 w 0 2 w</p>
    <p>x</p>
    <p>f 11 f 1 2 f</p>
    <p>w11 w 1 2 w</p>
    <p>f 21 f 2 2 f</p>
    <p>... ... ...</p>
    <p>wN1 w N 2 w</p>
    <p>N 3</p>
    <p>y1 y2 y3</p>
    <p>y</p>
    <p>w01 w 0 2 w</p>
    <p>w11 w 1 2 w</p>
    <p>... ... ...</p>
    <p>... ... ... w11 w</p>
    <p>y1 y2 y3</p>
    <p>e  {1, 2, 3}</p>
    <p>w01 w 0 2</p>
    <p>w03</p>
    <p>w11 w 1 2</p>
    <p>w13</p>
    <p>... ... ...</p>
    <p>... ... ... wN1 w</p>
    <p>N 2</p>
    <p>w13</p>
    <p>y1 y2 y3</p>
    <p>w01 w 0 2</p>
    <p>w03</p>
    <p>f 11 f 1 2</p>
    <p>w11 w 1 2</p>
    <p>w13</p>
    <p>f 21 f 2 2</p>
    <p>... ... ...</p>
    <p>wN1 w N 2</p>
    <p>w13</p>
    <p>y1 y2 y3</p>
    <p>y</p>
    <p>Check consistency</p>
    <p>Soundness error: 2/3</p>
  </div>
  <div class="page">
    <p>ZKBoo Protocol</p>
    <p>Public data: C : {0, 1}n  {0, 1}m (boolean circuit) and y  {0, 1}m</p>
    <p>Input: x s.t. C(x) = y</p>
    <p>w01 w 0 2 w</p>
    <p>x</p>
    <p>f 11 f 1 2 f</p>
    <p>w11 w 1 2 w</p>
    <p>f 21 f 2 2 f</p>
    <p>... ... ...</p>
    <p>wN1 w N 2 w</p>
    <p>N 3</p>
    <p>y1 y2 y3</p>
    <p>y</p>
    <p>w01 w 0 2 w</p>
    <p>w11 w 1 2 w</p>
    <p>... ... ...</p>
    <p>... ... ... w11 w</p>
    <p>y1 y2 y3</p>
    <p>e  {1, 2, 3}</p>
    <p>w01 w 0 2</p>
    <p>w03</p>
    <p>w11 w 1 2</p>
    <p>w13</p>
    <p>... ... ...</p>
    <p>... ... ... wN1 w</p>
    <p>N 2</p>
    <p>w13</p>
    <p>y1 y2 y3</p>
    <p>w01 w 0 2</p>
    <p>w03</p>
    <p>f 11 f 1 2</p>
    <p>w11 w 1 2</p>
    <p>w13</p>
    <p>f 21 f 2 2</p>
    <p>... ... ...</p>
    <p>wN1 w N 2</p>
    <p>w13</p>
    <p>y1 y2 y3</p>
    <p>y</p>
    <p>Check consistency Soundness error: 2/3</p>
  </div>
  <div class="page">
    <p>Linear Decomposition:</p>
    <p>N= number of gates in the boolean circuit C</p>
    <p>Share(x) = (w01, w 0 2, w</p>
    <p>Rec(y1, y2, y3) = y1  y2  y3</p>
    <p>{f (j)1 , f (j) 2 , f</p>
    <p>(j) 3 }</p>
    <p>XOR gate</p>
    <p>f (j) e (w</p>
    <p>a e, w</p>
    <p>b e ) = w</p>
    <p>a e  wbe</p>
    <p>AND gate</p>
    <p>f (j) e (w</p>
    <p>a e, w</p>
    <p>b e , w</p>
    <p>a e+1, w</p>
    <p>b e+1) = w</p>
    <p>a e w</p>
    <p>b e  wae+1w</p>
    <p>b e  wae wbe+1  rj</p>
    <p>e = 1, 2, 3</p>
    <p>a-th b-th</p>
    <p>j-th gate</p>
  </div>
  <div class="page">
    <p>Linear Decomposition:</p>
    <p>N= number of gates in the boolean circuit C</p>
    <p>Share(x) = (w01, w 0 2, w</p>
    <p>Rec(y1, y2, y3) = y1  y2  y3</p>
    <p>{f (j)1 , f (j) 2 , f</p>
    <p>(j) 3 }</p>
    <p>XOR gate</p>
    <p>f (j) e (w</p>
    <p>a e, w</p>
    <p>b e ) = w</p>
    <p>a e  wbe</p>
    <p>AND gate</p>
    <p>f (j) e (w</p>
    <p>a e, w</p>
    <p>b e , w</p>
    <p>a e+1, w</p>
    <p>b e+1) = w</p>
    <p>a e w</p>
    <p>b e  wae+1w</p>
    <p>b e  wae wbe+1  rj</p>
    <p>e = 1, 2, 3</p>
    <p>a-th b-th</p>
    <p>j-th gate</p>
  </div>
  <div class="page">
    <p>Linear Decomposition:</p>
    <p>N= number of gates in the boolean circuit C</p>
    <p>Share(x) = (w01, w 0 2, w</p>
    <p>Rec(y1, y2, y3) = y1  y2  y3</p>
    <p>{f (j)1 , f (j) 2 , f</p>
    <p>(j) 3 }</p>
    <p>XOR gate</p>
    <p>f (j) e (w</p>
    <p>a e, w</p>
    <p>b e ) = w</p>
    <p>a e  wbe</p>
    <p>AND gate</p>
    <p>f (j) e (w</p>
    <p>a e, w</p>
    <p>b e , w</p>
    <p>a e+1, w</p>
    <p>b e+1) = w</p>
    <p>a e w</p>
    <p>b e  wae+1w</p>
    <p>b e  wae wbe+1  rj</p>
    <p>e = 1, 2, 3</p>
    <p>a-th b-th</p>
    <p>j-th gate</p>
  </div>
  <div class="page">
    <p>Linear Decomposition:</p>
    <p>N= number of gates in the boolean circuit C</p>
    <p>Share(x) = (w01, w 0 2, w</p>
    <p>Rec(y1, y2, y3) = y1  y2  y3</p>
    <p>{f (j)1 , f (j) 2 , f</p>
    <p>(j) 3 }</p>
    <p>XOR gate</p>
    <p>f (j) e (w</p>
    <p>a e, w</p>
    <p>b e ) = w</p>
    <p>a e  wbe</p>
    <p>AND gate</p>
    <p>f (j) e (w</p>
    <p>a e, w</p>
    <p>b e , w</p>
    <p>a e+1, w</p>
    <p>b e+1) = w</p>
    <p>a e w</p>
    <p>b e  wae+1w</p>
    <p>b e  wae wbe+1  rj</p>
    <p>e = 1, 2, 3</p>
    <p>a-th b-th</p>
    <p>j-th gate</p>
  </div>
  <div class="page">
    <p>Linear Decomposition:</p>
    <p>N= number of gates in the boolean circuit C</p>
    <p>Share(x) = (w01, w 0 2, w</p>
    <p>Rec(y1, y2, y3) = y1  y2  y3</p>
    <p>{f (j)1 , f (j) 2 , f</p>
    <p>(j) 3 }</p>
    <p>XOR gate</p>
    <p>f (j) e (w</p>
    <p>a e, w</p>
    <p>b e ) = w</p>
    <p>a e  wbe</p>
    <p>AND gate</p>
    <p>f (j) e (w</p>
    <p>a e, w</p>
    <p>b e , w</p>
    <p>a e+1, w</p>
    <p>b e+1) = w</p>
    <p>a e w</p>
    <p>b e  wae+1w</p>
    <p>b e  wae wbe+1  rj</p>
    <p>e = 1, 2, 3</p>
    <p>a-th b-th</p>
    <p>j-th gate</p>
  </div>
  <div class="page">
    <p>Experiments for ZKBoo</p>
    <p>SHA-1 SHA-256</p>
    <p>Serial Paral. Serial Paral.</p>
    <p>Prover (ms) 31.73 12.73 54.63 15.95</p>
    <p>Verifier (ms) 22.85 4.39 67.74 13.20</p>
    <p>Proof size (KB) 444.18 835.91</p>
    <p>Soundness error: 280</p>
    <p>(137 repetitions of ZKBoo with soundness 2/3)</p>
    <p>SHA-1  11680 AND gates SHA-256  25344 AND gates</p>
    <p>Implementation available at https://github.com/Sobuno/ZKBoo</p>
  </div>
  <div class="page">
    <p>Experiments for ZKBoo</p>
    <p>SHA-1 SHA-256</p>
    <p>Serial Paral. Serial Paral.</p>
    <p>Prover (ms) 31.73 12.73 54.63 15.95</p>
    <p>Verifier (ms) 22.85 4.39 67.74 13.20</p>
    <p>Proof size (KB) 444.18 835.91</p>
    <p>Soundness error: 280</p>
    <p>(137 repetitions of ZKBoo with soundness 2/3)</p>
    <p>SHA-1  11680 AND gates SHA-256  25344 AND gates</p>
    <p>Implementation available at https://github.com/Sobuno/ZKBoo</p>
  </div>
  <div class="page">
    <p>Recap:</p>
    <p>ZKBoo: a nearly practical ZK protocol that</p>
    <p>is non-interactive!</p>
    <p>is implemented for SHA-1 and SHA-256!</p>
    <p>has proving time much smaller than SNARGs !</p>
    <p>... has a really cute name!!! :)</p>
  </div>
  <div class="page">
    <p>Recap:</p>
    <p>ZKBoo: a nearly practical ZK protocol that</p>
    <p>is non-interactive!</p>
    <p>is implemented for SHA-1 and SHA-256!</p>
    <p>has proving time much smaller than SNARGs !</p>
    <p>... has a really cute name!!! :)</p>
  </div>
  <div class="page">
    <p>Recap:</p>
    <p>ZKBoo: a nearly practical ZK protocol that</p>
    <p>is non-interactive!</p>
    <p>is implemented for SHA-1 and SHA-256!</p>
    <p>has proving time much smaller than SNARGs !</p>
    <p>... has a really cute name!!! :)</p>
  </div>
  <div class="page">
    <p>Recap:</p>
    <p>ZKBoo: a nearly practical ZK protocol that</p>
    <p>is non-interactive!</p>
    <p>is implemented for SHA-1 and SHA-256!</p>
    <p>has proving time much smaller than SNARGs !</p>
    <p>... has a really cute name!!! :)</p>
  </div>
  <div class="page">
    <p>Recap:</p>
    <p>ZKBoo: a nearly practical ZK protocol that</p>
    <p>is non-interactive!</p>
    <p>is implemented for SHA-1 and SHA-256!</p>
    <p>has proving time much smaller than SNARGs !</p>
    <p>... has a really cute name!!! :)</p>
  </div>
  <div class="page">
    <p>What next?</p>
    <p>ZKBoo can work for any circuit C ! (both arithmetic or boolean)</p>
    <p>implement general-purpose ZKBoo;</p>
    <p>consider another specific circuit (eg C =AES) and define new ad-hoc decomposition;</p>
    <p>Thanks for the attention! Questions?</p>
  </div>
  <div class="page">
    <p>What next?</p>
    <p>ZKBoo can work for any circuit C ! (both arithmetic or boolean)</p>
    <p>implement general-purpose ZKBoo;</p>
    <p>consider another specific circuit (eg C =AES) and define new ad-hoc decomposition;</p>
    <p>Thanks for the attention! Questions?</p>
  </div>
  <div class="page">
    <p>What next?</p>
    <p>ZKBoo can work for any circuit C ! (both arithmetic or boolean)</p>
    <p>implement general-purpose ZKBoo;</p>
    <p>consider another specific circuit (eg C =AES) and define new ad-hoc decomposition;</p>
    <p>Thanks for the attention! Questions?</p>
  </div>
  <div class="page">
    <p>What next?</p>
    <p>ZKBoo can work for any circuit C ! (both arithmetic or boolean)</p>
    <p>implement general-purpose ZKBoo;</p>
    <p>consider another specific circuit (eg C =AES) and define new ad-hoc decomposition;</p>
    <p>Thanks for the attention! Questions?</p>
  </div>
</Presentation>
