<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>FlowRadar: A Better NetFlow For Data Centers</p>
    <p>Yuliang Li Rui Miao Changhoon Kim Minlan Yu</p>
  </div>
  <div class="page">
    <p>Flow coverage in data centers</p>
    <p>Flow coverage  Traffic monitoring needs to cover all the flows</p>
    <p>Transient loop/blackhole Fine-grained traffic analysis</p>
    <p>D is tr ib ut io n</p>
    <p>Size(Byte)</p>
  </div>
  <div class="page">
    <p>Temporal coverage in data centers</p>
    <p>Temporal coverage  Traffic monitoring needs millisecond-level flow information</p>
    <p># Lo ss</p>
    <p>Time (ms)</p>
    <p>Short-time scale Loss rate Timely attack detection</p>
    <p>DoS</p>
  </div>
  <div class="page">
    <p>Key insight: division of labor</p>
    <p>Goal: report counters for all flows in fine-grained time granularity</p>
    <p>Overhead at the collector</p>
    <p>Overhead at the switches</p>
    <p>NetFlow</p>
    <p>Mirroring</p>
    <p>Limited per-packet processing time Limited memory (10s of MB)</p>
    <p>Collector has limited bandwidth and storage</p>
    <p>Needs sampling</p>
  </div>
  <div class="page">
    <p>Key insight: division of labor</p>
    <p>Goal: report counters for all flows in fine-grained time granularity</p>
    <p>FlowRadar</p>
    <p>Use fixed operations per-pkt in switch</p>
    <p>Overhead at the collector</p>
    <p>Overhead at the switches</p>
    <p>NetFlow</p>
    <p>Mirroring</p>
    <p>Keep the memory usage small</p>
  </div>
  <div class="page">
    <p>FlowRadar architecture</p>
    <p>Correlate network-wide info to extract per-flow counter Collector</p>
    <p>Network</p>
    <p>Analyze Flow&amp;counter</p>
    <p>Each switch maintains a fast and efficient data structure for half-baked per-flow counter</p>
    <p>Periodic report</p>
  </div>
  <div class="page">
    <p>Challenge: handling collision?</p>
    <p>Handling hash collision is hard  Large hash table  high memory usage  Linked list/Cuckoo hashing multiple, non-constant memory accesses</p>
    <p>Flow a b c PacketCount</p>
    <p>Flow d</p>
    <p>d 1</p>
    <p>collision</p>
  </div>
  <div class="page">
    <p>Switch embraces collisions!</p>
    <p>Handling hash collision is hard  Large hash table  high memory usage  Linked list/Cuckoo hashing multiple, non-constant memory accesses</p>
    <p>Embrace the collision  Less memory and constant #accesses</p>
  </div>
  <div class="page">
    <p>FlowXor FlowCount PacketCount</p>
    <p>Switch embraces collisions!</p>
    <p>Embrace the collision: xor up all the flows  Less memory and constant #accesses</p>
    <p>FlowXor a ab bc bc a c FlowCount 1 2 2 2 1 1 PacketCount S(a) S(a)+S(b) S(b)+S(c) S(b)+S(c) S(a) S(c)</p>
    <p>Counting table</p>
    <p>flow a: S(a) Flow b: S(b) Flow c: S(c)a a b b c c</p>
    <p>[Invertible Bloom Lookup Table (arXiv 2011)]</p>
    <p>S(x): #packets in x</p>
  </div>
  <div class="page">
    <p>Counting table</p>
    <p>Switch embraces collisions!</p>
    <p>1. Check and update the flow filter  2. Update counting table  Packet from a new flow, update all fields  Subsequent packets update only PacketCount</p>
    <p>bloom filter: identify new flow</p>
    <p>FlowXor a ab bc bc a c FlowCount 1 2 2 2 1 1 PacketCount S(a) S(a)+S(b) S(b)+S(c) S(b)+S(c) S(a) S(c)</p>
    <p>+1+1 +1</p>
    <p>d</p>
    <p>dd d +1+1 +1</p>
    <p>+1+1 +1</p>
    <p>d</p>
    <p>Flow filter</p>
    <p>[Invertible Bloom Lookup Table (arXiv 2011)]</p>
    <p>Encoded flowset</p>
  </div>
  <div class="page">
    <p>Easy to implement in merchant silicon</p>
    <p>Switch data plane  Fixed operations in hardware  Small memory, 2.36MB for 100K flows</p>
    <p>Switch control plane  Control plane gets the small flowset every 10ms</p>
    <p>We implemented it using P4 Language.</p>
  </div>
  <div class="page">
    <p>Flow&amp;counter</p>
    <p>Correlate network wide info to extract per-flow counter</p>
    <p>Analyze</p>
    <p>FlowRadar architecture</p>
    <p>Each switch maintains a fast and efficient data structure for half-baked per-flow counter</p>
    <p>Collector</p>
    <p>Network</p>
    <p>Periodic report</p>
    <p>Encoded flowset</p>
    <p>Encoded flowset</p>
    <p>Encoded flowset</p>
    <p>Stage1.SingleDecode Stage2. Network-wide Decode</p>
    <p>FlowXor  FlowCount  PacketCount</p>
    <p>Bloom filter</p>
    <p>Counting table</p>
    <p>Flow filter</p>
  </div>
  <div class="page">
    <p>Stage1. SingleDecode</p>
    <p>FlowXor  FlowCount  PacketCount</p>
    <p>Bloom filter</p>
    <p>Counting table</p>
    <p>Flow filter Flow #packet a S(a)</p>
    <p>Input: a single encoded flowset Output: per-flow counters</p>
  </div>
  <div class="page">
    <p>Flow #packet a 5</p>
    <p>FlowXor a ab bcd bcd a cd FlowCount 1 2 3 3 1 2 PacketCount 5 12 13 13 5 6</p>
    <p>Flow filter</p>
    <p>Stage1. SingleDecode</p>
    <p>Find a pure cell: a cell with one flow  Remove the flow from all cells</p>
    <p>Pure cell</p>
    <p>Decoded:</p>
    <p>-1 -1 -1 -5 -5 -5</p>
  </div>
  <div class="page">
    <p>FlowXor 0 b bcd bcd 0 cd FlowCount 0 1 3 3 0 2 PacketCount 0 7 13 13 0 6</p>
    <p>Flow filter</p>
    <p>Stage1. SingleDecode</p>
    <p>Find a cell with one flow (pure cell)  Remove the flow from all cells  Create more pure cells</p>
    <p>Iterate until no pure cells</p>
    <p>Flow #packet a 5Decoded:</p>
  </div>
  <div class="page">
    <p>Stage1. SingleDecode</p>
    <p>FlowXor 0 0 cd cd 0 cd FlowCount 0 0 2 2 0 2 PacketCount 0 0 6 6 0 6</p>
    <p>Flow filter</p>
    <p>Flow #packet a 5 b 7</p>
    <p>Decoded:</p>
  </div>
  <div class="page">
    <p>Analyze Flow&amp;counter</p>
    <p>FlowRadar architecture</p>
    <p>Collector</p>
    <p>Network</p>
    <p>Stage1.SingleDecode Stage2. Network-wide Decode</p>
    <p>Periodic report</p>
    <p>Encoded flowset</p>
    <p>Encoded flowset</p>
    <p>Encoded flowset</p>
  </div>
  <div class="page">
    <p>Key insight: overlapping sets of flows</p>
    <p>The sets of flows overlap across hops  We can use the redundancy to decode more flows</p>
    <p>Use different hash functions across hops</p>
    <p>a b c d</p>
    <p>a b c d</p>
    <p>a ac d</p>
    <p>bc d</p>
    <p>ab c</p>
    <p>bd</p>
    <p>ad ac bc d</p>
    <p>ab c</p>
    <p>bd</p>
    <p>FlowXor</p>
    <p>FlowCount PktCount</p>
    <p>FlowXor</p>
    <p>FlowCount PktCount</p>
    <p>Use 5 cells to decode 4 flows 10</p>
    <p>Collector can leverage flowsets from all switches to decode more</p>
    <p>Provision memory based on avg(#flows), not max(#flows)  SingleDecode for normal case  Network-wide decoding for bursts of flows</p>
  </div>
  <div class="page">
    <p>Challenge 1: sets of flows not fully overlapped</p>
    <p>Flows from one switch may go to different next hops  One switch receive flow from multiple hops</p>
    <p>a b c d</p>
    <p>a</p>
    <p>e</p>
    <p>c d</p>
  </div>
  <div class="page">
    <p>Challenge 1 solution: use flow filter to check</p>
    <p>Generalize to network  No need for routing info  Incremental deployment</p>
    <p>Flow filter Flow filter</p>
    <p>a</p>
    <p>a b c d</p>
    <p>Decoded:</p>
    <p>a ec d</p>
    <p>ab cc d d e SingleDecode SingleDecodeRemove from the other</p>
  </div>
  <div class="page">
    <p>Challenge 2: counters are different across hops</p>
    <p>The counter of a flow may be different across hops  Some packets may get lost  On-the-fly packets</p>
  </div>
  <div class="page">
    <p>Challenge 2 solution: solve linear equations</p>
    <p>We got full list of flows  Combine with counting table  Construct and solve a linear equation system for each switch  Speed up by using counters properties to stop solver earlier</p>
    <p>a b c d</p>
    <p>FlowXor</p>
    <p>FlowCount PktCount</p>
    <p>Flow #pkt a 5 b 7 c 4 d 2</p>
  </div>
  <div class="page">
    <p>Analyze Flow&amp;counter</p>
    <p>FlowRadar architecture</p>
    <p>Collector</p>
    <p>Network</p>
    <p>Stage1.SingleDecode Stage2. Network-wide Decode Stage2.1</p>
    <p>FlowDecode Stage2.2</p>
    <p>CounterDecode</p>
    <p>Periodic report</p>
    <p>Encoded flowset</p>
    <p>Encoded flowset</p>
    <p>Encoded flowset</p>
  </div>
  <div class="page">
    <p>Analyze Flow&amp;counter</p>
    <p>Evaluations</p>
    <p>Collector</p>
    <p>Network</p>
    <p>Stage1.SingleDecode Stage2.1</p>
    <p>FlowDecode Stage2.2</p>
    <p>CounterDecode</p>
    <p>Periodic report</p>
    <p>Encoded flowset</p>
    <p>Encoded flowset</p>
    <p>Encoded flowsetMemory efficiency</p>
    <p>Bandwidth usage</p>
    <p>SingleDecode vs. Network-wide Decode</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Simulation of k=8 FatTree (80 switches, 128 hosts) in ns3  Config the memory base on avg(#flow),  when burst of flows happens, use network-wide decode</p>
    <p>The worst case is all switches are pushed to max(#flow)  Traffic: each switch has same number of flows, and thus same memory</p>
    <p>Each switch reports the flowset every 10 ms.</p>
  </div>
  <div class="page">
    <p>Memory efficiency</p>
    <p>#cell=#flow (Impractical)</p>
    <p>FlowRadar: 2.36MB</p>
    <p>FlowRadar: 24.8MB</p>
    <p>Log scale</p>
  </div>
  <div class="page">
    <p>Other results</p>
    <p>Bandwidth usage  Only 0.52% based on topology and traffic of Facebook data centers (sigcomm15)</p>
    <p>NetDecode improvement over SingleDecode  SingleDecode 100K flow, which takes 10ms  NetDecode 26.8% more flows with the same memory, which takes around 3 sec</p>
  </div>
  <div class="page">
    <p>Analyze Flow&amp;counter</p>
    <p>FlowRadar analyzer</p>
    <p>Collector</p>
    <p>Network</p>
    <p>Stage1.SingleDecode Stage2. Network-wide Decode</p>
    <p>Periodic report</p>
    <p>Encoded flowset</p>
    <p>Encoded flowset</p>
    <p>Encoded flowset</p>
  </div>
  <div class="page">
    <p>Analysis applications</p>
    <p>Flow coverage  Transient loop/blackhole  Error in match-action table  Fine-grained traffic analysis</p>
    <p>Temporal coverage  Short time-scale per-flow loss rate  ECMP load imbalance  Timely attack detection</p>
  </div>
  <div class="page">
    <p>Per-flow loss map: better temporal coverage</p>
    <p>Detect loss faster than NetFlow</p>
    <p>Switch 1</p>
    <p>Switch 2</p>
    <p>NetFlow detects loss</p>
    <p>FlowRadar detects loss</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Report counters for all flows in fine-grained time granularity  Fully leverage the capability of both the switches and the collector  Switch: fixed per-packet processing time, memory-efficient  Collector: Network-wide decoding</p>
    <p>FlowRadar</p>
    <p>Overhead at the collector</p>
    <p>Overhead at the switches</p>
    <p>NetFlow</p>
    <p>Mirroring</p>
  </div>
</Presentation>
