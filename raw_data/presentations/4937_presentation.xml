<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>The Linux Kernel: A Challenging Workload for Transactional Memory</p>
    <p>Hany E. Ramadan Christopher J. Rossbach</p>
    <p>Emmett Witchel</p>
    <p>Operating Systems &amp; Architecture Group University of Texas at Austin</p>
  </div>
  <div class="page">
    <p>Talk overview</p>
    <p>Why OSes are interesting workloads (1)</p>
    <p>Interrupts (2)  Transaction stacking (3)</p>
    <p>Configurable contention management (1)</p>
    <p>Other issues considered in the paper (1)</p>
    <p>Preliminary results (2)</p>
  </div>
  <div class="page">
    <p>Why OSes are interesting workloads</p>
    <p>Large concurrent program with interacting subsystems</p>
    <p>Complex, will benefit from ease of programming and maintainability</p>
    <p>Lack of OS scalability will harm application performance</p>
    <p>Diverse primitives for managing concurrency  spinlocks, semaphores, per-CPU variables,</p>
    <p>RCU, seqlocks, completions, mutexes</p>
  </div>
  <div class="page">
    <p>Interrupts</p>
    <p>Cause asynchronous transfer of control</p>
    <p>Do not cause a thread switch</p>
    <p>Are more frequent than thread switches</p>
    <p>May interrupt other interrupt handlers</p>
    <p>Question: How does a kernel which uses transactional memory handle interrupts?</p>
  </div>
  <div class="page">
    <p>Using transactions in interrupt handlers</p>
    <p>TX #1 { 0x10 }</p>
    <p>system_call()</p>
    <p>{</p>
    <p>XBEGIN</p>
    <p>modify 0x10</p>
    <p>XEND</p>
    <p>}</p>
    <p>intr_handler()</p>
    <p>{</p>
    <p>XBEGIN</p>
    <p>modify 0x30</p>
    <p>XEND</p>
    <p>}</p>
    <p>No tx in interrupts</p>
    <p>TX #1 { 0x10 }</p>
    <p>TX #2 { 0x30 }</p>
    <p>Interrupts abort active tx</p>
    <p>TX #1 { 0x10, 0x30 }</p>
    <p>Nest the transactions</p>
    <p>TX #1 { 0x10 }</p>
    <p>TX #2 { 0x30 }</p>
    <p>Multiple active transactions</p>
    <p>TX #1 { 0x10 }</p>
    <p>interrupt</p>
  </div>
  <div class="page">
    <p>Benefits of multiple active Tx</p>
    <p>Most flexibility for programmer  Interrupt handlers free to use Tx as necessary</p>
    <p>Aborts only when necessary  Interrupts are frequent</p>
    <p>Interrupt handlers stay independent</p>
    <p>Implies..</p>
    <p>Multiple transactions on a single thread !</p>
  </div>
  <div class="page">
    <p>Multiple transactions per thread</p>
    <p>Many transactions may be simultaneously active but at most one is running per thread  They can conflict with each other</p>
    <p>Independent (no nesting relation)</p>
    <p>Stacked transactions  Transactions complete in LIFO order</p>
    <p>Each thread has a logical stack of transactions</p>
    <p>Stacked transactions ideal for interrupts  Stack grows and shrinks as interrupts occur and</p>
    <p>complete</p>
  </div>
  <div class="page">
    <p>Multiple Tx Per Thread - Open questions</p>
    <p>What are the roles of HW and SW  ISA changes for managing multiple transactions  Efficient HW implementation</p>
    <p>Contention management must know about stacking  Stacked transactions can livelock</p>
    <p>Identifying other scenarios where this is useful  Non-interrupt cases?  Forms other than stacking?</p>
    <p>Program stack issues</p>
  </div>
  <div class="page">
    <p>Configurable Contention Management</p>
    <p>Contention can be heavy within OS  Transactions most effective when contention is</p>
    <p>rare</p>
    <p>OS contains programmer hints for contention management  RCU (read-change-update) favor readers  Seqlocks favor writers</p>
    <p>Hardware TM should accept programmer hints  XBEGIN takes contention mgmt parameter</p>
  </div>
  <div class="page">
    <p>Other issues considered in the paper</p>
    <p>Primitives for which transactional memory might not be suitable  Per-CPU data structures</p>
    <p>Blocking operations</p>
    <p>I/O in transactions  Big issue for Linux</p>
    <p>I/O is frequently performed while spinlock held</p>
    <p>May be possible to just allow it  TLB shootdown</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Implemented HTM as extensions to x86  With multiple active transactions</p>
    <p>Modified many spinlocks in Linux kernel (2.6.16.1) to use transactional memory</p>
    <p>Simulation environment  Simics 3.0.10 machine simulator</p>
    <p>16KB L1 ; 4MB L2 ; 256MB RAM</p>
    <p>1 cycle/instruction, 200 cycle/memory miss</p>
  </div>
  <div class="page">
    <p>Preliminary Results  We are booting Linux</p>
    <p>Transactions speed up boot by ~2%</p>
    <p>Tranactionalized Linux Unmodified Linux</p>
    <p>N o rm</p>
    <p>a li</p>
    <p>z e d</p>
    <p>R e la</p>
    <p>ti v e S</p>
    <p>p e e d</p>
    <p>u p</p>
    <p>Transactionalized Linux</p>
    <p>Unmodified Linux</p>
  </div>
  <div class="page">
    <p>Fin</p>
  </div>
</Presentation>
