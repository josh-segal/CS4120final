<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Janus Consolidating Concurrency Control and Consensus for Commits under Conflicts</p>
    <p>Shuai Mu, Lamont Nelson, Wyatt Lloyd, Jinyang Li</p>
    <p>New York University, University of Southern California</p>
  </div>
  <div class="page">
    <p>Paxos</p>
    <p>State of the Art for Distributed Transactions Layer Concurrency Control on top of Consensus</p>
    <p>California Texas New York</p>
    <p>Paxos</p>
    <p>Geo-replicate for fault tolerance Shard for scalability</p>
    <p>Transaction Protocol (e.g., 2PC)</p>
  </div>
  <div class="page">
    <p>a++</p>
    <p>b++</p>
    <p>Latency Limitation: Multiple Wide-Area Round Trips from Layering</p>
    <p>California Texas New York</p>
  </div>
  <div class="page">
    <p>a++ b++</p>
    <p>Throughput Limitation: Conflicts Cause Aborts</p>
    <p>a*=2 b*=2</p>
    <p>California Texas New York</p>
  </div>
  <div class="page">
    <p>Goals: Fewer Wide-Area Round Trips and Commits Under Conflicts</p>
    <p>Behavior under conflicts</p>
    <p>Spanner [OSDI12] ...</p>
    <p>Tapir [SOSP15] ...</p>
    <p>Janus</p>
    <p>Calvin [SIGMOD12] ...</p>
    <p>Best case wide-area RTTs</p>
    <p>2</p>
    <p>Aborts Commits</p>
  </div>
  <div class="page">
    <p>Establish Order Before Execution to Avoid Aborts  Designed for transactions with static read &amp; write-sets  Structure a transaction as a set of stored procedure pieces  Servers establishes consistent ordering for pieces before execution</p>
    <p>Challenge: Distributed ordering to avoid bottleneck</p>
    <p>a</p>
    <p>ba*=2</p>
    <p>a++</p>
    <p>b++</p>
    <p>b*=2</p>
    <p>a++</p>
    <p>b++</p>
    <p>a*=2</p>
    <p>b*=2</p>
    <p>a++</p>
    <p>b++</p>
    <p>b*=2</p>
    <p>a*=2a*=2</p>
    <p>b++</p>
  </div>
  <div class="page">
    <p>Transaction Replication</p>
    <p>Establish Order for Transactions and Replication Together to Commit in 1 Wide-area Roundtrip</p>
    <p>Consistent ordering for transaction and replication is the same!  Layering establishes the same order twice while Janus orders once</p>
    <p>Challenge: Fault tolerance for ordering</p>
    <p>a</p>
    <p>a++</p>
    <p>b++ a*=2 a'a++ Replica of a</p>
    <p>a++a++</p>
    <p>b++</p>
    <p>a++</p>
    <p>a*=2</p>
    <p>a++</p>
    <p>a*=2</p>
    <p>a*=2</p>
    <p>a*=2</p>
    <p>bb*=2 b++</p>
    <p>b*=2a*=2</p>
    <p>b*=2</p>
    <p>a*=2</p>
    <p>b*=2</p>
    <p>b++</p>
    <p>a*=2</p>
    <p>a++</p>
  </div>
  <div class="page">
    <p>Overview of the Janus Protocol</p>
  </div>
  <div class="page">
    <p>No Conflicts: Commit in 1 Wide-Area Round Trip</p>
  </div>
  <div class="page">
    <p>Conflicts: Commit in 2 Wide-Area RTT</p>
  </div>
  <div class="page">
    <p>Conflicts: Commit in 2 Wide-Area Round Trips</p>
  </div>
  <div class="page">
    <p>Conflicts: Commit in 2 Wide-Area Round Trip</p>
  </div>
  <div class="page">
    <p>Janus Achieves Fewer Wide-Area Round Trips and Commits Under Conflicts  No conflicts: commit in 1 wide-area round trip  Pre-accept sufficient to ensure same order under failures</p>
    <p>Conflicts: commit in 2 wide-area round trips  Accept phase replicates dependencies to ensure same order under failures</p>
  </div>
  <div class="page">
    <p>Janus Paper Includes Many More Details</p>
    <p>Full details of execution</p>
    <p>Quorum sizes</p>
    <p>Behavior under server failure</p>
    <p>Behavior under coordinator (client) failure</p>
    <p>Design extensions to handle dynamic read &amp; write sets</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Throughput under conflicts  Latency under conflicts  Overhead when there are no conflicts?  Baselines  2PL (2PC) layered on top of MultiPaxos  TAPIR [SOSP15]</p>
    <p>Testbed: EC2 (Oregon, Ireland, Seoul)</p>
    <p>https://github.com/NYU-NEWS/janus</p>
  </div>
  <div class="page">
    <p>Janus Commits under Conflicts for High Throughput</p>
    <p>Th ro ug hp</p>
    <p>ut -( ne</p>
    <p>w -o rd er /s )</p>
    <p># Clients</p>
    <p>Aborts due to conflicts at shards &amp; replicas</p>
    <p>Aborts due to conflicts at shards</p>
    <p>No aborts Janus</p>
    <p>Tapir</p>
    <p>TPC-C with 6 shards, 3-way geo-replicated (9 total servers), 1 warehouse per shard.</p>
  </div>
  <div class="page">
    <p>s)</p>
    <p># Clients</p>
    <p>Janus Commits under Conflicts for Low Latency</p>
    <p>Janus</p>
    <p>Tapir</p>
    <p>High latency due to retries after aborts</p>
    <p>TPC-C with 6 shards, 3-way geo-replicated (9 total servers), 1 warehouse per shard.</p>
  </div>
  <div class="page">
    <p>Small Throughput Overhead under Few Conflicts</p>
    <p>Th ro ug hp</p>
    <p>ut -( tx n/ s)</p>
    <p>Zipf coefficient</p>
    <p>Overhead from retries after aborts</p>
    <p>Overhead from accept phase + increased</p>
    <p>dependency tracking</p>
    <p>Janus</p>
    <p>Tapir</p>
    <p>Microbenchmark with 3 shards, 3-way replicated in a single data center (9 total servers).</p>
  </div>
  <div class="page">
    <p>Isolation Level 1 RTT Commit under Conflicts Janus [OSDI16] Strict-Serial   Tapir [SOSP15] Strict-Serial   Rep.Commit [VLDB13] Strict-Serial   Calvin [SIGMOD12] Strict-Serial   Spanner [OSDI12] Strict-Serial   MDCC [EuroSys13] ReadCommit*   COPS [SOSP11] Causal+   Eiger [NSDI13] Causal+</p>
    <p>Related Work</p>
    <p>EPaxos [SOSP13] Rococo [OSDI14]</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Two limitations for layered transaction protocols  Multiple wide-area round trips in the best case  Conflicts cause aborts</p>
    <p>Janus consolidates concurrency control and consensus  Ordering requirements are similar and can be combined!  Establishing a single ordering with dependency tracking enables:</p>
    <p>Committing in 1 wide-area round trip in the best case  Committing in 2 wide-area round trips under conflicts</p>
    <p>Evaluation  Small throughput overhead when there are no conflicts  Low latency and good throughput even with many conflicts</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Two limitations for layered transaction protocols  Multiple wide-area round trips in the best case  Conflicts cause aborts</p>
    <p>Janus consolidates concurrency control and consensus  Ordering requirements are similar and can be combined!  Establishing a single ordering with dependency tracking enables:</p>
    <p>Committing in 1 wide-area round trip in the best case  Committing in 2 wide-area round trips under conflicts</p>
    <p>Evaluation  Small throughput overhead when there are no conflicts  Low latency and good throughput even with many conflicts</p>
  </div>
</Presentation>
