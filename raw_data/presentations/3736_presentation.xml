<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Multiple-Source Multiple-Sink Maximum Flow in Directed Planar</p>
    <p>Graphs in Near-Linear Time</p>
    <p>Shay Mozes</p>
    <p>joint work with Cora Borradaile, Philip Klein, Yahav Nussbaum and Christian Wulff-Nilsen</p>
  </div>
  <div class="page">
    <p>Planar Graphs</p>
  </div>
  <div class="page">
    <p>Planar Graphs</p>
  </div>
  <div class="page">
    <p>Planar Graphs</p>
  </div>
  <div class="page">
    <p>Planar Graphs</p>
    <p>arise in many applications</p>
  </div>
  <div class="page">
    <p>Planar Graphs</p>
    <p>arise in many applications  admit faster algorithms</p>
  </div>
  <div class="page">
    <p>Planar Graphs</p>
    <p>arise in many applications  admit faster algorithms  interesting structural properties</p>
  </div>
  <div class="page">
    <p>Maximum Flow</p>
    <p>input: a graph G with arc capacities and nodes s,t</p>
    <p>output: an assignment of flow to arcs such that:</p>
    <p>conservation at non-terminals  respects capacity at all arcs  maximizes the amount of flow entering t</p>
    <p>s</p>
    <p>t</p>
  </div>
  <div class="page">
    <p>Maximum Flow</p>
    <p>input: a graph G with arc capacities and nodes s,t</p>
    <p>output: an assignment of flow to arcs such that:</p>
    <p>conservation at non-terminals  respects capacity at all arcs  maximizes the amount of flow entering t</p>
    <p>s</p>
    <p>t</p>
  </div>
  <div class="page">
    <p>Main Result</p>
    <p>multiple-source, multiple-sink maximum flow in directed planar</p>
    <p>graphs in O(n log3n) time.</p>
  </div>
  <div class="page">
    <p>Applications Multiple Sources and Sinks</p>
    <p>transportation networks (Soviet railroad system)</p>
    <p>computer vision - image segmentation, restoration, stereo, object recognition, texture synthesis (grid)</p>
    <p>maximum bipartite matching</p>
  </div>
  <div class="page">
    <p>Reduction to Single Source and Sink</p>
  </div>
  <div class="page">
    <p>Reduction to Single Source and Sink</p>
  </div>
  <div class="page">
    <p>Reduction to Single Source and Sink</p>
    <p>reduction does not preserve planarity  [Miller, Naor 91] - sources and sinks on a small</p>
    <p>number of faces</p>
  </div>
  <div class="page">
    <p>Known Results for Single Source/Sink</p>
    <p>general graphs:  (nm) - many results (blocking flow, push relabel)  O(m3/2 log(n2/m) logU ) - [Goldberg, Rao 97]</p>
    <p>directed planar graphs:  O(n) - s and t on the same face [Hassin 81+</p>
    <p>Henzinger et al. 94]  O(n log n) [Borradaile, Klein 06]</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>a few tools and definitions  high-level description of recursive algorithm  main ingredients for near-linear time</p>
  </div>
  <div class="page">
    <p>Multiple Sinks on a path</p>
  </div>
  <div class="page">
    <p>Multiple Sinks on a path</p>
    <p>reduces to the single sink case connect all sinks with infinite-capacity edges</p>
    <p>preserves planarity!</p>
  </div>
  <div class="page">
    <p>The Residual Graph</p>
    <p>given flow f in graph G with capacities c(a), the residual graph Gf has same nodes and arcs as G and capacities cf (a) = c(a) - f(a)</p>
    <p>a path P is residual if every arc of P has positive capacity</p>
  </div>
  <div class="page">
    <p>The Residual Graph</p>
    <p>given flow f in graph G with capacities c(a), the residual graph Gf has same nodes and arcs as G and capacities cf (a) = c(a) - f(a)</p>
    <p>a path P is residual if every arc of P has positive capacity</p>
  </div>
  <div class="page">
    <p>s1 s2</p>
    <p>t</p>
    <p>a flow f is maximum iff there are no residual paths from sources to sinks in Gf</p>
  </div>
  <div class="page">
    <p>s1 s2</p>
    <p>t</p>
    <p>a flow f is maximum iff there are no residual paths from sources to sinks in Gf</p>
  </div>
  <div class="page">
    <p>s1 s2</p>
    <p>t</p>
    <p>a flow f is maximum iff there are no residual paths from sources to sinks in Gf</p>
  </div>
  <div class="page">
    <p>Flow Zoo  excess flow at node v is the difference between amount of flow</p>
    <p>entering v and leaving v conservation  excess flow is zero</p>
    <p>pseudoflow: arc capacities are respected (conservation may not)  feasible flow: pseudoflow that obeys conservation everywhere</p>
    <p>except sources and sinks</p>
    <p>circulation: pseudoflow that obeys conservation everywhere (even at sources and sinks)</p>
    <p>given a pseudoflow, it is possible to push back all positive/ negative excess flow to/from its origin in linear time</p>
  </div>
  <div class="page">
    <p>s1 s2</p>
    <p>t</p>
    <p>think of sources as having excess flow + think of sinks as having excess flow -</p>
    <p>a pseudoflow corresponds to a maximum flow iff there are no residual paths from + to - in the residual graph</p>
  </div>
  <div class="page">
    <p>think of sources as having excess flow + think of sinks as having excess flow -</p>
    <p>a pseudoflow corresponds to a maximum flow iff there are no residual paths from + to - in the residual graph</p>
    <p>s1 s2</p>
    <p>t</p>
  </div>
  <div class="page">
    <p>think of sources as having excess flow + think of sinks as having excess flow -</p>
    <p>a pseudoflow corresponds to a maximum flow iff there are no residual paths from + to - in the residual graph</p>
    <p>s1 s2</p>
    <p>t</p>
    <p>-1 0 0</p>
  </div>
  <div class="page">
    <p>Cycle Separators [Miller 86]</p>
    <p>simple cycle in a triangulated 2-connected planar graph</p>
    <p>balanced - between n/3 and 2n/3 nodes on each side</p>
    <p>small: consists of O(n) nodes</p>
    <p>can be found in O(n) time</p>
    <p>n/2</p>
    <p>! n</p>
    <p>n/2</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>a few tools and definitions  high-level description of recursive algorithm  main ingredients for near-linear time</p>
  </div>
  <div class="page">
    <p>Recursion, First try</p>
    <p>s 3</p>
    <p>s 2</p>
    <p>s 1</p>
    <p>t 3</p>
    <p>t 2</p>
    <p>t 1</p>
  </div>
  <div class="page">
    <p>s 3</p>
    <p>s 2</p>
    <p>s 1</p>
    <p>t 3</p>
    <p>t 2</p>
    <p>t 1</p>
    <p>Recursion, First try</p>
    <p>find separator</p>
  </div>
  <div class="page">
    <p>s 3</p>
    <p>s 2</p>
    <p>s 1</p>
    <p>t 3</p>
    <p>t 2</p>
    <p>t 1</p>
    <p>Recursion, First try</p>
    <p>find separator  find maximum MSMS flow</p>
    <p>inside and outsider recursively</p>
  </div>
  <div class="page">
    <p>s 3</p>
    <p>s 2</p>
    <p>s 1</p>
    <p>t 3</p>
    <p>t 2</p>
    <p>t 1</p>
    <p>Recursion, First try</p>
    <p>find separator  find maximum MSMS flow</p>
    <p>inside and outsider recursively</p>
    <p>no residual paths from sources to sinks in each subgraph</p>
  </div>
  <div class="page">
    <p>s 3</p>
    <p>s 2</p>
    <p>s 1</p>
    <p>t 3</p>
    <p>t 2</p>
    <p>t 1</p>
    <p>Recursion, Second try</p>
  </div>
  <div class="page">
    <p>s 3</p>
    <p>s 2</p>
    <p>s 1</p>
    <p>t 3</p>
    <p>t 2</p>
    <p>t 1</p>
    <p>Recursion, Second try</p>
    <p>find separator</p>
  </div>
  <div class="page">
    <p>s 3</p>
    <p>s 2</p>
    <p>s 1</p>
    <p>t 3</p>
    <p>t 2</p>
    <p>t 1</p>
    <p>Recursion, Second try</p>
    <p>find separator  recursive problem (almost):</p>
    <p>eliminate residual paths:  from sources to sinks  from sources to separator  from separator to sinks</p>
  </div>
  <div class="page">
    <p>+</p>
    <p>+ s3</p>
    <p>s 2</p>
    <p>s 1</p>
    <p>t 3</p>
    <p>t 2</p>
    <p>t 1</p>
    <p>Recursion, Second try</p>
    <p>find separator  recursive problem (almost):</p>
    <p>eliminate residual paths  from sources to sinks  from sources to separator  from separator to sinks</p>
  </div>
  <div class="page">
    <p>+</p>
    <p>- s3</p>
    <p>s 2</p>
    <p>s 1</p>
    <p>t 3</p>
    <p>t 2</p>
    <p>t 1</p>
    <p>Recursion, Second try</p>
    <p>find separator  recursive problem (almost):</p>
    <p>eliminate residual paths  from sources to sinks  from sources to separator  from separator to sinks</p>
  </div>
  <div class="page">
    <p>+</p>
    <p>- s3</p>
    <p>s 2</p>
    <p>s 1</p>
    <p>t 3</p>
    <p>t 2</p>
    <p>t 1</p>
    <p>Recursion, Second try</p>
    <p>find separator  recursive problem (almost):</p>
    <p>eliminate residual paths  from sources to sinks  from sources to separator  from separator to sinks</p>
    <p>eliminate residual paths from + to - on separator</p>
  </div>
  <div class="page">
    <p>+</p>
    <p>- s3</p>
    <p>s 2</p>
    <p>s 1</p>
    <p>t 3</p>
    <p>t 2</p>
    <p>t 1</p>
    <p>Recursion, Second try</p>
    <p>find separator  recursive problem (almost):</p>
    <p>eliminate residual paths  from sources to sinks  from sources to separator  from separator to sinks</p>
    <p>eliminate residual paths from + to - on separator</p>
  </div>
  <div class="page">
    <p>+</p>
    <p>- s3</p>
    <p>s 2</p>
    <p>s 1</p>
    <p>t 3</p>
    <p>t 2</p>
    <p>t 1</p>
    <p>Recursion, Second try</p>
    <p>find separator  recursive problem (almost):</p>
    <p>eliminate residual paths  from sources to sinks  from sources to separator  from separator to sinks</p>
    <p>eliminate residual paths from + to - on separator</p>
    <p>return flow from + to sources and from sinks to</p>
  </div>
  <div class="page">
    <p>s 3</p>
    <p>s 2</p>
    <p>s 1</p>
    <p>t 3</p>
    <p>t 2</p>
    <p>t 1</p>
    <p>Recursion, Second try</p>
    <p>find separator  recursive problem (almost):</p>
    <p>eliminate residual paths  from sources to sinks  from sources to separator  from separator to sinks</p>
    <p>eliminate residual paths from + to - on separator</p>
    <p>return flow from + to sources and from sinks to</p>
  </div>
  <div class="page">
    <p>s 3</p>
    <p>s 2</p>
    <p>s 1</p>
    <p>t 3</p>
    <p>t 2</p>
    <p>t 1</p>
    <p>Recursion, Second try</p>
    <p>find separator  recursive problem (almost):</p>
    <p>eliminate residual paths  from sources to sinks  from sources to separator  from separator to sinks</p>
    <p>eliminate residual paths from + to - on separator</p>
    <p>return flow from + to sources and from sinks to</p>
  </div>
  <div class="page">
    <p>Fixing the Separator eliminate residual paths from + to - on separator</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
  </div>
  <div class="page">
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>Fixing the Separator eliminate residual paths from + to - on separator</p>
    <p>make capacity of separator edges infinite</p>
    <p>handle nodes one by one:</p>
  </div>
  <div class="page">
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>Fixing the Separator eliminate residual paths from + to - on separator</p>
    <p>make capacity of separator edges infinite</p>
    <p>handle nodes one by one:</p>
    <p>reduce capacity of incident edges back to original</p>
  </div>
  <div class="page">
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>Fixing the Separator eliminate residual paths from + to - on separator</p>
    <p>make capacity of separator edges infinite</p>
    <p>handle nodes one by one:</p>
    <p>reduce capacity of incident edges back to original</p>
    <p>push + excess to neighbor using max-flow in residual graph</p>
  </div>
  <div class="page">
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>Fixing the Separator eliminate residual paths from + to - on separator</p>
    <p>make capacity of separator edges infinite</p>
    <p>handle nodes one by one:</p>
    <p>reduce capacity of incident edges back to original</p>
    <p>push + excess to neighbor  push - excess from neighbor using</p>
    <p>max-flow in residual graph</p>
  </div>
  <div class="page">
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>Fixing the Separator eliminate residual paths from + to - on separator</p>
    <p>make capacity of separator edges infinite</p>
    <p>handle nodes one by one:</p>
    <p>reduce capacity of incident edges back to original</p>
    <p>push + excess to neighbor  push - excess from neighbor using</p>
    <p>max-flow in residual graph</p>
  </div>
  <div class="page">
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>Fixing the Separator eliminate residual paths from + to - on separator</p>
    <p>make capacity of separator edges infinite</p>
    <p>handle nodes one by one:</p>
    <p>reduce capacity of incident edges back to original</p>
    <p>push + excess to neighbor  push - excess from neighbor</p>
    <p>running time:</p>
    <p>separator nodes time for max-flow between neighbors [Hassin + Henzinger et al.]</p>
    <p>O( ! n)  O(n) = O(n3/2)</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>a few tools and definitions  high-level description of recursive algorithm  main ingredients for near-linear time</p>
  </div>
  <div class="page">
    <p>bottleneck is fixing step which consists of max-flow computations in residual graph between neighbor nodes on a simple cycle</p>
    <p>can represent the flow compactly: flow is in graph with edges representation has size maintain flow only on separator edges flow elsewhere represented implicitly</p>
    <p>can perform each max-flow computation in instead of</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>Near Linear Time O(</p>
    <p>! n)</p>
    <p>O( ! n log2 n) O(n)</p>
    <p>O(n) O(</p>
    <p>! n)</p>
  </div>
  <div class="page">
    <p>Planar Duality</p>
  </div>
  <div class="page">
    <p>Planar Duality</p>
  </div>
  <div class="page">
    <p>Planar Duality</p>
  </div>
  <div class="page">
    <p>s</p>
    <p>t</p>
    <p>to compute max flow from s to t:</p>
    <p>Max-Flow between Neighbors [Hassin 1981]</p>
  </div>
  <div class="page">
    <p>Max-Flow between Neighbors [Hassin 1981]</p>
    <p>to compute max flow from s to t:</p>
    <p>make capacity of arc ts infinite</p>
    <p>s</p>
    <p>t</p>
  </div>
  <div class="page">
    <p>Max-Flow between Neighbors [Hassin 1981]</p>
    <p>s</p>
    <p>t</p>
    <p>! 0</p>
    <p>to compute max flow from s to t:</p>
    <p>make capacity of arc ts infinite  0 = the face to the left of arc ts</p>
  </div>
  <div class="page">
    <p>Max-Flow between Neighbors [Hassin 1981]</p>
    <p>s</p>
    <p>t</p>
    <p>! 0</p>
    <p>to compute max flow from s to t:</p>
    <p>make capacity of arc ts infinite  0 = the face to the left of arc ts  consider capacity of an arc in the</p>
    <p>primal as its length in the dual</p>
  </div>
  <div class="page">
    <p>Max-Flow between Neighbors [Hassin 1981]</p>
    <p>s</p>
    <p>t</p>
    <p>to compute max flow from s to t:</p>
    <p>make capacity of arc ts infinite  0 = the face to the left of arc ts  consider capacity of an arc in the</p>
    <p>primal as its length in the dual  compute:</p>
    <p>d() = distance of  from 0 in dual</p>
  </div>
  <div class="page">
    <p>Max-Flow between Neighbors [Hassin 1981]</p>
    <p>s</p>
    <p>t</p>
    <p>to compute max flow from s to t:</p>
    <p>make capacity of arc ts infinite  0 = the face to the left of arc ts  consider capacity of an arc in the</p>
    <p>primal as its length in the dual  compute:</p>
    <p>d() = distance of  from 0 in dual  define flow on arc a by: (a) = d(face right of a) - d(face left of a)  is a feasible circulation that maximizes the flow on arc ts</p>
  </div>
  <div class="page">
    <p>is a feasible circulation</p>
  </div>
  <div class="page">
    <p>is a feasible circulation conservation: (a) = d(face right of a) - d(face left of a) flows on arcs outgoing from a node cancel to zero</p>
  </div>
  <div class="page">
    <p>feasibility guaranteed by shortest paths inequality:</p>
    <p>is a feasible circulation conservation: (a) = d(face right of a) - d(face left of a) flows on arcs outgoing from a node cancel to zero</p>
  </div>
  <div class="page">
    <p>feasibility guaranteed by shortest paths inequality: d(head of dual of a)  d(tail of dual of a) + length(dual of a)</p>
    <p>is a feasible circulation conservation: (a) = d(face right of a) - d(face left of a) flows on arcs outgoing from a node cancel to zero</p>
  </div>
  <div class="page">
    <p>feasibility guaranteed by shortest paths inequality: d(head of dual of a)  d(tail of dual of a) + length(dual of a) d(head of dual of a) - d(tail of dual of a)  capacity of a</p>
    <p>is a feasible circulation conservation: (a) = d(face right of a) - d(face left of a) flows on arcs outgoing from a node cancel to zero</p>
  </div>
  <div class="page">
    <p>feasibility guaranteed by shortest paths inequality: d(head of dual of a)  d(tail of dual of a) + length(dual of a) d(head of dual of a) - d(tail of dual of a)  capacity of a</p>
    <p>(a) = d(face right of a) - d(face left of a) = d(head of dual of a) - d(tail of dual of a)  capacity of a</p>
    <p>is a feasible circulation conservation: (a) = d(face right of a) - d(face left of a) flows on arcs outgoing from a node cancel to zero</p>
  </div>
  <div class="page">
    <p>Max-Flow between Neighbors [Hassin 1981]</p>
    <p>s</p>
    <p>t</p>
    <p>to compute max flow from s to t:</p>
    <p>make capacity of arc ts infinite  0 = the face to the left of arc ts  consider capacity of an arc in the</p>
    <p>primal as its length in the dual  compute:</p>
    <p>d() = distance of  from 0 in dual  define flow on arc a by: (a) = d(face right of a) - d(face left of a)  is a feasible circulation that maximizes the flow on arc ts</p>
  </div>
  <div class="page">
    <p>Max-Flow between Neighbors [Hassin 1981]</p>
    <p>s</p>
    <p>t</p>
    <p>to compute max flow from s to t:</p>
    <p>make capacity of arc ts infinite  0 = the face to the left of arc ts  consider capacity of an arc in the</p>
    <p>primal as its length in the dual  compute:</p>
    <p>d() = distance of  from 0 in dual  define flow on arc a by: (a) = d(face right of a) - d(face left of a)  is a feasible circulation that maximizes the flow on arc ts</p>
    <p>dont push flow on ts</p>
  </div>
  <div class="page">
    <p>s</p>
    <p>tFlow Representation 1/4</p>
  </div>
  <div class="page">
    <p>s</p>
    <p>t</p>
    <p>flow between endpoints of arc ai of C can be represented by:</p>
    <p>Flow Representation 1/4</p>
  </div>
  <div class="page">
    <p>s</p>
    <p>t</p>
    <p>flow between endpoints of arc ai of C can be represented by:  face labels di() for each face</p>
    <p>Flow Representation 1/4</p>
  </div>
  <div class="page">
    <p>s</p>
    <p>t</p>
    <p>flow between endpoints of arc ai of C can be represented by:  face labels di() for each face   flow on ai</p>
    <p>Flow Representation 1/4</p>
  </div>
  <div class="page">
    <p>flow between endpoints of arc ai of C can be represented by:  face labels di() for each face   flow on ai</p>
    <p>Flow Representation 1/4</p>
  </div>
  <div class="page">
    <p>flow between endpoints of arc ai of C can be represented by:  face labels di() for each face   flow on ai</p>
    <p>to represent sum of flows for all iterations of fixing step:</p>
    <p>Flow Representation 1/4</p>
  </div>
  <div class="page">
    <p>flow between endpoints of arc ai of C can be represented by:  face labels di() for each face   flow on ai</p>
    <p>to represent sum of flows for all iterations of fixing step:  accumulate face labels over all iterations (linearity)</p>
    <p>Flow Representation 1/4</p>
  </div>
  <div class="page">
    <p>flow between endpoints of arc ai of C can be represented by:  face labels di() for each face   flow on ai</p>
    <p>to represent sum of flows for all iterations of fixing step:  accumulate face labels over all iterations (linearity)  explicitly store flow on arcs of separator C</p>
    <p>Flow Representation 1/4</p>
  </div>
  <div class="page">
    <p>flow between endpoints of arc ai of C can be represented by:  face labels di() for each face   flow on ai</p>
    <p>to represent sum of flows for all iterations of fixing step:  accumulate face labels over all iterations (linearity)  explicitly store flow on arcs of separator C</p>
    <p>will show it suffices to store face labels for just the faces adjacent to separator C</p>
    <p>Flow Representation 1/4</p>
  </div>
  <div class="page">
    <p>f0 - flow after recursive calls f - flow on Cs arcs up to current iteration d - accumulated face labels up to current iteration</p>
    <p>Flow Representation 2/4</p>
  </div>
  <div class="page">
    <p>f0 - flow after recursive calls f - flow on Cs arcs up to current iteration d - accumulated face labels up to current iteration</p>
    <p>Flow Representation 2/4</p>
  </div>
  <div class="page">
    <p>f0 - flow after recursive calls f - flow on Cs arcs up to current iteration d - accumulated face labels up to current iteration</p>
    <p>for an arc a not on C, flow is: f0(a) + d(face right of a) - d(face left of a)</p>
    <p>Flow Representation 2/4</p>
  </div>
  <div class="page">
    <p>f0 - flow after recursive calls f - flow on Cs arcs up to current iteration d - accumulated face labels up to current iteration</p>
    <p>for an arc a not on C, flow is: f0(a) + d(face right of a) - d(face left of a)</p>
    <p>residual capacity of a is: c(a) - f0(a) - d(face right of a) + d(face left of a)</p>
    <p>Flow Representation 2/4</p>
  </div>
  <div class="page">
    <p>f0 - flow after recursive calls f - flow on Cs arcs up to current iteration d - accumulated face labels up to current iteration</p>
    <p>for an arc a not on C, flow is: f0(a) + d(face right of a) - d(face left of a)</p>
    <p>residual capacity of a is: c(a) - f0(a) - d(face right of a) + d(face left of a)</p>
    <p>length of dual of a is: c(a) - f0(a) - d(head of dual of a) + d(tail of dual of a)</p>
    <p>Flow Representation 2/4</p>
  </div>
  <div class="page">
    <p>length of dual of a is: c(a) - f0(a) - d(head of dual of a) + d(tail of dual of a)</p>
    <p>Flow Representation 3/4</p>
  </div>
  <div class="page">
    <p>length of dual of a is: c(a) - f0(a) - d(head of dual of a) + d(tail of dual of a)</p>
    <p>Flow Representation 3/4</p>
  </div>
  <div class="page">
    <p>length of dual of a is: c(a) - f0(a) - d(head of dual of a) + d(tail of dual of a)</p>
    <p>length of any dual path P that does not use dual arcs of C is:  c(a) - f0(a) - d(head of dual of a) + d(tail of dual of a) = d(end of P) - d(start of P) + c(a) - f0(a)</p>
    <p>Flow Representation 3/4</p>
  </div>
  <div class="page">
    <p>length of dual of a is: c(a) - f0(a) - d(head of dual of a) + d(tail of dual of a)</p>
    <p>length of any dual path P that does not use dual arcs of C is:  c(a) - f0(a) - d(head of dual of a) + d(tail of dual of a) = d(end of P) - d(start of P) + c(a) - f0(a)</p>
    <p>ignoring arcs of C, shortest paths are independent of d note: length of shortest path does change by d(end of P) - d(start of P)</p>
    <p>Flow Representation 3/4</p>
  </div>
  <div class="page">
    <p>Flow Representation 4/4</p>
    <p>X = set of faces adjacent to separator C = set of endpoints of dual arcs of C</p>
  </div>
  <div class="page">
    <p>Flow Representation 4/4</p>
  </div>
  <div class="page">
    <p>Flow Representation 4/4</p>
    <p>X = set of faces adjacent to separator C = set of endpoints of dual arcs of C</p>
    <p>H - dual graph without dual arcs of C</p>
  </div>
  <div class="page">
    <p>Flow Representation 4/4</p>
    <p>X = set of faces adjacent to separator C = set of endpoints of dual arcs of C</p>
    <p>H - dual graph without dual arcs of C  any shortest path in dual graph can be decomposed into:</p>
    <p>- shortest paths in H - dual arcs of C</p>
  </div>
  <div class="page">
    <p>Flow Representation 4/4</p>
    <p>X = set of faces adjacent to separator C = set of endpoints of dual arcs of C</p>
    <p>H - dual graph without dual arcs of C  any shortest path in dual graph can be decomposed into:</p>
    <p>- shortest paths in H - dual arcs of C</p>
    <p>precompute all-pair shortest paths between nodes of X in H - can be done in O(n log n) time [Klein SODA05] - these shortest paths do not change - for x,y  X, length of x-to-y path changes by d(x) - d(y)</p>
  </div>
  <div class="page">
    <p>Flow Representation 4/4</p>
    <p>X = set of faces adjacent to separator C = set of endpoints of dual arcs of C</p>
    <p>H - dual graph without dual arcs of C  any shortest path in dual graph can be decomposed into:</p>
    <p>- shortest paths in H - dual arcs of C</p>
    <p>precompute all-pair shortest paths between nodes of X in H - can be done in O(n log n) time [Klein SODA05] - these shortest paths do not change - for x,y  X, length of x-to-y path changes by d(x) - d(y)</p>
    <p>suffices to maintain face labels for X and explicit flow for C</p>
  </div>
  <div class="page">
    <p>Efficient Implementation  precompute all-pair shortest paths</p>
    <p>between nodes of X in H O(n) pairs  maintain:</p>
    <p>- face labels for X faces - explicit flow for C arcs</p>
    <p>can implement Dijkstras algorithm with this representation in time using a modification of a data-structure of Fakcharoenphol and Rao [FOCS01]</p>
    <p>O( ! n)</p>
    <p>O( ! n)</p>
    <p>O( ! n log2 n)</p>
    <p>running time:</p>
    <p>separator nodes time for max-flow between neighbors using compact representation</p>
    <p>O( ! n)  O(</p>
    <p>! n log2 n) = O(n log2 n)</p>
  </div>
  <div class="page">
    <p>Back to the Entire Graph</p>
    <p>with compact representation we have: - explicit flow f on all arcs of C - accumulated face labels only for faces adjacent to C</p>
    <p>need to extend face labels to all faces  can be done using one more shortest-path computation in</p>
    <p>the dual which takes linear time</p>
  </div>
  <div class="page">
    <p>s 3</p>
    <p>s 2</p>
    <p>s 1</p>
    <p>t 3</p>
    <p>t 2</p>
    <p>t 1</p>
    <p>Recall High-Level Algorithm  find separator  recursive problem (almost):</p>
    <p>eliminate residual paths  from sources to sinks  from sources to separator  from separator to sinks</p>
    <p>eliminate residual paths from + to - on separator</p>
    <p>return flow from + to sources and from sinks to running time: O(n log3n)</p>
  </div>
  <div class="page">
    <p>Open Questions/Directions  can running time be improved?</p>
    <p>(bottleneck is Fakcharoenphol and Raos data structure and its modification)</p>
    <p>can this technique be adapted to bounded-genus graphs?  implementation</p>
  </div>
  <div class="page">
    <p>Thank You!</p>
    <p>s1 s2</p>
    <p>t</p>
    <p>-1</p>
    <p>s 3</p>
    <p>s 2</p>
    <p>s 1</p>
    <p>t 3</p>
    <p>t 2</p>
    <p>t 1</p>
  </div>
</Presentation>
