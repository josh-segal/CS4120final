<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>PTask: Operating System Abstractions to Manage</p>
    <p>GPUs as Compute Devices Chris Rossbach, Jon Currey, Microsoft Research</p>
    <p>Mark Silberstein, Technion Baishakhi Ray, Emmett Witchel, UT Austin</p>
    <p>SOSP October 25, 2011</p>
  </div>
  <div class="page">
    <p>There are lots of GPUs  3 of top 5 supercomputers use GPUs  In all new PCs, smart phones, tablets  Great for gaming and HPC/batch  Unusable in other application domains</p>
    <p>GPU programming challenges  GPU+main memory disjoint  Treated as I/O device by OS</p>
    <p>Motivation</p>
    <p>PTask SOSP 2011 2</p>
  </div>
  <div class="page">
    <p>There are lots of GPUs  3 of top 5 supercomputers use GPUs  In all new PCs, smart phones tablets  Great for gaming and HPC/batch  Unusable in other application domains</p>
    <p>GPU programing challenges  GPU+main memory disjoint  Treated as I/O device by OS</p>
    <p>Motivation</p>
    <p>These two things are related: We need OS abstractions</p>
    <p>PTask SOSP 2011 3</p>
  </div>
  <div class="page">
    <p>The case for OS support  PTask: Dataflow for GPUs  Evaluation  Related Work  Conclusion</p>
    <p>Outline</p>
    <p>PTask SOSP 2011 4</p>
  </div>
  <div class="page">
    <p>Traditional OS-Level abstractions</p>
    <p>programmervisible interface</p>
    <p>OS-level abstractions</p>
    <p>Hardware interface</p>
    <p>PTask SOSP 2011 5</p>
  </div>
  <div class="page">
    <p>DirectX/CUDA/OpenCL Runtime</p>
    <p>Language Integration</p>
    <p>Shaders/ Kernels</p>
    <p>GPGPU APIs</p>
    <p>GPU Abstractions</p>
    <p>programmervisible interface</p>
    <p>PTask SOSP 2011 6</p>
  </div>
  <div class="page">
    <p>CPU-bound processes hurt GPUs</p>
    <p>Image-convolution in CUDA  Windows 7 x64 8GB RAM  Intel Core 2 Quad 2.66GHz  nVidia GeForce GT230</p>
    <p>invocations per second</p>
    <p>Higher is better</p>
    <p>no CPU load high CPU load 0</p>
    <p>GPU benchmark throughput</p>
    <p>CPU scheduler and GPU scheduler not integrated!</p>
    <p>PTask SOSP 2011 7</p>
  </div>
  <div class="page">
    <p>GPU-bound processes hurt CPUs</p>
    <p>Windows 7 x64 8GB RAM  Intel Core 2 Quad 2.66GHz  nVidia GeForce GT230</p>
    <p>Flatter lines Are better</p>
    <p>OS cannot prioritize cursor updates  WDDM + DWM + CUDA == dysfunction</p>
    <p>PTask SOSP 2011 8</p>
  </div>
  <div class="page">
    <p>Composition: Gestural Interface</p>
    <p>capture</p>
    <p>filterxform</p>
    <p>Hand events</p>
    <p>Raw images</p>
    <p>detect</p>
    <p>High data rates  Data-parallel algorithms</p>
    <p>good fit for GPU</p>
    <p>PTask SOSP 2011 9</p>
    <p>noisy point cloud</p>
    <p>geometric transformation</p>
    <p>capture camera images</p>
    <p>detect gestures</p>
    <p>noise filtering</p>
    <p>NOT Kinect: this is a harder problem!</p>
  </div>
  <div class="page">
    <p>What Wed Like To Do</p>
    <p>#&gt; capture | xform | filter | detect &amp;</p>
    <p>PTask SOSP 2011 10</p>
    <p>Modular design  flexibility, reuse</p>
    <p>Utilize heterogeneous hardware  Data-parallel components  GPU  Sequential components  CPU</p>
    <p>Using OS provided tools  processes, pipes</p>
    <p>CPU CPUGPU GPU</p>
  </div>
  <div class="page">
    <p>GPUs cannot run OS: different ISA  Disjoint memory space, no coherence  Host CPU must manage GPU execution</p>
    <p>Program inputs explicitly transferred/bound at runtime  Device buffers pre-allocated</p>
    <p>GPU Execution model</p>
    <p>CPUMain memory</p>
    <p>GPU memory</p>
    <p>GPU</p>
    <p>Copy inputs Copy outputs Send commands</p>
    <p>User-mode apps must implement</p>
    <p>PTask SOSP 2011 11</p>
  </div>
  <div class="page">
    <p>OS executive</p>
    <p>capture</p>
    <p>GPU</p>
    <p>Data migration</p>
    <p>kernel</p>
    <p>user</p>
    <p>Run!</p>
    <p>camdrv GPU driver</p>
    <p>HW</p>
    <p>PCI-xfer PCI-xfer</p>
    <p>xform</p>
    <p>copy to</p>
    <p>GPU</p>
    <p>copy from GPU</p>
    <p>PCI-xfer PCI-xfer</p>
    <p>filter</p>
    <p>copy from GPU</p>
    <p>detect</p>
    <p>IRP</p>
    <p>HIDdrv</p>
    <p>read()</p>
    <p>copy to</p>
    <p>GPU</p>
    <p>write() read() write()read() write() read()</p>
    <p>capture xform filter detect</p>
    <p>#&gt; capture | xform | filter | detect &amp;</p>
    <p>PTask SOSP 2011 12</p>
  </div>
  <div class="page">
    <p>GPU Analogues for:  Process API  IPC API  Scheduler hints</p>
    <p>Abstractions that enable:  Fairness/isolation  OS use of GPU  Composition/data movement optimization</p>
    <p>GPUs need better OS abstractions</p>
    <p>PTask SOSP 2011 13</p>
  </div>
  <div class="page">
    <p>The case for OS support  PTask: Dataflow for GPUs  Evaluation  Related Work  Conclusion</p>
    <p>Outline</p>
    <p>PTask SOSP 2011 14</p>
  </div>
  <div class="page">
    <p>ptask (parallel task)  Has priority for fairness  Analogous to a process for GPU execution  List of input/output resources (e.g. stdin, stdout)</p>
    <p>ports  Can be mapped to ptask input/outputs  A data source or sink</p>
    <p>channels  Similar to pipes, connect arbitrary ports  Specialize to eliminate double-buffering</p>
    <p>graph  DAG: connected ptasks, ports, channels</p>
    <p>datablocks  Memory-space transparent buffers</p>
    <p>PTask OS abstractions: dataflow!</p>
    <p>OS objectsOS RM possible  data: specify where, not how</p>
    <p>PTask SOSP 2011 15</p>
  </div>
  <div class="page">
    <p>PTask Graph: Gestural Interface</p>
    <p>PTask SOSP 2011 16</p>
    <p>xform</p>
    <p>ptask (GPU)</p>
    <p>port</p>
    <p>channel</p>
    <p>c lo</p>
    <p>u d</p>
    <p>ra w</p>
    <p>im g filter</p>
    <p>fo u t</p>
    <p>fincapture</p>
    <p>process (CPU)</p>
    <p>detect</p>
    <p>ptask graph</p>
    <p>ptask graph</p>
    <p>#&gt; capture | xform | filter | detect &amp;</p>
    <p>mapped mem GPU mem GPU mem</p>
    <p>Optimized data movement</p>
    <p>ra w</p>
    <p>im g</p>
    <p>Data arrival triggers computation</p>
    <p>datablock</p>
  </div>
  <div class="page">
    <p>Graphs scheduled dynamically  ptasks queue for dispatch when inputs ready</p>
    <p>Queue: dynamic priority order  ptask priority user-settable  ptask prio normalized to OS prio</p>
    <p>Transparently support multiple GPUs  Schedule ptasks for input locality</p>
    <p>PTask Scheduling</p>
    <p>PTask SOSP 2011 17</p>
  </div>
  <div class="page">
    <p>PTask SOSP 2011 18</p>
    <p>Main Memory</p>
    <p>GPU 0 Memory</p>
    <p>GPU 1 Memory</p>
    <p>Datablock</p>
    <p>spac e</p>
    <p>V M R W</p>
    <p>data main 1 1 1 1 gpu0 0 1 1 0 gpu1 1 1 1 0</p>
    <p>Logical buffer  backed by multiple physical buffers  buffers created/updated lazily  mem-mapping used to share across process boundaries</p>
    <p>Track buffer validity per memory space  writes invalidate other views</p>
    <p>Flags for access control/data placement</p>
    <p>Location Transparency: Datablocks</p>
  </div>
  <div class="page">
    <p>Datablock spac</p>
    <p>e V M</p>
    <p>R W</p>
    <p>data main 0 0 0 0 gpu 0 0 0 0</p>
    <p>Main Memory</p>
    <p>GPU Memory</p>
    <p>Datablock Action Zone</p>
    <p>PTask SOSP 2011 19</p>
    <p>xform</p>
    <p>c lo</p>
    <p>u d</p>
    <p>ra w</p>
    <p>im g filterfincapture</p>
    <p>#&gt; capture | xform | filter</p>
    <p>ptask port</p>
    <p>channel</p>
    <p>process</p>
    <p>datablock1 1 1 1 1 1 1 11 1 1 1 1 1 1 1 0 1 1 1</p>
    <p>ra w</p>
    <p>im g</p>
    <p>c lo</p>
    <p>u d</p>
  </div>
  <div class="page">
    <p>Revised technology stack</p>
    <p>1-1 correspondence between programmer and OS abstractions  GPU APIs can be built on top of new OS abstractions</p>
    <p>datablock</p>
    <p>port</p>
    <p>port</p>
    <p>PTask SOSP 2011 20</p>
  </div>
  <div class="page">
    <p>The case for OS support  PTask: Dataflow for GPUs  Evaluation  Related Work  Conclusion</p>
    <p>Outline</p>
    <p>PTask SOSP 2011 21</p>
  </div>
  <div class="page">
    <p>Windows 7  Full PTask API implementation  Stacked UMDF/KMDF driver</p>
    <p>Kernel component: mem-mapping, signaling  User component: wraps DirectX, CUDA, OpenCL</p>
    <p>syscalls  DeviceIoControl() calls  Linux 2.6.33.2</p>
    <p>Changed OS scheduling to manage GPU  GPU accounting added to task_struct</p>
    <p>Implementation</p>
    <p>PTask SOSP 2011 22</p>
  </div>
  <div class="page">
    <p>Windows 7, Core2-Quad, GTX580 (EVGA)  Implementations</p>
    <p>pipes: capture | xform | filter | detect  modular: capture+xform+filter+detect, 1process  handcode: data movement optimized, 1process  ptask: ptask graph</p>
    <p>Configurations  real-time: driven by cameras  unconstrained: driven by in-memory playback</p>
    <p>Gestural Interface evaluation</p>
    <p>PTask SOSP 2011 23</p>
  </div>
  <div class="page">
    <p>runtime user sys 0</p>
    <p>handcode modular pipes ptask</p>
    <p>re la</p>
    <p>ti v e t</p>
    <p>o h</p>
    <p>a n</p>
    <p>d c o</p>
    <p>d e</p>
    <p>Gestural Interface Performance</p>
    <p>Windows 7 x64 8GB RAM  Intel Core 2 Quad 2.66GHz  GTX580 (EVGA)</p>
    <p>lower is better compared to pipes</p>
    <p>~2.7x less CPU usage  16x higher throughput  ~45% less memory usage</p>
    <p>compared to hand-code  11.6% higher throughput  lower CPU util: no driver</p>
    <p>program</p>
    <p>PTask SOSP 2011 24</p>
  </div>
  <div class="page">
    <p>Performance Isolation</p>
    <p>fifo priority</p>
    <p>PTask priority</p>
    <p>P Ta</p>
    <p>s k i n</p>
    <p>v o c a ti</p>
    <p>o n</p>
    <p>s /s</p>
    <p>e c o n</p>
    <p>d</p>
    <p>Windows 7 x64 8GB RAM  Intel Core 2 Quad 2.66GHz  GTX580 (EVGA)</p>
    <p>Higher is better</p>
    <p>FIFO  queue invocations in arrival order  ptask  aged priority queue w OS priority  graphs: 6x6 matrix multiply  priority same for every PTask node</p>
    <p>PTask provides throughput proportional to priority</p>
    <p>PTask SOSP 2011 25</p>
    <p>ptask</p>
  </div>
  <div class="page">
    <p>Multi-GPU Scheduling</p>
    <p>PTask SOSP 2011 26</p>
    <p>priority data-aware</p>
    <p>S p</p>
    <p>e e d</p>
    <p>u p</p>
    <p>o v e r</p>
    <p>P U</p>
    <p>Windows 7 x64 8GB RAM  Intel Core 2 Quad 2.66GHz  2 x GTX580 (EVGA)</p>
    <p>Higher is better</p>
    <p>Data-aware == priority + locality  Graph depth &gt; 1 req. for any benefit</p>
    <p>Data-aware provides best throughput, preserves priority</p>
    <p>Synthetic graphs: Varying depths</p>
  </div>
  <div class="page">
    <p>GPU/ CPU</p>
    <p>cuda-1 Linux</p>
    <p>cuda-2 Linux</p>
    <p>cuda-1 PTask</p>
    <p>cuda-2 Ptask</p>
    <p>Read 1.17 x</p>
    <p>Write 1.28 x</p>
    <p>Linux+EncFS Throughput</p>
    <p>PTask SOSP 2011 27</p>
    <p>R/W bnc</p>
    <p>EncFS FUSE libc</p>
    <p>Linux 2.6.33</p>
    <p>SSD1</p>
    <p>cuda-1 cuda-2</p>
    <p>SSD2 GPU</p>
    <p>user-prgs</p>
    <p>user-libs</p>
    <p>OS</p>
    <p>HW</p>
    <p>PTask</p>
    <p>EncFS: nice -20  cuda-*: nice +19  AES: XTS chaining  SATA SSD, RAID  seq. R/W 200 MB</p>
    <p>Simple GPU usage accounting  Restores performance</p>
  </div>
  <div class="page">
    <p>The case for OS support  PTask: Dataflow for GPUs  Evaluation  Related Work  Conclusion</p>
    <p>Outline</p>
    <p>PTask SOSP 2011 28</p>
  </div>
  <div class="page">
    <p>OS support for heterogeneous platforms:  Helios [Nightingale 09], BarrelFish [Baumann 09] ,Offcodes</p>
    <p>[Weinsberg 08]</p>
    <p>GPU Scheduling  TimeGraph [Kato 11], Pegasus [Gupta 11]</p>
    <p>Graph-based programming models  Synthesis [Masselin 89]  Monsoon/Id [Arvind]  Dryad [Isard 07]  StreamIt [Thies 02]  DirectShow  TCP Offload [Currid 04]</p>
    <p>Tasking  Tessellation, Apple GCD,</p>
    <p>Related Work</p>
    <p>PTask SOSP 2011 29</p>
  </div>
  <div class="page">
    <p>OS abstractions for GPUs are critical  Enable fairness &amp; priority  OS can use the GPU</p>
    <p>Dataflow: a good fit abstraction  system manages data movement  performance benefits significant</p>
    <p>Conclusions</p>
    <p>Thank you. Questions?</p>
    <p>PTask SOSP 2011 30</p>
  </div>
</Presentation>
