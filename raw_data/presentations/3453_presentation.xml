<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Inception: System-Wide Security Testing of RealWorld Embedded Systems Software Nassim Corteggiani (Maxim Integrated / EURECOM)</p>
    <p>Giovanni Camurati (EURECOM) Aurlien Francillon (EURECOM)</p>
  </div>
  <div class="page">
    <p>Embedded Systems Are Everywhere</p>
    <p>| Maxim Integrated | EURECOM2</p>
    <p>[1] https://community.arm.com/processors/b/bl og/posts/arm-cortex-m3-processor-the-coreof-the-iot</p>
  </div>
  <div class="page">
    <p>Embedded Systems Are Everywhere</p>
    <p>Low Power Micro-controllers</p>
    <p>| Maxim Integrated | EURECOM3</p>
    <p>[1] https://community.arm.com/processors/b/bl og/posts/arm-cortex-m3-processor-the-coreof-the-iot</p>
  </div>
  <div class="page">
    <p>Embedded Systems Are Everywhere</p>
    <p>Low Power Micro-controllers</p>
    <p>Over 32 billions of ARM Cortex M3 shipped in 2018</p>
    <p>[1]</p>
    <p>[1] https://community.arm.com/processors/b/bl og/posts/arm-cortex-m3-processor-the-coreof-the-iot</p>
    <p>Cover a wide range of fields</p>
    <p>| Maxim Integrated | EURECOM4</p>
  </div>
  <div class="page">
    <p>Why the Security of Such Systems Matters?</p>
    <p>| Maxim Integrated | EURECOM5</p>
  </div>
  <div class="page">
    <p>Why the Security of Such Systems Matters?</p>
    <p>Highly connected -&gt; large scale attacks</p>
    <p>| Maxim Integrated | EURECOM6</p>
  </div>
  <div class="page">
    <p>Why the Security of Such Systems Matters?</p>
    <p>Highly connected -&gt; large scale attacks</p>
    <p>Difficulty to patch the code &gt; Mask ROM  mask applied on the chip during the fabrication &gt; Off-line devices</p>
    <p>| Maxim Integrated | EURECOM7</p>
  </div>
  <div class="page">
    <p>Why the Security of Such Systems Matters?</p>
    <p>Highly connected -&gt; large scale attacks</p>
    <p>Difficulty to patch the code &gt; Mask ROM  mask applied on the chip during the fabrication &gt; Off-line devices</p>
    <p>Store sensitive data &gt; Bitcoin wallet &gt; Payment terminal</p>
    <p>| Maxim Integrated | EURECOM8</p>
  </div>
  <div class="page">
    <p>Why the Security of Such Systems Matters?</p>
    <p>Highly connected -&gt; large scale attacks</p>
    <p>Difficulty to patch the code &gt; Mask ROM  mask applied on the chip during the fabrication &gt; Off-line devices</p>
    <p>Store sensitive data &gt; Bitcoin wallet &gt; Payment terminal</p>
    <p>Drive sensitive hardware system &gt; Physical damage &gt; Production line outage &gt; Signaling systems (red light)</p>
    <p>| Maxim Integrated | EURECOM9</p>
  </div>
  <div class="page">
    <p>Exemple of Recent Security Issues Recent attacks</p>
    <p>| Maxim Integrated | EURECOM10</p>
  </div>
  <div class="page">
    <p>Exemple of Recent Security Issues Recent attacks</p>
    <p>Nintendo Switch Tegra X1 bootrom exploit 2018 &gt; buffer overflow in the USB stack embedded in the mask ROM</p>
    <p>&gt; Cannot be patched</p>
    <p>&gt; Give access to the entire software stack</p>
    <p>| Maxim Integrated | EURECOM11</p>
  </div>
  <div class="page">
    <p>How Can We Test Such Firmware Programs?</p>
    <p>Symbolic Execution &gt; High path coverage</p>
    <p>&gt; Return test case for bugs</p>
    <p>| Maxim Integrated | EURECOM12</p>
  </div>
  <div class="page">
    <p>Symbolic Execution Example i = symb_i</p>
    <p>Int buffer[2]</p>
    <p>i = &lt;input&gt;</p>
    <p>int buffer[2] = {0, 1};</p>
    <p>| Maxim Integrated | EURECOM13</p>
  </div>
  <div class="page">
    <p>Symbolic Execution Example</p>
    <p>(   &lt; )   &lt;</p>
    <p>i = symb_i Int buffer[2]</p>
    <p>buffer[i] TRUE FALSE</p>
    <p>i = &lt;input&gt;</p>
    <p>int buffer[2] = {0, 1};</p>
    <p>if( buffer[i] == 0 ) {</p>
    <p>Out of bounds access</p>
    <p>| Maxim Integrated | EURECOM14</p>
  </div>
  <div class="page">
    <p>Symbolic Execution Example</p>
    <p>(   &lt; )   &lt;</p>
    <p>i = symb_i Int buffer[2]</p>
    <p>buffer[i] TRUE FALSE</p>
    <p>i = &lt;input&gt;</p>
    <p>int buffer[2] = {0, 1};</p>
    <p>if( buffer[i] == 0 ) {</p>
    <p>buffer[i] = 0xDEADBEEF;</p>
    <p>}</p>
    <p>( = )  =</p>
    <p>buffer[i] == 0xDEADBEAF</p>
    <p>buffer[i] == 0 TRUE FALSE</p>
    <p>| Maxim Integrated | EURECOM15</p>
    <p>Out of bounds access</p>
  </div>
  <div class="page">
    <p>Building A Symbolic Executor For Firmware Programs Klee as a basis</p>
    <p>Inception is based on Klee a symbolic virtual machine:</p>
    <p>| Maxim Integrated | EURECOM16</p>
  </div>
  <div class="page">
    <p>Building A Symbolic Executor For Firmware Programs Klee as a basis</p>
    <p>Inception is based on Klee a symbolic virtual machine: &gt; Widely deployed, efficient and based on the LLVM framework.</p>
    <p>| Maxim Integrated | EURECOM17</p>
  </div>
  <div class="page">
    <p>Building A Symbolic Executor For Firmware Programs Klee as a basis</p>
    <p>Inception is based on Klee a symbolic virtual machine: &gt; Widely deployed, efficient and based on the LLVM framework.</p>
    <p>&gt; Find memory safety violations</p>
    <p>| Maxim Integrated | EURECOM18</p>
  </div>
  <div class="page">
    <p>Building A Symbolic Executor For Firmware Programs Klee as a basis</p>
    <p>Inception is based on Klee a symbolic virtual machine: &gt; Widely deployed, efficient and based on the LLVM framework.</p>
    <p>&gt; Find memory safety violations</p>
    <p>&gt; High code coverage</p>
    <p>| Maxim Integrated | EURECOM19</p>
  </div>
  <div class="page">
    <p>Building A Symbolic Executor For Firmware Programs Klee as a basis</p>
    <p>Inception is based on Klee a symbolic virtual machine: &gt; Widely deployed, efficient and based on the LLVM framework.</p>
    <p>&gt; Find memory safety violations</p>
    <p>&gt; High code coverage</p>
    <p>C/C++ source code</p>
    <p>| Maxim Integrated | EURECOM20</p>
  </div>
  <div class="page">
    <p>Building A Symbolic Executor For Firmware Programs Klee as a basis</p>
    <p>Inception is based on Klee a symbolic virtual machine: &gt; Widely deployed, efficient and based on the LLVM framework.</p>
    <p>&gt; Find memory safety violations</p>
    <p>&gt; High code coverage</p>
    <p>C/C++ source code</p>
    <p>Clang</p>
    <p>| Maxim Integrated | EURECOM21</p>
  </div>
  <div class="page">
    <p>Building A Symbolic Executor For Firmware Programs Klee as a basis</p>
    <p>Inception is based on Klee a symbolic virtual machine: &gt; Widely deployed, efficient and based on the LLVM framework.</p>
    <p>&gt; Find memory safety violations</p>
    <p>&gt; High code coverage</p>
    <p>C/C++ source code</p>
    <p>Clang</p>
    <p>LLVM bit-code</p>
    <p>| Maxim Integrated | EURECOM22</p>
  </div>
  <div class="page">
    <p>Building A Symbolic Executor For Firmware Programs Klee as a basis</p>
    <p>Inception is based on Klee a symbolic virtual machine: &gt; Widely deployed, efficient and based on the LLVM framework.</p>
    <p>&gt; Find memory safety violations</p>
    <p>&gt; High code coverage</p>
    <p>C/C++ source code</p>
    <p>Clang</p>
    <p>LLVM bit-code</p>
    <p>Klee</p>
    <p>| Maxim Integrated | EURECOM23</p>
  </div>
  <div class="page">
    <p>Why testing source code instead of binary code ? Source VS Binary</p>
    <p>| Maxim Integrated | EURECOM24</p>
  </div>
  <div class="page">
    <p>Why testing source code instead of binary code ? Source VS Binary</p>
    <p>char b1[2];</p>
    <p>char b2[2];</p>
    <p>char getElement(int index)</p>
    <p>{</p>
    <p>return b1[index];</p>
    <p>}</p>
    <p>b1: .space 2</p>
    <p>b2: .space 2</p>
    <p>getElement(int):</p>
    <p>ldr r2, .L3</p>
    <p>add r3, r2, r0</p>
    <p>ldrb r0, [r3]</p>
    <p>bx lr</p>
    <p>.L3: .word b1</p>
    <p>| Maxim Integrated | EURECOM25</p>
  </div>
  <div class="page">
    <p>Why testing source code instead of binary code ? Source VS Binary</p>
    <p>char b1[2];</p>
    <p>char b2[2];</p>
    <p>char getElement(int index)</p>
    <p>{</p>
    <p>return b1[index];</p>
    <p>}</p>
    <p>b1: .space 2</p>
    <p>b2: .space 2</p>
    <p>getElement(int):</p>
    <p>ldr r2, .L3</p>
    <p>add r3, r2, r0</p>
    <p>ldrb r0, [r3]</p>
    <p>bx lr</p>
    <p>.L3: .word b1</p>
    <p>| Maxim Integrated | EURECOM26</p>
  </div>
  <div class="page">
    <p>Why testing source code instead of binary code ? Source ( Klee/Clang) VS Binary (SE2, angr, BAP)</p>
    <p>define i8 @getElement(i32 %index){</p>
    <p>entry:</p>
    <p>%0 = load i32* %index.addr</p>
    <p>%1 = getelementptr inbounds</p>
    <p>[2 x i8]* @b1, i32 0, i32 %0</p>
    <p>%2 = load i8* %1</p>
    <p>ret i8 %2</p>
    <p>}</p>
    <p>char b1[2];</p>
    <p>char b2[2];</p>
    <p>char getElement(int index)</p>
    <p>{</p>
    <p>return b1[index];</p>
    <p>}</p>
    <p>b1: .space 2</p>
    <p>b2: .space 2</p>
    <p>getElement(int):</p>
    <p>ldr r2, .L3</p>
    <p>add r3, r2, r0</p>
    <p>ldrb r0, [r3]</p>
    <p>bx lr</p>
    <p>.L3: .word b1</p>
    <p>define i8 @getElement(i32 index) {</p>
    <p>entry:</p>
    <p>store i32 %index, i32* @R0</p>
    <p>store i32 268436792, i32* @R2</p>
    <p>%R2_1 = load i32* @R2</p>
    <p>%R0_1 = load i32* @R0</p>
    <p>%R2_2 = add i32 %R2_1, %R0_1</p>
    <p>%R3_0 = inttoptr i32 %R2_2 to i32*</p>
    <p>%R3_1 = bitcast i32* %R3_0 to i8*</p>
    <p>%R3_2 = load i8* %R3_1</p>
    <p>%R3_3 = zext i8 %R3_2 to i32</p>
    <p>| Maxim Integrated | EURECOM27</p>
  </div>
  <div class="page">
    <p>Why testing source code instead of binary code ? Source ( Klee/Clang) VS Binary (SE2, angr, BAP)</p>
    <p>define i8 @getElement(i32 %index){</p>
    <p>entry:</p>
    <p>%0 = load i32* %index.addr</p>
    <p>%1 = getelementptr inbounds</p>
    <p>[2 x i8]* @b1, i32 0, i32 %0</p>
    <p>%2 = load i8* %1</p>
    <p>ret i8 %2</p>
    <p>}</p>
    <p>char b1[2];</p>
    <p>char b2[2];</p>
    <p>char getElement(int index)</p>
    <p>{</p>
    <p>return b1[index];</p>
    <p>}</p>
    <p>b1: .space 2</p>
    <p>b2: .space 2</p>
    <p>getElement(int):</p>
    <p>ldr r2, .L3</p>
    <p>add r3, r2, r0</p>
    <p>ldrb r0, [r3]</p>
    <p>bx lr</p>
    <p>.L3: .word b1</p>
    <p>define i8 @getElement(i32 index) {</p>
    <p>entry:</p>
    <p>store i32 %index, i32* @R0</p>
    <p>store i32 268436792, i32* @R2</p>
    <p>%R2_1 = load i32* @R2</p>
    <p>%R0_1 = load i32* @R0</p>
    <p>%R2_2 = add i32 %R2_1, %R0_1</p>
    <p>%R3_0 = inttoptr i32 %R2_2 to i32*</p>
    <p>%R3_1 = bitcast i32* %R3_0 to i8*</p>
    <p>%R3_2 = load i8* %R3_1</p>
    <p>%R3_3 = zext i8 %R3_2 to i32</p>
    <p>| Maxim Integrated | EURECOM28</p>
  </div>
  <div class="page">
    <p>Source vs Binary</p>
    <p>When source available testing binary is possible however: &gt; Types are lost</p>
    <p>&gt; Corruption will be detected later if at all</p>
    <p>&gt; Worse on embedded systems</p>
    <p>See: Muench et. al. What you corrupt is not what you crash, NDSS 2018</p>
    <p>Goal of Inception: improve testing for firmware during development &gt; Limit requirements on code</p>
    <p>| Maxim Integrated | EURECOM29</p>
  </div>
  <div class="page">
    <p>Major Challenges For Symbolic Execution of Firmware Programs Is C/C++ Support Enough To Test Real World Firmware ?</p>
    <p>Number of functions including assembly instructions in real world embedded software</p>
    <p>STM32(demos) FreeRTOS(STM32) Mbed OS ChibiOS</p>
    <p>Functions2</p>
    <p>| Maxim Integrated | EURECOM30</p>
  </div>
  <div class="page">
    <p>Major Challenges For Symbolic Execution of Firmware Programs Is C/C++ Support Enough To Test Real World Firmware ?</p>
    <p>Number of functions including assembly instructions in real world embedded software</p>
    <p>STM32(demos) FreeRTOS(STM32) Mbed OS ChibiOS</p>
    <p>Functions2</p>
    <p>Assembly code : &gt; Multithreading</p>
    <p>&gt; Optimizations</p>
    <p>&gt; Side channel counter-measures</p>
    <p>&gt; Hardware features e.g. ultra low power mode</p>
    <p>| Maxim Integrated | EURECOM31</p>
  </div>
  <div class="page">
    <p>Major Challenges For Symbolic Execution of Firmware Programs Is C/C++ Support Enough To Test Real World Firmware ?</p>
    <p>Presence of assembly instructions in real world embedded software</p>
    <p>STM32(demos) FreeRTOS(STM32) Mbed OS ChibiOS</p>
    <p>Functions with inline asm Functions2</p>
    <p>Assembly code : &gt; Multithreading</p>
    <p>&gt; Optimizations</p>
    <p>&gt; Side channel counter-measures</p>
    <p>&gt; Hardware features e.g. ultra low power modeChallenge 1 :</p>
    <p>Firmware source code contains a mix of C/C++, assembly and binary</p>
    <p>| Maxim Integrated | EURECOM32</p>
  </div>
  <div class="page">
    <p>Major Challenges For Symbolic Execution of Firmware Programs Hardware environment</p>
    <p>| Maxim Integrated | EURECOM33</p>
  </div>
  <div class="page">
    <p>Major Challenges For Symbolic Execution of Firmware Programs Hardware environment</p>
    <p>Hardware interactions &gt; Memory Mapped I/O</p>
    <p>| Maxim Integrated | EURECOM34</p>
  </div>
  <div class="page">
    <p>Major Challenges For Symbolic Execution of Firmware Programs Hardware environment</p>
    <p>Hardware interactions &gt; Memory Mapped I/O</p>
    <p>Memory</p>
    <p>Peripherals</p>
    <p>#define UART_STATUS 0x40000000</p>
    <p>#define UART_DATA 0x40000004</p>
    <p>char* RX_BUFFER = 0x20000000;</p>
    <p>while(!*UART_STATUS) {</p>
    <p>char* data = (char*)UART_DATA;</p>
    <p>strncpy(RX_BUFFER++, data, 4);</p>
    <p>}</p>
    <p>Internal/external memory</p>
    <p>Internal/external peripherals</p>
    <p>| Maxim Integrated | EURECOM35</p>
  </div>
  <div class="page">
    <p>Major Challenges For Symbolic Execution of Firmware Programs Hardware environment</p>
    <p>Hardware interactions &gt; Memory Mapped I/O</p>
    <p>Memory</p>
    <p>Peripherals</p>
    <p>&gt; Interrupt driven programs</p>
    <p>#define UART_STATUS 0x40000000</p>
    <p>#define UART_DATA 0x40000004</p>
    <p>char* RX_BUFFER = 0x20000000;</p>
    <p>while(!*UART_STATUS) {</p>
    <p>char* data = (char*)UART_DATA;</p>
    <p>strncpy(RX_BUFFER++, data, 4);</p>
    <p>}</p>
    <p>Internal/external memory</p>
    <p>Internal/external peripherals</p>
    <p>Interrupt Controller</p>
    <p>void interrupt_handler() { }</p>
    <p>| Maxim Integrated | EURECOM36</p>
  </div>
  <div class="page">
    <p>Major Challenges For Symbolic Execution of Firmware Programs Hardware environment</p>
    <p>Hardware interactions &gt; Memory Mapped I/O</p>
    <p>Memory</p>
    <p>Peripherals</p>
    <p>&gt; Interrupt driven programs</p>
    <p>#define UART_STATUS 0x40000000</p>
    <p>#define UART_DATA 0x40000004</p>
    <p>char* RX_BUFFER = 0x20000000;</p>
    <p>while(!*UART_STATUS) {</p>
    <p>char* data = (char*)UART_DATA;</p>
    <p>strncpy(RX_BUFFER++, data, 4);</p>
    <p>}</p>
    <p>Internal/external memory</p>
    <p>Internal/external peripherals</p>
    <p>Interrupt Controller</p>
    <p>void interrupt_handler() { }</p>
    <p>Challenge 2 :</p>
    <p>Firmware programs highly interact with their hardware environment</p>
    <p>| Maxim Integrated | EURECOM37</p>
  </div>
  <div class="page">
    <p>Building A Symbolic Executor For Firmware Programs</p>
    <p>| Maxim Integrated | EURECOM38</p>
  </div>
  <div class="page">
    <p>Building A Symbolic Executor For Firmware Programs</p>
    <p>Firmware (C/C++, asm,</p>
    <p>binary) Clang LLVM bit-code</p>
    <p>| Maxim Integrated | EURECOM39</p>
  </div>
  <div class="page">
    <p>Building A Symbolic Executor For Firmware Programs</p>
    <p>Firmware (C/C++, asm,</p>
    <p>binary) Clang LLVM bit-code ELF</p>
    <p>ARM Backend</p>
    <p>| Maxim Integrated | EURECOM40</p>
  </div>
  <div class="page">
    <p>Building A Symbolic Executor For Firmware Programs</p>
    <p>Firmware (C/C++, asm,</p>
    <p>binary) Clang LLVM bit-code ELF</p>
    <p>Inception Translator</p>
    <p>LLVM bit-code Mixed IR</p>
    <p>ARM Backend</p>
    <p>Inception translator: &gt; Lift assembly directives and binary code in</p>
    <p>LLVM bit-code</p>
    <p>&gt; Merge lifted bit-code with other  High-IR : obtained from C/C++</p>
    <p>Glue-IR : glue code</p>
    <p>Low-IR : lifted assembly/binary</p>
    <p>| Maxim Integrated | EURECOM41</p>
  </div>
  <div class="page">
    <p>Building A Symbolic Executor For Firmware Programs</p>
    <p>Firmware (C/C++, asm,</p>
    <p>binary) Clang LLVM bit-code</p>
    <p>Modified Klee</p>
    <p>ELF</p>
    <p>Inception Translator</p>
    <p>LLVM bit-code Mixed IR</p>
    <p>ARM Backend</p>
    <p>| Maxim Integrated | EURECOM42</p>
    <p>Inception translator: &gt; Lift assembly directives and binary code in</p>
    <p>LLVM bit-code</p>
    <p>&gt; Merge lifted bit-code with other  High-IR : obtained from C/C++</p>
    <p>Glue-IR : glue code</p>
    <p>Low-IR : lifted assembly/binary</p>
    <p>&gt; Support Cortex M3 ISA</p>
  </div>
  <div class="page">
    <p>Challenge 1 : Supporting C/C++/Asm/Binary code Inception-translator</p>
    <p>| Maxim Integrated | EURECOM52</p>
  </div>
  <div class="page">
    <p>Inception Translator : Merging High-IR and Low-IR</p>
    <p>| Maxim Integrated | EURECOM53</p>
    <p>int a = 4;</p>
    <p>boo(a);</p>
    <p>&lt;boo&gt;:</p>
  </div>
  <div class="page">
    <p>Inception Translator : Merging High-IR and Low-IR</p>
    <p>High IR</p>
    <p>%a = alloca i32</p>
    <p>store i32 4, i32* %a</p>
    <p>%0 = load i32* %a</p>
    <p>%call = call i32</p>
    <p>@boo(i32 %0)</p>
    <p>ret void }</p>
    <p>| Maxim Integrated | EURECOM54</p>
    <p>int a = 4;</p>
    <p>boo(a);</p>
    <p>&lt;boo&gt;:</p>
  </div>
  <div class="page">
    <p>Inception Translator : Merging High-IR and Low-IR</p>
    <p>Low IRHigh IR</p>
    <p>int a = 4;</p>
    <p>boo(a);</p>
    <p>%a = alloca i32</p>
    <p>store i32 4, i32* %a</p>
    <p>%0 = load i32* %a</p>
    <p>%call = call i32</p>
    <p>@boo(i32 %0)</p>
    <p>ret void }</p>
    <p>&lt;boo&gt;:</p>
    <p>&quot;boo+0&quot;: ; preds = %entry</p>
    <p>%R7_1 = load i32* @R7</p>
    <p>%SP1 = load i32* @SP</p>
    <p>%SP2 = sub i32 %SP1, 4</p>
    <p>%SP3 = inttoptr i32 %SP2 to i32*</p>
    <p>store i32 %R7_1, i32* %SP3</p>
    <p>store i32 %SP2, i32* @SP</p>
    <p>%SP4 = load i32* @SP</p>
    <p>%SP5 = add i32 %SP4, -13</p>
    <p>%SP6 = add i32 %SP5, 1</p>
    <p>| Maxim Integrated | EURECOM55</p>
  </div>
  <div class="page">
    <p>Inception Translator : Merging High-IR and Low-IR</p>
    <p>Glue IR Low IRHigh IR</p>
    <p>int a = 4;</p>
    <p>boo(a);</p>
    <p>define i32 @boo(i32 %a){</p>
    <p>entry:</p>
    <p>store i32 %a, i32* @R0</p>
    <p>br label %&quot;boo+0&quot;</p>
    <p>%a = alloca i32</p>
    <p>store i32 4, i32* %a</p>
    <p>%0 = load i32* %a</p>
    <p>%call = call i32</p>
    <p>@boo(i32 %0)</p>
    <p>ret void }</p>
    <p>&lt;boo&gt;:</p>
    <p>&quot;boo+0&quot;: ; preds = %entry</p>
    <p>%R7_1 = load i32* @R7</p>
    <p>%SP1 = load i32* @SP</p>
    <p>%SP2 = sub i32 %SP1, 4</p>
    <p>%SP3 = inttoptr i32 %SP2 to i32*</p>
    <p>store i32 %R7_1, i32* %SP3</p>
    <p>store i32 %SP2, i32* @SP</p>
    <p>%SP4 = load i32* @SP</p>
    <p>%SP5 = add i32 %SP4, -13</p>
    <p>%SP6 = add i32 %SP5, 1</p>
    <p>| Maxim Integrated | EURECOM56</p>
  </div>
  <div class="page">
    <p>Unified Memory Layout</p>
    <p>| Maxim Integrated | EURECOM57</p>
  </div>
  <div class="page">
    <p>Unified Memory Layout</p>
    <p>Glue IR : lower</p>
    <p>the level of semantic</p>
    <p>Low IRHigh IR</p>
    <p>Glue IR : higher</p>
    <p>the level of semantic</p>
    <p>High IR</p>
    <p>Execution path | Maxim Integrated | EURECOM58</p>
  </div>
  <div class="page">
    <p>Unified Memory Layout</p>
    <p>Allocate Low IR memory : stack, virtual CPU registers, heap</p>
    <p>Glue IR : lower</p>
    <p>the level of semantic</p>
    <p>Low IRHigh IR</p>
    <p>Glue IR : higher</p>
    <p>the level of semantic</p>
    <p>High IR</p>
    <p>Execution path | Maxim Integrated | EURECOM59</p>
  </div>
  <div class="page">
    <p>Unified Memory Layout</p>
    <p>Allocate Low IR memory : stack, virtual CPU registers, heap</p>
    <p>Fill gaps in global data sections  When no C/C++ symbols point to this area</p>
    <p>Glue IR : lower</p>
    <p>the level of semantic</p>
    <p>Low IRHigh IR</p>
    <p>Glue IR : higher</p>
    <p>the level of semantic</p>
    <p>High IR</p>
    <p>Execution path | Maxim Integrated | EURECOM60</p>
  </div>
  <div class="page">
    <p>Unified Memory Layout</p>
    <p>Allocate Low IR memory : stack, virtual CPU registers, heap</p>
    <p>Fill gaps in global data sections  When no C/C++ symbols point to this area</p>
    <p>Allocate High-IR objects at location defined in the ELF symbols table</p>
    <p>Glue IR : lower</p>
    <p>the level of semantic</p>
    <p>Low IRHigh IR</p>
    <p>Glue IR : higher</p>
    <p>the level of semantic</p>
    <p>High IR</p>
    <p>Execution path | Maxim Integrated | EURECOM61</p>
  </div>
  <div class="page">
    <p>Low IR Hardware Mechanisms Emulation</p>
    <p>Challenge we solved: &gt; Indirect calls (Indirect Call Promotion)</p>
    <p>&gt; Seamless hardware mechanisms (Context switching)</p>
    <p>&gt; Supervisor call</p>
    <p>&gt; Update specific registers values (LR, MSP, PSP, BASEPRI, ITSTATE, )</p>
    <p>Glue IR : lower</p>
    <p>the level of semantic</p>
    <p>Low IRHigh IR</p>
    <p>Glue IR : higher</p>
    <p>the level of semantic</p>
    <p>High IR</p>
    <p>Execution path</p>
    <p>Emulation</p>
    <p>| Maxim Integrated | EURECOM62</p>
  </div>
  <div class="page">
    <p>Challenge 2 : Hardware interactions Inception-analyzer</p>
    <p>| Maxim Integrated | EURECOM63</p>
  </div>
  <div class="page">
    <p>The Inception System Overview</p>
    <p>Mixed Bytecode</p>
    <p>config.json</p>
    <p>Klee-based Symbolic Virtual Machine</p>
    <p>ELF</p>
    <p>| Maxim Integrated | EURECOM64</p>
  </div>
  <div class="page">
    <p>The Inception System Overview</p>
    <p>Mixed Bytecode</p>
    <p>config.json</p>
    <p>Klee-based Symbolic Virtual</p>
    <p>Machine</p>
    <p>Memory Mapped</p>
    <p>stack</p>
    <p>Globals</p>
    <p>heap</p>
    <p>Data are allocated according to the information present in the symbol table</p>
    <p>User configuration (config.json): - Local memory - Redirected memory - Symbolic memory</p>
    <p>ELF</p>
    <p>| Maxim Integrated | EURECOM65</p>
  </div>
  <div class="page">
    <p>The Inception System Overview: Inception debugger</p>
    <p>Mixed Bytecode</p>
    <p>config.json</p>
    <p>Klee-based Symbolic Virtual</p>
    <p>Machine</p>
    <p>Memory Mapped</p>
    <p>stack</p>
    <p>Globals</p>
    <p>heap</p>
    <p>ELF Real Device</p>
    <p>Custom Inception Debugger</p>
    <p>USB 3.0 link</p>
    <p>Jtag</p>
    <p>| Maxim Integrated | EURECOM66</p>
  </div>
  <div class="page">
    <p>The Inception System Overview: Inception debugger</p>
    <p>Inspired by Surrogates and Avatar</p>
    <p>| Maxim Integrated | EURECOM67</p>
    <p>Memory Mapped</p>
    <p>stack</p>
    <p>Globals</p>
    <p>heap</p>
    <p>Real Device</p>
    <p>Custom Inception Debugger</p>
    <p>USB 3.0 link</p>
    <p>Jtag</p>
    <p>Zaddach et. al. AVATAR: A Framework to Support Dynamic Security Analysis of Embedded Systems' Firmwares, NDSS 2014 Koscher et. al. SURROGATES: Enabling Near-Real-Time Dynamic Analyses of Embedded Systems, WOOT 2015</p>
  </div>
  <div class="page">
    <p>The Inception System Overview: Inception debugger</p>
    <p>Mixed Bytecode</p>
    <p>config.json</p>
    <p>Klee-based Symbolic Virtual</p>
    <p>Machine</p>
    <p>Memory Mapped</p>
    <p>stack</p>
    <p>Globals</p>
    <p>heap</p>
    <p>ELF Real Device</p>
    <p>Custom Inception Debugger</p>
    <p>USB 3.0 link</p>
    <p>Interrupt Controller</p>
    <p>Jtag</p>
    <p>| Maxim Integrated | EURECOM68</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>| Maxim Integrated | EURECOM69</p>
  </div>
  <div class="page">
    <p>Performance</p>
    <p>Average time to complete 1  106 read or write requests for SURROGATES and Inception.</p>
    <p>Performance comparison between native execution and Inception.</p>
    <p>* Current bottleneck is bit-code execution</p>
    <p>Reads Writes Buffered Reads</p>
    <p>Inception Surrogates</p>
    <p>Wget Ping UART</p>
    <p>Inception Native</p>
    <p>| Maxim Integrated | EURECOM70</p>
    <p>Average IO per second Average runtime [ms]</p>
  </div>
  <div class="page">
    <p>Bug Detection</p>
    <p>Evolution of corruption detection vs. number of assembly functions in the EXPACT XML parser (4 vulnerabilities [1], symbolic inputs, and a timeout of 90s).</p>
    <p>Corruption detection of real-world security flaws based on FreeRTOS and the Juliet 1.3 test suites.</p>
    <p>Detected Undetected</p>
    <p>Division by Zero</p>
    <p>Null Pointer Dereference</p>
    <p>Use After Free</p>
    <p>Free Memory Not</p>
    <p>on Heap</p>
    <p>Heap-Based Buffer</p>
    <p>Overflow</p>
    <p>Integer Overflow</p>
    <p>Detected Undetected</p>
    <p>[1] MUENCH et. al. What you corrupt is not what you crash: Challenges in fuzzing embedded devices. In NDSS 2018.</p>
    <p>| Maxim Integrated | EURECOM71</p>
    <p>% of detected bugsAverage number of detected vuln.</p>
  </div>
  <div class="page">
    <p>Verification</p>
    <p>Intensive verification of the lifter and the modified Klee &gt; 53K tests comparison between Inception and native</p>
    <p>&gt; 1562 tests based on NIST Juliet 1.3 tests suite</p>
    <p>&gt; 40 tests based on the Klockwork tests suite</p>
    <p>&gt; Several demos for the STM32 L152RE and the LPC1850 DB1 boards</p>
    <p>&gt; 1 Mbed TLS test suite</p>
    <p>&gt; Several embedded operating systems (FreeRTOS, mini-arm-os)</p>
    <p>| Maxim Integrated | EURECOM72</p>
  </div>
  <div class="page">
    <p>Conlusion</p>
    <p>Extends analysis to mixed languages: assembly, C/C++, binary</p>
    <p>Fit well in chip life-cycle : &gt; test without hardware &gt; FPGA-based design &gt; silicium</p>
    <p>Already used on proprietary real world Mask ROM code at Maxim &gt; Bugs found before mask manufacturing</p>
    <p>Inception is open-sourced: &gt; Getting started at</p>
    <p>https://inception-framework.github.io/inception/ &gt; Github and docker</p>
    <p>| Maxim Integrated | EURECOM73</p>
  </div>
  <div class="page">
    <p>Questions?</p>
    <p>| Maxim Integrated | EURECOM74</p>
    <p>Free icons license : https://icons8.com</p>
  </div>
</Presentation>
