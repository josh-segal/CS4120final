<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Elastic Scaling of Stateful Network Functions</p>
    <p>Shinae Woo*+, Justine Sherry*, Sangjin Han*, Sue Moon+, Sylvia Ratnasamy*, Scott Shenker*</p>
    <p>+ KAIST, * UC Berkeley</p>
    <p>NSDI 2018</p>
  </div>
  <div class="page">
    <p>NFV promises the benefit of virtualization; Elastic scaling is one of such benefits.</p>
    <p>Elastic scaling: Adjusting the number of NF instances in response to varying load.</p>
    <p>In practice, realizing elastic scaling comes at a significant cost of correctness and performance.</p>
    <p>Elastic Scaling of NFs</p>
    <p>Packets SDN controller</p>
    <p>Forwarding rule</p>
    <p>NF controller</p>
    <p>Adjust # of instances</p>
    <p>Instance 1 Instance N. . . . . . . . .</p>
  </div>
  <div class="page">
    <p>Requirements of Elastic Scaling</p>
    <p>Correct NF operations  Multiple instances work like a single instance, no matter how many</p>
    <p>and where they are.</p>
    <p>High performance  High throughput (10s  100s of Mpps)  Low latency (sub-millisecond)</p>
    <p>Scaling events should not compromise above.</p>
    <p>Stateful NFs make elastic scaling challenging.</p>
  </div>
  <div class="page">
    <p>Background: NF State Types</p>
    <p>YES: Partitionable NO: Non-partitionable</p>
    <p>TCP connection state  Per-flow statistics</p>
    <p>Attack detection status such as port scanner and password guesser</p>
    <p>Inst 1 Inst 2</p>
    <p>P PPPPP</p>
    <p>locally accessed remotely accessed</p>
    <p>Can state be distributed in a way that no remote access is necessary?</p>
    <p>Inst 1 Inst 2</p>
    <p>P PPPPP</p>
    <p>Remote access cost is expensive State locality changes when scaling</p>
  </div>
  <div class="page">
    <p>Partitionable State: Scaling Breaks Correctness</p>
    <p>P PP</p>
    <p>PP P</p>
    <p>Scale out</p>
    <p>P P</p>
    <p>P PPP</p>
    <p>L NF3 doesnt have necessary state: sharing/migration is a must</p>
  </div>
  <div class="page">
    <p>Prior NF state management models (or, why managing NF state is so challenging?)</p>
  </div>
  <div class="page">
    <p>Traditional Model: Local-only</p>
    <p>NF states are in local memory L No sharing support L Incorrect behavior when scale-out</p>
    <p>Packets</p>
    <p>Local memory</p>
    <p>. . . . . . . .</p>
  </div>
  <div class="page">
    <p>Remote-Only Model</p>
    <p>All state management is offloaded to remote storage</p>
    <p>Packets</p>
    <p>. . . . . . . .</p>
    <p>Remote shared memory</p>
  </div>
  <div class="page">
    <p>Remote-Only Sacrifices Performance</p>
    <p>NAT PRADS IDS</p>
    <p>Re la tiv e Th ro ug hp</p>
    <p>ut</p>
    <p>local-only remote-only</p>
    <p>NAT PRADS IDS La te nc y (u s)</p>
    <p>* For remote-only, we follow the algorithm described in Stateless Network Functions: Breaking the Tight Coupling of State and Processing, NSDI 2017</p>
    <p>L Losing throughput L Inflating packet latency</p>
  </div>
  <div class="page">
    <p>Local+Remote Model</p>
    <p>All state access is local  Out-of-band control for state synchronization</p>
    <p>Packets</p>
    <p>Local memory</p>
    <p>. . . . . . . .</p>
    <p>export, import, merge state Synchronize state</p>
    <p>NF controller</p>
  </div>
  <div class="page">
    <p>Stop-Synchronize-Resume: NO GOOD</p>
    <p>Centralized controller keeps state locality and consistency+  Proactively prepare state before it is accessed</p>
    <p>P PPPPP Synchronize</p>
    <p>P P P P</p>
    <p>P PPP PPP P</p>
    <p>P P P</p>
    <p>Forwarding</p>
  </div>
  <div class="page">
    <p>Local+Remote Trades Performance for Correctness</p>
    <p>gp ut (K</p>
    <p>pp s)</p>
    <p>La te nc y (m</p>
    <p>s)</p>
    <p>Time(s)</p>
    <p>xput (NF1) xput (NF2) 99-% latency 50-% latency</p>
    <p>* OpenNF: Enabling Innovation in Network Function Control, SIGCOMM 2014</p>
    <p>OpenNF*, PRADS (monitoring) 10kpps, 1500 flows context migration from NF1 to NF2</p>
    <p>L 100s of ms median latencies</p>
    <p>System pause</p>
  </div>
  <div class="page">
    <p>Summary on State Management Model</p>
    <p>Normal Operation Scaling Operation</p>
    <p>Local-only L No scaling</p>
    <p>Remote-only L Low performance J No disruption</p>
    <p>Local + Remote J Little overhead L System-wide pause</p>
    <p>Normal Operation Scaling Operation</p>
    <p>Local-only L No scaling</p>
    <p>Remote-only L Low performance J No disruption</p>
    <p>Local + Remote J Little overhead L System-wide pause</p>
    <p>Distributed Shared Space</p>
    <p>J Little overhead J Minimal disruption</p>
    <p>Normal Operation (Without scaling-out)</p>
    <p>Scaling-out</p>
  </div>
  <div class="page">
    <p>P PP</p>
    <p>PP</p>
    <p>Load Balancer (Switch / SDN Controller)</p>
    <p>. . . . . . . .</p>
    <p>S6: A Framework to Build Scalable NFs</p>
    <p>Distributed Shared Space</p>
    <p>Locally distributed  Minimal performance overhead</p>
    <p>State sharing</p>
    <p>No system-wide pausing during scaling events</p>
    <p>Any NF can access to any state</p>
  </div>
  <div class="page">
    <p>S6 Scales Elastically and Gracefully</p>
    <p>Th ro ug pu</p>
    <p>t ( Kp</p>
    <p>ps )</p>
    <p>La te nc y (m</p>
    <p>s)</p>
    <p>Time(s)</p>
    <p>Th ro ug pu</p>
    <p>t ( Kp</p>
    <p>ps )</p>
    <p>La te nc y (m</p>
    <p>s)</p>
    <p>Time(s)</p>
    <p>local+remote (OpenNF*)</p>
    <p>Distributed Shared (S6)</p>
    <p>* OpenNF: Enabling Innovation in Network Function Control, SIGCOMM 2014</p>
    <p>Sub-millisecond median latency</p>
    <p>Overall throughput keeps stable</p>
    <p>Even with more extreme scenarios, 1000x higher workload (Mpps), 1000x lower median latency</p>
  </div>
  <div class="page">
    <p>S6: A Framework to Build Scalable NFs</p>
  </div>
  <div class="page">
    <p>Object for NF State Abstraction</p>
    <p>Integrity protection of state</p>
    <p>- Single writer vs. Multiple writer</p>
    <p>Optimization per object - Performance vs. consistency: Different sweet spot per object</p>
    <p>Object encapsulation enables easy state management</p>
    <p>Object Data</p>
    <p>Operations</p>
    <p>Interfaces</p>
  </div>
  <div class="page">
    <p>Optimization Strategies for NF State</p>
    <p>State type?</p>
    <p>Access pattern?Local access</p>
    <p>Non-blocking updates Merging local replicas</p>
    <p>Caching</p>
    <p>Partitionable Non-partitionable</p>
    <p>Read-heavy Write-heavy</p>
    <p>*From our survey on 8 popular network functions</p>
    <p>Most NF state variables are covered by these strategies*</p>
  </div>
  <div class="page">
    <p>Examples of Optimization for NF state</p>
    <p>class Counter {</p>
    <p>private:</p>
    <p>uint32_t counter;</p>
    <p>public:</p>
    <p>uint32_t int_and_get();</p>
    <p>void inc(uint32_t x);</p>
    <p>uint32_t get() const ;</p>
    <p>};</p>
    <p>: public MultiWriter {</p>
    <p>untether;</p>
    <p>stale;</p>
    <p>non-blocking update</p>
    <p>return from cache</p>
    <p>function shipping for updating from multiple instances c.f., SingleWriter</p>
  </div>
  <div class="page">
    <p>S6: A Framework to Build Scalable NFs</p>
  </div>
  <div class="page">
    <p>S6 Shared Object Space Architecture</p>
    <p>where(Key1)=A</p>
    <p>....... get(Key1) .......</p>
    <p>Instance A Instance B</p>
    <p>Object Space</p>
    <p>Key Space</p>
    <p>NF app</p>
    <p>Obj1</p>
    <p>Hash(Key)={x|A,B}</p>
    <p>create new object or access existing object</p>
  </div>
  <div class="page">
    <p>Hash(Key)={x|A,B}</p>
    <p>Elastic Scaling Requires Space Reorganizing</p>
    <p>where(Key1)=A</p>
    <p>....... get(Key1) .......</p>
    <p>Instance A Instance B</p>
    <p>Object Space</p>
    <p>Key Space</p>
    <p>NF app</p>
    <p>Obj1</p>
    <p>Hash(Key)={x|A,B}</p>
    <p>Instance C</p>
    <p>Hash_v2(Key)={x|A,B,C}</p>
    <p>Changing locality of partitionable state</p>
    <p>New hash function for key distribution</p>
  </div>
  <div class="page">
    <p>State Migration for Locality</p>
    <p>Instance C</p>
    <p>where(Key1)=A</p>
    <p>Instance A Instance B</p>
    <p>Object Space</p>
    <p>Key Space</p>
    <p>NF app</p>
    <p>Obj1</p>
    <p>....... get(Key1) .......</p>
    <p>where(Key1)=C local access</p>
    <p>Obj1migrationObj1</p>
    <p>* Key ownership is also transferred for new hash</p>
    <p>When scaling-out, does bursty state migration degrade performance?</p>
  </div>
  <div class="page">
    <p>State Migration Happens Gradually Behind</p>
    <p>Flow state doesnt need to be migrated at once  Packets in the same flow come in bursts  Long inter-arrival time between packet chunks in the same flow</p>
    <p>Micro-threading: Keep processing even with unavoidable blocking remote access</p>
    <p>f1</p>
    <p>f2</p>
    <p>f3</p>
    <p>f4</p>
    <p>f5</p>
    <p>request flow1</p>
    <p>request flow2</p>
    <p>request flow5</p>
    <p>request flow4</p>
    <p>request flow3</p>
    <p>f1</p>
    <p>f1</p>
    <p>f1</p>
    <p>f2</p>
    <p>f3</p>
    <p>request flow1</p>
    <p>request flow3</p>
    <p>request flow2</p>
    <p>L Worst-case J Real network load</p>
  </div>
  <div class="page">
    <p>S6: A Framework to Build Scalable NFs</p>
    <p>More details in the paper</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>S6 Compiler  Compiles S6 C++ extension into plain C++ code  Generates S6 object wrappers (stub, skeleton)  Uses clang 3.6 library</p>
    <p>S6 Runtime  Built in 12K lines of C++ code  Uses boost co-routine for micro-threads</p>
    <p>Applications  PRADS: a Passive Real-time Asset Detection System  Snort: Intrusion Detection System  NAT</p>
  </div>
  <div class="page">
    <p>Applications</p>
    <p>PRADS  a Passive Real-time Asset Detection</p>
    <p>System  allows to access real-time network</p>
    <p>monitoring results  protocols, services, and devices</p>
    <p>State Size (B) Update Access Frequency</p>
    <p>Flow 160 Exclusive Per-packet RW</p>
    <p>Statistics 208 Concurrent Per-packet RW</p>
    <p>Asset 112 + 64n Concurrent Rarely R Per-packet W</p>
    <p>Config 1.16Mi Exclusive Per-packet R Rarely W</p>
    <p>Flow hashtable</p>
    <p>Asset hashtable</p>
    <p>Snort  Intrusion Detection System  We port logic to detect</p>
    <p>malicious packets</p>
    <p>State Size (B) Update Access Frequency</p>
    <p>Flow 160~32Ki Exclusive Per-packet RW</p>
    <p>Whitelist 12 + 28n Exclusive Per-packet RW</p>
    <p>Malicious 12 + 28n Concurrent Per-packet RW</p>
    <p>Config 1.43 Mi Exclusive Per-packet R Rarely W</p>
    <p>Maclicious hashtable</p>
    <p>Whitelisth ashtable</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Scaling experiments  Use Amazon EC2 instance as NF instances (Docket container)  C4.xlarge, 4 cores @ 2.90 GHz</p>
    <p>Workloads: Synthetic TCP traffic  Empirical flow distribution in size and arrival rate</p>
  </div>
  <div class="page">
    <p>S6 Performance During Normal Phase</p>
    <p>NAT PRADS IDS</p>
    <p>Re la te iv e Th</p>
    <p>ro ug hp</p>
    <p>ut</p>
    <p>local-only remote-only distributed/shared</p>
    <p>NAT PRADS IDS La te nc y (u s)</p>
    <p>Keys are evenly distributed through 2 instances  Half of the first state accesses are remote</p>
    <p>J S6 preserves 80 ~ 95% throughput from local-only</p>
    <p>J S6 keeps similar median latency from local-only</p>
    <p>(S6)</p>
  </div>
  <div class="page">
    <p>Space Reorganization Overhead during Scale-out</p>
    <p>Latency distribution of scale-out  Scale-out from 1 to 2 instances (1Mpps  0.5Mpps * 2)</p>
    <p>La te nc y (m</p>
    <p>s)</p>
    <p>Size of objects to migrate</p>
    <p>control channel becomes bottleneck</p>
    <p>S6 shows minimal performance overhead when scaling-out</p>
    <p>sub-millisecond median latencies</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>S6: A framework to build scalable NFs  Allows NF state to be shared/distributed/migrated across instances  Achieves high performance with:</p>
    <p>State abstractions specifying state requirements  When scaling, gradual object migration and space reorganization</p>
    <p>Has minimal performance impact during normal operations as well as scaling event</p>
    <p>https://github.com/NetSys/S6</p>
  </div>
</Presentation>
