<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Regular Expression Learning for Information Extraction</p>
    <p>Yunyao Li*, Rajasekar Krishnamurthy*, Sriram Raghavan*, Shivakumar Vaithyanathan*, H. V. Jagadish</p>
    <p>*IBM Almaden Research Center</p>
    <p>University of Michigan</p>
    <p>http://www.almaden.ibm.com/cs/projects/avatar/</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation</p>
    <p>Regex Learning Problem</p>
    <p>Regex Transformations</p>
    <p>ReLIE Search Algorithm</p>
    <p>Experiments</p>
    <p>Summary</p>
  </div>
  <div class="page">
    <p>Importance of Regular Expression (Regex)</p>
    <p>Regex is essential to many information extraction (IE) tasks</p>
    <p>Email addresses</p>
    <p>Software names</p>
    <p>Credit card numbers</p>
    <p>Social security numbers</p>
    <p>Gene and Protein names</p>
    <p>.</p>
    <p>But  writing regexes for an IE task is not straightforward</p>
    <p>Web collections</p>
    <p>Email compliance</p>
    <p>bioinformatics</p>
  </div>
  <div class="page">
    <p>Phone Number Extraction</p>
    <p>A simple pattern:</p>
    <p>blocks of digits separated by non-word character:</p>
    <p>R0 = (\d+\W)+\d+</p>
    <p>Identifies valid phone numbers (e.g. 800-865-1125, 725-1234)</p>
    <p>Produces invalid matches (e.g. 123-45-6789, 10/19/2002, 1.25 )</p>
    <p>Misses valid phone numbers (e.g. (800) 865-CARE)</p>
  </div>
  <div class="page">
    <p>Software Name Extraction</p>
    <p>A simple pattern:</p>
    <p>blocks of capitalized words followed by version number:</p>
    <p>R0 = ([A-Z]\w*\s*)+[Vv]?(\d+\.?)+</p>
    <p>Identifies valid software names (e.g. Eclipse 3.2, Windows 2000)</p>
    <p>Produces invalid matches (e.g. English 123, Room 301, Chapter 1.2)</p>
    <p>Misses valid software names (e.g. Windows XP)</p>
  </div>
  <div class="page">
    <p>Conventional Regex Writing Process for IE</p>
    <p>Regex0</p>
    <p>Sample Documents</p>
    <p>Match 1 Match 2</p>
    <p>Good Enough?</p>
    <p>N</p>
    <p>Y Regexfinal</p>
    <p>(\d+\W)+\d+(\d+\W)+\d{4}</p>
    <p>Regex1Regex2Regex3 (\d+[\.\s\-])+\d{4}(\d{3}[\.\s\-])+\d{4}</p>
  </div>
  <div class="page">
    <p>Our goal - Learning Regexfinal automatically</p>
    <p>Regex0</p>
    <p>Sample Documents</p>
    <p>Match 1 Match 2</p>
    <p>NegMatch 1</p>
    <p>NegMatch m0 PosMatch 1</p>
    <p>PosMatch n0</p>
    <p>Labeled Matches ReLIE Regexfinal</p>
  </div>
  <div class="page">
    <p>Intuition</p>
    <p>R0 ([A-Z][a-zA-Z]{1,10}\s){1,5}\s*(\w{0,2}\d[\.]?){1,4}</p>
    <p>([A-Z][a-zA-Z]{1,10}\s){1,5}\s*(\ [a-zA-Z] {0,2}\d[\.]?){1,4}</p>
    <p>([A-Z][a-zA-Z]{1,10}\s){1,2}\s*(\w{0,2}\d[\.]?){1,4}</p>
    <p>([A-Z][a-zA-Z]{1,10}\s){1,5}\s* (?!(201||330))(\w{0,2}\d[\.]?) {1,4}</p>
    <p>([A-Z] [a-z] {1,10}\s){1,5}\s*(\\w{0,2}\d[\.]?){1,4}</p>
    <p>([A-Z][a-zA-Z]{1,10}\s){2,4}\s*(\w{0,2}\d[\.]?){1,4}</p>
    <p>Compute F-measure</p>
    <p>F1</p>
    <p>F7</p>
    <p>F8</p>
    <p>F34</p>
    <p>F48</p>
    <p>((?!(Copyright|Page|Physics|Question|    |Article|Issue)</p>
    <p>[A-Z][a-zA-Z]{1,10}\s){1,5}\s*(\w{0,2}\d[\.]?){1,4} F35</p>
    <p>R</p>
    <p>([A-Z] [a-z] {1,10}\s){1,5}\s*( [a-zA-z] {0,2}\d[\.]?){1,4}</p>
    <p>([A-Z] [a-z] {1,10}\s) {1,2} \s*(\\w{0,2}\d[\.]?){1,4}</p>
    <p>(((?!(Copyright|Page|Physics|Question|    |Article|Issue)</p>
    <p>[A-Z] [a-z] {1,10}\s){1,5}\s*(\\w{0,2}\d[\.]?){1,4}</p>
    <p>([A-Z] [a-z] {1,10}\s){1,5} \s*( \d {0,2}\d[\.]?){1,4}</p>
    <p>([A-Z] [a-z] {1,10}\s){1,5} \s*(\\w{0,2}\d[\.]?){1,3}</p>
    <p>([A-Z] [a-z] {1,10}\s){1,5}\s* (?!(201||330))(\w{0,2}\d[\.]?) {1,4}</p>
    <p>..</p>
    <p>Generate candidate regular expressions by modifying current regular expression</p>
    <p>Select the best candidate R  If R has better than current regular expression, repeat the process</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation</p>
    <p>Regex Learning Problem</p>
    <p>Regex Transformations</p>
    <p>ReLIE Search Algorithm</p>
    <p>Experiments</p>
    <p>Summary</p>
  </div>
  <div class="page">
    <p>Regex Learning Problem</p>
    <p>Ideally:</p>
    <p>find the best Rf among all possible regexes</p>
    <p>How do we define the best?</p>
    <p>Highest F-measure over a document collection D.</p>
    <p>We can only compute F-measure based on the labeled data</p>
    <p>Must limited Rf such that any match of Rf is also a match of R0</p>
  </div>
  <div class="page">
    <p>Regex Learning as a Search Problem</p>
    <p>+ + +</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+ +</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+ +</p>
    <p>++ +</p>
    <p>+ +</p>
    <p>++</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+</p>
    <p>+ +</p>
    <p>+</p>
    <p>+ +</p>
    <p>+</p>
    <p>+ + +</p>
    <p>+</p>
    <p>+ +</p>
    <p>+</p>
    <p>+ +</p>
    <p>+ +</p>
    <p>+</p>
    <p>+ +</p>
    <p>+</p>
    <p>+</p>
    <p>+ +</p>
    <p>-</p>
    <p>-</p>
    <p>-</p>
    <p>-</p>
    <p>-</p>
    <p>- -</p>
    <p>- -</p>
    <p>- -</p>
    <p>- -</p>
    <p>+ + --- -</p>
    <p>-M(R0, D)M(Rf, D)</p>
    <p>M(R, D): Matches of R over document collection D.</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation</p>
    <p>Regex Learning Problem</p>
    <p>Regex Transformations</p>
    <p>ReLIE Search Algorithm</p>
    <p>Experiments</p>
    <p>Summary</p>
  </div>
  <div class="page">
    <p>Two Regex Transformations</p>
    <p>Drop-disjunct Transformation:</p>
    <p>R = Ra(R1| R2| Ri| Ri+1|| Rn) Rb  R = Ra (R1|  Ri|) Rb</p>
    <p>Include-Intersect Transformation</p>
    <p>R = RaXRb  R = Ra(XY) Rb</p>
    <p>where Y</p>
  </div>
  <div class="page">
    <p>(\d+\W)+\d+  (\d{3}\W)+\d+</p>
    <p>Applying Drop-Disjunct Transformation</p>
    <p>Character Class Restriction</p>
    <p>E.g. To restrict the matching of non-word characters</p>
    <p>(\d+\W)+\d+  (\d+[\.\s\-])+\d+</p>
    <p>Quantifier Restriction</p>
    <p>E.g. To restrict the number of digits in a block</p>
  </div>
  <div class="page">
    <p>Applying Include-Intersect Transformation</p>
    <p>Negative Dictionaries</p>
    <p>Disallow certain words from matching specific portions of the regex</p>
    <p>E.g. a simple pattern for software name extraction:</p>
    <p>blocks of capitalized words followed by version number:</p>
    <p>R0 = ([A-Z]\w*\s*)+[Vv]?(\d+\.?)+</p>
    <p>Identifies valid software name (e.g. Eclipse 3.2, Windows 2000)</p>
    <p>Produces invalid matches (e.g. ENGLISH 123, Room 301, Chapter 1.2)</p>
    <p>([A-Z]\w*\s*)+[Vv]?(\d+\.?)+  ( [A-Z]\w*\s*)+[Vv]?(\d+\.?)+((?! ENGLISH|Room|Chapter)</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation</p>
    <p>Regex Learning Problem</p>
    <p>Regex Transformations</p>
    <p>ReLIE Search Algorithm</p>
    <p>Experiments</p>
    <p>Summary</p>
  </div>
  <div class="page">
    <p>ReLIE Algorithm</p>
    <p>Ch ar</p>
    <p>ac te</p>
    <p>r c la</p>
    <p>ss</p>
    <p>re st</p>
    <p>ric tio</p>
    <p>ns</p>
    <p>Quantifier restrictions</p>
    <p>Negative dictionary</p>
    <p>R0 ([A-Z][a-zA-Z]{1,10}\s){1,5}\s*(\w{0,2}\d[\.]?){1,4}</p>
    <p>([A-Z][a-zA-Z]{1,10}\s){1,5}\s*(\ [a-zA-Z] {0,2}\d[\.]?){1,4}</p>
    <p>([A-Z][a-zA-Z]{1,10}\s){1,2}\s*(\w{0,2}\d[\.]?){1,4}</p>
    <p>([A-Z][a-zA-Z]{1,10}\s){1,5}\s* (?!(201||330))(\w{0,2}\d[\.]?) {1,4}</p>
    <p>([A-Z] [a-z] {1,10}\s){1,5}\s*(\\w{0,2}\d[\.]?){1,4}</p>
    <p>([A-Z][a-zA-Z]{1,10}\s){2,4}\s*(\w{0,2}\d[\.]?){1,4}</p>
    <p>Compute F-measure</p>
    <p>F1</p>
    <p>F7</p>
    <p>F8</p>
    <p>F34</p>
    <p>F48</p>
    <p>((?!(Copyright|Page|Physics|Question|    |Article|Issue)</p>
    <p>[A-Z][a-zA-Z]{1,10}\s){1,5}\s*(\w{0,2}\d[\.]?){1,4}</p>
    <p>Ch ar</p>
    <p>ac te</p>
    <p>r c la</p>
    <p>ss</p>
    <p>re st</p>
    <p>ric tio</p>
    <p>ns</p>
    <p>Quantifier restrictions</p>
    <p>Negative dictionary</p>
    <p>F35</p>
    <p>R</p>
    <p>([A-Z] [a-z] {1,10}\s){1,5}\s*( [a-zA-z] {0,2}\d[\.]?){1,4}</p>
    <p>([A-Z] [a-z] {1,10}\s) {1,2} \s*(\\w{0,2}\d[\.]?){1,4}</p>
    <p>(((?!(Copyright|Page|Physics|Question|    |Article|Issue)</p>
    <p>[A-Z] [a-z] {1,10}\s){1,5}\s*(\\w{0,2}\d[\.]?){1,4}</p>
    <p>([A-Z] [a-z] {1,10}\s){1,5} \s*( \d {0,2}\d[\.]?){1,4}</p>
    <p>([A-Z] [a-z] {1,10}\s){1,5} \s*(\\w{0,2}\d[\.]?){1,3}</p>
    <p>([A-Z] [a-z] {1,10}\s){1,5}\s* (?!(201||330))(\w{0,2}\d[\.]?) {1,4}</p>
    <p>..</p>
    <p>Generate candidate regular expressions by applying a single transformation  Select the best candidate R based on F-measure on training corpus  If R has better F-measure than current regular expression, repeat the process</p>
    <p>Use validation set to avoid over-fitting</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation</p>
    <p>Regex Learning Problem</p>
    <p>Regex Transformations</p>
    <p>ReLIE Search Algorithm</p>
    <p>Experiments</p>
    <p>Summary</p>
  </div>
  <div class="page">
    <p>Experimental Set Up</p>
    <p>Data Set</p>
    <p>EWeb: 50K web pages from IBM intranet</p>
    <p>AWeb: 50K web pages from University of Michigan web site.</p>
    <p>AWeb-S: subset of 10K pages from AWeb  Email: 10K emails from Enron collection</p>
    <p>Extraction Tasks SoftwareNameTask CourseNumberTask</p>
    <p>PhoneNumberTask URLTask</p>
    <p>Comparison Study</p>
    <p>ReLIE</p>
    <p>Conditional Random Fields (CRF):</p>
    <p>Base feature set  matches corresponding to the input regex</p>
    <p>three adjacent words to each side of the matches</p>
  </div>
  <div class="page">
    <p>Extraction Quality</p>
    <p>ReLIE performs comparably with CRF with a slight edge with limited training data</p>
    <p>Program repeatedly failed at training phrase.</p>
  </div>
  <div class="page">
    <p>Cross-domain Evaluation</p>
    <p>ReLIE significantly outperforms CRF for all three tasks</p>
    <p>(b) CourseNameTask is not tested, as course names exist only in AWeb.</p>
  </div>
  <div class="page">
    <p>Performance</p>
    <p>ReLIE is an order of magnitude faster than CRF for both training and testing</p>
    <p>Average Training/Testing Time (sec)(with 40% data for training)</p>
  </div>
  <div class="page">
    <p>What has ReLIE learned?</p>
    <p>Patterns learned by ReLIE are similar to features manually given to CRF</p>
  </div>
  <div class="page">
    <p>ReLIE as Feature Extractor for CRF</p>
    <p>C+RL: CRF + features learned by ReLIE</p>
    <p>Token level features learned by ReLIE  helpful when the training data is small</p>
    <p>Character level features learned by ReLIE  always helpful</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation</p>
    <p>Regex Learning Problem</p>
    <p>Regex Transformations</p>
    <p>ReLIE Search Algorithm</p>
    <p>Experiments</p>
    <p>Summary</p>
  </div>
  <div class="page">
    <p>ReLIE</p>
    <p>Effective for learning regexes for certain classes of IE</p>
    <p>Particularly useful when</p>
    <p>cross-domain, or</p>
    <p>limited training data</p>
    <p>Potentially becoming a powerful feature extractor for CRF and other machine learning algorithms.</p>
  </div>
  <div class="page">
    <p>http://www.almaden.ibm.com/cs/projects/avatar/</p>
  </div>
</Presentation>
