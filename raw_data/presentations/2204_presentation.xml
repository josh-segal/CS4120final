<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>DeclStore: Layering is for the Faint of Heart</p>
    <p>Noah Watkins, Michael Sevilla, Ivo Jimenez, Kathryn Dahlgren, Peter Alvaro, Shel Finkelstein, Carlos Maltzahn</p>
  </div>
  <div class="page">
    <p>Layers on layers on layers</p>
    <p>Middleware</p>
    <p>Application</p>
    <p>Special App</p>
    <p>Unified Storage</p>
    <p>Storage Interfaces</p>
    <p>Object Block File</p>
    <p>Logging Key-value</p>
    <p>Special App</p>
    <p>POSIX Fancy Storage</p>
  </div>
  <div class="page">
    <p>Application-specific storage systems</p>
    <p>Middleware</p>
    <p>Application</p>
    <p>Special App</p>
    <p>Unified Storage</p>
    <p>Storage Interfaces</p>
    <p>Object Block File</p>
    <p>Logging Key-value</p>
    <p>Special App</p>
    <p>POSIX Fancy Storage</p>
  </div>
  <div class="page">
    <p>Unified storage systems</p>
    <p>Middleware</p>
    <p>Application</p>
    <p>Special App</p>
    <p>Unified Storage</p>
    <p>Storage Interfaces</p>
    <p>Object Block File</p>
    <p>Logging Key-value</p>
    <p>Special App</p>
    <p>POSIX Fancy Storage</p>
    <p>Examples  OnTap  Swift  Ceph  GPFS  EMC</p>
  </div>
  <div class="page">
    <p>Eliminating layers: big challenges, big rewards</p>
    <p>Talk Outline</p>
    <p>Motivating unified storage  Storage interface design space  Declarative storage interfaces</p>
    <p>Unified Storage</p>
    <p>Storage Interfaces</p>
    <p>Object Block File</p>
    <p>Logging Key-value</p>
    <p>Special App</p>
    <p>Big Question</p>
    <p>If unified storage becomes the new normal, what new challenges will need to be addressed in system design?</p>
  </div>
  <div class="page">
    <p>Motivation: systems trend towards generality</p>
    <p>Specialized real-time and embedded systems</p>
    <p>Embedded Linux and RT_PREEMPT</p>
    <p>Specialized unstructured data management systems</p>
    <p>JSON data type in relational database management systems</p>
    <p>Specialized storage systems Embedded Ceph and unified system</p>
    <p>Technology Trend Example</p>
  </div>
  <div class="page">
    <p>Examples  Locking, Logging,</p>
    <p>Concurrency control,  Metadata</p>
    <p>management  Remote compute</p>
    <p>Motivation: breaking the narrow waist model</p>
    <p>User Defined Classes</p>
    <p>Developers willing to break layers and use non-standard APIs 7</p>
  </div>
  <div class="page">
    <p>Why in practice do people break down layers?</p>
    <p>Middleware</p>
    <p>Application</p>
    <p>Special App</p>
    <p>Unified Storage</p>
    <p>Storage Interfaces</p>
    <p>Object Block File</p>
    <p>Logging Key-value</p>
    <p>Special App</p>
    <p>POSIX Fancy Storage</p>
    <p>Cod e pa</p>
    <p>th a nd A</p>
    <p>PI in effic</p>
    <p>ienc ies</p>
    <p>Dup licat</p>
    <p>ion of s</p>
    <p>ervi ces</p>
    <p>,</p>
    <p>ove r-pr</p>
    <p>ovis ioni</p>
    <p>ng, cos</p>
    <p>t, ris ks</p>
  </div>
  <div class="page">
    <p>Unified storage has its own set of challenges</p>
    <p>Middleware</p>
    <p>Application</p>
    <p>Special App</p>
    <p>Unified Storage</p>
    <p>Storage Interfaces</p>
    <p>Object Block File</p>
    <p>Logging Key-value</p>
    <p>Special App</p>
    <p>POSIX Fancy Storage</p>
    <p>Cod e pa</p>
    <p>th a nd A</p>
    <p>PI in effic</p>
    <p>ienc ies</p>
    <p>Dup licat</p>
    <p>ion of s</p>
    <p>ervi ces</p>
    <p>,</p>
    <p>ove r-pr</p>
    <p>ovis ioni</p>
    <p>ng, cos</p>
    <p>t, ris ks</p>
    <p>Por tabi</p>
    <p>lity, QoS</p>
    <p>, Sa fety</p>
    <p>(plu s co</p>
    <p>de p ath</p>
    <p>inef ficie</p>
    <p>ncie s)</p>
  </div>
  <div class="page">
    <p>Exploring design challenges in unified storage</p>
    <p>Middleware</p>
    <p>Application</p>
    <p>Special App</p>
    <p>Unified Storage</p>
    <p>Storage Interfaces</p>
    <p>Object Block File</p>
    <p>Logging Key-value</p>
    <p>Special App</p>
    <p>POSIX Fancy Storage</p>
    <p>Cod e pa</p>
    <p>th a nd A</p>
    <p>PI in effic</p>
    <p>ienc ies</p>
    <p>Dup licat</p>
    <p>ion of s</p>
    <p>ervi ces</p>
    <p>,</p>
    <p>ove r-pr</p>
    <p>ovis ioni</p>
    <p>ng, cos</p>
    <p>t, ris ks</p>
  </div>
  <div class="page">
    <p>Malacology: programmable interface research platform</p>
    <p>Target storage interface (Goal)</p>
    <p>Internal sys services (Building blocks)</p>
    <p>Composed, generic service glue layer</p>
    <p>Malacology: A Programmable Storage System, M. Sevilla, N. Watkins, I. Jimenez, P. Alvaro, S. Finkelstein, J. LeFevre, C. Maltzahn, EuroSys 17 Mantle: A Programmable Metadata Load Balancer for the Ceph File System, M. Sevilla, N. Watkins, C. Maltzahn, I. Nassi, S. Brandt, et. al, SC 15 CORFU: A Shared Log Design for Flash Clusters, Mahesh Balakrishnan, Dahlia Malkhi, Vijayan Prabhakaran, and Ted Wobber, Michael Wei, et. al, NSDI 12</p>
  </div>
  <div class="page">
    <p>Keeping pace with evolving storage systems</p>
    <p>Hard-wired prototype implementations</p>
    <p>How to take advantage of...  Software upgrades  New hardware  Additional services  Performance features</p>
  </div>
  <div class="page">
    <p>Example: building the CORFU shared-log interface</p>
    <p>Append and random reads  I/O parallelism (striping)  Soft-state network counter</p>
    <p>Challenges  Find a good mapping  Performance optimizations  Minimal maintenance</p>
    <p>CORFU: A Shared Log Design for Flash Clusters, Mahesh Balakrishnan, Dahlia Malkhi, Vijayan Prabhakaran, and Ted Wobber, Michael Wei, et. al, NSDI 12</p>
    <p>??</p>
  </div>
  <div class="page">
    <p>Example: building CORFU distributed shared-log</p>
    <p>Log partitioning?: 1-1, striping, etc...</p>
    <p>Implementation options  Partitioning</p>
  </div>
  <div class="page">
    <p>Example: building CORFU distributed shared-log</p>
    <p>Log partitioning?: 1-1, striping, etc...</p>
    <p>Implementation options  Partitioning  Metadata</p>
  </div>
  <div class="page">
    <p>Example: building CORFU distributed shared-log</p>
    <p>Log partitioning?: 1-1, striping, etc...</p>
    <p>ByteStream, K/V  FS (xfs, btrfs)  BlueStore  K/V (Rocks, LMDB)</p>
    <p>Implementation options  Partitioning  Metadata  I/O interfaces</p>
  </div>
  <div class="page">
    <p>Example: building CORFU distributed shared-log</p>
    <p>Log partitioning?: 1-1, striping, etc...</p>
    <p>ByteStream, K/V  FS (xfs, btrfs)  BlueStore  K/V (Rocks, LMDB)</p>
    <p>Implementation options  Partitioning  Metadata  I/O interfaces</p>
    <p>Constructed 4 versions  2 partitioning * 2 I/O interfaces  Partitioning (1-1, striping)  I/O interface (bytestream, K/V)</p>
  </div>
  <div class="page">
    <p>Example: building CORFU distributed shared-log</p>
    <p>Log partitioning?: 1-1, striping, etc...</p>
    <p>ByteStream, K/V  FS (xfs, btrfs)  BlueStore  K/V (Rocks, LMDB)</p>
    <p>Implementation options  Partitioning  Metadata  I/O interfaces</p>
    <p>Constructed 4 versions  2 partitioning * 2 I/O interfaces  Partitioning (1-1, striping)  I/O interface (bytestream, K/V)</p>
    <p>Hard-wired implementations  Few 1000s LOC  Manually optimize and switch</p>
    <p>between approaches</p>
  </div>
  <div class="page">
    <p>Example: shared-log performance toss-up in 2014  Four implementations  Ceph version circa 2014  Graph takeaways</p>
    <p>Clear performance losers</p>
    <p>Similar top performers  Our claim</p>
    <p>Select simpler implementation  Added complexity for no benefit</p>
    <p>What is complexity?  Lines of code  Conceptual</p>
    <p>Performance Comparison of 4 Designs</p>
    <p>A pp</p>
    <p>en ds</p>
    <p>/ S</p>
    <p>ec</p>
    <p>Ceph 2014</p>
  </div>
  <div class="page">
    <p>Example: clear design choice in 2016  Same implementations  Same hardware / benchmark  Newer version of Ceph  Clear performance winner</p>
    <p>in 2016</p>
    <p>Takeaway:</p>
    <p>A reasonable choice in 2014 would be a poor choice in 2016 after a simple upgrade</p>
    <p>Performance Comparison of 4 Designs</p>
    <p>A pp</p>
    <p>en ds</p>
    <p>/ S</p>
    <p>ec</p>
    <p>Ceph 2014</p>
    <p>Ceph 2016A pp</p>
    <p>en ds</p>
    <p>/ S</p>
    <p>ec</p>
  </div>
  <div class="page">
    <p>Problem: navigation of large design space</p>
    <p>interfaces / data models</p>
    <p>heterogeneous hardware / memories features &amp;</p>
    <p>tunables (&gt;1000 in Ceph)</p>
    <p>time / versions</p>
    <p>you are here</p>
  </div>
  <div class="page">
    <p>DeclStore: express storage interfaces declaratively  Freedom from storage system and domain expertise  Abstractions over storage services and interfaces  The point is we need a high-level language</p>
    <p>Many possible mappings  Many degrees of freedom</p>
    <p>Generate storage interface implementations  Exploit relational database optimization research</p>
  </div>
  <div class="page">
    <p>DeclStore: building on a strong foundation  Based on Bloom programming language</p>
    <p>High-level declarative language (Alvaro, CIDR `11)  Abstract relational data model  Programs are queries</p>
    <p>Many degrees of freedom on reordering  Subject to optimization</p>
    <p>Evidence this is possible...</p>
    <p>LogicBlox (Aref, SIGMOD 2015)</p>
    <p>Dedalus (Alvaro, et. al, Datalog 2010)</p>
    <p>Declarative Networking (Loo, SIGMOD 2006)</p>
  </div>
  <div class="page">
    <p>Example: a declarative specification for CORFU  System state modeled as</p>
    <p>a set of relations  Persistent state  Input/Output</p>
    <p># persistent relations table :epoch, [:epoch] table :log, [:pos] =&gt; [:state, :data]</p>
    <p># interfaces are also like tables interface input, :op, [:type, :pos, :epoch] =&gt; [:data] interface output, :ret, [:type, :pos, :epoch] =&gt; [:retval]</p>
    <p>bloom :write do temp :valid_write &lt;= write_op.notin(found_op) log &lt;+ valid_write { |o| [o.pos, 'valid', o.data] } ret &lt;= valid_write { |o| [o.type, o.pos, o.epoch, 'ok'] } ret &lt;= write_op.notin(valid_write) { |o| [o.type, o.pos, o.epoch, 'read-only'] } end</p>
    <p>Full specification  Just another slides worth  Compare 1Ks LOC C++</p>
    <p>Interfaces are queries over a request stream</p>
    <p>Operate on persistent state  Collection operations</p>
    <p>Brados: Declarative, Programmable Object Storage, Noah Watkins, Michael Sevilla, Ivo Jimenez, Neha Ojha, Peter Alvaro, Carlos Maltzahn, UCSC-SOE-16-12</p>
  </div>
  <div class="page">
    <p>Whats the catch?  This is a storage system, not a database...  Generality introduces overhead  Additional complexity and layers</p>
    <p>We dont want layers!</p>
    <p>The cost of online optimization</p>
  </div>
  <div class="page">
    <p>Taking advantage of time scales: offline optimization  We are generating storage service implementations  Automate integration on new features and hardware  Planned upgrade points v.s. per-request optimization</p>
    <p>System Upgrade</p>
    <p>Point</p>
    <p>System Upgrade</p>
    <p>Point</p>
    <p>System Upgrade</p>
    <p>Point Opt.</p>
    <p>DeclStore Interface Definition</p>
    <p>Opt.</p>
    <p>Timescale (Month / Year) Request (&lt; 1ms)</p>
  </div>
  <div class="page">
    <p>Example: a declarative specification for CORFU  No hard-wired choice of</p>
    <p>storage interface!  Bytestream vs K/V  Partitioning strategy</p>
    <p># persistent relations table :epoch, [:epoch] table :log, [:pos] =&gt; [:state, :data]</p>
    <p># interfaces are also like tables interface input, :op, [:type, :pos, :epoch] =&gt; [:data] interface output, :ret, [:type, :pos, :epoch] =&gt; [:retval]</p>
    <p>bloom :write do temp :valid_write &lt;= write_op.notin(found_op) log &lt;+ valid_write { |o| [o.pos, 'valid', o.data] } ret &lt;= valid_write { |o| [o.type, o.pos, o.epoch, 'ok'] } ret &lt;= write_op.notin(valid_write) { |o| [o.type, o.pos, o.epoch, 'read-only'] } end</p>
    <p>Convincingly correct!</p>
    <p>Take advantage of existing analysis tools and techniques!</p>
  </div>
  <div class="page">
    <p>Example: performance benefit of group commit  Ceph I/O handling is conservative</p>
    <p>Queuing, locking, ordering</p>
    <p>Log operations are independent  Determined through analysis  Amortize across I/O and code path</p>
    <p>Basic Operation Batching  Lots of internal code traversal</p>
    <p>Using efficient interfaces  Vector or range-based interfaces</p>
    <p>See paper for more details  Cost models and outliers</p>
  </div>
  <div class="page">
    <p>Conclusion: expanding the set of storage interfaces...</p>
    <p>is becoming increasingly common  new systems being built  old systems being adapted</p>
    <p>will create an entirely new set of challenges; we showed  hard-wired solutions are difficult to maintain  even a basic software upgrade can have a big impact</p>
    <p>through declarative specifications can address many concerns  lower maintenance costs  automate system evolution</p>
  </div>
  <div class="page">
    <p>Thank you Questions? DeclStore: Layering is for the Faint of Heart</p>
    <p>Noah Watkins, Michael Sevilla, Ivo Jimenez, Kathryn Dahlgren, Peter Alvaro, Shel Finkelstein, Carlos Maltzahn</p>
  </div>
</Presentation>
