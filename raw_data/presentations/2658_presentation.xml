<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Well-Supported Semantics for Description</p>
    <p>Logic Programs</p>
    <p>IJCAI 2011, Barcelona, Spain</p>
    <p>Yi-Dong Shen</p>
    <p>Institute of Software, Chinese Academy of Sciences, Beijing, China</p>
    <p>http://lcs.ios.ac.cn/~ydshen</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>I. Background and Motivation</p>
    <p>II. DL-Programs</p>
    <p>III. Well-Supported Models</p>
    <p>IV. Well-Supported Answer Set Semantics</p>
    <p>V. Related Work</p>
    <p>VI. Summary and Future Work</p>
  </div>
  <div class="page">
    <p>Semantic Web Stack</p>
  </div>
  <div class="page">
    <p>Integration in the Semantic Web</p>
    <p>Ontologies describe terminological knowledge.</p>
    <p>Rules model constraints and exceptions over the</p>
    <p>ontologies.</p>
    <p>They provide complementary descriptions of the same</p>
    <p>problem domain, so a unifying logic is used to</p>
    <p>integrate the two components, and</p>
    <p>study the semantic properties of the integrated knowledge base</p>
  </div>
  <div class="page">
    <p>Three Forms of Integration</p>
    <p>Loose integration</p>
    <p>Ontologies and rules share no predicate symbols (Eiter et al.</p>
    <p>Tight (or Hybrid) integration</p>
    <p>Ontologies and rules share some predicate symbols (Rosati</p>
    <p>Full integration</p>
    <p>Ontologies and rules share the same vocabulary (de Bruijn et</p>
    <p>al. 2008, KR; Motik and Rosati 2010, JACM).</p>
  </div>
  <div class="page">
    <p>DL-Programs</p>
    <p>We consider a loose integration, called Description logic</p>
    <p>programs (or DL-programs) (Eiter et al. 2008, AIJ)</p>
    <p>A DL-program is  = (, )</p>
    <p>: a DL knowledge base (ontologies).</p>
    <p>: an extended logic program under the answer set semantics.</p>
  </div>
  <div class="page">
    <p>Semantic Issues with DL-Programs</p>
    <p>Weak answer set semantics (Eiter et al. 2008, AIJ)</p>
    <p>The authors noted that an obvious disadvantage of the</p>
    <p>semantics is that it may produce counterintuitive answer sets</p>
    <p>with circular justifications by self-supporting loops.</p>
    <p>Strong answer set semantics (Eiter et al. 2008, AIJ)</p>
    <p>We observed that the problem of circular justifications persists</p>
    <p>in this semantics.</p>
    <p>FLP answer set semantics (Eiter et al. 2005, IJCAI)</p>
    <p>We observed that the problem of circular justifications persists</p>
    <p>in this semantics.</p>
  </div>
  <div class="page">
    <p>Semantic Issues with DL-Programs</p>
    <p>Therefore, it presents an interesting yet challenging</p>
    <p>open problem to develop a new semantics for DL</p>
    <p>programs, which produces answer sets free of</p>
    <p>circular justifications.</p>
  </div>
  <div class="page">
    <p>Circular Justifications</p>
    <p>A model  of a logic program  is circularly justified if</p>
    <p>the truth of some    is supported by itself in .</p>
    <p>Examples</p>
    <p>is circularly justified by a self-supporting loop:</p>
    <p>where  =  and  =    ,  ; -() . Let  = () .</p>
    <p>()   is circularly justified by a self-supporting loop:</p>
    <p>,  ; -()  ()</p>
  </div>
  <div class="page">
    <p>Fages Well-Supportedness Condition</p>
    <p>For normal logic programs, the problem of circular</p>
    <p>justifications is elegantly handled by Fages well</p>
    <p>supportedness condition (Fages 1994, JMLCS).</p>
    <p>It defines a level mapping, which prevents well-supported</p>
    <p>models from circular justifications.</p>
    <p>It is a key property to characterize the standard answer</p>
    <p>set semantics (Gelfond and Lifschitz 1991, NJC) :</p>
    <p>A model of a normal logic program is an answer set under the standard</p>
    <p>answer set semantics iff it is well-supported (Fages 1994, JMLCS).</p>
  </div>
  <div class="page">
    <p>Fages Well-Supportedness Condition</p>
    <p>Can we extend Fages well-supportedness condition from</p>
    <p>normal logic programs to DL-programs to overcome</p>
    <p>circular justifications?</p>
    <p>Our answer is Yes.</p>
  </div>
  <div class="page">
    <p>Our Contributions</p>
    <p>We solve the semantic problem of circular justifications</p>
    <p>with DL-programs by</p>
    <p>extending Fages well-supportedness condition from normal</p>
    <p>logic programs to DL-programs, and</p>
    <p>defining a well-supported semantics for DL-programs, which</p>
    <p>produces answer sets free of circular justifications.</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>I. Background and Motivation</p>
    <p>II. DL-Programs</p>
    <p>III. Well-Supported Models</p>
    <p>IV. Well-Supported Answer Set Semantics</p>
    <p>V. Related Work</p>
    <p>VI. Summary and Future Work</p>
  </div>
  <div class="page">
    <p>Notation</p>
    <p>A DL-program is  = (, )</p>
    <p>: a DL knowledge base built over  =   ,</p>
    <p>A, R, I: atomic concepts, atomic roles, and individuals.</p>
    <p>: a rule base built over  = ,</p>
    <p>P, C: predicate symbols, and constants</p>
    <p>= , and</p>
    <p>: Herbrand base of  built over</p>
    <p>ground(): ground instances (relative to ) of all rules in</p>
  </div>
  <div class="page">
    <p>Notation</p>
    <p>consists of rules of the form</p>
    <p>1,  , ,  1,  ,</p>
    <p>where  is an atom, and each  and  are atoms or dl-atoms</p>
    <p>A dl-atom is an interface between  and :</p>
    <p>,1 1 1,  ,   ; -()</p>
    <p>each Si is a concept or role built from   , each p   is a</p>
    <p>predicate symbol, () is a dl-query and</p>
  </div>
  <div class="page">
    <p>Satisfaction Relation</p>
    <p>Definition (Eiter et al. 2008, AIJ) Let  = (, ) and  be an</p>
    <p>interpretation. Define satisfaction under , denoted , as follows:</p>
    <p>if  =1      , where</p>
    <p>*** Any    is an interpretation of  = (, ). Let  =  \ and</p>
    <p>= *|  }</p>
  </div>
  <div class="page">
    <p>Program Transformation Reducts</p>
    <p>Given an interpretation , FLP reduct   is obtained from</p>
    <p>ground() by</p>
    <p>deleting every rule r with   .</p>
    <p>Weak transformation reduct   is obtained from</p>
    <p>by</p>
    <p>deleting all negative literals and all dl-atoms.</p>
    <p>Strong transformation reduct   is obtained from</p>
    <p>by</p>
    <p>deleting all negative literals and all nonmonotonic dl-atoms.</p>
    <p>*** A ground dl-atom  is monotonic</p>
    <p>if for any      ,    implies   .</p>
  </div>
  <div class="page">
    <p>Three Semantics of DL-Programs</p>
    <p>Weak/strong/FLP answer set semantics</p>
    <p>A model  of  = (, ) is a weak (resp. strong and FLP)</p>
    <p>answer set if  is a minimal model of   (resp.</p>
    <p>and   )</p>
    <p>(Eiter et al. 2008, AIJ; Eiter et al. 2005, IJCAI).</p>
    <p>FLP answer sets are minimal models, but weak/strong</p>
    <p>answer sets may not.</p>
  </div>
  <div class="page">
    <p>Circular Justification Problem</p>
    <p>The three answer set semantics suffer from the</p>
    <p>problem of circular justifications.</p>
    <p>Example Consider a DL-program  = ,  , where  =  and</p>
    <p>:</p>
    <p>= *  ,   + is the only model of . It is also a weak, a strong,</p>
    <p>and an FLP answer set.     is circularly justified by a self</p>
    <p>supporting loop:</p>
    <p>()</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>I. Background and Motivation</p>
    <p>II. DL-Programs</p>
    <p>III. Well-Supported Models</p>
    <p>IV. Well-Supported Answer Set Semantics</p>
    <p>V. Related Work</p>
    <p>VI. Summary and Future Work</p>
  </div>
  <div class="page">
    <p>Fages Well-Supportedness</p>
    <p>Fages well-supportedness condition (Fages 1994, JMLCS):</p>
    <p>A model I of a normal logic program is well-supported if there is a</p>
    <p>level mapping on I such that for every   , there is a rule</p>
    <p>1,  , ,  1,  ,</p>
    <p>where I satisfies the rule body and the level of each  is below the</p>
    <p>level of .</p>
    <p>This well-supportedness condition does not apply to</p>
    <p>DL-programs, due to occurrences of dl-atoms.</p>
  </div>
  <div class="page">
    <p>up to Satisfaction (, )</p>
    <p>To handle dl-atoms, we introduce up to satisfaction.</p>
    <p>Informally, for     ,</p>
    <p>,    if for every  with     ,   .</p>
    <p>,    implies that the truth of  depends only on</p>
    <p>and , and is independent of \E.</p>
    <p>For instance, if  = *+,  = *, , + and  =   ,</p>
    <p>then for every  with     ,   . Therefore,</p>
    <p>,   .</p>
  </div>
  <div class="page">
    <p>up to Satisfaction (, )</p>
    <p>Definition Let  = ,  and     . For any</p>
    <p>ground literal , define        ,</p>
    <p>denoted ,   , as follows:</p>
    <p>,    if   ; ,     if   .</p>
    <p>,    if for every  with     ,   ;</p>
    <p>,     if for no  with     ,   .</p>
  </div>
  <div class="page">
    <p>Monotonicity of (, )</p>
    <p>Proposition Let  be a ground atom or dl-atom. For any</p>
    <p>1  2  ,</p>
    <p>if 1,    then 2,   ;</p>
    <p>and if 1,     then 2,    .</p>
    <p>We use this up to satisfaction to extend Fages well</p>
    <p>supportedness condition and define well-supported</p>
    <p>models for DL-programs.</p>
  </div>
  <div class="page">
    <p>Well-Supported Models</p>
    <p>Informally, a model I of a DL-program is strongly well-supported</p>
    <p>if there is a level mapping on I such that for every   , there is</p>
    <p>and a rule   (), where ,     and the</p>
    <p>level of each element in  is below the level of .</p>
    <p>Put another way,</p>
    <p>is supported by (),</p>
    <p>while the truth of () is determined by  and ,</p>
    <p>where no    is circularly dependent on a.</p>
    <p>This guarantees that strongly well-supported models are free of</p>
    <p>circular justifications.</p>
  </div>
  <div class="page">
    <p>Well-Supported Models</p>
    <p>Definition A model I of a DL-program  = (, ) is</p>
    <p>strongly well-supported if there exists a strict well-founded</p>
    <p>partial order  on I such that for every   , there is</p>
    <p>and a rule   () in   such that</p>
    <p>,     and for every   ,   .</p>
  </div>
  <div class="page">
    <p>Well-Supported Models</p>
    <p>Example Consider a DL-program  = ,  , where</p>
    <p>=  and</p>
    <p>:</p>
    <p>= *  ,   + is the only model of . It is also a weak,</p>
    <p>a strong, and an FLP answer set. However,  is not a</p>
    <p>strongly well-supported model, since for     there is</p>
    <p>no    satisfying the well-supportedness condition.</p>
  </div>
  <div class="page">
    <p>Well-Supported Models</p>
    <p>Theorem Let  = ,  be a DL-program, where</p>
    <p>=  and  is a normal logic program. A model  is a</p>
    <p>strongly well-supported model of  iff  is a well</p>
    <p>supported model of  under Fages definition.</p>
    <p>As a result, Fages well-supportedness condition is</p>
    <p>extended to DL-programs.</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>I. Background and Motivation</p>
    <p>II. DL-Programs</p>
    <p>III. Well-Supported Models</p>
    <p>IV. Well-Supported Answer Set Semantics</p>
    <p>V. Related Work</p>
    <p>VI. Summary and Future Work</p>
  </div>
  <div class="page">
    <p>Consequence Operator  ,</p>
    <p>Definition Let  = (, ) and     . Define</p>
    <p>,  = *|       and ,     }</p>
    <p>Monotonicity property of  ,</p>
    <p>Theorem Let  be a model of . For any 1  2  ,</p>
    <p>1,    2,   .</p>
  </div>
  <div class="page">
    <p>Fixpoint   ,</p>
    <p>,  : a fixpoint from the monotone sequence</p>
    <p>,</p>
    <p>=0</p>
    <p>with</p>
    <p>,  ,</p>
    <p>Theorem Let  be a model of  = (, ). If  =</p>
    <p>,  then  is a minimal model of .</p>
  </div>
  <div class="page">
    <p>Well-Supported Semantics</p>
    <p>Definition Let  be a model of a DL-program  = (, ).</p>
    <p>is an answer set of  if  =   ,  .</p>
    <p>Answer sets are exactly strongly well-supported models</p>
    <p>Theorem  is an answer set of  iff  is a strongly well</p>
    <p>supported model of .</p>
    <p>Therefore, we call such answer sets well-supported</p>
    <p>answer sets, which are free of circular justifications.</p>
  </div>
  <div class="page">
    <p>Well-Supported Semantics</p>
    <p>Theorem If  is a well-supported answer set of , then</p>
    <p>answer set of .</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>I. Background and Motivation</p>
    <p>II. DL-Programs</p>
    <p>III. Well-Supported Models</p>
    <p>IV. Well-Supported Answer Set Semantics</p>
    <p>V. Related Work</p>
    <p>VI. Summary and Future Work</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>There are circular justifications by self-supporting loops.</p>
    <p>The problem of circular justifications persists.</p>
    <p>Weak/strong answer sets may not be minimal models.</p>
    <p>FLP answer sets are minimal models.</p>
    <p>The problem of circular justifications persists.</p>
    <p>The problem of circular justifications persists.</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>FLP answer set semantics is based on FLP-reduct, a concept</p>
    <p>introduced in (Faber et al. 2004, JELIA) to define answer set</p>
    <p>semantics for logic programs with aggregates.</p>
    <p>Our up to satisfaction relation is inspired by conditional</p>
    <p>satisfaction, a concept introduced in (Son et al. 2007, JAIR) to</p>
    <p>define answer set semantics for logic programs with</p>
    <p>aggregates.</p>
    <p>DL-programs and logic programs with aggregates are closely</p>
    <p>related. Exploiting the deep connection presents an interesting</p>
    <p>future work.</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>I. Background and Motivation</p>
    <p>II. DL-Programs</p>
    <p>III. Well-Supported Models</p>
    <p>IV. Well-Supported Answer Set Semantics</p>
    <p>V. Related Work</p>
    <p>VI. Summary and Future Work</p>
  </div>
  <div class="page">
    <p>Summary and Future Work</p>
    <p>Summary:</p>
    <p>To resolve the semantic problem of circular justifications</p>
    <p>with DL-programs, we</p>
    <p>extended Fages well-supportedness condition from</p>
    <p>normal logic programs to DL-programs, and</p>
    <p>presented a well-supported semantics for DL</p>
    <p>programs, which produces answer sets free of</p>
    <p>circular justifications.</p>
  </div>
  <div class="page">
    <p>Summary and Future Work</p>
    <p>Future work:</p>
    <p>Extend the work to DL-programs with disjunctive rule</p>
    <p>heads.</p>
    <p>Study the complexity properties.</p>
    <p>Exploit the connection between DL-programs and</p>
    <p>logic programs with aggregates.</p>
  </div>
  <div class="page">
    <p>Thanks !</p>
    <p>Yi-Dong Shen</p>
    <p>ydshen@ios.ac.cn</p>
    <p>http://lcs.ios.ac.cn/~ydshen</p>
  </div>
</Presentation>
