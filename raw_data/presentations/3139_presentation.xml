<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>PCF: Scaling Secure Computation</p>
    <p>Benjamin Kreuter, abhi shelat,</p>
    <p>Benjamin Mood, Kevin Butler</p>
    <p>University of Virginia University of Oregon</p>
  </div>
  <div class="page">
    <p>Secure 2-Party Computation</p>
    <p>x= x1 x2 x3 ... xn  y= y1 y2 y3 ... ym</p>
    <p>f ( x , y)</p>
    <p>f A ( x , y) f B ( x , y)</p>
    <p>Alice Bob</p>
    <p>Guarantee: x and y remain private, outputs are correct</p>
    <p>Key result [Yao82]:</p>
    <p>Secure 2-party protocols exist for any computable function</p>
  </div>
  <div class="page">
    <p>Secure 2-Party Computation</p>
    <p>x= x1 x2 x3 ... xn  y= y1 y2 y3 ... ym</p>
    <p>f ( x , y)</p>
    <p>f A ( x , y) f B ( x , y)</p>
    <p>Alice Bob</p>
    <p>Guarantee: x and y remain private, outputs are correct</p>
    <p>Need oblivious representation of f x = read_input(); if (x &gt; 5) {</p>
    <p>y = 7; } else {</p>
    <p>y = 12; }</p>
    <p>Leaks information about x</p>
  </div>
  <div class="page">
    <p>Oblivious Programs</p>
    <p>Control flow, memory access, etc. are independent of program inputs</p>
    <p>Key result: Pippenger and Fischer oblivious Turing machine construction  Logarithmic overhead  Also gives generic circuit family construction</p>
  </div>
  <div class="page">
    <p>Oblivious Programs</p>
    <p>x = read_input(); if (x &gt; 5) {</p>
    <p>y = 7; } else {</p>
    <p>y = 12; }</p>
    <p>x = read_input(); c1 = x &gt; 5; y1 = 7; c2 = !c1; y2 = 12; y = (y1 &amp; c1) || (y2 &amp; c2);</p>
    <p>Multiplexer</p>
  </div>
  <div class="page">
    <p>Prior Work</p>
    <p>Thousands [MNPS'04]</p>
    <p>Millions [sS'11]</p>
    <p>Billions [HEKM'11, KSS'12]</p>
    <p>Tens of billions This work</p>
    <p>Solved protocol scalability problem</p>
  </div>
  <div class="page">
    <p>Prior Work</p>
    <p>Thousands [MNPS'04]</p>
    <p>Millions [sS'11]</p>
    <p>Billions [HEKM'11, KSS'12]</p>
    <p>Tens of billions This work</p>
    <p>Tools scale poorly</p>
    <p>Solves toolchain scalability problem</p>
    <p>Solved protocol scalability problem</p>
    <p>Limits of Fairplay compiler</p>
  </div>
  <div class="page">
    <p>Previous Approaches</p>
    <p>Compiler High level domain</p>
    <p>specific lang.: SFDL/KSS/etc</p>
    <p>MNPS04, PSSW09, KSS12, HFKV12</p>
    <p>Circuits are described as lists of gates  Loops must be unrolled  Functions must be inlined  Conditionals must be flattened</p>
  </div>
  <div class="page">
    <p>Previous Approaches</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>AND</p>
    <p>AND 6</p>
    <p>Problem: Storage size = worst case running time</p>
  </div>
  <div class="page">
    <p>Previous Approaches</p>
    <p>Machine resources limit the size of circuits that can be optimized or stored</p>
    <p>Storage requirements grow with worst case running time  Millions of gates = many gigabytes</p>
    <p>Function</p>
    <p>KSS12 HFKV12 Circuit Size Compile Time Circuit Size Compile Time</p>
  </div>
  <div class="page">
    <p>Related problem: Evaluating Circuits</p>
    <p>Wire values</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>AND</p>
    <p>AND 1</p>
    <p>T</p>
    <p>F</p>
    <p>T</p>
    <p>T</p>
    <p>T</p>
  </div>
  <div class="page">
    <p>Related problem: Evaluating Circuits</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>AND</p>
    <p>AND 1</p>
    <p>Wire values</p>
    <p>T</p>
    <p>T</p>
    <p>F</p>
    <p>T</p>
    <p>T</p>
    <p>T</p>
  </div>
  <div class="page">
    <p>Related problem: Evaluating Circuits</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>AND</p>
    <p>AND 1</p>
    <p>Wire values</p>
    <p>T T</p>
    <p>T</p>
    <p>F</p>
    <p>T</p>
    <p>T</p>
    <p>T</p>
  </div>
  <div class="page">
    <p>Related problem: Evaluating Circuits</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>AND</p>
    <p>AND 1</p>
    <p>Wire values</p>
    <p>T T F</p>
    <p>T</p>
    <p>F</p>
    <p>T</p>
    <p>T</p>
    <p>T</p>
  </div>
  <div class="page">
    <p>Related problem: Evaluating Circuits</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>AND</p>
    <p>AND 1</p>
    <p>Wire values</p>
    <p>T T F F</p>
    <p>T</p>
    <p>F</p>
    <p>T</p>
    <p>T</p>
    <p>T</p>
  </div>
  <div class="page">
    <p>Related problem: Evaluating Circuits</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>AND</p>
    <p>AND 1</p>
    <p>Wire values</p>
    <p>T T F F F</p>
    <p>T</p>
    <p>F</p>
    <p>T</p>
    <p>T</p>
    <p>T</p>
    <p>Problem: Memory requirement grows with running time!</p>
  </div>
  <div class="page">
    <p>KSS12 Approach</p>
    <p>Observation: Wire values are not needed after their last use as an input to a gate</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>AND</p>
    <p>AND 1</p>
    <p>Wire values</p>
    <p>T T</p>
    <p>T</p>
    <p>F</p>
    <p>T</p>
    <p>T</p>
    <p>T</p>
    <p>Ref. count</p>
  </div>
  <div class="page">
    <p>KSS12 Approach</p>
    <p>Observation: Wire values are not needed after their last use as an input to a gate</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>AND</p>
    <p>AND 1</p>
    <p>Wire values</p>
    <p>T T F</p>
    <p>T</p>
    <p>F</p>
    <p>T</p>
    <p>T</p>
    <p>T</p>
  </div>
  <div class="page">
    <p>KSS12 Approach</p>
    <p>Observation: Wire values are not needed after their last use as an input to a gate</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>XOR</p>
    <p>AND</p>
    <p>AND 1</p>
    <p>Wire values</p>
    <p>T T F F</p>
    <p>T</p>
    <p>F</p>
    <p>T</p>
    <p>T</p>
    <p>T</p>
  </div>
  <div class="page">
    <p>Key Insight (1): Overwriting</p>
    <p>When wire values are not needed, just overwrite them</p>
    <p>Simpler than reference counting</p>
    <p>The compiler can use high-level information (scope, assignments, etc.) to determine when a wire can be overwritten</p>
    <p>Removes need for unique wire IDs  just need the index in the table</p>
    <p>i</p>
    <p>i</p>
    <p>i</p>
    <p>... x ...</p>
    <p>i</p>
    <p>i</p>
    <p>i</p>
    <p>... y ...</p>
  </div>
  <div class="page">
    <p>Key Insight (2): JIT Gate Generation</p>
    <p>Unrolling loops carries a heavy cost: the loop body is repeated many times</p>
    <p>Control-flow graphs are more compact than circuits  CFGs are also useful</p>
    <p>for optimization</p>
    <p>X = 0 Y = 1</p>
    <p>X &gt; Z?</p>
    <p>X = X + Y</p>
    <p>...</p>
  </div>
  <div class="page">
    <p>Key Insight (2): JIT Gate Generation</p>
    <p>X = 0 Y = 1</p>
    <p>X &gt; Z?</p>
    <p>X = X + Y</p>
    <p>...</p>
    <p>Loops do not need to be unrolled immediately</p>
    <p>Just-in-time gate generation</p>
  </div>
  <div class="page">
    <p>Key Insight (2): JIT Gate Generation</p>
    <p>X = 0 Y = 1</p>
    <p>X &gt; Z?</p>
    <p>X = X + Y</p>
    <p>...</p>
    <p>Loops do not need to be unrolled immediately</p>
    <p>Gates emitted as side effects of state transitions</p>
    <p>Now we deal with programs, not circuits</p>
  </div>
  <div class="page">
    <p>PCF</p>
    <p>PCF combines these two ideas  This requires no changes to secure 2-party</p>
    <p>computation protocols  The PCF runtime emits a stream of gates  this can</p>
    <p>be used like any other description  No compromises on security</p>
  </div>
  <div class="page">
    <p>PCF Runtime</p>
    <p>loop?</p>
    <p>...</p>
    <p>Wire Table</p>
  </div>
  <div class="page">
    <p>PCF Runtime</p>
    <p>loop?</p>
    <p>...</p>
    <p>Wire Table</p>
  </div>
  <div class="page">
    <p>PCF Runtime</p>
    <p>loop?</p>
    <p>...</p>
    <p>Wire Table</p>
  </div>
  <div class="page">
    <p>PCF Runtime</p>
    <p>loop?</p>
    <p>...</p>
    <p>Wire Table</p>
    <p>XOR(...)</p>
  </div>
  <div class="page">
    <p>PCF Runtime</p>
    <p>loop?</p>
    <p>...</p>
    <p>Wire Table</p>
    <p>XOR(...) AND(...)</p>
  </div>
  <div class="page">
    <p>PCF Runtime</p>
    <p>loop?</p>
    <p>...</p>
    <p>Wire Table</p>
    <p>XOR(...) AND(...)</p>
  </div>
  <div class="page">
    <p>PCF Runtime</p>
    <p>loop?</p>
    <p>...</p>
    <p>Wire Table</p>
    <p>XOR(...) AND(...)</p>
    <p>XOR(...)</p>
  </div>
  <div class="page">
    <p>PCF Runtime</p>
    <p>loop?</p>
    <p>...</p>
    <p>Wire Table</p>
    <p>XOR(...) AND(...)</p>
    <p>XOR(...) AND(...)</p>
  </div>
  <div class="page">
    <p>PCF Runtime</p>
    <p>loop?</p>
    <p>...</p>
    <p>Wire Table</p>
    <p>XOR(...) AND(...)</p>
    <p>XOR(...) AND(...)</p>
  </div>
  <div class="page">
    <p>PCF Runtime</p>
    <p>loop?</p>
    <p>...</p>
    <p>Wire Table</p>
    <p>XOR(...) AND(...)</p>
    <p>XOR(...) AND(...)</p>
    <p>XOR(...)</p>
  </div>
  <div class="page">
    <p>Key Insight (3): Start with Bytecode</p>
    <p>Previous systems support one language  Fairplay, KSS'12 use a domain specific language  HFKV'12 support C (suggest LLVM bytecode as</p>
    <p>future work)</p>
    <p>Our system reads a bytecode format as input  Any language can be compiled to bytecode; any</p>
    <p>language can be supported</p>
  </div>
  <div class="page">
    <p>Our System</p>
    <p>C LCC PCF Compiler PCF</p>
    <p>No changes to C, just restrictions on what programs can be executed (e.g. loop termination must not depend on input values, no pointers to functions)</p>
    <p>Nothing special about LCC  could use JVM, LLVM, etc. to support other languages</p>
    <p>Can handle big functions, tens of billions of gates or more, using just a laptop computer</p>
  </div>
  <div class="page">
    <p>k-width Millionaire's</p>
    <p>unsigned int alice(unsigned int,unsigned int); unsigned int bob(unsigned int,unsigned int); void output_alice(unsigned int);</p>
    <p>void main(void) { unsigned int res = 0x00000001, x=0; unsigned int i; unsigned int borrow;</p>
    <p>for(i = 0; i &lt; 128;) { unsigned int a1 = alice(i,0); unsigned int b1 = bob(i,0); unsigned int b = borrow; borrow = 0;</p>
    <p>if(a1 &lt; (b1 + b)) borrow = 1;</p>
    <p>i += 32; } if(borrow == 0) x= 0x1; else x = 0xffffffff;</p>
    <p>output_alice(x); }</p>
  </div>
  <div class="page">
    <p>unsigned int alice(unsigned int,unsigned int); unsigned int bob(unsigned int,unsigned int); void output_alice(unsigned int); void output_bob(unsigned int);</p>
    <p>#define N 4 #define M 1024</p>
    <p>unsigned int transZ[16*N]; unsigned int transO[16*N];</p>
    <p>void read_table(void) { unsigned int i = 0, inp = 0;</p>
    <p>for (i = 0; i &lt; N; i++) { inp = alice(32*i, 0); transZ[2*i] = inp &amp; 0xFF;</p>
    <p>transO[2*i] = (inp &gt;&gt; 8) &amp; 0xFF;</p>
    <p>transZ[2*i+1] = (inp &gt;&gt; 16) &amp; 0xFF;</p>
    <p>transO[2*i+1] = (inp &gt;&gt; 24) &amp; 0xFF; } }</p>
    <p>void main(void) { unsigned int i = 0, j = 0, k=0, z = 0, inp = 0; unsigned int state;</p>
    <p>read_table();</p>
    <p>state = 0; for(z = 0; z &lt; M; z++) { inp = bob(32*z,0); for(i = 0; i &lt; 32; i++) { for(j = 0; j &lt; 16*N; j++) { unsigned int xstate = 0; if((inp &amp; 0x01) != 0) xstate = transO[j] &amp; 0xFF;</p>
    <p>if((inp &amp; 0x01) == 0) xstate = transZ[j] &amp; 0xFF;</p>
    <p>if((j == state) &amp;&amp; (k == 0)) { k = 1; state = xstate; } }</p>
    <p>inp = inp &gt;&gt; 1; k = 0; } } output_alice(state); }</p>
    <p>Regex Matching</p>
  </div>
  <div class="page">
    <p>Technical Issues</p>
  </div>
  <div class="page">
    <p>Handling Branches</p>
    <p>Branch statements require special treatment  Must evaluate all</p>
    <p>possible control paths  Multiplexers must be</p>
    <p>used for assignments</p>
    <p>In bytecode formats, branches are not as structured as in HLLs</p>
    <p>if(x &lt;= 5) { n = z; if(z == w) {</p>
    <p>y += n; }</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Handling Branches (Fairplay/KSS'12)</p>
    <p>BRANCH L1</p>
    <p>GTU4</p>
    <p>NEQ4</p>
    <p>BRANCH L2</p>
    <p>LABELV L2</p>
    <p>LABELV L1</p>
    <p>if(x &lt;= 5) { n = z; if(z == w) {</p>
    <p>y += n; }</p>
    <p>}</p>
    <p>Stack</p>
  </div>
  <div class="page">
    <p>Handling Branches (Fairplay/KSS'12)</p>
    <p>BRANCH L1</p>
    <p>GTU4</p>
    <p>NEQ4</p>
    <p>BRANCH L2</p>
    <p>LABELV L2</p>
    <p>LABELV L1</p>
    <p>if(x &lt;= 5) { n = z; if(z == w) {</p>
    <p>y += n; }</p>
    <p>}</p>
    <p>c1 = x &gt; 5</p>
    <p>Stack</p>
  </div>
  <div class="page">
    <p>Handling Branches (Fairplay/KSS'12)</p>
    <p>BRANCH L1</p>
    <p>GTU4</p>
    <p>NEQ4</p>
    <p>BRANCH L2</p>
    <p>LABELV L2</p>
    <p>LABELV L1</p>
    <p>if(x &lt;= 5) { n = z; if(z == w) {</p>
    <p>y += n; }</p>
    <p>}</p>
    <p>c1 = x &gt; 5</p>
    <p>Stack</p>
    <p>(L1, c1)</p>
  </div>
  <div class="page">
    <p>Handling Branches (Fairplay/KSS'12)</p>
    <p>BRANCH L1</p>
    <p>GTU4</p>
    <p>NEQ4</p>
    <p>BRANCH L2</p>
    <p>LABELV L2</p>
    <p>LABELV L1</p>
    <p>if(x &lt;= 5) { n = z; if(z == w) {</p>
    <p>y += n; }</p>
    <p>}</p>
    <p>c1 = x &gt; 5</p>
    <p>Stack</p>
    <p>(L1, c1)</p>
    <p>c2 = z != w</p>
  </div>
  <div class="page">
    <p>Handling Branches (Fairplay/KSS'12)</p>
    <p>BRANCH L1</p>
    <p>GTU4</p>
    <p>NEQ4</p>
    <p>BRANCH L2</p>
    <p>LABELV L2</p>
    <p>LABELV L1</p>
    <p>if(x &lt;= 5) { n = z; if(z == w) {</p>
    <p>y += n; }</p>
    <p>}</p>
    <p>c1 = x &gt; 5</p>
    <p>Stack</p>
    <p>(L1, c1)</p>
    <p>c2 = z != w</p>
    <p>(L2, c2)</p>
  </div>
  <div class="page">
    <p>Handling Branches (Fairplay/KSS'12)</p>
    <p>BRANCH L1</p>
    <p>GTU4</p>
    <p>NEQ4</p>
    <p>BRANCH L2</p>
    <p>LABELV L2</p>
    <p>LABELV L1</p>
    <p>if(x &lt;= 5) { n = z; if(z == w) {</p>
    <p>y += n; }</p>
    <p>}</p>
    <p>c1 = x &gt; 5</p>
    <p>Stack</p>
    <p>(L1, c1)</p>
    <p>c2 = z != w</p>
    <p>mux(y, c2)</p>
  </div>
  <div class="page">
    <p>Handling Branches (Fairplay/KSS'12)</p>
    <p>BRANCH L1</p>
    <p>GTU4</p>
    <p>NEQ4</p>
    <p>BRANCH L2</p>
    <p>LABELV L2</p>
    <p>LABELV L1</p>
    <p>if(x &lt;= 5) { n = z; if(z == w) {</p>
    <p>y += n; }</p>
    <p>}</p>
    <p>c1 = x &gt; 5</p>
    <p>Stack</p>
    <p>c2 = z != w</p>
    <p>mux(y, c2)</p>
    <p>mux(n, c1) mux(y, c1)</p>
  </div>
  <div class="page">
    <p>Handling (Complex) Branches</p>
    <p>BRANCH L1</p>
    <p>GTU4</p>
    <p>NEU4</p>
    <p>BRANCH L2</p>
    <p>LABELV L1</p>
    <p>LABELV L2</p>
    <p>Priority Queue</p>
    <p>CND = true</p>
    <p>Strategy:  Maintain global condition wire  Emit muxes for each assignment  Use priority queue to keep track</p>
    <p>of next branch target</p>
    <p>n = z;</p>
  </div>
  <div class="page">
    <p>Handling (Complex) Branches</p>
    <p>BRANCH L1</p>
    <p>GTU4</p>
    <p>NEU4</p>
    <p>BRANCH L2</p>
    <p>LABELV L1</p>
    <p>LABELV L2</p>
    <p>Priority Queue</p>
    <p>CND = true</p>
    <p>n = z;</p>
    <p>c1 = ... &gt; ...</p>
  </div>
  <div class="page">
    <p>Handling (Complex) Branches</p>
    <p>BRANCH L1</p>
    <p>GTU4</p>
    <p>NEU4</p>
    <p>BRANCH L2</p>
    <p>LABELV L1</p>
    <p>LABELV L2</p>
    <p>Priority Queue</p>
    <p>CND = (!c1) &amp;&amp; true</p>
    <p>n = z;</p>
    <p>c1 = ... &gt; ...</p>
    <p>(L1, c1)</p>
    <p>If c1 is not true, we pass this</p>
    <p>instruction</p>
  </div>
  <div class="page">
    <p>Handling (Complex) Branches</p>
    <p>BRANCH L1</p>
    <p>GTU4</p>
    <p>NEU4</p>
    <p>BRANCH L2</p>
    <p>LABELV L1</p>
    <p>LABELV L2</p>
    <p>Priority Queue</p>
    <p>CND = (!c1) &amp;&amp; true</p>
    <p>n = z;</p>
    <p>c1 = ... &gt; ...</p>
    <p>(L1, c1)</p>
    <p>mux(y, (!c1) &amp;&amp; true)</p>
  </div>
  <div class="page">
    <p>Handling (Complex) Branches</p>
    <p>BRANCH L1</p>
    <p>GTU4</p>
    <p>NEU4</p>
    <p>BRANCH L2</p>
    <p>LABELV L1</p>
    <p>LABELV L2</p>
    <p>Priority Queue</p>
    <p>CND = (!c1) &amp;&amp; true</p>
    <p>n = z;</p>
    <p>c1 = ... &gt; ...</p>
    <p>(L1, c1)</p>
    <p>mux(y, (!c1) &amp;&amp; true)</p>
    <p>c2 = ... != ...</p>
  </div>
  <div class="page">
    <p>Handling (Complex) Branches</p>
    <p>BRANCH L1</p>
    <p>GTU4</p>
    <p>NEU4</p>
    <p>BRANCH L2</p>
    <p>LABELV L1</p>
    <p>LABELV L2</p>
    <p>Priority Queue</p>
    <p>CND = (!c2) &amp;&amp; (!c1) &amp;&amp; true</p>
    <p>n = z;</p>
    <p>c1 = ... &gt; ...</p>
    <p>mux(y, (!c1) &amp;&amp; true)</p>
    <p>c2 = ... != ...</p>
    <p>(L2, c2)</p>
    <p>(L1, c1)</p>
    <p>Priority order: L1 comes before L2</p>
  </div>
  <div class="page">
    <p>Handling (Complex) Branches</p>
    <p>BRANCH L1</p>
    <p>GTU4</p>
    <p>NEU4</p>
    <p>BRANCH L2</p>
    <p>LABELV L1</p>
    <p>LABELV L2</p>
    <p>Priority Queue</p>
    <p>CND = c1 || (!c2) &amp;&amp; (!c1) &amp;&amp; true</p>
    <p>n = z;</p>
    <p>c1 = ... &gt; ...</p>
    <p>mux(y, (!c1) &amp;&amp; true)</p>
    <p>c2 = ... != ...</p>
    <p>(L2, c2)</p>
  </div>
  <div class="page">
    <p>Handling (Complex) Branches</p>
    <p>BRANCH L1</p>
    <p>GTU4</p>
    <p>NEU4</p>
    <p>BRANCH L2</p>
    <p>LABELV L1</p>
    <p>LABELV L2</p>
    <p>Priority Queue</p>
    <p>CND = c2 || c1 || (!c2) &amp;&amp; (!c1) ...</p>
    <p>y = 7;</p>
    <p>c1 = ... &gt; ...</p>
    <p>mux(y, (!c1) &amp;&amp; true)</p>
    <p>c2 = ... != ...</p>
  </div>
  <div class="page">
    <p>Handling Loops</p>
    <p>Common assumption: backwards branches are used to build loops</p>
    <p>Only one rule: such branches must not be dependent on input values (enforced by runtime system)</p>
    <p>Preventing infinite loops is the user's responsibility</p>
  </div>
  <div class="page">
    <p>Circuit Optimization Strategy</p>
    <p>Two stages  compile time and run time  At compile time, use techniques based on</p>
    <p>dataflow analysis.  Circuit sizes are reduced indirectly by reducing</p>
    <p>program run time</p>
    <p>At run time, check gates for constant outputs</p>
  </div>
  <div class="page">
    <p>Circuit Optimization Strategy</p>
    <p>Function</p>
    <p>KSS12 HFKV12 This Work</p>
    <p>Total Non-XOR Total Non-XOR Total Non-XOR</p>
  </div>
  <div class="page">
    <p>File Sizes and Compile Times</p>
    <p>Function</p>
    <p>KSS12 HFKV12 PCF Circuit Size Compile</p>
    <p>Time (s) Circuit Size Compile</p>
    <p>Time (s) Circuit Size Compile</p>
    <p>Time (s)</p>
    <p>?? ?? - - 1.3MB 564.</p>
    <p>~1000x improvement</p>
  </div>
  <div class="page">
    <p>Comparison with circuit libraries</p>
    <p>Circuit Libraries [HEKM'11, MAL'11]</p>
    <p>PCF</p>
    <p>Scalability Good  Circuit not stored anywhere</p>
    <p>Good  Circuit is compressed</p>
    <p>Building Circuits Ad-hoc  separate gadgets composed by user</p>
    <p>Automatic  gadgets composed automatically by compiler</p>
    <p>Optimization Per-gadget, user can be clever</p>
    <p>Automatic, can cross gadget boundaries</p>
  </div>
  <div class="page">
    <p>Comparison with circuit libraries</p>
    <p>Our approach subsumes circuit libraries  New gadgets can be added for new bytecode</p>
    <p>instructions</p>
  </div>
  <div class="page">
    <p>Using PCF</p>
    <p>A library for interpreting PCF files  Simple interface  two functions  Compiler and library are available upon</p>
    <p>request, and posted to github shortly</p>
  </div>
  <div class="page">
    <p>We are happy to help integrate PCF into your</p>
    <p>secure computation project</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>We have scalable protocols for secure 2-party computation</p>
    <p>and...</p>
    <p>We have scalable tools for secure 2-party computation</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Other settings  Verifiable computation  arithmetic circuits / QAPs  FHE  arithmetic circuits + SIMD  Multiparty computation (more than 2 parties)</p>
    <p>Other computation models  New optimization techniques</p>
  </div>
  <div class="page">
    <p>Questions?</p>
  </div>
</Presentation>
