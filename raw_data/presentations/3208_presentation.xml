<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Enforcing Forward-Edge Control-Flow Integrity in GCC &amp; LLVM</p>
    <p>Caroline Tice Tom Roeder Peter Collingbourne Stephen Checkoway Google, Inc. Google Inc. Google Inc. Johns Hopkins University</p>
    <p>lfar Erlingsson Luis Lozano Geoff Pike Google, Inc. Google Inc. Google Inc.</p>
  </div>
  <div class="page">
    <p>What is Control-Flow Integrity? Control Flow Integrity (CFI) is a security policy that dictates that the software</p>
    <p>execution must follow the path of a previously determined control flow graph (CFG).</p>
    <p>Static CFG</p>
    <p>Dynamic Path</p>
    <p>(attacker code!)</p>
  </div>
  <div class="page">
    <p>How can branch targets be attacked?  Targets are hard-coded (in non-writable memory)...</p>
    <p>call *(my_func)</p>
    <p>Heap</p>
    <p>my_func: 0x123</p>
    <p>Stack</p>
    <p>&lt;ret addr&gt;: 0xabc</p>
    <p>return</p>
    <p>forward edge</p>
    <p>backward edge</p>
    <p>...except when on the heap  ...or on the stack.</p>
    <p>je 0x40186d (direct control flow)</p>
    <p>(indirect control flow)</p>
  </div>
  <div class="page">
    <p>So...why focus on forward-edge?</p>
    <p>attacker defender</p>
    <p>STACK</p>
    <p>Attacks Defenses</p>
    <p>Buffer Overflow</p>
    <p>Return-Oriented Programming</p>
    <p>Return-to-libc</p>
    <p>Stack Canaries, Layout Reordering</p>
    <p>Address-Space Layout Randomization (ASLR)</p>
    <p>Coding patterns that avoid stack buffers</p>
  </div>
  <div class="page">
    <p>Status of forward-edge defenses?</p>
    <p>attacker defender</p>
    <p>HEAP</p>
    <p>Attacks Defenses</p>
    <p>Buffer overflow / fake vtables</p>
    <p>Exploit use-after-free bugs</p>
    <p>Heap spraying / feng shui</p>
    <p>Heap-Metadata Canaries</p>
    <p>Address-Space Layout Randomization</p>
    <p>Various ad hoc CFI attempts</p>
  </div>
  <div class="page">
    <p>Our Overall Contribution</p>
    <p>Practical CFI enforcement in production compilers, for forward edges.</p>
  </div>
  <div class="page">
    <p>What do we have to offer?</p>
    <p>Integrated forward-edge CFI into GCC &amp; LLVM.  No restrictions or simplifying assumptions.  Scales completely.  Strong security guarantees.  Low performance degradation.</p>
  </div>
  <div class="page">
    <p>Vtable Verification (VTV), in GCC 4.9 For every virtual call in C++, verifies the vtable pointer used to make the call is valid and correct for the static class (type) of object making the call.</p>
    <p>Indirect Function Call Checker (IFCC), in LLVM Forces every indirect function call to use a specially constructed jump table (in non-writable memory), to prevent attacker changing target to something outside the program.</p>
    <p>Verifies (at runtime) that the actual function signature of the called function exactly matches the function signature at the call site.</p>
    <p>Indirect Function Call Sanitizer (FSan), in LLVM</p>
    <p>What exactly did we do?</p>
  </div>
  <div class="page">
    <p>Load Dynamic Library</p>
    <p>VTV Pointer Data Set details</p>
    <p>Compiler/ Assembler</p>
    <p>Source Files</p>
    <p>Object Files</p>
    <p>Class Hierarchy Info</p>
    <p>Start</p>
    <p>Load Libraries</p>
    <p>Constructor Inits</p>
    <p>Main</p>
    <p>libvtv</p>
    <p>(vtable ptr data sets)</p>
  </div>
  <div class="page">
    <p>IFCC: Function Verification Details</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>call *%rax</p>
    <p>f:</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
  </div>
  <div class="page">
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>IFCC: Function Verification Details</p>
    <p>call *%rax</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>f:</p>
    <p>f_JT: jmp f@PLT</p>
    <p>Jump table of size 2n</p>
  </div>
  <div class="page">
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>IFCC: Function Verification Details</p>
    <p>&lt;transform/check %rax&gt; call *%rax</p>
    <p>.</p>
    <p>.</p>
    <p>.</p>
    <p>f:</p>
    <p>f_JT: jmp f@PLT</p>
    <p>Jump table of size 2n</p>
  </div>
  <div class="page">
    <p>Measurements: What &amp; How?  Security</p>
    <p>AIR = Average Indirect-target Reduction [Zhang 13]  ~ fraction of protected indirect control flow insns.  fAIR = forward-edge AIR</p>
    <p>Run-time performance degradation  SPEC 2006 C++ benchmarks  Chromium web browser</p>
    <p>dromaeo, sunspider, octane benchmarks</p>
  </div>
  <div class="page">
    <p>How do they compare?</p>
    <p>VTV IFCC FSan</p>
    <p>Security fAIR = 95.2% fAIR = 99.8% NA</p>
    <p>Performance Penalty</p>
    <p>Precision guarantees</p>
    <p>Target is in a correct class for call site.</p>
    <p>Target is a function (of correct arity) in original program.</p>
    <p>Target has correct signature.</p>
    <p>Applicability - C++ only - Virtual calls only</p>
    <p>- Any LLVM lang. - All indirect calls</p>
    <p>- C++ only - All indirect calls</p>
  </div>
  <div class="page">
    <p>What have we learned?  Fully integrating CFI w/compiler helps with performance.  Do security analysis on final compiler output.</p>
    <p>Some optimizations could affect security passes.  Incremental compilation: Incomplete data =&gt; false +s</p>
    <p>(execution aborts -- MUST AVOID!!).</p>
    <p>assembler</p>
    <p>Source Files</p>
    <p>Assembly Files</p>
    <p>Object Files</p>
    <p>Final Optimized</p>
    <p>Binary</p>
    <p>linker</p>
    <p>link-time optimizer( )</p>
    <p>parser/analyzer</p>
    <p>optimizer</p>
  </div>
  <div class="page">
    <p>What have we learned (cont.)?  Need to support dynamic library loading.</p>
    <p>Purely statically linked binaries are hard to find!  Mixed verified &amp; unverified code (e.g. libraries):</p>
    <p>Another source of incomplete information!  Requires ability for programmer intervention:</p>
    <p>IFCC: Allows explicitly disabling verification for specified functions.</p>
    <p>VTV: Allows modifying the failure function, e.g. w/whitelist or secondary verification.</p>
  </div>
  <div class="page">
    <p>Questions &amp; Answers...</p>
    <p>Practical CFI enforcement in production compilers for forward edges.</p>
  </div>
  <div class="page">
    <p>Back up slides come next.</p>
  </div>
  <div class="page">
    <p>Performance - SPEC CPU2006</p>
  </div>
  <div class="page">
    <p>Performance - Chromium</p>
  </div>
</Presentation>
