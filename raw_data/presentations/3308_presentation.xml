<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Undermining Information Hiding (And What to do About it)</p>
    <p>Enes Gkta, Robert Gawlik, Benjamin Kollenda, Elias Athanasopoulos,</p>
    <p>Georgios Portokalidis, Cristiano Giuffrida, Herbert Bos</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Mitigating code-reuse attacks</p>
    <p>Hiding code pointers in sensitive regions (information hiding)</p>
    <p>Sensitive region per thread</p>
    <p>Thread Spraying</p>
    <p>Reveal SafeStack (LLVM) in seconds</p>
    <p>Authenticating Page Mapper: harden information hiding</p>
  </div>
  <div class="page">
    <p>ROP attack</p>
    <p>CODE</p>
    <p>DATA</p>
    <p>HEAP</p>
    <p>STACK</p>
    <p>HEAP = dynamic data</p>
    <p>STACK = program code execution context (contains code pointers)</p>
  </div>
  <div class="page">
    <p>ROP attack</p>
    <p>CODE</p>
    <p>DATA</p>
    <p>HEAP</p>
    <p>STACK</p>
    <p>FAKE STACK</p>
    <p>HEAP = dynamic data</p>
    <p>Inject FAKE STACK through normal data input</p>
    <p>STACK = program code execution context (contains code pointers)</p>
  </div>
  <div class="page">
    <p>ROP attack</p>
    <p>CODE</p>
    <p>DATA</p>
    <p>HEAP</p>
    <p>STACK</p>
    <p>FAKE STACK</p>
    <p>RSP</p>
    <p>HEAP = dynamic data</p>
    <p>Hijack control flow trough mem. vuln.</p>
    <p>Inject FAKE STACK through normal data input</p>
    <p>STACK = program code execution context (contains code pointers)</p>
  </div>
  <div class="page">
    <p>ROP attack</p>
    <p>CODE</p>
    <p>DATA</p>
    <p>HEAP</p>
    <p>STACK</p>
    <p>FAKE STACK</p>
    <p>RSP</p>
    <p>HEAP = dynamic data</p>
    <p>STACK = program code execution context (contains code pointers)</p>
    <p>Hijack control flow trough mem. vuln.</p>
    <p>Inject FAKE STACK through normal data input</p>
    <p>How does the attacker get to know the code pointers?</p>
  </div>
  <div class="page">
    <p>ROP attack</p>
    <p>CODE</p>
    <p>DATA</p>
    <p>HEAP</p>
    <p>STACK</p>
    <p>FAKE STACK</p>
    <p>RSP</p>
    <p>HEAP = dynamic data</p>
    <p>STACK = program code execution context (contains code pointers)</p>
    <p>Hijack control flow trough mem. vuln.</p>
    <p>Inject FAKE STACK through normal data input</p>
    <p>How does the attacker get to know the code pointers?</p>
    <p>- Fingerprint app version</p>
  </div>
  <div class="page">
    <p>Protect code pointers</p>
    <p>Address Space Layout Randomization</p>
    <p>CODE</p>
    <p>DATA</p>
    <p>Random address</p>
    <p>Leak pointer to CODE or DATA</p>
  </div>
  <div class="page">
    <p>Protect code pointers</p>
    <p>Address Space Layout Randomization</p>
    <p>Function / Instruction Level Randomization</p>
    <p>CODE</p>
    <p>DATA</p>
    <p>CODE</p>
    <p>DATA</p>
    <p>Random address</p>
    <p>Random address</p>
    <p>JIT-ROP</p>
    <p>Leak pointer to CODE or DATA</p>
  </div>
  <div class="page">
    <p>Protect code pointers</p>
    <p>Address Space Layout Randomization</p>
    <p>Function / Instruction Level Randomization</p>
    <p>Isolate code pointers to a safe area  Hardware Segmentation</p>
    <p>Software-Fault Isolation</p>
    <p>Information Hiding</p>
    <p>CODE</p>
    <p>DATA</p>
    <p>CODE</p>
    <p>DATA</p>
    <p>CODE</p>
    <p>DATA</p>
    <p>Random address</p>
    <p>Random address</p>
    <p>Random address</p>
    <p>JIT-ROP</p>
    <p>Leak pointer to CODE or DATA</p>
  </div>
  <div class="page">
    <p>Isolating code pointers</p>
    <p>ASLR-Guard and Code Pointer Integrity</p>
    <p>Two types of safe areas  Safe Stack : code pointers located on the stack (like return addresses)</p>
    <p>Safe Region : all other code pointers (like function addresses)</p>
    <p>Safe Stack is in production compiler LLVM</p>
    <p>Our focus</p>
  </div>
  <div class="page">
    <p>Information Hiding</p>
    <p>Preferred model because</p>
    <p>Hardware Segmentation not available on 64 bit</p>
    <p>Information Hiding lower perf. overhead than Software-Fault Isolation</p>
    <p>Information Hiding idea:</p>
    <p>Separate Code Pointers to safe area</p>
    <p>Assumes no pointers to safe area</p>
    <p>Assumes high entropy of safe area 12</p>
    <p>Our focus</p>
    <p>See paper</p>
  </div>
  <div class="page">
    <p>Entropy</p>
    <p>Degree of randomness</p>
    <p>Given in bits</p>
    <p>Example:</p>
    <p>3 bit address space</p>
    <p>8 blocks of 1 byte</p>
    <p>Hide sensitive data</p>
    <p>Entropy:</p>
    <p>Worst case #probes</p>
    <p>:</p>
    <p>Hit chance: 22 1</p>
    <p>= 4</p>
    <p>(21)</p>
  </div>
  <div class="page">
    <p>Entropy</p>
    <p>Degree of randomness</p>
    <p>Given in bits</p>
    <p>Example:</p>
    <p>3 bit address space</p>
    <p>8 blocks of 1 byte</p>
    <p>Hide sensitive data</p>
    <p>Entropy:</p>
    <p>Worst case #probes</p>
    <p>:</p>
    <p>Hit chance: 22 1</p>
    <p>= 4</p>
    <p>= 2</p>
    <p>(21) (22)</p>
  </div>
  <div class="page">
    <p>Entropy: 64 bits</p>
    <p>Hide: 1 byte</p>
  </div>
  <div class="page">
    <p>Linux user space only uses 47 bit</p>
    <p>Entropy: 47 bits</p>
    <p>Hide: 1 byte</p>
  </div>
  <div class="page">
    <p>Linux user space only uses 47 bit</p>
    <p>Entropy: 35 bits</p>
    <p>Hide: 4096 bytes</p>
  </div>
  <div class="page">
    <p>Linux user space only uses 47 bit</p>
    <p>Entropy: 24 bits</p>
    <p>Hide: 223 bytes</p>
    <p>Safe Stack of 8 MB = 223 bytes = 211 pages</p>
  </div>
  <div class="page">
    <p>Linux user space only uses 47 bit</p>
    <p>Entropy: 24 bits</p>
    <p>Hide: 223 bytes</p>
    <p>Safe Stack of 8 MB = 223 bytes = 211 pages</p>
    <p>Thread Spraying Legitimately spawn as many threads as possible</p>
  </div>
  <div class="page">
    <p>Linux user space only uses 47 bit</p>
    <p>Entropy: 23 bits</p>
    <p>Hide: 224 bytes</p>
    <p>Safe Stack of 8 MB = 223 bytes = 211 pages</p>
    <p>Thread Spraying Legitimately spawn as many threads as possible</p>
    <p>Spawn a new thread</p>
  </div>
  <div class="page">
    <p>Linux user space only uses 47 bit</p>
    <p>Entropy: 22 bits</p>
    <p>Hide: 225 bytes</p>
    <p>Safe Stack of 8 MB = 223 bytes = 211 pages</p>
    <p>Thread Spraying Legitimately spawn as many threads as possible</p>
    <p>Spawn a new thread</p>
    <p>Spawn 2 more threads</p>
  </div>
  <div class="page">
    <p>Linux user space only uses 47 bit</p>
    <p>Entropy: 7 bits</p>
    <p>Hide: 240 bytes</p>
    <p>Safe Stack of 8 MB = 223 bytes = 211 pages</p>
    <p>Thread Spraying Legitimately spawn as many threads as possible</p>
    <p>Spawn a new thread</p>
    <p>Spawn 2 more threads</p>
    <p>Spawn 128k threads = 217 stacks</p>
  </div>
  <div class="page">
    <p>Linux user space only uses 47 bit</p>
    <p>Entropy: 7 bits</p>
    <p>Hide: 240 bytes</p>
    <p>Safe Stack of 8 MB = 223 bytes = 211 pages</p>
    <p>Thread Spraying Legitimately spawn as many threads as possible</p>
    <p>Spawn a new thread</p>
    <p>Spawn 2 more threads</p>
    <p>Spawn 128k threads = 217 stacks Drops worst case #probes to 128</p>
  </div>
  <div class="page">
    <p>Linux user space only uses 47 bit</p>
    <p>Entropy: 7 bits</p>
    <p>Hide: 240 bytes</p>
    <p>Safe Stack of 8 MB = 223 bytes = 211 pages</p>
    <p>Thread Spraying Legitimately spawn as many threads as possible</p>
    <p>Spawn a new thread</p>
    <p>Spawn 2 more threads</p>
    <p>Spawn 128k threads = 217 stacks Drops worst case #probes to 128</p>
    <p>Mmap entropy is 40 bit =&gt; worst case #probes is 1 (20)</p>
  </div>
  <div class="page">
    <p>Thread Spraying</p>
    <p>Firefox: unbounded JS web worker threads</p>
    <p>Chrome: about 250 JS web workers threads</p>
    <p>MySQL: about 1000 connection threads</p>
  </div>
  <div class="page">
    <p>Thread Spraying</p>
    <p>Firefox: unbounded JS web worker threads</p>
    <p>Chrome: about 250 JS web workers threads</p>
    <p>MySQL: about 1000 connection threads</p>
    <p>FF is going to look at it and put a limit</p>
  </div>
  <div class="page">
    <p>Thread Spraying</p>
    <p>Firefox: unbounded JS web worker threads</p>
    <p>Chrome: about 250 JS web workers threads</p>
    <p>MySQL: about 1000 connection threads</p>
    <p>Proof-of-Concept in Firefox:  Spawn 2k threads</p>
    <p>Crash-less memory probing</p>
    <p>Find safe stack &lt; 3 seconds</p>
    <p>FF is going to look at it and put a limit</p>
  </div>
  <div class="page">
    <p>Authenticating Page Mapper</p>
    <p>Based on observations:  Active stack space is smaller than its actual size</p>
    <p>Well defined access pattern</p>
    <p>Authenticates first access to registered pages</p>
    <p>Installs user-level page-fault handler</p>
  </div>
  <div class="page">
    <p>Authenticating Page Mapper</p>
    <p>RSP</p>
    <p>Inactive</p>
    <p>Active</p>
    <p>Stack (8MB)</p>
    <p>low addr</p>
    <p>high addrstack_base</p>
  </div>
  <div class="page">
    <p>Authenticating Page Mapper</p>
    <p>sub 0x80, %rsp</p>
    <p>RSP</p>
    <p>Inactive</p>
    <p>Active</p>
    <p>Stack (8MB)</p>
    <p>low addr</p>
    <p>high addrstack_base</p>
  </div>
  <div class="page">
    <p>Authenticating Page Mapper</p>
    <p>sub 0x80, %rsp mov 0x1000, (%rsp)</p>
    <p>RSP</p>
    <p>Inactive</p>
    <p>Active</p>
    <p>Stack (8MB)</p>
    <p>low addr</p>
    <p>high addrstack_base</p>
  </div>
  <div class="page">
    <p>Authenticating Page Mapper</p>
    <p>RSP</p>
    <p>sub 0x80, %rsp mov 0x1000, (%rsp)</p>
    <p>Inactive</p>
    <p>Active</p>
    <p>Stack (8MB)</p>
    <p>low addr</p>
    <p>high addrstack_base</p>
    <p>page-fault handler checks: RSP &lt;= page-fault addr &lt; stack_base</p>
  </div>
  <div class="page">
    <p>Authenticating Page Mapper</p>
    <p>RSP</p>
    <p>sub 0x80, %rsp mov 0x1000, (%rsp)</p>
    <p>Inactive</p>
    <p>Active</p>
    <p>Stack (8MB)</p>
    <p>low addr</p>
    <p>high addrstack_base</p>
    <p>page-fault handler checks: RSP &lt;= page-fault addr &lt; stack_base</p>
    <p>OK</p>
  </div>
  <div class="page">
    <p>Authenticating Page Mapper</p>
    <p>RSP</p>
    <p>sub 0x80, %rsp mov 0x1000, (%rsp)</p>
    <p>Inactive</p>
    <p>Active</p>
    <p>Stack (8MB)</p>
    <p>low addr</p>
    <p>high addrstack_base</p>
    <p>page-fault handler checks: RSP &lt;= page-fault addr &lt; stack_base</p>
    <p>probe</p>
  </div>
  <div class="page">
    <p>Authenticating Page Mapper</p>
    <p>RSP</p>
    <p>sub 0x80, %rsp mov 0x1000, (%rsp)</p>
    <p>Inactive</p>
    <p>Active</p>
    <p>Stack (8MB)</p>
    <p>low addr</p>
    <p>high addrstack_base</p>
    <p>page-fault handler checks: RSP &lt;= page-fault addr &lt; stack_base</p>
    <p>probe</p>
    <p>NOT OK</p>
  </div>
  <div class="page">
    <p>Authenticating Page Mapper</p>
    <p>RSP</p>
    <p>Stack (8MB)</p>
    <p>low addr</p>
    <p>high addrstack_base</p>
    <p>Inactive</p>
    <p>Active</p>
    <p>Attacker can follow pointers and get to the base, or get to active region by probing from the high addr</p>
  </div>
  <div class="page">
    <p>Authenticating Page Mapper</p>
    <p>RSP</p>
    <p>Stack (8MB)</p>
    <p>low addr</p>
    <p>high addrstack_base</p>
    <p>Inactive</p>
    <p>Active</p>
    <p>Attacker can follow pointers and get to the base, or get to active region by probing from the high addr</p>
    <p>=&gt; Inflate stack and move stack into inflated area</p>
  </div>
  <div class="page">
    <p>Authenticating Page Mapper</p>
    <p>=&gt; Inflate stack and move stack into inflated area</p>
    <p>RSP</p>
    <p>Inactive</p>
    <p>Active</p>
    <p>Stack (80MB)</p>
    <p>low addr</p>
    <p>high addrstack_base</p>
    <p>Trap</p>
    <p>Trap</p>
    <p>Attacker can follow pointers and get to the base, or get to active region by probing from the high addr</p>
  </div>
  <div class="page">
    <p>Authenticating Page Mapper</p>
    <p>=&gt; Inflate stack and move stack into inflated area</p>
    <p>RSP</p>
    <p>Inactive</p>
    <p>Active</p>
    <p>Stack (80MB)</p>
    <p>low addr</p>
    <p>high addrstack_base</p>
    <p>Trap</p>
    <p>Trap</p>
    <p>=&gt; Check remains the same</p>
    <p>=&gt; Trap has different handler and access is never allowed</p>
    <p>Attacker can follow pointers and get to the base, or get to active region by probing from the high addr</p>
  </div>
  <div class="page">
    <p>Authenticating Page Mapper</p>
    <p>Attacker can follow pointers and get to the base, or get to active region by probing from the high addr</p>
    <p>=&gt; Inflate stack and move stack into inflated area</p>
    <p>RSP</p>
    <p>Inactive</p>
    <p>Active</p>
    <p>Stack (80MB)</p>
    <p>low addr</p>
    <p>high addrstack_base</p>
    <p>Trap</p>
    <p>Trap</p>
    <p>=&gt; Check remains the same</p>
    <p>=&gt; Trap has different handler and access is never allowed</p>
    <p>=&gt; Increases detection rate</p>
  </div>
  <div class="page">
    <p>Overhead APM</p>
    <p>Ran SPEC CPU2006 + Safe Stack without and with APM  0.0% overhead*</p>
    <p>Ran browser benchmarks in Chrome and Firefox without and with APM  Chrome: 0.0% overhead*</p>
    <p>Firefox: 0.5% overhead*</p>
  </div>
  <div class="page">
    <p>Worst case Detection Guarantees with APM</p>
    <p>Assumes attacker fills up Active Mem</p>
    <p>Active mem == Stack Size</p>
    <p>Detection Guarantees = (1</p>
    <p>)  100</p>
    <p>Inflation factor Detection Guarantees</p>
    <p>Inactive</p>
    <p>Active</p>
    <p>Stack</p>
    <p>Trap</p>
    <p>Trap</p>
  </div>
  <div class="page">
    <p>APM limitations</p>
    <p>Application implementation issues  Pointer to active region of stack</p>
    <p>Determine active region through side channel attacks</p>
    <p>Inactive</p>
    <p>Active</p>
    <p>Stack</p>
    <p>Trap</p>
    <p>Trap</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Demonstrated an efficient way to locate the Safe Stack through a new attack vector named Thread Spraying</p>
    <p>Stronger isolation techniques should be preferred over Information Hiding</p>
    <p>APM is a possible solution to harden Information Hiding until SFI is or can be widely deployed</p>
  </div>
</Presentation>
