<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Solving Difficult HTM Problems Without Difficult Hardware Owen Hofmann, Donald Porter, Hany Ramadan,</p>
    <p>Christopher Rossbach, and Emmett Witchel</p>
    <p>University of Texas at Austin</p>
  </div>
  <div class="page">
    <p>Intro</p>
    <p>Processors now scaling via cores, not clock rate  8 cores now, 64 tomorrow, 4096 next week?</p>
    <p>Parallel programming increasingly important  Software must keep up with hardware advances</p>
    <p>But parallel programming is really hard  Deadlock, priority inversion, data races, etc.</p>
    <p>STM is here</p>
    <p>We would like HTM</p>
  </div>
  <div class="page">
    <p>Difficult HTM Problems</p>
    <p>Enforcing atomicity and isolation requires conflict detection and rollback</p>
    <p>TM Hardware only applies to memory and processor state  I/O, System calls may have effects that are not</p>
    <p>isolated, cannot be rolled back</p>
    <p>mov $norad, %eax mov $canada, %ebx launchmissiles %eax, %ebx</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Handling kernel I/O with minimal hardware</p>
    <p>User-level system call rollback</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Handling kernel I/O with minimal hardware</p>
    <p>User-level system call rollback</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>cxspinlocks</p>
    <p>Cooperative transactional spinlocks allow kernel to take advantage of limited TM hardware  Optimistically execute with transactions</p>
    <p>Fall back on locking when hardware TM is not enough</p>
    <p>I/O, page table operations</p>
    <p>overflow?</p>
    <p>Correctness provided by isolation of lock variable  Transactional threads read lock</p>
    <p>Non-transactional threads write lock</p>
  </div>
  <div class="page">
    <p>cxspinlock guarantees</p>
    <p>Multiple transactional threads in critical region</p>
    <p>Non-transactional thread excludes all others</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1 cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2 cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: TX cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: TX cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>lockA</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
    <p>lockA</p>
    <p>Transactional threads read unlocked lock variable</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: TX cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: TX cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>lockA</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
    <p>lockA</p>
    <p>Transactional threads read unlocked lock variable</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: TX cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>lockA</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
    <p>lockA</p>
    <p>Transactional threads read unlocked lock variable</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: TX cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: TX cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>lockA</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
    <p>lockA</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: TX cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: TX cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>lockA</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
    <p>lockA</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: TX cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: TX cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>lockA</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
    <p>lockA</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: TX cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: TX cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>lockA</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
    <p>lockA</p>
    <p>Hardware restarts transactions for I/O</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: TX cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
    <p>lockA</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: TX cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
    <p>lockA</p>
    <p>contention managed CAS</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: TX cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
    <p>lockA</p>
    <p>contention managed CAS</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
    <p>contention managed CAS</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: Non-TX cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>locked</p>
    <p>lockA:</p>
    <p>read write</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: Non-TX cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>locked</p>
    <p>lockA:</p>
    <p>read write</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: Non-TX cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>locked</p>
    <p>lockA:</p>
    <p>read write</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: Non-TX cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: TX cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>locked</p>
    <p>lockA:</p>
    <p>read write</p>
    <p>conditionally add variable to read set</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: Non-TX cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: TX cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>locked</p>
    <p>lockA:</p>
    <p>read write</p>
    <p>conditionally add variable to read set</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: TX cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
    <p>conditionally add variable to read set</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: TX cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
    <p>lockA</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: TX cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
    <p>lockA</p>
  </div>
  <div class="page">
    <p>cxspinlocks in action</p>
    <p>Thread 1: cx_optimistic(lockA); modify_data(); if(condition) { perform_IO(); } cx_end(lock);</p>
    <p>Thread 2: cx_optimistic(lockA); modify_data(); cx_end(lock);</p>
    <p>read write</p>
    <p>unlocke d</p>
    <p>lockA:</p>
    <p>read write</p>
  </div>
  <div class="page">
    <p>Implementing cxspinlocks</p>
    <p>Return codes: Correctness  Hardware returns status code from xbegin to</p>
    <p>indicate when hardware has failed (I/O)</p>
    <p>xtest: Performance  Conditionally add a memory cell (e.g. lock</p>
    <p>variable) to the read set based on its value</p>
    <p>xcas: Fairness  Contention managed CAS</p>
    <p>Non-transactional threads can wait for transactional threads</p>
    <p>Simple hardware primitives support complicated behaviors without implementing them</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Handling kernel I/O with minimal hardware</p>
    <p>User-level system call rollback</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>User-level system call rollback</p>
    <p>Open nesting requires user-level syscall rollback</p>
    <p>Many calls have clear inverses  mmap, munmap</p>
    <p>Even simple calls have many side effects  e.g. file write</p>
    <p>Even simple calls might be irreversible</p>
  </div>
  <div class="page">
    <p>Users cant always roll back fd_A = open(file_A);</p>
    <p>unlink(file_A);</p>
    <p>void *map_A =</p>
    <p>mmap(fd=fd_A,</p>
    <p>size=4096);</p>
    <p>close(fd_A);</p>
    <p>xbegin;</p>
    <p>modify_data();</p>
    <p>fd_B = open(file_B);</p>
    <p>xbegin_open;</p>
    <p>void *map_B =</p>
    <p>mmap(fd=fd_B,</p>
    <p>start=map_A,</p>
    <p>size=4096);</p>
    <p>xend_open(</p>
    <p>abort_action=munmap);</p>
    <p>xrestart;</p>
  </div>
  <div class="page">
    <p>Users cant always roll back fd_A = open(file_A);</p>
    <p>unlink(file_A);</p>
    <p>void *map_A =</p>
    <p>mmap(fd=fd_A,</p>
    <p>size=4096);</p>
    <p>close(fd_A);</p>
    <p>xbegin;</p>
    <p>modify_data();</p>
    <p>fd_B = open(file_B);</p>
    <p>xbegin_open;</p>
    <p>void *map_B =</p>
    <p>mmap(fd=fd_B,</p>
    <p>start=map_A,</p>
    <p>size=4096);</p>
    <p>xend_open(</p>
    <p>abort_action=munmap);</p>
    <p>xrestart;</p>
  </div>
  <div class="page">
    <p>Users cant always roll back fd_A = open(file_A);</p>
    <p>unlink(file_A);</p>
    <p>void *map_A =</p>
    <p>mmap(fd=fd_A,</p>
    <p>size=4096);</p>
    <p>close(fd_A);</p>
    <p>xbegin;</p>
    <p>modify_data();</p>
    <p>fd_B = open(file_B);</p>
    <p>xbegin_open;</p>
    <p>void *map_B =</p>
    <p>mmap(fd=fd_B,</p>
    <p>start=map_A,</p>
    <p>size=4096);</p>
    <p>xend_open(</p>
    <p>abort_action=munmap);</p>
    <p>xrestart;</p>
  </div>
  <div class="page">
    <p>Users cant always roll back fd_A = open(file_A);</p>
    <p>unlink(file_A);</p>
    <p>void *map_A =</p>
    <p>mmap(fd=fd_A,</p>
    <p>size=4096);</p>
    <p>close(fd_A);</p>
    <p>xbegin;</p>
    <p>modify_data();</p>
    <p>fd_B = open(file_B);</p>
    <p>xbegin_open;</p>
    <p>void *map_B =</p>
    <p>mmap(fd=fd_B,</p>
    <p>start=map_A,</p>
    <p>size=4096);</p>
    <p>xend_open(</p>
    <p>abort_action=munmap);</p>
    <p>xrestart;</p>
  </div>
  <div class="page">
    <p>Users cant always roll back fd_A = open(file_A);</p>
    <p>unlink(file_A);</p>
    <p>void *map_A =</p>
    <p>mmap(fd=fd_A,</p>
    <p>size=4096);</p>
    <p>close(fd_A);</p>
    <p>xbegin;</p>
    <p>modify_data();</p>
    <p>fd_B = open(file_B);</p>
    <p>xbegin_open;</p>
    <p>void *map_B =</p>
    <p>mmap(fd=fd_B,</p>
    <p>start=map_A,</p>
    <p>size=4096);</p>
    <p>xend_open(</p>
    <p>abort_action=munmap);</p>
    <p>xrestart;</p>
  </div>
  <div class="page">
    <p>Users cant always roll back fd_A = open(file_A);</p>
    <p>unlink(file_A);</p>
    <p>void *map_A =</p>
    <p>mmap(fd=fd_A,</p>
    <p>size=4096);</p>
    <p>close(fd_A);</p>
    <p>xbegin;</p>
    <p>modify_data();</p>
    <p>fd_B = open(file_B);</p>
    <p>xbegin_open;</p>
    <p>void *map_B =</p>
    <p>mmap(fd=fd_B,</p>
    <p>start=map_A,</p>
    <p>size=4096);</p>
    <p>xend_open(</p>
    <p>abort_action=munmap);</p>
    <p>xrestart;</p>
  </div>
  <div class="page">
    <p>Users cant always roll back fd_A = open(file_A);</p>
    <p>unlink(file_A);</p>
    <p>void *map_A =</p>
    <p>mmap(fd=fd_A,</p>
    <p>size=4096);</p>
    <p>close(fd_A);</p>
    <p>xbegin;</p>
    <p>modify_data();</p>
    <p>fd_B = open(file_B);</p>
    <p>xbegin_open;</p>
    <p>void *map_B =</p>
    <p>mmap(fd=fd_B,</p>
    <p>start=map_A,</p>
    <p>size=4096);</p>
    <p>xend_open(</p>
    <p>abort_action=munmap);</p>
    <p>xrestart;</p>
  </div>
  <div class="page">
    <p>Users cant always roll back fd_A = open(file_A);</p>
    <p>unlink(file_A);</p>
    <p>void *map_A =</p>
    <p>mmap(fd=fd_A,</p>
    <p>size=4096);</p>
    <p>close(fd_A);</p>
    <p>xbegin;</p>
    <p>modify_data();</p>
    <p>fd_B = open(file_B);</p>
    <p>xbegin_open;</p>
    <p>void *map_B =</p>
    <p>mmap(fd=fd_B,</p>
    <p>start=map_A,</p>
    <p>size=4096);</p>
    <p>xend_open(</p>
    <p>abort_action=munmap);</p>
    <p>xrestart;</p>
  </div>
  <div class="page">
    <p>Users cant always roll back fd_A = open(file_A);</p>
    <p>unlink(file_A);</p>
    <p>void *map_A =</p>
    <p>mmap(fd=fd_A,</p>
    <p>size=4096);</p>
    <p>close(fd_A);</p>
    <p>xbegin;</p>
    <p>modify_data();</p>
    <p>fd_B = open(file_B);</p>
    <p>xbegin_open;</p>
    <p>void *map_B =</p>
    <p>mmap(fd=fd_B,</p>
    <p>start=map_A,</p>
    <p>size=4096);</p>
    <p>xend_open(</p>
    <p>abort_action=munmap);</p>
    <p>xrestart;</p>
  </div>
  <div class="page">
    <p>Users cant always roll back fd_A = open(file_A);</p>
    <p>unlink(file_A);</p>
    <p>void *map_A =</p>
    <p>mmap(fd=fd_A,</p>
    <p>size=4096);</p>
    <p>close(fd_A);</p>
    <p>xbegin;</p>
    <p>modify_data();</p>
    <p>fd_B = open(file_B);</p>
    <p>xbegin_open;</p>
    <p>void *map_B =</p>
    <p>mmap(fd=fd_B,</p>
    <p>start=map_A,</p>
    <p>size=4096);</p>
    <p>xend_open(</p>
    <p>abort_action=munmap);</p>
    <p>xrestart;</p>
  </div>
  <div class="page">
    <p>Users cant always roll back fd_A = open(file_A);</p>
    <p>unlink(file_A);</p>
    <p>void *map_A =</p>
    <p>mmap(fd=fd_A,</p>
    <p>size=4096);</p>
    <p>close(fd_A);</p>
    <p>xbegin;</p>
    <p>modify_data();</p>
    <p>fd_B = open(file_B);</p>
    <p>xbegin_open;</p>
    <p>void *map_B =</p>
    <p>mmap(fd=fd_B,</p>
    <p>start=map_A,</p>
    <p>size=4096);</p>
    <p>xend_open(</p>
    <p>abort_action=munmap);</p>
    <p>xrestart;</p>
  </div>
  <div class="page">
    <p>Users cant always roll back fd_A = open(file_A);</p>
    <p>unlink(file_A);</p>
    <p>void *map_A =</p>
    <p>mmap(fd=fd_A,</p>
    <p>size=4096);</p>
    <p>close(fd_A);</p>
    <p>xbegin;</p>
    <p>modify_data();</p>
    <p>fd_B = open(file_B);</p>
    <p>xbegin_open;</p>
    <p>void *map_B =</p>
    <p>mmap(fd=fd_B,</p>
    <p>start=map_A,</p>
    <p>size=4096);</p>
    <p>xend_open(</p>
    <p>abort_action=munmap);</p>
    <p>xrestart;</p>
  </div>
  <div class="page">
    <p>Users cant always roll back fd_A = open(file_A);</p>
    <p>unlink(file_A);</p>
    <p>void *map_A =</p>
    <p>mmap(fd=fd_A,</p>
    <p>size=4096);</p>
    <p>close(fd_A);</p>
    <p>xbegin;</p>
    <p>modify_data();</p>
    <p>fd_B = open(file_B);</p>
    <p>xbegin_open;</p>
    <p>void *map_B =</p>
    <p>mmap(fd=fd_B,</p>
    <p>start=map_A,</p>
    <p>size=4096);</p>
    <p>xend_open(</p>
    <p>abort_action=munmap);</p>
    <p>xrestart;</p>
  </div>
  <div class="page">
    <p>Kernel participation required</p>
    <p>Users cant track all syscall side effects  Must also track all non-tx syscalls</p>
    <p>Kernel must manage transactional syscalls</p>
    <p>Kernel enhances user-level programming model  Seamless transactional system calls</p>
    <p>Strong isolation for system calls?</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>Other I/O solutions  Hardware open nesting [Moravan 06]</p>
    <p>Unrestricted transactions [Blundell 07]</p>
    <p>Transactional Locks  Speculative lock elision [Rajwar 01]</p>
    <p>Transparently Reconciling Transactions &amp; Locks [Welc 06]</p>
    <p>Simple hardware models  Hybrid TM [Damron 06, Shriraman 07]</p>
    <p>Hardware-accelerated STM [Saha 2006]</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>Kernel can use even minimal hardware TM designs  May not get full programming model</p>
    <p>Simple primitives support complex behavior</p>
    <p>User-level programs cant roll back system calls  Kernel must participate</p>
  </div>
</Presentation>
