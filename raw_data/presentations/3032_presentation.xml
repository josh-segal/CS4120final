<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Fault-Tolerance, Fast and Slow: Exploiting Failure Asynchrony</p>
    <p>in Distributed Systems Ramnatthan Alagappan, Aishwarya Ganesan, Jing Liu, Andrea Arpaci-Dusseau, and Remzi Arpaci-Dusseau</p>
  </div>
  <div class="page">
    <p>Replication Protocols</p>
    <p>Viewstamped replication RaftPaxos</p>
  </div>
  <div class="page">
    <p>Replication Protocols</p>
    <p>GFS Colossus BigTable</p>
    <p>Foundation upon which datacenter systems are built</p>
    <p>Viewstamped replication RaftPaxos</p>
  </div>
  <div class="page">
    <p>The Two Different Worlds of Replication</p>
  </div>
  <div class="page">
    <p>The Two Different Worlds of Replication</p>
    <p>World-1 World-2</p>
  </div>
  <div class="page">
    <p>The Two Different Worlds of Replication</p>
    <p>How and where to store system state? World-1 World-2</p>
  </div>
  <div class="page">
    <p>The Two Different Worlds of Replication</p>
    <p>How and where to store system state?</p>
    <p>synchronously persist updates to disks</p>
    <p>Disk-durable</p>
    <p>World-1 World-2</p>
  </div>
  <div class="page">
    <p>buffer updates only in volatile memory</p>
    <p>The Two Different Worlds of Replication</p>
    <p>How and where to store system state?</p>
    <p>synchronously persist updates to disks</p>
    <p>Disk-durable</p>
    <p>World-1</p>
    <p>Memory-durable</p>
    <p>World-2</p>
  </div>
  <div class="page">
    <p>buffer updates only in volatile memory</p>
    <p>The Two Different Worlds of Replication</p>
    <p>How and where to store system state?</p>
    <p>synchronously persist updates to disks</p>
    <p>Disk-durable</p>
    <p>World-1</p>
    <p>Paxos, Raft [ATC 14], ZAB [DSN 11], Gaios [NSDI 11], ZooKeeper, etcd, LogCabin</p>
    <p>Memory-durable</p>
    <p>World-2</p>
  </div>
  <div class="page">
    <p>buffer updates only in volatile memory</p>
    <p>The Two Different Worlds of Replication</p>
    <p>How and where to store system state?</p>
    <p>synchronously persist updates to disks</p>
    <p>Disk-durable</p>
    <p>World-1</p>
    <p>Paxos, Raft [ATC 14], ZAB [DSN 11], Gaios [NSDI 11], ZooKeeper, etcd, LogCabin</p>
    <p>Memory-durable</p>
    <p>World-2</p>
    <p>Viewstamped replication, NOPaxos [OSDI 16], SpecPaxos [NSDI 15]</p>
  </div>
  <div class="page">
    <p>buffer updates only in volatile memory</p>
    <p>The Two Different Worlds of Replication</p>
    <p>How and where to store system state?</p>
    <p>synchronously persist updates to disks</p>
    <p>Disk-durable</p>
    <p>World-1</p>
    <p>Neither approach is ideal: reliable or performant</p>
    <p>Paxos, Raft [ATC 14], ZAB [DSN 11], Gaios [NSDI 11], ZooKeeper, etcd, LogCabin</p>
    <p>Memory-durable</p>
    <p>World-2</p>
    <p>Viewstamped replication, NOPaxos [OSDI 16], SpecPaxos [NSDI 15]</p>
  </div>
  <div class="page">
    <p>buffer updates only in volatile memory</p>
    <p>The Two Different Worlds of Replication</p>
    <p>How and where to store system state?</p>
    <p>synchronously persist updates to disks</p>
    <p>Disk-durable</p>
    <p>World-1</p>
    <p>Neither approach is ideal: reliable or performant</p>
    <p>Paxos, Raft [ATC 14], ZAB [DSN 11], Gaios [NSDI 11], ZooKeeper, etcd, LogCabin</p>
    <p>Memory-durable</p>
    <p>World-2</p>
    <p>Viewstamped replication, NOPaxos [OSDI 16], SpecPaxos [NSDI 15]</p>
    <p>safe but suffer from poor performance</p>
  </div>
  <div class="page">
    <p>buffer updates only in volatile memory</p>
    <p>The Two Different Worlds of Replication</p>
    <p>How and where to store system state?</p>
    <p>synchronously persist updates to disks</p>
    <p>Disk-durable</p>
    <p>World-1</p>
    <p>Neither approach is ideal: reliable or performant</p>
    <p>Paxos, Raft [ATC 14], ZAB [DSN 11], Gaios [NSDI 11], ZooKeeper, etcd, LogCabin</p>
    <p>Memory-durable</p>
    <p>World-2</p>
    <p>Viewstamped replication, NOPaxos [OSDI 16], SpecPaxos [NSDI 15]</p>
    <p>safe but suffer from poor performance</p>
    <p>performant but risk unsafety or unavailability</p>
  </div>
  <div class="page">
    <p>Can a protocol provide strong reliability while maintaining high performance?</p>
  </div>
  <div class="page">
    <p>SAUCR: Situation-Aware Updates and Crash Recovery</p>
  </div>
  <div class="page">
    <p>SAUCR: Situation-Aware Updates and Crash Recovery</p>
    <p>Simple insight: dynamically (based on the situation) decide how to commit updates</p>
  </div>
  <div class="page">
    <p>SAUCR: Situation-Aware Updates and Crash Recovery</p>
    <p>Simple insight: dynamically (based on the situation) decide how to commit updates</p>
    <p>with many or all nodes up, buffer in memory  fast mode with failures, if only bare majority up, flush to disk  slow mode</p>
  </div>
  <div class="page">
    <p>SAUCR: Situation-Aware Updates and Crash Recovery</p>
    <p>Simple insight: dynamically (based on the situation) decide how to commit updates</p>
    <p>with many or all nodes up, buffer in memory  fast mode with failures, if only bare majority up, flush to disk  slow mode</p>
    <p>Strong reliability while maintaining high performance</p>
  </div>
  <div class="page">
    <p>Simultaneity of Failures</p>
    <p>SAUCRs effectiveness depends upon simultaneity of failures</p>
  </div>
  <div class="page">
    <p>Simultaneity of Failures</p>
    <p>SAUCRs effectiveness depends upon simultaneity of failures independent and non-simultaneous correlated (gap of a few milliseconds to a few seconds)</p>
    <p>can react and switch from fast to slow mode preserves durability and availability</p>
  </div>
  <div class="page">
    <p>Simultaneity of Failures</p>
    <p>SAUCRs effectiveness depends upon simultaneity of failures independent and non-simultaneous correlated (gap of a few milliseconds to a few seconds)</p>
    <p>can react and switch from fast to slow mode preserves durability and availability</p>
    <p>many truly simultaneous correlated no gap and so cannot react remain unavailable</p>
  </div>
  <div class="page">
    <p>Simultaneity of Failures</p>
    <p>SAUCRs effectiveness depends upon simultaneity of failures independent and non-simultaneous correlated (gap of a few milliseconds to a few seconds)</p>
    <p>can react and switch from fast to slow mode preserves durability and availability</p>
    <p>many truly simultaneous correlated no gap and so cannot react remain unavailable</p>
    <p>however, existing data hints they are extremely rare  the Non-Simultaneity Conjecture</p>
  </div>
  <div class="page">
    <p>Results</p>
  </div>
  <div class="page">
    <p>Results</p>
    <p>Implemented in ZooKeeper</p>
  </div>
  <div class="page">
    <p>Results</p>
    <p>Implemented in ZooKeeper SAUCR improves reliability compared to memory-durable systems</p>
    <p>durable and available in 100s of crash scenarios memory-durable loses data or becomes unavailable</p>
  </div>
  <div class="page">
    <p>Results</p>
    <p>Implemented in ZooKeeper SAUCR improves reliability compared to memory-durable systems</p>
    <p>durable and available in 100s of crash scenarios memory-durable loses data or becomes unavailable</p>
    <p>Improvements at no or little cost overheads within 0%-9% of memory-durable systems</p>
  </div>
  <div class="page">
    <p>Results</p>
    <p>Implemented in ZooKeeper SAUCR improves reliability compared to memory-durable systems</p>
    <p>durable and available in 100s of crash scenarios memory-durable loses data or becomes unavailable</p>
    <p>Improvements at no or little cost overheads within 0%-9% of memory-durable systems</p>
    <p>Compared to disk-durable slight reduction in availability in extremely rare cases improves performance  2.5x on SSDs, 100x on HDDs</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Introduction Distributed updates and crash recovery</p>
    <p>disk-durable protocols memory-durable protocols</p>
    <p>Situation-aware updates and crash recovery Results Summary and conclusion</p>
  </div>
  <div class="page">
    <p>Disk-Durable Protocols</p>
  </div>
  <div class="page">
    <p>Disk-Durable Protocols</p>
    <p>Leader Follower Follower</p>
    <p>Update</p>
  </div>
  <div class="page">
    <p>Disk-Durable Protocols</p>
    <p>A=1 A=1 A=1</p>
    <p>Leader Follower Follower</p>
    <p>Update</p>
  </div>
  <div class="page">
    <p>Disk-Durable Protocols</p>
    <p>A=1 A=1 A=1</p>
    <p>A=2</p>
    <p>Leader Follower Follower</p>
    <p>Client</p>
    <p>Update</p>
  </div>
  <div class="page">
    <p>Disk-Durable Protocols</p>
    <p>A=1 A=1 A=1</p>
    <p>A=2</p>
    <p>Leader Follower Follower</p>
    <p>Client</p>
    <p>Update</p>
    <p>A=2A=2</p>
  </div>
  <div class="page">
    <p>Disk-Durable Protocols</p>
    <p>A=1 A=1 A=1</p>
    <p>A=2</p>
    <p>Leader Follower Follower</p>
    <p>Client</p>
    <p>Update</p>
    <p>A=2 A=2</p>
  </div>
  <div class="page">
    <p>Disk-Durable Protocols</p>
    <p>A=1 A=1 A=1A=2</p>
    <p>Leader Follower Follower</p>
    <p>fsync</p>
    <p>Client</p>
    <p>Update</p>
    <p>fsync</p>
    <p>A=2 A=2</p>
    <p>fsync</p>
  </div>
  <div class="page">
    <p>Disk-Durable Protocols</p>
    <p>A=1 A=1 A=1A=2</p>
    <p>Leader Follower Follower</p>
    <p>fsync</p>
    <p>Client Committed</p>
    <p>fsync completed on a majority ?</p>
    <p>Update</p>
    <p>fsync</p>
    <p>A=2 A=2</p>
    <p>fsync</p>
  </div>
  <div class="page">
    <p>Disk-Durable Protocols</p>
    <p>A=1 A=1 A=1A=2</p>
    <p>Leader Follower Follower</p>
    <p>fsync</p>
    <p>Client Committed</p>
    <p>Recovery</p>
    <p>fsync completed on a majority ?</p>
    <p>Update</p>
    <p>fsync</p>
    <p>A=2 A=2</p>
    <p>fsync</p>
  </div>
  <div class="page">
    <p>Disk-Durable Protocols</p>
    <p>A=1 A=1 A=1A=2</p>
    <p>Leader Follower Follower</p>
    <p>fsync</p>
    <p>Client Committed</p>
    <p>Recovery</p>
    <p>fsync completed on a majority ?</p>
    <p>if ackd anyone, data on disk  safe Update</p>
    <p>fsync</p>
    <p>A=2 A=2</p>
    <p>fsync</p>
  </div>
  <div class="page">
    <p>Disk-Durable Protocols</p>
    <p>A=1 A=1 A=1A=2</p>
    <p>Leader Follower Follower</p>
    <p>fsync</p>
    <p>Client Committed</p>
    <p>Recovery</p>
    <p>fsync completed on a majority ?</p>
    <p>A=1 A=2</p>
    <p>if ackd anyone, data on disk  safe Update</p>
    <p>fsync</p>
    <p>A=2 A=2</p>
    <p>fsync</p>
  </div>
  <div class="page">
    <p>Disk-Durable Protocols</p>
    <p>A=1 A=1 A=1A=2</p>
    <p>Leader Follower Follower</p>
    <p>fsync</p>
    <p>Client Committed</p>
    <p>Recovery</p>
    <p>fsync completed on a majority ?</p>
    <p>A=1 A=2</p>
    <p>if ackd anyone, data on disk  safe Update</p>
    <p>fsync</p>
    <p>A=2 A=2</p>
    <p>fsync</p>
  </div>
  <div class="page">
    <p>Disk-Durable Protocols</p>
    <p>A=1 A=1 A=1A=2</p>
    <p>Leader Follower Follower</p>
    <p>fsync</p>
    <p>Client Committed</p>
    <p>Recovery</p>
    <p>fsync completed on a majority ?</p>
    <p>A=1 A=2</p>
    <p>if ackd anyone, data on disk  safe Update</p>
    <p>fsync</p>
    <p>A=2 A=2</p>
    <p>fsync</p>
  </div>
  <div class="page">
    <p>Disk-Durable Protocols</p>
    <p>A=1 A=1 A=1A=2</p>
    <p>Leader Follower Follower</p>
    <p>fsync</p>
    <p>Client Committed</p>
    <p>Recovery</p>
    <p>fsync completed on a majority ?</p>
    <p>A=1 A=2</p>
    <p>ready</p>
    <p>im m</p>
    <p>ed ia</p>
    <p>te</p>
    <p>if ackd anyone, data on disk  safe</p>
    <p>A=1 A=2</p>
    <p>Update</p>
    <p>fsync</p>
    <p>A=2 A=2</p>
    <p>fsync recovery: just read from local disk</p>
  </div>
  <div class="page">
    <p>Disk-Durable Protocols</p>
    <p>A=1 A=1 A=1A=2</p>
    <p>Leader Follower Follower</p>
    <p>fsync</p>
    <p>Client Committed</p>
    <p>Recovery</p>
    <p>fsync completed on a majority ?</p>
    <p>A=1 A=2</p>
    <p>ready</p>
    <p>im m</p>
    <p>ed ia</p>
    <p>te</p>
    <p>if ackd anyone, data on disk  safe</p>
    <p>A=1 A=2</p>
    <p>Update</p>
    <p>fsync</p>
    <p>A=2 A=2</p>
    <p>fsync recovery: just read from local disk</p>
    <p>A=1</p>
    <p>ready</p>
    <p>im m</p>
    <p>ed ia</p>
    <p>te</p>
    <p>A=1</p>
    <p>lagging</p>
  </div>
  <div class="page">
    <p>Disk-Durable Protocols</p>
    <p>A=1 A=1 A=1A=2</p>
    <p>Leader Follower Follower</p>
    <p>fsync</p>
    <p>Client Committed</p>
    <p>Recovery</p>
    <p>fsync completed on a majority ?</p>
    <p>A=1 A=2</p>
    <p>ready</p>
    <p>im m</p>
    <p>ed ia</p>
    <p>te</p>
    <p>if ackd anyone, data on disk  safe</p>
    <p>A=1 A=2</p>
    <p>Update</p>
    <p>fsync</p>
    <p>A=2 A=2</p>
    <p>Safe and available</p>
    <p>fsync recovery: just read from local disk</p>
    <p>A=1</p>
    <p>ready</p>
    <p>im m</p>
    <p>ed ia</p>
    <p>te</p>
    <p>A=1</p>
    <p>lagging</p>
  </div>
  <div class="page">
    <p>Disk-Durable Protocols</p>
    <p>A=1 A=1 A=1A=2</p>
    <p>Leader Follower Follower</p>
    <p>fsync</p>
    <p>Client Committed</p>
    <p>Recovery</p>
    <p>But poor performance due to fsync  50x on HDDs, 2.5x on SSDs</p>
    <p>fsync completed on a majority ?</p>
    <p>A=1 A=2</p>
    <p>ready</p>
    <p>im m</p>
    <p>ed ia</p>
    <p>te</p>
    <p>if ackd anyone, data on disk  safe</p>
    <p>A=1 A=2</p>
    <p>Update</p>
    <p>fsync</p>
    <p>A=2 A=2</p>
    <p>Safe and available</p>
    <p>fsync recovery: just read from local disk</p>
    <p>A=1</p>
    <p>ready</p>
    <p>im m</p>
    <p>ed ia</p>
    <p>te</p>
    <p>A=1</p>
    <p>lagging</p>
  </div>
  <div class="page">
    <p>OSDI 18 9</p>
    <p>Leader Follower Follower</p>
    <p>Client</p>
    <p>Update</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>A=2</p>
    <p>Memory-Durable Protocols (Oblivious Recovery)</p>
  </div>
  <div class="page">
    <p>OSDI 18 9</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>Update</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2 A=2 A=2</p>
    <p>buffered on a majority ?</p>
    <p>Memory-Durable Protocols (Oblivious Recovery)</p>
  </div>
  <div class="page">
    <p>OSDI 18 9</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2 A=2 A=2</p>
    <p>buffered on a majority ?</p>
    <p>Memory-Durable Protocols (Oblivious Recovery)</p>
  </div>
  <div class="page">
    <p>OSDI 18 9</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate Oblivious: doesnt realize loss on failure</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2 A=2 A=2</p>
    <p>buffered on a majority ?</p>
    <p>Memory-Durable Protocols (Oblivious Recovery)</p>
  </div>
  <div class="page">
    <p>Memory</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate Oblivious: doesnt realize loss on failure</p>
    <p>A=1 A=2</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2 A=2 A=2</p>
    <p>buffered on a majority ?</p>
    <p>Memory-Durable Protocols (Oblivious Recovery)</p>
  </div>
  <div class="page">
    <p>Memory</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate Oblivious: doesnt realize loss on failure</p>
    <p>A=1 A=2</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2 A=2 A=2</p>
    <p>buffered on a majority ?</p>
    <p>Memory-Durable Protocols (Oblivious Recovery)</p>
  </div>
  <div class="page">
    <p>Memory</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate Oblivious: doesnt realize loss on failure</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2 A=2 A=2</p>
    <p>buffered on a majority ?</p>
    <p>Memory-Durable Protocols (Oblivious Recovery)</p>
  </div>
  <div class="page">
    <p>MemoryMemory</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate Oblivious: doesnt realize loss on failure</p>
    <p>ready</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2 A=2 A=2</p>
    <p>buffered on a majority ?</p>
    <p>im m</p>
    <p>ed ia</p>
    <p>te</p>
    <p>Memory-Durable Protocols (Oblivious Recovery)</p>
  </div>
  <div class="page">
    <p>MemoryMemory</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate Oblivious: doesnt realize loss on failure</p>
    <p>ready</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2 A=2 A=2</p>
    <p>buffered on a majority ?</p>
    <p>im m</p>
    <p>ed ia</p>
    <p>te</p>
    <p>Memory-Durable Protocols (Oblivious Recovery)</p>
    <p>e.g., ZooKeeper with forceSync = false practitioners do use this config!</p>
  </div>
  <div class="page">
    <p>MemoryMemory</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate Oblivious: doesnt realize loss on failure</p>
    <p>ready</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2 A=2 A=2</p>
    <p>buffered on a majority ?</p>
    <p>im m</p>
    <p>ed ia</p>
    <p>te</p>
    <p>Memory-Durable Protocols (Oblivious Recovery)</p>
    <p>Performant</p>
    <p>e.g., ZooKeeper with forceSync = false practitioners do use this config!</p>
  </div>
  <div class="page">
    <p>But can lead to data loss</p>
    <p>MemoryMemory</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate Oblivious: doesnt realize loss on failure</p>
    <p>ready</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2 A=2 A=2</p>
    <p>buffered on a majority ?</p>
    <p>im m</p>
    <p>ed ia</p>
    <p>te</p>
    <p>Memory-Durable Protocols (Oblivious Recovery)</p>
    <p>Performant</p>
    <p>e.g., ZooKeeper with forceSync = false practitioners do use this config!</p>
  </div>
  <div class="page">
    <p>Data Loss Example in Oblivious Approach</p>
  </div>
  <div class="page">
    <p>Data Loss Example in Oblivious Approach</p>
  </div>
  <div class="page">
    <p>Data Loss Example in Oblivious Approach</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1 committed</p>
  </div>
  <div class="page">
    <p>Data Loss Example in Oblivious Approach</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1 committed two nodes slow or failed</p>
  </div>
  <div class="page">
    <p>Data Loss Example in Oblivious Approach</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1 committed</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>two nodes slow or failed</p>
  </div>
  <div class="page">
    <p>Data Loss Example in Oblivious Approach</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1 committed</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>crashes two nodes slow or failed</p>
  </div>
  <div class="page">
    <p>Data Loss Example in Oblivious Approach</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1 committed</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>crashes two nodes slow or failed</p>
    <p>, recovers</p>
  </div>
  <div class="page">
    <p>Data Loss Example in Oblivious Approach</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1 committed</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>crashes two nodes slow or failed</p>
    <p>, recovers loses its data but oblivious:</p>
    <p>immediately joins</p>
  </div>
  <div class="page">
    <p>Data Loss Example in Oblivious Approach</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1 committed</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>crashes two nodes slow or failed</p>
    <p>, recovers loses its data but oblivious:</p>
    <p>immediately joins</p>
    <p>A=1</p>
    <p>A=1</p>
  </div>
  <div class="page">
    <p>Data Loss Example in Oblivious Approach</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1 committed</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>crashes</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>two nodes slow or failed</p>
    <p>, recovers loses its data but oblivious:</p>
    <p>immediately joins</p>
  </div>
  <div class="page">
    <p>Data Loss Example in Oblivious Approach</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1 committed</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>crashes</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>two nodes slow or failed</p>
    <p>, recovers loses its data but oblivious:</p>
    <p>immediately joins</p>
    <p>lagging nodes along with recovered node form majority;</p>
    <p>lose committed update</p>
    <p>majority do not know</p>
    <p>of previously committed update</p>
  </div>
  <div class="page">
    <p>OSDI 18 11</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>Update</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2A=2</p>
    <p>buffered on a majority ?</p>
    <p>Memory-Durable Protocols (Loss-Aware Recovery)</p>
    <p>A=2</p>
  </div>
  <div class="page">
    <p>OSDI 18 11</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2A=2</p>
    <p>buffered on a majority ?</p>
    <p>Memory-Durable Protocols (Loss-Aware Recovery)</p>
    <p>A=2</p>
  </div>
  <div class="page">
    <p>OSDI 18 11</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate</p>
    <p>Loss-aware: realizes loss, waits for majority</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2A=2</p>
    <p>buffered on a majority ?</p>
    <p>Memory-Durable Protocols (Loss-Aware Recovery)</p>
    <p>A=2</p>
  </div>
  <div class="page">
    <p>Memory</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate</p>
    <p>Loss-aware: realizes loss, waits for majority</p>
    <p>A=1 A=2</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2A=2</p>
    <p>buffered on a majority ?</p>
    <p>Memory-Durable Protocols (Loss-Aware Recovery)</p>
    <p>A=2</p>
  </div>
  <div class="page">
    <p>Memory</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate</p>
    <p>Loss-aware: realizes loss, waits for majority</p>
    <p>A=1 A=2</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2A=2</p>
    <p>buffered on a majority ?</p>
    <p>Memory-Durable Protocols (Loss-Aware Recovery)</p>
    <p>A=2</p>
  </div>
  <div class="page">
    <p>Memory</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate</p>
    <p>Loss-aware: realizes loss, waits for majority</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2A=2</p>
    <p>buffered on a majority ?</p>
    <p>Memory-Durable Protocols (Loss-Aware Recovery)</p>
    <p>A=2</p>
  </div>
  <div class="page">
    <p>OSDI 18 11</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate</p>
    <p>Loss-aware: realizes loss, waits for majority</p>
    <p>recovering wait for majority</p>
    <p>responses Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2A=2</p>
    <p>buffered on a majority ?</p>
    <p>Memory-Durable Protocols (Loss-Aware Recovery)</p>
    <p>A=2</p>
  </div>
  <div class="page">
    <p>Memory</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate</p>
    <p>Loss-aware: realizes loss, waits for majority</p>
    <p>recovering wait for majority</p>
    <p>responses</p>
    <p>ready</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2A=2</p>
    <p>buffered on a majority ?</p>
    <p>m aj</p>
    <p>o ri</p>
    <p>ty</p>
    <p>re sp</p>
    <p>o ns</p>
    <p>es</p>
    <p>Memory-Durable Protocols (Loss-Aware Recovery)</p>
    <p>A=1 A=2</p>
    <p>A=2</p>
  </div>
  <div class="page">
    <p>Memory</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate</p>
    <p>Loss-aware: realizes loss, waits for majority</p>
    <p>recovering wait for majority</p>
    <p>responses</p>
    <p>ready</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2A=2</p>
    <p>buffered on a majority ?</p>
    <p>m aj</p>
    <p>o ri</p>
    <p>ty</p>
    <p>re sp</p>
    <p>o ns</p>
    <p>es</p>
    <p>Memory-Durable Protocols (Loss-Aware Recovery)</p>
    <p>A=1 A=2</p>
    <p>A=2 e.g., Viewstamped replication</p>
  </div>
  <div class="page">
    <p>Avoids loss (unlike oblivious) but can lead to unavailability</p>
    <p>Memory</p>
    <p>Leader Follower Follower</p>
    <p>Client Committed</p>
    <p>RecoveryUpdate</p>
    <p>Loss-aware: realizes loss, waits for majority</p>
    <p>recovering wait for majority</p>
    <p>responses</p>
    <p>ready</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1</p>
    <p>Memory</p>
    <p>A=1A=2A=2</p>
    <p>buffered on a majority ?</p>
    <p>m aj</p>
    <p>o ri</p>
    <p>ty</p>
    <p>re sp</p>
    <p>o ns</p>
    <p>es</p>
    <p>Memory-Durable Protocols (Loss-Aware Recovery)</p>
    <p>A=1 A=2</p>
    <p>A=2 e.g., Viewstamped replication</p>
  </div>
  <div class="page">
    <p>Unavailability Example in Loss-Aware Approach</p>
  </div>
  <div class="page">
    <p>Unavailability Example in Loss-Aware Approach</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1 committed two nodes crashed</p>
  </div>
  <div class="page">
    <p>Unavailability Example in Loss-Aware Approach</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1 committed</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>two nodes crashed</p>
  </div>
  <div class="page">
    <p>Unavailability Example in Loss-Aware Approach</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1 committed</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>crashes two nodes crashed</p>
  </div>
  <div class="page">
    <p>Unavailability Example in Loss-Aware Approach</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1 committed</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>crashes two nodes crashed</p>
    <p>, recovers</p>
  </div>
  <div class="page">
    <p>Unavailability Example in Loss-Aware Approach</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1 committed</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>crashes two nodes crashed</p>
    <p>, recovers cannot collect</p>
    <p>majority responses although majority up  unavailable</p>
  </div>
  <div class="page">
    <p>Unavailability Example in Loss-Aware Approach</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1 committed</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>crashes two nodes crashed</p>
    <p>, recovers cannot collect</p>
    <p>majority responses although majority up  unavailable</p>
    <p>A=1</p>
    <p>A=1</p>
  </div>
  <div class="page">
    <p>Unavailability Example in Loss-Aware Approach</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1 committed</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>crashes two nodes crashed</p>
    <p>, recovers cannot collect</p>
    <p>majority responses although majority up  unavailable</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>failed nodes recover</p>
  </div>
  <div class="page">
    <p>Unavailability Example in Loss-Aware Approach</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>A=1 committed</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>crashes two nodes crashed</p>
    <p>, recovers cannot collect</p>
    <p>majority responses although majority up  unavailable</p>
    <p>A=1</p>
    <p>A=1</p>
    <p>failed nodes recover stay in recovering</p>
    <p>unavailable even after all nodes recover</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Introduction Distributed updates and crash recovery Situation-aware updates and crash recovery</p>
    <p>SAUCR insights, guarantees, and overview situation-aware updates situation-aware crash recovery</p>
    <p>Results Summary and conclusion</p>
  </div>
  <div class="page">
    <p>OSDI 18 14</p>
    <p>SAUCR Intuition and Insight</p>
  </div>
  <div class="page">
    <p>Existing protocols are static in nature: do not adapt to failures</p>
    <p>SAUCR Intuition and Insight</p>
  </div>
  <div class="page">
    <p>Existing protocols are static in nature: do not adapt to failures</p>
    <p>buffer even with many failures</p>
    <p>Memory-durable</p>
    <p>always</p>
    <p>poor reliability</p>
    <p>SAUCR Intuition and Insight</p>
  </div>
  <div class="page">
    <p>Existing protocols are static in nature: do not adapt to failures</p>
    <p>buffer even with many failures</p>
    <p>Memory-durable</p>
    <p>persist even when no failures</p>
    <p>Disk-durable</p>
    <p>alwaysalways</p>
    <p>poor reliability poor performance</p>
    <p>SAUCR Intuition and Insight</p>
  </div>
  <div class="page">
    <p>Existing protocols are static in nature: do not adapt to failures</p>
    <p>Insight: reacting to failures and adapting to situation can achieve reliability and performance</p>
    <p>buffer even with many failures</p>
    <p>Memory-durable</p>
    <p>persist even when no failures</p>
    <p>Disk-durable</p>
    <p>alwaysalways</p>
    <p>poor reliability poor performance</p>
    <p>SAUCR Intuition and Insight</p>
  </div>
  <div class="page">
    <p>Existing protocols are static in nature: do not adapt to failures</p>
    <p>Insight: reacting to failures and adapting to situation can achieve reliability and performance</p>
    <p>when no or few failures could buffer in memory</p>
    <p>buffer even with many failures</p>
    <p>Memory-durable</p>
    <p>persist even when no failures</p>
    <p>Disk-durable</p>
    <p>alwaysalways common case</p>
    <p>when many or all up</p>
    <p>buffer in memory</p>
    <p>Memory-durable</p>
    <p>poor reliability poor performance</p>
    <p>SAUCR Intuition and Insight</p>
  </div>
  <div class="page">
    <p>Existing protocols are static in nature: do not adapt to failures</p>
    <p>Insight: reacting to failures and adapting to situation can achieve reliability and performance</p>
    <p>when no or few failures could buffer in memory when failure arise, flush</p>
    <p>buffer even with many failures</p>
    <p>Memory-durable</p>
    <p>persist even when no failures</p>
    <p>Disk-durable</p>
    <p>alwaysalways with failures</p>
    <p>when only minimum up common case</p>
    <p>when many or all up</p>
    <p>buffer in memory</p>
    <p>flush to disk</p>
    <p>Memory-durable Disk-durable</p>
    <p>poor reliability poor performance</p>
    <p>SAUCR Intuition and Insight</p>
  </div>
  <div class="page">
    <p>Guarantees Depend upon Simultaneity of Failures</p>
  </div>
  <div class="page">
    <p>Guarantees Depend upon Simultaneity of Failures</p>
    <p>With non-simultaneous, gap exists, SAUCR can react and ensures durability</p>
  </div>
  <div class="page">
    <p>Guarantees Depend upon Simultaneity of Failures</p>
    <p>With non-simultaneous, gap exists, SAUCR can react and ensures durability independent: likelihood of many nodes failing together is negligible</p>
  </div>
  <div class="page">
    <p>Guarantees Depend upon Simultaneity of Failures</p>
    <p>With non-simultaneous, gap exists, SAUCR can react and ensures durability independent: likelihood of many nodes failing together is negligible correlated: many nodes fail together</p>
    <p>although many nodes fail, not necessarily simultaneous; most cases, non-simultaneous</p>
  </div>
  <div class="page">
    <p>Guarantees Depend upon Simultaneity of Failures</p>
    <p>With non-simultaneous, gap exists, SAUCR can react and ensures durability independent: likelihood of many nodes failing together is negligible correlated: many nodes fail together</p>
    <p>although many nodes fail, not necessarily simultaneous; most cases, non-simultaneous</p>
    <p>With simultaneous correlated, no gap, SAUCR cannot react, unavailable</p>
  </div>
  <div class="page">
    <p>Guarantees Depend upon Simultaneity of Failures</p>
    <p>With non-simultaneous, gap exists, SAUCR can react and ensures durability independent: likelihood of many nodes failing together is negligible correlated: many nodes fail together</p>
    <p>although many nodes fail, not necessarily simultaneous; most cases, non-simultaneous</p>
    <p>With simultaneous correlated, no gap, SAUCR cannot react, unavailable</p>
    <p>We conjecture they are extremely rare: a gap exists between failures correlated but a few seconds apart [Ford et al., OSDI 10] analysis reveals a gap of 50 ms or more almost always</p>
  </div>
  <div class="page">
    <p>Guarantees Depend upon Simultaneity of Failures</p>
    <p>With non-simultaneous, gap exists, SAUCR can react and ensures durability independent: likelihood of many nodes failing together is negligible correlated: many nodes fail together</p>
    <p>although many nodes fail, not necessarily simultaneous; most cases, non-simultaneous</p>
    <p>With simultaneous correlated, no gap, SAUCR cannot react, unavailable</p>
    <p>We conjecture they are extremely rare: a gap exists between failures correlated but a few seconds apart [Ford et al., OSDI 10] analysis reveals a gap of 50 ms or more almost always</p>
    <p>Most cases: any no. of independent and non-simultaneous correlated  same as disk-durable Rare cases: more than a majority crash truly simultaneously  remain unavailable</p>
  </div>
  <div class="page">
    <p>SAUCR Overview</p>
  </div>
  <div class="page">
    <p>SAUCR Overview</p>
    <p>Updates when more than a majority up, buffer updates in memory  fast mode</p>
    <p>e.g., 4 or 5 nodes up in a 5-node cluster</p>
  </div>
  <div class="page">
    <p>SAUCR Overview</p>
    <p>Updates when more than a majority up, buffer updates in memory  fast mode</p>
    <p>e.g., 4 or 5 nodes up in a 5-node cluster</p>
    <p>When nodes fail and only a bare majority alive, flush to disk  slow mode e.g., only 3 nodes up in a 5-node cluster</p>
  </div>
  <div class="page">
    <p>SAUCR Overview</p>
    <p>Updates when more than a majority up, buffer updates in memory  fast mode</p>
    <p>e.g., 4 or 5 nodes up in a 5-node cluster</p>
    <p>When nodes fail and only a bare majority alive, flush to disk  slow mode e.g., only 3 nodes up in a 5-node cluster</p>
    <p>Crash Recovery when a node recovers from a crash, it recovers its data</p>
    <p>either from its disk (if crashed in slow mode) or from other nodes (if crashed in fast mode)</p>
  </div>
  <div class="page">
    <p>Situation-Aware Updates</p>
  </div>
  <div class="page">
    <p>Situation-Aware Updates</p>
    <p>L</p>
    <p>all nodes up</p>
  </div>
  <div class="page">
    <p>Situation-Aware Updates</p>
    <p>L</p>
    <p>all nodes up fast mode</p>
    <p>buffer updates</p>
  </div>
  <div class="page">
    <p>Situation-Aware Updates</p>
    <p>L L</p>
    <p>all nodes up 4 nodes up (more than majority)fast mode</p>
    <p>buffer updates</p>
  </div>
  <div class="page">
    <p>Situation-Aware Updates</p>
    <p>L L</p>
    <p>all nodes up 4 nodes up (more than majority)fast mode</p>
    <p>buffer updates remain in fast mode</p>
  </div>
  <div class="page">
    <p>Situation-Aware Updates</p>
    <p>L L L</p>
    <p>all nodes up 4 nodes up (more than majority)</p>
    <p>only majority up fast mode</p>
    <p>buffer updates remain in fast mode</p>
  </div>
  <div class="page">
    <p>Situation-Aware Updates</p>
    <p>L L L</p>
    <p>all nodes up 4 nodes up (more than majority)</p>
    <p>only majority up fast mode</p>
    <p>buffer updates remain in fast mode</p>
    <p>switch to slow, flush to disk</p>
  </div>
  <div class="page">
    <p>Situation-Aware Updates</p>
    <p>L L L L</p>
    <p>all nodes up 4 nodes up (more than majority)</p>
    <p>only majority up fast mode</p>
    <p>buffer updates remain in fast mode</p>
    <p>switch to slow, flush to disk</p>
  </div>
  <div class="page">
    <p>Situation-Aware Updates</p>
    <p>L L L L</p>
    <p>all nodes up 4 nodes up (more than majority)</p>
    <p>only majority up commit subsequent</p>
    <p>updates in slow mode</p>
    <p>fast mode buffer updates remain in</p>
    <p>fast mode</p>
    <p>switch to slow, flush to disk</p>
  </div>
  <div class="page">
    <p>Situation-Aware Updates</p>
    <p>L L L L L</p>
    <p>all nodes up 4 nodes up (more than majority)</p>
    <p>only majority up commit subsequent</p>
    <p>updates in slow mode</p>
    <p>one node recovers and catches up;fast mode</p>
    <p>buffer updates remain in fast mode</p>
    <p>switch to slow, flush to disk</p>
  </div>
  <div class="page">
    <p>Situation-Aware Updates</p>
    <p>L L L L L</p>
    <p>all nodes up 4 nodes up (more than majority)</p>
    <p>only majority up commit subsequent</p>
    <p>updates in slow mode</p>
    <p>one node recovers and catches up;fast mode</p>
    <p>buffer updates remain in fast mode</p>
    <p>switch to slow, flush to disk</p>
  </div>
  <div class="page">
    <p>Situation-Aware Updates</p>
    <p>L L L L L</p>
    <p>all nodes up 4 nodes up (more than majority)</p>
    <p>only majority up commit subsequent</p>
    <p>updates in slow mode</p>
    <p>one node recovers and catches up;fast mode</p>
    <p>buffer updates remain in fast mode</p>
    <p>switch to slow, flush to disk</p>
  </div>
  <div class="page">
    <p>Situation-Aware Updates</p>
    <p>L L L L L</p>
    <p>all nodes up 4 nodes up (more than majority)</p>
    <p>only majority up commit subsequent</p>
    <p>updates in slow mode</p>
    <p>one node recovers and catches up;fast mode</p>
    <p>buffer updates remain in fast mode</p>
    <p>switch to slow, flush to disk switch to fast</p>
  </div>
  <div class="page">
    <p>Failure Reaction</p>
    <p>Basic failure-detection mechanism: heartbeats</p>
    <p>remain in fast mode</p>
    <p>Follower failures</p>
    <p>switch to slow mode</p>
    <p>Leader failures</p>
    <p>on a missing heartbeat, followers flush to disk</p>
    <p>Leader Leader</p>
    <p>Challenges: too many packets, spurious elections, too much data to flush Techniques in the paper</p>
    <p>Result: can react to failures even when they are only a few milliseconds apart, preserving durability and availability</p>
    <p>steps down</p>
  </div>
  <div class="page">
    <p>Mode-Aware Crash Recovery</p>
  </div>
  <div class="page">
    <p>Disk-durable: always recover from disk Memory-durable: always recover from other nodes (loss-aware)</p>
    <p>Mode-Aware Crash Recovery</p>
  </div>
  <div class="page">
    <p>Disk-durable: always recover from disk Memory-durable: always recover from other nodes (loss-aware)</p>
    <p>Mode-Aware Crash Recovery</p>
    <p>SAUCR</p>
  </div>
  <div class="page">
    <p>Disk-durable: always recover from disk Memory-durable: always recover from other nodes (loss-aware)</p>
    <p>Mode-Aware Crash Recovery</p>
    <p>SAUCR</p>
  </div>
  <div class="page">
    <p>Disk-durable: always recover from disk Memory-durable: always recover from other nodes (loss-aware)</p>
    <p>Mode-Aware Crash Recovery</p>
    <p>SAUCR</p>
  </div>
  <div class="page">
    <p>Disk-durable: always recover from disk Memory-durable: always recover from other nodes (loss-aware)</p>
    <p>Mode-Aware Crash Recovery</p>
    <p>SAUCR</p>
  </div>
  <div class="page">
    <p>Disk-durable: always recover from disk Memory-durable: always recover from other nodes (loss-aware)</p>
    <p>Mode-Aware Crash Recovery</p>
    <p>SAUCR</p>
    <p>recover from local disk</p>
  </div>
  <div class="page">
    <p>Disk-durable: always recover from disk Memory-durable: always recover from other nodes (loss-aware)</p>
    <p>Mode-Aware Crash Recovery</p>
    <p>SAUCR</p>
    <p>recover from local disk</p>
    <p>ready</p>
    <p>immediate</p>
  </div>
  <div class="page">
    <p>Disk-durable: always recover from disk Memory-durable: always recover from other nodes (loss-aware)</p>
    <p>Mode-Aware Crash Recovery</p>
    <p>SAUCR</p>
    <p>recover from local disk</p>
    <p>ready</p>
    <p>immediate</p>
  </div>
  <div class="page">
    <p>Disk-durable: always recover from disk Memory-durable: always recover from other nodes (loss-aware)</p>
    <p>Mode-Aware Crash Recovery</p>
    <p>SAUCR</p>
    <p>recover from local disk</p>
    <p>ready</p>
    <p>lost updates</p>
    <p>recover from other nodes</p>
    <p>immediate</p>
  </div>
  <div class="page">
    <p>Disk-durable: always recover from disk Memory-durable: always recover from other nodes (loss-aware)</p>
    <p>Mode-Aware Crash Recovery</p>
    <p>SAUCR</p>
    <p>recover from local disk</p>
    <p>ready</p>
    <p>lost updates</p>
    <p>recover from other nodes</p>
    <p>a bare minority (bare majority - 1) responses</p>
    <p>immediate</p>
  </div>
  <div class="page">
    <p>Disk-durable: always recover from disk Memory-durable: always recover from other nodes (loss-aware)</p>
    <p>Mode-Aware Crash Recovery</p>
    <p>SAUCR</p>
    <p>recover from local disk</p>
    <p>ready</p>
    <p>lost updates</p>
    <p>recover from other nodes</p>
    <p>ready</p>
    <p>a bare minority (bare majority - 1) responses</p>
    <p>immediate</p>
  </div>
  <div class="page">
    <p>Intuition for why SAUCRs recovery is safe</p>
  </div>
  <div class="page">
    <p>Intuition for why SAUCRs recovery is safe</p>
    <p>Assume update-A committed, S1 recovers and has seen A before crash S1</p>
  </div>
  <div class="page">
    <p>Intuition for why SAUCRs recovery is safe</p>
    <p>Assume update-A committed, S1 recovers and has seen A before crash</p>
    <p>Safety condition: update-A must be recovered</p>
    <p>S1</p>
  </div>
  <div class="page">
    <p>Intuition for why SAUCRs recovery is safe</p>
    <p>Assume update-A committed, S1 recovers and has seen A before crash</p>
    <p>Safety condition: update-A must be recovered If A was committed in fast mode, then at least one in any bare minority must contain update-A</p>
    <p>AAA</p>
    <p>S1</p>
  </div>
  <div class="page">
    <p>Intuition for why SAUCRs recovery is safe</p>
    <p>Assume update-A committed, S1 recovers and has seen A before crash</p>
    <p>Safety condition: update-A must be recovered If A was committed in fast mode, then at least one in any bare minority must contain update-A If update-A was committed in slow mode, S1 recovers from disk</p>
    <p>A AA</p>
    <p>S1</p>
  </div>
  <div class="page">
    <p>Intuition for why SAUCRs recovery is safe</p>
    <p>Assume update-A committed, S1 recovers and has seen A before crash</p>
    <p>Safety condition: update-A must be recovered If A was committed in fast mode, then at least one in any bare minority must contain update-A If update-A was committed in slow mode, S1 recovers from disk Proof sketch in the paper</p>
    <p>A AA</p>
    <p>S1</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Introduction Distributed updates and crash recovery Situation-aware updates and crash recovery Results Summary and conclusion</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>We implement in SAUCR in ZooKeeper Compare SAUCRs reliability and performance against</p>
    <p>disk-durable ZooKeeper (forceSync = true) memory-durable ZooKeeper (forceSync = false) viewstamped replication (ideal model)</p>
  </div>
  <div class="page">
    <p>Reliability Testing</p>
    <p>Cluster crash-testing framework Generates cluster-state sequences</p>
    <p>How it works? Please see our paper</p>
  </div>
  <div class="page">
    <p>Reliability Results</p>
    <p>Correct Unavailable Data loss Correct Unavailable Data loss</p>
    <p>Systems memory-durable</p>
    <p>zookeeper viewstamped replication</p>
    <p>disk-durable zookeeper SAUCR 1200 64 0</p>
    <p>Simultaneous</p>
    <p>non-simultaneous: gap of 50 ms, simultaneous: no gap memory-durable zookeeper silently loses data viewstamped replication leads to permanent unavailability SAUCR reacts to non-simultaneous  durable and available other systems behave the same as non-simultaneous cases simultaneous: SAUCR by design remains unavailable in some cases</p>
    <p>Non-Simultaneous</p>
  </div>
  <div class="page">
    <p>Macro-benchmark Performance: YCSB-load</p>
    <p>Compared to disk-durable, both memory-durable and SAUCR are faster SAUCRs performance matches memory-durable ZooKeeper</p>
    <p>within 9% of memory-durable Zookeeper even for write-intensive workloads overheads because SAUCR writes to one additional node</p>
    <p>HDD SSD</p>
    <p>T hr</p>
    <p>o ug</p>
    <p>hp ut</p>
    <p>(K</p>
    <p>O ps</p>
    <p>/s )</p>
    <p>Memory-durable ZooKeeper SAUCR Disk-durable ZooKeeper</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Replication protocols are an important foundation need to be performant, yet also provide high reliability</p>
    <p>Dichotomy: disk-durable vs. memory-durable protocols unsavory choices: either performant or reliable</p>
    <p>SAUCR  situation-aware updates and crash recovery provides both high performance and reliability</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>Paying careful attention to how failures occur can find approaches that provide both performance and reliability more data from real-world deployments?</p>
    <p>Hybrid approach  an effective systems-design technique  applicable to distributed updates and recovery too</p>
    <p>worthwhile to look at other important protocols/systems where we make similar two-ends-of-the-spectrum tradeoffs?</p>
    <p>Thank you! Poster #6</p>
  </div>
</Presentation>
