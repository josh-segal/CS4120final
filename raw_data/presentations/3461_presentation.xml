<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Tommaso Frassetto, Patrick Jauernig, Christopher Liebchen, Ahmad-Reza Sadeghi</p>
    <p>Technische Universitt Darmstadt</p>
    <p>IMIX: Hardware-Enforced In-Process Memory Isolation</p>
  </div>
  <div class="page">
    <p>IMIX</p>
    <p>Application</p>
    <p>Mitigations Safe Region</p>
    <p>App Code</p>
    <p>Mitigations Safe Region</p>
    <p>Mitigation Code</p>
    <p>Application</p>
    <p>Mitigations Safe Region</p>
    <p>App Code</p>
    <p>Mitigation Code</p>
    <p>State of the Art IMIX</p>
    <p>Memory Isolation</p>
  </div>
  <div class="page">
    <p>Why is in-process memory isolation a good idea?</p>
  </div>
  <div class="page">
    <p>Inter- &amp; In-Process Isolation</p>
    <p>App</p>
    <p>Operating System</p>
    <p>Hardware</p>
    <p>App App</p>
    <p>Inter-Process Isolation enforced by OS</p>
  </div>
  <div class="page">
    <p>Inter- &amp; In-Process Isolation</p>
    <p>Application</p>
    <p>App</p>
    <p>Operating System</p>
    <p>Hardware</p>
    <p>App App</p>
    <p>Inter-Process Isolation enforced by OS</p>
    <p>Memory</p>
    <p>CodeCode</p>
    <p>Memory</p>
    <p>Code</p>
  </div>
  <div class="page">
    <p>Inter- &amp; In-Process Isolation</p>
    <p>Application</p>
    <p>App</p>
    <p>Operating System</p>
    <p>Hardware</p>
    <p>App App</p>
    <p>Inter-Process Isolation enforced by OS</p>
    <p>Memory</p>
    <p>CodeCode</p>
    <p>In-Process Isolation</p>
  </div>
  <div class="page">
    <p>Shadow Stack</p>
    <p>Backup return addresses</p>
    <p>Address gets restored before ret is called</p>
    <p>Buffer</p>
    <p>Parameters</p>
    <p>Malicious Input</p>
    <p>Return AddressReturn Address</p>
    <p>FUNC A</p>
    <p>FUNC B</p>
    <p>Code</p>
    <p>Stack</p>
    <p>Shadow Stack</p>
    <p>Return Address 0xcafecafe</p>
    <p>Return Address</p>
  </div>
  <div class="page">
    <p>Shadow Stack</p>
    <p>Backup return addresses</p>
    <p>Address gets restored before ret is called</p>
    <p>Buffer</p>
    <p>Parameters</p>
    <p>Malicious Input</p>
    <p>Return AddressReturn Address</p>
    <p>FUNC A</p>
    <p>FUNC B</p>
    <p>Code</p>
    <p>Stack</p>
    <p>Shadow Stack</p>
    <p>Return Address 0xcafecafe</p>
  </div>
  <div class="page">
    <p>Shadow Stack</p>
    <p>Backup return addresses</p>
    <p>Address gets restored before ret is called</p>
    <p>Buffer</p>
    <p>Parameters</p>
    <p>Malicious Input</p>
    <p>Return AddressReturn Address</p>
    <p>FUNC A</p>
    <p>FUNC B</p>
    <p>Code</p>
    <p>Stack</p>
    <p>Shadow Stack</p>
    <p>Return Address 0xcafecafe</p>
    <p>Shadow Stack begins at</p>
  </div>
  <div class="page">
    <p>Our Contribution</p>
    <p>Complete pipeline from compiler down to hardwareMemory isolation primitive</p>
    <p>PoC implementation Implemented compiler support &amp; use case</p>
    <p>Thorough evaluation Compared high-frequency memory domain switching performance to related work</p>
  </div>
  <div class="page">
    <p>In-Process Isolation</p>
    <p>Memory Protection Keys e.g., Intel PKU</p>
    <p>W</p>
    <p>R</p>
    <p>R</p>
    <p>MemoryPermission Table</p>
    <p>write</p>
    <p>Randomization</p>
    <p>Base Register</p>
    <p>Memory</p>
    <p>read [reg+192]</p>
    <p>Hardware Bounds Checking e.g., Intel MPX</p>
    <p>Bounds Check 0x123ab</p>
    <p>Problem</p>
  </div>
  <div class="page">
    <p>In-Process Isolation</p>
    <p>Memory Protection Keys e.g., Intel PKU</p>
    <p>W</p>
    <p>R</p>
    <p>R</p>
    <p>MemoryPermission Table</p>
    <p>write</p>
    <p>Randomization</p>
    <p>Base Register</p>
    <p>Memory</p>
    <p>read [reg+192]</p>
    <p>Hardware Bounds Checking e.g., Intel MPX</p>
    <p>Bounds Check 0x123ab</p>
    <p>Problem Problems</p>
    <p>Entropy-based: single information leak breaks isolation</p>
    <p>Problems</p>
    <p>Excessive instrumentation</p>
    <p>High performance overhead</p>
    <p>Problems</p>
    <p>High performance overhead for frequent switches</p>
  </div>
  <div class="page">
    <p>What characteristics should a memory isolation primitive have?</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>Policy-based Isolation Hardware</p>
    <p>Enforced</p>
    <p>Fast Interleaved</p>
    <p>Access</p>
    <p>Fails Safe</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>Goal: build a practical primitive that incorporates all aspects</p>
    <p>Technique Policy-based Isolation Hardware Enforced</p>
    <p>Fast Interleaved Access</p>
    <p>Fails Safe</p>
    <p>SFI [1]</p>
    <p>Segmentation only for x86-32</p>
    <p>Memory Hiding</p>
    <p>Paging / EPT only single-threaded applications</p>
    <p>Intel MPK</p>
    <p>Intel SGX</p>
    <p>Intel MPX   ()</p>
    <p>Intel CET only for Shadow Stack</p>
    <p>[1] D. Sehr, R. Muth, C. Biffle, V. Khimenko, E. Pasko, K. Schimpf, B. Yee, and B. Chen. Adapting software fault isolation to contemporary cpu architectures. In 18th USENIX Security Symposium, USENIX Sec, 2010.</p>
  </div>
  <div class="page">
    <p>Our Solution: IMIX</p>
    <p>Hardware-enforced in-process memory isolation</p>
    <p>Isolation primitive for mitigations at page granularity</p>
    <p>Two separate memory realms</p>
    <p>smov instruction to load/store sensitive data</p>
    <p>mov instruction for regular memory Code</p>
    <p>Sensitive Data</p>
    <p>Run-Time Defense Metadata</p>
    <p>Application</p>
    <p>IMIXIMIX</p>
    <p>IMIX</p>
    <p>WX</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>Technique Policy-based Isolation Hardware Enforced</p>
    <p>Fast Interleaved Access</p>
    <p>Fails Safe</p>
    <p>SFI [1]</p>
    <p>Segmentation only for x86-32</p>
    <p>Memory Hiding</p>
    <p>Paging / EPT only single-threaded applications</p>
    <p>Intel MPK</p>
    <p>Intel SGX</p>
    <p>Intel MPX   ()</p>
    <p>Intel CET only for Shadow Stack</p>
    <p>IMIX</p>
  </div>
  <div class="page">
    <p>IMIX in Action: Shadow Stack Revisited</p>
    <p>IMIX isolates Shadow Stack deterministically</p>
    <p>Exclusively use smov for Shadow Stack</p>
    <p>Buffer</p>
    <p>Parameters</p>
    <p>Malicious Input</p>
    <p>Return AddressReturn Address</p>
    <p>FUNC A</p>
    <p>FUNC B</p>
    <p>Code</p>
    <p>Stack</p>
    <p>Shadow Stack</p>
    <p>Return Address 0xcafecafe</p>
    <p>Shadow Stack begins at</p>
    <p>IMIX</p>
    <p>mov</p>
    <p>sm o</p>
    <p>v</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Clang</p>
    <p>LLVM Extension</p>
    <p>mprotect(page, PROT_IMIX)</p>
    <p>User Program</p>
    <p>mov i, rcx</p>
    <p>smov i, rcx</p>
    <p>smov s, rcx</p>
    <p>mov s, rcx</p>
    <p>C/C++ Source</p>
    <p>smov-based load/store for compiler IR</p>
  </div>
  <div class="page">
    <p>Page table bit to mark page sensitive</p>
    <p>PT-bit management for Kernel</p>
    <p>Implementation</p>
    <p>OS Kernel</p>
    <p>Page permissions</p>
    <p>Memory</p>
    <p>Page Tables</p>
    <p>IMIX bit</p>
    <p>Normal Memory</p>
    <p>Protected Memory</p>
    <p>i: 0x18192021</p>
    <p>s: 0x39404142</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>OS Kernel</p>
    <p>Page permissions</p>
    <p>CPU</p>
    <p>Core MMU</p>
    <p>smov check</p>
    <p>smov</p>
    <p>Memory</p>
    <p>Page Tables</p>
    <p>IMIX bit</p>
    <p>Normal Memory</p>
    <p>Protected Memory</p>
    <p>i: 0x18192021</p>
    <p>s: 0x39404142</p>
    <p>ISA extension &amp; MMU check</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>OS Kernel</p>
    <p>Page permissions</p>
    <p>CPU</p>
    <p>Core MMU</p>
    <p>smov check</p>
    <p>smov</p>
    <p>Memory</p>
    <p>Page Tables</p>
    <p>IMIX bit</p>
    <p>Normal Memory</p>
    <p>Protected Memory</p>
    <p>i: 0x18192021</p>
    <p>s: 0x39404142</p>
    <p>Clang</p>
    <p>LLVM Extension</p>
    <p>mprotect(page, PROT_IMIX)</p>
    <p>User Program</p>
    <p>mov i, rcx</p>
    <p>smov i, rcx</p>
    <p>smov s, rcx</p>
    <p>mov s, rcx</p>
    <p>C/C++ Source</p>
  </div>
  <div class="page">
    <p>Use-Case Evaluation: CPI</p>
    <p>CPI [2] prevents code-reuse attacks</p>
    <p>Move Code pointers and indirect code pointers to safe region  integrity</p>
    <p>BUT: safe region is only hidden  exploited by Evans et al. [3]</p>
    <p>jmp 0x0(gs)</p>
    <p>FUNC A</p>
    <p>Code</p>
    <p>CPI Metadata</p>
    <p>&amp;FUNC A gs</p>
    <p>[3] I. Evans, S. Fingeret, J. Gonzalez, U. Otgonbaatar, T. Tang, H. Shrobe, S. Sidiroglou-Douskos, M. Rinard, and H. Okhravi. Missing the point(er): On the effectiveness of code pointer integrity. In 36th IEEE Symposium on Security and Privacy, S&amp;P, 2015.</p>
    <p>[2] V. Kuznetsov, L. Szekeres, M. Payer, G. Candea, R. Sekar, and D. Song. Code-pointer integrity. In 11th USENIX Symposium on Operating Systems Design and Implementation, OSDI, 2014.</p>
  </div>
  <div class="page">
    <p>Use-Case: CPI - Replace Hiding with IMIX</p>
    <p>CPI evaluated different approaches for safe region protection</p>
    <p>Benefit: highly-modular implementation</p>
    <p>Added IMIX memory allocation</p>
    <p>Changed register-offset addressing to direct accesses mov 0x40(gs), ptr smov 0xcafecafe+0x40, ptr</p>
  </div>
  <div class="page">
    <p>Evaluation: CPI using IMIX</p>
    <p>CPI+Seg - CPI+IMIX CPI+MPK - CPI+MPX</p>
    <p>Perf. Overhead [%]</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>IMIX is the first practical solution for in-process memory isolation</p>
    <p>Isolation is enforced at page granularity</p>
    <p>Existing approaches cannot be leveraged for CFI/CPI</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Can IMIX be adapted to protect the complete memory pipeline?</p>
    <p>Are there new mitigation approaches that IMIX enables?</p>
  </div>
  <div class="page">
    <p>Tommaso Frassetto, Patrick Jauernig, Christopher Liebchen, Ahmad-Reza Sadeghi</p>
    <p>Technische Universitt Darmstadt</p>
    <p>IMIX: Hardware-Enforced In-Process Memory Isolation</p>
  </div>
</Presentation>
