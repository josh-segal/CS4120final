<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Frenetic: A High-Level Language for OpenFlow Networks Nate Foster, Rob Harrison, Matthew L. Meola, Michael J. Freedman, Jennifer Rexford, David Walker</p>
    <p>PRESTO 2010, Philadelphia, PA</p>
    <p>PRESTO 2010, Philadelphia, PA</p>
  </div>
  <div class="page">
    <p>Background</p>
    <p>OpenFlow/NOX allowed us to take back the network  Direct access to dataplane hardware  Programmable control plane via open API</p>
    <p>OpenFlow/NOX made innovation possible, not easy  Low level interface mirrors hardware  Thin layer of abstraction  Few built-in features</p>
    <p>So lets give the network programmer some help</p>
  </div>
  <div class="page">
    <p>OpenFlow Architecture</p>
    <p>Priorit y</p>
    <p>Pattern Action Counters</p>
    <p>Physical Port, Link Source/Destination/Type, VLAN, Network Source/Destination/Type, Transport Source/Destination</p>
    <p>Forward Modify Drop</p>
    <p>Bytes, Count</p>
    <p>OpenFlow Switch Flow Table</p>
    <p>Controller</p>
    <p>Switches</p>
    <p>Network Events  Flow table miss  Port status  Join/leave  Query responses</p>
    <p>Control Messages  Send packet  Add/remove flow  Statistics Queries</p>
  </div>
  <div class="page">
    <p>NOXNOX</p>
    <p>Programming Networks with NOX</p>
    <p>In general, program modules do not compose  If m yields r, and some m yields r, then (m ^ m ) does</p>
    <p>not yield (r ^ r)</p>
    <p>ForwardingForwarding MonitoringMonitoring Access ControlAccess Control</p>
    <p>Application</p>
    <p>Destination addressing</p>
    <p>Transport ports  Individual MACs</p>
  </div>
  <div class="page">
    <p>Example</p>
    <p>Simple Network Repeater  Forward packets received on port 1 out 2; vice versa</p>
    <p>Controller</p>
    <p>Switch</p>
  </div>
  <div class="page">
    <p>Simple Repeater</p>
    <p>def simple_repeater(): # Repeat Port 1 to Port 2 p1 = {IN_PORT:1} a1 = [(OFPAT_OUTPUT, PORT_2)] install(switch, p1, HIGH, a1) # Repeat Port 2 to Port 1 p2 = {IN_PORT:2} a2 = [(OFPAT_OUTPUT, PORT_1)] install(switch, p2, HIGH, a2)</p>
    <p>def simple_repeater(): # Repeat Port 1 to Port 2 p1 = {IN_PORT:1} a1 = [(OFPAT_OUTPUT, PORT_2)] install(switch, p1, HIGH, a1) # Repeat Port 2 to Port 1 p2 = {IN_PORT:2} a2 = [(OFPAT_OUTPUT, PORT_1)] install(switch, p2, HIGH, a2)</p>
    <p>Priority Pattern Action Counters HIGH IN_PORT:1 OUTPUT:2 (0,0)</p>
    <p>HIGH IN_PORT:2 OUTPUT:1 (0,0)</p>
    <p>NOX Program</p>
    <p>Flow Table</p>
    <p>Controller</p>
    <p>Switch</p>
  </div>
  <div class="page">
    <p>Example</p>
    <p>Simple Network Repeater  Forward packets received on port 1 out 2; vice versa  Monitor incoming HTTP traffic totals per host</p>
    <p>Controller</p>
    <p>Switch</p>
    <p>with Host Monitoring</p>
  </div>
  <div class="page">
    <p>Simple Repeater with Host Monitoring</p>
    <p># Repeat port 1 to 2 def port1_to_2(): p1 = {IN_PORT:1} a1 = [(OFPAT_OUTPUT, PORT_2)] install(switch, p1, HIGH, a1)</p>
    <p># Callback to generate rules per host def packet_in(switch, inport, pkt): p = {DL_DST:dstmac(pkt)} pweb = {DL_DST:dstmac(pkt), DL_TYPE:IP,NW_PROTO:TCP, TP_SRC:80} a = [(OFPAT_OUTPUT, PORT_1)] install(switch, pweb, HIGH, a) install(switch, p, MEDIUM, a)</p>
    <p>def main(): register_callback(packet_in) port1_to_2()</p>
    <p># Repeat port 1 to 2 def port1_to_2(): p1 = {IN_PORT:1} a1 = [(OFPAT_OUTPUT, PORT_2)] install(switch, p1, HIGH, a1)</p>
    <p># Callback to generate rules per host def packet_in(switch, inport, pkt): p = {DL_DST:dstmac(pkt)} pweb = {DL_DST:dstmac(pkt), DL_TYPE:IP,NW_PROTO:TCP, TP_SRC:80} a = [(OFPAT_OUTPUT, PORT_1)] install(switch, pweb, HIGH, a) install(switch, p, MEDIUM, a)</p>
    <p>def main(): register_callback(packet_in) port1_to_2()</p>
    <p>Priorit y</p>
    <p>Pattern Action Counte rs</p>
    <p>HIGH {IN_PORT:1} OUTPUT:2 (0,0)</p>
    <p>HIGH {DL_DST:mac,DL_TYPE:IP_TYPE,NW_PROTO:TCP, TP_SRC:80}</p>
    <p>OUTPUT:1 (0,0)</p>
    <p>MEDIUM {DL_DST:mac} OUTPUT:1 (0,0)</p>
    <p>def simple_repeater(): # Port 1 to port 2 p1 = {IN_PORT:1} a1 = [(OFPAT_OUTPUT, PORT_2)] install(switch, p1, HIGH, a1) # Port 2 to Port 1 p2 = {IN_PORT:2} a2 = [(OFPAT_OUTPUT, PORT_1)] install(switch, p2, HIGH, a2)</p>
    <p>def simple_repeater(): # Port 1 to port 2 p1 = {IN_PORT:1} a1 = [(OFPAT_OUTPUT, PORT_2)] install(switch, p1, HIGH, a1) # Port 2 to Port 1 p2 = {IN_PORT:2} a2 = [(OFPAT_OUTPUT, PORT_1)] install(switch, p2, HIGH, a2)</p>
  </div>
  <div class="page">
    <p>OpenFlow/NOX Difficulties</p>
    <p>Low-level, brittle rules  No support for operations like union and intersection</p>
    <p>Split architecture  Between logic running on the switch and controller</p>
    <p>No compositionality  Manual refactoring of rules to compose subprograms</p>
    <p>Asynchronous interactions  Between switch and controller</p>
  </div>
  <div class="page">
    <p>Our Solution: Frenetic</p>
    <p>A High-level Language  High-level patterns to describe flows</p>
    <p>Unified abstraction  Composition</p>
    <p>A Run-time System  Handles module interactions</p>
    <p>Deals with asynchronous behavior</p>
    <p>NOX</p>
  </div>
  <div class="page">
    <p>Frenetic Version</p>
    <p># Static repeating between ports 1 and 2 def simple_repeater(): rules=[Rule(inport_fp(1), [output(2)]), Rule(inport_fp(2), [output(1)])] register_static(rules)</p>
    <p># per host monitoring es: E(int) def per_host_monitoring(): q = (Select(bytes) * Where(protocol(tcp) &amp; srcport(80))* GroupBy([dstmac]) * Every(60)) log = Print(HTTP Bytes:) q &gt;&gt; l</p>
    <p># Composition of two separate modules def main(): simple_repeater() per_host_monitoring()</p>
    <p># Static repeating between ports 1 and 2 def simple_repeater(): rules=[Rule(inport_fp(1), [output(2)]), Rule(inport_fp(2), [output(1)])] register_static(rules)</p>
    <p># per host monitoring es: E(int) def per_host_monitoring(): q = (Select(bytes) * Where(protocol(tcp) &amp; srcport(80))* GroupBy([dstmac]) * Every(60)) log = Print(HTTP Bytes:) q &gt;&gt; l</p>
    <p># Composition of two separate modules def main(): simple_repeater() per_host_monitoring()</p>
    <p>Controller</p>
    <p>Switch</p>
  </div>
  <div class="page">
    <p>No refactoring of rules</p>
    <p>Pure composition of modules</p>
    <p>Unified see every packet abstraction</p>
    <p>Run-time deals with the rest</p>
    <p>Frenetic Version</p>
    <p># Static repeating between ports 1 and 2 def simple_repeater(): rules=[Rule(inport_fp(1), [output(2)]), Rule(inport_fp(2), [output(1)])] register_static(rules)</p>
    <p># per host monitoring es: E(int) def per_host_monitoring(): q = (Select(bytes) * Where(protocol(tcp) &amp; srcport(80))* GroupBy([dstmac]) * Every(60)) log = Print(HTTP Bytes:) q &gt;&gt; l</p>
    <p># Composition of two separate modules def main(): simple_repeater() per_host_monitoring()</p>
    <p># Static repeating between ports 1 and 2 def simple_repeater(): rules=[Rule(inport_fp(1), [output(2)]), Rule(inport_fp(2), [output(1)])] register_static(rules)</p>
    <p># per host monitoring es: E(int) def per_host_monitoring(): q = (Select(bytes) * Where(protocol(tcp) &amp; srcport(80))* GroupBy([dstmac]) * Every(60)) log = Print(HTTP Bytes:) q &gt;&gt; l</p>
    <p># Composition of two separate modules def main(): simple_repeater() per_host_monitoring()</p>
  </div>
  <div class="page">
    <p>Frenetic Language</p>
    <p>Network as a stream of discrete, heterogenous events  Packets, node join, node leave, status change, time, etc</p>
    <p>Unified Abstraction  See every packet  Relieves programmer from reasoning about split architecture</p>
    <p>Compositional Semantics  Standard operators from Functional Reactive Programming (FRP) 13</p>
    <p>Event Stream</p>
    <p>Single Value or Event . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
  </div>
  <div class="page">
    <p>Frenetic Run-time System</p>
    <p>Frenetic programs interact only with the run-time  Programs create subscribers</p>
    <p>Programs register rules</p>
    <p>Run-time handles the details  Manages switch-level rules</p>
    <p>Handles NOX events  Pushes values onto the appropriate event streams</p>
    <p>NOX</p>
  </div>
  <div class="page">
    <p>NOX</p>
    <p>Run-time System Implementation</p>
    <p>Reactive, microflow based run-time system</p>
    <p>Check Subscribers</p>
    <p>Check Subscribers</p>
    <p>Check Rules</p>
    <p>Check Rules</p>
    <p>Monitoring Loop</p>
    <p>Monitoring Loop</p>
    <p>Stats Request</p>
    <p>Do ActionsDo Actions</p>
    <p>Install Flow</p>
    <p>Send Packet</p>
    <p>Update Stats</p>
    <p>Update Stats</p>
    <p>Stats In</p>
    <p>Packets Stats</p>
    <p>SubscribersSubscribers</p>
    <p>RulesRules</p>
    <p>Flow Removed</p>
    <p>Subscribe Register</p>
    <p>NOX</p>
    <p>Frenetic Program</p>
    <p>Frenetic Run-time System</p>
    <p>Packet InPacketPacket PacketPacket</p>
    <p>Rul e</p>
    <p>Rul e</p>
    <p>PacketPacket</p>
  </div>
  <div class="page">
    <p>Optimizing Frenetic</p>
    <p>See every packet abstraction can negatively affect performance in the worst case  Nave implementation strategy  Application directed</p>
    <p>Using an efficient combination of operators, we can keep packets in the dataplane  Must match switch capabilities Filtering, Grouping, Splitting, Aggregating, Limiting</p>
    <p>Expose this interface to the programmer explicitly</p>
  </div>
  <div class="page">
    <p>Does it Work in Practice?</p>
    <p>Frenetic programs perform comparably with pure NOX  But we still have room for improvement</p>
    <p>Learning Switch</p>
    <p>Web Stats Static</p>
    <p>Web Stats Learning</p>
    <p>Heavy Hitters</p>
    <p>Learning</p>
    <p>Pure NOX</p>
    <p>Lines of Code 55 29 121 125 Traffic to Controller (Bytes) 71224 1932 5300 18010</p>
    <p>Nave Frenetic</p>
    <p>Lines of Code 15 7 19 36 Traffic to Controller (Bytes) 120104 6590 14075 95440</p>
    <p>Optimized Frenetic</p>
    <p>Lines of Code 14 5 16 32 Traffic to Controller (Bytes) 70694 3912 5368 19360</p>
  </div>
  <div class="page">
    <p>Frenetic Scalability</p>
    <p>Frenetic scales to larger networks comparably with NOX</p>
    <p>Hosts</p>
    <p>Frenetic NOX</p>
  </div>
  <div class="page">
    <p>Memcached with dynamic membership  Forwards queries to a dynamic member set  Works with unmodified memcached clients/servers</p>
    <p>Defensive Network Switch  Identifies hosts conducting network scanning  Drops packets from suspected scanners</p>
    <p>MemcachedMemcached</p>
    <p>Larger Applications</p>
    <p>ServersClient get(key) set(k,v)</p>
    <p>a-i a-i</p>
    <p>jq jq</p>
    <p>r-zr-z</p>
    <p>am am</p>
    <p>n-zn-z</p>
  </div>
  <div class="page">
    <p>Ongoing and Future Work</p>
    <p>Surface Language  Current prototype is in Python  to ease transition</p>
    <p>Would like a standalone language</p>
    <p>Optimizations  More programs can also be implemented efficiently</p>
    <p>Would like a compiler to identify and rewrite optimizations</p>
    <p>Proactive Strategy  Current prototype is reactive, based on microflow rules</p>
    <p>Would like to enable proactive, wildcard rule installation</p>
    <p>Network Wide Abstractions  Current prototype focuses only on a single switch  Need to expand to multiple switches</p>
  </div>
  <div class="page">
    <p>Questions?</p>
    <p>See our recent submission for more details http://www.cs.cornell.edu/~jnfoster/papers/frenetic-draft.pdf</p>
  </div>
</Presentation>
