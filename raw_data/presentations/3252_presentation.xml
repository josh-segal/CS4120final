<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Type Casting Verification: Stopping an Emerging Attack Vector</p>
    <p>Byoungyoung Lee, Chengyu Song, Taesoo Kim, and Wenke Lee</p>
    <p>Georgia Institute of Technology</p>
  </div>
  <div class="page">
    <p>Vulnerability Trends</p>
    <p>Microsoft vulnerability trends (2013)</p>
    <p>Use-after-free Stack overflow</p>
    <p>Heap overflow Bad casting (or type confusion)</p>
  </div>
  <div class="page">
    <p>Microsoft vulnerability trends (2013)</p>
    <p>Stack Overflows</p>
    <p># of Stack overflows is decreasing</p>
  </div>
  <div class="page">
    <p>Microsoft vulnerability trends (2013)</p>
    <p># of Use-after-free is increasing  Preventing Use-after-free with</p>
    <p>Dangling Pointers Nullification [NDSS 15]</p>
    <p>Use-After-Free</p>
  </div>
  <div class="page">
    <p>Bad-casting</p>
    <p>Bad-casting (or type confusion) is still not solved.</p>
  </div>
  <div class="page">
    <p>Type Conversions in C++</p>
    <p>static_cast</p>
    <p>Compile-time conversions</p>
    <p>Fast: no extra verification in run-time</p>
    <p>No information on actually allocated types in runtime.</p>
    <p>dynamic_cast</p>
    <p>Run-time conversions</p>
    <p>Requires Runtime Type Information (RTTI)</p>
    <p>Slow: Extra verification by parsing RTTI</p>
    <p>Typically prohibited in performance critical applications</p>
  </div>
  <div class="page">
    <p>Upcasting and Downcasting  Upcasting</p>
    <p>From a derived class to its parent class</p>
    <p>Downcasting</p>
    <p>From a parent class to one of its derived classes</p>
  </div>
  <div class="page">
    <p>Upcasting and Downcasting  Upcasting</p>
    <p>From a derived class to its parent class</p>
    <p>Downcasting</p>
    <p>From a parent class to one of its derived classes</p>
    <p>Element</p>
    <p>HTMLElement SVGElement</p>
  </div>
  <div class="page">
    <p>Upcasting and Downcasting  Upcasting</p>
    <p>From a derived class to its parent class</p>
    <p>Downcasting</p>
    <p>From a parent class to one of its derived classes</p>
    <p>Upcasting</p>
    <p>Element</p>
    <p>HTMLElement SVGElement</p>
  </div>
  <div class="page">
    <p>Upcasting and Downcasting  Upcasting</p>
    <p>From a derived class to its parent class</p>
    <p>Downcasting</p>
    <p>From a parent class to one of its derived classes</p>
    <p>Downcasting Upcasting</p>
    <p>Element</p>
    <p>HTMLElement SVGElement</p>
  </div>
  <div class="page">
    <p>Upcasting and Downcasting  Upcasting</p>
    <p>From a derived class to its parent class</p>
    <p>Downcasting</p>
    <p>From a parent class to one of its derived classes</p>
    <p>Downcasting Upcasting</p>
    <p>Upcasting is always safe, but downcasting is not!</p>
    <p>Element</p>
    <p>HTMLElement SVGElement</p>
  </div>
  <div class="page">
    <p>Downcasting is not always safe!</p>
    <p>class P { virtual ~P() {} int m_P; };</p>
    <p>class D: public P { virtual ~D() {} int m_D; };</p>
  </div>
  <div class="page">
    <p>Downcasting is not always safe!</p>
    <p>vftptr for P</p>
    <p>int m_P</p>
    <p>class P { virtual ~P() {} int m_P; };</p>
    <p>class D: public P { virtual ~D() {} int m_D; };</p>
    <p>Access scope of P*</p>
  </div>
  <div class="page">
    <p>Downcasting is not always safe!</p>
    <p>vftptr for P</p>
    <p>int m_P</p>
    <p>vftptr for D</p>
    <p>int m_P</p>
    <p>int m_D</p>
    <p>class P { virtual ~P() {} int m_P; };</p>
    <p>class D: public P { virtual ~D() {} int m_D; };</p>
    <p>Access scope of P*</p>
    <p>Access scope of D*</p>
  </div>
  <div class="page">
    <p>Downcasting can be Bad-casting</p>
    <p>P *pS = new P(); D *pD = static_cast&lt;D*&gt;(pS); pD-&gt;m_D;</p>
  </div>
  <div class="page">
    <p>Downcasting can be Bad-casting</p>
    <p>P *pS = new P(); D *pD = static_cast&lt;D*&gt;(pS); pD-&gt;m_D;</p>
    <p>Bad-casting occurs: D is not a sub-object of P  Undefined behavior</p>
    <p>D *pD = static_cast&lt;D*&gt;(pS);</p>
  </div>
  <div class="page">
    <p>Downcasting can be Bad-casting</p>
    <p>P *pS = new P(); D *pD = static_cast&lt;D*&gt;(pS); pD-&gt;m_D; pD-&gt;m_D;</p>
    <p>Memory corruptions</p>
  </div>
  <div class="page">
    <p>Downcasting can be Bad-casting</p>
    <p>P *pS = new P(); D *pD = static_cast&lt;D*&gt;(pS); pD-&gt;m_D; pD-&gt;m_D;</p>
    <p>Memory corruptions</p>
    <p>vftptr for P</p>
    <p>int m_P</p>
  </div>
  <div class="page">
    <p>Downcasting can be Bad-casting</p>
    <p>P *pS = new P(); D *pD = static_cast&lt;D*&gt;(pS); pD-&gt;m_D; pD-&gt;m_D;</p>
    <p>Memory corruptions</p>
    <p>vftptr for P</p>
    <p>int m_P</p>
    <p>&amp;(pD-&gt;m_D)</p>
  </div>
  <div class="page">
    <p>Downcasting can be Bad-casting</p>
    <p>P *pS = new P(); D *pD = static_cast&lt;D*&gt;(pS); pD-&gt;m_D; pD-&gt;m_D;</p>
    <p>Memory corruptions</p>
    <p>vftptr for P</p>
    <p>int m_P</p>
    <p>int m_D</p>
    <p>&amp;(pD-&gt;m_D)</p>
  </div>
  <div class="page">
    <p>Downcasting can be Bad-casting</p>
    <p>P *pS = new P(); D *pD = static_cast&lt;D*&gt;(pS); pD-&gt;m_D; pD-&gt;m_D;</p>
    <p>Memory corruptions</p>
    <p>vftptr for P</p>
    <p>int m_P</p>
    <p>int m_D</p>
    <p>&amp;(pD-&gt;m_D)</p>
  </div>
  <div class="page">
    <p>Real-world Exploits on Bad-casting</p>
    <p>Element</p>
    <p>SVGElement HTMLElement</p>
    <p>CVE-2013-0912  A bad-casting vulnerability in Chrome</p>
    <p>Used in 2013 Pwn2Own</p>
    <p>HTMLUnknownElement</p>
    <p>ContainerNode</p>
  </div>
  <div class="page">
    <p>Real-world Exploits on Bad-casting</p>
    <p>Element</p>
    <p>SVGElement HTMLElement</p>
    <p>CVE-2013-0912  A bad-casting vulnerability in Chrome</p>
    <p>Used in 2013 Pwn2Own</p>
    <p>HTMLUnknownElement</p>
    <p>ContainerNode</p>
  </div>
  <div class="page">
    <p>Real-world Exploits on Bad-casting</p>
    <p>Element</p>
    <p>SVGElement HTMLElement</p>
    <p>CVE-2013-0912  A bad-casting vulnerability in Chrome</p>
    <p>Used in 2013 Pwn2Own</p>
    <p>HTMLUnknownElement</p>
    <p>ContainerNode</p>
  </div>
  <div class="page">
    <p>Real-world Exploits on Bad-casting</p>
    <p>Element</p>
    <p>SVGElement HTMLElement</p>
    <p>CVE-2013-0912  A bad-casting vulnerability in Chrome</p>
    <p>Used in 2013 Pwn2Own</p>
    <p>HTMLUnknownElement</p>
    <p>ContainerNode</p>
  </div>
  <div class="page">
    <p>Real-world Exploits on Bad-casting</p>
    <p>Element</p>
    <p>SVGElement HTMLElement</p>
    <p>CVE-2013-0912  A bad-casting vulnerability in Chrome</p>
    <p>Used in 2013 Pwn2Own</p>
    <p>HTMLUnknownElement</p>
    <p>ContainerNode</p>
  </div>
  <div class="page">
    <p>Element</p>
    <p>SVGElement HTMLElement</p>
    <p>ContainerNode</p>
    <p>Real-world Exploits on Bad-casting</p>
    <p>PseudoElement</p>
    <p>Node</p>
    <p>EventTarget TreeShared&lt;Node&gt;</p>
    <p>ScriptWrapperble NoBaseWillBeGarbageCollectedFinalized&lt;&gt;</p>
    <p>VTTElement VTTElement</p>
    <p>LabelableElement</p>
    <p>HtmlTableElement</p>
    <p>HTMLRubyElement</p>
    <p>HTMLFontElement</p>
    <p>HTMLMenuElement</p>
    <p>HTMLLabelElement</p>
    <p>HTMLUnknownElement</p>
  </div>
  <div class="page">
    <p>Element</p>
    <p>SVGElement HTMLElement</p>
    <p>ContainerNode</p>
    <p>Real-world Exploits on Bad-casting</p>
    <p>PseudoElement</p>
    <p>Node</p>
    <p>EventTarget TreeShared&lt;Node&gt;</p>
    <p>ScriptWrapperble NoBaseWillBeGarbageCollectedFinalized&lt;&gt;</p>
    <p>VTTElement VTTElement</p>
    <p>LabelableElement</p>
    <p>HtmlTableElement</p>
    <p>HTMLRubyElement</p>
    <p>HTMLFontElement</p>
    <p>HTMLMenuElement</p>
    <p>HTMLLabelElement</p>
    <p>HTMLUnknownElement</p>
    <p>Very complex class hierarchies  Error-prone type casting operations</p>
  </div>
  <div class="page">
    <p>Existing Solutions and Challenges</p>
    <p>Replace all static_cast into dynamic_cast</p>
    <p>dynamic_cast on a polymorphic class (with RTTI)</p>
    <p>A pointer points to a virtual function table pointer</p>
    <p>Traversing a virtual function table leads to RTTI</p>
    <p>vftptr</p>
    <p>ptr &amp;std::type_info</p>
    <p>Offset to the top</p>
    <p>A class name</p>
    <p>12</p>
  </div>
  <div class="page">
    <p>Existing Solutions and Challenges</p>
    <p>dynamic_cast on a non-polymorphic class</p>
    <p>A pointer points to the first member variable</p>
    <p>Simply traversing such a variable leads to a runtime crash</p>
    <p>...</p>
    <p>ptr</p>
  </div>
  <div class="page">
    <p>Existing Solutions and Challenges</p>
    <p>dynamic_cast on a non-polymorphic class</p>
    <p>A pointer points to the first member variable</p>
    <p>Simply traversing such a variable leads to a runtime crash</p>
    <p>...</p>
    <p>ptr</p>
    <p>C++ supports no reliable methods to resolve whether</p>
    <p>a pointer points to polymorphic or non-polymorphic classes.</p>
  </div>
  <div class="page">
    <p>Existing Solutions and Challenges</p>
    <p>dynamic_cast on a non-polymorphic class</p>
    <p>A pointer points to the first member variable</p>
    <p>Simply traversing such a variable leads to a runtime crash</p>
    <p>...</p>
    <p>ptr</p>
    <p>C++ supports no reliable methods to resolve whether</p>
    <p>a pointer points to polymorphic or non-polymorphic classes.</p>
    <p>Previous solutions including Undefined Behavior Sanitizer relies on blacklists.</p>
  </div>
  <div class="page">
    <p>CaVer: CastVerifier</p>
    <p>CaVer: CastVerifier</p>
    <p>A bad-casting detection tool</p>
    <p>Design goals</p>
    <p>Easy-to-deploy: no blacklists</p>
    <p>Reasonable runtime performance</p>
  </div>
  <div class="page">
    <p>CaVer Overview</p>
    <p>Emit THTable</p>
    <p>Instrumentation</p>
    <p>Source code</p>
    <p>Compile</p>
  </div>
  <div class="page">
    <p>CaVer Overview</p>
    <p>Emit THTable</p>
    <p>Instrumentation</p>
    <p>CaVer Runtime</p>
    <p>Source code</p>
    <p>Compile</p>
    <p>Link</p>
  </div>
  <div class="page">
    <p>CaVer Overview</p>
    <p>Emit THTable</p>
    <p>Instrumentation</p>
    <p>CaVer Runtime</p>
    <p>Source code</p>
    <p>Compile</p>
    <p>Link</p>
    <p>Secured executable</p>
  </div>
  <div class="page">
    <p>static_cast&lt;D*&gt;(ptr);</p>
    <p>Technical Goal of CaVer</p>
    <p>P *ptr = new P;</p>
  </div>
  <div class="page">
    <p>static_cast&lt;D*&gt;(ptr);</p>
    <p>Technical Goal of CaVer</p>
    <p>P *ptr = new P; Allocated</p>
  </div>
  <div class="page">
    <p>static_cast&lt;D*&gt;(ptr);</p>
    <p>Technical Goal of CaVer</p>
    <p>P *ptr = new P; Allocated</p>
    <p>To be casted</p>
  </div>
  <div class="page">
    <p>static_cast&lt;D*&gt;(ptr);</p>
    <p>Technical Goal of CaVer</p>
    <p>P *ptr = new P;</p>
    <p>Object (P)</p>
    <p>ptr</p>
    <p>Allocated</p>
    <p>To be casted</p>
  </div>
  <div class="page">
    <p>static_cast&lt;D*&gt;(ptr);</p>
    <p>Technical Goal of CaVer</p>
    <p>P *ptr = new P;</p>
    <p>Object (P)</p>
    <p>ptr</p>
    <p>Allocated</p>
    <p>To be casted</p>
    <p>Q. What are the class relationships b/w P and D?  THTable</p>
  </div>
  <div class="page">
    <p>static_cast&lt;D*&gt;(ptr);</p>
    <p>Technical Goal of CaVer</p>
    <p>P *ptr = new P;</p>
    <p>Object (P)</p>
    <p>ptr</p>
    <p>Allocated</p>
    <p>To be casted</p>
    <p>Q. Is ptr points to P or D?  Runtime type tracing</p>
    <p>Q. What are the class relationships b/w P and D?  THTable</p>
  </div>
  <div class="page">
    <p>Type Hierarchy Table (THTable)</p>
    <p>hash(P) hash(D)</p>
    <p>hash(P)</p>
    <p>THTable (P) THTable (D)</p>
    <p>A set of all legitimate classes to be converted</p>
    <p>Class names are hashed for fast comparison</p>
    <p>Hierarchies are unrolled to avoid recursive traversal</p>
  </div>
  <div class="page">
    <p>Type Hierarchy Table (THTable)</p>
    <p>hash(P) hash(D)</p>
    <p>hash(P)</p>
    <p>THTable (P) THTable (D)</p>
    <p>A set of all legitimate classes to be converted</p>
    <p>Class names are hashed for fast comparison</p>
    <p>Hierarchies are unrolled to avoid recursive traversal</p>
    <p>Hashed class names</p>
  </div>
  <div class="page">
    <p>Type Hierarchy Table (THTable)</p>
    <p>hash(P) hash(D)</p>
    <p>hash(P)</p>
    <p>THTable (P) THTable (D)</p>
    <p>A set of all legitimate classes to be converted</p>
    <p>Class names are hashed for fast comparison</p>
    <p>Hierarchies are unrolled to avoid recursive traversal</p>
    <p>Unrolled linearly</p>
  </div>
  <div class="page">
    <p>Runtime Type Tracing</p>
    <p>P *ptr = new P; P *ptr = new P; trace(ptr, &amp;THTable(P));</p>
  </div>
  <div class="page">
    <p>Runtime Type Tracing</p>
    <p>P *ptr = new P;</p>
    <p>Object (P)</p>
    <p>ptr</p>
    <p>P *ptr = new P; trace(ptr, &amp;THTable(P));</p>
    <p>hash(P)</p>
    <p>THTable (P)</p>
  </div>
  <div class="page">
    <p>Runtime Type Tracing</p>
    <p>P *ptr = new P;</p>
    <p>Object (P)</p>
    <p>ptr</p>
    <p>P *ptr = new P; trace(ptr, &amp;THTable(P));</p>
    <p>hash(P)</p>
    <p>THTable (P)</p>
    <p>&amp;THTable(P)</p>
  </div>
  <div class="page">
    <p>Runtime Type Tracing</p>
    <p>P *ptr = new P;</p>
    <p>Object (P)</p>
    <p>ptr</p>
    <p>P *ptr = new P; trace(ptr, &amp;THTable(P));</p>
    <p>hash(P)</p>
    <p>THTable (P)</p>
    <p>&amp;THTable(P)</p>
    <p>Maintain an internal mapping from objects to metadata Heap: Alignment based direct mapping Stack: Per-thread red-black tree Global : Per-process red-black tree</p>
  </div>
  <div class="page">
    <p>Runtime Type Tracing</p>
    <p>P *ptr = new P;</p>
    <p>Object (P)</p>
    <p>ptr</p>
    <p>P *ptr = new P; trace(ptr, &amp;THTable(P));</p>
    <p>hash(P)</p>
    <p>THTable (P)</p>
    <p>&amp;THTable(P)</p>
    <p>Decoupled metadata  Overcome RTTIs limitation</p>
  </div>
  <div class="page">
    <p>Runtime Type Verification</p>
    <p>static_cast&lt;D*&gt;(ptr);</p>
    <p>To be casted</p>
  </div>
  <div class="page">
    <p>Runtime Type Verification</p>
    <p>Object (P)</p>
    <p>ptr</p>
    <p>hash(P)</p>
    <p>THTable (P)</p>
    <p>&amp;THTable(P)</p>
    <p>static_cast&lt;D*&gt;(ptr);</p>
    <p>To be casted</p>
  </div>
  <div class="page">
    <p>Runtime Type Verification</p>
    <p>Object (P)</p>
    <p>ptr</p>
    <p>hash(P)</p>
    <p>THTable (P)</p>
    <p>&amp;THTable(P)</p>
    <p>static_cast&lt;D*&gt;(ptr);</p>
    <p>To be casted</p>
  </div>
  <div class="page">
    <p>Runtime Type Verification</p>
    <p>Object (P)</p>
    <p>ptr</p>
    <p>hash(P)</p>
    <p>THTable (P)</p>
    <p>&amp;THTable(P)</p>
    <p>static_cast&lt;D*&gt;(ptr);</p>
    <p>To be casted</p>
  </div>
  <div class="page">
    <p>Runtime Type Verification</p>
    <p>Object (P)</p>
    <p>ptr</p>
    <p>hash(P)</p>
    <p>THTable (P)</p>
    <p>&amp;THTable(P)</p>
    <p>static_cast&lt;D*&gt;(ptr);</p>
    <p>To be casted</p>
  </div>
  <div class="page">
    <p>Runtime Type Verification</p>
    <p>Object (P)</p>
    <p>ptr</p>
    <p>hash(P)</p>
    <p>THTable (P)</p>
    <p>&amp;THTable(P)</p>
    <p>static_cast&lt;D*&gt;(ptr);</p>
    <p>To be casted</p>
    <p>THTable(P) does not have D  Bad-casting!</p>
  </div>
  <div class="page">
    <p>Performance Optimization</p>
    <p>Selective object tracing</p>
    <p>Not all objects are involved in downcasting</p>
    <p>Statically identify such objects, and skip tracing them</p>
    <p>Reusing verification results</p>
    <p>A verification process has to be the same for same class</p>
    <p>A verification result is cached for reuses</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Based on LLVM Compiler suites</p>
    <p>Added 3,540 lines of C++ code</p>
    <p>Currently support Linux x86-64</p>
    <p>CaVer can be activated with one extra compiler flag</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>How much efforts are required to deploy CaVer?</p>
    <p>How effective is CaVer in detecting bad-casting?</p>
    <p>What is the overall runtime overhead of CaVer?</p>
  </div>
  <div class="page">
    <p>Deployment Efforts</p>
    <p>Build configuration changes</p>
    <p>21 and 10 lines were changed in Chromium and Firefox</p>
    <p>No blacklists are required</p>
    <p>CaVer successfully</p>
    <p>Build both browsers</p>
    <p>Run both browsers without runtime crashes</p>
  </div>
  <div class="page">
    <p>CaVer Report Example</p>
    <p>== CaVer : Bad-casting detected @SVGViewSpec.cpp:87:12 Casting an object of blink::HTMLUnknownElement from blink::Element to blink::SVGElement Pointer 0x60c000008280 Alloc base 0x60c000008280 Offset 0x000000000000 THTable 0x7f7963aa20d0 #1 0x7f795d76f1a4 in viewTarget SVGViewSpec.cpp:87 #2 0x7f795d939d1c in viewTargetAttribute V8SVGViewSpec.cpp:56 ...</p>
  </div>
  <div class="page">
    <p>CaVer Report Example</p>
    <p>== CaVer : Bad-casting detected @SVGViewSpec.cpp:87:12 Casting an object of blink::HTMLUnknownElement from blink::Element to blink::SVGElement Pointer 0x60c000008280 Alloc base 0x60c000008280 Offset 0x000000000000 THTable 0x7f7963aa20d0 #1 0x7f795d76f1a4 in viewTarget SVGViewSpec.cpp:87 #2 0x7f795d939d1c in viewTargetAttribute V8SVGViewSpec.cpp:56 ...</p>
    <p>Detailed casting information</p>
  </div>
  <div class="page">
    <p>CaVer Report Example</p>
    <p>== CaVer : Bad-casting detected @SVGViewSpec.cpp:87:12 Casting an object of blink::HTMLUnknownElement from blink::Element to blink::SVGElement Pointer 0x60c000008280 Alloc base 0x60c000008280 Offset 0x000000000000 THTable 0x7f7963aa20d0 #1 0x7f795d76f1a4 in viewTarget SVGViewSpec.cpp:87 #2 0x7f795d939d1c in viewTargetAttribute V8SVGViewSpec.cpp:56 ...</p>
    <p>Detailed casting information</p>
    <p>Runtime call stacks</p>
  </div>
  <div class="page">
    <p>New vulnerabilities</p>
    <p>CaVer discovered 11 new vulnerabilities</p>
    <p>2 cases in Firefox (won bug bounty awards)</p>
    <p>9 cases in GNU libstdc++</p>
    <p>All reported to and fixed by vendors</p>
  </div>
  <div class="page">
    <p>Runtime Overhead</p>
    <p>Octane SunSpider Dromaeo-JS Dromaeo-DOM</p>
    <p>Chromium</p>
    <p>Firefox</p>
    <p>On average, Chromium: 7.6%</p>
    <p>Firefox: 64.6%</p>
  </div>
  <div class="page">
    <p>Applications of CaVer</p>
    <p>A back-end bug detection tool</p>
    <p>A runtime attack mitigation tool</p>
    <p>Limitations of previous mitigations techniques</p>
    <p>Focusing on certain attack methods</p>
    <p>e.g., CFI or ROP techniques</p>
    <p>Not effective if an exploit relies on other attack methods</p>
    <p>e.g., non-control data attack</p>
    <p>CaVer tackles the root cause of bad-casintg.</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>Proposed CaVer, a new runtime bad-casting detection mechanism</p>
    <p>Discovered 11 new bad-casting vulnerabilities in Firefox and libstdc++</p>
  </div>
  <div class="page">
    <p>Thank you!</p>
  </div>
</Presentation>
