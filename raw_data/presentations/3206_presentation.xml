<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Precise client-side protection against DOM-based Cross-Site Scripting</p>
    <p>USENIX Security 2014, San Diego Ben Stock (University of Erlangen-Nuremberg) Sebastian Lekies, Tobias Mller, Patrick Spiegel, Martin Johns (SAP AG)</p>
  </div>
  <div class="page">
    <p>DOM-based Cross-Site Scripting</p>
    <p>All kinds of XSS vulnerabilities that are purely inside client-side code  both &quot;reflected&quot; (e.g. extracting part of the URL)  ... and stored (e.g. localStorage)</p>
    <p>Source: http://blogs.sfweekly.com/thesnitch/ cookie_monster.jpg</p>
  </div>
  <div class="page">
    <p>SotA in XSS filtering: XSSAuditor</p>
    <p>Deployed in all WebKit/Blink-based browsers  Located inside the HTML parser</p>
    <p>whenever dangerous element/attribute is found, search for &quot;payload&quot; in request</p>
  </div>
  <div class="page">
    <p>DOM-based XSS in the wild and effectiveness of countermeasures</p>
  </div>
  <div class="page">
    <p>Finding DOMXSS at scale (CCS 2013)</p>
    <p>using byte-level taint tracking in Chromium  precise source information for every character  patched sinks (e.g. document.write or eval)</p>
    <p>Chrome extension to crawl given set of Web sites  and act as interface between taint engine and backend</p>
    <p>and an exploit generator  using precise taint information  and HTML and JavaScript syntax rules  to generate exploits fully automatic</p>
  </div>
  <div class="page">
    <p>DOMXSS in the wild</p>
    <p>CCS 2013  Alexa Top5k, one level down from homepage   480 domains vulnerable</p>
    <p>This talk (moar crawling power)  Alexa Top10k, two levels down from homepage   958 domains with 1,602 unique vulnerabilities  with disabled XSSAuditor</p>
  </div>
  <div class="page">
    <p>Bypassing the XSSAuditor</p>
  </div>
  <div class="page">
    <p>Bypassable exploits</p>
    <p>776 out of 958 domains bypassable  1,169 out of 1,602 vulnerabilities bypassable</p>
    <p>! State of the Art XSS filter cannot protect against DOM-based XSS*</p>
    <p>* was not necessarily designed that way, though</p>
  </div>
  <div class="page">
    <p>Our proposed solution</p>
  </div>
  <div class="page">
    <p>The hard life of a reflected XSS filter</p>
    <p>XSS abstracted: user-provided data ends up being interpreted as code  same for SQLi, CMDi, ..</p>
    <p>XSS filter's problem: find this code among all the other code  string matching to approximate data flow</p>
  </div>
  <div class="page">
    <p>Our proposal</p>
    <p>Approximation unnecessary imprecise for local flows  we can use taint tracking</p>
    <p>XSS boils down to being JavaScript execution  build filter into JavaScript engine</p>
    <p>XSS means that data ends up being interpreted as code  allow user-provided data only to generate Literals</p>
    <p>(Numeric, String, Boolean)  never anything else</p>
  </div>
  <div class="page">
    <p>Our proposal exemplified</p>
    <p>var userinput = location.hash.slice(1)!</p>
    <p>eval(&quot;var a='&quot; + userinput + &quot;';&quot;)! !</p>
    <p>!</p>
    <p>!</p>
  </div>
  <div class="page">
    <p>Userinput: userdata!</p>
    <p>Declaration!</p>
    <p>Identifier: a!</p>
    <p>StringLiteral: 'userdata'!</p>
    <p>var a='userdata';!</p>
  </div>
  <div class="page">
    <p>Userinput: userdata'; alert(1); //!</p>
    <p>Declaration!</p>
    <p>Identifier: a!</p>
    <p>StringLiteral: 'userdata'!</p>
    <p>ExpressionStmt!</p>
    <p>Type: CallExpression!</p>
    <p>Callee:!</p>
    <p>Identifier: alert!</p>
    <p>Arguments:!</p>
    <p>Literal: 1.0!</p>
    <p>var a='userdata';! alert(1); //'!</p>
  </div>
  <div class="page">
    <p>Policies</p>
    <p>No tainted value may generate anything other than a Literal in the JavaScript tokenizer</p>
    <p>No element that can reference an external resource may have tainted origin(e.g. script.src or embed.src)  enforced in the HTML parser and DOM bindings  single exception to rule: SAME origin as current page</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
  </div>
  <div class="page">
    <p>False negatives</p>
    <p>Took known vulnerabilities  ... with matching exploit URLs</p>
    <p>Disabled the XSSAuditor  ... to avoid interference</p>
    <p>Caught every exploit</p>
  </div>
  <div class="page">
    <p>False positives</p>
    <p>Compatibility crawl of Alexa Top10k with policies in place  981,453 URLs, 9,304,036 frames</p>
    <p>Blocking component</p>
    <p>documents</p>
    <p>JavaScript 5,979</p>
    <p>HTML 8,805</p>
    <p>DOM API 182</p>
    <p>Sum 14,966 (0.016%)</p>
  </div>
  <div class="page">
    <p>False positives</p>
    <p>Compatibility crawl of Alexa Top10k with policies in place  981,453 URLs, 9,304,036 frames</p>
    <p>Blocking component</p>
    <p>documents</p>
    <p>domains</p>
    <p>JavaScript 5,979 50</p>
    <p>HTML 8,805 73</p>
    <p>DOM API 182 60</p>
    <p>Sum 14,966 (0.016%) 183 (1.83%)</p>
  </div>
  <div class="page">
    <p>False positives</p>
    <p>Compatibility crawl of Alexa Top10k with policies in place  981,453 URLs, 9,304,036 frames</p>
    <p>Blocking component</p>
    <p>documents</p>
    <p>domains</p>
    <p>exploitable domains</p>
    <p>JavaScript 5,979 50 22</p>
    <p>HTML 8,805 73 60</p>
    <p>DOM API 182 60 8</p>
    <p>Sum 14,966 (0.016%) 183 (1.83%) 90</p>
  </div>
  <div class="page">
    <p>Performance</p>
    <p>Evaluation using standard benchmarks  Dromaeo, Octane, Kraken, Sunspider</p>
    <p>Two modes (benchmarks usually don't use tainted values)  normal operation  all strings tainted</p>
    <p>Overhead between 7 and 17%  optimization possible</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>SotA filters can be bypassed for DOM-based XSS  We propose filter inside JavaScript parser</p>
    <p>using precise taint information, allowing only tainted Literals</p>
    <p>No false negatives  Low false positives</p>
    <p>&quot;XSS by design&quot;  untaint API built in</p>
    <p>performance impact exists  optimizations possible  deployable next to the Auditor if optimized</p>
  </div>
  <div class="page">
    <p>Thank you</p>
    <p>@kcotsneb</p>
    <p>ben@kittenpics.org</p>
    <p>https://kittenpics.org</p>
    <p>Questions?</p>
  </div>
</Presentation>
