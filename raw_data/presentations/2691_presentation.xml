<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Speeding up Web Page Loads with Shandian</p>
    <p>Sophia Wang University of Washington</p>
  </div>
  <div class="page">
    <p>Why is page load time (PLT) slow?</p>
  </div>
  <div class="page">
    <p>&lt;html&gt; &lt;body onload=done();&gt; &lt;link src=1.css&gt; &lt;script src=d3.js&gt;&lt;/script&gt; &lt;script src=2.js&gt;&lt;/script&gt; &lt;div id=content&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;</p>
  </div>
  <div class="page">
    <p>Elapsed Time</p>
  </div>
  <div class="page">
    <p>html</p>
    <p>Elapsed Time</p>
  </div>
  <div class="page">
    <p>html</p>
    <p>Elapsed Time</p>
    <p>css</p>
  </div>
  <div class="page">
    <p>html</p>
    <p>Elapsed Time</p>
    <p>css</p>
    <p>js</p>
    <p>Components that access to the same resource cant execute at the same time</p>
  </div>
  <div class="page">
    <p>html</p>
    <p>Elapsed Time</p>
    <p>css</p>
    <p>js</p>
    <p>js</p>
  </div>
  <div class="page">
    <p>html</p>
    <p>Elapsed Time</p>
    <p>Page load</p>
    <p>css</p>
    <p>js</p>
    <p>js</p>
    <p>A simple page incurs complex load process, mainly due to interactions between</p>
    <p>HTML/JS/CSS.</p>
  </div>
  <div class="page">
    <p>How much can SPDY help PLT?</p>
  </div>
  <div class="page">
    <p>html</p>
    <p>Elapsed Time</p>
    <p>Page load</p>
    <p>css</p>
    <p>js</p>
    <p>js</p>
  </div>
  <div class="page">
    <p>html</p>
    <p>Elapsed Time</p>
    <p>Page load</p>
    <p>css</p>
    <p>js</p>
    <p>js</p>
  </div>
  <div class="page">
    <p>html</p>
    <p>Elapsed Time</p>
    <p>Page load</p>
    <p>css</p>
    <p>js</p>
    <p>js</p>
    <p>A technique that helps one factor of PLT is hard to help the overall PLT.</p>
  </div>
  <div class="page">
    <p>What does the simplest dependency graph look like?</p>
  </div>
  <div class="page">
    <p>???</p>
    <p>Elapsed Time</p>
    <p>Page load</p>
    <p>css</p>
    <p>js</p>
    <p>js</p>
  </div>
  <div class="page">
    <p>???</p>
    <p>Elapsed Time</p>
    <p>Page load</p>
    <p>css</p>
    <p>js</p>
    <p>js</p>
    <p>Time to interact</p>
    <p>Can we make every Web page look like this?</p>
  </div>
  <div class="page">
    <p>Yes, we want to make every page like this, automatically.</p>
  </div>
  <div class="page">
    <p>Approach: Split Browser</p>
    <p>Preprocess Web pages on a proxy server to simplify the client-side page load process</p>
  </div>
  <div class="page">
    <p>Approach: Split Browser</p>
    <p>Preprocess Web pages on a proxy server according to whether they are used initially</p>
    <p>???</p>
    <p>Elapsed Time</p>
    <p>Page load</p>
    <p>css</p>
    <p>js</p>
    <p>js</p>
    <p>Time to interact</p>
    <p>Load-time state</p>
    <p>Used in an initial page load</p>
    <p>Display as fast as possible</p>
  </div>
  <div class="page">
    <p>Approach: Split Browser</p>
    <p>Preprocess Web pages on a proxy server according to whether they are used initially</p>
    <p>???</p>
    <p>Elapsed Time</p>
    <p>Page load</p>
    <p>css</p>
    <p>js</p>
    <p>js</p>
    <p>Time to interact</p>
    <p>Post-load state</p>
    <p>Not used in an initial page load</p>
    <p>Ensure correctness of future interactions, and compatibility with existing technologies</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Load-time state  Post-load state  Deployment and implementation  Evaluation</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Load-time state  Post-load state  Deployment and implementation  Evaluation</p>
  </div>
  <div class="page">
    <p>Load-time State</p>
    <p>Goal  Display as fast as possible</p>
    <p>Approach  Eliminate both contents and computation of JS</p>
    <p>and CSS on the client as many as possible</p>
  </div>
  <div class="page">
    <p>Loading load-time state</p>
    <p>{loadTimeState:{ css:[#main{font-size:12px;}&quot;], html:{children: [{ tagName:body, ... children: [..., { tagName:div,id:main, css:[0]</p>
    <p>}]}]}}</p>
  </div>
  <div class="page">
    <p>Loading load-time state</p>
    <p>{loadTimeState:{ css:[#main{font-size:12px;}&quot;], html:{children: [{ tagName:body, ... children: [..., { tagName:div,id:main, css:[0]</p>
    <p>}]}]}}</p>
    <p>A list of matched CSS rules</p>
  </div>
  <div class="page">
    <p>Loading load-time state</p>
    <p>{loadTimeState:{ css:[#main{font-size:12px;}&quot;], html:{children: [{ tagName:body, ... children: [..., { tagName:div,id:main, css:[0]</p>
    <p>}]}]}}</p>
    <p>Visible HTML elements</p>
  </div>
  <div class="page">
    <p>Loading load-time state</p>
    <p>{loadTimeState:{ css:[#main{font-size:12px;}&quot;], html:{children: [{ tagName:body, ... children: [..., { tagName:div,id:main, css:[0]</p>
    <p>}]}]}}</p>
    <p>Which HTML element matches which CSS rules</p>
  </div>
  <div class="page">
    <p>Loading load-time state</p>
    <p>???</p>
    <p>Elapsed Time</p>
    <p>Page load</p>
    <p>css</p>
    <p>js</p>
    <p>js</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Load-time state  Post-load state  Deployment and implementation  Evaluation</p>
  </div>
  <div class="page">
    <p>Post-load state</p>
    <p>Goals  Correctness of future interactions</p>
    <p>Requirement: Post-load and load-time state contain full state of a Web page</p>
    <p>Compatibility  Requirement: Post-load state contains unmodified</p>
    <p>JS/CSS snippets</p>
  </div>
  <div class="page">
    <p>Vanilla post-load state</p>
    <p>The entire Web page itself  Pros</p>
    <p>Easy to ensure correctness of interactions and compatibility with caching/CDN</p>
    <p>Cons  Redundant contents and computation from load</p>
    <p>time state</p>
    <p>From here, how much can we improve?</p>
  </div>
  <div class="page">
    <p>Whats equivalent to evaling this CSS?</p>
    <p>#main { font-size:12px;</p>
    <p>} #main { font-size:12px;</p>
    <p>} #main { font-size:12px;</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Whats equivalent to evaling this CSS?</p>
    <p>#main { font-size:12px;</p>
    <p>} #main { font-size:12px;</p>
    <p>} #main { font-size:12px;</p>
    <p>}</p>
    <p>#main { font-size:12px;</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Whats equivalent to evaling this JS?</p>
    <p>a += hello world!\n</p>
    <p>a += hello world!\n</p>
    <p>a += hello world!\n</p>
  </div>
  <div class="page">
    <p>Whats equivalent to evaling this JS?</p>
    <p>a += hello world!\n</p>
    <p>a += hello world!\n</p>
    <p>a += hello world!\n</p>
    <p>a += hello world!\n + hello world!\n + hello world!\n</p>
  </div>
  <div class="page">
    <p>Whats equivalent to evaling this JS?</p>
    <p>function add(a, b) { return a + b;</p>
    <p>} function add(a, b) { return a + b;</p>
    <p>} function add(a, b) { return a + b;</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Whats equivalent to evaling this JS?</p>
    <p>function add(a, b) { return a + b;</p>
    <p>} function add(a, b) { return a + b;</p>
    <p>} function add(a, b) { return a + b;</p>
    <p>}</p>
    <p>function add(a, b) { return a + b;</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Post-load state</p>
    <p>Exploit the idempotency of evaluating CSS rules and JavaScript functions/statements  Eliminate redundant content that appeared in</p>
    <p>load-time state  Capture results of non-idempotent JS statements</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Load-time state  Post-load state  Deployment and implementation  Evaluation</p>
  </div>
  <div class="page">
    <p>Deployment</p>
    <p>How to fast load on the proxy server?  Use a beefy server  Co-locate with Web front ends</p>
    <p>As part of the website: reverse proxy  As a 3rd-party service: cloud servers</p>
    <p>Client Web server Proxy</p>
    <p>server html</p>
    <p>css</p>
    <p>js CDNs Edge cache</p>
    <p>image</p>
    <p>video</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Server extension  Chromes content_shell  Only handle HTML/JS/CSS</p>
    <p>Client browser  Chrome  JSON lexer, Blink, V8</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Load-time state  Post-load state  Deployment and implementation  Evaluation</p>
  </div>
  <div class="page">
    <p>Experimental setup</p>
    <p>Server: 2.4GHz 16 core CPU, 16GB memory  Clients</p>
    <p>Mobile: Nexus S, 1GHz Cortex-A8 CPU, 512MB RAM</p>
    <p>Desktop: Linux VM, 2GHz CPU, 1GB memory  Top 100 Web pages</p>
  </div>
  <div class="page">
    <p>PLT on mobile</p>
    <p>A bs</p>
    <p>ol ut</p>
    <p>e P</p>
    <p>LT s</p>
    <p>(s ec</p>
    <p>on ds</p>
    <p>) Chrome SplitBrowser</p>
    <p>Shandian helps 60% in the median case</p>
  </div>
  <div class="page">
    <p>PLT w/ varying RTT</p>
    <p>C D</p>
    <p>F</p>
    <p>PLT</p>
    <p>Unlike Chrome, Shandian is not sensitive to RTT, due to simplified page load process</p>
    <p>Increased gap for Chrome</p>
    <p>Small gap for Shandian</p>
  </div>
  <div class="page">
    <p>PLT w/ varying CPU</p>
    <p>C D</p>
    <p>F</p>
    <p>PLT</p>
    <p>CPU has the same amount of impact for both Chrome and Shandian</p>
  </div>
  <div class="page">
    <p>More results</p>
    <p>PLT breakdowns  Time spent on proxy server is negligible  Most time is spent on client</p>
    <p>Page size  Shandian increases page size by 1% after</p>
    <p>applying gzip compression</p>
  </div>
  <div class="page">
    <p>Difference from related work</p>
    <p>Amazon Silk, Opera mini  Our client can run JavaScript  We place proxy servers near Web servers</p>
    <p>Prioritizing resources (server push, Klotski)  We remove page load dependencies on the client</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Split the page state according to whether they are used for an initial page load</p>
    <p>The dependency graph until the page is loaded is fairly simple</p>
    <p>Improve PLT by more than half consistently for various settings</p>
    <p>Is compatible with caching/CDNs</p>
  </div>
</Presentation>
