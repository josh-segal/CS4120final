<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Performance Implications of Communication Mechanisms in All-Software Global Address Space Systems</p>
    <p>Chi-Chao Chang Dept. of Computer Science</p>
    <p>Cornell University</p>
    <p>Joint work with Beng-Hong Lim (IBM), Grzegorz Czajkowski and Thorsten von Eicken</p>
  </div>
  <div class="page">
    <p>Framework</p>
    <p>Parallel computing on clusters of workstations  Hardware communication primitives are message-based  Global addressing of data structures</p>
    <p>Problem  Tolerating high network latencies and overheads when</p>
    <p>accessing remote data</p>
    <p>Mechanisms for tolerating latencies and overheads  Caching: coherent data replication  Bulk transfers: amortizes fixed cost of a single message  Split-phase: overlaps computation with communication  Push-based: sender-controlled communication</p>
  </div>
  <div class="page">
    <p>Objective</p>
    <p>Global Addressing Languages  DSM: cache-coherent access to shared data</p>
    <p>C Region Library (CRL) [Johnson et. al. 95]  Caching</p>
    <p>Global pointers and arrays: explicit access to remote data  Split-C [Culler et. al. 93]</p>
    <p>Bulk transfers  Split-phase communication  Push-based communication</p>
    <p>Which of the two languages is easier to program?</p>
    <p>Which of the two yields better performance?  Which mechanisms are more effective?</p>
  </div>
  <div class="page">
    <p>Approach</p>
    <p>Develop comparable implementations of CRL and Split-C  Same compiler: GCC  Common communication layer: Active Messages</p>
    <p>Analyze the performance implications of caching, bulk, splitphase and push-based communication mechanisms</p>
    <p>with five applications  on the IBM SP, Meiko CS-2, and two simulated architectures</p>
  </div>
  <div class="page">
    <p>CRL versus Split-C</p>
    <p>// CRL</p>
    <p>rid_t r; double *x, w = 0;</p>
    <p>if (MYPROC == 0) {</p>
    <p>r = rgn_create(100*8);</p>
    <p>x = rgn_map(r);</p>
    <p>for(i=0;i&lt;100;i++) x[i] = i;</p>
    <p>rgn_bcast_send(&amp;r);</p>
    <p>} else {</p>
    <p>rgn_bcast_recv(&amp;r);</p>
    <p>y = rgn_map(r);</p>
    <p>rgn_start_read(y);</p>
    <p>for(i=0;i&lt;100;i++) w += y[i];</p>
    <p>rgn_end_read(y);</p>
    <p>}</p>
    <p>// Split-C</p>
    <p>double x[100];</p>
    <p>if (MYPROC == 0) {</p>
    <p>for(i=0;i&lt;100;i++) x[i] = i;</p>
    <p>barrier();</p>
    <p>} else {</p>
    <p>double *global y;</p>
    <p>double w = 0, z[100];</p>
    <p>barrier();</p>
    <p>y = toglobal(0,x);</p>
    <p>for(i=0;i&lt;100;i++) w += y[i];</p>
    <p>bulk_read(z, y, 100*8);</p>
    <p>}</p>
    <p>CRL: Caching (regions), implicit bulk xfers, size fixed at creation</p>
    <p>Split-C: No caching, global pointers, explicit bulk xfers, variable size</p>
  </div>
  <div class="page">
    <p>CRL versus Split-C</p>
    <p>// Split-C</p>
    <p>int i;</p>
    <p>int *global gp;</p>
    <p>i := *gp; // split-phase get</p>
    <p>*gp := 5 // split-phase store</p>
    <p>sync(); // wait until til completion</p>
    <p>CRL: No explicit communication</p>
    <p>Split-C: Split-phase/push-based communication with special assignments and explicit synchronization</p>
  </div>
  <div class="page">
    <p>Hardware Platforms</p>
    <p>Machine CPU AM</p>
    <p>Round-trip AM</p>
    <p>Bandwidth</p>
    <p>Meiko CS-2</p>
    <p>IBM SP2</p>
    <p>RMC1 66 MHz</p>
    <p>RS6000/590 17 s 500 MB/s</p>
    <p>RMC2 66 MHz</p>
    <p>RS6000/590 217 s 500 MB/s</p>
  </div>
  <div class="page">
    <p>Applications</p>
    <p>Versions Apps Origin Description Inputs</p>
    <p>CRL SC MM Split-C C = A * B</p>
    <p>A and B block-cyclic 512x512 16x16, 128x128 blocks</p>
    <p>FFT Split-C FFT butterfly algorithm</p>
    <p>LU SPLASH/ CRL</p>
    <p>Blocked LU Factorization</p>
    <p>Water SPLASH/ CRL</p>
    <p>N-Body System of Water Molecules</p>
    <p>Barnes SPLASH/ CRL</p>
    <p>Barnes-Hut NBody algorithm</p>
  </div>
  <div class="page">
    <p>Overall Observations</p>
    <p>Some applications benefit from caching:  MM, Barnes</p>
    <p>Others benefit from explicit communication:  FFT, LU, Water</p>
    <p>CRL and Split-C applications have similar performance  if right mechanisms are used,  if programmer spends comparable effort, and  if underlying CRL and SC implementations are comparable</p>
  </div>
  <div class="page">
    <p>Sample: Matrix Multiply</p>
    <p>C R</p>
    <p>L 1</p>
    <p>S C</p>
    <p>C R</p>
    <p>L 1</p>
    <p>S C</p>
    <p>C R</p>
    <p>L 1</p>
    <p>S C</p>
    <p>C R</p>
    <p>L 1</p>
    <p>S C</p>
    <p>NET COHERENCE SYNC CPU</p>
    <p>SP2 RMC2</p>
    <p>MM 16x16, 128x128 blk , 8 procs</p>
  </div>
  <div class="page">
    <p>Caching in CRL</p>
    <p>Benefits applications with sufficient temporal and spatial locality</p>
    <p>Key parameter: Region Size  Small regions increase coherence protocol overhead  Large regions increase communication overhead</p>
    <p>Tuning region sizes can be difficult in many cases  Trade-off depends on communication latency  Regions tend to correspond to static data structures (e.g. matrix</p>
    <p>blocks, molecule structures)  Re-designing data structures can be time consuming</p>
  </div>
  <div class="page">
    <p>Caching: Region Size</p>
    <p>Small regions can hurt caching, especially if latency is high</p>
    <p>LU 4x4: CRL much slower than SC</p>
    <p>Large regions usually improve caching</p>
    <p>LU 16x16: CRL closes performance gap</p>
    <p>C R</p>
    <p>L 4</p>
    <p>S C</p>
    <p>C R</p>
    <p>L 1</p>
    <p>S C</p>
    <p>C R</p>
    <p>L 4</p>
    <p>S C</p>
    <p>C R</p>
    <p>L 1</p>
    <p>S C</p>
    <p>NET COHERENCE SYNC CPU</p>
    <p>SP2 RMC2</p>
    <p>LU 4x4, 16x16 blk, 8 procs</p>
  </div>
  <div class="page">
    <p>Caching: Latency</p>
    <p>Advantages of caching diminish as communication latency decreases</p>
    <p>Barnes: Split-C closes performance gap on Meiko and is faster on RMC1</p>
    <p>C R</p>
    <p>L 5</p>
    <p>S C</p>
    <p>C R</p>
    <p>L 5</p>
    <p>S C</p>
    <p>C R</p>
    <p>L 5</p>
    <p>S C</p>
    <p>C R</p>
    <p>L 5</p>
    <p>S C</p>
    <p>NET COHERENCE SYNC CPU</p>
    <p>SP2 RMC1 RMC2Meiko</p>
    <p>Barnes 512 bds, 8 procs</p>
  </div>
  <div class="page">
    <p>Caching vs. Bulk Transfer</p>
    <p>Large regions are harmful to caching when region size doesnt match the actual amount of data used (a.k.a. false sharing)</p>
    <p>Water 512: CRL is much slower than SC</p>
    <p>The ability to specify the transfer size is a plus for bulk transfers</p>
    <p>Water 512: Selective prefetching reduces SC time substantially</p>
    <p>Water 512 mols, 8 procs</p>
    <p>C R</p>
    <p>L</p>
    <p>S C</p>
    <p>S L</p>
    <p>P F</p>
    <p>-S C</p>
    <p>C R</p>
    <p>L</p>
    <p>S C</p>
    <p>S L</p>
    <p>P F</p>
    <p>-S C</p>
    <p>C R</p>
    <p>L</p>
    <p>S C</p>
    <p>S L</p>
    <p>P F</p>
    <p>-S C</p>
    <p>NET COHERENCE SYNC CPU</p>
    <p>SP2 RMC1</p>
    <p>RMC2</p>
  </div>
  <div class="page">
    <p>Caching vs. Bulk Transfer</p>
    <p>Caching harmful if lack of temporal locality</p>
    <p>FFT: SC faster than CRL on all platforms</p>
    <p>C R</p>
    <p>L 2</p>
    <p>S C</p>
    <p>C R</p>
    <p>L 2</p>
    <p>S C</p>
    <p>C R</p>
    <p>L 2</p>
    <p>S C</p>
    <p>C R</p>
    <p>L 2</p>
    <p>S C</p>
    <p>NET COHERENCE SYNC CPU</p>
    <p>SP2 RMC1 RMC2Meiko</p>
    <p>FFT 2M pts, 8 procs</p>
  </div>
  <div class="page">
    <p>Split-Phase and Push-Based</p>
    <p>Two observations:  Bandwidth is not a limitation  Split-phase/Push-based</p>
    <p>allow pipelined communication phases</p>
    <p>Split-phase/Push-based outperforms caching</p>
    <p>LU 16x16: Base-SC is substantially faster than CRL</p>
    <p>LU 16x16 blk, 8 procs</p>
    <p>C R</p>
    <p>L 1</p>
    <p>S C</p>
    <p>C R</p>
    <p>L 1</p>
    <p>S C</p>
    <p>C R</p>
    <p>L 1</p>
    <p>S C</p>
    <p>NET COHERENCE SYNC CPU</p>
    <p>SP2 RMC2RMC1</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>Previous research (WindTunnel, Alewife, FLASH, TreadMark) shows:</p>
    <p>the benefits of explicit bulk communication with shared-memory  that overhead in shared-memory systems is proportional to the</p>
    <p>amount of cache/page/region misses</p>
    <p>Split-C shows the benefits of explicit communication without caching</p>
    <p>Scales and Lam demonstrate the benefits of caching and pushbased communication with caching in SAM</p>
    <p>First study that compares and evaluates the performance of the four communication mechanisms in global address space systems</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>Split-C and CRL applications have comparable performances  if a carefully controlled study is conducted</p>
    <p>Programming experience: what versus when  CRL Regions: Programmer optimizes what to transfer  Split-C: Programmer optimizes when to transfer...</p>
    <p>Pipelining communication phases with explicit synchronization  Managing local copies of remote data</p>
    <p>Paper contains detailed results for:  multiple versions of 5 applications  running on 4 machines</p>
  </div>
</Presentation>
