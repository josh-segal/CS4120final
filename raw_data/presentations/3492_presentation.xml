<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>A Distributed Polylogarithmic Time Algorithm for SelfStabilizing Skip Graphs</p>
    <p>Stefan Schmid &amp; Christian Scheideler</p>
    <p>Dept. of Computer Science</p>
    <p>University of Paderborn</p>
    <p>Riko Jacob &amp; Hanjo Tubig</p>
    <p>Dept. of Computer Science</p>
    <p>Technische Universitt Mnchen</p>
    <p>Andrea Richa</p>
    <p>Dept. of Computer Science</p>
    <p>Arizona State University</p>
  </div>
  <div class="page">
    <p>Overlay Network</p>
    <p>Internet Internet</p>
  </div>
  <div class="page">
    <p>Overlay Network</p>
    <p>Basic question: how to organize sites in a scalable and robust overlay network???</p>
    <p>Problem: high join/leave activity!</p>
  </div>
  <div class="page">
    <p>Overlay Network</p>
    <p>Scalability: Every operation needs at most (poly-)logarithmic time and work</p>
  </div>
  <div class="page">
    <p>Overlay Network</p>
    <p>Robustness: can recover from any attack ( self-stabilizing overlay network)</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Basic notation  Prior work  Self-stabilizing skip graph  Conclusion</p>
  </div>
  <div class="page">
    <p>Basic Notation</p>
    <p>Overlay network: directed graph G=(V,E):  V: set of nodes  E  {(v,w) | v,wV}: set of edges</p>
    <p>A</p>
    <p>D B C</p>
    <p>v knows wv knows w</p>
  </div>
  <div class="page">
    <p>Basic Notation</p>
    <p>State of a node v:  Local variables  Neighborhood N(v)  Set of actions/rules of the form</p>
    <p>&lt;label&gt;: &lt;guard&gt;  &lt;commands&gt;</p>
    <p>The set of actions is the same for every node and is supposed to be immutable.</p>
  </div>
  <div class="page">
    <p>Basic Notation</p>
    <p>The nodes may only know the local state of their direct neighbors.</p>
    <p>Only the following overlay commands:  u.insert(v,w): u asks neighbor v to establish</p>
    <p>edge to neighbor w</p>
    <p>u v</p>
    <p>w u</p>
    <p>v</p>
    <p>w</p>
  </div>
  <div class="page">
    <p>Basic Notation</p>
    <p>The nodes may only know the local state of their direct neighbors.</p>
    <p>Only the following overlay commands:  u.move(v,w): u asks neighbor v to establish</p>
    <p>edge to neighbor w and removes (u,w)</p>
    <p>no delete operation!</p>
    <p>u v</p>
    <p>w u</p>
    <p>v</p>
    <p>w</p>
  </div>
  <div class="page">
    <p>Basic Notation</p>
    <p>The nodes may only know the local state of their direct neighbors.</p>
    <p>Only the following overlay commands:  u.move(v,w): u asks neighbor v to establish</p>
    <p>edge to neighbor w and removes (u,w)</p>
    <p>sufficient to merge parallel edges</p>
    <p>u v</p>
    <p>w u</p>
    <p>v</p>
    <p>w</p>
  </div>
  <div class="page">
    <p>Basic Notation</p>
    <p>Self-stabilizing overlay network: A network that can get back to a desired topology from any initial state in which the network is still weakly connected.</p>
  </div>
  <div class="page">
    <p>Basic Notation</p>
    <p>During the self-stabilization process:  Node set is fixed, all nodes reliable  Messages arrive within a time unit  No message loss</p>
  </div>
  <div class="page">
    <p>Basic Notation</p>
    <p>During the self-stabilization process:  Time proceeds in synchronous rounds.  All actions that are enabled in a round (i.e.</p>
    <p>their guard is true) are executed.  All local and overlay commands are</p>
    <p>correctly executed within the given round.</p>
    <p>Simplifies analysis!</p>
  </div>
  <div class="page">
    <p>Basic Requirements</p>
    <p>Scalability: Only O(polylog(n)) many enabled actions per join or leave operation to get back to legal topology</p>
    <p>Robustness: Self-stabilization from any weakly connected state</p>
  </div>
  <div class="page">
    <p>Our Requirements</p>
    <p>Scalability: Only O(polylog(n)) many enabled actions per join or leave operation to get back to legal topology</p>
    <p>Robustness: Quick self-stabilization from any weakly connected state</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Basic notation  Prior work  Self-stabilizing skip graph  Conclusion</p>
  </div>
  <div class="page">
    <p>Prior Work</p>
    <p>Self-stabilization goes back to Dijkstras seminal work in 1974</p>
    <p>Self-stabilizing algorithms known for leader election, various communication protocols, graph theory problems, termination detection, clock synchronization, etc.</p>
    <p>Underlying network is usually assumed to be static (if not, then changes are not under control of algorithm but happen in a random or adversarial manner)</p>
  </div>
  <div class="page">
    <p>Prior Work</p>
    <p>Static networks allow efficient cross-checking of distributed computation</p>
    <p>Development of various techniques that convert conventional algorithms into self-stabilizing algorithms (Awerbuch, Dolev, Herman, Kutten, Patt-Shamir, Varghese,)</p>
    <p>u v</p>
    <p>w St+1(u) = f(St(u),St(v),St(w))</p>
  </div>
  <div class="page">
    <p>Prior Work</p>
    <p>These general techniques do not work (well)</p>
    <p>for self-stabilizing overlay networks.</p>
    <p>u v</p>
    <p>v</p>
    <p>Time t Time t+1</p>
    <p>u</p>
    <p>w</p>
    <p>w</p>
    <p>w</p>
    <p>St+1(u) = f(St(u),St(v),St(v))</p>
    <p>Two options:  find old neighbors  reset</p>
  </div>
  <div class="page">
    <p>Prior Work</p>
    <p>Suprisingly little known for self-stabilizing</p>
    <p>overlay networks  Chord network [Stoica et al.]: recovery from certain degenerate</p>
    <p>states. Problem: Chord not locally checkable</p>
    <p>Skip graphs [Aspnes &amp; Shah]: recovery from certain degenerate states. Problem: skip graphs not locally checkable as well</p>
    <p>Self-stabilizing line/cycle/hypertree: - Angluin, Aspnes,  2005 - Cramer &amp; Fuhrmann 2005 - Shaker &amp; Reeves 2005 - Dolev &amp; Kat 2007</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Basic notation  Prior work  Self-stabilizing skip graph  Conclusion</p>
  </div>
  <div class="page">
    <p>Self-Stabilizing Skip Graph</p>
    <p>Each node v has arbitrary unique name v.id and random bit string v.rs</p>
    <p>v.id and v.rs are assumed to be immutable  prei(v): first i bits of v.rs</p>
    <p>Skip graph rule: For every node v and iIN0:  v connects to closest successor and</p>
    <p>predecessor w (w.r.t. v.id ) with prei(w) = prei(v)</p>
  </div>
  <div class="page">
    <p>Self-Stabilizing Skip Graph</p>
    <p>Nodes v with v.rs=0</p>
    <p>Nodes v with v.rs=1</p>
  </div>
  <div class="page">
    <p>Self-Stabilizing Skip Graph</p>
    <p>Hierarchical view:</p>
    <p>log n) degree, (log n) diameter, (1) expansion w.h.p.</p>
  </div>
  <div class="page">
    <p>Self-Stabilizing Skip Graph</p>
    <p>Problem: original skip graph does not allow local checking of correct topology</p>
    <p>wv</p>
  </div>
  <div class="page">
    <p>Self-Stabilizing Skip Graph</p>
    <p>Problem: original skip graph does not allow local checking of correct topology</p>
    <p>Solution: extend connections</p>
    <p>For each node v let  succi(v,b), b{0,1}: closest successor of v with prefix</p>
    <p>prei(v)b  predi(v,b), b{0,1}: closest predecessor of v with prefix prei(v)b  rangei(v)=[minb predi(v,b), maxb succi(v,b)]</p>
    <p>v connects to all nodes wrangei(v)with prei(w) = prei(v)</p>
    <p>Result: SKIP+</p>
    <p>Skip graph: rangei(v)=[predi(v),succi(v)] Skip graph: rangei(v)=[predi(v),succi(v)]</p>
  </div>
  <div class="page">
    <p>Self-Stabilizing Skip Graph</p>
    <p>log n) degree, (log n) diameter, (1) expansion w.h.p.</p>
  </div>
  <div class="page">
    <p>Self-Stabilizing Skip Graph</p>
    <p>edge (u,v) stable: SKIP+ edge from viewpoint of u</p>
    <p>otherwise, (u,v) is temporary  flag F(v): indicator in u whether (u,v)</p>
    <p>stable</p>
    <p>Rule 1a: create reverse edges u v</p>
    <p>stable</p>
    <p>u v</p>
  </div>
  <div class="page">
    <p>Self-Stabilizing Skip Graph</p>
    <p>Rule 1b/c: introduce stable edges</p>
    <p>Rule 2: forward temporary edges</p>
    <p>u v</p>
    <p>w</p>
    <p>w.id  rangei(v)</p>
    <p>u v</p>
    <p>w</p>
    <p>b c</p>
    <p>u v</p>
    <p>w (longer prefix match)</p>
    <p>temp</p>
    <p>stable</p>
    <p>u v</p>
    <p>w</p>
  </div>
  <div class="page">
    <p>Self-Stabilizing Skip Graph</p>
    <p>Rule 3a: introduce all u changes set of stable neighbors: initiates insert(v,w) for all neighbors v,w of u</p>
    <p>Rule 3b: linearize</p>
    <p>u</p>
    <p>v1 v2 v3 vk</p>
    <p>stable</p>
    <p>u</p>
    <p>v1 v2 v3 vk</p>
    <p>stable</p>
    <p>stable</p>
  </div>
  <div class="page">
    <p>Self-Stabilizing Skip Graph</p>
    <p>Each node u follows six rules:  Rule 1a: create reverse edges to u  Rules 1b and 1c: introduce stable edges</p>
    <p>between neighbors of u  Rule 2: forward temporary edges  Rule 3a: introduce all when stable</p>
    <p>neighborhood changes  Rule 3b: linearize stable neighborhood</p>
  </div>
  <div class="page">
    <p>Self-Stabilizing Skip Graph</p>
    <p>Theorem 1: For any weakly connected graph, the rules establish SKIP+ in O(log2 n) rounds w.h.p.</p>
    <p>Theorem 2: Any join or leave operation in a perfect SKIP+ requires at most O(log4 n) work.</p>
  </div>
  <div class="page">
    <p>Self-Stabilizing Skip Graph</p>
    <p>Proof of Theorem 1:  Bottom-up phase: connected components</p>
    <p>are formed for every prefix</p>
  </div>
  <div class="page">
    <p>Self-Stabilizing Skip Graph</p>
    <p>Proof of Theorem 1:  Top-down phase: components sorted</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>Many interesting fronts to work on in context of self-stabilizing overlay networks:  Show O(log n) runtime bound  bound/restrict number of enabled actions</p>
    <p>to polylog at each node per round  self-stabilizing networks under adversarial</p>
    <p>behavior  self-preserving networks  self-optimizing networks</p>
  </div>
  <div class="page">
    <p>Questions?</p>
  </div>
</Presentation>
