<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Daniel Luchaup, University of Wisconsin-Madison Kevin P. Dyer, Portland State University Somesh Jha, University of Wisconsin-Madison Thomas Ristenpart, University of Wisconsin-Madison Thomas Shrimpton, Portland State University</p>
    <p>LibFTE: A Toolkit for Constructing Practical, Format-Abiding Encryption Schemes</p>
  </div>
  <div class="page">
    <p>FPE1234 5678 9876 5432 4417 1234 5678 9112</p>
    <p>In-place encryption in database</p>
    <p>Plaintext Ciphertext</p>
    <p>(Bellare et al. SAC09) (Format-preserving encryption)</p>
  </div>
  <div class="page">
    <p>FTE</p>
    <p>(Dyer et al. CCS13)</p>
    <p>or SMTP, SIP, RSTP, SSH,.</p>
    <p>Censorship circumvention</p>
    <p>Plaintext Ciphertext</p>
    <p>(Format-transforming encryption)</p>
  </div>
  <div class="page">
    <p>What about other applications?</p>
    <p>Expert knowledge required, substantial implementation and performance challenges.</p>
  </div>
  <div class="page">
    <p>What about other applications?</p>
    <p>Expert knowledge required, substantial implementation and performance challenges.</p>
  </div>
  <div class="page">
    <p>New algorithms to support this framework that solve open problem</p>
    <p>A general framework for building FTE (and FPE)</p>
    <p>A library (python/C++), and a toolkit to support development</p>
    <p>Our contribution: LibFTE</p>
    <p>https://libfte.org/</p>
    <p>FTE</p>
    <p>key plaintext in L(R1)</p>
    <p>ciphertext in L(R2)</p>
    <p>regex R1 regex R2</p>
  </div>
  <div class="page">
    <p>New algorithms to support this framework that solve open problem</p>
    <p>A general framework for building FTE (and FPE)</p>
    <p>A library (python/C++), and a toolkit to support development</p>
    <p>Our contribution: LibFTE</p>
    <p>https://libfte.org/</p>
    <p>FTE</p>
    <p>key plaintext in L(R1)</p>
    <p>ciphertext in L(R2)</p>
    <p>regex R1 regex R2</p>
  </div>
  <div class="page">
    <p>The Previous FTE scheme (Dyer et al. 2013)</p>
    <p>L(R)</p>
    <p>xi</p>
    <p>x2</p>
    <p>rank(xi)=i</p>
    <p>unrank(2)=x2</p>
    <p>Goldberg/Sipser (1985) Bellare et al. (2009)</p>
    <p>Encrypt Unrank</p>
    <p>regex-to-DFA</p>
    <p>key plaintext ciphertext</p>
    <p>in L(R)regex R</p>
  </div>
  <div class="page">
    <p>The Previous FTE scheme (Dyer et al. 2013)</p>
    <p>L(R)</p>
    <p>xi</p>
    <p>x2</p>
    <p>rank(xi)=i</p>
    <p>unrank(2)=x2</p>
    <p>Goldberg/Sipser (1985) Bellare et al. (2009)</p>
    <p>Encrypt Unrank</p>
    <p>regex-to-DFA</p>
    <p>key plaintext ciphertext</p>
    <p>in L(R)regex R</p>
  </div>
  <div class="page">
    <p>The Previous FTE scheme (Dyer et al. 2013)</p>
    <p>L(R)</p>
    <p>xi</p>
    <p>x2</p>
    <p>rank(xi)=i</p>
    <p>unrank(2)=x2</p>
    <p>Goldberg/Sipser (1985) Bellare et al. (2009)</p>
    <p>efficient implementation of (un)rank requires DFA representation of</p>
    <p>language</p>
    <p>Encrypt Unrank</p>
    <p>regex-to-DFA</p>
    <p>key plaintext ciphertext</p>
    <p>in L(R)regex R</p>
  </div>
  <div class="page">
    <p>The Previous FTE scheme (Dyer et al. 2013)</p>
    <p>Encrypt Unrank</p>
    <p>regex-to-DFA</p>
    <p>unranking requires space linear in the size of the DFA, and the length</p>
    <p>of the longest plaintext</p>
    <p>key plaintext ciphertext</p>
    <p>in L(R)regex R</p>
  </div>
  <div class="page">
    <p>The Previous FTE scheme (Dyer et al. 2013)</p>
    <p>Encrypt Unrank</p>
    <p>regex-to-DFA</p>
    <p>key plaintext ciphertext</p>
    <p>in L(R)regex R</p>
    <p>regex NFA DFA</p>
    <p>For some regular expressions, this works out just fine</p>
    <p>unranking requires space linear in the size of the DFA, and the length</p>
    <p>of the longest plaintext</p>
  </div>
  <div class="page">
    <p>The Previous FTE scheme (Dyer et al. 2013)</p>
    <p>Encrypt Unrank</p>
    <p>regex-to-DFA</p>
    <p>key plaintext ciphertext</p>
    <p>in L(R)regex R</p>
    <p>regex NFA DFA for others, you can have an</p>
    <p>exponential space blow-up</p>
    <p>unranking requires space linear in the size of the DFA, and the length</p>
    <p>of the longest plaintext</p>
    <p>A DFA with 13K states requires ~200MB of memory for (un)ranking. (Dyer et al., CCS13)</p>
  </div>
  <div class="page">
    <p>A new, NFA-based, FTE scheme</p>
    <p>Encrypt Unrank</p>
    <p>regex-to-NFA</p>
    <p>key plaintext ciphertext</p>
    <p>in L(R)regex R</p>
    <p>valid?</p>
    <p>L(R)</p>
    <p>x</p>
    <p>x</p>
    <p>rank(xi)=i</p>
    <p>unrank(2)=x2 unrank(3)=x2</p>
    <p>Based on new concept, relaxed ranking:</p>
  </div>
  <div class="page">
    <p>A new, NFA-based, FTE scheme</p>
    <p>Encrypt Unrank</p>
    <p>regex-to-NFA</p>
    <p>key plaintext ciphertext</p>
    <p>in L(R)regex R</p>
    <p>valid?</p>
    <p>L(R)</p>
    <p>x</p>
    <p>x</p>
    <p>rank(xi)=i</p>
    <p>unrank(2)=x2 unrank(3)=x2</p>
    <p>Based on new concept, relaxed ranking:</p>
  </div>
  <div class="page">
    <p>LibFTE framework is more general</p>
    <p>key plaintext in L(R1)</p>
    <p>ciphertext in L(R2)</p>
    <p>regex R1</p>
    <p>UnrankRank</p>
    <p>regex R2</p>
    <p>YEncrypt valid?</p>
    <p>N</p>
  </div>
  <div class="page">
    <p>LibFTE framework is more general</p>
    <p>key plaintext in L(R1)</p>
    <p>ciphertext in L(R2)</p>
    <p>regex R1</p>
    <p>UnrankRank</p>
    <p>regex R2</p>
    <p>YEncrypt valid?</p>
    <p>N</p>
  </div>
  <div class="page">
    <p>LibFTE framework is more general</p>
    <p>key plaintext in L(R1)</p>
    <p>ciphertext in L(R2)</p>
    <p>regex R1</p>
    <p>UnrankRank</p>
    <p>regex R2</p>
    <p>YEncrypt valid?</p>
    <p>N</p>
  </div>
  <div class="page">
    <p>LibFTE framework is more general</p>
    <p>key plaintext in L(R1)</p>
    <p>ciphertext in L(R2)</p>
    <p>regex R1</p>
    <p>UnrankRank</p>
    <p>regex R2</p>
    <p>YEncrypt valid?</p>
    <p>N</p>
  </div>
  <div class="page">
    <p>LibFTE framework is more general</p>
    <p>UnrankRank YEncrypt valid?</p>
    <p>N</p>
    <p>NFA or DFA ranking for R1</p>
    <p>key plaintext in L(R1)</p>
    <p>ciphertext in L(R2)</p>
    <p>regex R1 regex R2</p>
  </div>
  <div class="page">
    <p>LibFTE framework is more general</p>
    <p>UnrankRank YEncrypt valid?</p>
    <p>N</p>
    <p>NFA or DFA ranking for R1 NFA or DFA ranking for R2</p>
    <p>key plaintext in L(R1)</p>
    <p>ciphertext in L(R2)</p>
    <p>regex R1 regex R2</p>
  </div>
  <div class="page">
    <p>LibFTE framework is more general</p>
    <p>UnrankRank YEncrypt valid?</p>
    <p>N</p>
    <p>NFA or DFA ranking for R1 NFA or DFA ranking for R2</p>
    <p>Deterministic or randomized encryption</p>
    <p>key plaintext in L(R1)</p>
    <p>ciphertext in L(R2)</p>
    <p>regex R1 regex R2</p>
  </div>
  <div class="page">
    <p>LibFTE framework is more general</p>
    <p>UnrankRank YEncrypt valid?</p>
    <p>N</p>
    <p>NFA or DFA ranking for R1 NFA or DFA ranking for R2</p>
    <p>Deterministic or randomized encryption Choice of regular expressions R1, R2</p>
    <p>key plaintext in L(R1)</p>
    <p>ciphertext in L(R2)</p>
    <p>regex R1 regex R2</p>
  </div>
  <div class="page">
    <p>LibFTE framework is more general</p>
    <p>UnrankRank YEncrypt valid?</p>
    <p>N</p>
    <p>NFA or DFA ranking for R1 NFA or DFA ranking for R2</p>
    <p>Deterministic or randomized encryption Choice of regular expressions R1, R2</p>
    <p>key plaintext in L(R1)</p>
    <p>ciphertext in L(R2)</p>
    <p>regex R1 regex R2</p>
  </div>
  <div class="page">
    <p>LibFTE framework is more general</p>
    <p>UnrankRank YEncrypt valid?</p>
    <p>N</p>
    <p>NFA or DFA ranking for R1 NFA or DFA ranking for R2</p>
    <p>Deterministic or randomized encryption Choice of regular expressions R1, R2</p>
    <p>key plaintext in L(R1)</p>
    <p>ciphertext in L(R2)</p>
    <p>regex R1 regex R2</p>
  </div>
  <div class="page">
    <p>LibFTE Configuration Assistant</p>
    <p>input: input format, output format, and optional restrictions (e.g., encryption must be randomized/deterministic)</p>
    <p>output: an error OR a list of schemes that satisfy the userspecified constraints, with statistics (no. cycle walks, etc.)</p>
    <p>$ ./configuration-assistant \ &gt; --input-format &quot;(a|b)*a(a|b){16}&quot; 0 64 \ &gt; --output-format &quot;[0-9a-f]{16}&quot; 0 16 ! ==== Identifying valid schemes ==== No valid schemes. ERROR: Input language size greater than output language size. $ !!!!!!</p>
    <p>error</p>
    <p>$ ./configuration-assistant \ &gt; --input-format &quot;(a|b)*a(a|b){16}&quot; 0 32 \ &gt; --output-format &quot;[0-9a-f]{16}&quot; 0 16 ! ==== Identifying valid schemes ==== WARNING: Memory threshold exceeded when building DFA for input format VALID SCHEMES: T-ND, T-NN, T-ND-$, T-NN-$ ! ==== Evaluating valid schemes ==== SCHEME ENCRYPT DECRYPT ... MEMORY T-ND 0.32ms 0.31ms ... 77KB T-NN 0.39ms 0.38ms ... 79KB  $</p>
    <p>OR</p>
    <p>success</p>
  </div>
  <div class="page">
    <p>LibFTE Configuration Assistant</p>
    <p>input: input format, output format, and optional restrictions (e.g., encryption must be randomized/deterministic)</p>
    <p>output: an error OR a list of schemes that satisfy the userspecified constraints, with statistics (no. cycle walks, etc.)</p>
    <p>$ ./configuration-assistant \ &gt; --input-format &quot;(a|b)*a(a|b){16}&quot; 0 64 \ &gt; --output-format &quot;[0-9a-f]{16}&quot; 0 16 ! ==== Identifying valid schemes ==== No valid schemes. ERROR: Input language size greater than output language size. $ !!!!!!</p>
    <p>error</p>
    <p>$ ./configuration-assistant \ &gt; --input-format &quot;(a|b)*a(a|b){16}&quot; 0 32 \ &gt; --output-format &quot;[0-9a-f]{16}&quot; 0 16 ! ==== Identifying valid schemes ==== WARNING: Memory threshold exceeded when building DFA for input format VALID SCHEMES: T-ND, T-NN, T-ND-$, T-NN-$ ! ==== Evaluating valid schemes ==== SCHEME ENCRYPT DECRYPT ... MEMORY T-ND 0.32ms 0.31ms ... 77KB T-NN 0.39ms 0.38ms ... 79KB  $</p>
    <p>OR</p>
    <p>success</p>
  </div>
  <div class="page">
    <p>Case Studies</p>
  </div>
  <div class="page">
    <p>LibFTE: Snort IDS Regexs</p>
    <p>Reduced avg. memory by 30%. In some cases by orders of magnitude.</p>
    <p>Handled extreme cases (~3%) where DFA ranking fails. All 3.5K regexs could be used with &lt;150MB of memory using NFA ranking.</p>
    <p>Used a set of ~3.5K regexs from the Snort corpus. A good stress test.</p>
    <p>Threshold (MB)</p>
    <p>C D</p>
    <p>F (%</p>
    <p>u n d er</p>
    <p>th re</p>
    <p>sh o ld</p>
    <p>)</p>
    <p>T-DN-$ vs. T-DD-$</p>
    <p>T-DN-$</p>
    <p>T-DD-$</p>
    <p>with LibFTE w/o LibFTE</p>
  </div>
  <div class="page">
    <p>LibFTE: Snort IDS Regexs</p>
    <p>Reduced avg. memory by 30%. In some cases by orders of magnitude.</p>
    <p>Handled extreme cases (~3%) where DFA ranking fails. All 3.5K regexs could be used with &lt;150MB of memory using NFA ranking.</p>
    <p>Used a set of ~3.5K regexs from the Snort corpus. A good stress test.</p>
    <p>Threshold (MB)</p>
    <p>C D</p>
    <p>F (%</p>
    <p>u n d er</p>
    <p>th re</p>
    <p>sh o ld</p>
    <p>)</p>
    <p>T-DN-$ vs. T-DD-$</p>
    <p>T-DN-$</p>
    <p>T-DD-$</p>
    <p>with LibFTE w/o LibFTE</p>
  </div>
  <div class="page">
    <p>LibFTE: Database encryption+compression</p>
    <p>Database Configuration</p>
    <p>PSQL +AES +AE +FPE +FTE</p>
    <p>Table Size 50MB 65MB 112MB 50MB 42MB</p>
    <p>Query Avg. 74ms 92ms 112ms 125ms 110ms</p>
    <p>Query Avg. = time to retrieve 1000 CC nums</p>
    <p>Compare against PostgreSQL encryption library. Because there does not exist any public implementation of FPE/FFX.</p>
    <p>Created a table with credit card numbers. Then tested under various configurations.</p>
  </div>
  <div class="page">
    <p>LibFTE: Database encryption+compression</p>
    <p>Database Configuration</p>
    <p>PSQL +AES +AE +FPE +FTE</p>
    <p>Table Size 50MB 65MB 112MB 50MB 42MB</p>
    <p>Query Avg. 74ms 92ms 112ms 125ms 110ms</p>
    <p>Compared to AES, LibFTE saves ~35% on disk.</p>
    <p>Query Avg. = time to retrieve 1000 CC nums</p>
    <p>Compare against PostgreSQL encryption library. Because there does not exist any public implementation of FPE/FFX.</p>
    <p>Created a table with credit card numbers. Then tested under various configurations.</p>
  </div>
  <div class="page">
    <p>LibFTE: Firefox extension</p>
    <p>A pure-Javascript LibFTE interface.</p>
    <p>We created a mapping between fields and FPE/FTE schemes. Simple, using CSS id/class attrs.</p>
    <p>Using libfte: only 20 lines of code</p>
  </div>
  <div class="page">
    <p>LibFTE: Firefox extension</p>
    <p>A pure-Javascript LibFTE interface.</p>
    <p>We created a mapping between fields and FPE/FTE schemes. Simple, using CSS id/class attrs.</p>
    <p>Using libfte: only 20 lines of code</p>
  </div>
  <div class="page">
    <p>Conclusion: LibFTE</p>
    <p>New algorithmic advances. Abstracts away clunky design choices.</p>
    <p>High-performance, publicly available. APIs for C++ and Python.</p>
    <p>A general framework for building FTE (and FPE) schemes. No one-off, per-deployment solutions.</p>
    <p>https://libfte.org/</p>
    <p>Surfaced new use cases. Compression+encryption, in-browser encryption.</p>
  </div>
</Presentation>
