<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Hashing Round-down Prefixes for Rapid Packet Classification</p>
    <p>Fong Pong and Nian-Feng Tzeng*</p>
    <p>*Center for Advanced Computer Studies University of Louisiana, Lafayette, USA</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Packet Classification  Review of Existing Decision Tree and Hash Table-based Methods  The HaRP (Hash Round-down Prefixes) Design  Evaluation Results  Conclusion</p>
  </div>
  <div class="page">
    <p>Packet Classification</p>
    <p>Perform action A on packets of type T, from S to D,   Packet Filtering  Deny/Accept  Policy Routing  Send via designated network  Accounting &amp; Billing  Precedence and accounting  QoS, Drop Precedence, Rate Limiting or Traffic Shaping</p>
    <p>Fields used can be widely varying  Source IP (prefix)  Destination IP (prefix)  Transport port numbers (Range)  Protocol number (Range)  VLAN, Flag,</p>
    <p>Challenges  High speed/throughput  Low storage for growing number of rules  Incremental update for dynamic environments  Adaptive to changing rule specifications for different purposes</p>
  </div>
  <div class="page">
    <p>Prior Arts</p>
  </div>
  <div class="page">
    <p>Decision Tree-Based Methods (HyperCuts)</p>
    <p>An m-ary decision tree, at each node  max m children,  cuts made to multiple dimensions</p>
    <p>Challenges  Tree size explosion, sensitive to</p>
    <p>selection of dimensions  number of cuts per dimension  wildcard fields (e.g. (SIP=*, DIP))</p>
    <p>Difficulty in performing incremental updates  Refinements</p>
    <p>Dead pointer elimination; careful tuning of a space factor (SF),</p>
    <p>Use of Extended Bit Map to pack pointers in consecutive locations</p>
    <p>Push Common Rules to intermediate nodes</p>
  </div>
  <div class="page">
    <p>Hash Table-Based (Tuple Space)</p>
    <p>What is a tuple?  A vector of k integer elements, specifying the number of bits of fields used to</p>
    <p>form the hash key</p>
    <p>For example, a 2-D filter tuple (3, 4) means destination IP DIP|3 and source IP SIP| 4</p>
    <p>Each tuple is realized by a hash table prefix length</p>
    <p>source IP 0 1 2 3 4 5 6 . 32</p>
    <p>destination IP</p>
  </div>
  <div class="page">
    <p>Challenges and Optimization</p>
    <p>Identify a tuple  e.g. (216.31.219.19, 69.147.114.16, 80, 2408, TCP), how many bits needed for hash</p>
    <p>keys?</p>
    <p>Reduce number of hash probes and keep small hash tables  Optimization schemes include Tuple pruning, Rectangle search, Binary Search</p>
    <p>on Columns, Diagonal-based Search</p>
    <p>prefix length</p>
    <p>source IP 0 1 2 3 4 5 6 . 32</p>
    <p>destination IP</p>
    <p>T T</p>
    <p>T</p>
    <p>T T</p>
  </div>
  <div class="page">
    <p>Practical Implementation  Use two Decision Trees to perform Prefix Match</p>
    <p>Produce two tuple lists  Cross product the two lists to reveal the hash tables for probing</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Decision tree  size explosion  difficult to do incremental updates  no good ways to tune for ideal configurations</p>
    <p>Tuple space  practical implementation uses tries, combined with hash tables  may suffer as decision trees  many hash tables to manage  markers and pre-computed results increase storage</p>
  </div>
  <div class="page">
    <p>HaRP (Hash Round-down Prefix)</p>
    <p>Simple method and data structures enable  parallel lookup for high performance  high memory efficiency and less storage  easy incremental updates</p>
  </div>
  <div class="page">
    <p>Two Stages</p>
    <p>Rules are broken into two parts: (SIP, DIP) + (SP, DP, Proto)  1st stage percolate rules by prefix match on (SIP, DIP) via a simple hash</p>
    <p>table</p>
    <p>2nd stage inspects further on ASI (Application-Specific-Information); the rest of fields (SP, DP, Proto) via a simple linear search</p>
    <p>(SIP|a, DIP|b) ASI</p>
    <p>(SIP|c, DIP|d) ASI</p>
    <p>:: ::</p>
    <p>(SIP|m, DIP|n) ASI</p>
    <p>R1:(sp, dp, pr) R2:(sp, dp, pr) R3:(sp, dp, pr) R4:(sp, dp, pr)</p>
    <p>R5:(sp, dp, pr) R6:(sp, dp, pr)</p>
    <p>R7:(sp, dp, pr) R8:(sp, dp, pr) R9:(sp, dp, pr)</p>
  </div>
  <div class="page">
    <p>Prefix Matches on (SIP, DIP)  Choose Designated Prefix Length (DPL) {l1, l2,  li,  lm}, for example,</p>
    <p>{32, 28, 24, 20, 16, 12, 8, 1}</p>
    <p>Round down prefix P|w, with li  w &lt; li+1, to P|li , e.g. 23 20  Each DPL tread logically defines a hash table, but   Achieve higher storage utilization by lumping all tables in one, and each</p>
    <p>bucket has k entries to mitigate hash collisions</p>
    <p>Storage efficiency (and less hash collisions) is further improved by migrating (SIP, DIP) among buckets</p>
    <p>(SIP|a, DIP|b) ASI</p>
    <p>(SIP|c, DIP|d) ASI</p>
    <p>:: ::</p>
    <p>(SIP|m, DIP|n) ASI</p>
    <p>(sp, dp, pr) (sp, dp, pr) (sp, dp, pr) (sp, dp, pr)</p>
    <p>(sp, dp, pr) (sp, dp, pr)</p>
  </div>
  <div class="page">
    <p>Re-balancing by Transitive Property</p>
    <p>Prefixes P1 &gt;&gt; P2 &amp;&amp; P2 &gt;&gt; P3  P1 &gt;&gt; P2 &gt;&gt; P3  P3 can be installed in buckets identified by hash(P1), hash (P2)</p>
    <p>and hash (P3) so long we search all of them, which we must do anyway</p>
    <p>P|32</p>
    <p>P|16</p>
    <p>P|8</p>
    <p>P|24</p>
  </div>
  <div class="page">
    <p>Adding Rules</p>
    <p>Rule: (SIP|m, DIP|n, sp, dp, tcp)  Round DIP|m to next tread t1 in DPL  Round SIP|n to next tread t2 in DPL</p>
    <p>HaRP  basic algorithm installs (SIP, DIP) in  the bucket indexed by Hash(DIP|t1) or  the bucket indexed by Hash(SIP|t2)  effectively increase the bucket capacity to 2*k</p>
    <p>HaRP* - enhanced algorithm installs (SIP, DIP) in (the Host)  any one of the buckets indexed by Hash(DIP), where DIP &gt;&gt; DIP, or  any one of the buckets indexed by Hash(SIP), where SIP &gt;&gt; SIP  effectively increase the bucket capacity to 2*k* (is + id)</p>
  </div>
  <div class="page">
    <p>Lookup (Exact 2m Hash Probes)</p>
  </div>
  <div class="page">
    <p>Evaluation Results</p>
  </div>
  <div class="page">
    <p>Rule Set Characteristics (ClassBench)</p>
    <p>Seed Filters (#filters)</p>
    <p>Synthetic (#filters)</p>
    <p>FW1 (269)</p>
    <p>FW-10K (9311)</p>
    <p>ACL1 (752)</p>
    <p>ACL-10K (9603)</p>
    <p>IPC1 (1550)</p>
    <p>IPC-10K (9037)</p>
  </div>
  <div class="page">
    <p>Tunable Parameters</p>
  </div>
  <div class="page">
    <p>(SIP, DIP) Hash Distribution (Bucket Size k = 4)</p>
  </div>
  <div class="page">
    <p>Search of the ASI Lists</p>
  </div>
  <div class="page">
    <p>Deal with Long ASI Lists</p>
    <p>Divide a long ASI list to several short lists by selected yardsticks</p>
  </div>
  <div class="page">
    <p>Storage Requirement</p>
  </div>
  <div class="page">
    <p>Measured Lookup Performance</p>
    <p>Execute the program on Broadcoms 4-way Multi-core SoC  4 x 700MHz MIPS cores  Each core is a 4-way superscalar design  32KB non-blocking L1 cache that allows 8 outstanding misses  1MB shared L2 cache</p>
    <p>Same result trends are observed for more powerful systems  AMD Opteron @2.8GHz w/ 1MB Cache  Intel Xeon @3.16GHz w/ 6MB Cache</p>
  </div>
  <div class="page">
    <p>Execution Performance</p>
  </div>
  <div class="page">
    <p>Data Footprint</p>
  </div>
  <div class="page">
    <p>HyperCuts</p>
  </div>
  <div class="page">
    <p>Tuple Space</p>
  </div>
  <div class="page">
    <p>HaRP Search Performance</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>We propose an innovative hash table-based design  A two stage method is shown to be effective  The transitive property of prefixes allow migration of elements in</p>
    <p>the hash table for more even distribution  simple data structures  simple operations  the smallest amount of storage among existing methods  easy incremental update</p>
  </div>
  <div class="page">
    <p>Q&amp;A</p>
    <p>Thank You!</p>
  </div>
  <div class="page">
    <p>Comparison Between HaRP* and d-left (Multiple) Hashing</p>
    <p>d-left Hashing or Multilevel Hashing  d hash tables, [s1, s2, sd]  Use d hash functions to identify d buckets  Use the least loaded bucket  Tie breaker goes to sj with lower number j</p>
    <p>HaRP*  d-left with subtle differences</p>
    <p>HaRP* d-left</p>
    <p>#hash functions 1 d (&gt;=2)</p>
    <p>#hash tables 1 m*d (d per tread)</p>
    <p>#hash probes 2*m 2*m*d</p>
    <p>P|32</p>
    <p>P|8</p>
    <p>P|28</p>
  </div>
</Presentation>
