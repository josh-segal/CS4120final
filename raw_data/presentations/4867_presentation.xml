<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Towards Completely Automatic Decoder</p>
    <p>Synthesis</p>
    <p>Hsiou-Yuan Liu, Yen-Cheng Chou, Chen-Hsuan L in, and Jie-Hong Roland Jiang</p>
    <p>ALCom Lab EE Dept/ Grad. Inst. of Electronics Eng.</p>
    <p>National Taiwan University</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Introduction  Decoder existence checking  Decoder synthesis  Experimental results  Conclusions</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Encoder0,1,1,0,0, 1,0,1,0,1,</p>
    <p>Decoder</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Decoding process under a bounded observation window</p>
    <p>, ok, ok+1, ok+2, ok+3, ok+4, ok+5, Encoder Decoder</p>
    <p>ij ij+1ij+1 ij+2</p>
  </div>
  <div class="page">
    <p>Introduction  Example</p>
    <p>Output Input</p>
    <p>q0 q1</p>
    <p>q0 q1</p>
    <p>Output Input</p>
  </div>
  <div class="page">
    <p>Introduction  Encoding/decoding scheme plays key roles in</p>
    <p>various applications, including  Communication,  Signal processing,  Cryptography,</p>
    <p>Designing a decoder can be more difficult than designing an encoder</p>
    <p>Automatic decoder synthesis helps a designer effectively and correctly implement his/her system</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Basic assumptions:  Encoder can be sequential</p>
    <p>Combinational encoder is a special case  Can be decoded with observation window of size 1</p>
    <p>Steady state behavior is of main concern  Initial transient behavior is neglected</p>
    <p>Decoder has finite memory  Bounded observation window</p>
  </div>
  <div class="page">
    <p>Prior Work</p>
    <p>Decoder synthesis [Shen et al. ICCAD09]  Bounded decoder existence checking  Decoder generation using ALLSAT</p>
    <p>Halting algorithm [Shen et al. FMCAD10]  Unbounded decoder existence checking (with flaw)</p>
  </div>
  <div class="page">
    <p>Contributions</p>
    <p>Theoretically, guaranteed decoder existence/inexistence checking with simplified formulation</p>
    <p>Practically, fast computation  Simplified CNF encoding  Interpolation for decoder synthesis</p>
  </div>
  <div class="page">
    <p>Decoder Existence Checking  Notation</p>
    <p>T</p>
    <p>x y</p>
    <p>s s'</p>
    <p>input output</p>
    <p>current state next state</p>
    <p>transition relation</p>
  </div>
  <div class="page">
    <p>Decoder Existence Checking  Decoder exists under window (-n,p) iff</p>
    <p>is UNSAT</p>
    <p>T0T1 T1 TpTn</p>
    <p>T*0T*1 T*1 T*pT*n</p>
    <p>)())((),( 0*0** xxyyTTpnM</p>
    <p>p</p>
    <p>nt</p>
    <p>tttt</p>
  </div>
  <div class="page">
    <p>Decoder Existence Checking  Decoder does not exist iff</p>
    <p>is SAT for some n and p, where</p>
    <p>))((),( ,   pnpn LLLpnM</p>
    <p>p</p>
    <p>i</p>
    <p>p</p>
    <p>ij</p>
    <p>jiji p</p>
    <p>ni ij</p>
    <p>jiji n</p>
    <p>ni</p>
    <p>p</p>
    <p>j</p>
    <p>jiji pn</p>
    <p>ssssL</p>
    <p>ssssL</p>
    <p>ssssL</p>
    <p>**</p>
    <p>**</p>
    <p>** ,</p>
    <p>)))(((</p>
    <p>)),)(((</p>
    <p>)),)(((</p>
  </div>
  <div class="page">
    <p>Decoder Existence Checking  Decoder does not exist iff</p>
    <p>is SAT for some n and p, where</p>
    <p>))((),( ,   pnpn LLLpnM</p>
    <p>p</p>
    <p>j</p>
    <p>jpjp p</p>
    <p>nj</p>
    <p>jnjn n</p>
    <p>p</p>
    <p>j nj</p>
    <p>jpjpjnjn pn</p>
    <p>ssssL</p>
    <p>ssssL</p>
    <p>ssssssssL</p>
    <p>*1*1</p>
    <p>**</p>
    <p>,</p>
    <p>)))(((</p>
    <p>)),)(((</p>
    <p>,)))((()))(((</p>
  </div>
  <div class="page">
    <p>Decoder Existence Checking</p>
    <p>T0T1 T1 TpTn</p>
    <p>T*0T*1 T*1 T*pT*n</p>
    <p>L L</p>
    <p>L</p>
  </div>
  <div class="page">
    <p>Decoder Existence Checking</p>
    <p>encodersolve M(n,p)</p>
    <p>SAT?</p>
    <p>yes</p>
    <p>no decoder exists return (n, p)</p>
    <p>solve M(n,p)(L(LL))</p>
    <p>SAT? yes no decoder</p>
    <p>return counterexample</p>
    <p>no</p>
    <p>n := n+1 p := p+1</p>
    <p>n := 0 p := 0</p>
  </div>
  <div class="page">
    <p>Decoder Existence Checking  Incremental timeframe expansion</p>
    <p>Expand from outside</p>
    <p>T0T1</p>
    <p>T*0T*1</p>
    <p>T2</p>
    <p>T*2</p>
    <p>T3</p>
    <p>T*3</p>
  </div>
  <div class="page">
    <p>Decoder Existence Checking  Incremental timeframe expansion</p>
    <p>Expand from inside</p>
    <p>T0</p>
    <p>T*0</p>
    <p>T1</p>
    <p>T*1</p>
    <p>T1</p>
    <p>T*1</p>
    <p>T2</p>
    <p>T*2</p>
    <p>T2</p>
    <p>T*2</p>
    <p>T3</p>
    <p>T*3</p>
  </div>
  <div class="page">
    <p>Decoder Existence Checking  Disjunctive conditions</p>
    <p>p</p>
    <p>j</p>
    <p>jpjp p</p>
    <p>nj</p>
    <p>jnjn n</p>
    <p>p</p>
    <p>j nj</p>
    <p>jpjpjnjn pn</p>
    <p>ssssL</p>
    <p>ssssL</p>
    <p>ssssssssL</p>
    <p>*1*1</p>
    <p>**</p>
    <p>,</p>
    <p>)))(((</p>
    <p>)),)(((</p>
    <p>,)))((()))(((</p>
    <p>)),((),( ,   pnpn LLLpnM</p>
    <p>Not good for CNF encoding</p>
  </div>
  <div class="page">
    <p>Decoder Existence Checking  CNF encoding of disjunctive conditions</p>
    <p>E.g.,</p>
    <p>Let  = 1+2+3 = (C1C2C3)+(C4C5)+(C6C7)</p>
    <p>Let  = (C1+1) (C2+1) (C3+1) (C4+2) (C5+ 2) (C6+3) (C7+3) (1+2+3)</p>
    <p>and  are equisatisfiable</p>
  </div>
  <div class="page">
    <p>Decoder Existence Checking  Incremental CNF encoding of disjunctive con ditions  E.g.,</p>
    <p>Let  = 1+2+3 = (C1C2C3)+(C4C5)+(C6C7)</p>
    <p>Suppose i are appended incrementally</p>
    <p>Let  = (C1+1) (C2+1) (C3+1) (0+1+1) (C4+2) (C5+2) (1+2+2) (C6+3) (C7+3) (2+3+3)</p>
    <p>and (03) are equisatisfiable</p>
  </div>
  <div class="page">
    <p>Decoder Existence Checking</p>
    <p>encodersolve M(n,p)</p>
    <p>SAT?</p>
    <p>yes</p>
    <p>no decoder exists return (n, p)</p>
    <p>solve M(n,p)(L(LL))</p>
    <p>SAT? yes no decoder</p>
    <p>return counterexample</p>
    <p>no</p>
    <p>n := n+1 p := p+1</p>
    <p>n := 0 p := 0</p>
  </div>
  <div class="page">
    <p>Decoder Synthesis</p>
    <p>Craig interpolation theorem:  For (A  B) UNSAT, there exist</p>
    <p>s an interpolant I such that</p>
    <p>BA</p>
    <p>I</p>
  </div>
  <div class="page">
    <p>Decoder Synthesis  The interpolant corresponds to the desired decoder</p>
    <p>T0T1 T1 TpTn</p>
    <p>T*0T*1 T*1 T*pT*n</p>
    <p>A</p>
    <p>B</p>
  </div>
  <div class="page">
    <p>Experimental Results</p>
    <p>Our decoding system Decosy implemented in ABC using C language</p>
    <p>Experiments conducted on Linux machine with Xeon 2.53 GHz CPU and 48GB RAM</p>
    <p>Final circuits mapped into mcnc.genlib libr ary</p>
  </div>
  <div class="page">
    <p>Experimental Results  Comparison on decoder generation time</p>
    <p>circuit</p>
    <p>[14]* Decosy area ratio</p>
    <p>delay ratioarea/delay time area/delay time</p>
    <p>XGXS 269/7.4 1.23 286/7.3 0.08 1.06 0.99</p>
    <p>XFI 5697/14.4 492.58 3978/14.3 4.02 0.70 0.99</p>
    <p>Scrambler 736/3.8 1.88 640/3.8 0.25 0.87 1</p>
    <p>PCIE 171/5.8 1.04 190/6.6 0.08 1.11 1.14</p>
    <p>T2Ethernet 299/7.5 22.67 583/9.0 1.47 1.95 1.20</p>
    <p>HM(7,4) 255/7.3 0.12 255/7.3 0.08 1 1</p>
    <p>HM(15,11) 4232/13.8 56.82 3279/13.2 1.33 0.77 0.96</p>
    <p>*Prior work [14] implemented in OCaml.</p>
  </div>
  <div class="page">
    <p>Experimental Results  Comparison on decoder existence checking and</p>
    <p>decoder generation</p>
    <p>circuit</p>
    <p>[15]* Decosy area ratio</p>
    <p>delay Ratioarea/delay time area/delay time</p>
    <p>XGXS 293/7.5 2.70 295/7.1 0.10 1.01 0.95</p>
    <p>XFI 5697/14.4 1144.32 3913/12.5 7.52 0.69 0.87</p>
    <p>Scrambler 736/3.8 10.46 640/3.8 0.50 0.87 1</p>
    <p>PCIE 163/6.1 3.91 190/6.6 0.14 1.17 1.08</p>
    <p>T2Ethernet 269/6.9 113.89 526/9.7 12.38 1.96 1.41</p>
    <p>HM(7,4) 255/7.3 0.12 255/7.3 0.08 1 1</p>
    <p>HM(15,11) 4232/13.8 56.92 3279/13.2 1.94 0.77 0.96</p>
    <p>*Prior work [14] implemented in OCaml.</p>
  </div>
  <div class="page">
    <p>Experimental Results  Comparison on decoder inexistence checking</p>
    <p>circuit (w/o decoder) [15]*</p>
    <p>time (s) Decosy time (s)</p>
    <p>XGXS_err 2.17 0.01</p>
    <p>XFI_err 39.71 0.01</p>
    <p>Scrambler_err 3.96 0.08</p>
    <p>PCIE_err 2.94 0.01</p>
    <p>T2Ethernet_err 128.73 0.04</p>
    <p>HM(7,4)_err 1.35 0.01</p>
    <p>HM(15,11)_err 23.25 0.39</p>
    <p>AD &gt;6000 0.01</p>
    <p>*Prior work [14] implemented in OCaml.</p>
  </div>
  <div class="page">
    <p>Conclusions  We presented a sound and complete approach to</p>
    <p>decoder synthesis</p>
    <p>An effective incremental SAT solving solution was proposed for decoder existence checking</p>
    <p>Craig interpolation was used for effective decoder generation</p>
    <p>Experiments showed robust and fast computation (with synthesis quality comparable to prior work)</p>
  </div>
  <div class="page">
    <p>Thank You for Your Attention  Questions?</p>
  </div>
</Presentation>
