<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Unraveling Unstructured Process Models</p>
    <p>Marlon Dumas</p>
    <p>University of Tartu, Estonia</p>
    <p>Joint work with Artem Polyvyanyy and Luciano Garca-Bauelos</p>
    <p>Invited Talk, BPMN2010 Workshop, Potsdam, 14 Oct. 2010</p>
  </div>
  <div class="page">
    <p>Poll: Which desk do you prefer?</p>
  </div>
  <div class="page">
    <p>Poll: Which model do you prefer?</p>
  </div>
  <div class="page">
    <p>The Problem</p>
    <p>Sometimes, structured is preferable  Easier to understand</p>
    <p>Easier to analyze</p>
    <p>Easier to automatically layout</p>
    <p>Easier to abstract (zoom-out)</p>
    <p>But not all models are structured  often for a good reason!</p>
    <p>We know not all models can be structured</p>
    <p>Which ones can, which ones cant? 4</p>
  </div>
  <div class="page">
    <p>Analysis of Structured Models</p>
    <p>CTparallel = Max{T1, T2,, TM}</p>
    <p>CT = p1T1+p2T2++pmTm=</p>
    <p>m</p>
    <p>CT = T/(1-r)</p>
    <p>CT = T1+T2++ Tm</p>
    <p>Laguna &amp; Marklund (2005): Business Process Modeling, Simulation and Design</p>
  </div>
  <div class="page">
    <p>Automated Layout and Abstraction</p>
  </div>
  <div class="page">
    <p>A Bit of History</p>
  </div>
  <div class="page">
    <p>Everything can be structured if you accept to break and continue</p>
    <p>Everyone forgot to release their implementation (they were ashamed since it was full of GOTOs)</p>
  </div>
  <div class="page">
    <p>diagram, except:  Incorrect ones  Cycles with multiple exit points  Z-structures  Inclusive join gateways, complex</p>
    <p>gateways and other demons</p>
    <p>Try it out: http://sep.cs.ut.ee/Main/bpstruct 9</p>
  </div>
  <div class="page">
    <p>Corollary (if you care)</p>
    <p>Any (sound) BPMN model can be transformed into an equivalent (readable) BPEL process definition</p>
    <p>If BPEL had break/continue statements or we use boolean variables to simulate break/continue statememts  And the BPMN model does not have inclusive join gateways, complex gateways and other demons  And some other minor details not worth mentioning</p>
  </div>
  <div class="page">
    <p>Behavioral Equivalence</p>
    <p>Preserves the level of concurrency in a process model</p>
    <p>Sequential simulation of a process model</p>
    <p>Fully concurrent bisimilar (FCB)</p>
    <p>Weakly bisimilar Weakly</p>
    <p>bisimilar</p>
    <p>Sequential simulation of a process model</p>
  </div>
  <div class="page">
    <p>Starting Point  Process Structure Tree</p>
  </div>
  <div class="page">
    <p>Taxonomy of Process Fragments</p>
    <p>Trivials, polygons, and bonds are structured fragments  Rigids are unstructured</p>
  </div>
  <div class="page">
    <p>Homogeneous XOR Rigid</p>
  </div>
  <div class="page">
    <p>Homogeneous AND Rigid</p>
  </div>
  <div class="page">
    <p>Block-structured version</p>
  </div>
  <div class="page">
    <p>Homogeneous AND Rigid that cannot be structured</p>
    <p>Causal rules:  {A, B}  { C }  { B }  { D }</p>
    <p>Overlap on the left-hand side of the rules</p>
  </div>
  <div class="page">
    <p>Compare to this</p>
    <p>Causal relations  {A, B}  {C, D}</p>
  </div>
  <div class="page">
    <p>Heterogeneous Acyclic Rigid</p>
  </div>
  <div class="page">
    <p>Equivalent Structured Fragment</p>
  </div>
  <div class="page">
    <p>The Key Ingredient: Unfoldings</p>
    <p>An unfolding is a representation of a net without merge points</p>
    <p>A complete prefix unfolding is a finite initial part of the unfolding that contains full information about the reachable states</p>
  </div>
  <div class="page">
    <p>Ordering Relations</p>
    <p>Two transitions of an occurrence net are in one of the following relations:  A and B are in causal relation (A&gt;B), iff there exists a path from A to B  A and B are in conflict (A#B), iff there are two transitions t1, t2 that share an</p>
    <p>input place and there is a path from t1 to A and a path from t2 to B</p>
    <p>A and B are in concurrency (A||B) relation iff A and B are neither in causal, nor in conflict relation</p>
    <p>A&gt;C1</p>
    <p>B&gt;D2</p>
    <p>B#A A#D2</p>
    <p>C2||D2</p>
    <p>D2||C2</p>
  </div>
  <div class="page">
    <p>FCB and Ordering Relations Two process models are FCB-equivalent</p>
    <p>if and only if, (complete prefix) unfoldings of both models expose same ordering relations</p>
  </div>
  <div class="page">
    <p>Structuring Process Models Compute ordering relations</p>
    <p>of the (unstructured) process model</p>
    <p>Construct a block-structured process model from ordering</p>
    <p>relations</p>
  </div>
  <div class="page">
    <p>Ordering Relations Graph</p>
    <p>An ordering relations graph</p>
  </div>
  <div class="page">
    <p>Modular Decomposition Tree (MDT)</p>
    <p>The MDT is unique and can be computed in linear time</p>
    <p>The MDT</p>
    <p>A linear (L) module is a total order on a set of nodes of a graph  A complete (C) module is a complete graph, or a clique  A primitive (P) module is neither trivial, nor linear, nor complete</p>
    <p>A module is a set of edges with uniform structure</p>
  </div>
  <div class="page">
    <p>Structuring Acyclic Process Models</p>
    <p>A primitive module</p>
    <p>Let G be an ordering relations graph. The MDT of G has no primitive module, iff there exists a well-structured process model W such that G is the ordering relations graph of W.</p>
  </div>
  <div class="page">
    <p>Heterogeneous Cyclic Rigid</p>
  </div>
  <div class="page">
    <p>For further details</p>
    <p>Download and try:</p>
    <p>http://sep.cs.ut.ee/Main/bpstruct</p>
    <p>http://code.google.com/p/bpstruct/</p>
    <p>Perspectives:</p>
    <p>Analyze</p>
    <p>Decompose (e.g. for distributed execution)</p>
    <p>Refactor (extract duplicate fragments into subprocesses)</p>
    <p>Visualize</p>
  </div>
</Presentation>
