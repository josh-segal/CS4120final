<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Verifying Safety of a Token Coherence</p>
    <p>Implementation by Compositional Parametric</p>
    <p>Refinement</p>
    <p>Sebastian Burckhardt Rajeev Alur</p>
    <p>Milo M.K. Martin</p>
    <p>University of Pennsylvania</p>
  </div>
  <div class="page">
    <p>- 2</p>
    <p>Verifying Token Coherence</p>
    <p>Token Coherence is a novel approach for multiprocessor memory systems that reconciles the diverging requirements of</p>
    <p>performance / cost / verifiability</p>
  </div>
  <div class="page">
    <p>- 3</p>
    <p>Verifying Token Coherence</p>
    <p>Token Coherence is a novel approach for multiprocessor memory systems that reconciles the diverging requirements of</p>
    <p>performance / cost / verifiability  We develop a compositional method for verifying</p>
    <p>Token Coherence Safety and apply it to a detailed implementation  we found 7 bugs  we demonstrate scalability of the method</p>
  </div>
  <div class="page">
    <p>- 4</p>
    <p>Related Work</p>
    <p>K. L. McMillan. A compositional rule for hardware design refinement  compositional assume-guarantee refinement rules for</p>
    <p>synchronous process model</p>
    <p>M. M. K. Martin. Token Coherence.  Our abstract protocol resembles work by</p>
    <p>G. Delzanno (state multisets for parametric cache coherence verification)</p>
    <p>Arvind and X. W. Shen (term rewriting for functional hardware specifications)</p>
    <p>G. Berry and G. Boudol (chemical abstract machine)</p>
  </div>
  <div class="page">
    <p>- 5</p>
    <p>Background: Shared-Memory Multiprocessor</p>
    <p>Processors access the same memory (reads and writes to memory addresses)</p>
    <p>Processor Processor Processor</p>
    <p>Memory Location 2</p>
    <p>Memory Location 1</p>
    <p>Memory Location 3</p>
    <p>Coherent Memory System</p>
  </div>
  <div class="page">
    <p>- 6</p>
    <p>Coherent Memory</p>
    <p>Message-passing interconnection network  Processors cache local copies as needed  Coherence Protocol prevents access to stale copies</p>
    <p>Processor Processor Processor</p>
    <p>Cache CacheCache</p>
    <p>Directory + Memory</p>
    <p>Directory + Memory</p>
    <p>Directory + Memory</p>
    <p>Interconnection Network</p>
  </div>
  <div class="page">
    <p>- 7</p>
    <p>Example: Coherence by Single Writer, Multiple Reader</p>
    <p>C CC</p>
    <p>D</p>
    <p>N</p>
    <p>P1 P2 P3</p>
    <p>wants to access and modify the</p>
    <p>block</p>
    <p>wants to access and modify the</p>
    <p>block</p>
    <p>have readonly copies</p>
  </div>
  <div class="page">
    <p>- 8</p>
    <p>Example: Coherence by Single Writer, Multiple Reader</p>
    <p>C CC</p>
    <p>D</p>
    <p>N</p>
    <p>P1 P2 P3</p>
    <p>wants to access and modify the</p>
    <p>block</p>
  </div>
  <div class="page">
    <p>- 9</p>
    <p>Example: Coherence by Single Writer, Multiple Reader</p>
    <p>C CC</p>
    <p>D</p>
    <p>N</p>
    <p>P1 P2 P3</p>
    <p>has exclusive copy  can safely write</p>
  </div>
  <div class="page">
    <p>- 10</p>
    <p>Performance, Cost, and Complexity</p>
    <p>PerformancePerformance: prefer direct communication to centralized directory (lower cache-to-cache latency)</p>
    <p>CostCost: prefer unordered interconnect (e.g. mesh topology)</p>
    <p>But this creates complexitycomplexity, i.e. its hard to design a protocol that is correct and fast.  races need arbitration  unordered, asynchronous broadcast creates unreliable</p>
    <p>snapshots of the system state</p>
  </div>
  <div class="page">
    <p>- 11</p>
    <p>Performance, Cost, and Complexity  Token Coherence</p>
    <p>PerformancePerformance: direct communication   CostCost: unordered interconnect   ComplexityComplexity:</p>
    <p>use token counting to guarantee safety.  there is a fixed number of tokens per cache block  require one token to read, all tokens to write</p>
    <p>use timeouts to guarantee liveness.  after timeout, use slower, but reliable mechanism</p>
  </div>
  <div class="page">
    <p>- 12</p>
    <p>Performance, Cost, and Complexity  Token Coherence</p>
    <p>PerformancePerformance: direct communication   CostCost: unordered interconnect   ComplexityComplexity:</p>
    <p>use token counting to guarantee safety.  there is a fixed number of tokens per cache block  require one token to read, all tokens to write</p>
    <p>use timeouts to guarantee liveness.  after timeout, use slower, but reliable mechanism</p>
    <p>allows scalable formal</p>
    <p>verification</p>
  </div>
  <div class="page">
    <p>- 13</p>
    <p>Tokens help to verify safety  Our method is scalable because</p>
    <p>its compositional --- each component is modelchecked individually</p>
    <p>its parametric --- safety is proved for an arbitrary number of caches</p>
    <p>How do we achieve that?</p>
  </div>
  <div class="page">
    <p>- 14</p>
    <p>Tokens help to verify safety  Our verification method is scalable because</p>
    <p>its compositional --- each implementation component is model-checked individually</p>
    <p>its parametric --- safety is proved for an arbitrary number of caches</p>
    <p>How do we achieve that?  we develop a formal model, the abstract token protocol</p>
    <p>and prove that it is coherent  we check refinement of this abstract protocol in a</p>
    <p>compositional and inductive manner.</p>
  </div>
  <div class="page">
    <p>- 15</p>
    <p>Token counting rules (these are the original rules)</p>
    <p>Basic Rules  Fixed number of tokens per cache block  Require at least one token for read access.  Require all tokens for write access.</p>
    <p>Extended (MOESI) Rules  One of the tokens is owner token  Owner token can be clean or dirty</p>
    <p>dirty owner token indicates that writeback is needed</p>
    <p>C D</p>
  </div>
  <div class="page">
    <p>- 16</p>
    <p>We take it one step further:</p>
    <p>Abstract Token Protocol  Model single cache block only</p>
    <p>This is sufficient because the memory system is not required to be sequentially consistent. The only requirement is coherence.</p>
    <p>Express all relevant state as tokens  use token to represent data value  use token to represent the memory value</p>
    <p>Express state of components as a token bag (multiset)</p>
    <p>v</p>
    <p>v</p>
    <p>v</p>
    <p>D</p>
  </div>
  <div class="page">
    <p>- 17</p>
    <p>Sebastia n Burckh ardtSystem components and messages are</p>
    <p>abstractly modeled as token bags</p>
    <p>Bags can split (= send a message)</p>
    <p>Bags can fuse (= receive a message)</p>
    <p>Bags can perform local reactions</p>
    <p>Token Transition System</p>
  </div>
  <div class="page">
    <p>- 18</p>
    <p>Rules for a 3-token system</p>
    <p>Tokens :Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>Rewrite Rules:Rewrite Rules:</p>
    <p>Read v</p>
    <p>Write w</p>
    <p>Memread</p>
    <p>Memwrite</p>
    <p>Copy</p>
    <p>Drop</p>
    <p>Invariants:Invariants:</p>
    <p>- must have in same bag</p>
    <p>- must have in same bagD v</p>
    <p>v</p>
    <p>v v</p>
    <p>v wC/D D</p>
    <p>vCv Cv</p>
    <p>w Dv Cw</p>
    <p>v v v</p>
    <p>v</p>
  </div>
  <div class="page">
    <p>- 19</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C v1</p>
  </div>
  <div class="page">
    <p>- 20</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C v1</p>
    <p>wants to read</p>
  </div>
  <div class="page">
    <p>- 21</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C v1</p>
    <p>wants to read</p>
    <p>v1</p>
  </div>
  <div class="page">
    <p>- 22</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C v1</p>
    <p>wants to read</p>
    <p>v1</p>
  </div>
  <div class="page">
    <p>- 23</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C v1</p>
    <p>wants to read</p>
    <p>v1</p>
  </div>
  <div class="page">
    <p>- 24</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C v1</p>
    <p>wants to read</p>
    <p>v1</p>
  </div>
  <div class="page">
    <p>- 25</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C v1</p>
    <p>reads v1</p>
    <p>v1</p>
  </div>
  <div class="page">
    <p>- 26</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C v1</p>
    <p>v1</p>
    <p>wants to read</p>
  </div>
  <div class="page">
    <p>- 27</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C v1</p>
    <p>v1</p>
    <p>wants to read</p>
    <p>v1</p>
  </div>
  <div class="page">
    <p>- 28</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C v1</p>
    <p>v1</p>
    <p>wants to read</p>
    <p>v1</p>
  </div>
  <div class="page">
    <p>- 29</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C v1</p>
    <p>v1</p>
    <p>wants to read</p>
    <p>v1</p>
  </div>
  <div class="page">
    <p>- 30</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C v1</p>
    <p>v1</p>
    <p>wants to read</p>
    <p>v1</p>
  </div>
  <div class="page">
    <p>- 31</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C v1</p>
    <p>v1</p>
    <p>reads v1v1</p>
  </div>
  <div class="page">
    <p>- 32</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C v1</p>
    <p>v1</p>
    <p>v1</p>
  </div>
  <div class="page">
    <p>- 33</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C v1</p>
    <p>v1</p>
    <p>wants to</p>
    <p>modify</p>
    <p>v1</p>
  </div>
  <div class="page">
    <p>- 34</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C v1</p>
    <p>wants to</p>
    <p>modify</p>
    <p>v1</p>
  </div>
  <div class="page">
    <p>- 35</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>vC</p>
    <p>v1</p>
    <p>wants to</p>
    <p>modify</p>
    <p>v1</p>
  </div>
  <div class="page">
    <p>- 36</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C</p>
    <p>v1</p>
    <p>wants to</p>
    <p>modify</p>
    <p>v1</p>
  </div>
  <div class="page">
    <p>- 37</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C</p>
    <p>v1</p>
    <p>wants to</p>
    <p>modify</p>
    <p>v1</p>
  </div>
  <div class="page">
    <p>- 38</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C</p>
    <p>v1</p>
    <p>can now modify:</p>
    <p>adds 1</p>
    <p>v1</p>
  </div>
  <div class="page">
    <p>- 39</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>D</p>
    <p>v1</p>
    <p>v2</p>
    <p>wants to</p>
    <p>modify</p>
  </div>
  <div class="page">
    <p>- 40</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>D</p>
    <p>v1</p>
    <p>v2</p>
    <p>wants to</p>
    <p>modify</p>
  </div>
  <div class="page">
    <p>- 41</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>v1</p>
    <p>wants to</p>
    <p>modify</p>
    <p>D</p>
    <p>v2</p>
  </div>
  <div class="page">
    <p>- 42</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>v1</p>
    <p>D</p>
    <p>v2</p>
    <p>wants to</p>
    <p>modify</p>
  </div>
  <div class="page">
    <p>- 43</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>v1</p>
    <p>can now</p>
    <p>modify</p>
    <p>D v2</p>
  </div>
  <div class="page">
    <p>- 44</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>v1</p>
    <p>modifies</p>
    <p>D v3</p>
  </div>
  <div class="page">
    <p>- 45</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>D</p>
    <p>v1</p>
    <p>v3</p>
    <p>wants to evict</p>
  </div>
  <div class="page">
    <p>- 46</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>D</p>
    <p>v1</p>
    <p>v3</p>
  </div>
  <div class="page">
    <p>- 47</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>D</p>
    <p>v1</p>
    <p>v3</p>
  </div>
  <div class="page">
    <p>- 48</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v D</p>
    <p>v1</p>
    <p>v3</p>
  </div>
  <div class="page">
    <p>- 49</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v D</p>
    <p>v1</p>
    <p>v3</p>
  </div>
  <div class="page">
    <p>- 50</p>
    <p>Abstract Token Protocol: Example</p>
    <p>Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>C v3</p>
  </div>
  <div class="page">
    <p>- 51</p>
    <p>Rules for a 3-token system</p>
    <p>Tokens :Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>Rewrite Rules:Rewrite Rules:</p>
    <p>Read v</p>
    <p>Write w</p>
    <p>Memread</p>
    <p>Memwrite</p>
    <p>Copy</p>
    <p>Drop</p>
    <p>Invariants:Invariants:</p>
    <p>- must have in same bag</p>
    <p>- must have in same bagD v</p>
    <p>v</p>
    <p>v v</p>
    <p>v wC/D D</p>
    <p>vCv Cv</p>
    <p>w Dv Cw</p>
    <p>v v v</p>
    <p>v</p>
  </div>
  <div class="page">
    <p>- 52</p>
    <p>Rules for a 3-token system</p>
    <p>Tokens :Tokens :</p>
    <p>Regular Token</p>
    <p>Clean Owner Token</p>
    <p>Dirty Owner Token</p>
    <p>Data Token</p>
    <p>Memory Token</p>
    <p>C</p>
    <p>D</p>
    <p>v</p>
    <p>v</p>
    <p>Rewrite Rules:Rewrite Rules:</p>
    <p>Read v</p>
    <p>Write w</p>
    <p>Memread</p>
    <p>Memwrite</p>
    <p>Copy</p>
    <p>Drop</p>
    <p>Invariants:Invariants:</p>
    <p>- must have in same bag</p>
    <p>- must have in same bagD v</p>
    <p>v</p>
    <p>v v</p>
    <p>v wC/D D</p>
    <p>vCv Cv</p>
    <p>w Dv Cw</p>
    <p>v v v</p>
    <p>v</p>
    <p>We prove by hand that the abstract token</p>
    <p>protocol is coherent.</p>
    <p>The proof is quite simple because</p>
    <p>token bags (multisets) are intuitive to reason about.</p>
  </div>
  <div class="page">
    <p>- 53</p>
    <p>Whats next</p>
    <p>Formal spec of abstract token protocol   Multisets  Rewrite rules</p>
    <p>Abstract token protocol is coherent   Direct proof by hand</p>
    <p>Next: we take an actual implementation and do a compositional parametric refinement verification.</p>
  </div>
  <div class="page">
    <p>- 54</p>
    <p>The implementation...  is fairly low-level</p>
    <p>its not just about tokens  it contains many microarchitectural details, as it was used for performance simulations</p>
    <p>it includes the secondary (liveness) protocol</p>
    <p>is too big to be efficiently verifiable by purely manual methods</p>
    <p>is coded in SLICC  specification language for implementing cache</p>
    <p>coherence  generates html-formatted overview tables</p>
  </div>
  <div class="page">
    <p>- 55</p>
    <p>This is the overview table for the cache controller, generated from the SLICC code by the SLICC compiler.</p>
  </div>
  <div class="page">
    <p>- 56</p>
    <p>State</p>
    <p>Trigger</p>
    <p>Successor State</p>
    <p>Action Sequence</p>
    <p>Considered Unreachabl</p>
    <p>e</p>
  </div>
  <div class="page">
    <p>- 57</p>
    <p>SLICC code specifies action sequences to execute for a given state &amp; trigger: transition(NP, Ifetch, IS) { pp_allocateL1ICacheBlock; i_allocateTBE; a_issueRequest; uu_profileMiss; k_popMandatoryQueue; }</p>
    <p>SLICC code defines each action: action(d_sendDataWithAllTokens, &quot;d&quot;) { peek(requestNetwork_in, RequestMsg) { enqueue(responseNetwork_out, ResponseMsg) { out_msg.Address := address; out_msg.Type := DATA_OWNER; out_msg.Sender := id; out_msg.SenderMachine := MachineType:Directory; out_msg.Destination.add(in_msg.Requestor); out_msg.DestMachine := MachineType:L1Cache; assert(directory[address].Tokens &gt; 0); out_msg.Tokens := directory[in_msg.Address].Tokens; out_msg.DataBlk := directory[in_msg.Address].DataBlk; out_msg.Dirty := false; out_msg.MessageSize := MessageSizeType:Response_Data; directory[address].Tokens := 0; }</p>
  </div>
  <div class="page">
    <p>- 58</p>
    <p>Why we need compositionality</p>
    <p>Verifying refinement of the entire system is beyond the practical limit of model checking  too many states for explicit model checker  BDDs too complex for symbolic model checker</p>
    <p>refines</p>
    <p>C 3</p>
    <p>C CC</p>
    <p>D N</p>
    <p>P1 P2 P3</p>
  </div>
  <div class="page">
    <p>- 59</p>
    <p>Verify components individually</p>
    <p>refinesC D</p>
    <p>D refines C</p>
    <p>N refines</p>
  </div>
  <div class="page">
    <p>- 60</p>
    <p>But... there are some issues</p>
    <p>Components make assumptions on the context  if the context does not preserve token numbers,</p>
    <p>the implementation is not required to refine the specification.</p>
    <p>Solution: define contextual refinement</p>
  </div>
  <div class="page">
    <p>- 61</p>
    <p>Contextual Refinement</p>
    <p>Say: Q is specification, P is implementation</p>
    <p>classic refinement: P  Q means any behavior of P is a possible behavior of Q</p>
    <p>contextual refinement: P C Q means any behavior that P can exhibit in context C is a behavior that Q can exhibit in context C</p>
  </div>
  <div class="page">
    <p>- 62</p>
    <p>Compositional Proof</p>
    <p>If each system component refines the abstract protocol T in context T:</p>
    <p>C T T and D T T and N T T</p>
    <p>then the entire system refines the abstract protocol:</p>
    <p>C | C | C ... | C | N | D  T</p>
    <p>Proof:  uses assume-guarantee proof rules inductively  exploits the deep symmetries of abstract protocol T</p>
  </div>
  <div class="page">
    <p>- 63</p>
    <p>Formalism (read the paper for more detail on this.)</p>
    <p>a process model based on finite traces  process = set of traces  interleaved concurrency  synchronous communication (CCS-style)</p>
    <p>contextual refinement  we use a direct definition for this process model  can handle open and closed refinement</p>
    <p>assume-guarantee proof rules  can be applied inductively  allow us to use context abstraction</p>
  </div>
  <div class="page">
    <p>- 64</p>
    <p>Visualization: Abstracting the context</p>
    <p>C</p>
    <p>C</p>
    <p>messages and nodes look alike  abstract protocol is self-similar: T | T | ... | T = T</p>
    <p>means that context can be modeled as single bag</p>
  </div>
  <div class="page">
    <p>- 65</p>
    <p>Whats next?</p>
    <p>We discharge the local obligations</p>
    <p>C T T D T T N T T</p>
    <p>by model checking the implementation</p>
  </div>
  <div class="page">
    <p>- 66</p>
    <p>Model checking in Murphi  Do translation &amp; abstraction of SLICC</p>
    <p>remove non-relevant state  introduces non-determinism  done by hand</p>
    <p>Model the abstract token coherence  Model is used both for spec. and context  use finite representations of bags</p>
    <p>Need correspondence between impl. and spec.  We use annotations to guide the model checker</p>
    <p>(eliminates existential quantifier from refinement problem)</p>
  </div>
  <div class="page">
    <p>- 67</p>
    <p>Found 7 bugs  Some debug-only code was not</p>
    <p>properly marked as such  In four instances, state was updated incorrectly</p>
    <p>for the case where the last token was sent  was not hit by sim because the ratio tokens vs. nodes was large</p>
    <p>in all sim configurations</p>
    <p>Dirty bit was updated too often  causes superfluous writebacks  is a performance bug  would not have been found had we checked for coherence only,</p>
    <p>rather than the stronger refinement obligation</p>
    <p>Once the above were fixed, the dirty bit was no longer updated often enough</p>
  </div>
  <div class="page">
    <p>- 68</p>
    <p>Results</p>
    <p>Found 7 bugs  note that implementation had been subjected to</p>
    <p>extensive simulation</p>
    <p>Model checking was very resource-efficient  well within reach of Murphi, with room to spare  indicates that the method scales to lower-level</p>
    <p>implementations</p>
  </div>
  <div class="page">
    <p>- 69</p>
    <p>Contributions</p>
    <p>We perform a formal verification of a systemlevel implementation of token coherence</p>
    <p>We present a general, formal specification of the safety substrate of token coherence</p>
    <p>We demonstrate that the token abstraction makes the verification more scalable</p>
  </div>
  <div class="page">
    <p>- 70</p>
    <p>Future Work</p>
    <p>We would like to verify liveness.  not a priori clear if same framework is beneficial.</p>
    <p>We would like to apply token formalisms to other protocols.  try to retrofit on existing protocols (e.g. define</p>
    <p>virtual tokens)</p>
    <p>We would like to automate the procedure.  Translation seems automatable  Apply algorithms for rewrite logic  Eliminate or reduce annotations</p>
  </div>
  <div class="page">
    <p>- 71</p>
    <p>Visit my homepage for  an extended version of the paper  this presentation in ppt format  additional resources (e.g. SLICC code)</p>
    <p>Thank you for your attention. C</p>
    <p>v1</p>
    <p>v1</p>
  </div>
</Presentation>
