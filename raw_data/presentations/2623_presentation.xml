<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>NETWORK CONFIGURATION IS HARD!</p>
    <p>High-level tasks are realized through low-level commands and scripts: hard to understand</p>
    <p>Distributed configura&lt;on: hard to manage</p>
    <p>Variety of network-wide tasks cause changes to the network: lots of dynamics</p>
    <p>No changes are checked for correctness: error-prone</p>
  </div>
  <div class="page">
    <p>SURVEY WITH NETWORK OPERATORS</p>
  </div>
  <div class="page">
    <p>SURVEY WITH NETWORK OPERATORS</p>
    <p>You should track down those 10-20% of operators who say they are always certain. They are LYING.</p>
  </div>
  <div class="page">
    <p>MOTIVATING EXAMPLE: THE START SYSTEM</p>
    <p>VLAN mapper</p>
  </div>
  <div class="page">
    <p>MOTIVATING EXAMPLE: THE START SYSTEM</p>
    <p>- Network events - Changes in forwarding behavior</p>
    <p>VLAN mapper - Ad hoc scripts</p>
    <p>- Configura&lt;on and changes are distributed - Too complex!</p>
  </div>
  <div class="page">
    <p>SOFTWARE-DEFINED NETWORKING</p>
    <p>Embedded control logic</p>
    <p>Embedded control logic</p>
    <p>Embedded control logic</p>
    <p>So_ware w/ control logic</p>
    <p>Tradi&lt;onal network SDN</p>
  </div>
  <div class="page">
    <p>SDN IS NOT A SILVER BULLET</p>
    <p>Low-level commands &amp; scripts: hard to understand</p>
    <p>Distributed configura&lt;on: hard to manage</p>
    <p>Many network-wide tasks, lots of changes: lots of dynamics</p>
    <p>No correctness guarantee:</p>
    <p>error-prone</p>
    <p>Central control</p>
    <p>Programs: e.g., C++, Java, Python, Pyre&lt;c</p>
    <p>Unsolved</p>
    <p>Unsolved</p>
  </div>
  <div class="page">
    <p>WHAT SDN PLATFORM NEEDS</p>
    <p>Guidance on how to implement a network control program  How to provide dynamic control that handles arbitrary network events</p>
    <p>E.g, Intrusion detec&lt;on, traffic load shi_, etc</p>
    <p>Verifica&lt;on and guarantees of programs correctness  Huge missed opportuni&lt;es in so_ware</p>
  </div>
  <div class="page">
    <p>DIFFERENT TYPES OF NETWORK EVENTS</p>
    <p>Network traffic  Traffic load increase/decrease, security incidents</p>
    <p>User-specific  User authen&lt;ca&lt;on, excessive data usage</p>
    <p>Data-plane events  Topology change, switch/link failures</p>
    <p>9</p>
  </div>
  <div class="page">
    <p>DIFFERENT REACTIONS TO AN EVENT</p>
    <p>Host is infected!</p>
    <p>Only block that infected host</p>
    <p>Block all communica&lt;ons in the network!</p>
    <p>Direct communica&lt;on to our internal honeypot</p>
    <p>Event Operators Reac&lt;on</p>
  </div>
  <div class="page">
    <p>INSIGHT</p>
    <p>Network events and dynamic reacVons to them should be programmaVcally encoded in the network control program by operators</p>
  </div>
  <div class="page">
    <p>DYNAMIC NETWORK CONTROL PROGRAM</p>
    <p>SoWware program that embeds event  reac&lt;on rela&lt;onships</p>
    <p>So_ware program</p>
    <p>Network events</p>
    <p>policy update</p>
    <p>rule update</p>
    <p>Data Plane</p>
    <p>Control Plane</p>
  </div>
  <div class="page">
    <p>UNANSWERED QUESTIONS</p>
    <p>How to embed event-reacVon logic in so_ware?</p>
    <p>How to verify that the program will make changes correctly?</p>
    <p>KineVc tackles these quesVons</p>
  </div>
  <div class="page">
    <p>KINETIC</p>
    <p>Domain specific language and control plalorm</p>
    <p>Helps create SDN control programs that embed custom event-reacVon rela&lt;onships</p>
    <p>Verifies programs correctness</p>
  </div>
  <div class="page">
    <p>OUR APPROACH</p>
    <p>Domain specific language  Constrained, but structured</p>
    <p>Express changing behavior as a finite state machine</p>
    <p>Verify programs correctness with a model checker (NuSMV)</p>
  </div>
  <div class="page">
    <p>KINETICS DOMAIN SPECIFIC LANGUAGE</p>
    <p>Embedded in Python  Borrows some abstrac&lt;ons from Pyre&lt;c  Encodes forwarding behavior in a policy variable</p>
    <p>New constructs and func&lt;ons to express policies that respond to changing condi1ons</p>
    <p>Policy variable</p>
    <p>Incoming packet</p>
    <p>Outgoing packet</p>
    <p>Policy variable 1</p>
    <p>Incoming packet</p>
    <p>Outgoing packet</p>
    <p>Policy variable 2</p>
    <p>Policy variable 3</p>
    <p>Policy variable 1</p>
    <p>Policy variable 2</p>
    <p>Policy variable 3</p>
    <p>Network event</p>
  </div>
  <div class="page">
    <p>IDS EXAMPLE IN KINETIC</p>
    <p>Event: infected  State: policy variables value  allow or block packet</p>
    <p>infected:False Policy:allow</p>
    <p>event(infected,True)</p>
    <p>event(infected,False)</p>
    <p>infected:True Policy:block</p>
    <p>There are many different flows Each flow can have its own independent FSM</p>
  </div>
  <div class="page">
    <p>DECOMPOSING TO MULTIPLE FSMS</p>
    <p>allow</p>
    <p>block</p>
    <p>FSM instance is instan&lt;ated per flow</p>
    <p>Host 1</p>
    <p>allow</p>
    <p>block</p>
    <p>Host 2</p>
    <p>allow</p>
    <p>block</p>
    <p>Host N</p>
    <p>Total # of states: 2N Total # of transi1ons: 2N # of hosts: N</p>
    <p>allow</p>
    <p>block</p>
    <p>Host 3</p>
    <p>+ + + +</p>
    <p>State representa&lt;on is Linear in N (instead of geometric)</p>
  </div>
  <div class="page">
    <p>LPEC: ABSTRACTION TO DEFINE A FLOW</p>
    <p>In IDS example, flow is defined by source IP address (host)</p>
    <p>Other policies may require more flexibility (e.g., need to group packets by loca&lt;on)</p>
    <p>Located Packet Equivalence Class (LPEC)  Programmer abstrac&lt;on to define flow</p>
    <p>def lpec(pkt): return match(ds&lt;p=pkt[ds&lt;p])</p>
  </div>
  <div class="page">
    <p>KINETIC VERIFICATION PROCESS</p>
    <p>Kine&lt;c verifies correctness of the program  User-specified temporal proper&lt;es  Verifies current and future forwarding behavior based on network events</p>
    <p>Verifica&lt;on process is automated  Constrained but structured language allows automa&lt;c parsing and transla&lt;on of program</p>
    <p>Verifica&lt;on runs before programs deployment 20</p>
  </div>
  <div class="page">
    <p>VERIFICATION PROCESS</p>
    <p>KineVc program</p>
    <p>infected:False, policy:identity,</p>
    <p>,,event(infected,True),</p>
    <p>,,event(infected,False),</p>
    <p>infected:True, policy:drop,</p>
    <p>Figure 4: Intrusion detection system FSM.</p>
    <p>same LPEC. E.g., a Kinetic programmer might specify a FSM that applies to packets from a generic host, between a generic host-pair, or passing through a generic switch. The programmer also supplies a LPEC generator: a function which given any packet returns the LPEC to which that packet belongs. With these two input, the Kinetic runtime can then automatically generate the full network policy.</p>
    <p>joint behavior (Figure 3a) across all variable values, Kinetic instead encodes a single generic FSM that can be applied to any given LPEC (e.g., host=X) (Figure 3b). How this actually reduces the number of states and how LPEC FSMs are combined with product automaton will be discussed in Section 5 in more detail. This LPEC FSM is then combined with the programmer-supplied LPEC generator that given a packet, will return the corresponding LPEC to which that packet belongs.</p>
    <p>The LPEC FSM contains:</p>
    <p>As events arrive, the LPEC FSM may transition between states, triggering the Pyretic runtime to re-compile the policy and push updated rules to network switches.</p>
    <p>trusion detection system that monitors each host in the network, and has been configured to send events notifying the network controller when a host infection has been detected, or a previously infected host has been cleaned. The job of the ids module on the controller is to block traffic to/from hosts that have been infected and allow traffic to previously infected hosts that have been cleaned.</p>
    <p>Figure 4 shows how the controller behaves with respect to a generic host that is encoded as a LPEC FSM. The ids LPEC FSM has two variables, infected and policy. infected is a boolean variable, corresponding to the most recent external event received about the host. policy can take either the value identity (allowing packets from the host) or drop (dropping packets from the host). Initially (bold border), hosts are not in</p>
    <p>i d e n t i t y }) , 15 i n i t = i d e n t i t y , 16 t r a n s = p o l i c y ) )</p>
    <p>Figure 5: Intrusion detection system code.</p>
    <p>fected and traffic is allowed. However, if an infected event is received, this LPEC FSM transitions to the second state in which the infected variable is True and the policy variable is drop. If at some later point, the intrusion detection system sends an event indicating the host in no longer infected, the LPEC FSM will transition back to the initial state, allowing traffic once again.</p>
    <p>LPEC FSM: Now we show how this FSM logic is expressed in Kinetic. Kinetic encodings are intended to automatically produce models that can be automatically checked using the NuSMV model checker (Section 6). Consequently, we have chosen to encode Kinetic LPEC FSMs in the fashion used by NuSMV. Instead of specifying states and transitions explicitly (mirroring Figure 4), NuSVM specifies the evolution of each variable as a function of the current state (which itself is implicitly defined as the current values of all FSM variables).</p>
    <p>Figure 5 provides a concrete example of the NuSMVstyle FSM encoding used by Kinetic. The logic encoded by the infected transition function (lines 1-3) contains a single case: when an external infected event occurs, the new value for infected variable in the FSM is the value of that event. In short, infected variables value is determined by the value of an external event with the same name. The policy transition function (lines 5-8) contains two cases. The first case (line 7) says that if the infected variable (denoted by V(variable name)) has the value True, then the policy variable will take the constant value drop (denoted by C(value to be taken)). The second default case (line 8) says that otherwise the policy variable will take the constant value identity.</p>
    <p>Of course, we need to ensure the Kinetic library associates these transition functions with the respective variables. Starting at line 10, the program assigns the value to</p>
    <p>NuSMV FSM model</p>
    <p>port:n, policy:fwd(n),</p>
    <p>TC:False, ,</p>
    <p>port:0, policy:flood,</p>
    <p>TC:True, ,</p>
    <p>port:0, policy:flood, TC:False,</p>
    <p>'</p>
    <p>event' (port,n)'</p>
    <p>event' (TC,True)'</p>
    <p>event(TC,False)'</p>
    <p>Figure 9: MAC Learner FSM.</p>
    <p>Each state variables type and possible values are described in line 24, and initial values are written in line 57. Transition relationship is shown in line 812 for policy variable and line 1316 for infected variable. The policy variable value transitions to drop if infected is True (line 10) while the default is identity (line 11). Line 15 means that the infected variable can be change between FALSE and TRUE independently (in reality, the value changes based on external event of the same name).</p>
    <p>netic, we describe three additional programs: a MAC learner, a stateful firewall, and a usage-based rate limiter, along with example verification properties. We have more programs, but omit the details (e.g., FSM and verifications) due to page constraints. All programs can be found in our public repository [22].</p>
    <p>switch) program in Kinetic to show its generality, and to demonstrate several built-in events in Kinetic. Figure 9 shows the Kinetic FSM for a MAC learner that responds to topology changes and packets coming from hosts. In this program, there are two different types of events: TC (or topo change) and port events. The TC event is not a custom event defined by the programmer, but a built-in event that is invoked automatically whenever there is a topology change. In Kinetic, programs can register and react to this built-in event. The port events are generated by a Pyretic query that collects the first packet seen for each (switch,srcmac) pair. This is a built-in event</p>
    <p>rate:Level_1' policy:No_delay'</p>
    <p>rate:Level_2' policy:100ms'delay'</p>
    <p>rate:Level_3' policy:400ms'delay'</p>
    <p>event, (rate,Level_2),</p>
    <p>event, (rate,Level_2),</p>
    <p>event, (rate,Level_3),</p>
    <p>event, (rate,Level_1),</p>
    <p>event, (rate,Level_1),</p>
    <p>event, (rate,Level_3),</p>
    <p>Figure 10: Data usage-based rate limiter FSM.</p>
    <p>as well. The values of policy is completely defined by that of port: flood when port is 0, fwd(n)2 when port=n.</p>
    <p>In the FSMs initial state (left-most), port is set to 0 (indicating the port has not yet been learned), and TC is False. When a (port,n) event arrives, which is invoked by the Pyretic runtime when it sees a packet from an unseen host, transition occurs, setting the port to the value learned and the policy to unicast out that port. Once the port has been learned, the MAC learner unicasts packets to learned hosts until a topology change occurs, triggering the transition to the right-most state in which TC is True. This is followed by a cascade transition back to the initial state by TC becoming False automatically.</p>
    <p>Table 2 presents four specifications about the MAC learner program that are verified by Kinetics model checker. Specifications are given in CTL along with descriptions. Kinetic verifies whether all specifications hold as true. If not, it will generate a counterexample with a sequence of events that leads to the falsification of the specification.</p>
    <p>complex, dynamic, and realistic. We found that a policy that enforces bandwidth caps (limiting network usage based on data consumption) is widely deployed in campus and enterprise networks. CMU campus networks Wired/Wireless network bandwidth usage guideline [10] is a good example of such policy, and we have found tens of more campuses that enforce a similar network policy. To enforce such policy on conventional networks, operators need to create customized scripts that interact with monitoring devices and multiple network switches. The same policy can be programmed using Kinetic in an efficient and concise manner.</p>
    <p>Figure 10 illustrates the Kinetic FSM for a usage-based rate limiter. The rate limiter program allows traffic between hosts with three different levels of forwarding rates: no delay, 100ms delay, and 400ms delay. In the default state, traffic is allowed with full bandwidth. When the Kinetic controller receives a dynamic event notifying that 2 fwd(n) is sugar for match(outport=n).</p>
    <p>Automa&lt;cally generates</p>
    <p>User-specified temporal properVes</p>
    <p>True or False (w/ counter-example)</p>
    <p>NuSMV Model Checker</p>
  </div>
  <div class="page">
    <p>EXAMPLES OF TEMPORAL PROPERTIES</p>
    <p>If a host is infected, drop packets from that host AG (infected  AX policy=drop)</p>
    <p>If host is authen&lt;cated either by Web or 802.1X, and is not infected, packets should never be dropped.</p>
    <p>AG ( (authen&lt;cated_web | authen&lt;cated_1x) &amp; !infected  AX policy!=drop )</p>
    <p>For all current and future states,</p>
    <p>For all possible transi&lt;ons from current state,</p>
    <p>For all possible transi&lt;ons from current state,</p>
    <p>For the next state,</p>
  </div>
  <div class="page">
    <p>EVALUATION</p>
    <p>Usability evalua&lt;on  User study against over 870 par&lt;cipants  Lines of code comparison with other SDN solu&lt;ons</p>
    <p>Performance and scalability  Event handling and policy recompila&lt;on</p>
  </div>
  <div class="page">
    <p>KINETIC: USER STUDY</p>
    <p>Demographic</p>
    <p>Task  Implement an enhanced IDS program with Kine&lt;c, Pyre&lt;c, and POX.</p>
    <p>Profession Experience (years) Operator 216 1 32</p>
    <p>Developer 251 1-5 310</p>
    <p>Student 123 5-10 187</p>
    <p>Vendor 80 10-15 150</p>
    <p>Manager 69 15-20 122</p>
    <p>Other 138 &gt; 20 73</p>
    <p>Total 877 874</p>
  </div>
  <div class="page">
    <p>RANK PLATFORMS BY PREFERENCE</p>
  </div>
  <div class="page">
    <p>LINES OF CODE COMPARISON</p>
    <p>Programs FL POX PyreVc KineVc IDS/firewall 416 22 46 17</p>
    <p>Mac learner 314 73 17 33</p>
    <p>Server load balance 951 145 34 37</p>
    <p>Stateful firewall None found None found</p>
    <p>Usage-based rate limiter None found None found None found 30</p>
  </div>
  <div class="page">
    <p>NOTABLE QUOTES</p>
    <p>Why did you like Kine&lt;c?  FSM-based structure and support for intuiVon</p>
    <p>More concise</p>
    <p>Kine1c is more intui1ve: the only things I need to do is to define the FSM variable</p>
    <p>intui1ve and easy to understand</p>
    <p>reduces the number of lines of code</p>
    <p>the logic is more concise</p>
    <p>Programming state transi1ons in FSMs makes much more sense</p>
  </div>
  <div class="page">
    <p>NOTABLE QUOTES</p>
    <p>Why didnt you like Kine&lt;c?  Steep learning curve</p>
    <p>Kine1c took less 1me and was actually more understandable [but] the structure was very cryp1c</p>
    <p>Not friendly when finding why program is wrong I spent a lot more 1me chasing down weird bugs I had because of things I leN out or perhaps didnt understand</p>
  </div>
  <div class="page">
    <p>Event handling and policy recompilaVon</p>
  </div>
  <div class="page">
    <p>KINETIC: REAL DEPLOYMENTS</p>
    <p>Campus network  Func&lt;onal access control system  Deployed SDN-enabled switches over 3 buildings</p>
    <p>Home network  Usage-based access control  Deployed 21 SDN-enabled wireless routers over 3 con&lt;nents</p>
    <p>Jul., 2012  Feb., 2014  Presented in ACM CHI 2015</p>
    <p>Registration Scanning</p>
    <p>Operation Quarantine</p>
    <p>Allow Capped</p>
  </div>
  <div class="page">
    <p>KINETIC TAKEAWAYS</p>
    <p>Domain specific language and control plalorm  Program encodes event-reacVon logic</p>
    <p>Extensive user study shows that  Much easier to express dynamics in the network  Helps to reduce lines of code</p>
    <p>Scales well to large networks and lots of events</p>
    <p>VerificaVon process reduces bugs in programs</p>
  </div>
  <div class="page">
    <p>DISCUSSION &amp; FUTURE WORK</p>
    <p>Combining with verifica&lt;ons in other stacks  Consistent updates to data plane  Verifica&lt;on of data-plane state</p>
    <p>More dynamic network policies  Should collect more real network policies  Need public repository</p>
  </div>
  <div class="page">
    <p>THANK YOU</p>
    <p>More about Kine&lt;c: h~p://kine&lt;c.noise.gatech.edu</p>
    <p>Contact:</p>
    <p>joonk@gatech.edu</p>
    <p>Ques&lt;ons?</p>
  </div>
</Presentation>
