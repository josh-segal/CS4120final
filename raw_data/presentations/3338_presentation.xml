<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research</p>
    <p>USENIX Security16, Austin, TX Aug 11, 2016</p>
    <p>Making USB Great Again with USBFILTER</p>
    <p>Dave Tian*, Nolen Scaife*, Adam Bates**, Kevin Butler*, Patrick Traynor* *University of Florida, Gainesville, FL</p>
    <p>**University of Illinois, Urbana-Champaign, IL</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 2</p>
    <p>Make it real</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 3</p>
    <p>Universal Serial Bus  USB 1.0/2.0/3.0/3.1/Type-C</p>
    <p>Speed  10 gigabits per second</p>
    <p>Ubiquitous</p>
    <p>Why USB was great</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 4</p>
    <p>Why USB is not great anymore</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 5</p>
    <p>USB enumeration Host Device</p>
    <p>SetAddress(n)</p>
    <p>ACK</p>
    <p>GetDescriptor(Device)</p>
    <p>MNF: Kingston, Product: Flash Drive</p>
    <p>GetDescriptor(Interface)</p>
    <p>Storage</p>
    <p>Human Interface</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 6</p>
    <p>USB device rules can stop attacks on hosts by identifying and dropping unwanted USB packets before they reach their destination in the host operating system.</p>
    <p>Implement and characterize performance: We demonstrate how USBFILTER imposes minimal overhead on USB traffic. As a result, our system is well-suited for protecting any USB workload.</p>
    <p>Demonstrate effectiveness in real-world scenarios: We explore how USBFILTER can be used to thwart attacks and provide security guarantees for benign devices. USBFILTER can pin devices (e.g., webcams) to approved programs (e.g., Skype, Hangouts) to prevent malicious software on a host from enabling or accessing protected devices.</p>
    <p>USBFILTER is different from previous works in this space because it enables the creation of rules that explicitly allow or deny functionality based on a wide range of features. GoodUSB [41] relies on the user to explicitly allow or deny specific functionality based on what the device reports, but cannot enforce that the behavior of a device matches what it reports. SELinux [35] policies and PinUP [13] provide mechanisms for pinning processes to filesystem objects, but USBFILTER expands this by allowing individual USB packets to be associated with processes. This not only allows our system to permit pinning devices to processes, but also individual interfaces of composite devices.</p>
    <p>Our policies can be applied to differentiate individual devices by identifiers presented during device enumeration. These identifiers, such as serial number, provide a stronger measure of identification than simple product and vendor codes. While not a strong authentication mechanism, USBFILTER is able to perform filtering without additional hardware. The granularity and extensibility of USBFILTER allows it to perform the functions of existing filters [41] while permitting much stronger control over USB devices.</p>
    <p>The remainder of this paper is structured as follows: In Section 2, we provide background on the USB protocol and explain why it is not great anymore; in Section 3, we discuss the security goals, design and implementation of our system; in Section 4, we discuss how USBFILTER meets our required security guarantees; in Section 5, we evaluate USBFILTER and discuss individual use cases; in Section 6, we provide additional discussion; in Section 7, we explore related work; and in Section 8, we conclude.</p>
    <p>A USB device refers to a USB transceiver, USB hub, host controller, or peripheral device such as a human-interface</p>
    <p>USB Device Interface 0 Interface 1 Interface 2</p>
    <p>In Out In InOut Out</p>
    <p>EP 0 EP 0 EP 1 EP1</p>
    <p>EP 0 EP 0 EP 0 EP 0 EP 1 EP 1 EP 1 EP 1 EP 2 EP 2EP 2 EP 2</p>
    <p>EP n EP n</p>
    <p>Figure 1: A detailed view of a generic USB device. Similar to a typical USB headset, this device has three interfaces and multiple endpoints.</p>
    <p>device (HID, e.g., keyboard and mouse), printer, or storage. However, the device may have multiple functions internally, known as interfaces. An example device with three interfaces is shown in Figure 1. USB devices with more than one interface are known as composite devices. For example, USB headsets often have at least three interfaces: the speaker, the microphone, and the volume control functionalities. Each interface is treated as an independent entity by the host controller. The operating system loads a separate device driver for each interface on the device.</p>
    <p>The USB protocol works in a master-slave fashion, where the host USB controller is responsible to poll the device both for requests and responses. When a USB device is attached to a host machine, the host USB controller queries the device to obtain the configurations of the device, and activates a single configuration supported by the device. For instance, when a smartphone is connected with a host machine via USB, users can choose it to be a storage or networking device. By parsing the current active configuration, the host operating system identifies all the interfaces contained in the configuration, and loads the corresponding device drivers for each interface. This whole procedure is called USB enumeration [10]. Once a USB device driver starts, it first parses the endpoints information embedded within this interface as shown in Figure 1.</p>
    <p>While the interface provides the basic information for the host operating system to load the driver, the endpoint is the communication unit when a driver talks with the USB device hardware. Per specification, the endpoint 0 (EP0) should be supported by default, enabling Control (packet) transfer from a host to a device to further probe the device, prepare for data transmission, and check for errors. All other endpoints can be optional though there is usually at least EP1, providing Isochronous, Interrupt, or Bulk (packet) transfers, which are used by audio/video, keyboard/mouse, and storage/networking devices respectively. All endpoints are grouped into either In pipes, where transfers are from the device to the host,</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 7</p>
    <p>USB packet</p>
    <p>USB_packet(key)</p>
    <p>USB_packet(data)</p>
    <p>USB_packet(key)</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 8</p>
    <p>USBFILTER</p>
    <p>Rule DB</p>
    <p>USBFILTER</p>
    <p>App1 App2 App3</p>
    <p>keyboard storage</p>
    <p>headset cameramouse</p>
    <p>wireless</p>
    <p>Kernel Space</p>
    <p>User Space I/O operation</p>
    <p>USB packet</p>
    <p>Figure 2: USBFILTER implements a USB-layer reference monitor within the kernel, by filtering USB packets to different USB devices to control the communications between applications and devices based on rules configured.</p>
    <p>to enable or access authorized devices from unauthorized processes or devices. In either case, the adversary may attempt to exfiltrate data from the host system via both physical and virtual USB devices.</p>
    <p>We consider the following actions by an adversary:</p>
    <p>Device Tampering: The adversary may attempt to attach or tamper with a previously-authorized device to add unauthorized functionality (e.g., BadUSB [27]).</p>
    <p>Unauthorized Devices: Unauthorized devices attached to the system either physically or virtually [21] can be used to discreetly interact with the host system or to provide data storage for future exfiltration.</p>
    <p>Unauthorized Access: The adversary may attempt to enable or access authorized devices on a host (e.g., webcam, microphone, etc.) via unauthorized software to gain access to information or functionality that would otherwise inaccessible.</p>
    <p>We assume that as a kernel component, the integrity of USBFILTER depends on the integrity of the operating system and the host hardware (except USB devices). Code running in the kernel space has unrestricted access to the kernels memory, including our code, and we assume that the code running in the kernel will not tamper with USBFILTER. We discuss how we ensure runtime and platform integrity in our experimental setup in Section 3.4.</p>
    <p>Rule DB</p>
    <p>USBFILTER</p>
    <p>App1 App2 App3</p>
    <p>Kernel Space</p>
    <p>User Space</p>
    <p>usbtables</p>
    <p>Host Controller</p>
    <p>USB Devices</p>
    <p>Storage Driver</p>
    <p>Input Driver</p>
    <p>Video Driver</p>
    <p>USB packet</p>
    <p>I/O operation</p>
    <p>URB</p>
    <p>netlink</p>
    <p>usbfilter modules</p>
    <p>Figure 3: The architecture of USBFILTER.</p>
    <p>defined rule-based filtering for the USB protocol. To achieve this, we first designed our system to satisfy the concept of a reference monitor [2], shown in Figure 2. While these goals are not required for full functionality of USBFILTER, we chose to design for stronger security guarantees to ensure that processes attempting to access hardware USB devices directly would be unable to circumvent our system. We define the specific goals as follows:</p>
    <p>G1 Complete Mediation. All physical or virtual USB packets must pass through USBFILTER before delivery to the intended destination.</p>
    <p>G2 Tamperproof. USBFILTER may not be bypassed or disabled as long as the integrity of the operating system is maintained.</p>
    <p>G3 Verifiable. The user-defined rules input into the system must be verifiably correct. These rules may not conflict with each other.</p>
    <p>While the above goals support the security guarantees that we want USBFILTER to provide, we expand upon these to provide additional functionality:</p>
    <p>G4 Granular. Any mutable data in a USB packet header must be accessible by a user-defined rule. If the ultimate destination of a packet is a userspace process, USBFILTER must permit the user to specify the process in a rule.</p>
    <p>G5 Modular. USBFILTER must be extensible and allow users to provide submodules to support additional types of analysis.</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 9</p>
    <p>Goals  Complete mediation  Tamperproof  Verifiability  Granularity  Extensibility</p>
    <p>Reference Monitor</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 10</p>
    <p>Rule constructions</p>
    <p>Process pid,ppid,pgid,uid,euid,gid,egid,comm</p>
    <p>Device bus#,dev#,port#,if#,devpath,manufacturer,product,serial</p>
    <p>Packet type,direction,endpoint,address</p>
    <p>LUM name</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 11</p>
    <p>Rule consistency  General conflict</p>
    <p>Weak conflict</p>
    <p>Strong conflict</p>
    <p>existing rules maintained by USBFILTER. If the new rule has a unique name, all the values of conditions are in range, and it does not conflict with any existing rules, the rule is correct.</p>
    <p>While the name and the value checks are straightforward, there are different conflicting cases between the conditions and the action, particularly when a rule does not contain all conditions. For example, a rule can be contradictory with, a sub rule of, or the same as another existing rule. As such, we define the general conflict between two rules as follows:</p>
    <p>general_con f lict(Ra,Rb) 8Ci 3 C :</p>
    <p>(9Cai 3 Ra ^9C b i 3 Rb ^value(C</p>
    <p>a i ) 6= value(C</p>
    <p>b i ))_</p>
    <p>(9Cai 3 Ra^ 6 9C b i 3 Rb)_</p>
    <p>(6 9Cai 3 Ra^ 6 9C b i 3 Rb).</p>
    <p>A rule Ra is generally conflicted with another rule Rb if all conditions used by Ra are a subset of the ones specified in Rb. We consider a general conflict to occur if the new rule and an existing rule would fire on the same packet.</p>
    <p>Based on the general conflict, we define weak conflict and strong conflict as follows:</p>
    <p>weak_con f lict(Ra,Rb) general_con f lict(Ra,Rb)^action(Ra) = action(Rb).</p>
    <p>strong_con f lict(Ra,Rb) general_con f lict(Ra,Rb)^action(Ra) 6= action(Rb).</p>
    <p>While weak conflict shows that the new rule could be a duplicate of an existing rule, strong conflict presents that this new rule would not work. The weak conflict, however, depending on the requirement and the implementation, may be allowed temporarily to shrink the scope of an existing rule while avoiding the time gap between the old rule removed and the new rule added. For instance, rule A drops any USB packets writing data into any external USB storage devices. Later on, the user decides to block write operations only for the Kingston thumb drive by writing rule B, which is weak conflicted with rule A, since both rules have the same destination and action. When the user wants to unblock the Kingston storage by writing rule C, rule C is strong conflicted with both rule A and B, since rule C has a different action, and will never work as expected because of rule A/B. By relying on the logic reasoning of Prolog, we are able to guarantee that a rule before added is formally verified no conflict with existing rules 3.</p>
    <p>-d|--debug enable debug mode -c|--config path to configuration file (TBD) -h|--help display this help message -p|--dump dump all the rules -a|--add add a new rule -r|--remove remove an existing rule -s|--sync synchronize rules with kernel -e|--enable enable usbfilter -q|--disable disable usbfilter -b|--behave change the default behavior -o|--proc process table rule -v|--dev device table rule -k|--pkt packet table rule -l|--lum LUM table rule -t|--act table rule action --------------------------------proc: pid,ppid,pgid,uid,euid,gid,egid,comm dev: busnum,devnum,portnum,ifnum,devpath,product,</p>
    <p>manufacturer,serial pkt: types,direction,endpoint,address lum: name behavior/action: allow|drop</p>
    <p>Figure 4: The output of usbtables -h. The permitted conditions are divided into 4 tables: the process table, the device table, the packet table, and the Linux USBFILTER Module (LUM) table.</p>
    <p>Granular (G4). A USBFILTER rule can contain 21 different conditions, excluding the name and action field. We further divide these conditions into 4 tables, including the process, device, packet, and the Linux USBFILTER Module (LUM) table, as shown in Figure 4. The process table lists conditions specific to target applications; the device table contains details of USB devices in the system; the packet table includes important information about USB packets; and the LUM table determines the name of the LUM to be used if needed. Note that all LUMs should be loaded into the kernel before being used in USBFILTER rules.</p>
    <p>Module Extension (G5). To support customized rule construction and deep USB packet analysis, USBFILTER allows system administrators to write Linux USBFILTER Modules (LUMs), and load them into the kernel as needed. To write a LUM, developers need only include the &lt;linux/usbfilter.h&gt; header file in the kernel module, implement the callback lum_filter_urb(), and register the module using usbfilter_register_lum(). Once registered, the LUM can be referenced by its name in the construction of a rule. When a LUM is encountered in a rule, besides other condition checking, USBFILTER calls the lum_filter_urb() callback within this LUM, passing the USB packet as the sole parameter. The callback returns 1 if the packet matches the target of this LUM, 0 otherwise. Note that the current implementation supports only one LUM per rule.</p>
    <p>existing rules maintained by USBFILTER. If the new rule has a unique name, all the values of conditions are in range, and it does not conflict with any existing rules, the rule is correct.</p>
    <p>While the name and the value checks are straightforward, there are different conflicting cases between the conditions and the action, particularly when a rule does not contain all conditions. For example, a rule can be contradictory with, a sub rule of, or the same as another existing rule. As such, we define the general conflict between two rules as follows:</p>
    <p>general_con f lict(Ra,Rb) 8Ci 3 C :</p>
    <p>(9Cai 3 Ra ^9C b i 3 Rb ^value(C</p>
    <p>a i ) 6= value(C</p>
    <p>b i ))_</p>
    <p>(9Cai 3 Ra^ 6 9C b i 3 Rb)_</p>
    <p>(6 9Cai 3 Ra^ 6 9C b i 3 Rb).</p>
    <p>A rule Ra is generally conflicted with another rule Rb if all conditions used by Ra are a subset of the ones specified in Rb. We consider a general conflict to occur if the new rule and an existing rule would fire on the same packet.</p>
    <p>Based on the general conflict, we define weak conflict and strong conflict as follows:</p>
    <p>weak_con f lict(Ra,Rb) general_con f lict(Ra,Rb)^action(Ra) = action(Rb).</p>
    <p>strong_con f lict(Ra,Rb) general_con f lict(Ra,Rb)^action(Ra) 6= action(Rb).</p>
    <p>While weak conflict shows that the new rule could be a duplicate of an existing rule, strong conflict presents that this new rule would not work. The weak conflict, however, depending on the requirement and the implementation, may be allowed temporarily to shrink the scope of an existing rule while avoiding the time gap between the old rule removed and the new rule added. For instance, rule A drops any USB packets writing data into any external USB storage devices. Later on, the user decides to block write operations only for the Kingston thumb drive by writing rule B, which is weak conflicted with rule A, since both rules have the same destination and action. When the user wants to unblock the Kingston storage by writing rule C, rule C is strong conflicted with both rule A and B, since rule C has a different action, and will never work as expected because of rule A/B. By relying on the logic reasoning of Prolog, we are able to guarantee that a rule before added is formally verified no conflict with existing rules 3.</p>
    <p>-d|--debug enable debug mode -c|--config path to configuration file (TBD) -h|--help display this help message -p|--dump dump all the rules -a|--add add a new rule -r|--remove remove an existing rule -s|--sync synchronize rules with kernel -e|--enable enable usbfilter -q|--disable disable usbfilter -b|--behave change the default behavior -o|--proc process table rule -v|--dev device table rule -k|--pkt packet table rule -l|--lum LUM table rule -t|--act table rule action --------------------------------proc: pid,ppid,pgid,uid,euid,gid,egid,comm dev: busnum,devnum,portnum,ifnum,devpath,product,</p>
    <p>manufacturer,serial pkt: types,direction,endpoint,address lum: name behavior/action: allow|drop</p>
    <p>Figure 4: The output of usbtables -h. The permitted conditions are divided into 4 tables: the process table, the device table, the packet table, and the Linux USBFILTER Module (LUM) table.</p>
    <p>Granular (G4). A USBFILTER rule can contain 21 different conditions, excluding the name and action field. We further divide these conditions into 4 tables, including the process, device, packet, and the Linux USBFILTER Module (LUM) table, as shown in Figure 4. The process table lists conditions specific to target applications; the device table contains details of USB devices in the system; the packet table includes important information about USB packets; and the LUM table determines the name of the LUM to be used if needed. Note that all LUMs should be loaded into the kernel before being used in USBFILTER rules.</p>
    <p>Module Extension (G5). To support customized rule construction and deep USB packet analysis, USBFILTER allows system administrators to write Linux USBFILTER Modules (LUMs), and load them into the kernel as needed. To write a LUM, developers need only include the &lt;linux/usbfilter.h&gt; header file in the kernel module, implement the callback lum_filter_urb(), and register the module using usbfilter_register_lum(). Once registered, the LUM can be referenced by its name in the construction of a rule. When a LUM is encountered in a rule, besides other condition checking, USBFILTER calls the lum_filter_urb() callback within this LUM, passing the USB packet as the sole parameter. The callback returns 1 if the packet matches the target of this LUM, 0 otherwise. Note that the current implementation supports only one LUM per rule.</p>
    <p>existing rules maintained by USBFILTER. If the new rule has a unique name, all the values of conditions are in range, and it does not conflict with any existing rules, the rule is correct.</p>
    <p>While the name and the value checks are straightforward, there are different conflicting cases between the conditions and the action, particularly when a rule does not contain all conditions. For example, a rule can be contradictory with, a sub rule of, or the same as another existing rule. As such, we define the general conflict between two rules as follows:</p>
    <p>general_con f lict(Ra,Rb) 8Ci 3 C :</p>
    <p>(9Cai 3 Ra ^9C b i 3 Rb ^value(C</p>
    <p>a i ) 6= value(C</p>
    <p>b i ))_</p>
    <p>(9Cai 3 Ra^ 6 9C b i 3 Rb)_</p>
    <p>(6 9Cai 3 Ra^ 6 9C b i 3 Rb).</p>
    <p>A rule Ra is generally conflicted with another rule Rb if all conditions used by Ra are a subset of the ones specified in Rb. We consider a general conflict to occur if the new rule and an existing rule would fire on the same packet.</p>
    <p>Based on the general conflict, we define weak conflict and strong conflict as follows:</p>
    <p>weak_con f lict(Ra,Rb) general_con f lict(Ra,Rb)^action(Ra) = action(Rb).</p>
    <p>strong_con f lict(Ra,Rb) general_con f lict(Ra,Rb)^action(Ra) 6= action(Rb).</p>
    <p>While weak conflict shows that the new rule could be a duplicate of an existing rule, strong conflict presents that this new rule would not work. The weak conflict, however, depending on the requirement and the implementation, may be allowed temporarily to shrink the scope of an existing rule while avoiding the time gap between the old rule removed and the new rule added. For instance, rule A drops any USB packets writing data into any external USB storage devices. Later on, the user decides to block write operations only for the Kingston thumb drive by writing rule B, which is weak conflicted with rule A, since both rules have the same destination and action. When the user wants to unblock the Kingston storage by writing rule C, rule C is strong conflicted with both rule A and B, since rule C has a different action, and will never work as expected because of rule A/B. By relying on the logic reasoning of Prolog, we are able to guarantee that a rule before added is formally verified no conflict with existing rules 3.</p>
    <p>-d|--debug enable debug mode -c|--config path to configuration file (TBD) -h|--help display this help message -p|--dump dump all the rules -a|--add add a new rule -r|--remove remove an existing rule -s|--sync synchronize rules with kernel -e|--enable enable usbfilter -q|--disable disable usbfilter -b|--behave change the default behavior -o|--proc process table rule -v|--dev device table rule -k|--pkt packet table rule -l|--lum LUM table rule -t|--act table rule action --------------------------------proc: pid,ppid,pgid,uid,euid,gid,egid,comm dev: busnum,devnum,portnum,ifnum,devpath,product,</p>
    <p>manufacturer,serial pkt: types,direction,endpoint,address lum: name behavior/action: allow|drop</p>
    <p>Figure 4: The output of usbtables -h. The permitted conditions are divided into 4 tables: the process table, the device table, the packet table, and the Linux USBFILTER Module (LUM) table.</p>
    <p>Granular (G4). A USBFILTER rule can contain 21 different conditions, excluding the name and action field. We further divide these conditions into 4 tables, including the process, device, packet, and the Linux USBFILTER Module (LUM) table, as shown in Figure 4. The process table lists conditions specific to target applications; the device table contains details of USB devices in the system; the packet table includes important information about USB packets; and the LUM table determines the name of the LUM to be used if needed. Note that all LUMs should be loaded into the kernel before being used in USBFILTER rules.</p>
    <p>Module Extension (G5). To support customized rule construction and deep USB packet analysis, USBFILTER allows system administrators to write Linux USBFILTER Modules (LUMs), and load them into the kernel as needed. To write a LUM, developers need only include the &lt;linux/usbfilter.h&gt; header file in the kernel module, implement the callback lum_filter_urb(), and register the module using usbfilter_register_lum(). Once registered, the LUM can be referenced by its name in the construction of a rule. When a LUM is encountered in a rule, besides other condition checking, USBFILTER calls the lum_filter_urb() callback within this LUM, passing the USB packet as the sole parameter. The callback returns 1 if the packet matches the target of this LUM, 0 otherwise. Note that the current implementation supports only one LUM per rule.</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 12</p>
    <p>Linux USBFILTER Module (LUM)  User-defined extension for USBFILTER</p>
    <p>&lt;linux/usbfilter.h&gt;  Rule construction unit</p>
    <p>writing new rules with LUM  Looking into the USB packet</p>
    <p>SCSI commands, IP packets, HID packets, and etc.</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 13</p>
    <p>LUM: detect the SCSI write cmd</p>
    <p>Appendix</p>
    <p>Figure 9: An example Linux USBFILTER Module that blocks writes to USB removable storage.</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 14</p>
    <p>Overview  USBFILTER - 27 kernel source files</p>
    <p>4 new files, 23 modified files  Across USB, SCSI, Block, and Networking subsystems</p>
    <p>USBTABLES  Internal Prolog engine  21 rule constructions</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 15</p>
    <p>Stop BadUSB attacks</p>
    <p>For my keyboard/mouse:</p>
    <p>The USBFILTER host machine is a Dell Optiplex 7010 with an Intel Quad-core 3.20 GHz CPU with 8 GB memory and is running Ubuntu Linux 14.04 LTS with kernel version 3.13. The machine has two USB 2.0 controllers and one USB 3.0 controller, provided by the Intel 7 Series/C210 Series chipset. To demonstrate the power of USBFILTER, we first examine different USB devices and provide practical use cases which are non-trivial for traditional access control mechanisms. Finally we measure the overhead introduced by USBFILTER.</p>
    <p>The default behavior of USBFILTER in our host machine is to allow the USB packet if no rule matches the packet. A more constrained setting is to change the default behavior to drop, requiring each permitted USB device to need an allow rule. In this setting, malicious devices have to impersonate benign devices to allow communications, which are still regulated by the rules, e.g., no HID traffic allowed for a legit USB storage device. All tests use the same front-end USB 2.0 port on the machine.</p>
    <p>We use a Logitech H390 Headset to demonstrate how to achieve this guarantee on the USBFILTER host machine: usbtables -a logitech-headset -v ifnum=2,product=</p>
    <p>&quot;Logitech USB Headset&quot;,manufacturer=Logitech -k direction=1 -t drop</p>
    <p>This rule drops any incoming packets from the Logitech USB headsets microphone. By adding the interface number (ifnum=2), we avoid breaking other functionality in the headset.</p>
    <p>Customizing devices. To further show how USBFILTER can filter functionalities provided by USB devices, we use Teensy 3.2 [29] to create a complex USB device with five interfaces including a keyboard, a mouse, a joystick, and two serial ports. The keyboard contin</p>
    <p>ually types commands in the terminal, while the mouse continually moves the cursor. We can write USBFILTER rules to completely shutdown the keyboard and mouse functionalities: usbtables -a teensy1 -v ifnum=2,manufacturer=</p>
    <p>Teensyduino,serial=1509380 -t drop usbtables -a teensy2 -v ifnum=3,manufacturer=</p>
    <p>Teensyduino,serial=1509380 -t drop</p>
    <p>In these rules, we use condition manufacturer and serial (serial number) to limit the Teensys functionality. Different interface numbers represent the keyboard and the mouse respectively. After these rules applied, both the keyboard and the mouse return to normal.</p>
    <p>Default-deny input devices. Next, we show how to defend against HID-based BadUSB attacks using USBFILTER. These types of devices are a type of trojan horse; they appear to be one device, such as a storage device, but secretly contain hidden input functionality (e.g., keyboard or mouse). When attached to a host, the device can send keystrokes to the host and perform actions as the current user.</p>
    <p>First, we create a BadUSB storage device using a Rubber Ducky [18], which looks like a USB thumb drive but opens a terminal and injects keystrokes. Then we add following rules into the host machine: usbtables -a mymouse -v busnum=1,devnum=4,portnum=2,</p>
    <p>devpath=1.2,product=&quot;USB Optical Mouse&quot;, manufacturer=PixArt -k types=1 -t allow</p>
    <p>usbtables -a mykeyboard -v busnum=1,devnum=3, portnum=1,devpath=1.1, product=&quot;Dell USB Entry Keyboard&quot;, manufacturer=DELL -k types=1 -t allow</p>
    <p>usbtables -a noducky -k types=1 -t drop</p>
    <p>The first two rules whitelist the existing keyboard and mouse on the host machine; the last rule drops any USB packets from other HID devices. After these rules are inserted into the kernel, reconnecting the malicious device does nothing. Attackers may try to impersonate the keyboard or mouse on the host machine. However, we have leveraged information about the physical interface (busnum and portnum) to write the first two rules, which would require the attacker to unplug the existing devices, plug the malicious device in, and impersonate the original devices including the devices VID/PID and serial number. We leave authenticating individual USB devices to future work, however USBFILTER is extensible so that authentication can be added and used in rules.</p>
    <p>Data exfiltration. To prevent data exfiltration from the host machine to USB storage devices, we write a LUM (Linux USBFILTER Module) to block the SCSI write command from the host to the device, as shown in Figure 9 in the Appendix. The LUM then registers itself with USBFILTER and can be referenced by its name in</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 16</p>
    <p>Pin Skype to webcam</p>
    <p>rule constructions. In this case study, we use a Kingston DT 101 II 2G USB flash drive, and insert the following rule:</p>
    <p>usbtables -a nodataexfil -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>This rule prevents modification of files on the storage device. Interestingly, vim reports files on the device to be read-only, despite the filesystem reporting that the files are read-write. Since USBFILTER is able to trace packets back to the applications initiating I/O operations at the Linux kernel block layer, we are able to write rules blocking (or allowing) specific users or applications from writing to flash drive:</p>
    <p>usbtables -a nodataexfil2 -o uid=1001 -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>usbtables -a nodataexfil3 -o comm=vim -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>The first rule prevents the user with uid=1001 from writing anything to the USB storage; the second blocks vim from writing to the storage. We can also block any writes to USB storage devices:</p>
    <p>usbtables -a nodataexfil4 -l name=block_scsi_write -t drop</p>
    <p>USBFILTER logs dropped USB packets, and these logs can easily be used in a centralized alerting system, notifying administrators to unauthorized access attempts. Webcam pinning. Webcams can easily be enabled and accessed by attackers from exploiting vulnerable applications. Once access has been established, the attacker can listen or watch the environment around the host computer. In this case study, we show how to use USBFILTER to restrict the use of a Logitech Webcam C310 to specific users and applications.</p>
    <p>usbtables -a skype -o uid=1001,comm=skype -v serial=B4482A20 -t allow</p>
    <p>usbtables -a nowebcam -v serial=B4482A20 -t drop</p>
    <p>The serial number of the Logitech webcam is specified in the rules to differentiate any others that may be attached to the system as well as to prevent other webcams from being attached. The first rule allows USB communication with the webcam only if the user is uid=1001 and the application is Skype. The following nowebcam rule drops other USB packets to the webcam otherwise. As expected, the user can use the webcam from his Skype but not from Pidgin, and other users cannot start video calls even with Skype.</p>
    <p>USB charge-only. Another form of BadUSB attacks is DNS spoofing using smartphones. Once plugged into the host machine, the malicious phone automatically enables USB tethering, is recognized as a USB NIC by the host,</p>
    <p>Prolog Engine Min Avg Med Max Dev Time (20 rules) 128.0 239.8 288.0 329.0 73.2</p>
    <p>Time (100 rules) 132.0 251.7 298.0 485.0 78.6</p>
    <p>Table 1: Prolog reasoning time ( s) averaged by 100 runs.</p>
    <p>then injects spoofed DNS replies into the host. The resulting man-in-the-middle attack gives the attacker access to the hosts network communications without the authorization of the user. To prevent this attack, we use USBFILTER to prevent all USB packets from a Google Nexus 4 smartphone: usbtables -a n4-charger -v product=&quot;Nexus 4&quot; -t drop</p>
    <p>This rule rule drops any USB packets to/from the phone, which enforces the phone as a pure charging device without any USB functionality. The phone is unable to be used for storage or tethering after the rule is applied.</p>
    <p>We can construct a more specific charge-only rule: usbtables -a charger -v busnum=1,portnum=4 -t drop</p>
    <p>This rule specifies a specific physical port on the host and this port can only be used for charging. This type of rule is useful where USB ports may be exposed (e.g., on a point of sale terminal) and cannot be physically removed. It is also vital to defend against malicious devices whose firmware can be reprogrammed to forge the VID/PID such as BadUSB, since this type of rule only leverages the physical information on the host machine. USBFILTER can partition all physical USB ports and limit the USB traffic on each port.</p>
    <p>The measurement host is loaded with the rules mentioned in the case studies above before beginning benchmarking. When coupled with the default rules provided by USBFILTER, there are 20 total rules loaded in the kernel. We chose 20 because we believe that a typical enterprise hosts USB devices (e.g., keyboard, mouse, removable storage, webcam, etc.) will total less than 20. Then we load 100 rules in the kernel to understand the scalability of USBFILTER.</p>
    <p>USBTABLES Performance. We measure the time used by the Prolog engine to formally verify a rule before it is added into the kernel. We loaded the kernel with 20 and</p>
    <p>For Logitech webcam C310:</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 17</p>
    <p>Stop data exfiltration</p>
    <p>rule constructions. In this case study, we use a Kingston DT 101 II 2G USB flash drive, and insert the following rule:</p>
    <p>usbtables -a nodataexfil -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>This rule prevents modification of files on the storage device. Interestingly, vim reports files on the device to be read-only, despite the filesystem reporting that the files are read-write. Since USBFILTER is able to trace packets back to the applications initiating I/O operations at the Linux kernel block layer, we are able to write rules blocking (or allowing) specific users or applications from writing to flash drive:</p>
    <p>usbtables -a nodataexfil2 -o uid=1001 -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>usbtables -a nodataexfil3 -o comm=vim -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>The first rule prevents the user with uid=1001 from writing anything to the USB storage; the second blocks vim from writing to the storage. We can also block any writes to USB storage devices:</p>
    <p>usbtables -a nodataexfil4 -l name=block_scsi_write -t drop</p>
    <p>USBFILTER logs dropped USB packets, and these logs can easily be used in a centralized alerting system, notifying administrators to unauthorized access attempts. Webcam pinning. Webcams can easily be enabled and accessed by attackers from exploiting vulnerable applications. Once access has been established, the attacker can listen or watch the environment around the host computer. In this case study, we show how to use USBFILTER to restrict the use of a Logitech Webcam C310 to specific users and applications.</p>
    <p>usbtables -a skype -o uid=1001,comm=skype -v serial=B4482A20 -t allow</p>
    <p>usbtables -a nowebcam -v serial=B4482A20 -t drop</p>
    <p>The serial number of the Logitech webcam is specified in the rules to differentiate any others that may be attached to the system as well as to prevent other webcams from being attached. The first rule allows USB communication with the webcam only if the user is uid=1001 and the application is Skype. The following nowebcam rule drops other USB packets to the webcam otherwise. As expected, the user can use the webcam from his Skype but not from Pidgin, and other users cannot start video calls even with Skype.</p>
    <p>USB charge-only. Another form of BadUSB attacks is DNS spoofing using smartphones. Once plugged into the host machine, the malicious phone automatically enables USB tethering, is recognized as a USB NIC by the host,</p>
    <p>Prolog Engine Min Avg Med Max Dev Time (20 rules) 128.0 239.8 288.0 329.0 73.2</p>
    <p>Time (100 rules) 132.0 251.7 298.0 485.0 78.6</p>
    <p>Table 1: Prolog reasoning time ( s) averaged by 100 runs.</p>
    <p>then injects spoofed DNS replies into the host. The resulting man-in-the-middle attack gives the attacker access to the hosts network communications without the authorization of the user. To prevent this attack, we use USBFILTER to prevent all USB packets from a Google Nexus 4 smartphone: usbtables -a n4-charger -v product=&quot;Nexus 4&quot; -t drop</p>
    <p>This rule rule drops any USB packets to/from the phone, which enforces the phone as a pure charging device without any USB functionality. The phone is unable to be used for storage or tethering after the rule is applied.</p>
    <p>We can construct a more specific charge-only rule: usbtables -a charger -v busnum=1,portnum=4 -t drop</p>
    <p>This rule specifies a specific physical port on the host and this port can only be used for charging. This type of rule is useful where USB ports may be exposed (e.g., on a point of sale terminal) and cannot be physically removed. It is also vital to defend against malicious devices whose firmware can be reprogrammed to forge the VID/PID such as BadUSB, since this type of rule only leverages the physical information on the host machine. USBFILTER can partition all physical USB ports and limit the USB traffic on each port.</p>
    <p>The measurement host is loaded with the rules mentioned in the case studies above before beginning benchmarking. When coupled with the default rules provided by USBFILTER, there are 20 total rules loaded in the kernel. We chose 20 because we believe that a typical enterprise hosts USB devices (e.g., keyboard, mouse, removable storage, webcam, etc.) will total less than 20. Then we load 100 rules in the kernel to understand the scalability of USBFILTER.</p>
    <p>USBTABLES Performance. We measure the time used by the Prolog engine to formally verify a rule before it is added into the kernel. We loaded the kernel with 20 and</p>
    <p>For any USB storage devices:</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 18</p>
    <p>Just speaker, no microphone</p>
    <p>The USBFILTER host machine is a Dell Optiplex 7010 with an Intel Quad-core 3.20 GHz CPU with 8 GB memory and is running Ubuntu Linux 14.04 LTS with kernel version 3.13. The machine has two USB 2.0 controllers and one USB 3.0 controller, provided by the Intel 7 Series/C210 Series chipset. To demonstrate the power of USBFILTER, we first examine different USB devices and provide practical use cases which are non-trivial for traditional access control mechanisms. Finally we measure the overhead introduced by USBFILTER.</p>
    <p>The default behavior of USBFILTER in our host machine is to allow the USB packet if no rule matches the packet. A more constrained setting is to change the default behavior to drop, requiring each permitted USB device to need an allow rule. In this setting, malicious devices have to impersonate benign devices to allow communications, which are still regulated by the rules, e.g., no HID traffic allowed for a legit USB storage device. All tests use the same front-end USB 2.0 port on the machine.</p>
    <p>We use a Logitech H390 Headset to demonstrate how to achieve this guarantee on the USBFILTER host machine: usbtables -a logitech-headset -v ifnum=2,product=</p>
    <p>&quot;Logitech USB Headset&quot;,manufacturer=Logitech -k direction=1 -t drop</p>
    <p>This rule drops any incoming packets from the Logitech USB headsets microphone. By adding the interface number (ifnum=2), we avoid breaking other functionality in the headset.</p>
    <p>Customizing devices. To further show how USBFILTER can filter functionalities provided by USB devices, we use Teensy 3.2 [29] to create a complex USB device with five interfaces including a keyboard, a mouse, a joystick, and two serial ports. The keyboard contin</p>
    <p>ually types commands in the terminal, while the mouse continually moves the cursor. We can write USBFILTER rules to completely shutdown the keyboard and mouse functionalities: usbtables -a teensy1 -v ifnum=2,manufacturer=</p>
    <p>Teensyduino,serial=1509380 -t drop usbtables -a teensy2 -v ifnum=3,manufacturer=</p>
    <p>Teensyduino,serial=1509380 -t drop</p>
    <p>In these rules, we use condition manufacturer and serial (serial number) to limit the Teensys functionality. Different interface numbers represent the keyboard and the mouse respectively. After these rules applied, both the keyboard and the mouse return to normal.</p>
    <p>Default-deny input devices. Next, we show how to defend against HID-based BadUSB attacks using USBFILTER. These types of devices are a type of trojan horse; they appear to be one device, such as a storage device, but secretly contain hidden input functionality (e.g., keyboard or mouse). When attached to a host, the device can send keystrokes to the host and perform actions as the current user.</p>
    <p>First, we create a BadUSB storage device using a Rubber Ducky [18], which looks like a USB thumb drive but opens a terminal and injects keystrokes. Then we add following rules into the host machine: usbtables -a mymouse -v busnum=1,devnum=4,portnum=2,</p>
    <p>devpath=1.2,product=&quot;USB Optical Mouse&quot;, manufacturer=PixArt -k types=1 -t allow</p>
    <p>usbtables -a mykeyboard -v busnum=1,devnum=3, portnum=1,devpath=1.1, product=&quot;Dell USB Entry Keyboard&quot;, manufacturer=DELL -k types=1 -t allow</p>
    <p>usbtables -a noducky -k types=1 -t drop</p>
    <p>The first two rules whitelist the existing keyboard and mouse on the host machine; the last rule drops any USB packets from other HID devices. After these rules are inserted into the kernel, reconnecting the malicious device does nothing. Attackers may try to impersonate the keyboard or mouse on the host machine. However, we have leveraged information about the physical interface (busnum and portnum) to write the first two rules, which would require the attacker to unplug the existing devices, plug the malicious device in, and impersonate the original devices including the devices VID/PID and serial number. We leave authenticating individual USB devices to future work, however USBFILTER is extensible so that authentication can be added and used in rules.</p>
    <p>Data exfiltration. To prevent data exfiltration from the host machine to USB storage devices, we write a LUM (Linux USBFILTER Module) to block the SCSI write command from the host to the device, as shown in Figure 9 in the Appendix. The LUM then registers itself with USBFILTER and can be referenced by its name in</p>
    <p>For Logitech USB headset:</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 19</p>
    <p>Charge safe</p>
    <p>rule constructions. In this case study, we use a Kingston DT 101 II 2G USB flash drive, and insert the following rule:</p>
    <p>usbtables -a nodataexfil -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>This rule prevents modification of files on the storage device. Interestingly, vim reports files on the device to be read-only, despite the filesystem reporting that the files are read-write. Since USBFILTER is able to trace packets back to the applications initiating I/O operations at the Linux kernel block layer, we are able to write rules blocking (or allowing) specific users or applications from writing to flash drive:</p>
    <p>usbtables -a nodataexfil2 -o uid=1001 -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>usbtables -a nodataexfil3 -o comm=vim -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>The first rule prevents the user with uid=1001 from writing anything to the USB storage; the second blocks vim from writing to the storage. We can also block any writes to USB storage devices:</p>
    <p>usbtables -a nodataexfil4 -l name=block_scsi_write -t drop</p>
    <p>USBFILTER logs dropped USB packets, and these logs can easily be used in a centralized alerting system, notifying administrators to unauthorized access attempts. Webcam pinning. Webcams can easily be enabled and accessed by attackers from exploiting vulnerable applications. Once access has been established, the attacker can listen or watch the environment around the host computer. In this case study, we show how to use USBFILTER to restrict the use of a Logitech Webcam C310 to specific users and applications.</p>
    <p>usbtables -a skype -o uid=1001,comm=skype -v serial=B4482A20 -t allow</p>
    <p>usbtables -a nowebcam -v serial=B4482A20 -t drop</p>
    <p>The serial number of the Logitech webcam is specified in the rules to differentiate any others that may be attached to the system as well as to prevent other webcams from being attached. The first rule allows USB communication with the webcam only if the user is uid=1001 and the application is Skype. The following nowebcam rule drops other USB packets to the webcam otherwise. As expected, the user can use the webcam from his Skype but not from Pidgin, and other users cannot start video calls even with Skype.</p>
    <p>USB charge-only. Another form of BadUSB attacks is DNS spoofing using smartphones. Once plugged into the host machine, the malicious phone automatically enables USB tethering, is recognized as a USB NIC by the host,</p>
    <p>Prolog Engine Min Avg Med Max Dev Time (20 rules) 128.0 239.8 288.0 329.0 73.2</p>
    <p>Time (100 rules) 132.0 251.7 298.0 485.0 78.6</p>
    <p>Table 1: Prolog reasoning time ( s) averaged by 100 runs.</p>
    <p>then injects spoofed DNS replies into the host. The resulting man-in-the-middle attack gives the attacker access to the hosts network communications without the authorization of the user. To prevent this attack, we use USBFILTER to prevent all USB packets from a Google Nexus 4 smartphone: usbtables -a n4-charger -v product=&quot;Nexus 4&quot; -t drop</p>
    <p>This rule rule drops any USB packets to/from the phone, which enforces the phone as a pure charging device without any USB functionality. The phone is unable to be used for storage or tethering after the rule is applied.</p>
    <p>We can construct a more specific charge-only rule: usbtables -a charger -v busnum=1,portnum=4 -t drop</p>
    <p>This rule specifies a specific physical port on the host and this port can only be used for charging. This type of rule is useful where USB ports may be exposed (e.g., on a point of sale terminal) and cannot be physically removed. It is also vital to defend against malicious devices whose firmware can be reprogrammed to forge the VID/PID such as BadUSB, since this type of rule only leverages the physical information on the host machine. USBFILTER can partition all physical USB ports and limit the USB traffic on each port.</p>
    <p>The measurement host is loaded with the rules mentioned in the case studies above before beginning benchmarking. When coupled with the default rules provided by USBFILTER, there are 20 total rules loaded in the kernel. We chose 20 because we believe that a typical enterprise hosts USB devices (e.g., keyboard, mouse, removable storage, webcam, etc.) will total less than 20. Then we load 100 rules in the kernel to understand the scalability of USBFILTER.</p>
    <p>USBTABLES Performance. We measure the time used by the Prolog engine to formally verify a rule before it is added into the kernel. We loaded the kernel with 20 and</p>
    <p>rule constructions. In this case study, we use a Kingston DT 101 II 2G USB flash drive, and insert the following rule:</p>
    <p>usbtables -a nodataexfil -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>This rule prevents modification of files on the storage device. Interestingly, vim reports files on the device to be read-only, despite the filesystem reporting that the files are read-write. Since USBFILTER is able to trace packets back to the applications initiating I/O operations at the Linux kernel block layer, we are able to write rules blocking (or allowing) specific users or applications from writing to flash drive:</p>
    <p>usbtables -a nodataexfil2 -o uid=1001 -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>usbtables -a nodataexfil3 -o comm=vim -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>The first rule prevents the user with uid=1001 from writing anything to the USB storage; the second blocks vim from writing to the storage. We can also block any writes to USB storage devices:</p>
    <p>usbtables -a nodataexfil4 -l name=block_scsi_write -t drop</p>
    <p>USBFILTER logs dropped USB packets, and these logs can easily be used in a centralized alerting system, notifying administrators to unauthorized access attempts. Webcam pinning. Webcams can easily be enabled and accessed by attackers from exploiting vulnerable applications. Once access has been established, the attacker can listen or watch the environment around the host computer. In this case study, we show how to use USBFILTER to restrict the use of a Logitech Webcam C310 to specific users and applications.</p>
    <p>usbtables -a skype -o uid=1001,comm=skype -v serial=B4482A20 -t allow</p>
    <p>usbtables -a nowebcam -v serial=B4482A20 -t drop</p>
    <p>The serial number of the Logitech webcam is specified in the rules to differentiate any others that may be attached to the system as well as to prevent other webcams from being attached. The first rule allows USB communication with the webcam only if the user is uid=1001 and the application is Skype. The following nowebcam rule drops other USB packets to the webcam otherwise. As expected, the user can use the webcam from his Skype but not from Pidgin, and other users cannot start video calls even with Skype.</p>
    <p>USB charge-only. Another form of BadUSB attacks is DNS spoofing using smartphones. Once plugged into the host machine, the malicious phone automatically enables USB tethering, is recognized as a USB NIC by the host,</p>
    <p>Prolog Engine Min Avg Med Max Dev Time (20 rules) 128.0 239.8 288.0 329.0 73.2</p>
    <p>Time (100 rules) 132.0 251.7 298.0 485.0 78.6</p>
    <p>Table 1: Prolog reasoning time ( s) averaged by 100 runs.</p>
    <p>then injects spoofed DNS replies into the host. The resulting man-in-the-middle attack gives the attacker access to the hosts network communications without the authorization of the user. To prevent this attack, we use USBFILTER to prevent all USB packets from a Google Nexus 4 smartphone: usbtables -a n4-charger -v product=&quot;Nexus 4&quot; -t drop</p>
    <p>This rule rule drops any USB packets to/from the phone, which enforces the phone as a pure charging device without any USB functionality. The phone is unable to be used for storage or tethering after the rule is applied.</p>
    <p>We can construct a more specific charge-only rule: usbtables -a charger -v busnum=1,portnum=4 -t drop</p>
    <p>This rule specifies a specific physical port on the host and this port can only be used for charging. This type of rule is useful where USB ports may be exposed (e.g., on a point of sale terminal) and cannot be physically removed. It is also vital to defend against malicious devices whose firmware can be reprogrammed to forge the VID/PID such as BadUSB, since this type of rule only leverages the physical information on the host machine. USBFILTER can partition all physical USB ports and limit the USB traffic on each port.</p>
    <p>The measurement host is loaded with the rules mentioned in the case studies above before beginning benchmarking. When coupled with the default rules provided by USBFILTER, there are 20 total rules loaded in the kernel. We chose 20 because we believe that a typical enterprise hosts USB devices (e.g., keyboard, mouse, removable storage, webcam, etc.) will total less than 20. Then we load 100 rules in the kernel to understand the scalability of USBFILTER.</p>
    <p>USBTABLES Performance. We measure the time used by the Prolog engine to formally verify a rule before it is added into the kernel. We loaded the kernel with 20 and</p>
    <p>For Nexus 4:</p>
    <p>For any phone:</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 20</p>
    <p>Scalability</p>
    <p>Adding a new rule Avg (ms) 20 Base Rules 5.9</p>
    <p>Packet filtering Avg (s) 20 Base Rules 2.6</p>
    <p>USBTABLES:</p>
    <p>USBFILTER:</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 21</p>
    <p>Throughput</p>
    <p>Figure 5: Filebench throughput (MB/s) using fileserver workload with different mean file sizes.</p>
    <p>Figure 6: Iperf bandwidth (MB/s) using TCP with different time intervals.</p>
    <p>Figure 7: Iperf bandwidth (MB/s) using UDP with different time intervals.</p>
    <p>Figure 8: Performance comparison of realworld workloads.</p>
    <p>Rule Adding Min Avg Med Max Dev Time (20 rules) 5.1 5.9 6.1 6.6 0.3 Time (100 rules) 4.9 5.9 6.1 6.8 0.4</p>
    <p>Table 2: Rule adding operation time (ms) averaged by 100 runs.</p>
    <p>We measured 100 trials of each test. The performance of the Prolog engine is shown in Table 1. The average time used by the Prolog engine is 239.8  s with 20 rules and 251.7  s with 100 rules. This fast speed is the result of using GNU Prolog (gplc) compiler to compile Prolog into assembly for acceleration. We also measure the overhead for USBTABLES to add a new rule to the kernel space. This includes loading existing rules into the Prolog engine, checking for conflicts, saving the rule</p>
    <p>USB Enumeration Min Avg Med Max Dev Cost Stock Kernel 32.0 33.9 34.1 34.8 0.6 N/A</p>
    <p>USBFILTER (20 rules) 33.2 34.4 34.3 35.8 0.7 1.5% USBFILTER (100 rules) 33.9 34.8 34.6 36.0 0.5 2.7%</p>
    <p>Table 3: USB enumeration time (ms) averaged by 20 runs.</p>
    <p>locally, passing the rule to the kernel, and waiting for the acknowledgment. As shown in Table 2, the average time of adding a rule using USBTABLES stays at around 6 ms in both cases, which is a negligible one-time cost.</p>
    <p>USB Enumeration Overhead. For this test, we used the Logitech H390 USB headset, which has 4 interfaces. We manually plugged the headset into the host 20 times. We then compare the results between the USBFILTER kernel with varying numbers of rules loaded and the stock Ubuntu kernel, where USBFILTER is fully disabled,</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 22</p>
    <p>Latency</p>
    <p>Latency (s) 1 KB 10 KB 100 KB 1 MB 10 MB 100 MB</p>
    <p>Stock 97.6 98.1 99.2 105.5 741.7 5177.7</p>
    <p>USBFILTER 97.7 98.2 99.6 106.3 851.5 6088.4</p>
    <p>Overhead 0.1% 0.1% 0.4% 0.8% 14.8% 17.6%</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 23</p>
    <p>Performance in real world</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 24</p>
    <p>Limitations &amp; Future Work  IRQ contexts  Vendor-specific drivers  Response-path filtering  Making it faster - BPF  More useful LUMs  Usability - targeting administrators</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 25</p>
    <p>Conclusion  USBFILTER</p>
    <p>A USB layer firewall in the Linux kernel  USBTABLES</p>
    <p>A user-space tool to manage policies/rules  Controlling USB device behaviors</p>
    <p>Defending against BadUSB attacks  Limiting USB device functionalities</p>
    <p>Introducing minimum overhead</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 26</p>
    <p>Q&amp;A Get USBFILTER now:</p>
    <p>https://github.com/daveti/usbfilter</p>
    <p>All bugs are introduced by: root@davejingtian.org</p>
    <p>Thanks!</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 27</p>
    <p>USBTABLES -h existing rules maintained by USBFILTER. If the new rule has a unique name, all the values of conditions are in range, and it does not conflict with any existing rules, the rule is correct.</p>
    <p>While the name and the value checks are straightforward, there are different conflicting cases between the conditions and the action, particularly when a rule does not contain all conditions. For example, a rule can be contradictory with, a sub rule of, or the same as another existing rule. As such, we define the general conflict between two rules as follows:</p>
    <p>general_con f lict(Ra,Rb) 8Ci 3 C :</p>
    <p>(9Cai 3 Ra ^9C b i 3 Rb ^value(C</p>
    <p>a i ) 6= value(C</p>
    <p>b i ))_</p>
    <p>(9Cai 3 Ra^ 6 9C b i 3 Rb)_</p>
    <p>(6 9Cai 3 Ra^ 6 9C b i 3 Rb).</p>
    <p>A rule Ra is generally conflicted with another rule Rb if all conditions used by Ra are a subset of the ones specified in Rb. We consider a general conflict to occur if the new rule and an existing rule would fire on the same packet.</p>
    <p>Based on the general conflict, we define weak conflict and strong conflict as follows:</p>
    <p>weak_con f lict(Ra,Rb) general_con f lict(Ra,Rb)^action(Ra) = action(Rb).</p>
    <p>strong_con f lict(Ra,Rb) general_con f lict(Ra,Rb)^action(Ra) 6= action(Rb).</p>
    <p>While weak conflict shows that the new rule could be a duplicate of an existing rule, strong conflict presents that this new rule would not work. The weak conflict, however, depending on the requirement and the implementation, may be allowed temporarily to shrink the scope of an existing rule while avoiding the time gap between the old rule removed and the new rule added. For instance, rule A drops any USB packets writing data into any external USB storage devices. Later on, the user decides to block write operations only for the Kingston thumb drive by writing rule B, which is weak conflicted with rule A, since both rules have the same destination and action. When the user wants to unblock the Kingston storage by writing rule C, rule C is strong conflicted with both rule A and B, since rule C has a different action, and will never work as expected because of rule A/B. By relying on the logic reasoning of Prolog, we are able to guarantee that a rule before added is formally verified no conflict with existing rules 3.</p>
    <p>-d|--debug enable debug mode -c|--config path to configuration file (TBD) -h|--help display this help message -p|--dump dump all the rules -a|--add add a new rule -r|--remove remove an existing rule -s|--sync synchronize rules with kernel -e|--enable enable usbfilter -q|--disable disable usbfilter -b|--behave change the default behavior -o|--proc process table rule -v|--dev device table rule -k|--pkt packet table rule -l|--lum LUM table rule -t|--act table rule action --------------------------------proc: pid,ppid,pgid,uid,euid,gid,egid,comm dev: busnum,devnum,portnum,ifnum,devpath,product,</p>
    <p>manufacturer,serial pkt: types,direction,endpoint,address lum: name behavior/action: allow|drop</p>
    <p>Figure 4: The output of usbtables -h. The permitted conditions are divided into 4 tables: the process table, the device table, the packet table, and the Linux USBFILTER Module (LUM) table.</p>
    <p>Granular (G4). A USBFILTER rule can contain 21 different conditions, excluding the name and action field. We further divide these conditions into 4 tables, including the process, device, packet, and the Linux USBFILTER Module (LUM) table, as shown in Figure 4. The process table lists conditions specific to target applications; the device table contains details of USB devices in the system; the packet table includes important information about USB packets; and the LUM table determines the name of the LUM to be used if needed. Note that all LUMs should be loaded into the kernel before being used in USBFILTER rules.</p>
    <p>Module Extension (G5). To support customized rule construction and deep USB packet analysis, USBFILTER allows system administrators to write Linux USBFILTER Modules (LUMs), and load them into the kernel as needed. To write a LUM, developers need only include the &lt;linux/usbfilter.h&gt; header file in the kernel module, implement the callback lum_filter_urb(), and register the module using usbfilter_register_lum(). Once registered, the LUM can be referenced by its name in the construction of a rule. When a LUM is encountered in a rule, besides other condition checking, USBFILTER calls the lum_filter_urb() callback within this LUM, passing the USB packet as the sole parameter. The callback returns 1 if the packet matches the target of this LUM, 0 otherwise. Note that the current implementation supports only one LUM per rule.</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 28</p>
    <p>A LUM written by dtrumpAppendix 1 /* 2 * lbsw - A LUM kernel module 3 * used to block SCSI write command within USB packets 4 */ 5 #include &lt;linux/module.h&gt; 6 #include &lt;linux/usbfilter.h&gt; 7 #include &lt;scsi/scsi.h&gt; 8 9 #define LUM_NAME &quot;block_scsi_write&quot;</p>
    <p>Figure 9: An example Linux USBFILTER Module that blocks writes to USB removable storage.</p>
    <p>Appendix</p>
    <p>Figure 9: An example Linux USBFILTER Module that blocks writes to USB removable storage.</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 29</p>
    <p>Just read, seriously rule constructions. In this case study, we use a Kingston DT 101 II 2G USB flash drive, and insert the following rule:</p>
    <p>usbtables -a nodataexfil -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>This rule prevents modification of files on the storage device. Interestingly, vim reports files on the device to be read-only, despite the filesystem reporting that the files are read-write. Since USBFILTER is able to trace packets back to the applications initiating I/O operations at the Linux kernel block layer, we are able to write rules blocking (or allowing) specific users or applications from writing to flash drive:</p>
    <p>usbtables -a nodataexfil2 -o uid=1001 -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>usbtables -a nodataexfil3 -o comm=vim -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>The first rule prevents the user with uid=1001 from writing anything to the USB storage; the second blocks vim from writing to the storage. We can also block any writes to USB storage devices:</p>
    <p>usbtables -a nodataexfil4 -l name=block_scsi_write -t drop</p>
    <p>USBFILTER logs dropped USB packets, and these logs can easily be used in a centralized alerting system, notifying administrators to unauthorized access attempts. Webcam pinning. Webcams can easily be enabled and accessed by attackers from exploiting vulnerable applications. Once access has been established, the attacker can listen or watch the environment around the host computer. In this case study, we show how to use USBFILTER to restrict the use of a Logitech Webcam C310 to specific users and applications.</p>
    <p>usbtables -a skype -o uid=1001,comm=skype -v serial=B4482A20 -t allow</p>
    <p>usbtables -a nowebcam -v serial=B4482A20 -t drop</p>
    <p>The serial number of the Logitech webcam is specified in the rules to differentiate any others that may be attached to the system as well as to prevent other webcams from being attached. The first rule allows USB communication with the webcam only if the user is uid=1001 and the application is Skype. The following nowebcam rule drops other USB packets to the webcam otherwise. As expected, the user can use the webcam from his Skype but not from Pidgin, and other users cannot start video calls even with Skype.</p>
    <p>USB charge-only. Another form of BadUSB attacks is DNS spoofing using smartphones. Once plugged into the host machine, the malicious phone automatically enables USB tethering, is recognized as a USB NIC by the host,</p>
    <p>Prolog Engine Min Avg Med Max Dev Time (20 rules) 128.0 239.8 288.0 329.0 73.2</p>
    <p>Time (100 rules) 132.0 251.7 298.0 485.0 78.6</p>
    <p>Table 1: Prolog reasoning time ( s) averaged by 100 runs.</p>
    <p>then injects spoofed DNS replies into the host. The resulting man-in-the-middle attack gives the attacker access to the hosts network communications without the authorization of the user. To prevent this attack, we use USBFILTER to prevent all USB packets from a Google Nexus 4 smartphone: usbtables -a n4-charger -v product=&quot;Nexus 4&quot; -t drop</p>
    <p>This rule rule drops any USB packets to/from the phone, which enforces the phone as a pure charging device without any USB functionality. The phone is unable to be used for storage or tethering after the rule is applied.</p>
    <p>We can construct a more specific charge-only rule: usbtables -a charger -v busnum=1,portnum=4 -t drop</p>
    <p>This rule specifies a specific physical port on the host and this port can only be used for charging. This type of rule is useful where USB ports may be exposed (e.g., on a point of sale terminal) and cannot be physically removed. It is also vital to defend against malicious devices whose firmware can be reprogrammed to forge the VID/PID such as BadUSB, since this type of rule only leverages the physical information on the host machine. USBFILTER can partition all physical USB ports and limit the USB traffic on each port.</p>
    <p>The measurement host is loaded with the rules mentioned in the case studies above before beginning benchmarking. When coupled with the default rules provided by USBFILTER, there are 20 total rules loaded in the kernel. We chose 20 because we believe that a typical enterprise hosts USB devices (e.g., keyboard, mouse, removable storage, webcam, etc.) will total less than 20. Then we load 100 rules in the kernel to understand the scalability of USBFILTER.</p>
    <p>USBTABLES Performance. We measure the time used by the Prolog engine to formally verify a rule before it is added into the kernel. We loaded the kernel with 20 and</p>
    <p>For Kingston USB flash drive:</p>
    <p>rule constructions. In this case study, we use a Kingston DT 101 II 2G USB flash drive, and insert the following rule:</p>
    <p>usbtables -a nodataexfil -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>This rule prevents modification of files on the storage device. Interestingly, vim reports files on the device to be read-only, despite the filesystem reporting that the files are read-write. Since USBFILTER is able to trace packets back to the applications initiating I/O operations at the Linux kernel block layer, we are able to write rules blocking (or allowing) specific users or applications from writing to flash drive:</p>
    <p>usbtables -a nodataexfil2 -o uid=1001 -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>usbtables -a nodataexfil3 -o comm=vim -v manufacturer=Kingston -l name=block_scsi_write -t drop</p>
    <p>The first rule prevents the user with uid=1001 from writing anything to the USB storage; the second blocks vim from writing to the storage. We can also block any writes to USB storage devices:</p>
    <p>usbtables -a nodataexfil4 -l name=block_scsi_write -t drop</p>
    <p>USBFILTER logs dropped USB packets, and these logs can easily be used in a centralized alerting system, notifying administrators to unauthorized access attempts. Webcam pinning. Webcams can easily be enabled and accessed by attackers from exploiting vulnerable applications. Once access has been established, the attacker can listen or watch the environment around the host computer. In this case study, we show how to use USBFILTER to restrict the use of a Logitech Webcam C310 to specific users and applications.</p>
    <p>usbtables -a skype -o uid=1001,comm=skype -v serial=B4482A20 -t allow</p>
    <p>usbtables -a nowebcam -v serial=B4482A20 -t drop</p>
    <p>The serial number of the Logitech webcam is specified in the rules to differentiate any others that may be attached to the system as well as to prevent other webcams from being attached. The first rule allows USB communication with the webcam only if the user is uid=1001 and the application is Skype. The following nowebcam rule drops other USB packets to the webcam otherwise. As expected, the user can use the webcam from his Skype but not from Pidgin, and other users cannot start video calls even with Skype.</p>
    <p>USB charge-only. Another form of BadUSB attacks is DNS spoofing using smartphones. Once plugged into the host machine, the malicious phone automatically enables USB tethering, is recognized as a USB NIC by the host,</p>
    <p>Prolog Engine Min Avg Med Max Dev Time (20 rules) 128.0 239.8 288.0 329.0 73.2</p>
    <p>Time (100 rules) 132.0 251.7 298.0 485.0 78.6</p>
    <p>Table 1: Prolog reasoning time ( s) averaged by 100 runs.</p>
    <p>then injects spoofed DNS replies into the host. The resulting man-in-the-middle attack gives the attacker access to the hosts network communications without the authorization of the user. To prevent this attack, we use USBFILTER to prevent all USB packets from a Google Nexus 4 smartphone: usbtables -a n4-charger -v product=&quot;Nexus 4&quot; -t drop</p>
    <p>This rule rule drops any USB packets to/from the phone, which enforces the phone as a pure charging device without any USB functionality. The phone is unable to be used for storage or tethering after the rule is applied.</p>
    <p>We can construct a more specific charge-only rule: usbtables -a charger -v busnum=1,portnum=4 -t drop</p>
    <p>This rule specifies a specific physical port on the host and this port can only be used for charging. This type of rule is useful where USB ports may be exposed (e.g., on a point of sale terminal) and cannot be physically removed. It is also vital to defend against malicious devices whose firmware can be reprogrammed to forge the VID/PID such as BadUSB, since this type of rule only leverages the physical information on the host machine. USBFILTER can partition all physical USB ports and limit the USB traffic on each port.</p>
    <p>The measurement host is loaded with the rules mentioned in the case studies above before beginning benchmarking. When coupled with the default rules provided by USBFILTER, there are 20 total rules loaded in the kernel. We chose 20 because we believe that a typical enterprise hosts USB devices (e.g., keyboard, mouse, removable storage, webcam, etc.) will total less than 20. Then we load 100 rules in the kernel to understand the scalability of USBFILTER.</p>
    <p>USBTABLES Performance. We measure the time used by the Prolog engine to formally verify a rule before it is added into the kernel. We loaded the kernel with 20 and</p>
  </div>
  <div class="page">
    <p>Florida Institute of Cyber Security (FICS) Research 30</p>
    <p>What is wrong with USB  Unlimited capabilities  No authentication  BadUSB attacks</p>
  </div>
</Presentation>
