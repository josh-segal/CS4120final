<?xml version="1.0" ?>
<Presentation>
  <div class="page"/>
  <div class="page">
    <p>Compositional Veri ation</p>
    <p>of Se ure Applet Intera tions</p>
    <p>Marieke Huisman</p>
    <p>INRIA Sophia Antipolis, Fran e</p>
    <p>Marieke.Huismansophia.inria.fr</p>
    <p>Joint work with:</p>
    <p>Dilian Gurov</p>
    <p>SICS, Sweden</p>
    <p>diliansi s.se</p>
    <p>Gilles Barthe</p>
    <p>INRIA Sophia Antipolis, Fran e</p>
    <p>Gilles.Barthesophia.inria.fr</p>
  </div>
  <div class="page">
    <p>Introdu tion</p>
    <p>Growing interest in veri ation of ( ontrol ow based) se urity properties</p>
    <p>New generation of multi-appli ation smart ards: post-issuan e loading</p>
    <p>of applets</p>
    <p>De omposition of properties desirable (also useful for management of</p>
    <p>veri ation)</p>
  </div>
  <div class="page">
    <p>A framework for ompositional veri ation</p>
    <p>Program model</p>
    <p>Temporal logi spe i ation language + high level patterns</p>
    <p>Proof system to show orre tness of de omposition</p>
  </div>
  <div class="page">
    <p>Ba kground</p>
    <p>VeriCard proje t: reasoning about JavaCard</p>
    <p>Representation of program as all-transfer graph (Jensen, Le Metayer,</p>
    <p>Thorn, 1999)</p>
    <p>Context Free Pro esses: e ient model he king algorithms (polynomial</p>
    <p>in the size of the CFP) (Burkart &amp; Steen, 1992, Esparza &amp; S hwoon,</p>
    <p>Compositional proof systems for modal - al ulus (Dam &amp; Gurov, 1998)</p>
  </div>
  <div class="page">
    <p>A framework for ompositional veri ation</p>
    <p>Program model</p>
    <p>Temporal logi spe i ation language + high level patterns</p>
    <p>Proof system to show orre tness of de omposition</p>
  </div>
  <div class="page">
    <p>Running example: ele troni purse</p>
    <p>Three applets: purse + 2 loyalties (AirFran e, RentACar)</p>
    <p>Purse keeps log table of transa tions</p>
    <p>Loyalties an subs ribe to logFull servi e</p>
    <p>AirFran e subs ribed, RentACar not subs ribed</p>
    <p>logFull: AirFran e asks purse for transa tions, and RentACar for</p>
    <p>balan e</p>
    <p>RentACar dedu es that log table is full</p>
  </div>
  <div class="page">
    <p>Ele troni purse: bad s enario</p>
    <p>RentACar</p>
    <p>logFull</p>
    <p>getTrs</p>
    <p>getTrs</p>
    <p>getTrs</p>
    <p>getTrs</p>
    <p>logFull</p>
    <p>getBalance</p>
    <p>getBalance</p>
    <p>Purse AirFrance</p>
  </div>
  <div class="page">
    <p>The program model</p>
  </div>
  <div class="page">
    <p>Compositional program model</p>
    <p>Program: set of applets, ommuni ating via method invo ations and</p>
    <p>returns</p>
    <p>External program points</p>
    <p>Applet: transfer graph + all graph</p>
    <p>Ea h applet: lo al ontrol sta k</p>
    <p>Global state: well-formed set of lo al states</p>
    <p>Transition rules indu e operational semanti s</p>
  </div>
  <div class="page">
    <p>Formally</p>
    <p>M</p>
    <p>= (A;V ; app; ret; !</p>
    <p>T</p>
    <p>;!</p>
    <p>C</p>
    <p>)</p>
    <p>A a set of applets</p>
    <p>verti es V are program points</p>
    <p>app: V * A attributes verti es to applets</p>
    <p>set of return verti es identied by ret</p>
    <p>program = transfer graph !</p>
    <p>T</p>
    <p>+ all graph !</p>
    <p>C</p>
    <p>, distributed over dierent</p>
    <p>applets</p>
  </div>
  <div class="page">
    <p>Example ompositional model for ele troni purse</p>
    <p>P.debit.Med</p>
    <p>AF.logFull.Med1</p>
    <p>AF.buyTicket AF.logFull</p>
    <p>AF.buyTicket.Ret AF.logFull.Ret</p>
    <p>P.getTrs</p>
    <p>P.getTrs.Ret</p>
    <p>RentACar</p>
    <p>RaC.rentCar</p>
    <p>User.RaC</p>
    <p>RaC.getBalance.Med</p>
    <p>RaC.rentCar.Ret RaC.getBalance.Ret</p>
    <p>RaC.getBalance</p>
    <p>P.debit.Ret</p>
    <p>P.debit</p>
    <p>Purse</p>
    <p>User.P User.AF</p>
    <p>AirFrance</p>
  </div>
  <div class="page">
    <p>Operational semanti s</p>
    <p>Two sets of transition rules:</p>
    <p>{ Applet transition rules</p>
    <p>{ Transition rules to ombine behaviour of sets of applets</p>
    <p>Transition labels denote method invo ations and returns</p>
    <p>{ Perfe t a tions: internal ow or method invo ation/return lo al to</p>
    <p>applet set ( all, ret)</p>
    <p>{ Imperfe t a tions: method invo ation/return over applet set</p>
    <p>boundaries ( all?, all!, ret?, ret!)</p>
    <p>Imperfe t a tions an syn hronise, forming perfe t a tions</p>
  </div>
  <div class="page">
    <p>Lo al state per applet</p>
    <p>Every applet has lo al state: list of pairs, representing the ontrol sta k</p>
    <p>Example: lo al states in the Purse</p>
    <p>When AF.logFull.Med1 has been rea hed:</p>
    <p>Purse: = hUser.P; P.debit.Medi</p>
    <p>hP.debit.Med; AF.logFulli</p>
    <p>AirFran e: = hP.debit.Med; AF.logFull.Med1i</p>
    <p>RentACar: =</p>
  </div>
  <div class="page">
    <p>States formally</p>
    <p>An applet state of M is a pair a:, where a 2 A and  2 (V  V )</p>
    <p>A program state of M is a wellformed olle tion a</p>
    <p>:</p>
    <p>ja</p>
    <p>:</p>
    <p>j: : :ja</p>
    <p>n</p>
    <p>:</p>
    <p>n</p>
    <p>of applet states.</p>
    <p>A tive</p>
    <p>a: is a tive i the last program point in  is lo al to applet a</p>
    <p>A program state is alled a tive i it ontains an a tive applet state.</p>
  </div>
  <div class="page">
    <p>Wellformedness ondition on program states</p>
    <p>A program state is wellformed i</p>
    <p>ea h applet name is mentioned at most on e</p>
    <p>at most one applet is a tive</p>
  </div>
  <div class="page">
    <p>Example applet transition rule: send all</p>
    <p>[send all</p>
    <p>v</p>
    <p>!</p>
    <p>C</p>
    <p>v</p>
    <p>lo</p>
    <p>a</p>
    <p>v</p>
    <p>:lo</p>
    <p>a</p>
    <p>v</p>
    <p>a:  hv; v</p>
    <p>i</p>
    <p>v</p>
    <p>all! v</p>
    <p>! a:  hv; v</p>
    <p>i  hv</p>
    <p>; v</p>
    <p>i</p>
    <p>applet a</p>
    <p>v</p>
    <p>v1</p>
    <p>v2</p>
  </div>
  <div class="page">
    <p>Applet transition rules</p>
    <p>[lo al all</p>
    <p>v</p>
    <p>!</p>
    <p>C</p>
    <p>v</p>
    <p>lo</p>
    <p>a</p>
    <p>v</p>
    <p>lo</p>
    <p>a</p>
    <p>v</p>
    <p>a:  hv; v</p>
    <p>i</p>
    <p>v</p>
    <p>all v</p>
    <p>! a:  hv; v</p>
    <p>; ihv</p>
    <p>; v</p>
    <p>i</p>
    <p>[lo al return</p>
    <p>v</p>
    <p>!</p>
    <p>T</p>
    <p>v</p>
    <p>lo</p>
    <p>a</p>
    <p>v</p>
    <p>lo</p>
    <p>a</p>
    <p>v</p>
    <p>ret v</p>
    <p>a:  hv; v</p>
    <p>i  hv</p>
    <p>; v</p>
    <p>i</p>
    <p>v</p>
    <p>ret v</p>
    <p>! a:  hv; v</p>
    <p>i</p>
    <p>[lo al transfer</p>
    <p>v</p>
    <p>!</p>
    <p>T</p>
    <p>v</p>
    <p>lo</p>
    <p>a</p>
    <p>v</p>
    <p>v</p>
    <p>C</p>
    <p>a:  hv; v</p>
    <p>i ! a:  hv; v</p>
    <p>i</p>
  </div>
  <div class="page">
    <p>[send all</p>
    <p>v</p>
    <p>!</p>
    <p>C</p>
    <p>v</p>
    <p>lo</p>
    <p>a</p>
    <p>v</p>
    <p>:lo</p>
    <p>a</p>
    <p>v</p>
    <p>a:  hv; v</p>
    <p>i</p>
    <p>v</p>
    <p>all! v</p>
    <p>! a:  hv; v</p>
    <p>i  hv</p>
    <p>; v</p>
    <p>i</p>
    <p>[re eive all</p>
    <p>v</p>
    <p>!</p>
    <p>C</p>
    <p>v</p>
    <p>:lo</p>
    <p>a</p>
    <p>v</p>
    <p>lo</p>
    <p>a</p>
    <p>v</p>
    <p>:a tivea</p>
    <p>a:</p>
    <p>v</p>
    <p>all? v</p>
    <p>! a:  hv</p>
    <p>;v</p>
    <p>i</p>
    <p>[send return</p>
    <p>:lo</p>
    <p>a</p>
    <p>v</p>
    <p>lo</p>
    <p>a</p>
    <p>v</p>
    <p>return v</p>
    <p>a:  hv</p>
    <p>;v</p>
    <p>i</p>
    <p>v</p>
    <p>ret! v</p>
    <p>! a:</p>
    <p>[re eive return</p>
    <p>v</p>
    <p>!</p>
    <p>T</p>
    <p>v</p>
    <p>lo</p>
    <p>a</p>
    <p>v</p>
    <p>:lo</p>
    <p>a</p>
    <p>v</p>
    <p>(v</p>
    <p>) = (v</p>
    <p>)</p>
    <p>a:  hv; v</p>
    <p>i  hv</p>
    <p>; v</p>
    <p>i</p>
    <p>v</p>
    <p>ret? v</p>
    <p>! a:  hv; v</p>
    <p>i</p>
  </div>
  <div class="page">
    <p>Lo al tra e AirFran e applet</p>
    <p>AirFran e:</p>
    <p>P.debit.Med all? AF.logFull</p>
    <p>!</p>
    <p>hP.debit.Med; AF.logFulli</p>
    <p>!</p>
    <p>hP.debit.Med; AF.logFull.Med1i</p>
    <p>AF.logFull.Med1 all! P.getTrs</p>
    <p>!</p>
    <p>hP.debit.Med; AF.logFull.Med1i</p>
    <p>hAF.logFull.Med1; P.getTrsi</p>
    <p>P.getTrs.Ret ret? AF.logFull.Med1</p>
    <p>!</p>
    <p>hP.debit.Med; AF.logFull.Med2i</p>
    <p>AF.logFull.Med2 all! RaC.getBalan e</p>
    <p>!</p>
    <p>: : :</p>
  </div>
  <div class="page">
    <p>Transition rules for omposite states</p>
    <p>[tau</p>
    <p>A</p>
    <p>! A</p>
    <p>A</p>
    <p>j A</p>
    <p>! A</p>
    <p>j A</p>
    <p>[syn hro</p>
    <p>A</p>
    <p>v</p>
    <p>l? v</p>
    <p>! A</p>
    <p>A</p>
    <p>v</p>
    <p>l! v</p>
    <p>! A</p>
    <p>` 2 all; ret</p>
    <p>A</p>
    <p>j A</p>
    <p>v</p>
    <p>l v</p>
    <p>! A</p>
    <p>j A</p>
    <p>[propagation</p>
    <p>A</p>
    <p>v</p>
    <p>l?! v</p>
    <p>! A</p>
    <p>:lo</p>
    <p>A</p>
    <p>v</p>
    <p>:lo</p>
    <p>A</p>
    <p>v</p>
    <p>A</p>
    <p>j A</p>
    <p>v</p>
    <p>l?! v</p>
    <p>! A</p>
    <p>j A</p>
  </div>
  <div class="page">
    <p>Fragment of the global tra e</p>
    <p>P: j AF: j RaC:</p>
    <p>User.P all? P.debit</p>
    <p>!</p>
    <p>P: hUser.P; P.debiti j AF: j RaC: !</p>
    <p>P: hUser.P; P.debit.Medi j AF: j RaC:</p>
    <p>P.debit.Med all AF.logFull</p>
    <p>!</p>
    <p>P: hUser.P; P.debit.Medi  hP.debit.Med; AF.logFulli j</p>
    <p>AF: hP.debit.Med; AF.logFulli j</p>
    <p>RaC:</p>
    <p>!</p>
    <p>: : :</p>
    <p>P.debit.Ret ret! User.P</p>
    <p>!</p>
    <p>P: j AF: j RaC:</p>
  </div>
  <div class="page">
    <p>The properties</p>
  </div>
  <div class="page">
    <p>Behavioural applet properties</p>
    <p>m</p>
    <p>never triggers m</p>
    <p>( ondentiality, integrity)</p>
    <p>m</p>
    <p>never triggers m</p>
    <p>when it triggers m</p>
    <p>(ex lusion)</p>
    <p>m</p>
    <p>only triggers m</p>
    <p>through m</p>
    <p>(segregation of duty)</p>
    <p>m</p>
    <p>never triggers m</p>
    <p>before m</p>
    <p>(authenti ation)</p>
  </div>
  <div class="page">
    <p>Spe ifying the ele troni purse system</p>
    <p>Invo ation of logFull in AirFran e applet by Purse</p>
    <p>should not trigger</p>
    <p>a all from RentACar to getTrs (to ask the transa tions) in Purse:</p>
    <p>Spe</p>
    <p>= Within AirFran e.logFull</p>
    <p>CannotCall RentACar Purse.getTrs</p>
  </div>
  <div class="page">
    <p>Formulae</p>
    <p>::=  a tive :  ^  8x: [  X X:</p>
    <p>with standard semanti s, and:</p>
    <p>ka tivek</p>
    <p>M</p>
    <p>= fs 2 S</p>
    <p>M</p>
    <p>j s is a tiveg</p>
    <p>kk</p>
    <p>M</p>
    <p>= if [[</p>
    <p>M</p>
    <p>then S</p>
    <p>M</p>
    <p>else ;</p>
  </div>
  <div class="page">
    <p>Atomi formulae</p>
    <p>::= t = t</p>
    <p>return v</p>
    <p>lo al</p>
    <p>A</p>
    <p>v</p>
    <p>with semanti s</p>
    <p>[[t</p>
    <p>= t</p>
    <p>M</p>
    <p>= t</p>
    <p>= t</p>
    <p>[[return v</p>
    <p>M</p>
    <p>= ret(v)</p>
    <p>[[lo al</p>
    <p>A</p>
    <p>v</p>
    <p>M</p>
    <p>= app(v) o urs in A</p>
  </div>
  <div class="page">
    <p>Spe i ation patterns</p>
    <p>Always</p>
    <p>=</p>
    <p>X:  ^ [ X</p>
    <p>^ 8v</p>
    <p>: 8v</p>
    <p>: [v</p>
    <p>all v</p>
    <p>X</p>
    <p>^ [v</p>
    <p>all? v</p>
    <p>X</p>
    <p>^ [v</p>
    <p>all! v</p>
    <p>X</p>
    <p>^ [v</p>
    <p>ret v</p>
    <p>X</p>
    <p>^ [v</p>
    <p>ret? v</p>
    <p>X</p>
    <p>^ [v</p>
    <p>ret! v</p>
    <p>X</p>
    <p>Within v</p>
    <p>=</p>
    <p>: [v</p>
    <p>all v Always</p>
    <p>ret v</p>
    <p>^ [v</p>
    <p>all? v Always</p>
    <p>ret! v</p>
    <p>Always</p>
    <p>v</p>
    <p>is Always  with [v</p>
    <p>v</p>
    <p>X repla ed by [v</p>
    <p>v</p>
    <p>((v</p>
    <p>= v)_X).</p>
  </div>
  <div class="page">
    <p>Spe ifying the individual applets</p>
    <p>Spe</p>
    <p>P</p>
    <p>= lo al</p>
    <p>Purse</p>
    <p>Purse.getTrs ^</p>
    <p>Always (Within Purse.getTrs</p>
    <p>(CallsExtOnly ;))</p>
    <p>Spe</p>
    <p>AF</p>
    <p>= lo al</p>
    <p>AirFran e</p>
    <p>AirFran e.logFull ^</p>
    <p>Always (Within AirFran e.logFull</p>
    <p>(CallsExtOnly Purse.getTrs;</p>
    <p>RentACar.getBalan e))</p>
    <p>Spe</p>
    <p>RaC</p>
    <p>= lo al</p>
    <p>RentACar</p>
    <p>RentACar.getBalan e ^</p>
    <p>Always (Within RentACar.getBalan e</p>
    <p>(CallsExtOnly ;))</p>
  </div>
  <div class="page">
    <p>Corre tness of the de omposition</p>
    <p>Parameterize spe i ations:</p>
    <p>{ repla e on rete applet names by applet variables</p>
    <p>{ repla e on rete method names by program point variables</p>
    <p>Prove:</p>
    <p>a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>: Spe</p>
    <p>P</p>
    <p>;</p>
    <p>a</p>
    <p>AF</p>
    <p>:</p>
    <p>AF</p>
    <p>: Spe</p>
    <p>AF</p>
    <p>;</p>
    <p>a</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>: Spe</p>
    <p>RaC</p>
    <p>` a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>ja</p>
    <p>AF</p>
    <p>:</p>
    <p>AF</p>
    <p>ja</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>: Spe</p>
  </div>
  <div class="page">
    <p>The proof system</p>
  </div>
  <div class="page">
    <p>Proof system</p>
    <p>Proof rules for dierent kind of assertions</p>
    <p>{ atomi formula assertion</p>
    <p>{ satisfa tion assertion A :</p>
    <p>{ transition assertion A</p>
    <p>! A</p>
    <p>{ transfer-edge assertion v !</p>
    <p>T</p>
    <p>v</p>
    <p>{ all-edge assertion v !</p>
    <p>C</p>
    <p>v</p>
    <p>Fixed points handled with dis harge ondition (Dam/Gurov)</p>
    <p>Modal operators introdu e transition assertions, transition rules introdu e</p>
    <p>edge assertions</p>
  </div>
  <div class="page">
    <p>Sequents</p>
    <p>; : : : ;</p>
    <p>n</p>
    <p>`</p>
    <p>; : : : ;</p>
    <p>n</p>
    <p>has intuitive meaning</p>
    <p>^ : : : ^</p>
    <p>n</p>
    <p>)</p>
    <p>_ : : : _</p>
    <p>n</p>
  </div>
  <div class="page">
    <p>Proof system { A tive rules</p>
    <p>(A tL)</p>
    <p>;  =   hv</p>
    <p>; v</p>
    <p>i ; lo al</p>
    <p>a</p>
    <p>v</p>
    <p>`</p>
    <p>fresh ; v</p>
    <p>;v</p>
    <p>; a: : a tive `</p>
    <p>(A tR)</p>
    <p>`  =</p>
    <p>hv</p>
    <p>;v</p>
    <p>i ;   ` lo al</p>
    <p>a</p>
    <p>v</p>
    <p>;</p>
    <p>` a: : a tive;</p>
  </div>
  <div class="page">
    <p>Proof system { Box rules</p>
    <p>(BoxL)</p>
    <p>` A</p>
    <p>! A</p>
    <p>;  ; A</p>
    <p>:  `</p>
    <p>; A : [  `</p>
    <p>(BoxR)</p>
    <p>;A</p>
    <p>! X ` X : ;</p>
    <p>fresh X</p>
    <p>` A : [ ;</p>
  </div>
  <div class="page">
    <p>Proof system { Transition rules</p>
    <p>(SendCallR)</p>
    <p>` v</p>
    <p>!</p>
    <p>C</p>
    <p>v</p>
    <p>;</p>
    <p>` lo al</p>
    <p>a</p>
    <p>v</p>
    <p>;</p>
    <p>; lo al</p>
    <p>a</p>
    <p>v</p>
    <p>`</p>
    <p>`  =   hv; v</p>
    <p>i ;</p>
    <p>` a:</p>
    <p>v</p>
    <p>all! v</p>
    <p>! a:(  hv</p>
    <p>; v</p>
    <p>i);</p>
    <p>(SendCallL)</p>
    <p>[a:(  hv</p>
    <p>; v</p>
    <p>i)=X;</p>
    <p>=   hv; v</p>
    <p>i ;</p>
    <p>v</p>
    <p>!</p>
    <p>C</p>
    <p>v</p>
    <p>; lo al</p>
    <p>a</p>
    <p>v</p>
    <p>` lo al</p>
    <p>a</p>
    <p>v</p>
    <p>; [a:(  hv</p>
    <p>; v</p>
    <p>i)=X</p>
    <p>fresh v;</p>
    <p>; a:</p>
    <p>v</p>
    <p>all! v</p>
    <p>! X `</p>
  </div>
  <div class="page">
    <p>Proof system - Composite transition rules</p>
    <p>(ComPerfL)</p>
    <p>[(YjA</p>
    <p>)=X; A</p>
    <p>v</p>
    <p>lv</p>
    <p>! Y; wf(A</p>
    <p>jA</p>
    <p>); wf(YjA</p>
    <p>) ` lo al</p>
    <p>A</p>
    <p>v</p>
    <p>; lo al</p>
    <p>A</p>
    <p>v</p>
    <p>; [(YjA</p>
    <p>)=X</p>
    <p>[(A</p>
    <p>jY)=X; A</p>
    <p>v</p>
    <p>lv</p>
    <p>! Y; wf(A</p>
    <p>jA</p>
    <p>); wf(A</p>
    <p>jY) ` lo al</p>
    <p>A</p>
    <p>v</p>
    <p>; lo al</p>
    <p>A</p>
    <p>v</p>
    <p>; [(A</p>
    <p>jY)=X</p>
    <p>[(X</p>
    <p>jX</p>
    <p>)=X; A</p>
    <p>v</p>
    <p>l!v</p>
    <p>! X</p>
    <p>; A</p>
    <p>v</p>
    <p>l?v</p>
    <p>! X</p>
    <p>; wf(A</p>
    <p>jA</p>
    <p>); wf(X</p>
    <p>jX</p>
    <p>) ` [(X</p>
    <p>jX</p>
    <p>)=X</p>
    <p>[(X</p>
    <p>jX</p>
    <p>)=X; A</p>
    <p>v</p>
    <p>l?v</p>
    <p>! X</p>
    <p>; A</p>
    <p>v</p>
    <p>l!v</p>
    <p>! X</p>
    <p>; wf(A</p>
    <p>jA</p>
    <p>); wf(X</p>
    <p>jX</p>
    <p>) ` [(X</p>
    <p>jX</p>
    <p>)=X</p>
    <p>fresh X</p>
    <p>;X</p>
    <p>;Y</p>
    <p>; A</p>
    <p>jA</p>
    <p>v</p>
    <p>lv</p>
    <p>! X `</p>
  </div>
  <div class="page">
    <p>Corre tness</p>
    <p>Soundness:</p>
    <p>{ Formalisation of program model and operational semanti s</p>
    <p>{ Formalisation of proof system</p>
    <p>{ Proof rules sound w.r.t. the underlying semanti s</p>
    <p>{ All in PVS</p>
    <p>Completeness: future work</p>
  </div>
  <div class="page">
    <p>Example veri ation</p>
  </div>
  <div class="page">
    <p>The method</p>
    <p>Prove</p>
    <p>a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>: Spe</p>
    <p>P</p>
    <p>;</p>
    <p>a</p>
    <p>AF</p>
    <p>:</p>
    <p>AF</p>
    <p>: Spe</p>
    <p>AF</p>
    <p>;</p>
    <p>a</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>: Spe</p>
    <p>RaC</p>
    <p>` a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>ja</p>
    <p>AF</p>
    <p>:</p>
    <p>AF</p>
    <p>ja</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>: Spe</p>
    <p>by</p>
    <p>- symboli exe ution to ompute symboli next states</p>
    <p>- identi ation of impossible states</p>
    <p>- loop dete tion to lose o bran hes in proof</p>
  </div>
  <div class="page">
    <p>Some abbreviations</p>
    <p>Spe</p>
    <p>= Within AirFran e.logFull Spe</p>
    <p>Spe</p>
    <p>= CannotCall RentACar Purse.getTrs</p>
    <p>Spe</p>
    <p>P</p>
    <p>= lo al</p>
    <p>Purse</p>
    <p>Purse.getTrs ^ Spe</p>
    <p>Spe</p>
    <p>= Always (Within Purse.getTrs (CallsExtOnly ;))</p>
  </div>
  <div class="page">
    <p>Some abbreviations - 2</p>
    <p>Spe</p>
    <p>AF</p>
    <p>= lo al</p>
    <p>AirFran e</p>
    <p>AirFran e.logFull ^ Spe</p>
    <p>Spe</p>
    <p>= Always (Within AirFran e.logFull Spe</p>
    <p>AF</p>
    <p>)</p>
    <p>Spe</p>
    <p>AF</p>
    <p>= CallsExtOnly Purse.getTrs; RentACar.getBalan e</p>
    <p>Spe</p>
    <p>RaC</p>
    <p>= lo al</p>
    <p>RentACar</p>
    <p>RentACar.getBalan e ^ Spe</p>
    <p>Spe</p>
    <p>= Always (Within RentACar.getBalan e(CallsExtOnly ;))</p>
  </div>
  <div class="page">
    <p>Step 1</p>
    <p>Unfold pattern</p>
    <p>Apply logi al rules to outermost logi al onne tives of Spe</p>
    <p>Two subgoals: fo us on rst</p>
    <p>lo al</p>
    <p>a</p>
    <p>P</p>
    <p>v</p>
    <p>GT</p>
    <p>; lo al</p>
    <p>a</p>
    <p>AF</p>
    <p>v</p>
    <p>LF</p>
    <p>; lo al</p>
    <p>a</p>
    <p>RaC</p>
    <p>v</p>
    <p>GB</p>
    <p>;</p>
    <p>a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>: Spe</p>
    <p>; a</p>
    <p>AF</p>
    <p>:</p>
    <p>AF</p>
    <p>: Spe</p>
    <p>; a</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>: Spe</p>
    <p>` a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>ja</p>
    <p>AF</p>
    <p>:</p>
    <p>AF</p>
    <p>ja</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>: [v</p>
    <p>all v</p>
    <p>LF</p>
    <p>Always</p>
    <p>ret v</p>
    <p>Spe</p>
  </div>
  <div class="page">
    <p>Apply rule BoxR and left transition rules</p>
    <p>Result: nine sequents { nine dierent ways in whi h a perfe t all a tion</p>
    <p>an ome about</p>
    <p>Four subgoals dis arded by Id: a</p>
    <p>AF</p>
    <p>is not involved in ommuni ation</p>
    <p>Two subgoals assume a</p>
    <p>AF</p>
    <p>sends a all to an external v</p>
    <p>LF</p>
    <p>, dis arded by</p>
    <p>SendCallL and Id.</p>
    <p>Three subgoals onsider the dierent ways of produ ing a perfe t all to</p>
    <p>vertex v</p>
    <p>LF</p>
  </div>
  <div class="page">
    <p>v</p>
    <p>LF</p>
    <p>is invoked by a lo al all</p>
    <p>a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>: Spe</p>
    <p>;</p>
    <p>a</p>
    <p>AF</p>
    <p>:</p>
    <p>AF</p>
    <p>: Spe</p>
    <p>;</p>
    <p>a</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>: Spe</p>
    <p>;</p>
    <p>a</p>
    <p>AF</p>
    <p>:</p>
    <p>AF</p>
    <p>v</p>
    <p>all v</p>
    <p>LF</p>
    <p>! X ;</p>
    <p>wf(a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>ja</p>
    <p>AF</p>
    <p>:</p>
    <p>AF</p>
    <p>ja</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>);</p>
    <p>wf(a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>jX ja</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>);</p>
    <p>lo al</p>
    <p>a</p>
    <p>P</p>
    <p>v</p>
    <p>GT</p>
    <p>;</p>
    <p>lo al</p>
    <p>a</p>
    <p>AF</p>
    <p>v</p>
    <p>LF</p>
    <p>;</p>
    <p>lo al</p>
    <p>a</p>
    <p>RaC</p>
    <p>v</p>
    <p>GB</p>
    <p>`</p>
    <p>a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>jX ja</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>: Always</p>
    <p>ret v</p>
    <p>Spe</p>
  </div>
  <div class="page">
    <p>Deriving assumptions about X</p>
    <p>Apply l.h.s. rules</p>
    <p>Apply BoxL to box-formula labeled v</p>
    <p>all v</p>
    <p>LF</p>
    <p>.</p>
    <p>First subgoal: show a</p>
    <p>AF</p>
    <p>:</p>
    <p>AF</p>
    <p>v</p>
    <p>all v</p>
    <p>LF</p>
    <p>! X by Id</p>
    <p>Se ond subgoal:</p>
    <p>lo al</p>
    <p>a</p>
    <p>P</p>
    <p>v</p>
    <p>GT</p>
    <p>; lo al</p>
    <p>a</p>
    <p>AF</p>
    <p>v</p>
    <p>LF</p>
    <p>; lo al</p>
    <p>a</p>
    <p>RaC</p>
    <p>v</p>
    <p>GB</p>
    <p>;</p>
    <p>a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>: Spe</p>
    <p>; X : Always</p>
    <p>ret v</p>
    <p>Spe</p>
    <p>AF</p>
    <p>; a</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>: Spe</p>
    <p>;</p>
    <p>a</p>
    <p>AF</p>
    <p>:</p>
    <p>AF</p>
    <p>v</p>
    <p>all v</p>
    <p>LF</p>
    <p>! X ;</p>
    <p>wf(a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>ja</p>
    <p>AF</p>
    <p>:</p>
    <p>AF</p>
    <p>ja</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>); wf(a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>jX ja</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>)</p>
    <p>` a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>jX ja</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>: Always</p>
    <p>ret v</p>
    <p>Spe</p>
  </div>
  <div class="page">
    <p>Eliminate transition assertion by Lo CallL</p>
    <p>lo al</p>
    <p>a</p>
    <p>P</p>
    <p>v</p>
    <p>GT</p>
    <p>;</p>
    <p>lo al</p>
    <p>a</p>
    <p>AF</p>
    <p>v</p>
    <p>LF</p>
    <p>;</p>
    <p>lo al</p>
    <p>a</p>
    <p>AF</p>
    <p>v</p>
    <p>;</p>
    <p>lo al</p>
    <p>a</p>
    <p>RaC</p>
    <p>v</p>
    <p>GB</p>
    <p>;</p>
    <p>a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>: Spe</p>
    <p>;</p>
    <p>a</p>
    <p>AF</p>
    <p>:</p>
    <p>AF</p>
    <p>hv</p>
    <p>;v</p>
    <p>LF</p>
    <p>i : Always</p>
    <p>ret v</p>
    <p>Spe</p>
    <p>AF</p>
    <p>;</p>
    <p>a</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>: Spe</p>
    <p>;</p>
    <p>AF</p>
    <p>=   hv; v</p>
    <p>i ;</p>
    <p>v</p>
    <p>!</p>
    <p>C</p>
    <p>v</p>
    <p>LF</p>
    <p>;</p>
    <p>wf(a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>ja</p>
    <p>AF</p>
    <p>:</p>
    <p>AF</p>
    <p>ja</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>);</p>
    <p>wf(a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>ja</p>
    <p>AF</p>
    <p>:</p>
    <p>AF</p>
    <p>hv</p>
    <p>; v</p>
    <p>LF</p>
    <p>ija</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>) `</p>
    <p>a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>ja</p>
    <p>AF</p>
    <p>:</p>
    <p>AF</p>
    <p>hv</p>
    <p>; v</p>
    <p>LF</p>
    <p>ija</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>: Always</p>
    <p>ret v</p>
    <p>Spe</p>
  </div>
  <div class="page">
    <p>Analysis of symboli next-state</p>
    <p>Computed next-state:</p>
    <p>a</p>
    <p>P</p>
    <p>:</p>
    <p>P</p>
    <p>ja</p>
    <p>AF</p>
    <p>:</p>
    <p>AF</p>
    <p>hv</p>
    <p>; v</p>
    <p>LF</p>
    <p>ija</p>
    <p>RaC</p>
    <p>:</p>
    <p>RaC</p>
    <p>Show in this symboli next-state formula Always</p>
    <p>ret v</p>
    <p>Spe</p>
    <p>holds:</p>
    <p>{ In this state Spe</p>
    <p>is true: trivial, be ause of wellformedness.</p>
    <p>{ In all possible next states within the all (not labeled v ret v</p>
    <p>)</p>
    <p>Always</p>
    <p>ret v</p>
    <p>Spe</p>
    <p>holds.</p>
    <p>External all: only two possible destinations of all v</p>
    <p>GT</p>
    <p>or v</p>
    <p>GB</p>
    <p>Continue with these states</p>
    <p>Other ases: loop and dis harge</p>
  </div>
  <div class="page">
    <p>Ongoing and future work</p>
    <p>Maximal graph onstru tion - ompleteness for a fragment of the logi</p>
    <p>Con urren y</p>
    <p>Keep notion of method in program model</p>
    <p>Extension of Erlang Veri ation Tool</p>
    <p>Veri ation of individual applets</p>
    <p>Case studies</p>
  </div>
</Presentation>
