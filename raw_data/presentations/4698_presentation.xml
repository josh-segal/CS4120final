<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Temporal Aggregation over Data Streams using Multiple Granularities</p>
    <p>Donghui Zhang Dimitrios Gunopulos Vassilis J. Tsotras</p>
    <p>University of California, Riverside Bernhard Seeger</p>
    <p>University of Marburg, Germany</p>
  </div>
  <div class="page">
    <p>Content  Temporal Aggregation  Motivation  Models  Our Solutions</p>
    <p>fixed storage model  fixed time window model</p>
    <p>Other Aggregations  Conclusions</p>
  </div>
  <div class="page">
    <p>Temporal Aggregation</p>
    <p>time</p>
    <p>key</p>
    <p>t1 t 2</p>
  </div>
  <div class="page">
    <p>Temporal Aggregation</p>
    <p>time</p>
    <p>key</p>
    <p>t1 t 2Given a query interval, compute the total value</p>
    <p>of objects intersecting with it.</p>
  </div>
  <div class="page">
    <p>Temporal Aggregation</p>
    <p>time</p>
    <p>key</p>
    <p>t1 t 2Given a query interval, compute the total value</p>
    <p>of objects intersecting with it.</p>
    <p>aggregate =17</p>
  </div>
  <div class="page">
    <p>Find the number of phone calls made over the past year.</p>
    <p>Compute the total salary of employees from 1995 to 1999.</p>
    <p>Report the total dosage of Aspirin distributed to patients last month.</p>
    <p>Examples</p>
  </div>
  <div class="page">
    <p>SB-tree  [YW01] proposed the SB-tree to</p>
    <p>compute temporal aggregates.  A B+-tree like, disk-based,</p>
    <p>incrementally updateable index.  A specialized index; maintains not</p>
    <p>the original objects, but aggregated information.</p>
    <p>O(logBn) query time and update time.</p>
  </div>
  <div class="page">
    <p>Content  Temporal Aggregation  Motivation  Models  Our Solutions</p>
    <p>fixed storage model  fixed time window model</p>
    <p>Other Aggregations  Conclusions</p>
  </div>
  <div class="page">
    <p>Storage Requirement  A major telecommunication</p>
    <p>company collects 75GB of detailed call data every day, or 27TB every year.</p>
    <p>Even specialized aggregation indices soon grow too large.</p>
  </div>
  <div class="page">
    <p>Stream Model  Stream: ordered sequence of</p>
    <p>points that are read in increasing order.</p>
    <p>Appropriate for network traffic data.</p>
    <p>Data is read normally once, with limited storage space.</p>
  </div>
  <div class="page">
    <p>Straightforward Solution  Discard older data.  E.g. keep information over the past</p>
    <p>week.  Bad: not able to answer queries</p>
    <p>over the past.</p>
  </div>
  <div class="page">
    <p>Content  Temporal Aggregation  Motivation  Models  Our Solutions</p>
    <p>fixed storage model  fixed time window model</p>
    <p>Other Aggregations  Conclusions</p>
  </div>
  <div class="page">
    <p>Idea of Our Solution  Keep full aggregation information</p>
    <p>of recent records, and keep aggregation of older records at a coarser granularity (e.g. instead of aggregating by day, aggregate by month).</p>
  </div>
  <div class="page">
    <p>Practical</p>
    <p>Consider a database that tracks phone call information.</p>
    <p>An aggregation query: find the total calls made between 8:15 and 9:20.</p>
    <p>While aggregating per minute is necessary for recent data, it may not be interesting for over 10 years ago, where aggregating per day is good enough.</p>
  </div>
  <div class="page">
    <p>General Model  Divide the time space (orig, now)</p>
    <p>to multiple segments, aggregating with different granularities.</p>
    <p>orig tdiv1 tdiv2 now</p>
    <p>Aggregate by year</p>
    <p>Aggregate by month</p>
    <p>Aggregate by day</p>
  </div>
  <div class="page">
    <p>Fixed Storage Model  Each segment has a fixed amount</p>
    <p>of storage size.  As data accumulate, automatically</p>
    <p>move to previous segments.</p>
    <p>orig tdiv1 tdiv2 now</p>
    <p>Aggregate by year</p>
    <p>Aggregate by month</p>
    <p>Aggregate by day</p>
  </div>
  <div class="page">
    <p>Fixed Time Window Model  Each segment corresponds to a</p>
    <p>fixed length of time.  E.g. past month: aggregate by day;</p>
    <p>earlier five years: aggregate by month.</p>
    <p>orig tdiv1 tdiv2 now</p>
    <p>Aggregate by year</p>
    <p>Aggregate by month</p>
    <p>Aggregate by day</p>
  </div>
  <div class="page">
    <p>Issues to be Addressed  1. detach and attach:  To increase a dividing time, need to</p>
    <p>detach a bunch of information from the finer-granularity aggregation index, aggregate at coarser granularity and attach to another index.</p>
  </div>
  <div class="page">
    <p>orig tdiv1 tdiv2 now</p>
    <p>Aggregate by year</p>
    <p>Aggregate by month</p>
    <p>Aggregate by day</p>
  </div>
  <div class="page">
    <p>orig tdiv1 tdiv2 now</p>
    <p>Aggregate by year</p>
    <p>Aggregate by month</p>
    <p>Aggregate by day</p>
  </div>
  <div class="page">
    <p>orig tdiv1 tdiv2 now</p>
    <p>Aggregate by year</p>
    <p>Aggregate by month</p>
    <p>Aggregate by day</p>
  </div>
  <div class="page">
    <p>Issues to be Addressed  2. avoid duplicates:  If a record spans multiple</p>
    <p>segments, a query which involves these segments should count the record only once.</p>
    <p>orig tdiv1 tdiv2 now</p>
    <p>Aggregate by year</p>
    <p>r2 r1</p>
  </div>
  <div class="page">
    <p>Issues to be Addressed  2. avoid duplicates:  If a record spans multiple</p>
    <p>segments, a query which involves these segments should count the record only once.</p>
    <p>orig tdiv1 tdiv2 now</p>
    <p>Aggregate by year</p>
    <p>r2 r1</p>
  </div>
  <div class="page">
    <p>Issues to be Addressed  2. avoid duplicates:  If a record spans multiple</p>
    <p>segments, a query which involves these segments should count the record only once.</p>
    <p>orig tdiv1 tdiv2 now</p>
    <p>Aggregate by year</p>
    <p>r2 r1</p>
  </div>
  <div class="page">
    <p>Content  Temporal Aggregation  Motivation  Models  Our Solutions</p>
    <p>fixed storage model  fixed time window model</p>
    <p>Other Aggregations  Conclusions</p>
  </div>
  <div class="page">
    <p>Content  Temporal Aggregation  Motivation  Models  Our Solutions</p>
    <p>fixed storage model  fixed time window model</p>
    <p>Other Aggregations  Conclusions</p>
  </div>
  <div class="page">
    <p>From Interval to Point Objects  temporal aggregate = sum of start</p>
    <p>points dominated by the end time of query minus sum of end points dominated by the start time of query.</p>
    <p>orig time</p>
    <p>total=5</p>
    <p>orig time</p>
    <p>total=9</p>
    <p>=</p>
    <p>orig time</p>
    <p>total=4</p>
  </div>
  <div class="page">
    <p>From Interval to Point Objects  Common to the two sub-problems:</p>
    <p>maintain a set of objects, each having a time and a value, so as to efficiently compute the total value of objects whose times are smaller than a query time.</p>
    <p>Solvable using the SB-tree.</p>
    <p>orig time</p>
    <p>total=9</p>
    <p>orig time</p>
    <p>total=4</p>
  </div>
  <div class="page">
    <p>Structure for Fixed Storage Space  We maintain two indices, one for</p>
    <p>the start points of maintained objects, and the other for the end points. They have the same structure:</p>
  </div>
  <div class="page">
    <p>Structure  Three SB-trees corresponding to</p>
    <p>points in their corresponding segments, aggregating at different granularities;</p>
    <p>snap1: total value of points before tdiv1; snap2: total value of points before tdiv2.</p>
    <p>orig tdiv1 tdiv2 now</p>
    <p>snap1 SBmonth SBday</p>
    <p>snap2 SBvear</p>
  </div>
  <div class="page">
    <p>Avoiding Duplicates  Note: by reducing the interval</p>
    <p>aggregation to point aggregation, we solve the duplicate avoidance issue.</p>
    <p>orig tdiv1 tdiv2 now</p>
    <p>snap1 SBday</p>
    <p>snap2 SBvear</p>
  </div>
  <div class="page">
    <p>Update  To insert an point object, insert into</p>
    <p>the corresponding SB-tree; plus, add to the snap1, snap2 values if applicable.</p>
    <p>orig tdiv1 tdiv2 now</p>
    <p>snap1 SBmonth SBday</p>
    <p>snap2 SBvear</p>
  </div>
  <div class="page">
    <p>Update  To insert an point object, insert into</p>
    <p>the corresponding SB-tree; plus, add to the snap1, snap2 values if applicable.</p>
    <p>orig tdiv1 tdiv2 now</p>
    <p>snap1 SBmonth SBday</p>
    <p>snap2 SBvear</p>
  </div>
  <div class="page">
    <p>Query  To compute the total value of point</p>
    <p>objects to the left of a query time, query a single SB-tree, adding to the result snap1 (or snap2) if applicable.</p>
    <p>orig tdiv1 tdiv2 now</p>
    <p>snap1 SBmonth SBday</p>
    <p>snap2 SBvear</p>
  </div>
  <div class="page">
    <p>Detach &amp; Attach  To advance tdiv2,</p>
    <p>need to detach from SBday and attach to SBmonth.</p>
    <p>tdiv2 now</p>
    <p>SBmonth SBday snap2</p>
    <p>tdiv2 now</p>
    <p>SBmonth SBday snap2</p>
  </div>
  <div class="page">
    <p>tdiv2 now</p>
    <p>SBmonth SBday snap2</p>
    <p>Detach  To detach from SBday,</p>
    <p>start with the root node, remove the sub-trees to the left of the new tdiv2.</p>
    <p>tdiv2 now</p>
    <p>SBmonth SBday snap2</p>
    <p>tdiv2</p>
  </div>
  <div class="page">
    <p>tdiv2 now</p>
    <p>SBmonth SBday snap2</p>
    <p>Detach  If tdiv2 falls in the</p>
    <p>middle of some record, break the sub-tree into two, keeping the right part.</p>
    <p>tdiv2 now</p>
    <p>SBmonth SBday snap2</p>
    <p>tdiv2</p>
  </div>
  <div class="page">
    <p>tdiv2 now</p>
    <p>SBmonth SBday snap2</p>
    <p>Attach  To attach to SBmonth</p>
    <p>(aggregated at coarser granularity) needs more work.</p>
    <p>Two algorithms.</p>
    <p>tdiv2 now</p>
    <p>SBmonth SBday snap2</p>
  </div>
  <div class="page">
    <p>tdiv2 now</p>
    <p>SBmonth SBday snap2</p>
    <p>Attach  Algorithm 1: find for</p>
    <p>each month in the green region, the total value of points in that month. O(M logBN).  M: number of months;  N: number of leaf</p>
    <p>elements in SBday.</p>
    <p>tdiv2 now</p>
    <p>SBmonth SBday snap2</p>
  </div>
  <div class="page">
    <p>tdiv2 now</p>
    <p>SBmonth SBday snap2</p>
    <p>Attach  Algorithm 2: browse</p>
    <p>the detached part of SBday to construct a linear array of aggregates; traverse this array to construct the points to be inserted in SBmonth.</p>
    <p>O(N).</p>
    <p>tdiv2 now</p>
    <p>SBmonth SBday snap2</p>
  </div>
  <div class="page">
    <p>tdiv2 now</p>
    <p>SBmonth SBday snap2</p>
    <p>Attach  O(M logBN) vs. O(N)</p>
    <p>M: number of months;  N: number of leaf</p>
    <p>elements in SBday.  Dynamically choose</p>
    <p>algorithm when M and N are known.</p>
    <p>tdiv2 now</p>
    <p>SBmonth SBday snap2</p>
  </div>
  <div class="page">
    <p>Complexity  Given storage limit = S disk pages,</p>
    <p>each page holds up to B records;  Allow k granularities;  The complexity of our temporal</p>
    <p>aggregation solution with fixed storage:  Query: O(logB(S/k))  Update: O(k logB(S/k))</p>
  </div>
  <div class="page">
    <p>Content  Temporal Aggregation  Motivation  Models  Our Solutions</p>
    <p>fixed storage model  fixed time window model</p>
    <p>Other Aggregations  Conclusions</p>
  </div>
  <div class="page">
    <p>Solution for Fixed Time Window  Again, we maintain two indices,</p>
    <p>one for the start points and the other for the end points of objects.</p>
    <p>For simplicity, assume two granularities.</p>
    <p>Before t, coarser; after t, finer.  Distance between t and now: in</p>
    <p>range [w, 2w).</p>
  </div>
  <div class="page">
    <p>Structure for Fixed Time Window  SI: an sparse index (i.e. at coarse</p>
    <p>granularity). DI: an dense index.  Separate the dense index after t into</p>
    <p>two parts, while maintaining sparse indexes for them as well.</p>
    <p>orig t t+w now</p>
    <p>snap1 snap2</p>
    <p>SI0 DI1</p>
    <p>SI1</p>
    <p>DI2</p>
    <p>SI2</p>
    <p>t+2w</p>
    <p>snap3</p>
  </div>
  <div class="page">
    <p>Query &amp; Update</p>
    <p>Similar to the previous case.</p>
    <p>orig t t+w now</p>
    <p>snap1 snap2</p>
    <p>SI0 DI1</p>
    <p>SI1</p>
    <p>DI2</p>
    <p>SI2</p>
    <p>t+2w</p>
    <p>snap3</p>
  </div>
  <div class="page">
    <p>Advancing the Dividing Time</p>
    <p>orig t t+w (now)</p>
    <p>snap1 snap2</p>
    <p>SI0 DI1</p>
    <p>SI1</p>
    <p>DI2</p>
    <p>SI2</p>
    <p>t+2w</p>
    <p>snap3  integrate SI1 to</p>
    <p>SI0  Discard DI1, SI1  Create DI2, SI2</p>
    <p>orig t+w (now)</p>
    <p>snap1</p>
    <p>SI0 DI1</p>
    <p>SI1</p>
    <p>t+2w</p>
    <p>snap2</p>
    <p>DI2</p>
    <p>SI2</p>
    <p>snap3</p>
    <p>t+3w</p>
  </div>
  <div class="page">
    <p>Experimental Setup</p>
    <p>dataset: 10 million updates  time space: 40 years  by-minute window size: average</p>
    <p>distance between t and now  Algorithms:</p>
    <p>SB_min: single SB-tree by minute;  SB_day: single SB-tree by day;  SB_FTW: fixed time window;</p>
  </div>
  <div class="page">
    <p>Performance</p>
    <p>Query time</p>
    <p>SB_min</p>
    <p>SB_day</p>
    <p>SB_FTW</p>
    <p>SB_min</p>
    <p>SB_day</p>
    <p>SB_FTW</p>
    <p>Index size</p>
    <p>#MB #sec</p>
  </div>
  <div class="page">
    <p>Content  Temporal Aggregation  Motivation  Models  Our Solutions</p>
    <p>fixed storage model  fixed time window model</p>
    <p>Other Aggregations  Conclusions</p>
  </div>
  <div class="page">
    <p>Other Aggregation Problems  range-temporal aggregation: find</p>
    <p>how many phone calls were made in the 626 area over the past 10 months.</p>
    <p>spatio-temporal aggregation: given a spatial region, compute the total volume of rainfalls in this region over the past 5 years.</p>
  </div>
  <div class="page">
    <p>Range-temporal aggregation: MVSBtree [PODS01]</p>
    <p>Spatio-temporal aggregation: BA-tree [PODS02]</p>
    <p>Extend to fixed time window model.</p>
    <p>orig t t+w now</p>
    <p>snap1 snap2</p>
    <p>SI0 DI1</p>
    <p>SI1</p>
    <p>DI2</p>
    <p>SI2</p>
    <p>t+2w</p>
    <p>snap3</p>
    <p>Other Aggregation Problems</p>
  </div>
  <div class="page">
    <p>Conclusions  We extended existing temporal aggregation</p>
    <p>solutions to the fixed storage and the fixed time window model.</p>
    <p>As data accumulate and as time advances, our methods systematically aggregate older data at coarser granularities.</p>
    <p>Also apply to the range-temporal and spatio-temporal aggregation problems.</p>
  </div>
</Presentation>
