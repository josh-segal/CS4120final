<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Maximum Benefit from a Minimal HTM</p>
    <p>Owen Hofmann, Chris Rossbach, and Emmett Witchel</p>
    <p>The University of Texas at Austin</p>
  </div>
  <div class="page">
    <p>Concurrency is here Core count ever</p>
    <p>increasing Parallel programming</p>
    <p>is difficult  Synchronization perilous  Performance/complexity</p>
    <p>Many ideas for simpler parallelism  TM, Galois, MapReduce</p>
  </div>
  <div class="page">
    <p>Transactional memory Better performance from simple code</p>
    <p>Change performance/complexity tradeof</p>
    <p>Replace locking with memory transactions  Optimistically execute in parallel  Track read/write sets, roll back on conflict  WA(RBWB) !=   Commit successful changes</p>
  </div>
  <div class="page">
    <p>TM ain't easy TM must be fast</p>
    <p>Lose benefits of concurrency</p>
    <p>TM must be unbounded  Keeping within size not easy programming</p>
    <p>model</p>
    <p>TM must be realizable  Implementing TM an important first step</p>
  </div>
  <div class="page">
    <p>TM ain't easy</p>
    <p>Version and detect conflicts with existing structures  Cache coherence, store bufer</p>
    <p>Fast Realizabl e</p>
    <p>Unbounde d</p>
    <p>Best-efort HTM</p>
  </div>
  <div class="page">
    <p>TM ain't easy</p>
    <p>Version and detect conflicts with existing structures  Cache coherence, store bufer</p>
    <p>Simple modifications to processor  Very realizable (stay tuned for Sun Rock)</p>
    <p>Fast Realizabl e</p>
    <p>Unbounde d</p>
    <p>Best-efort HTM</p>
  </div>
  <div class="page">
    <p>TM ain't easy</p>
    <p>Version and detect conflicts with existing structures  Cache coherence, store bufer</p>
    <p>Simple modifications to processor  Very realizable (stay tuned for Sun Rock)</p>
    <p>Resource-limited  Cache size/associativity, store bufer size</p>
    <p>Fast Realizabl e</p>
    <p>Unbounde d</p>
    <p>Best-efort HTM</p>
  </div>
  <div class="page">
    <p>TM ain't easy</p>
    <p>Software endlessly flexible  Transaction size limited only by virtual memory</p>
    <p>Slow  Instrument most memory references</p>
    <p>Fast Realizabl e</p>
    <p>Unbounde d</p>
    <p>Best-efort HTM</p>
    <p>STM</p>
  </div>
  <div class="page">
    <p>TM ain't easy</p>
    <p>Versioning unbounded data in hardware is difficult  Unlikely to be implemented</p>
    <p>Fast Realizabl e</p>
    <p>Unbounde d</p>
    <p>Best-efort HTM</p>
    <p>STM</p>
    <p>Unbounde d HTM</p>
  </div>
  <div class="page">
    <p>TM ain't easy</p>
    <p>Tight marriage of hardware and software  Disadvantages of both?</p>
    <p>Fast Realizabl e</p>
    <p>Unbounde d</p>
    <p>Best-efort HTM</p>
    <p>STM</p>
    <p>Unbounde d HTM</p>
    <p>Hybrid TM ~ ~</p>
  </div>
  <div class="page">
    <p>Fast Realizabl e</p>
    <p>Unbounde d</p>
    <p>Best-efort HTM</p>
    <p>Back to basics</p>
    <p>Cache-based HTM  Speculative updates in L1  Augment cache line with transactional state  Detect conflicts via cache coherence</p>
    <p>Operations outside transactions can conflict  Asymmetric conflict  Detected and handled in strong isolation</p>
  </div>
  <div class="page">
    <p>Fast Realizabl e</p>
    <p>Unbounde d</p>
    <p>Best-efort HTM</p>
    <p>Back to basics</p>
    <p>Transactions bounded by cache  Overflow because of size or associativity  Restart, return reason</p>
    <p>Not all operations supported  Transactions cannot perform I/O</p>
  </div>
  <div class="page">
    <p>Fast Realizabl e</p>
    <p>Unbounde d</p>
    <p>Best-efort HTM</p>
    <p>Back to basics</p>
    <p>Transactions bounded by cache  Software finds another way</p>
    <p>Not all operations supported  Software finds another way</p>
  </div>
  <div class="page">
    <p>Fast Realizabl e</p>
    <p>Unbounde d</p>
    <p>Best-efort HTM</p>
    <p>Maximum benefit</p>
    <p>Creative software and ISA makes best-efort unbounded</p>
    <p>TxLinux  Better performance from simpler synchronization</p>
    <p>Transaction ordering  Make best-efort unbounded</p>
  </div>
  <div class="page">
    <p>Linux: HTM proving ground Large, complex application(s)</p>
    <p>With diferent synchronization Jan. 2001: Linux 2.4</p>
    <p>5 types of synchronization  ~8,000 dynamic spinlocks  Heavy use of Big Kernel Lock</p>
    <p>Dec. 2003: Linux 2.6  8 types of synchronization  ~640,000 dynamic spinlocks  Restricted Big Kernel Lock use</p>
  </div>
  <div class="page">
    <p>Linux: HTM proving ground Large, complex application</p>
    <p>With evolutionary snapshots Linux 2.4</p>
    <p>Simple, coarse synchronization</p>
    <p>Linux 2.6  Complex, fine-grained synchronization</p>
  </div>
  <div class="page">
    <p>Linux: HTM proving ground</p>
    <p>Modified Andrew Benchmark</p>
  </div>
  <div class="page">
    <p>Linux: HTM proving ground</p>
    <p>Modified Andrew Benchmark</p>
  </div>
  <div class="page">
    <p>HTM can help 2.4 Software must back up</p>
    <p>hardware  Use locks</p>
    <p>Cooperative transactional primitives  Replace locking function  Execute speculatively,</p>
    <p>concurrently in HTM  Tolerate overflow, I/O  Restart, (fairly) use locking</p>
    <p>if necessary</p>
    <p>acquire_lock(lo ck)</p>
    <p>release_lock(lo ck)</p>
    <p>acquire_lock(lo ck)</p>
    <p>release_lock(lo ck)</p>
  </div>
  <div class="page">
    <p>HTM can help 2.4 Software must back up</p>
    <p>hardware  Use locks</p>
    <p>Cooperative transactional primitives  Replace locking function  Execute speculatively,</p>
    <p>concurrently in HTM  Tolerate overflow, I/O  Restart, (fairly) use locking</p>
    <p>if necessary</p>
    <p>cx_begin(lock)</p>
    <p>cx_end(lock)</p>
    <p>cx_begin(lock)</p>
    <p>cx_end(lock)</p>
  </div>
  <div class="page">
    <p>HTM can help 2.4 Software must back up</p>
    <p>hardware  Use locks</p>
    <p>Cooperative transactional primitives  Replace locking function  Execute speculatively,</p>
    <p>concurrently in HTM  Tolerate overflow, I/O  Restart, (fairly) use locking</p>
    <p>if necessary</p>
    <p>cx_begin(lock)</p>
    <p>cx_end(lock)</p>
    <p>cx_begin(lock)</p>
    <p>cx_end(lock)</p>
    <p>TX ATX A</p>
    <p>TX BTX B</p>
  </div>
  <div class="page">
    <p>HTM can help 2.4 Software must back up</p>
    <p>hardware  Use locks</p>
    <p>Cooperative transactional primitives  Replace locking function  Execute speculatively,</p>
    <p>concurrently in HTM  Tolerate overflow, I/O  Restart, (fairly) use locking</p>
    <p>if necessary</p>
    <p>cx_begin(lock)</p>
    <p>cx_end(lock)</p>
    <p>cx_begin(lock)</p>
    <p>cx_end(lock)</p>
    <p>TX ATX A</p>
    <p>do_IO() TX B</p>
    <p>do_IO() TX B</p>
  </div>
  <div class="page">
    <p>HTM can help 2.4 Software must back up</p>
    <p>hardware  Use locks</p>
    <p>Cooperative transactional primitives  Replace locking function  Execute speculatively,</p>
    <p>concurrently in HTM  Tolerate overflow, I/O  Restart, (fairly) use locking</p>
    <p>if necessary</p>
    <p>cx_begin(lock)</p>
    <p>cx_end(lock)</p>
    <p>cx_begin(lock)</p>
    <p>cx_end(lock)</p>
    <p>TX ATX A</p>
    <p>Locking BLocking B</p>
  </div>
  <div class="page">
    <p>HTM can help 2.4 Software must back up</p>
    <p>hardware  Use locks</p>
    <p>Cooperative transactional primitives  Replace locking function  Execute speculatively,</p>
    <p>concurrently in HTM  Tolerate overflow, I/O  Restart, (fairly) use locking</p>
    <p>if necessary</p>
    <p>cx_begin(lock)</p>
    <p>cx_end(lock)</p>
    <p>cx_begin(lock)</p>
    <p>cx_end(lock)</p>
    <p>TX ATX A</p>
    <p>Locking BLocking B</p>
  </div>
  <div class="page">
    <p>Adding HTM Spinlocks: good fit for best-efort</p>
    <p>transactions  Short, performance-critical synchronization  cxspinlocks (SOSP '07)</p>
    <p>2.4 needs cooperative transactional mutexes  Must support blocking  Complicated interactions with BKL  cxmutex  Must modify wakeup behavior</p>
  </div>
  <div class="page">
    <p>Adding HTM, cont. Reorganize data structures</p>
    <p>Linked lists  Shared counters  ~120 lines of code</p>
    <p>Atomic lock acquire  Record locks  Acquire in transaction  Commit changes</p>
    <p>Linux 2.4  TxLinux 2.4  Change synchronization, not</p>
    <p>use</p>
    <p>cx_begin(lock)</p>
    <p>cx_end(lock)</p>
    <p>cx_begin(lock)</p>
    <p>cx_end(lock)</p>
    <p>stat++ TX B</p>
    <p>stat++ TX B</p>
  </div>
  <div class="page">
    <p>Adding HTM, cont. Reorganize data structures</p>
    <p>Linked lists  Shared counters  ~120 lines of code</p>
    <p>Atomic lock acquire  Record locks  Acquire in transaction  Commit changes</p>
    <p>Linux 2.4  TxLinux 2.4  Change synchronization, not</p>
    <p>use</p>
    <p>cx_begin(lock)</p>
    <p>cx_end(lock)</p>
    <p>cx_begin(lock)</p>
    <p>cx_end(lock)</p>
    <p>stat[CPU]++ TX B</p>
    <p>stat[CPU]++ TX B</p>
  </div>
  <div class="page">
    <p>Adding HTM, cont. Reorganize data structures</p>
    <p>Linked lists  Shared counters  ~120 lines of code</p>
    <p>Atomic lock acquire  Record locks  Acquire in transaction  Commit changes</p>
    <p>Linux 2.4  TxLinux 2.4  Change synchronization, not</p>
    <p>use</p>
    <p>cx_begin(lock)</p>
    <p>do_IO()</p>
    <p>cx_end(lock)</p>
    <p>cx_begin(lock)</p>
    <p>do_IO()</p>
    <p>cx_end(lock)</p>
    <p>TX BTX B</p>
  </div>
  <div class="page">
    <p>Adding HTM, cont. Reorganize data structures</p>
    <p>Linked lists  Shared counters  ~120 lines of code</p>
    <p>Atomic lock acquire  Record locks  Acquire in transaction  Commit changes</p>
    <p>Linux 2.4  TxLinux 2.4  Change synchronization, not</p>
    <p>use</p>
    <p>cx_begin(lock)</p>
    <p>do_IO()</p>
    <p>cx_end(lock)</p>
    <p>cx_begin(lock)</p>
    <p>do_IO()</p>
    <p>cx_end(lock)</p>
    <p>acquire_locks() TX B</p>
    <p>acquire_locks() TX B</p>
  </div>
  <div class="page">
    <p>Adding HTM, cont. Reorganize data structures</p>
    <p>Linked lists  Shared counters  ~120 lines of code</p>
    <p>Atomic lock acquire  Record locks  Acquire in transaction  Commit changes</p>
    <p>Linux 2.4  TxLinux 2.4  Change synchronization, not</p>
    <p>use</p>
    <p>cx_begin(lock)</p>
    <p>do_IO()</p>
    <p>cx_end(lock)</p>
    <p>cx_begin(lock)</p>
    <p>do_IO()</p>
    <p>cx_end(lock)</p>
    <p>do_IO() Locking B</p>
    <p>do_IO() Locking B</p>
  </div>
  <div class="page">
    <p>Evaluating TxLinux MAB</p>
    <p>Modified Andrew Benchmark dpunish</p>
    <p>Stress dcache synchronization find</p>
    <p>Parallel find + grep config</p>
    <p>Parallel software package configure pmake</p>
    <p>Parallel make</p>
  </div>
  <div class="page">
    <p>Evaluation: MAB</p>
    <p>2.4 wastes 63% kernel time synchronizing</p>
  </div>
  <div class="page">
    <p>Evaluation: dpunish</p>
    <p>2.4 wastes 57% kernel time synchronizing</p>
  </div>
  <div class="page">
    <p>Evaluation: config</p>
    <p>2.4 wastes 30% kernel time synchronizing</p>
  </div>
  <div class="page">
    <p>From kernel to user Best-efort HTM means simpler locking</p>
    <p>code  Good programming model for kernel  Fall back on locking when necessary  Still permits concurrency</p>
    <p>HTM promises transactions  Good model for user  Need software synchronization fallback  Dont want to expose to user  Want concurrency</p>
  </div>
  <div class="page">
    <p>Software, save me! HTM falls back on software transactions</p>
    <p>Global lock  STM</p>
    <p>Concurrency  Conflict detection  HTM workset in cache  STM workset in memory  Global lock  no workset</p>
    <p>Communicate between disjoint SW and HW  No shared data structures</p>
  </div>
  <div class="page">
    <p>Hardware, save me! HTM has strong isolation</p>
    <p>Detect conflicts with software  Restart hardware transaction  Only if hardware already has value in</p>
    <p>read/write set</p>
    <p>Transaction ordering  Commit protocol for hardware  Wait for concurrent software TX  Resolve inconsistencies  Hardware/OS contains bad side efects</p>
  </div>
  <div class="page">
    <p>Transaction ordering</p>
    <p>char* rchar* r int idxint idx</p>
  </div>
  <div class="page">
    <p>Transaction ordering</p>
    <p>Transaction A</p>
    <p>begin_transaction()</p>
    <p>r[idx] = 0xFF</p>
    <p>end_transaction()</p>
    <p>Transaction A</p>
    <p>begin_transaction()</p>
    <p>r[idx] = 0xFF</p>
    <p>end_transaction()</p>
    <p>Transaction B</p>
    <p>begin_transaction()</p>
    <p>r = new_array</p>
    <p>idx = new_idx</p>
    <p>end_transaction()</p>
    <p>Transaction B</p>
    <p>begin_transaction()</p>
    <p>r = new_array</p>
    <p>idx = new_idx</p>
    <p>end_transaction()</p>
    <p>Invariant: idx is valid for r</p>
    <p>char* rchar* r int idxint idx</p>
  </div>
  <div class="page">
    <p>Transaction ordering</p>
    <p>Transaction A</p>
    <p>begin_transaction()</p>
    <p>r[idx] = 0xFF</p>
    <p>end_transaction()</p>
    <p>Transaction A</p>
    <p>begin_transaction()</p>
    <p>r[idx] = 0xFF</p>
    <p>end_transaction()</p>
    <p>Transaction B</p>
    <p>begin_transaction()</p>
    <p>r = new_array</p>
    <p>idx = new_idx</p>
    <p>end_transaction()</p>
    <p>Transaction B</p>
    <p>begin_transaction()</p>
    <p>r = new_array</p>
    <p>idx = new_idx</p>
    <p>end_transaction()</p>
    <p>Invariant: idx is valid for r Inconsistent read causes bad data write</p>
    <p>char* rchar* r int idxint idx</p>
  </div>
  <div class="page">
    <p>Transaction ordering</p>
    <p>A(HW)</p>
    <p>B(HW )</p>
    <p>read: write:</p>
    <p>read: write:</p>
    <p>r = old_arrayr = old_array</p>
    <p>idx = old_idxidx = old_idxtimetime</p>
    <p>r=new_array idx=new_idx</p>
    <p>r[idx] = 0xFF</p>
  </div>
  <div class="page">
    <p>Transaction ordering</p>
    <p>A(HW)</p>
    <p>B(HW )</p>
    <p>read: write: r</p>
    <p>read: write:</p>
    <p>r = new_arrayr = new_array</p>
    <p>idx = old_idxidx = old_idxtimetime</p>
    <p>r[idx] = 0xFF</p>
    <p>r=new_array idx=new_idx</p>
  </div>
  <div class="page">
    <p>r[idx] = 0xFF</p>
    <p>timetime</p>
    <p>Transaction ordering</p>
    <p>A(HW)</p>
    <p>B(HW )</p>
    <p>read: write: r</p>
    <p>read: r write:</p>
    <p>r = new_arrayr = new_array</p>
    <p>idx = old_idxidx = old_idx</p>
    <p>r=new_array idx=new_idx</p>
    <p>Conflict!Conflict!</p>
  </div>
  <div class="page">
    <p>r[idx] = 0xFF</p>
    <p>timetime</p>
    <p>Transaction ordering</p>
    <p>A(HW)</p>
    <p>B(HW )</p>
    <p>read: write: r</p>
    <p>read: write:</p>
    <p>r = new_arrayr = new_array</p>
    <p>idx = old_idxidx = old_idx</p>
    <p>r=new_array idx=new_idx</p>
    <p>RestartRestart</p>
  </div>
  <div class="page">
    <p>Transaction ordering</p>
    <p>A(HW)</p>
    <p>B(HW )</p>
    <p>read: write:</p>
    <p>read: write:</p>
    <p>r = old_arrayr = old_array</p>
    <p>idx = old_idxidx = old_idxtimetime</p>
    <p>r=new_array idx=new_idx</p>
    <p>r[idx] = 0xFF</p>
  </div>
  <div class="page">
    <p>r=new_array idx=new_idx</p>
    <p>Transaction ordering</p>
    <p>A(SW)</p>
    <p>B(HW )read: write:</p>
    <p>idx = old_idxidx = old_idx</p>
    <p>r = old_arrayr = old_array</p>
    <p>timetime</p>
    <p>r[idx] = 0xFF</p>
  </div>
  <div class="page">
    <p>r=new_array idx=new_idx</p>
    <p>Transaction ordering</p>
    <p>A(SW)</p>
    <p>B(HW )read: write:</p>
    <p>idx = old_idxidx = old_idx</p>
    <p>r = new_arrayr = new_array</p>
    <p>timetime</p>
    <p>r[idx] = 0xFF</p>
  </div>
  <div class="page">
    <p>r=new_array idx=new_idx</p>
    <p>r[idx] = 0xFF</p>
    <p>timetime</p>
    <p>Transaction ordering</p>
    <p>A(SW)</p>
    <p>B(HW )read: r write:</p>
    <p>idx = old_idxidx = old_idx</p>
    <p>r = new_arrayr = new_arrayConflict not</p>
    <p>detected</p>
    <p>Conflict not</p>
    <p>detected</p>
  </div>
  <div class="page">
    <p>Transaction ordering</p>
    <p>new_array[old_idx] = 0xFF</p>
    <p>A(SW)</p>
    <p>B(HW )read: r, idx write: r[idx]</p>
    <p>idx = old_idxidx = old_idx</p>
    <p>r = new_arrayr = new_array</p>
    <p>timetime</p>
    <p>r=new_array idx=new_idx</p>
    <p>r[idx] = 0xFF</p>
  </div>
  <div class="page">
    <p>Transaction ordering</p>
    <p>new_array[old_idx] = 0xFF</p>
    <p>A(SW)</p>
    <p>B(HW )read: r, idx write: r[idx]</p>
    <p>idx = old_idxidx = old_idx</p>
    <p>r = new_arrayr = new_array</p>
    <p>timetime</p>
    <p>r=new_array idx=new_idx</p>
    <p>r[idx] = 0xFFOh, no!Oh, no!</p>
  </div>
  <div class="page">
    <p>timetime</p>
    <p>Transaction ordering</p>
    <p>Hardware contains efects of B  Unless B commits</p>
    <p>A(SW)</p>
    <p>B(HW )read: r, idx write: r[idx]</p>
    <p>idx = old_idxidx = old_idx</p>
    <p>r = new_arrayr = new_array</p>
    <p>r=new_array idx=new_idx</p>
    <p>r[idx] = 0xFF</p>
  </div>
  <div class="page">
    <p>timetime</p>
    <p>Transaction ordering</p>
    <p>A(SW)</p>
    <p>B(HW )read: r, idx write: r[idx]</p>
    <p>idx = old_idxidx = old_idx</p>
    <p>r = new_arrayr = new_array</p>
    <p>r=new_array idx=new_idx</p>
    <p>r[idx] = 0xFF</p>
    <p>Hardware contains efects of B  Unless B commits</p>
  </div>
  <div class="page">
    <p>timetime</p>
    <p>Transaction ordering</p>
    <p>A(SW)</p>
    <p>B(HW )read: r, idx write: r[idx]</p>
    <p>r = new_arrayr = new_array</p>
    <p>r=new_array idx=new_idx</p>
    <p>r[idx] = 0xFF</p>
    <p>Hardware contains efects of B  Unless B commits</p>
    <p>idx = new_idxidx = new_idx</p>
  </div>
  <div class="page">
    <p>timetime</p>
    <p>Transaction ordering</p>
    <p>A(SW)</p>
    <p>B(HW )read: r, idx write: r[idx]</p>
    <p>r = new_arrayr = new_array</p>
    <p>r=new_array idx=new_idx</p>
    <p>r[idx] = 0xFF</p>
    <p>Hardware contains efects of B  Unless B commits</p>
    <p>idx = new_idxidx = new_idx</p>
    <p>Asymmetr ic</p>
    <p>conflict!</p>
    <p>Asymmetr ic</p>
    <p>conflict!</p>
  </div>
  <div class="page">
    <p>timetime</p>
    <p>Transaction ordering</p>
    <p>A(SW)</p>
    <p>B(HW )read: a, idx write: a[idx]</p>
    <p>r = new_arrayr = new_array</p>
    <p>r=new_array idx=new_idx</p>
    <p>r[idx] = 0xFFRestartRestart</p>
    <p>Hardware contains efects of B  Unless B commits</p>
    <p>idx = new_idxidx = new_idx</p>
  </div>
  <div class="page">
    <p>Software + hardware mechanisms Commit protocol</p>
    <p>Hardware commit waits for any current software TX</p>
    <p>Implemented as sequence lock Operating system</p>
    <p>Inconsistent data can cause spurious fault  Resolve faults by TX restart</p>
    <p>Hardware  Even inconsistent TX must commit</p>
    <p>correctly  Pass commit protocol address to transaction_begin()</p>
  </div>
  <div class="page">
    <p>Transaction ordering Safe, concurrent hardware and software Evaluated on STAMP benchmarks</p>
    <p>ssca2  graph kernels  vacation  reservation system</p>
    <p>High-contention  Low-contention</p>
    <p>yada  Delauney mesh refinement</p>
    <p>Best-efort + Single Global Lock STM (ordered)</p>
    <p>Idealized HTM (free)</p>
  </div>
  <div class="page">
    <p>Evaluation: ssca2</p>
    <p>No overflow  performance == ideal</p>
  </div>
  <div class="page">
    <p>Evaluation: vacation-low</p>
    <p>&lt;1% overflow  performance == ideal</p>
  </div>
  <div class="page">
    <p>Evaluation: vacation-high</p>
    <p>~3% overflow  performance near ideal</p>
  </div>
  <div class="page">
    <p>Evaluation: yada</p>
    <p>~11% overflow  software bottleneck  85% execution spent in software</p>
  </div>
  <div class="page">
    <p>Evaluation Small overflow rates, performance</p>
    <p>near ideal  Typical overflow unknown  TxLinux 2.4: &lt;1%</p>
    <p>Can be limited by software synchronization  Global lock: yada has long critical path  STM can help</p>
  </div>
  <div class="page">
    <p>Related work Best-efort HTM</p>
    <p>Herlihy &amp; Moss ISCA '93  Sun Rock (Dice et al. ASPLOS '09)</p>
    <p>Speculative Lock Elision  Rajwar &amp; Goodman MICRO '01, ASPLOS '02</p>
    <p>Hybrid TM  Damron et al. ASPLOS '06  Saha et al. MICRO '06  Shriraman et al. TRANSACT '06</p>
  </div>
  <div class="page">
    <p>We have the technology TxLinux 2.4</p>
    <p>Add concurrency to simpler locking</p>
    <p>Transaction ordering  Best-efort becomes unbounded</p>
    <p>Creative software + simple ISA additions</p>
  </div>
</Presentation>
