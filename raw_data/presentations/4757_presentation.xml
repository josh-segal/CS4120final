<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>IncreaseIncrease--Decrease Decrease Congestion Control for Congestion Control for RealReal--time Streaming: time Streaming: ScalabilityScalability</p>
    <p>Dmitri LoguinovDmitri Loguinov City University of New YorkCity University of New York</p>
    <p>Hayder RadhaHayder Radha Michigan State UniversityMichigan State University</p>
  </div>
  <div class="page">
    <p>Motivation  Current Internet video streaming is often constant</p>
    <p>bitrate (CBR), where the rate is determined a-priori</p>
    <p>A user has to click on the desired rate on a web page</p>
    <p>Typical bitrate selections are quite coarse (i.e., 28k, 56k, 100k, 300k)</p>
    <p>Rate adaptation used in current streaming:  Drop one layer upon congestion</p>
    <p>Add one layer to probe for new bandwidth</p>
    <p>Need protocols that can scale video to any bitrate (such as 435 kb/s) while maintaining fairness properties of regular congestion control</p>
  </div>
  <div class="page">
    <p>Motivation (contd)  Given MPEG4 FGS (Fine Granular Scalability), can</p>
    <p>we apply true congestion control to it?</p>
    <p>MPEG4 FGS:  One low-bitrate base layer</p>
    <p>One high-bitrate enhancement layer</p>
    <p>Rescale the enhancement layer by discarding a certain percentage of each frame</p>
    <p>Rate-based streaming</p>
    <p>Can rate-based congestion control scale to a large number of concurrent flows?</p>
    <p>Scalability applies to the number of flows only</p>
  </div>
  <div class="page">
    <p>Overview of the Talk</p>
    <p>Background on congestion &amp; flow control</p>
    <p>Scalability of congestion control</p>
    <p>Study of existing methods in NACK-based protocols</p>
    <p>Limitations of the existing methods</p>
    <p>Ideally-scalable congestion control</p>
    <p>Simulations and experimental results</p>
    <p>Drawbacks</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>Background (Overview)  Flow control is how application sends its packets</p>
    <p>Two types of flow control</p>
    <p>ACK-based (window-based):  receiver acknowledges each received packet</p>
    <p>new packets are sent only if ACKs are being received</p>
    <p>average sending rate r(t) arbitrarily fluctuates</p>
    <p>sender does not know its average rate r(t) a-priori</p>
    <p>NACK-based (rate-based):  receiver acknowledges each lost packet</p>
    <p>new packets are sent regardless of the NACKs</p>
    <p>average sending rate r(t) is known in advance</p>
  </div>
  <div class="page">
    <p>Background (contd)  ACK-based flow control is typically difficult to use in real</p>
    <p>time streaming:  Server must maintain a certain streaming rate for the base layer</p>
    <p>Difficult to decide how to scale the enhancement-layer pictures since future rate r(t) is not known</p>
    <p>Enhancement layer coded at max bitrate R. Scale to target</p>
    <p>rate r(t) by taking r(t)/R percent of each frame.</p>
    <p>Base layer</p>
    <p>Enhancement layer</p>
  </div>
  <div class="page">
    <p>Background (summary)  We look at the problem of providing end-to</p>
    <p>end congestion control for rate-based applications  NACK-based congestion control is usually</p>
    <p>labeled as simply difficult</p>
    <p>ATM/data-link methods exist, but they are inapplicable on the IP+ layers</p>
    <p>We assume a best-effort Internet environment</p>
    <p>QoS (Quality of Service) router support is not available</p>
  </div>
  <div class="page">
    <p>Congestion Control (overview)  Typically many flows share common links of finite</p>
    <p>capacity  After observing packet loss, flows must reduce their rates</p>
    <p>A key aspect of congestion control is convergence to fairness:</p>
    <p>t im e</p>
    <p>s e n d in g ra t e</p>
  </div>
  <div class="page">
    <p>Overview (contd)</p>
    <p>Internet protocols use congestion control that:  reacts to packet loss by decreasing the rate</p>
    <p>reacts to the absence of packet loss by increasing the rate</p>
    <p>Congestion control is executed on discrete timescales of RTT (round-trip delay) units each</p>
    <p>Sending rate during interval i is given by ri</p>
  </div>
  <div class="page">
    <p>Overview (contd)</p>
    <p>Increase-decrease congestion control is summarized as following:</p>
    <p>+</p>
    <p>=+ lossrRr lossnorRr</p>
    <p>r iDi</p>
    <p>iIi i ),(</p>
    <p>),( 1</p>
    <p>RI is the increase function, RD is the decrease function</p>
    <p>Not all functions guarantee convergence to fairness</p>
    <p>Easy to show that RI , RD = constant does not converge</p>
    <p>Hence the add/drop one layer method does not converge to fairness</p>
  </div>
  <div class="page">
    <p>Overview (contd)</p>
    <p>Among linear functions RI and RD, only one method converges to fairness</p>
    <p>This method is called AIMD (Additive Increase, Multiplicative Decrease):</p>
    <p>RI(r) = , RD(r) = r</p>
    <p>AIMD is used in TCP (Transmission Control Protocol)</p>
  </div>
  <div class="page">
    <p>Overview (contd)  Binomial schemes are a special case of I-D</p>
    <p>congestion control (proposed in 2001 by Bansal et al.):</p>
    <p>=</p>
    <p>=</p>
    <p>lrrR</p>
    <p>krrR l</p>
    <p>D</p>
    <p>k I</p>
    <p>Powers (k, l) determine the shape of the increase and decrease curves</p>
    <p>Power l cannot be greater than 1 (otherwise, rates may become negative)</p>
    <p>Necessary condition for convergence is k + l &gt; 0</p>
  </div>
  <div class="page">
    <p>Overview (contd)</p>
    <p>A scheme is TCP-friendly, if it achieves the same throughput as a TCP connection over a shared link</p>
    <p>AIMD is TCP-friendly</p>
    <p>Binomial schemes with k+l = 1 are TCP-friendly</p>
    <p>Two such TCP-friendly schemes were introduced in 2001:  IIAD (Inverse Increase, Additive Decrease) with l = 0, k = 1</p>
    <p>SQRT (Square Root) with l = k = 0.5</p>
    <p>Even though two schemes may have the same throughput, they may differ in other characteristics</p>
    <p>One important characteristic is called scalability</p>
  </div>
  <div class="page">
    <p>Scalability of Congestion Control  Scalability aspects of congestion control have not</p>
    <p>been extensively studied before or even quantified</p>
    <p>We created a new measure of scalability and use it to compare various congestion control schemes</p>
    <p>We define scalability of a scheme as the increase in packet loss as a function of the number of flows n that use the scheme over a shared bottleneck</p>
    <p>Suppose pn is packet loss when n flows use a scheme</p>
    <p>Hence, scalability is described by the packet loss increase factor sn = pn / p1</p>
  </div>
  <div class="page">
    <p>Scalability (contd)  How does scalability matter?</p>
    <p>NACK-based protocols are very sensitive to the scalability aspects of a scheme, much more so than ACK-based protocols</p>
    <p>In ACK-based protocols, upon loss of communication, the sender simply stops, hence increasing stability of the network</p>
    <p>In the absence of feedback, congestion control in NACKbased protocols becomes open-loop, or simply CBR:  If the communication from the receiver is delayed, the sender</p>
    <p>continues stressing the network at the same rate</p>
    <p>Congestion control in NACK protocols is considered very difficult</p>
  </div>
  <div class="page">
    <p>Scalability (contd)  To investigate the scalability of binomial algorithms, we use</p>
    <p>steady-state analysis and continuous fluid approximation</p>
    <p>We compute n-flow packet loss pn:</p>
    <p>( )( )</p>
    <p>+</p>
    <p>++</p>
    <p>+</p>
    <p>/11</p>
    <p>)2( klk</p>
    <p>k</p>
    <p>n nCC</p>
    <p>nk p</p>
    <p>C is the capacity of the bottleneck link</p>
    <p>Packet loss increase factor sn = pn / p1 (describing the scalability of a particular scheme) is given by:</p>
    <p>( ) ).(</p>
    <p>)/()1(2 )1(2 12</p>
    <p>++</p>
    <p>= +</p>
    <p>+  kl</p>
    <p>l</p>
    <p>lkl</p>
    <p>n nO nCk Ckn</p>
    <p>s</p>
  </div>
  <div class="page">
    <p>Scalability (contd)</p>
    <p>This formula can be used to compare the scalability of different schemes</p>
    <p>Schemes with the lowest scalability power l+2k+1 are best</p>
    <p>AIMD is O(n2)</p>
    <p>IIAD is O(n3)</p>
    <p>SQRT is O(n2.5)</p>
    <p>In practice, scalability is typically proportional to nl+2k, but worse-case scalability nl+2k+1 does happen in certain scenarios</p>
  </div>
  <div class="page">
    <p>Scalability Examples  Discrete event simulation below shows three flows under</p>
    <p>different conditions  AIMD1  n1.91(red), AIMD2  n1.27(purple), and IIAD  n2.67(blue):</p>
    <p>number of flows n</p>
    <p>s c a la</p>
    <p>b il</p>
    <p>it y s n</p>
    <p>AIMD1 AIMD2 IIAD</p>
  </div>
  <div class="page">
    <p>Scalability Examples (contd)  Such high loss increases mean that these</p>
    <p>schemes will not be able to provide adequate performance once deployed globally</p>
  </div>
  <div class="page">
    <p>Scalability Limitations</p>
    <p>Among TCP-friendly schemes (i.e., k+l = 1), parameter sn grows as O(n3l)</p>
    <p>Hence, among all TCP-friendly schemes, the one with the largest l scales best</p>
    <p>Recall the restriction on binomial schemes that prevents the scheme from assuming negative rates is: l  1  Example l = 2: new rate r   r 2 cannot be guaranteed to</p>
    <p>be positive for all r &gt; 0, no matter how we select constant</p>
    <p>This is due to the fact that r is considered unlimited (i.e., upper limit is not known a-priori)</p>
  </div>
  <div class="page">
    <p>Scalability Limitations (contd)  Notice that among all TCP-friendly schemes, AIMD</p>
    <p>has the largest l equal to 1</p>
    <p>Hence, AIMD scales best among TCP-friendly schemes</p>
    <p>The only way to improve scalability beyond O(n2) is to somehow find a tight upper bound on sending rate r(t)</p>
    <p>One such upper bound is the bottleneck capacity of an end-to-end path</p>
    <p>The bottleneck capacity (or bottleneck bandwidth) is the speed of the slowest link of an end-to-end path</p>
  </div>
  <div class="page">
    <p>Scalability Limitations (contd)  No prior work considered the bottleneck bandwidth</p>
    <p>in conjunction with congestion control</p>
    <p>Not only do we aim to improve the scalability of AIMD (i.e., O(n2)), we also attempt to achieve ideal-scalability as explained below</p>
    <p>Ideal scalability is such choice of increasedecrease powers that ensures constant packet loss</p>
    <p>In other words, under ideal scalability, pn = p1 for all n</p>
  </div>
  <div class="page">
    <p>Ideal Scalability  Recall that packet loss increases as O(nl+2k+1)</p>
    <p>For ideal scalability we want the power to be zero:</p>
    <p>l+2k+1 = 0</p>
    <p>To maintain convergence to fairness, we need:</p>
    <p>k+l &gt; 0</p>
    <p>Combining both conditions above, we find that the necessary conditions of ideal stability are:</p>
    <p>l &gt; 1 and k &lt; 1</p>
    <p>Hence, we have the same restriction on l that can only be lifted with the knowledge of bottleneck capacity C</p>
  </div>
  <div class="page">
    <p>Ideal Scalability (contd)  Assume that we know bottleneck capacity C</p>
    <p>Rate r is limited by a constant: 0 &lt; r  C</p>
    <p>We introduce a new class of ideally-scalable congestion control (ISCC) that maintains convergence while l+2k+1 equals zero</p>
  </div>
  <div class="page">
    <p>ISCC  Knowing C, we can adjust constants (,) to each path so</p>
    <p>that rate r(t) is never reduced below zero</p>
    <p>At the same time, we want to be able to tune the scheme to achieve different levels of packet loss and efficiency</p>
    <p>One such selection is given by the following:</p>
    <p>= +</p>
    <p>I I</p>
    <p>k</p>
    <p>m m C</p>
    <p>lm Cm</p>
    <p>Dl D</p>
    <p>=</p>
    <p>, 1</p>
    <p>Constant mD is the efficiency factor, where higher values of mD result in higher efficiency (i.e., higher link utilization)</p>
    <p>Constant mI is the aggressiveness factor, where higher values of mI result in less aggressive behavior (i.e., less packet loss)</p>
  </div>
  <div class="page">
    <p>Experiments  Implemented NACK-based congestion control and</p>
    <p>binomial algorithms in our streaming software</p>
    <p>Special module controls the choice of congestion control (IIAD, SQRT, TFRC, ISCC, etc.)</p>
    <p>Tested between a Unix server and a Windows 2000 client, with the number of flows between 2 and 50</p>
    <p>10 minute video sequence coded with MPEG-4 FGS:  14 kb/s base layer</p>
    <p>1,190 kb/s FGS enhancement layer</p>
    <p>Each flow maintained a rate between 14 and 1,204 kb/s during the experiment</p>
  </div>
  <div class="page">
    <p>Experiments (contd)  Setup including two high-speed ethernets on each side of</p>
    <p>the bottleneck T1 links (see below)</p>
    <p>WFQ and WRED (QoS features of routers) were disabled to reflect the current setup of Internet routers</p>
    <p>Cisco 3620</p>
    <p>Cisco 3620</p>
    <p>Cisco 3660 Catalyst</p>
    <p>Client Server</p>
    <p>Catalyst 2912</p>
    <p>T1 T1 10 mb/s 10 mb/s</p>
  </div>
  <div class="page">
    <p>Scalability Results  The following figure shows packet loss pn for all schemes</p>
    <p>as a function of n</p>
    <p>num ber of flow s n</p>
    <p>p a c k e t</p>
    <p>lo s s p n</p>
    <p>AIMD IIAD TFRC ISCC SQRT</p>
  </div>
  <div class="page">
    <p>Scalability Results (contd)  All non-scalable schemes suffered from high packet loss</p>
    <p>rates:  as high as 45% in IIAD (p2 = 0.29%, s50 = 151)  32% in SQRT (p2 = 0.10%, s50 = 268)  27% in TFRC (p2 = 0.27%, s50 = 74)  22% in AIMD (p2 = 0.38%, s50 = 59)</p>
    <p>ISCC maintained virtually constant loss at 3% (p2 = 0.57%, s50 = 5.6)</p>
    <p>In non-scalable schemes, underflow events in the base layer were frequent, even given a large startup delay (3 seconds):  IIAD and SQRT maintained no picture for up to 66% of the time  AIMD and TFRC between 11 and 40% of the time</p>
  </div>
  <div class="page">
    <p>Scalability Results (contd)  The ISCC scheme recovered all base-layer and</p>
    <p>FGS-layer frames before their deadlines</p>
    <p>This in fact represents an ideal performance for the end-user</p>
  </div>
  <div class="page">
    <p>Drawbacks  However, ideal performance comes at a price:</p>
    <p>All flows must acquire consistent estimates of the bandwidth</p>
    <p>Ideally-scalable schemes are too TCP-friendly</p>
    <p>In fact, ISCC will yield bandwidth to TCP due to its lessaggressive behavior</p>
    <p>Differentiated Services (DiffServ) is required in the network</p>
    <p>Efficiency is similar to that of AIMD, but convergence is slower</p>
    <p>The Internet is moving toward DiffServ</p>
    <p>Hence it is possible that UDP and TCP traffic will end up in different router queues</p>
    <p>ISCC is possible in DiffServ-enabled Internet</p>
  </div>
  <div class="page">
    <p>Congestion Control Conclusion</p>
    <p>Applications with rate-based flow control are very sensitive to what kind of congestion control is employed</p>
    <p>Hence, traditional schemes designed for ACK-based protocols are not well suited for NACK-based protocols</p>
    <p>At the same time, ACK-based flow control is poorly suited for real-time streaming</p>
    <p>Consequently, future real-time streaming protocols should only use congestion control that scales well in the presence of a large number of concurrent flows</p>
    <p>One such class of scalable schemes was developed in our work and is called ISCC</p>
  </div>
</Presentation>
