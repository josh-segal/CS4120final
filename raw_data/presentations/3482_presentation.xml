<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Meltdown</p>
    <p>Reading Kernel Memory from User Space</p>
    <p>Moritz Lipp1, Michael Schwarz1, Daniel Gruss1, Thomas Prescher2, Werner Haas2, Anders Fogh3, Jann Horn4, Stefan Mangard1, Paul Kocher5, Daniel Genkin6, Yuval Yarom7, Mike Hamburg8</p>
    <p>tography Research Division</p>
  </div>
  <div class="page">
    <p>Virtual Memory</p>
    <p>Kernel Addresses</p>
    <p>Non-canonical Addresses</p>
    <p>User Addresses</p>
    <p>Virtual Address Space</p>
  </div>
  <div class="page">
    <p>Building the Code</p>
    <p>Find something human readable, e.g., the Linux version</p>
    <p># sudo grep linux_banner /proc/kallsyms ffffffff81a000e0 R linux_banner</p>
  </div>
  <div class="page">
    <p>Building the Code</p>
    <p>char data = *(char*) 0xffffffff81a000e0; printf(&quot;%c\n&quot;, data);</p>
    <p>Any invalid access throws an exception  segmentation fault</p>
  </div>
  <div class="page">
    <p>Building the Code</p>
    <p>char data = *(char*) 0xffffffff81a000e0; printf(&quot;%c\n&quot;, data);</p>
    <p>Any invalid access throws an exception  segmentation fault</p>
  </div>
  <div class="page">
    <p>Memory Isolation</p>
    <p>Userspace Kernelspace</p>
    <p>Applications Operating System Memory</p>
    <p>Kernel is isolated from user space</p>
    <p>This isolation is a combination of</p>
    <p>hardware and software</p>
    <p>User applications cannot access</p>
    <p>anything from the kernel</p>
  </div>
  <div class="page">
    <p>Memory Isolation</p>
    <p>Userspace Kernelspace</p>
    <p>Applications Operating System Memory</p>
    <p>Kernel is isolated from user space</p>
    <p>This isolation is a combination of</p>
    <p>hardware and software</p>
    <p>User applications cannot access</p>
    <p>anything from the kernel</p>
  </div>
  <div class="page">
    <p>Memory Isolation</p>
    <p>Userspace Kernelspace</p>
    <p>Applications Operating System Memory</p>
    <p>Kernel is isolated from user space</p>
    <p>This isolation is a combination of</p>
    <p>hardware and software</p>
    <p>User applications cannot access</p>
    <p>anything from the kernel</p>
  </div>
  <div class="page">
    <p>Paging</p>
    <p>CPU support virtual address spaces to isolate</p>
    <p>processes</p>
    <p>Physical memory is organized in page frames</p>
    <p>Virtual memory pages are mapped to page frames</p>
    <p>using page tables</p>
  </div>
  <div class="page">
    <p>Paging</p>
    <p>CPU support virtual address spaces to isolate</p>
    <p>processes</p>
    <p>Physical memory is organized in page frames</p>
    <p>Virtual memory pages are mapped to page frames</p>
    <p>using page tables</p>
  </div>
  <div class="page">
    <p>Paging</p>
    <p>CPU support virtual address spaces to isolate</p>
    <p>processes</p>
    <p>Physical memory is organized in page frames</p>
    <p>Virtual memory pages are mapped to page frames</p>
    <p>using page tables</p>
  </div>
  <div class="page">
    <p>Address Translation on x86-64</p>
    <p>PML4I (9 b) PDPTI (9 b) PDI (9 b) PTI (9 b) Offset (12 b)</p>
    <p>CR3 PML4</p>
    <p>PML4E 0</p>
    <p>PML4E 1  #PML4I</p>
    <p>PML4E 511</p>
    <p>PDPT</p>
    <p>PDPTE 0</p>
    <p>PDPTE 1  #PDPTI</p>
    <p>PDPTE 511</p>
    <p>Page Directory</p>
    <p>PDE 0</p>
    <p>PDE 1</p>
    <p>PDE #PDI</p>
    <p>PDE 511</p>
    <p>Page Table</p>
    <p>PTE 0</p>
    <p>PTE 1</p>
    <p>PTE #PTI</p>
    <p>PTE 511</p>
    <p>Byte 0</p>
    <p>Byte 1</p>
    <p>Offset</p>
    <p>Byte 4095</p>
  </div>
  <div class="page">
    <p>Address Translation on x86-64</p>
    <p>PML4I (9 b) PDPTI (9 b) PDI (9 b) PTI (9 b) Offset (12 b)</p>
    <p>CR3 PML4</p>
    <p>PML4E 0</p>
    <p>PML4E 1  #PML4I</p>
    <p>PML4E 511</p>
    <p>PDPT</p>
    <p>PDPTE 0</p>
    <p>PDPTE 1  #PDPTI</p>
    <p>PDPTE 511</p>
    <p>Page Directory</p>
    <p>PDE 0</p>
    <p>PDE 1</p>
    <p>PDE #PDI</p>
    <p>PDE 511</p>
    <p>Page Table</p>
    <p>PTE 0</p>
    <p>PTE 1</p>
    <p>PTE #PTI</p>
    <p>PTE 511</p>
    <p>Byte 0</p>
    <p>Byte 1</p>
    <p>Offset</p>
    <p>Byte 4095</p>
  </div>
  <div class="page">
    <p>Page Table Entry</p>
    <p>P RW US WT UC R D S G Ignored</p>
    <p>Physical Page Number</p>
    <p>Ignored X</p>
    <p>User/Supervisor bit defines in which privilege level the page can be</p>
    <p>accessed</p>
  </div>
  <div class="page">
    <p>Direct-physical map</p>
    <p>Physical memory</p>
    <p>User</p>
    <p>Kernel</p>
    <p>247 1</p>
    <p>Kernel is typically mapped into every address space</p>
    <p>Entire physical memory is mapped in the kernel</p>
  </div>
  <div class="page">
    <p>Direct-physical map</p>
    <p>Physical memory</p>
    <p>User</p>
    <p>Kernel</p>
    <p>247 1</p>
    <p>Kernel is typically mapped into every address space</p>
    <p>Entire physical memory is mapped in the kernel</p>
  </div>
  <div class="page">
    <p>Loading an address</p>
    <p>char data = *(char*) 0xffffffff81a000e0; printf(&quot;%c\n&quot;, data);</p>
    <p>We try to load an inaccessible address</p>
    <p>Permission is checked</p>
  </div>
  <div class="page">
    <p>Architecture and Microarchitecture</p>
    <p>Instruction Set Architecture (ISA) is an abstract model of a</p>
    <p>computer (x86, ARMv8, SPARC, )</p>
    <p>Serves as the interface between hardware and software</p>
    <p>Microarchitecture is an actual implementation of the ISA</p>
  </div>
  <div class="page">
    <p>Architecture and Microarchitecture</p>
    <p>Instruction Set Architecture (ISA) is an abstract model of a</p>
    <p>computer (x86, ARMv8, SPARC, )</p>
    <p>Serves as the interface between hardware and software</p>
    <p>Microarchitecture is an actual implementation of the ISA</p>
  </div>
  <div class="page">
    <p>Architecture and Microarchitecture</p>
    <p>Instruction Set Architecture (ISA) is an abstract model of a</p>
    <p>computer (x86, ARMv8, SPARC, )</p>
    <p>Serves as the interface between hardware and software</p>
    <p>Microarchitecture is an actual implementation of the ISA</p>
  </div>
  <div class="page">
    <p>Architecture and Microarchitecture</p>
    <p>Instruction Set Architecture (ISA) is an abstract model of a</p>
    <p>computer (x86, ARMv8, SPARC, )</p>
    <p>Serves as the interface between hardware and software</p>
    <p>Microarchitecture is an actual implementation of the ISA</p>
  </div>
  <div class="page">
    <p>Side-channel Attacks</p>
    <p>Safe software infrastructure does not mean safe execution</p>
    <p>Information leaks because of the underlying hardware</p>
    <p>Exploit unintentional information leakage by side-effects</p>
    <p>Power</p>
    <p>consumption</p>
    <p>Execution</p>
    <p>time CPU caches</p>
  </div>
  <div class="page">
    <p>Side-channel Attacks</p>
    <p>Safe software infrastructure does not mean safe execution</p>
    <p>Information leaks because of the underlying hardware</p>
    <p>Exploit unintentional information leakage by side-effects</p>
    <p>Power</p>
    <p>consumption</p>
    <p>Execution</p>
    <p>time CPU caches</p>
  </div>
  <div class="page">
    <p>Side-channel Attacks</p>
    <p>Safe software infrastructure does not mean safe execution</p>
    <p>Information leaks because of the underlying hardware</p>
    <p>Exploit unintentional information leakage by side-effects</p>
    <p>Power</p>
    <p>consumption</p>
    <p>Execution</p>
    <p>time CPU caches</p>
  </div>
  <div class="page">
    <p>Side-channel Attacks</p>
    <p>Safe software infrastructure does not mean safe execution</p>
    <p>Information leaks because of the underlying hardware</p>
    <p>Exploit unintentional information leakage by side-effects</p>
    <p>Power</p>
    <p>consumption</p>
    <p>Execution</p>
    <p>time CPU caches</p>
  </div>
  <div class="page">
    <p>CPU Cache</p>
  </div>
  <div class="page">
    <p>CPU Cache</p>
  </div>
  <div class="page">
    <p>CPU Cache</p>
  </div>
  <div class="page">
    <p>CPU Cache</p>
  </div>
  <div class="page">
    <p>CPU Cache</p>
  </div>
  <div class="page">
    <p>CPU Cache</p>
  </div>
  <div class="page">
    <p>CPU Cache</p>
  </div>
  <div class="page">
    <p>CPU Cache</p>
  </div>
  <div class="page">
    <p>Memory Access Latency</p>
    <p>104</p>
    <p>Measured access time (CPU cycles)</p>
    <p>N u m b e r o f a c c e s s e s</p>
    <p>Cache hit</p>
    <p>Cache miss</p>
  </div>
  <div class="page">
    <p>Flush+Reload</p>
  </div>
  <div class="page">
    <p>Flush+Reload</p>
  </div>
  <div class="page">
    <p>Flush+Reload</p>
  </div>
  <div class="page">
    <p>Flush+Reload</p>
  </div>
  <div class="page">
    <p>Flush+Reload</p>
  </div>
  <div class="page">
    <p>Flush+Reload</p>
  </div>
  <div class="page">
    <p>Flush+Reload</p>
  </div>
  <div class="page">
    <p>Flush+Reload</p>
  </div>
  <div class="page">
    <p>Out-of-Order Execution E</p>
    <p>xe cu</p>
    <p>ti on</p>
    <p>E ng</p>
    <p>in e</p>
    <p>Reorder buffer</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>Scheduler</p>
    <p>Execution Units</p>
    <p>A L</p>
    <p>U ,A</p>
    <p>E S</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,F</p>
    <p>M A</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,V</p>
    <p>ec t,</p>
    <p>.. .</p>
    <p>A L</p>
    <p>U ,B</p>
    <p>ra nc</p>
    <p>h</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>S to</p>
    <p>re da</p>
    <p>ta</p>
    <p>A G</p>
    <p>U</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>CDB</p>
    <p>M em</p>
    <p>or y</p>
    <p>S ub</p>
    <p>sy st</p>
    <p>em</p>
    <p>Load Buffer Store Buffer</p>
    <p>L1 Data Cache DTLB STLB</p>
    <p>L2 Cache</p>
    <p>F ro</p>
    <p>nt en</p>
    <p>d</p>
    <p>Allocation Queue</p>
    <p>OP  OP  OP  OP</p>
    <p>MUX</p>
    <p>OP  OP  OP  OP</p>
    <p>Instruction Queue</p>
    <p>Instruction Fetch &amp; PreDecode</p>
    <p>OP Cache</p>
    <p>OPs</p>
    <p>Branch Predictor</p>
    <p>L1 Instruction Cache ITLB</p>
    <p>Instructions are</p>
    <p>fetched and decoded in the front-end</p>
    <p>dispatched to the backend</p>
    <p>processed by individual execution units</p>
  </div>
  <div class="page">
    <p>Out-of-Order Execution E</p>
    <p>xe cu</p>
    <p>ti on</p>
    <p>E ng</p>
    <p>in e</p>
    <p>Reorder buffer</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>Scheduler</p>
    <p>Execution Units</p>
    <p>A L</p>
    <p>U ,A</p>
    <p>E S</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,F</p>
    <p>M A</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,V</p>
    <p>ec t,</p>
    <p>.. .</p>
    <p>A L</p>
    <p>U ,B</p>
    <p>ra nc</p>
    <p>h</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>S to</p>
    <p>re da</p>
    <p>ta</p>
    <p>A G</p>
    <p>U</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>CDB</p>
    <p>M em</p>
    <p>or y</p>
    <p>S ub</p>
    <p>sy st</p>
    <p>em</p>
    <p>Load Buffer Store Buffer</p>
    <p>L1 Data Cache DTLB STLB</p>
    <p>L2 Cache</p>
    <p>F ro</p>
    <p>nt en</p>
    <p>d</p>
    <p>Allocation Queue</p>
    <p>OP  OP  OP  OP</p>
    <p>MUX</p>
    <p>OP  OP  OP  OP</p>
    <p>Instruction Queue</p>
    <p>Instruction Fetch &amp; PreDecode</p>
    <p>OP Cache</p>
    <p>OPs</p>
    <p>Branch Predictor</p>
    <p>L1 Instruction Cache ITLB</p>
    <p>Instructions are</p>
    <p>fetched and decoded in the front-end</p>
    <p>dispatched to the backend</p>
    <p>processed by individual execution units</p>
  </div>
  <div class="page">
    <p>Out-of-Order Execution E</p>
    <p>xe cu</p>
    <p>ti on</p>
    <p>E ng</p>
    <p>in e</p>
    <p>Reorder buffer</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>Scheduler</p>
    <p>Execution Units</p>
    <p>A L</p>
    <p>U ,A</p>
    <p>E S</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,F</p>
    <p>M A</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,V</p>
    <p>ec t,</p>
    <p>.. .</p>
    <p>A L</p>
    <p>U ,B</p>
    <p>ra nc</p>
    <p>h</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>S to</p>
    <p>re da</p>
    <p>ta</p>
    <p>A G</p>
    <p>U</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>CDB</p>
    <p>M em</p>
    <p>or y</p>
    <p>S ub</p>
    <p>sy st</p>
    <p>em</p>
    <p>Load Buffer Store Buffer</p>
    <p>L1 Data Cache DTLB STLB</p>
    <p>L2 Cache</p>
    <p>F ro</p>
    <p>nt en</p>
    <p>d</p>
    <p>Allocation Queue</p>
    <p>OP  OP  OP  OP</p>
    <p>MUX</p>
    <p>OP  OP  OP  OP</p>
    <p>Instruction Queue</p>
    <p>Instruction Fetch &amp; PreDecode</p>
    <p>OP Cache</p>
    <p>OPs</p>
    <p>Branch Predictor</p>
    <p>L1 Instruction Cache ITLB</p>
    <p>Instructions are</p>
    <p>fetched and decoded in the front-end</p>
    <p>dispatched to the backend</p>
    <p>processed by individual execution units</p>
  </div>
  <div class="page">
    <p>Out-of-Order Execution E</p>
    <p>xe cu</p>
    <p>ti on</p>
    <p>E ng</p>
    <p>in e</p>
    <p>Reorder buffer</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>Scheduler</p>
    <p>Execution Units</p>
    <p>A L</p>
    <p>U ,A</p>
    <p>E S</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,F</p>
    <p>M A</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,V</p>
    <p>ec t,</p>
    <p>.. .</p>
    <p>A L</p>
    <p>U ,B</p>
    <p>ra nc</p>
    <p>h</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>S to</p>
    <p>re da</p>
    <p>ta</p>
    <p>A G</p>
    <p>U</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>CDB</p>
    <p>M em</p>
    <p>or y</p>
    <p>S ub</p>
    <p>sy st</p>
    <p>em</p>
    <p>Load Buffer Store Buffer</p>
    <p>L1 Data Cache DTLB STLB</p>
    <p>L2 Cache</p>
    <p>F ro</p>
    <p>nt en</p>
    <p>d</p>
    <p>Allocation Queue</p>
    <p>OP  OP  OP  OP</p>
    <p>MUX</p>
    <p>OP  OP  OP  OP</p>
    <p>Instruction Queue</p>
    <p>Instruction Fetch &amp; PreDecode</p>
    <p>OP Cache</p>
    <p>OPs</p>
    <p>Branch Predictor</p>
    <p>L1 Instruction Cache ITLB</p>
    <p>Instructions</p>
    <p>are executed out-of-order</p>
    <p>wait until their dependencies are ready</p>
    <p>Later instructions might execute prior earlier</p>
    <p>instructions</p>
    <p>retire in-order</p>
    <p>State becomes architecturally visible</p>
    <p>Exceptions are checked during retirement</p>
    <p>Flush pipeline and recover state</p>
  </div>
  <div class="page">
    <p>Out-of-Order Execution E</p>
    <p>xe cu</p>
    <p>ti on</p>
    <p>E ng</p>
    <p>in e</p>
    <p>Reorder buffer</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>Scheduler</p>
    <p>Execution Units</p>
    <p>A L</p>
    <p>U ,A</p>
    <p>E S</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,F</p>
    <p>M A</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,V</p>
    <p>ec t,</p>
    <p>.. .</p>
    <p>A L</p>
    <p>U ,B</p>
    <p>ra nc</p>
    <p>h</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>S to</p>
    <p>re da</p>
    <p>ta</p>
    <p>A G</p>
    <p>U</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>CDB</p>
    <p>M em</p>
    <p>or y</p>
    <p>S ub</p>
    <p>sy st</p>
    <p>em</p>
    <p>Load Buffer Store Buffer</p>
    <p>L1 Data Cache DTLB STLB</p>
    <p>L2 Cache</p>
    <p>F ro</p>
    <p>nt en</p>
    <p>d</p>
    <p>Allocation Queue</p>
    <p>OP  OP  OP  OP</p>
    <p>MUX</p>
    <p>OP  OP  OP  OP</p>
    <p>Instruction Queue</p>
    <p>Instruction Fetch &amp; PreDecode</p>
    <p>OP Cache</p>
    <p>OPs</p>
    <p>Branch Predictor</p>
    <p>L1 Instruction Cache ITLB</p>
    <p>Instructions</p>
    <p>are executed out-of-order</p>
    <p>wait until their dependencies are ready</p>
    <p>Later instructions might execute prior earlier</p>
    <p>instructions</p>
    <p>retire in-order</p>
    <p>State becomes architecturally visible</p>
    <p>Exceptions are checked during retirement</p>
    <p>Flush pipeline and recover state</p>
  </div>
  <div class="page">
    <p>Out-of-Order Execution E</p>
    <p>xe cu</p>
    <p>ti on</p>
    <p>E ng</p>
    <p>in e</p>
    <p>Reorder buffer</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>Scheduler</p>
    <p>Execution Units</p>
    <p>A L</p>
    <p>U ,A</p>
    <p>E S</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,F</p>
    <p>M A</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,V</p>
    <p>ec t,</p>
    <p>.. .</p>
    <p>A L</p>
    <p>U ,B</p>
    <p>ra nc</p>
    <p>h</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>S to</p>
    <p>re da</p>
    <p>ta</p>
    <p>A G</p>
    <p>U</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>CDB</p>
    <p>M em</p>
    <p>or y</p>
    <p>S ub</p>
    <p>sy st</p>
    <p>em</p>
    <p>Load Buffer Store Buffer</p>
    <p>L1 Data Cache DTLB STLB</p>
    <p>L2 Cache</p>
    <p>F ro</p>
    <p>nt en</p>
    <p>d</p>
    <p>Allocation Queue</p>
    <p>OP  OP  OP  OP</p>
    <p>MUX</p>
    <p>OP  OP  OP  OP</p>
    <p>Instruction Queue</p>
    <p>Instruction Fetch &amp; PreDecode</p>
    <p>OP Cache</p>
    <p>OPs</p>
    <p>Branch Predictor</p>
    <p>L1 Instruction Cache ITLB</p>
    <p>Instructions</p>
    <p>are executed out-of-order</p>
    <p>wait until their dependencies are ready</p>
    <p>Later instructions might execute prior earlier</p>
    <p>instructions</p>
    <p>retire in-order</p>
    <p>State becomes architecturally visible</p>
    <p>Exceptions are checked during retirement</p>
    <p>Flush pipeline and recover state</p>
  </div>
  <div class="page">
    <p>Out-of-Order Execution E</p>
    <p>xe cu</p>
    <p>ti on</p>
    <p>E ng</p>
    <p>in e</p>
    <p>Reorder buffer</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>Scheduler</p>
    <p>Execution Units</p>
    <p>A L</p>
    <p>U ,A</p>
    <p>E S</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,F</p>
    <p>M A</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,V</p>
    <p>ec t,</p>
    <p>.. .</p>
    <p>A L</p>
    <p>U ,B</p>
    <p>ra nc</p>
    <p>h</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>S to</p>
    <p>re da</p>
    <p>ta</p>
    <p>A G</p>
    <p>U</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>CDB</p>
    <p>M em</p>
    <p>or y</p>
    <p>S ub</p>
    <p>sy st</p>
    <p>em</p>
    <p>Load Buffer Store Buffer</p>
    <p>L1 Data Cache DTLB STLB</p>
    <p>L2 Cache</p>
    <p>F ro</p>
    <p>nt en</p>
    <p>d</p>
    <p>Allocation Queue</p>
    <p>OP  OP  OP  OP</p>
    <p>MUX</p>
    <p>OP  OP  OP  OP</p>
    <p>Instruction Queue</p>
    <p>Instruction Fetch &amp; PreDecode</p>
    <p>OP Cache</p>
    <p>OPs</p>
    <p>Branch Predictor</p>
    <p>L1 Instruction Cache ITLB</p>
    <p>Instructions</p>
    <p>are executed out-of-order</p>
    <p>wait until their dependencies are ready</p>
    <p>Later instructions might execute prior earlier</p>
    <p>instructions</p>
    <p>retire in-order</p>
    <p>State becomes architecturally visible</p>
    <p>Exceptions are checked during retirement</p>
    <p>Flush pipeline and recover state</p>
  </div>
  <div class="page">
    <p>Out-of-Order Execution E</p>
    <p>xe cu</p>
    <p>ti on</p>
    <p>E ng</p>
    <p>in e</p>
    <p>Reorder buffer</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>Scheduler</p>
    <p>Execution Units</p>
    <p>A L</p>
    <p>U ,A</p>
    <p>E S</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,F</p>
    <p>M A</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,V</p>
    <p>ec t,</p>
    <p>.. .</p>
    <p>A L</p>
    <p>U ,B</p>
    <p>ra nc</p>
    <p>h</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>S to</p>
    <p>re da</p>
    <p>ta</p>
    <p>A G</p>
    <p>U</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>CDB</p>
    <p>M em</p>
    <p>or y</p>
    <p>S ub</p>
    <p>sy st</p>
    <p>em</p>
    <p>Load Buffer Store Buffer</p>
    <p>L1 Data Cache DTLB STLB</p>
    <p>L2 Cache</p>
    <p>F ro</p>
    <p>nt en</p>
    <p>d</p>
    <p>Allocation Queue</p>
    <p>OP  OP  OP  OP</p>
    <p>MUX</p>
    <p>OP  OP  OP  OP</p>
    <p>Instruction Queue</p>
    <p>Instruction Fetch &amp; PreDecode</p>
    <p>OP Cache</p>
    <p>OPs</p>
    <p>Branch Predictor</p>
    <p>L1 Instruction Cache ITLB</p>
    <p>Instructions</p>
    <p>are executed out-of-order</p>
    <p>wait until their dependencies are ready</p>
    <p>Later instructions might execute prior earlier</p>
    <p>instructions</p>
    <p>retire in-order</p>
    <p>State becomes architecturally visible</p>
    <p>Exceptions are checked during retirement</p>
    <p>Flush pipeline and recover state</p>
  </div>
  <div class="page">
    <p>Out-of-Order Execution E</p>
    <p>xe cu</p>
    <p>ti on</p>
    <p>E ng</p>
    <p>in e</p>
    <p>Reorder buffer</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>Scheduler</p>
    <p>Execution Units</p>
    <p>A L</p>
    <p>U ,A</p>
    <p>E S</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,F</p>
    <p>M A</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,V</p>
    <p>ec t,</p>
    <p>.. .</p>
    <p>A L</p>
    <p>U ,B</p>
    <p>ra nc</p>
    <p>h</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>S to</p>
    <p>re da</p>
    <p>ta</p>
    <p>A G</p>
    <p>U</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>CDB</p>
    <p>M em</p>
    <p>or y</p>
    <p>S ub</p>
    <p>sy st</p>
    <p>em</p>
    <p>Load Buffer Store Buffer</p>
    <p>L1 Data Cache DTLB STLB</p>
    <p>L2 Cache</p>
    <p>F ro</p>
    <p>nt en</p>
    <p>d</p>
    <p>Allocation Queue</p>
    <p>OP  OP  OP  OP</p>
    <p>MUX</p>
    <p>OP  OP  OP  OP</p>
    <p>Instruction Queue</p>
    <p>Instruction Fetch &amp; PreDecode</p>
    <p>OP Cache</p>
    <p>OPs</p>
    <p>Branch Predictor</p>
    <p>L1 Instruction Cache ITLB</p>
    <p>Instructions</p>
    <p>are executed out-of-order</p>
    <p>wait until their dependencies are ready</p>
    <p>Later instructions might execute prior earlier</p>
    <p>instructions</p>
    <p>retire in-order</p>
    <p>State becomes architecturally visible</p>
    <p>Exceptions are checked during retirement</p>
    <p>Flush pipeline and recover state</p>
  </div>
  <div class="page">
    <p>Out-of-Order Execution E</p>
    <p>xe cu</p>
    <p>ti on</p>
    <p>E ng</p>
    <p>in e</p>
    <p>Reorder buffer</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>Scheduler</p>
    <p>Execution Units</p>
    <p>A L</p>
    <p>U ,A</p>
    <p>E S</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,F</p>
    <p>M A</p>
    <p>,. ..</p>
    <p>A L</p>
    <p>U ,V</p>
    <p>ec t,</p>
    <p>.. .</p>
    <p>A L</p>
    <p>U ,B</p>
    <p>ra nc</p>
    <p>h</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>L oa</p>
    <p>d da</p>
    <p>ta</p>
    <p>S to</p>
    <p>re da</p>
    <p>ta</p>
    <p>A G</p>
    <p>U</p>
    <p>OP  OP  OP  OP  OP  OP  OP  OP</p>
    <p>CDB</p>
    <p>M em</p>
    <p>or y</p>
    <p>S ub</p>
    <p>sy st</p>
    <p>em</p>
    <p>Load Buffer Store Buffer</p>
    <p>L1 Data Cache DTLB STLB</p>
    <p>L2 Cache</p>
    <p>F ro</p>
    <p>nt en</p>
    <p>d</p>
    <p>Allocation Queue</p>
    <p>OP  OP  OP  OP</p>
    <p>MUX</p>
    <p>OP  OP  OP  OP</p>
    <p>Instruction Queue</p>
    <p>Instruction Fetch &amp; PreDecode</p>
    <p>OP Cache</p>
    <p>OPs</p>
    <p>Branch Predictor</p>
    <p>L1 Instruction Cache ITLB</p>
    <p>Instructions</p>
    <p>are executed out-of-order</p>
    <p>wait until their dependencies are ready</p>
    <p>Later instructions might execute prior earlier</p>
    <p>instructions</p>
    <p>retire in-order</p>
    <p>State becomes architecturally visible</p>
    <p>Exceptions are checked during retirement</p>
    <p>Flush pipeline and recover state</p>
  </div>
  <div class="page">
    <p>Toy example</p>
    <p>*(volatile char*) 0; // raise_exception(); array[84 * 4096] = 0;</p>
  </div>
  <div class="page">
    <p>Building the Code</p>
    <p>Flush+Reload over all pages of the array</p>
    <p>Page A c c e s s ti m e</p>
    <p>[c y c le s ]</p>
    <p>Unreachable code line was actually executed</p>
    <p>Exception was only thrown afterwards</p>
  </div>
  <div class="page">
    <p>Building the Code</p>
    <p>Flush+Reload over all pages of the array</p>
    <p>Page A c c e s s ti m e</p>
    <p>[c y c le s ]</p>
    <p>Unreachable code line was actually executed</p>
    <p>Exception was only thrown afterwards</p>
  </div>
  <div class="page">
    <p>Building the Code</p>
    <p>Flush+Reload over all pages of the array</p>
    <p>Page A c c e s s ti m e</p>
    <p>[c y c le s ]</p>
    <p>Unreachable code line was actually executed</p>
    <p>Exception was only thrown afterwards</p>
  </div>
  <div class="page">
    <p>Building the Code</p>
    <p>Out-of-order instructions leave microarchitectural traces</p>
    <p>We can see them for example in the cache</p>
    <p>Give such instructions a name: transient instructions</p>
    <p>We can indirectly observe the execution of transient</p>
    <p>instructions</p>
  </div>
  <div class="page">
    <p>Building the Code</p>
    <p>Out-of-order instructions leave microarchitectural traces</p>
    <p>We can see them for example in the cache</p>
    <p>Give such instructions a name: transient instructions</p>
    <p>We can indirectly observe the execution of transient</p>
    <p>instructions</p>
  </div>
  <div class="page">
    <p>Building the Code</p>
    <p>Out-of-order instructions leave microarchitectural traces</p>
    <p>We can see them for example in the cache</p>
    <p>Give such instructions a name: transient instructions</p>
    <p>We can indirectly observe the execution of transient</p>
    <p>instructions</p>
  </div>
  <div class="page">
    <p>Building the Code</p>
    <p>Out-of-order instructions leave microarchitectural traces</p>
    <p>We can see them for example in the cache</p>
    <p>Give such instructions a name: transient instructions</p>
    <p>We can indirectly observe the execution of transient</p>
    <p>instructions</p>
  </div>
  <div class="page">
    <p>Building blocks</p>
    <p>Exception Handling/ Suppression</p>
    <p>Transient</p>
    <p>Instructions Secret</p>
    <p>Microarchitectural</p>
    <p>State Change</p>
    <p>Section 4.1</p>
    <p>Architectural State</p>
    <p>Transfer (Covert Channel)</p>
    <p>Recovered Secret</p>
    <p>Recovery</p>
    <p>L e a k e d</p>
    <p>Accessed</p>
    <p>Section 4.2</p>
  </div>
  <div class="page">
    <p>Executing transient instructions</p>
    <p>Transient instructions are executed all the time</p>
    <p>Loading inaccessible addresses leads to a crash (segfault)</p>
    <p>How to prevent the crash?</p>
    <p>Fault</p>
    <p>Handling</p>
    <p>Fault</p>
    <p>Suppression</p>
    <p>Fault</p>
    <p>Prevention</p>
  </div>
  <div class="page">
    <p>Executing transient instructions</p>
    <p>Transient instructions are executed all the time</p>
    <p>Loading inaccessible addresses leads to a crash (segfault)</p>
    <p>How to prevent the crash?</p>
    <p>Fault</p>
    <p>Handling</p>
    <p>Fault</p>
    <p>Suppression</p>
    <p>Fault</p>
    <p>Prevention</p>
  </div>
  <div class="page">
    <p>Executing transient instructions</p>
    <p>Transient instructions are executed all the time</p>
    <p>Loading inaccessible addresses leads to a crash (segfault)</p>
    <p>How to prevent the crash?</p>
    <p>Fault</p>
    <p>Handling</p>
    <p>Fault</p>
    <p>Suppression</p>
    <p>Fault</p>
    <p>Prevention</p>
  </div>
  <div class="page">
    <p>Executing transient instructions</p>
    <p>Transient instructions are executed all the time</p>
    <p>Loading inaccessible addresses leads to a crash (segfault)</p>
    <p>How to prevent the crash?</p>
    <p>Fault</p>
    <p>Handling</p>
    <p>Fault</p>
    <p>Suppression</p>
    <p>Fault</p>
    <p>Prevention</p>
  </div>
  <div class="page">
    <p>Building a Covert Channel</p>
    <p>Transfer of the microarchitectural state into an</p>
    <p>architectural state</p>
    <p>Transient instruction sequence is the sender</p>
    <p>Receiver receives the microarchitectural state change and</p>
    <p>deduces the secret from the state</p>
  </div>
  <div class="page">
    <p>Building a Covert Channel</p>
    <p>Leverage techniques from cache attacks: Flush+Reload</p>
    <p>Transmit multiple bits at once</p>
    <p>256 different byte values  access different cache line</p>
    <p>Not limited to the cache</p>
  </div>
  <div class="page">
    <p>Building the Code</p>
    <p>Add another layer of indirection to test</p>
    <p>char data = *(char*) 0xffffffff81a000e0; array[data * 4096] = 0;</p>
    <p>Then check whether any part of array is cached</p>
  </div>
  <div class="page">
    <p>Building the Code</p>
    <p>Add another layer of indirection to test</p>
    <p>char data = *(char*) 0xffffffff81a000e0; array[data * 4096] = 0;</p>
    <p>Then check whether any part of array is cached</p>
  </div>
  <div class="page">
    <p>Building the Code</p>
    <p>Flush+Reload over all pages of the array</p>
    <p>Page A c c e s s ti m e</p>
    <p>[c y c le s ]</p>
    <p>Index of cache hit reveals data</p>
    <p>Permission check is in some cases not fast enough</p>
  </div>
  <div class="page">
    <p>Building the Code</p>
    <p>Flush+Reload over all pages of the array</p>
    <p>Page A c c e s s ti m e</p>
    <p>[c y c le s ]</p>
    <p>Index of cache hit reveals data</p>
    <p>Permission check is in some cases not fast enough</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Meltdown</p>
    <p>Using out-of-order execution, we can read data at any address</p>
    <p>Index of cache hit reveals data</p>
    <p>Permission check is in some cases not fast enough</p>
    <p>Entire physical memory is typically accessible through kernel</p>
    <p>space</p>
  </div>
  <div class="page">
    <p>Meltdown</p>
    <p>Using out-of-order execution, we can read data at any address</p>
    <p>Index of cache hit reveals data</p>
    <p>Permission check is in some cases not fast enough</p>
    <p>Entire physical memory is typically accessible through kernel</p>
    <p>space</p>
  </div>
  <div class="page">
    <p>Meltdown</p>
    <p>Using out-of-order execution, we can read data at any address</p>
    <p>Index of cache hit reveals data</p>
    <p>Permission check is in some cases not fast enough</p>
    <p>Entire physical memory is typically accessible through kernel</p>
    <p>space</p>
  </div>
  <div class="page">
    <p>Meltdown</p>
    <p>Using out-of-order execution, we can read data at any address</p>
    <p>Index of cache hit reveals data</p>
    <p>Permission check is in some cases not fast enough</p>
    <p>Entire physical memory is typically accessible through kernel</p>
    <p>space</p>
  </div>
  <div class="page">
    <p>Demo</p>
  </div>
  <div class="page">
    <p>Uncached memory</p>
    <p>Assumed that one can only read data stored in the L1 with</p>
    <p>Meltdown</p>
    <p>Experiment where a thread flushes the value constantly</p>
    <p>and a thread on a different core reloads the value</p>
    <p>Target data is not in the L1 cache of the attacking core</p>
    <p>We can still leak the data at a lower reading rate</p>
    <p>Meltdown might implicitly cache the data</p>
  </div>
  <div class="page">
    <p>Uncached memory</p>
    <p>Assumed that one can only read data stored in the L1 with</p>
    <p>Meltdown</p>
    <p>Experiment where a thread flushes the value constantly</p>
    <p>and a thread on a different core reloads the value</p>
    <p>Target data is not in the L1 cache of the attacking core</p>
    <p>We can still leak the data at a lower reading rate</p>
    <p>Meltdown might implicitly cache the data</p>
  </div>
  <div class="page">
    <p>Uncached memory</p>
    <p>Assumed that one can only read data stored in the L1 with</p>
    <p>Meltdown</p>
    <p>Experiment where a thread flushes the value constantly</p>
    <p>and a thread on a different core reloads the value</p>
    <p>Target data is not in the L1 cache of the attacking core</p>
    <p>We can still leak the data at a lower reading rate</p>
    <p>Meltdown might implicitly cache the data</p>
  </div>
  <div class="page">
    <p>Uncached memory</p>
    <p>Assumed that one can only read data stored in the L1 with</p>
    <p>Meltdown</p>
    <p>Experiment where a thread flushes the value constantly</p>
    <p>and a thread on a different core reloads the value</p>
    <p>Target data is not in the L1 cache of the attacking core</p>
    <p>We can still leak the data at a lower reading rate</p>
    <p>Meltdown might implicitly cache the data</p>
  </div>
  <div class="page">
    <p>Uncached memory</p>
    <p>Assumed that one can only read data stored in the L1 with</p>
    <p>Meltdown</p>
    <p>Experiment where a thread flushes the value constantly</p>
    <p>and a thread on a different core reloads the value</p>
    <p>Target data is not in the L1 cache of the attacking core</p>
    <p>We can still leak the data at a lower reading rate</p>
    <p>Meltdown might implicitly cache the data</p>
  </div>
  <div class="page">
    <p>Uncachable memory</p>
    <p>Mark pages in page tables as UC (uncachable)</p>
    <p>Every read or write operation will go to main memory</p>
    <p>If the attacker can trigger a legitimate load (system call, )</p>
    <p>on the same CPU core, the data still can be leaked</p>
    <p>Meltdown might read the data from one of the fill buffers</p>
    <p>as they are shared between threads running on the same</p>
    <p>core</p>
  </div>
  <div class="page">
    <p>Uncachable memory</p>
    <p>Mark pages in page tables as UC (uncachable)  Every read or write operation will go to main memory</p>
    <p>If the attacker can trigger a legitimate load (system call, )</p>
    <p>on the same CPU core, the data still can be leaked</p>
    <p>Meltdown might read the data from one of the fill buffers</p>
    <p>as they are shared between threads running on the same</p>
    <p>core</p>
  </div>
  <div class="page">
    <p>Uncachable memory</p>
    <p>Mark pages in page tables as UC (uncachable)  Every read or write operation will go to main memory</p>
    <p>If the attacker can trigger a legitimate load (system call, )</p>
    <p>on the same CPU core, the data still can be leaked</p>
    <p>Meltdown might read the data from one of the fill buffers</p>
    <p>as they are shared between threads running on the same</p>
    <p>core</p>
  </div>
  <div class="page">
    <p>Uncachable memory</p>
    <p>Mark pages in page tables as UC (uncachable)  Every read or write operation will go to main memory</p>
    <p>If the attacker can trigger a legitimate load (system call, )</p>
    <p>on the same CPU core, the data still can be leaked</p>
    <p>Meltdown might read the data from one of the fill buffers</p>
    <p>as they are shared between threads running on the same</p>
    <p>core</p>
  </div>
  <div class="page">
    <p>Uncachable memory</p>
    <p>Mark pages in page tables as UC (uncachable)  Every read or write operation will go to main memory</p>
    <p>If the attacker can trigger a legitimate load (system call, )</p>
    <p>on the same CPU core, the data still can be leaked</p>
    <p>Meltdown might read the data from one of the fill buffers</p>
    <p>as they are shared between threads running on the same</p>
    <p>core</p>
  </div>
  <div class="page">
    <p>Affected by Meltdown</p>
    <p>Intel: Almost every CPU</p>
    <p>AMD: Seems not to be affected  ARM: Only the Cortex-A75  IBM: System Z, Power Architecture, POWER8 and POWER9  Apple: All Mac and iOS devices</p>
  </div>
  <div class="page">
    <p>Affected by Meltdown</p>
    <p>Intel: Almost every CPU  AMD: Seems not to be affected</p>
    <p>ARM: Only the Cortex-A75  IBM: System Z, Power Architecture, POWER8 and POWER9  Apple: All Mac and iOS devices</p>
  </div>
  <div class="page">
    <p>Affected by Meltdown</p>
    <p>Intel: Almost every CPU  AMD: Seems not to be affected  ARM: Only the Cortex-A75</p>
    <p>IBM: System Z, Power Architecture, POWER8 and POWER9  Apple: All Mac and iOS devices</p>
  </div>
  <div class="page">
    <p>Affected by Meltdown</p>
    <p>Intel: Almost every CPU  AMD: Seems not to be affected  ARM: Only the Cortex-A75  IBM: System Z, Power Architecture, POWER8 and POWER9</p>
    <p>Apple: All Mac and iOS devices</p>
  </div>
  <div class="page">
    <p>Affected by Meltdown</p>
    <p>Intel: Almost every CPU  AMD: Seems not to be affected  ARM: Only the Cortex-A75  IBM: System Z, Power Architecture, POWER8 and POWER9  Apple: All Mac and iOS devices</p>
  </div>
  <div class="page">
    <p>Samsung Galaxy S7</p>
    <p>Samsung Galaxy S7</p>
    <p>Exynos Mongoose M1 CPU Architecture</p>
    <p>Custom CPU core in the Exynos 8 Octa (8890)</p>
    <p>Perceptron Branch Prediction</p>
    <p>Full Out-of-Order Instruction Execution</p>
    <p>Full Out-of-Order loads and stores</p>
  </div>
  <div class="page">
    <p>Samsung Galaxy S7</p>
    <p>Samsung Galaxy S7</p>
    <p>Exynos Mongoose M1 CPU Architecture</p>
    <p>Custom CPU core in the Exynos 8 Octa (8890)</p>
    <p>Perceptron Branch Prediction</p>
    <p>Full Out-of-Order Instruction Execution</p>
    <p>Full Out-of-Order loads and stores</p>
  </div>
  <div class="page">
    <p>Samsung Galaxy S7</p>
    <p>Samsung Galaxy S7</p>
    <p>Exynos Mongoose M1 CPU Architecture</p>
    <p>Custom CPU core in the Exynos 8 Octa (8890)</p>
    <p>Perceptron Branch Prediction</p>
    <p>Full Out-of-Order Instruction Execution</p>
    <p>Full Out-of-Order loads and stores</p>
  </div>
  <div class="page">
    <p>Samsung Galaxy S7</p>
    <p>Samsung Galaxy S7</p>
    <p>Exynos Mongoose M1 CPU Architecture</p>
    <p>Custom CPU core in the Exynos 8 Octa (8890)</p>
    <p>Perceptron Branch Prediction</p>
    <p>Full Out-of-Order Instruction Execution</p>
    <p>Full Out-of-Order loads and stores</p>
  </div>
  <div class="page">
    <p>Samsung Galaxy S7</p>
    <p>Samsung Galaxy S7</p>
    <p>Exynos Mongoose M1 CPU Architecture</p>
    <p>Custom CPU core in the Exynos 8 Octa (8890)</p>
    <p>Perceptron Branch Prediction</p>
    <p>Full Out-of-Order Instruction Execution</p>
    <p>Full Out-of-Order loads and stores</p>
  </div>
  <div class="page">
    <p>Meltdown in Practice</p>
    <p>Dumping the entire physical memory takes some time</p>
    <p>L1: 582 KB/s</p>
    <p>L3: 12.4 KB/s</p>
    <p>Uncached: 10 B/s (improved: 3.2 KB/s)</p>
    <p>Not very practical in most scenarios</p>
  </div>
  <div class="page">
    <p>Meltdown in Practice</p>
    <p>Dumping the entire physical memory takes some time</p>
    <p>L1: 582 KB/s</p>
    <p>L3: 12.4 KB/s</p>
    <p>Uncached: 10 B/s (improved: 3.2 KB/s)</p>
    <p>Not very practical in most scenarios</p>
  </div>
  <div class="page">
    <p>Meltdown in Practice</p>
    <p>Dumping the entire physical memory takes some time</p>
    <p>L1: 582 KB/s</p>
    <p>L3: 12.4 KB/s</p>
    <p>Uncached: 10 B/s (improved: 3.2 KB/s)</p>
    <p>Not very practical in most scenarios</p>
  </div>
  <div class="page">
    <p>Breaking KASLR</p>
    <p>De-randomize KASLR to access internal kernel structures</p>
    <p>Locate a known value inside the kernel, e.g., Linux banner</p>
    <p>Start at the default address according to the symbol table</p>
    <p>of the running kernel</p>
    <p>Linux KASLR has an entropy of 6 bits  only 64 possible randomization offsets</p>
    <p>Difference between the found address and the</p>
    <p>non-randomized base address is the randomization offset</p>
  </div>
  <div class="page">
    <p>Breaking KASLR</p>
    <p>De-randomize KASLR to access internal kernel structures</p>
    <p>Locate a known value inside the kernel, e.g., Linux banner</p>
    <p>Start at the default address according to the symbol table</p>
    <p>of the running kernel</p>
    <p>Linux KASLR has an entropy of 6 bits  only 64 possible randomization offsets</p>
    <p>Difference between the found address and the</p>
    <p>non-randomized base address is the randomization offset</p>
  </div>
  <div class="page">
    <p>Breaking KASLR</p>
    <p>De-randomize KASLR to access internal kernel structures</p>
    <p>Locate a known value inside the kernel, e.g., Linux banner</p>
    <p>Start at the default address according to the symbol table</p>
    <p>of the running kernel</p>
    <p>Linux KASLR has an entropy of 6 bits  only 64 possible randomization offsets</p>
    <p>Difference between the found address and the</p>
    <p>non-randomized base address is the randomization offset</p>
  </div>
  <div class="page">
    <p>Breaking KASLR</p>
    <p>De-randomize KASLR to access internal kernel structures</p>
    <p>Locate a known value inside the kernel, e.g., Linux banner</p>
    <p>Start at the default address according to the symbol table</p>
    <p>of the running kernel</p>
    <p>Linux KASLR has an entropy of 6 bits  only 64 possible randomization offsets</p>
    <p>Difference between the found address and the</p>
    <p>non-randomized base address is the randomization offset</p>
  </div>
  <div class="page">
    <p>Breaking KASLR</p>
    <p>De-randomize KASLR to access internal kernel structures</p>
    <p>Locate a known value inside the kernel, e.g., Linux banner</p>
    <p>Start at the default address according to the symbol table</p>
    <p>of the running kernel</p>
    <p>Linux KASLR has an entropy of 6 bits  only 64 possible randomization offsets</p>
    <p>Difference between the found address and the</p>
    <p>non-randomized base address is the randomization offset</p>
  </div>
  <div class="page">
    <p>Locating the victim process</p>
    <p>Linux manages all processes in a linked list</p>
    <p>Head of the list is stored at init_task structure  At a fixed offset that varies only among kernel builds</p>
    <p>Each task list structure contains a pointer to the next task</p>
    <p>and</p>
    <p>PID of the task</p>
    <p>name of the task</p>
    <p>Root of the multi-level page table</p>
  </div>
  <div class="page">
    <p>Locating the victim process</p>
    <p>Linux manages all processes in a linked list</p>
    <p>Head of the list is stored at init_task structure</p>
    <p>At a fixed offset that varies only among kernel builds</p>
    <p>Each task list structure contains a pointer to the next task</p>
    <p>and</p>
    <p>PID of the task</p>
    <p>name of the task</p>
    <p>Root of the multi-level page table</p>
  </div>
  <div class="page">
    <p>Locating the victim process</p>
    <p>Linux manages all processes in a linked list</p>
    <p>Head of the list is stored at init_task structure  At a fixed offset that varies only among kernel builds</p>
    <p>Each task list structure contains a pointer to the next task</p>
    <p>and</p>
    <p>PID of the task</p>
    <p>name of the task</p>
    <p>Root of the multi-level page table</p>
  </div>
  <div class="page">
    <p>Locating the victim process</p>
    <p>Linux manages all processes in a linked list</p>
    <p>Head of the list is stored at init_task structure  At a fixed offset that varies only among kernel builds</p>
    <p>Each task list structure contains a pointer to the next task</p>
    <p>and</p>
    <p>PID of the task</p>
    <p>name of the task</p>
    <p>Root of the multi-level page table</p>
  </div>
  <div class="page">
    <p>Dumping memory content</p>
    <p>Resolve physical address using paging structures</p>
    <p>Read the content using the direct-physical map</p>
    <p>Enumerate all mapped pages and dump entire process</p>
    <p>memory</p>
    <p>Location of the key known, we can just dump the key</p>
    <p>directly</p>
  </div>
  <div class="page">
    <p>Dumping memory content</p>
    <p>Resolve physical address using paging structures</p>
    <p>Read the content using the direct-physical map</p>
    <p>Enumerate all mapped pages and dump entire process</p>
    <p>memory</p>
    <p>Location of the key known, we can just dump the key</p>
    <p>directly</p>
  </div>
  <div class="page">
    <p>Dumping memory content</p>
    <p>Resolve physical address using paging structures</p>
    <p>Read the content using the direct-physical map</p>
    <p>Enumerate all mapped pages and dump entire process</p>
    <p>memory</p>
    <p>Location of the key known, we can just dump the key</p>
    <p>directly</p>
  </div>
  <div class="page">
    <p>Dumping memory content</p>
    <p>Resolve physical address using paging structures</p>
    <p>Read the content using the direct-physical map</p>
    <p>Enumerate all mapped pages and dump entire process</p>
    <p>memory</p>
    <p>Location of the key known, we can just dump the key</p>
    <p>directly</p>
  </div>
  <div class="page">
    <p>Meltdown Mitigation</p>
    <p>Problem is rooted in hardware</p>
    <p>Race condition between the memory fetch and</p>
    <p>corresponding permission check</p>
    <p>Serialize both of them</p>
    <p>Hard split of user space and kernel space</p>
    <p>New bit in control register</p>
    <p>Fix the hardware  long-term solution  Can we fix it in software?</p>
  </div>
  <div class="page">
    <p>Meltdown Mitigation</p>
    <p>Problem is rooted in hardware</p>
    <p>Race condition between the memory fetch and</p>
    <p>corresponding permission check</p>
    <p>Serialize both of them</p>
    <p>Hard split of user space and kernel space</p>
    <p>New bit in control register</p>
    <p>Fix the hardware  long-term solution  Can we fix it in software?</p>
  </div>
  <div class="page">
    <p>Meltdown Mitigation</p>
    <p>Problem is rooted in hardware</p>
    <p>Race condition between the memory fetch and</p>
    <p>corresponding permission check</p>
    <p>Serialize both of them</p>
    <p>Hard split of user space and kernel space</p>
    <p>New bit in control register</p>
    <p>Fix the hardware  long-term solution  Can we fix it in software?</p>
  </div>
  <div class="page">
    <p>Meltdown Mitigation</p>
    <p>Problem is rooted in hardware</p>
    <p>Race condition between the memory fetch and</p>
    <p>corresponding permission check</p>
    <p>Serialize both of them</p>
    <p>Hard split of user space and kernel space</p>
    <p>New bit in control register</p>
    <p>Fix the hardware  long-term solution</p>
    <p>Can we fix it in software?</p>
  </div>
  <div class="page">
    <p>Meltdown Mitigation</p>
    <p>Problem is rooted in hardware</p>
    <p>Race condition between the memory fetch and</p>
    <p>corresponding permission check</p>
    <p>Serialize both of them</p>
    <p>Hard split of user space and kernel space</p>
    <p>New bit in control register</p>
    <p>Fix the hardware  long-term solution  Can we fix it in software?</p>
  </div>
  <div class="page">
    <p>KAISER</p>
    <p>Userspace Kernelspace</p>
    <p>Applications Operating System Memory</p>
  </div>
  <div class="page">
    <p>KAISER</p>
    <p>Userspace Kernelspace</p>
    <p>Applications Operating System Memory</p>
    <p>Userspace Kernelspace</p>
    <p>Applications</p>
    <p>Kernel View User View</p>
    <p>context switch</p>
  </div>
  <div class="page">
    <p>KAISER</p>
    <p>KAISER [Gru+17] has been published in May 2017</p>
    <p>as a countermeasure against other side-channel attacks</p>
    <p>Inadvertently defeats Meltdown as well</p>
  </div>
  <div class="page">
    <p>KAISER</p>
    <p>KAISER [Gru+17] has been published in May 2017</p>
    <p>as a countermeasure against other side-channel attacks</p>
    <p>Inadvertently defeats Meltdown as well</p>
  </div>
  <div class="page">
    <p>KAISER</p>
    <p>KAISER [Gru+17] has been published in May 2017</p>
    <p>as a countermeasure against other side-channel attacks</p>
    <p>Inadvertently defeats Meltdown as well</p>
  </div>
  <div class="page">
    <p>Mitigations</p>
    <p>Linux: Kernel Page-table Isolation (KPTI)</p>
    <p>Apple: Released updates  Windows: Kernel Virtual Address (KVA) Shadow</p>
  </div>
  <div class="page">
    <p>Mitigations</p>
    <p>Linux: Kernel Page-table Isolation (KPTI)  Apple: Released updates</p>
    <p>Windows: Kernel Virtual Address (KVA) Shadow</p>
  </div>
  <div class="page">
    <p>Mitigations</p>
    <p>Linux: Kernel Page-table Isolation (KPTI)  Apple: Released updates  Windows: Kernel Virtual Address (KVA) Shadow</p>
  </div>
  <div class="page">
    <p>Proof-of-Concept</p>
    <p>You can find our proof-of-concept implementation on:</p>
    <p>https://github.com/IAIK/meltdown</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Underestimated microarchitectural attacks for a long time</p>
    <p>Meltdown allows to read arbitrary kernel memory from</p>
    <p>user space</p>
    <p>Affecting millions of devices of various CPU manufacturers</p>
    <p>Countermeasures come with a performance impact</p>
  </div>
  <div class="page">
    <p>Meltdown</p>
    <p>Reading Kernel Memory from User Space</p>
    <p>Moritz Lipp1, Michael Schwarz1, Daniel Gruss1, Thomas Prescher2, Werner Haas2, Anders Fogh3, Jann Horn4, Stefan Mangard1, Paul Kocher5, Daniel Genkin6, Yuval Yarom7, Mike Hamburg8</p>
    <p>tography Research Division</p>
  </div>
</Presentation>
