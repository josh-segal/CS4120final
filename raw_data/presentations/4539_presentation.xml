<?xml version="1.0" ?>
<Presentation>
  <div class="page"/>
  <div class="page">
    <p>Composing High-Level Plans for Declarative Agent Programming</p>
    <p>Felipe Meneguzzi &amp; Michael Luck</p>
    <p>Kings College London</p>
  </div>
  <div class="page">
    <p>Outline Procedural versus Declarative AgentSpeak(L) AgentSpeak-PL</p>
    <p>The planning action  Chaining plans  AgentSpeak &lt;---&gt; STRIPS  Plan Execution</p>
    <p>Experiments</p>
  </div>
  <div class="page">
    <p>Procedural versus Declarative Procedural agents select black box</p>
    <p>plans to handle events in the environment</p>
    <p>Declarative agents select capabilities to bring about a specific world state</p>
  </div>
  <div class="page">
    <p>AgentSpeak(L)  Procedural agent language  Based on the BDI model  Designer specifies plans in a library</p>
    <p>Plans encode procedures  Plans are characterised by</p>
    <p>trigger and context condition</p>
    <p>Goals are implicit in the plans</p>
  </div>
  <div class="page">
    <p>AgentSpeak(L) Actual goal is implicit</p>
    <p>+!move(Destination) : true   !buy(iceCream).</p>
    <p>We want to be able to say  !achieve(at(Dest)) But this would require a very different</p>
    <p>interpreter  Not exactly</p>
  </div>
  <div class="page">
    <p>AgentSpeak-PL  AgentSpeak(L) + Planning</p>
    <p>Standard AgentSpeak(L) language  Planner invoked through an atomic action</p>
    <p>In principle, any state-space planner can be used</p>
    <p>AgentSpeak Interpreter</p>
    <p>Plan Library</p>
    <p>Conversion</p>
    <p>Planner</p>
    <p>Plan</p>
  </div>
  <div class="page">
    <p>The planning action Point of connection between interpreter</p>
    <p>and planner Encapsulates a conversion process</p>
    <p>From AgentSpeak to STRIPS/PDDL  From a STRIPS plan to AgentSpeak</p>
    <p>Takes a conjunction of beliefs as input Succeeds if planner is able to generate</p>
    <p>a plan to achieve its input</p>
  </div>
  <div class="page">
    <p>The planning action</p>
  </div>
  <div class="page">
    <p>Chaining Plans Traditional AgentSpeak programming</p>
    <p>is similar to procedural languages  Lower-level basic procedures (subroutines)  Higher-level procedures that use them</p>
    <p>AgentSpeak-PL uses a planner to create new high-level plans by chaining basic plans</p>
  </div>
  <div class="page">
    <p>AgentSpeak to STRIPS</p>
    <p>Relies on clear similarities between AgentSpeak plans and STRIPS operators</p>
    <p>Desired world state becomes the planners goal</p>
    <p>Belief base becomes the planners start state</p>
    <p>+!move(A,B) : at(A) &amp; not at(B)</p>
    <p>-at(A); +at(B).</p>
    <p>opname: move(A,B) pre: at(A) &amp; not at(B) del: at(A) add: at(B)</p>
  </div>
  <div class="page">
    <p>STRIPS to AgentSpeak</p>
    <p>Each STRIPS action correspond to a lowlevel AgentSpeak(L) plan</p>
    <p>Plans amount to a series of AgentSpeak(L) subgoals</p>
    <p>STRIPS Plan to achieve battery(full):</p>
    <p>move(1,1) move(1,2) charge</p>
    <p>AgentSpeak(L):</p>
    <p>+!goal_conj(battery(full)) : true &lt;- !move(1,1); !move(1,2); !charge.</p>
  </div>
  <div class="page">
    <p>Plan Execution Generated plans are added to the plan</p>
    <p>library The event that caused planning is re</p>
    <p>posted Generated plan is executed as a regular</p>
    <p>AgentSpeak(L) plan</p>
  </div>
  <div class="page">
    <p>Tests: Cleaning Robot Taken from Raos paper on AgentSpeak Cleaning Robot must switch lanes to</p>
    <p>pick up waste and move it to a bin</p>
  </div>
  <div class="page">
    <p>Cleaning Robot AgentSpeak(L) % Plan 1 +location(waste, X) : location(robot,X) &amp; location(bin,Y) &lt;- pick(waste); !location(robot,Y); drop(waste). % Plan 2 +!location(robot, X) : location(robot,X) &lt;- true. % Plan 3 +!location(robot, X) : location(robot,Y) &amp; not X = Y &amp; adjacent(Y,Z)&amp; not location(car,Z) &lt;- move(Y,Z); !location(robot,X).</p>
    <p>AgentSpeak-PL +location(waste,X) : location(robot,X) &amp; location(bin,Y) &lt;- pick(waste); +goal_conj([location(robot,Y)]); drop(waste).</p>
    <p>+!move(X,Y) : location(robot,X) &amp; not X = Y &amp; not location(car,Y) &amp; adjacent(X,Y) &lt;- -location(robot,X); +location(robot,Y); move(X,Y).</p>
  </div>
  <div class="page">
    <p>Conclusions Planning augments the runtime</p>
    <p>flexibility of BDI agents In the case of AgentSpeak(L), planning</p>
    <p>allows it to be used with declarative goals</p>
    <p>Previous efforts focused on HTN planning, which is not declarative</p>
  </div>
  <div class="page">
    <p>Future Work Refine conversion process</p>
    <p>Remove irrelevant beliefs from start state  Derive minimum context condition for generated plans</p>
    <p>Investigate issues with plan addition  Interactions of new plans and the plan library</p>
    <p>Positive and negative plan interaction Study planning agents in a society</p>
  </div>
</Presentation>
