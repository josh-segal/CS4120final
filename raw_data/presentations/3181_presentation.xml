<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>ret2dir: Rethinking Kernel Isolation</p>
    <p>Vasileios P. Kemerlis</p>
    <p>Michalis Polychronakis Angelos D. Keromytis</p>
    <p>Network Security Lab Department of Computer Science</p>
    <p>Columbia University New York, NY, USA</p>
    <p>USENIX Security Symposium</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 1 / 40</p>
  </div>
  <div class="page">
    <p>Introduction Kernel attacks &amp; defenses</p>
    <p>Return-to-user (ret2usr) Attacks What are they?</p>
    <p>Attacks against OS kernels with shared kernel/user address space</p>
    <p>Overwrite kernel code (or data) pointers with user space addresses</p>
    <p>I Payload ! Shellcode, ROP payload, tampered-with data structure(s)</p>
    <p>I Placed in user space 7 Executed (referenced) in kernel context</p>
    <p>I De facto kernel exploitation technique I Facilitates privilege escalation arbitrary code execution 7 http://www.exploit-db.com/exploits/34134/ (21/07/14) 7 http://www.exploit-db.com/exploits/131/ (05/12/03)</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 2 / 40</p>
  </div>
  <div class="page">
    <p>Introduction Kernel attacks &amp; defenses</p>
    <p>ret2usr Attacks (contd) Why do they work?</p>
    <p>Weak address space (kernel/user) separation</p>
    <p>Shared kernel/process model ! Performance X cost(mode switch)  cost(context switch)</p>
    <p>I The kernel is protected from userland ! Hardware-assisted isolation</p>
    <p>access to all memory and system objects)</p>
    <p>I The attacker completely controls user space memory</p>
    <p>Contents &amp; perms.</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 3 / 40</p>
  </div>
  <div class="page">
    <p>Introduction Kernel attacks &amp; defenses</p>
    <p>ret2usr Defenses State of the art overview</p>
    <p>X KERNEXEC/UDEREF ! PaX I 3rd-party Linux patch(es) ! x86-64/x86/AArch32 only I HW/SW-assisted address space separation</p>
    <p>x86 ! Seg. unit (reload %cs, %ss, %ds, %es)  x86-64 ! Code instr. &amp; temporary user space re-mapping  ARM (AArch32) ! ARM domains</p>
    <p>X kGuard ! Kemerlis et al. [USENIX Sec 12] I Cross-platform solution that enforces (partial) address space separation</p>
    <p>x86, x86-64, ARM, ...  Linux, {Free, Net, Open}BSD, ...</p>
    <p>I Builds upon inline monitoring (code intr.) &amp; code diversification (code inflation &amp; CFA motion)</p>
    <p>X SMEP/SMAP, PXN ! Intel, ARM I HW-assisted address space separation</p>
    <p>Access violation if priv. code (ring 0) executes/accesses instructions/data from user pages (U/S = 1)</p>
    <p>I Vendor and model specific (Intel x86/x86-64, ARM)</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 4 / 40</p>
  </div>
  <div class="page">
    <p>Introduction Kernel attacks &amp; defenses</p>
    <p>ret2usr Defenses (contd) Summary</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 5 / 40</p>
  </div>
  <div class="page">
    <p>Introduction Problem statement</p>
    <p>Rethinking Kernel Isolation What is this work about?</p>
    <p>Focus on ret2usr defenses ! SMEP/SMAP, PXN, PaX, kGuard</p>
    <p>I Can we subvert them?  Force the kernel to execute/access user-controlled code/data</p>
    <p>I Conflicting design choices or optimizations?  Features that weaken the (strong) separation of address spaces</p>
    <p>Return-to-direct-mapped memory (ret2dir)</p>
    <p>I Attack against hardened (Linux) kernels X Bypasses all existing ret2usr schemes X 8 ret2usr exploit 9 ret2dir exploit</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 6 / 40</p>
  </div>
  <div class="page">
    <p>Introduction Problem statement</p>
    <p>Rethinking Kernel Isolation What is this work about?</p>
    <p>Focus on ret2usr defenses ! SMEP/SMAP, PXN, PaX, kGuard I Can we subvert them?</p>
    <p>Force the kernel to execute/access user-controlled code/data I Conflicting design choices or optimizations?</p>
    <p>Features that weaken the (strong) separation of address spaces</p>
    <p>Return-to-direct-mapped memory (ret2dir)</p>
    <p>I Attack against hardened (Linux) kernels X Bypasses all existing ret2usr schemes X 8 ret2usr exploit 9 ret2dir exploit</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 6 / 40</p>
  </div>
  <div class="page">
    <p>Introduction Problem statement</p>
    <p>Rethinking Kernel Isolation What is this work about?</p>
    <p>Focus on ret2usr defenses ! SMEP/SMAP, PXN, PaX, kGuard I Can we subvert them?</p>
    <p>Force the kernel to execute/access user-controlled code/data I Conflicting design choices or optimizations?</p>
    <p>Features that weaken the (strong) separation of address spaces</p>
    <p>Return-to-direct-mapped memory (ret2dir)</p>
    <p>I Attack against hardened (Linux) kernels X Bypasses all existing ret2usr schemes X 8 ret2usr exploit 9 ret2dir exploit</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 6 / 40</p>
  </div>
  <div class="page">
    <p>Attack (ret2dir) Background</p>
    <p>Kernel Space Layout Linux x86-64</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 7 / 40</p>
  </div>
  <div class="page">
    <p>Attack (ret2dir) Background</p>
    <p>physmap Functionality</p>
    <p>Fundamental building block of dynamic kernel memory (kmalloc, SLAB/SLUB)</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 8 / 40</p>
  </div>
  <div class="page">
    <p>Attack (ret2dir) Bypassing SMEP/SMAP, PXN, PaX, kGuard</p>
    <p>The ret2dir Attack physmap is considered harmful</p>
    <p>physmap Address aliasing Given the existence of physmap, whenever the kernel (buddy allocator) maps a page frame to user space, it eectively creates an alias (synonym)</p>
    <p>of user content in kernel space!</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 9 / 40</p>
  </div>
  <div class="page">
    <p>Attack (ret2dir) Bypassing SMEP/SMAP, PXN, PaX, kGuard</p>
    <p>The ret2dir Attack (contd) Operation</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 10 / 40</p>
  </div>
  <div class="page">
    <p>Attack (ret2dir) Bypassing SMEP/SMAP, PXN, PaX, kGuard</p>
    <p>Locating Synonyms Leaking PFNs via /proc (1/2)</p>
    <p>C1: Given a user space virtual address (uaddr) ?! Synonym in</p>
    <p>kernel space (kaddr)</p>
    <p>I Usual suspect: /proc (procfs)</p>
    <p>X /proc/&lt;pid&gt;/pagemap ! Page table examination (from user space) for debugging purposes (since v2.6.25)</p>
    <p>I 64-bit value per page ! Indexed by virtual page number  [0:54] ! Page frame number (PFN)  [63] ! Page present</p>
    <p>PFN(uaddr) seek((uaddr &gt;&gt; PAGE_SHIFT) * sizeof(uint64_t)); read(&amp;v, sizeof(uint64_t)); if (v &amp; (1UL &lt;&lt; 63))</p>
    <p>PFN = v &amp; ((1UL &lt;&lt; 55) - 1);</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 11 / 40</p>
  </div>
  <div class="page">
    <p>Attack (ret2dir) Bypassing SMEP/SMAP, PXN, PaX, kGuard</p>
    <p>Locating Synonyms (contd) Leaking PFNs via /proc (2/2)</p>
    <p>F1 :kaddr = PHYS OFFSET + PAGE SIZE * (PFN(uaddr) - PFN MIN)</p>
    <p>I PHYS OFFSET ! Starting address of physmap in kernel space I PFN MIN ! 1st PFN (e.g., in ARM Versatile RAM starts at 0x60000000; PFN MIN = 0x60000)</p>
    <p>Architecture PHYS OFFSET</p>
    <p>x86 (3G/1G) 0xC0000000 (2G/2G) 0x80000000 (1G/3G) 0x40000000</p>
    <p>AArch32 (3G/1G) 0xC0000000 (2G/2G) 0x80000000 (1G/3G) 0x40000000</p>
    <p>x86-64 0xFFFF880000000000</p>
    <p>AArch64 0xFFFFFFC000000000</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 12 / 40</p>
  </div>
  <div class="page">
    <p>Attack (ret2dir) Bypassing SMEP/SMAP, PXN, PaX, kGuard</p>
    <p>Locating Synonyms (contd) ret2dir without access to /proc/&lt;pid&gt;/pagemap</p>
    <p>Q: What if PFN information is not available?</p>
    <p>physmap spraying ! Very similar to how heap spraying works 1. Pollute physmap with aligned copies of the exploit payload</p>
    <p>I Maximize the exploit foothold on physmap</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 13 / 40</p>
  </div>
  <div class="page">
    <p>Attack (ret2dir) Bypassing SMEP/SMAP, PXN, PaX, kGuard</p>
    <p>Locating Synonyms (contd) ret2dir without access to /proc/&lt;pid&gt;/pagemap</p>
    <p>Q: What if PFN information is not available?</p>
    <p>physmap spraying ! Very similar to how heap spraying works 1. Pollute physmap with aligned copies of the exploit payload</p>
    <p>I Maximize the exploit foothold on physmap</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 13 / 40</p>
  </div>
  <div class="page">
    <p>Attack (ret2dir) Bypassing SMEP/SMAP, PXN, PaX, kGuard</p>
    <p>Evaluation ret2dir eectiveness</p>
    <p>EDB-ID Arch. Kernel Payload Protection Bypassed</p>
    <p>Custom x86 3.12 STRUCT+ROP |KERNEXEC|UDEREF|kGuard*|SMEP|SMAP| | 3 Custom x86-64 3.12 STRUCT+ROP |KERNEXEC|UDEREF|kGuard*|SMEP|SMAP| | 3 Custom AArch32 3.8.7 STRUCT+SHELLCODE |KERNEXEC|UDEREF|kGuard | | | | 3 Custom AArch64 3.12 STRUCT+SHELLCODE | | |kGuard | | |PXN| 3</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 14 / 40</p>
  </div>
  <div class="page">
    <p>Attack (ret2dir) Bypassing SMEP/SMAP, PXN, PaX, kGuard</p>
    <p>Evaluation ret2dir eectiveness</p>
    <p>EDB-ID Arch. Kernel Payload Protection Bypassed</p>
    <p>Custom x86 3.12 STRUCT+ROP |KERNEXEC|UDEREF|kGuard*|SMEP|SMAP| | 3 Custom x86-64 3.12 STRUCT+ROP |KERNEXEC|UDEREF|kGuard*|SMEP|SMAP| | 3 Custom AArch32 3.8.7 STRUCT+SHELLCODE |KERNEXEC|UDEREF|kGuard | | | | 3 Custom AArch64 3.12 STRUCT+SHELLCODE | | |kGuard | | |PXN| 3</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 14 / 40</p>
  </div>
  <div class="page">
    <p>Defense (XPFO) Design &amp; implementation</p>
    <p>Defending against ret2dir Attacks Design</p>
    <p>eXclusive Page Frame Ownerwhip (XPFO)</p>
    <p>I Thin mgmt. layer over the buddy allocator ! Exclusive ownership (of page frames) by either the kernel or userland X Unless explicitly requested by a kernel component</p>
    <p>(e.g., to implement zero-copy buers)</p>
    <p>I Reclaimed page frames are always wiped out before remapping</p>
    <p>X Performance-critical kernel allocators are not aected ! Low extra overhead whenever page frames are alloted to (or reclaimed from) user processes</p>
    <p>Aligns well with demand paging &amp; COW</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 15 / 40</p>
  </div>
  <div class="page">
    <p>Defense (XPFO) Performance</p>
    <p>Evaluation XPFO performance</p>
    <p>Benchmark Metric Original XPFO (%Overhead) Apache Req/s 17636.30 17456.47 (%1.02) NGINX Req/s 16626.05 16186.91 (%2.64) PostgreSQL Trans/s 135.01 134.62 (%0.29) Kbuild sec 67.98 69.66 (%2.47) Kextract sec 12.94 13.10 (%1.24) GnuPG sec 13.61 13.72 (%0.80) OpenSSL Sign/s 504.50 503.57 (%0.18) PyBench ms 3017.00 3025.00 (%0.26) PHPBench Score 71111.00 70979.00 (%0.18) IOzone MB/s 70.12 69.43 (%0.98) tiobench MB/s 0.82 0.81 (%1.22) dbench MB/s 20.00 19.76 (%1.20) PostMark Trans/s 411.00 399.00 (%2.91)</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 16 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Summary physmap is considered harmful</p>
    <p>physmap region(s) in kernel space is a bad idea I ret2dir Deconstructs the isolation guarantees of ret2usr</p>
    <p>protections (SMEP/SMAP, PXN, PaX, kGuard) I XPFO Low overhead defense against ret2dir attacks</p>
    <p>Code (ret2dir exploits &amp; XPFO patch) http://www.cs.columbia.edu/vpk/research/ret2dir/</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 17 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Bonus Slides</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 18 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>The Kernel as a Target Why care?</p>
    <p>Kernel attacks are becoming (more) common</p>
    <p>I Sergey Glazunov (Pwnie Awards) 14 bugs to takedown Chrome A Tale of Two Pwnies (http://blog.chromium.org)</p>
    <p>[KERNEL]</p>
    <p>W^X RELRO BIND_NOW</p>
    <p>STACK_PROT HEAP_PROT</p>
    <p>FORTIFY_SRC ASLR</p>
    <p>BPF_SECCOMP vs.</p>
    <p>[APP]</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 19 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Attacking the Core Threats classification</p>
    <p>I Direct kernel object manipulation (DKOM) cloaking 7 Kernel non-control data</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Kernel Vulnerabilities Current state of aairs (all vendors)</p>
    <p># of</p>
    <p>v ul</p>
    <p>ne ra</p>
    <p>bi lit</p>
    <p>ie s</p>
    <p>Year</p>
    <p>Kernel vulnerabilities per year</p>
    <p>Source: National Vulnerability Database (http://nvd.nist.gov)</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 21 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Kernel Vulnerabilities (contd) Current state of aairs (Linux only)</p>
    <p># of</p>
    <p>v ul</p>
    <p>ne ra</p>
    <p>bi lit</p>
    <p>ie s</p>
    <p>Year</p>
    <p>Linux kernel vulnerabilities per year</p>
    <p>Source: CVE Details (http://www.cvedetails.com)</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 22 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Threat Evolution Whats next?</p>
    <p>X SMEP/SMAP, PXN, KERNEXEC/UDEREF, kGuard ret2usr X KASLR, WX, stack canaries, SLAB red zones, const dispatch tbl.,</p>
    <p>.rodata sections, ... Traditional (kernel) exploitation</p>
    <p>What will next generation kernel exploits do?</p>
    <p>I ROP-based code execution?</p>
    <p>I Data-only attacks?</p>
    <p>I Subvert hardening mechanisms by chaining together component-specific vulnerabilities?</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 23 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Threat Evolution (contd) Theres still plenty of candy left</p>
    <p>I The kernel is highly volatile ! Sub-systems change every hour I New features &amp; optimizations ! New attack opportunities Kernel ver. Size Dev. days Patches Changes/hr Fixes</p>
    <p>Source: The Linux Foundation</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 24 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Kernel Space Layout Linux x86/x86-64</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 25 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Kernel Space Layout (contd) Solaris sun4u</p>
    <p>Source: Solaris Internals (2nd ed.)</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 26 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Kernel Space Layout (contd) Solaris x86-64</p>
    <p>Source: Solaris Internals (2nd ed.)</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 27 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>physmap Location, size, and access rights</p>
    <p>Architecture PHYS OFFSET Size Prot.</p>
    <p>x86 (3G/1G) 0xC0000000 891MB RW (2G/2G) 0x80000000 1915MB RW (1G/3G) 0x40000000 2939MB RW</p>
    <p>AArch32 (3G/1G) 0xC0000000 760MB RW(X) (2G/2G) 0x80000000 1784MB RW(X) (1G/3G) 0x40000000 2808MB RW(X)</p>
    <p>x86-64 0xFFFF880000000000 64TB RW(X)</p>
    <p>AArch64 0xFFFFFFC000000000 256GB RW(X)</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 28 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>The ret2dir Attack The devil is (always) in the detail</p>
    <p>Challenges</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 29 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Ensuring the Presence of Synonyms What if sizeof(physmap) &lt; sizeof(RAM)?</p>
    <p>C2: Force a synonym of payload to emerge inside physmap</p>
    <p>I PFN MAX = PFN MIN + min(sizeof(physmap),sizeof(RAM))/PAGE SIZE</p>
    <p>I If PFN(uaddr) &gt; PFN MAX ! @ synonym of uaddr in physmap</p>
    <p>Architecture Size</p>
    <p>x86 (3G/1G) 891MB (2G/2G) 1915MB (1G/3G) 2939MB</p>
    <p>AArch32 (3G/1G) 760MB (2G/2G) 1784MB (1G/3G) 2808MB</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 30 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Ensuring the Presence of Synonyms (contd) Physical memory organization in 32-bit Linux architectures</p>
    <p>Source: Understanding the Linux Kernel (2nd ed.)</p>
    <p>I ZONE DMA  16MB I ZONE DMA &lt; ZONE NORMAL  min(sizeof(physmap),sizeof(RAM)) I ZONE HIGHMEM &gt; ZONE NORMAL  /proc/buddyinfo, /proc/zoneinfo</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 31 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Ensuring the Presence of Synonyms (contd) Physical memory organization in 32-bit Linux architectures</p>
    <p>I Ordering: ZONE DMA &lt;  ZONE NORMAL &lt;  ZONE HIGHMEM 7 User space gets page frames from ZONE HIGHMEM</p>
    <p>I Preserve direct-mapped memory for dynamic requests from the kernel</p>
    <p>Q: Can we force the zone allocator to provide page frames in user space from ZONE {NORMAL,DMA}?</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 32 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Ensuring the Presence of Synonyms (contd) Physical memory organization in 32-bit Linux architectures</p>
    <p>I Ordering: ZONE DMA &lt;  ZONE NORMAL &lt;  ZONE HIGHMEM 7 User space gets page frames from ZONE HIGHMEM</p>
    <p>I Preserve direct-mapped memory for dynamic requests from the kernel</p>
    <p>Q: Can we force the zone allocator to provide page frames in user space from ZONE {NORMAL,DMA}?</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 32 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Ensuring the Presence of Synonyms (contd) What if sizeof(physmap) &lt; sizeof(RAM)?</p>
    <p>C2: Force a synonym of payload to emerge inside physmap</p>
    <p>I mlock(P) I Compute kaddr using F1 (P)</p>
    <p>If sizeof(uspace)  sizeof(RAM) ! Spawn additional process(es)  Memory pressure helps!</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 33 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Locating Contiguous Synonyms What if sizeof(payload) &gt; PAGE SIZE?</p>
    <p>C3: Force synonym pages to be contiguous in physmap</p>
    <p>I mlock(Pi,Pj) I Split the payload in Pi &amp; Pj (synonyms of Pi, Pj are contiguous) I Compute kaddr using F1 (min(Pi,Pj))</p>
    <p>PFN(0xBEEF000) = 0x2E7C2, 0xFEEB000 = 0x2E7C3  64MB apart in user space ! Contiguous in physmap</p>
    <p>([0xEE7C2000:0xEE7C3FFF])</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 34 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Locating Synonyms physmap spraying</p>
    <p>I The attacking process copies the exploit payload into N physmap-resident pages</p>
    <p>I The probability P that an arbitrarily chosen, page-aligned physmap address will contain the exploit payload is: P = N/(PFN MAX-PFN MIN)</p>
    <p>max(P)</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 35 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Locating Synonyms physmap spraying</p>
    <p>I The attacking process copies the exploit payload into N physmap-resident pages</p>
    <p>I The probability P that an arbitrarily chosen, page-aligned physmap address will contain the exploit payload is: P = N/(PFN MAX-PFN MIN)</p>
    <p>max(P)</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 35 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>physmap Spraying max(N)</p>
    <p>as dirty (e.g., by writing a single byte)</p>
    <p>If sizeof(uspace)  sizeof(RAM) ! Spawn additional process(es)</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 36 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>physmap Spraying (contd) min(PFN MAX-PFN MIN)</p>
    <p>Reduce the set of target pages in physmap ! physmap signatures I x86</p>
    <p>Page frame 0 is used by BIOS ! HW config. discovered during POST  [0xA0000:0xFFFFF] ! Memory-mapped RAM of video cards</p>
    <p>I x86-64 I 0x1000000 ! Kernel .text, .rodata, data, .bss</p>
    <p>I AArch32 I ...</p>
    <p>I AArch64 I ...</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 37 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Evaluation Spraying performance</p>
    <p>Physical Memory 1GB 2GB 4GB 8GB 16GB</p>
    <p>S uc</p>
    <p>ce ss</p>
    <p>P ro</p>
    <p>ba bi</p>
    <p>lit y</p>
    <p>I 2x 2.66GHz quad core Xeon X5500, 16GB RAM, 64-bit Debian Linux v7 I 5 repetitions of the same experiment, 95% confidence intervals (error bars)</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 38 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Evaluation Spraying performance</p>
    <p>Physical Memory 1GB 2GB 4GB 8GB 16GB</p>
    <p>S uc</p>
    <p>ce ss</p>
    <p>P ro</p>
    <p>ba bi</p>
    <p>lit y</p>
    <p>I 2x 2.66GHz quad core Xeon X5500, 16GB RAM, 64-bit Debian Linux v7 I 5 repetitions of the same experiment, 95% confidence intervals (error bars)</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 38 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Defending against ret2dir Attacks Implementation (1/2)</p>
    <p>XPFO Linux kernel v3.13 (500LOC) I struct page extended with XPFO fields +3MB per 1GB of RAM</p>
    <p>xpfo kmcnt (ref. counter), xpfo lock (spinlock), xpfo flags I Careful handling of page frame allocation/reclamation cases X Demand paging frames (anonymous &amp; shared memory mappings)</p>
    <p>[stack], brk, mmap/mmap2, mremap, shmat X COW frames</p>
    <p>fork, clone X Explicitly &amp; implicitly reclaimed frames</p>
    <p>exit, munmap, shmdt X Swapping (swapped out and swapped in pages) X NUMA frame migrations</p>
    <p>migrate pages, move pages X Huge pages &amp; transparent huge pages</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 39 / 40</p>
  </div>
  <div class="page">
    <p>Conclusion Recap</p>
    <p>Defending against ret2dir Attacks (contd) Implementation (2/2)</p>
    <p>Optimizations</p>
    <p>vpk@cs.columbia.edu (Columbia University) ret2dir USENIX Sec 14 40 / 40</p>
  </div>
</Presentation>
