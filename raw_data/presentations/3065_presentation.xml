<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Proving the correct execution of concurrent services in zero-knowledge</p>
    <p>Srinath Setty, Sebastian Angel, Trinabh Gupta,* and Jonathan Lee</p>
    <p>Microsoft Research UPenn *UCSB</p>
  </div>
  <div class="page">
    <p>Software verification</p>
    <p>Proving correct executions</p>
    <p>!= Verifies that code obeys a desired specification</p>
    <p>(first three talks)</p>
    <p>A cryptographic proof that desired code was correctly</p>
    <p>executed (this talk)</p>
    <p>Neither subsumes the other</p>
  </div>
  <div class="page">
    <p>key-value store</p>
    <p>clientId balance</p>
    <p>Consider a cloud-hosted wallet service (e.g., Square, WeChat Pay)</p>
    <p>API</p>
    <p>Issue ()</p>
    <p>Transfer()</p>
    <p>Withdraw()</p>
    <p>verifiers</p>
    <p>recorded trace</p>
    <p>Verify trace by replay</p>
  </div>
  <div class="page">
    <p>Issues with verifiability via record-and-replay</p>
    <p>Recorded trace can be large  network costs are high</p>
    <p>Verifiable state machines address both problems</p>
  </div>
  <div class="page">
    <p>key-value store</p>
    <p>verifiers</p>
    <p>recorded trace</p>
    <p>Verify trace by replay</p>
    <p>proofs</p>
    <p>Verify proofs</p>
    <p>Proofs are zero-knowledge: they do not reveal requests, responses, or the state</p>
    <p>Proofs are succinct: each proof is small and verification is inexpensive</p>
    <p>If the service errs, verifiers output reject (except for a small probability, &lt;1/2128)</p>
    <p>A verifiable state machine:</p>
    <p>clientId balance</p>
  </div>
  <div class="page">
    <p>Prior work on verifiable state machines</p>
    <p>Pantry[SOSP13], Geppetto[S&amp;P15], CTV[EUROCRYPT15], vSQL[S&amp;P17],</p>
    <p>The underlying theory dates back to 90s: Babai et al.[STOC91],</p>
    <p>Pepper[HotOS11, NDSS12], CMT[ITCS12], Ginger[Security12], TRMP[HotCloud12]</p>
    <p>Zaatar[EuroSys13], Pinocchio[S&amp;P13], Allspice[S&amp;P13], SNARKs-for-C[CRYPTO13]</p>
    <p>storage interfaces: key-value stores, etc.</p>
    <p>cost reductions by 1020x</p>
    <p>support stateful computations</p>
  </div>
  <div class="page">
    <p>Prior work suffers from two major issues</p>
    <p>Several seconds to minutes of CPU-time/operation</p>
    <p>For the wallet service app (on a single CPU core): Pantry [SOSP13] achieves &lt; 0.15 requests/second</p>
    <p>Geppetto [S&amp;P15] achieves &lt; 0.002 requests/second</p>
  </div>
  <div class="page">
    <p>Our system: Spice  Features a new storage primitive: 292000x more efficient</p>
    <p>Supports concurrent request processing, with transactional semantics</p>
    <p>Includes a toolchain:</p>
    <p>We built three apps: a wallet service, payment network, and a dark pool</p>
    <p>Throughput: 4881048 reqs/sec (512 CPU-cores)</p>
    <p>This is 18,000685,000 higher throughput than prior work</p>
    <p>the service executable</p>
    <p>the verifier executableA C program</p>
  </div>
  <div class="page">
    <p>Rest of this talk</p>
    <p>Background</p>
    <p>Overview of Spice</p>
    <p>Experimental results</p>
  </div>
  <div class="page">
    <p>Background: Pantry[SOSP13]</p>
    <p>Under Pantry, a service is expressed using:</p>
    <p>Arithmetic operations</p>
    <p>Bitwise operations</p>
    <p>Conditional control flow</p>
    <p>Volatile memory (with pointers)</p>
    <p>Loops (with bounded iterations)</p>
    <p>subset of C storage primitives</p>
    <p>Key-value ops: get, put, etc.</p>
  </div>
  <div class="page">
    <p>Mechanics of Pantry [SOSP13] to produce proofs</p>
    <p>compile (translates C to constraints)</p>
    <p>constraints</p>
    <p>int f(int a, int b) { return a*2  b;</p>
    <p>}</p>
    <p>C program</p>
    <p>(x1  2)  x3 = 0</p>
    <p>(x3  x2)  x4 = 0</p>
    <p>x1  input a = 0</p>
    <p>x2  input b = 0</p>
    <p>x4  output = 0</p>
    <p>translate</p>
    <p>execute and produce proofs (an argument protocol)</p>
    <p>verifier</p>
    <p>service</p>
    <p>proof</p>
    <p>build</p>
  </div>
  <div class="page">
    <p>Background: Pantry[SOSP13]</p>
    <p>Under Pantry, a service is expressed using:</p>
    <p>Arithmetic operations</p>
    <p>Bitwise operations</p>
    <p>Conditional control flow</p>
    <p>Volatile memory (with pointers)</p>
    <p>Loops (with bounded iterations)</p>
    <p>subset of C storage primitives</p>
  </div>
  <div class="page">
    <p>Value get(Key k) { Value v = service_get(k); return v;</p>
    <p>}</p>
    <p>clientId balance</p>
    <p>key-value store maintained by service</p>
    <p>An attempt:</p>
    <p>service supplies state</p>
    <p>service could supply incorrect values</p>
  </div>
  <div class="page">
    <p>Merkle trees provide the necessary building block</p>
    <p>hash</p>
    <p>data</p>
    <p>(k1, v1) (k2,v2)</p>
    <p>M</p>
    <p>(k3, v3) (k4,v4)</p>
    <p>N</p>
    <p>R</p>
    <p>Merkle root</p>
    <p>key-value store maintained by the service</p>
    <p>(k1, v1) (k2,v2)</p>
    <p>N</p>
    <p>R</p>
    <p>Value get(Key k, Root R) { Value *v = service_get(k);</p>
    <p>assert R == R; // fails for incorrect value return v[0];</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Issues with using Merkle trees for key-value stores</p>
    <p>supports only sequential executions</p>
  </div>
  <div class="page">
    <p>Rest of this talk</p>
    <p>Background</p>
    <p>Overview of Spice</p>
    <p>Experimental results</p>
  </div>
  <div class="page">
    <p>Spice in a nutshell:</p>
    <p>Arithmetic and bitwise ops</p>
    <p>Conditionals, loops, memory</p>
    <p>subset of C storage primitives</p>
    <p>readset</p>
    <p>write-set</p>
    <p>[Blum et al. FOCS91, Clarke et al. ASIACRYPT03,</p>
    <p>Arasu et al. SIGMOD17]</p>
    <p>Succinct zero-knowledge proof</p>
    <p>Compile and apply argument protocol</p>
  </div>
  <div class="page">
    <p>read-set write-set</p>
    <p>services state</p>
    <p>Insert(k,v): (k,v,0)</p>
    <p>get(k)  v, 0</p>
    <p>(k,v,0) (k,v,0), (k,v,1)</p>
    <p>read-set is a subset of write-set</p>
    <p>get(k)  w, 0</p>
    <p>(k,w,0) (k,v,0), (k,w,1)</p>
    <p>read-set is a not subset of write-set</p>
  </div>
  <div class="page">
    <p>Set-Hash = Set-Hash * Set-Hash A, B,</p>
    <p>A B</p>
    <p>= Set-Hash * Set-HashB A</p>
    <p>writeset</p>
    <p>readset</p>
    <p>struct set-root { set-hash rs; // set-hash of read-set set-hash ws;</p>
    <p>}</p>
    <p>services state An equivalent of Merkle root</p>
  </div>
  <div class="page">
    <p>Takeaways on set-based storage:</p>
    <p>get, put add an element to read-set and write-set</p>
    <p>cost of a get, put is a constant</p>
    <p>service periodically proves read-set \subset write-set</p>
    <p>cost is linear in state size, but amortized over a batch</p>
    <p>non-conflicting set operations commute</p>
    <p>multiple writers and concurrent request processing</p>
  </div>
  <div class="page">
    <p>mutual-exclusion: lock, unlock</p>
    <p>set-based key-value store</p>
    <p>transactions: one-shot, 2PL,</p>
    <p>C library (2,000 LOC)</p>
    <p>Wallet service</p>
    <p>Payment network</p>
    <p>Dark pool Apps (1,500 LOC)</p>
    <p>We built transactions and apps atop set-based storage</p>
  </div>
  <div class="page">
    <p>Rest of this talk</p>
    <p>Background</p>
    <p>Overview of Spice</p>
    <p>Experimental results</p>
  </div>
  <div class="page">
    <p>Evaluation questions</p>
    <p>Evaluation testbed:</p>
    <p>Azure D64s_v3 instances: 32 CPUs, 2.4 Ghz Intel Xeon, 256 GB RAM, running Ubuntu 17.04</p>
  </div>
  <div class="page">
    <p>(1) How does Spice compare to prior work?</p>
    <p>get put</p>
    <p>Pantry [SOSP13] 0.078 0.039</p>
    <p>Pantry++ 0.15 0.076</p>
    <p>Geppetto [S&amp;P15] 0.002 0.002</p>
    <p>Spice (1-thread) 3.6 3.6</p>
    <p>Spice (512-threads) 1,366 1,370</p>
    <p>A million key-value pairs</p>
    <p>Transactions with a single operation, keys chosen with a uniform distribution</p>
    <p>Metric: number of ops/second (i.e., proofs/sec)</p>
  </div>
  <div class="page">
    <p>(2) End-to-end performance with varying #CPUs</p>
    <p>TPS is 18,000685,000x better than prior state-of-the-art  Verification throughput: &gt;1,000 proof verifications/sec (4 CPU-cores)</p>
    <p>issue transfer retire debit credit submit</p>
    <p>T h</p>
    <p>ro u</p>
    <p>g h</p>
    <p>p u</p>
    <p>t (r</p>
    <p>e q</p>
    <p>s/ se</p>
    <p>c) 1 core 4 cores 16 cores 64 cores 256 cores 512 cores</p>
  </div>
  <div class="page">
    <p>Limitations of Spice</p>
    <p>experiments)</p>
    <p>Tunable, but lower latency increases CPU-costs</p>
  </div>
  <div class="page">
    <p>Summary  Verifiable state machines add verifiability to serviceswithout</p>
    <p>compromising their privacy</p>
    <p>Spice is a substantial progress toward building verifiable state machines  18,000685,000x better performance (over prior state-of-the-art)</p>
    <p>Spice supports realistic apps with thousands of transactions/sec</p>
    <p>We predict: Spice or a variant will be a key tool in building secure systems</p>
  </div>
</Presentation>
