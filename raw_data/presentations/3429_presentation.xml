<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Efficient Protection of Path-Sensitive Control Security</p>
    <p>Ren Ding, Chenxiong Qian, Chengyu Song*, Bill Harris, Taesoo Kim, Wenke Lee</p>
    <p>Georgia Tech, UC Riverside*</p>
  </div>
  <div class="page">
    <p>What is Control Flow?</p>
    <p>The order of instruction execution</p>
    <p>Only limited sets of valid transitions</p>
  </div>
  <div class="page">
    <p>What is Control Hijacking?</p>
  </div>
  <div class="page">
    <p>Reported Software Flaws - Buffer Errors</p>
    <p>Control Flow Attacks Still Exist...</p>
    <p>ATTACK Year DEFENSE</p>
    <p>Stack smashing 1996</p>
    <p>Ret2libc 1997</p>
    <p>Format string Heap overflow</p>
    <p>Integer overflow</p>
    <p>Info leak to bypass ASLR 2002</p>
    <p>Softbound 2009</p>
    <p>CETS 2010</p>
    <p>Cfimon Control-flow locking</p>
    <p>Kbouncer 2013</p>
    <p>Modular CFI ROPecker</p>
    <p>Hardware-assisted CFI CPI</p>
    <p>Opaque CFI Per-Input CFI</p>
    <p>Context-Sensitive CFI</p>
    <p>Control Jujutsu COOP</p>
    <p>Griffin FlowGuard</p>
  </div>
  <div class="page">
    <p>Control Flow Integrity (CFI)</p>
    <p>Lightweight</p>
    <p>Runtime Enforcement</p>
    <p>Pre-computed valid sets: points-to analysis</p>
    <p>Limitations: over-approximation for soundness!</p>
  </div>
  <div class="page">
    <p>Motivating Example</p>
    <p>Parse request</p>
    <p>Assign handler fptr o If request from admin:</p>
    <p>handler() = priv</p>
    <p>o else:  handler() = unpriv</p>
    <p>Strip request args</p>
    <p>Handle request</p>
  </div>
  <div class="page">
    <p>Motivating Example</p>
    <p>req</p>
    <p>handler</p>
    <p>ret addr</p>
    <p>high</p>
    <p>low</p>
    <p>strip_args ()</p>
    <p>dispatch ()</p>
    <p>Shellcode</p>
    <p>libc.so</p>
    <p>priv()</p>
    <p>unpriv()</p>
  </div>
  <div class="page">
    <p>Limitation of Traditional CFI</p>
    <p>Computes valid transfer sets at each location (lack dynamic info)</p>
    <p>parse_request()</p>
    <p>if admin: priv() else: unpriv()</p>
    <p>handler()</p>
    <p>priv() &amp; unpriv()</p>
  </div>
  <div class="page">
    <p>Per-Input CFI:</p>
    <p>Most Precise Known CFI</p>
    <p>Relies on static analysis for soundness</p>
    <p>Instrumentation required</p>
    <p>Enable valid target based on execution history for addresses that are taken</p>
  </div>
  <div class="page">
    <p>Limitation of Per-Input CFI</p>
    <p>Once transfer targets enabled, cannot be eliminated</p>
    <p>parse_request()</p>
    <p>if admin: priv()</p>
    <p>handler()</p>
    <p>priv() &amp; unpriv()priv()</p>
    <p>else: unpriv()</p>
  </div>
  <div class="page">
    <p>PITTYPAT: Path-Sensitive CFI</p>
    <p>At each control transfer, verify based on points-to analysis of whole execution path</p>
    <p>parse_request()</p>
    <p>if admin: priv() else: unpriv()</p>
    <p>handler()</p>
    <p>unpriv()priv()</p>
  </div>
  <div class="page">
    <p>Assumptions</p>
    <p>Current approach only examines control security</p>
    <p>Non-control data is out of scope</p>
    <p>Not a memory safety solution</p>
  </div>
  <div class="page">
    <p>Challenges</p>
    <p>Collecting executed path information and share for analysis efficiently</p>
    <p>Trace information cannot be tampered</p>
    <p>Compute points-to relations online both efficiently and precisely</p>
  </div>
  <div class="page">
    <p>Our Solution Per Challenge</p>
    <p>Intel Processor Trace (PT)</p>
    <p>Incremental Online Points-to Analysis</p>
  </div>
  <div class="page">
    <p>Intel Processor Trace</p>
    <p>Low-overhead commodity hardware</p>
    <p>Compressed packets to save bandwidth</p>
    <p>CR3 filtering</p>
    <p>Trace information shared &amp; protected efficiently</p>
  </div>
  <div class="page">
    <p>Incremental Points-to Analysis</p>
    <p>Input: o LLVM IR of target program</p>
    <p>o Metadata of mapping between IR and binary</p>
    <p>o Runtime execution trace</p>
    <p>Output: points-to relations on a single execution path</p>
  </div>
  <div class="page">
    <p>Things Differentiate Our Analysis</p>
    <p>Traditional static points-to analysis reasons about all paths for soundness</p>
    <p>Instead, we only reasons about points-to relation on one single path</p>
    <p>Maintain shadow callstack of instructions executed</p>
    <p>Most precise enforcement based on control data only</p>
  </div>
  <div class="page">
    <p>System Overview</p>
    <p>Monitor Module: o Kernel-space driver for PT</p>
    <p>o Shares taken branch information</p>
    <p>Analyzer Module: o User-space</p>
    <p>o Updates points-to relation based on trace</p>
  </div>
  <div class="page">
    <p>Challenging Language Features</p>
    <p>Signal handling</p>
    <p>Setjmp/Longjmp</p>
    <p>Exception Handling</p>
  </div>
  <div class="page">
    <p>Signal Handling</p>
    <p>; Function Attrs: nounwind uwtable</p>
    <p>define void @SIGKILL_handler(i32 %signo) #0 {</p>
    <p>entry:</p>
    <p>...</p>
    <p>if.then: ; preds = %entry</p>
    <p>...</p>
    <p>if.else: ; preds = %entry</p>
    <p>...</p>
    <p>if.end: ; preds = %if.else, %if.then</p>
    <p>ret void</p>
    <p>}</p>
    <p>; Function Attrs: nounwind uwtable</p>
    <p>define i32 @main() #0 {</p>
    <p>entry:</p>
    <p>%call1 = call void (i32)* @signal(i32 9, void (i32)* @SIGKILL_handler) #3</p>
    <p>ret i32 0</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Setjmp/Longjmp</p>
    <p>; Function Attrs: nounwind uwtable</p>
    <p>define void @hello() #0 {</p>
    <p>entry:</p>
    <p>...</p>
    <p>call void @longjmp(%struct.__jmp_buf_tag* getelementptr inbounds ([1 x</p>
    <p>%struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* @resume_here, i32 0,</p>
    <p>i32 0), i32 1) #4</p>
    <p>...</p>
    <p>}</p>
    <p>; Function Attrs: nounwind uwtable</p>
    <p>define i32 @main() #0 {</p>
    <p>entry:</p>
    <p>...</p>
    <p>%call1 = call i32 @_setjmp(%struct.__jmp_buf_tag* getelementptr inbounds</p>
    <p>([1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* @resume_here, i32</p>
    <p>...</p>
  </div>
  <div class="page">
    <p>; Function Attrs: norecurse uwtable</p>
    <p>define i32 @main() #4 personality i8* bitcast (i32</p>
    <p>(...)* @__gxx_personality_v0 to i8*) {</p>
    <p>entry:</p>
    <p>...</p>
    <p>%call = invoke i32 @_Z3foov()</p>
    <p>to label %invoke.cont unwind label %lpad</p>
    <p>invoke.cont: ;</p>
    <p>preds = %entry</p>
    <p>br label %try.cont</p>
    <p>lpad: ;</p>
    <p>preds = %entry</p>
    <p>%0 = landingpad { i8*, i32 }</p>
    <p>catch i8* bitcast (i8** @_ZTIi to i8*)</p>
    <p>catch i8* bitcast (i8** @_ZTIc to i8*)</p>
    <p>catch i8* null</p>
    <p>...</p>
    <p>Exception Handling</p>
  </div>
  <div class="page">
    <p>Optimizations on Analysis</p>
    <p>Only analyzing about calling context</p>
    <p>Maintains current executing IR block along with execution o To avoid decoding of PT traces and translation from binary address</p>
    <p>to IR</p>
    <p>Only analyze control-relevant functions and instructions</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Are benign applications satisfying path-sensitive CFI less susceptible to control hijacking attacks?</p>
    <p>Do malicious applications that satisfy weaker CFI mechanisms fail to satisfy current solution?</p>
    <p>Can we achieve path-sensitive CFI efficiently?</p>
  </div>
  <div class="page">
    <p>Forward Edge Points-to Set Size</p>
  </div>
  <div class="page">
    <p>RIPE</p>
    <p>Contains various vulnerabilities that can be exploited to hijack control flow</p>
    <p>Passed all 264 benchmark suites that compiled in the testing environment</p>
  </div>
  <div class="page">
    <p>Performance Overhead</p>
    <p>pi-CFI</p>
    <p>PittyPat</p>
  </div>
  <div class="page">
    <p>Limitations</p>
    <p>Non-control data corruption can not be detected</p>
    <p>Not reasoning about field sensitiveness for points-to analysis</p>
    <p>Performance might not be ideal as a CFI solution</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Define path-sensitive CFI</p>
    <p>Deploy practical mechanism for enforcement</p>
    <p>Strictly stronger security guarantees</p>
    <p>Acceptable runtime overhead in security critical settings</p>
  </div>
</Presentation>
