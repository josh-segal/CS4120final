<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Automatically Correcting Networks with NEAt</p>
    <p>Wenxuan Zhou, Jason Croft, Bingzhe Liu,</p>
    <p>Elaine Ang, Matthew Caesar University of Illinois at Urbana-Champaign</p>
  </div>
  <div class="page">
    <p>A simple idea about complexity</p>
    <p>Networks are so complex its hard to make sure theyre doing the right thing.</p>
  </div>
  <div class="page">
    <p>They instill policies on their behavior:</p>
    <p>no untrusted traffic entering a secure zone  the preference of one path over another  loop &amp; black hole avoidance</p>
    <p>What is a network supposed to do?</p>
    <p>Intents</p>
    <p>IPv 6</p>
    <p>OSPF-TE</p>
    <p>VPN</p>
    <p>VLAN NAT</p>
    <p>An yc</p>
    <p>as t</p>
    <p>RS VP</p>
    <p>-TE</p>
    <p>MPL SM</p>
    <p>ulticast</p>
    <p>Virtualization</p>
    <p>SDN</p>
    <p>CloudiBGP, eBGP IPSec</p>
  </div>
  <div class="page">
    <p>A Typical Enterprise Network</p>
  </div>
  <div class="page">
    <p>Network errors are common Lots of problems arise today</p>
    <p>Ebay Target JP Morgan Chase</p>
    <p>Home Depot</p>
    <p>Korea Credit Bureau</p>
    <p>US Office of Personnel Management AshleyMadison.com</p>
    <p>Anthem European Central Bank</p>
    <p>Sony Pictures StaplesUPS</p>
    <p>Uber</p>
    <p>Vodafone</p>
    <p>Twitch.tvJapan Airlines</p>
    <p>Premera</p>
    <p>CarPhone Warehouse</p>
    <p>Adult Friend Finder AOL Community Health Service</p>
    <p>Slack NMBS</p>
    <p>NASDAQ</p>
    <p>Washington State court system</p>
    <p>Mozilla</p>
    <p>New York Taxis</p>
    <p>Neiman Marcus</p>
    <p>MSpyHacking Team</p>
    <p>Kissinger Cables</p>
    <p>Dominos Pizzas</p>
    <p>D&amp;B. Altegrity</p>
    <p>Carefirst</p>
    <p>British Airways</p>
    <p>Australian Immigration Department</p>
  </div>
  <div class="page">
    <p>Networks are so complex its hard to make sure theyre doing the right thing.</p>
    <p>Lets automate.</p>
    <p>What to automate?</p>
  </div>
  <div class="page">
    <p>Many have tried.</p>
    <p>Automatically identifying errors in networks (Verification)</p>
    <p>Automatically synthesize correct networks</p>
    <p>repairs. Furthermore, an interactive mode would allow the application to ensure its state is consistent with that of the network, as it can update its own state after choosing one of several potential repairs for the policy-violating update.</p>
    <p>At the core of NEAt is a verification and correction layer, which ensures only updates conforming to the network policies are sent onto the network. This layer receives updates from one of two integration modes with the SDN control infrastructure: pass-through and interactive.</p>
    <p>Policy</p>
    <p>X</p>
    <p>X</p>
    <p>NEAt Network Model</p>
    <p>Verication Engine</p>
    <p>Correction Engine</p>
    <p>Compressor</p>
    <p>Optimizer</p>
    <p>Network Events</p>
    <p>Yes</p>
    <p>No</p>
    <p>Updates</p>
    <p>Figure 1: System architecture of NEAt. NEAts verification and correction engines ensure the</p>
    <p>network is always consistent with the defined policy. To start, NEAt takes as input a policy graph ( 1 ), which defines the network policies (e.g., reachability, segmentation, waypointing) in the form of a directed graph. Next, NEAt receives updates (e.g., flow modification messages) from the SDN control infrastructure. With each update ( 2 ), NEAt applies the change to a network model, from which the ECs affected by the update are computed. Using the policy graph, NEAt checks each affected EC in the network model for policy violations using the verification engine ( 3 ). If the update does not introduce any violations, it is sent onto the network. However, if it does introduce a violation, the configuration graph and topology graph are compressed and passed to the correction engine ( 4 ). The optimizer returns a set of edges to be added or removed to the ECs configuration graph, which are then applied to the network model, converted to OpenFlow rules, and sent to the forwarding devices ( 5 ).</p>
    <p>NEAts correction engine models the process of discovering repairs as an optimization problem. Our exploration of alternative approaches guided us toward this optimization problem-based solution for performance con</p>
    <p>siderations. For example, consider a brute force approach that discovers repairs for a given EC by testing all possible permutations of edge additions and removals to the ECs configuration graph. A repair that requires only adding edges, from 10 possible unused topology edges, would need to explore 10! (3.6M) permutations. If the violating property can be checked in just 1ms, each EC could take up to 10 minutes to find a repair. Therefore we use the formulation described in 5 for our repair discovery process.</p>
    <p>Figure 2: Interaction modes of NEAt.</p>
    <p>With each repair, inconsistencies between application state and network state will arise. To prevent applications from diverging from the underlying network state, NEAt exposes two integration modes: pass-through and interactive.</p>
    <p>In pass-through mode, NEAt acts as a transparent layer that sits between the controller and forwarding devices. This mode enforces network policies without modifications to the controller applications. Both the controller and applications are unaware of NEAt in this mode. NEAt intercepts updates from the controller, as well as updates from the network about link and switch state, and passes it to the verification and repair engines.</p>
    <p>Interactive mode enables applications to leverage NEAts verification and repair process by checking proposed updates. An application passes to NEAt a set of updates, which are checked against the current network model. If the updates introduce a violation, NEAt returns a set of repaired updates, which the application can accept or reject. If the application accepts the changes, it can send them onto the network and update its state, ensuring the application and network state are consistent. If the application rejects the changes, it can propose another set of updates to NEAt. Interactive mode requires modifications to applications to update its state with the accepted change.</p>
    <p>NEAt maintains consistency between the interaction modes, allowing applications and the controller to both simultaneously benefit from NEAts automated repair. For example, one application can use NEAts API while another remains unmodified, allowing its updates to be checked by NEAt in pass-through mode.</p>
    <p>Policies</p>
    <p>Network abstraction</p>
    <p>Verifier</p>
    <p>Repair</p>
    <p>Manual Intervention</p>
    <p>Policies Synthesizer</p>
    <p>repairs. Furthermore, an interactive mode would allow the application to ensure its state is consistent with that of the network, as it can update its own state after choosing one of several potential repairs for the policy-violating update.</p>
    <p>At the core of NEAt is a verification and correction layer, which ensures only updates conforming to the network policies are sent onto the network. This layer receives updates from one of two integration modes with the SDN control infrastructure: pass-through and interactive.</p>
    <p>Policy</p>
    <p>X</p>
    <p>X</p>
    <p>NEAt Network Model</p>
    <p>Verication Engine</p>
    <p>Correction Engine</p>
    <p>Compressor</p>
    <p>Optimizer</p>
    <p>Network Events</p>
    <p>Yes</p>
    <p>No</p>
    <p>Updates</p>
    <p>Figure 1: System architecture of NEAt. NEAts verification and correction engines ensure the</p>
    <p>network is always consistent with the defined policy. To start, NEAt takes as input a policy graph ( 1 ), which defines the network policies (e.g., reachability, segmentation, waypointing) in the form of a directed graph. Next, NEAt receives updates (e.g., flow modification messages) from the SDN control infrastructure. With each update ( 2 ), NEAt applies the change to a network model, from which the ECs affected by the update are computed. Using the policy graph, NEAt checks each affected EC in the network model for policy violations using the verification engine ( 3 ). If the update does not introduce any violations, it is sent onto the network. However, if it does introduce a violation, the configuration graph and topology graph are compressed and passed to the correction engine ( 4 ). The optimizer returns a set of edges to be added or removed to the ECs configuration graph, which are then applied to the network model, converted to OpenFlow rules, and sent to the forwarding devices ( 5 ).</p>
    <p>NEAts correction engine models the process of discovering repairs as an optimization problem. Our exploration of alternative approaches guided us toward this optimization problem-based solution for performance con</p>
    <p>siderations. For example, consider a brute force approach that discovers repairs for a given EC by testing all possible permutations of edge additions and removals to the ECs configuration graph. A repair that requires only adding edges, from 10 possible unused topology edges, would need to explore 10! (3.6M) permutations. If the violating property can be checked in just 1ms, each EC could take up to 10 minutes to find a repair. Therefore we use the formulation described in 5 for our repair discovery process.</p>
    <p>Figure 2: Interaction modes of NEAt.</p>
    <p>With each repair, inconsistencies between application state and network state will arise. To prevent applications from diverging from the underlying network state, NEAt exposes two integration modes: pass-through and interactive.</p>
    <p>In pass-through mode, NEAt acts as a transparent layer that sits between the controller and forwarding devices. This mode enforces network policies without modifications to the controller applications. Both the controller and applications are unaware of NEAt in this mode. NEAt intercepts updates from the controller, as well as updates from the network about link and switch state, and passes it to the verification and repair engines.</p>
    <p>Interactive mode enables applications to leverage NEAts verification and repair process by checking proposed updates. An application passes to NEAt a set of updates, which are checked against the current network model. If the updates introduce a violation, NEAt returns a set of repaired updates, which the application can accept or reject. If the application accepts the changes, it can send them onto the network and update its state, ensuring the application and network state are consistent. If the application rejects the changes, it can propose another set of updates to NEAt. Interactive mode requires modifications to applications to update its state with the accepted change.</p>
    <p>NEAt maintains consistency between the interaction modes, allowing applications and the controller to both simultaneously benefit from NEAts automated repair. For example, one application can use NEAts API while another remains unmodified, allowing its updates to be checked by NEAt in pass-through mode.</p>
    <p>repairs. Furthermore, an interactive mode would allow the application to ensure its state is consistent with that of the network, as it can update its own state after choosing one of several potential repairs for the policy-violating update.</p>
    <p>At the core of NEAt is a verification and correction layer, which ensures only updates conforming to the network policies are sent onto the network. This layer receives updates from one of two integration modes with the SDN control infrastructure: pass-through and interactive.</p>
    <p>Policy</p>
    <p>X</p>
    <p>X</p>
    <p>NEAt Network Model</p>
    <p>Verication Engine</p>
    <p>Correction Engine</p>
    <p>Compressor</p>
    <p>Optimizer</p>
    <p>Network Events</p>
    <p>Yes</p>
    <p>No</p>
    <p>Updates</p>
    <p>Figure 1: System architecture of NEAt. NEAts verification and correction engines ensure the</p>
    <p>network is always consistent with the defined policy. To start, NEAt takes as input a policy graph ( 1 ), which defines the network policies (e.g., reachability, segmentation, waypointing) in the form of a directed graph. Next, NEAt receives updates (e.g., flow modification messages) from the SDN control infrastructure. With each update ( 2 ), NEAt applies the change to a network model, from which the ECs affected by the update are computed. Using the policy graph, NEAt checks each affected EC in the network model for policy violations using the verification engine ( 3 ). If the update does not introduce any violations, it is sent onto the network. However, if it does introduce a violation, the configuration graph and topology graph are compressed and passed to the correction engine ( 4 ). The optimizer returns a set of edges to be added or removed to the ECs configuration graph, which are then applied to the network model, converted to OpenFlow rules, and sent to the forwarding devices ( 5 ).</p>
    <p>NEAts correction engine models the process of discovering repairs as an optimization problem. Our exploration of alternative approaches guided us toward this optimization problem-based solution for performance con</p>
    <p>siderations. For example, consider a brute force approach that discovers repairs for a given EC by testing all possible permutations of edge additions and removals to the ECs configuration graph. A repair that requires only adding edges, from 10 possible unused topology edges, would need to explore 10! (3.6M) permutations. If the violating property can be checked in just 1ms, each EC could take up to 10 minutes to find a repair. Therefore we use the formulation described in 5 for our repair discovery process.</p>
    <p>Figure 2: Interaction modes of NEAt.</p>
    <p>With each repair, inconsistencies between application state and network state will arise. To prevent applications from diverging from the underlying network state, NEAt exposes two integration modes: pass-through and interactive.</p>
    <p>In pass-through mode, NEAt acts as a transparent layer that sits between the controller and forwarding devices. This mode enforces network policies without modifications to the controller applications. Both the controller and applications are unaware of NEAt in this mode. NEAt intercepts updates from the controller, as well as updates from the network about link and switch state, and passes it to the verification and repair engines.</p>
    <p>Interactive mode enables applications to leverage NEAts verification and repair process by checking proposed updates. An application passes to NEAt a set of updates, which are checked against the current network model. If the updates introduce a violation, NEAt returns a set of repaired updates, which the application can accept or reject. If the application accepts the changes, it can send them onto the network and update its state, ensuring the application and network state are consistent. If the application rejects the changes, it can propose another set of updates to NEAt. Interactive mode requires modifications to applications to update its state with the accepted change.</p>
    <p>NEAt maintains consistency between the interaction modes, allowing applications and the controller to both simultaneously benefit from NEAts automated repair. For example, one application can use NEAts API while another remains unmodified, allowing its updates to be checked by NEAt in pass-through mode.</p>
    <p>a compiler Repeated when policies change</p>
    <p>Do not cooperate with users (operators/applications)</p>
    <p>Q'EE%J:@*%),JJG('):H,(%G(&amp;*E':DE*%</p>
    <p>R:S,&amp;%IG&amp;&gt;E*%F,&amp;%/G))*//%,F%7&lt;?%</p>
    <p>Q*%(**&gt;%*U*)H.*%9:0/%+,%+*/+%7&lt;?%(*+9,&amp;@/% LI'/%+:E@V%:G+,J:H):EE0%+*/H(A%W4*(#E,9%344/%</p>
  </div>
  <div class="page">
    <p>What if we can automatically correct networks on the fly?</p>
    <p>repairs. Furthermore, an interactive mode would allow the application to ensure its state is consistent with that of the network, as it can update its own state after choosing one of several potential repairs for the policy-violating update.</p>
    <p>At the core of NEAt is a verification and correction layer, which ensures only updates conforming to the network policies are sent onto the network. This layer receives updates from one of two integration modes with the SDN control infrastructure: pass-through and interactive.</p>
    <p>Policy</p>
    <p>X</p>
    <p>X</p>
    <p>NEAt Network Model</p>
    <p>Verication Engine</p>
    <p>Correction Engine</p>
    <p>Compressor</p>
    <p>Optimizer</p>
    <p>Network Events</p>
    <p>Yes</p>
    <p>No</p>
    <p>Updates</p>
    <p>Figure 1: System architecture of NEAt. NEAts verification and correction engines ensure the</p>
    <p>network is always consistent with the defined policy. To start, NEAt takes as input a policy graph ( 1 ), which defines the network policies (e.g., reachability, segmentation, waypointing) in the form of a directed graph. Next, NEAt receives updates (e.g., flow modification messages) from the SDN control infrastructure. With each update ( 2 ), NEAt applies the change to a network model, from which the ECs affected by the update are computed. Using the policy graph, NEAt checks each affected EC in the network model for policy violations using the verification engine ( 3 ). If the update does not introduce any violations, it is sent onto the network. However, if it does introduce a violation, the configuration graph and topology graph are compressed and passed to the correction engine ( 4 ). The optimizer returns a set of edges to be added or removed to the ECs configuration graph, which are then applied to the network model, converted to OpenFlow rules, and sent to the forwarding devices ( 5 ).</p>
    <p>NEAts correction engine models the process of discovering repairs as an optimization problem. Our exploration of alternative approaches guided us toward this optimization problem-based solution for performance con</p>
    <p>siderations. For example, consider a brute force approach that discovers repairs for a given EC by testing all possible permutations of edge additions and removals to the ECs configuration graph. A repair that requires only adding edges, from 10 possible unused topology edges, would need to explore 10! (3.6M) permutations. If the violating property can be checked in just 1ms, each EC could take up to 10 minutes to find a repair. Therefore we use the formulation described in 5 for our repair discovery process.</p>
    <p>Figure 2: Interaction modes of NEAt.</p>
    <p>With each repair, inconsistencies between application state and network state will arise. To prevent applications from diverging from the underlying network state, NEAt exposes two integration modes: pass-through and interactive.</p>
    <p>In pass-through mode, NEAt acts as a transparent layer that sits between the controller and forwarding devices. This mode enforces network policies without modifications to the controller applications. Both the controller and applications are unaware of NEAt in this mode. NEAt intercepts updates from the controller, as well as updates from the network about link and switch state, and passes it to the verification and repair engines.</p>
    <p>Interactive mode enables applications to leverage NEAts verification and repair process by checking proposed updates. An application passes to NEAt a set of updates, which are checked against the current network model. If the updates introduce a violation, NEAt returns a set of repaired updates, which the application can accept or reject. If the application accepts the changes, it can send them onto the network and update its state, ensuring the application and network state are consistent. If the application rejects the changes, it can propose another set of updates to NEAt. Interactive mode requires modifications to applications to update its state with the accepted change.</p>
    <p>NEAt maintains consistency between the interaction modes, allowing applications and the controller to both simultaneously benefit from NEAts automated repair. For example, one application can use NEAts API while another remains unmodified, allowing its updates to be checked by NEAt in pass-through mode.</p>
    <p>Policies</p>
    <p>Network abstraction</p>
    <p>?</p>
    <p>repairs. Furthermore, an interactive mode would allow the application to ensure its state is consistent with that of the network, as it can update its own state after choosing one of several potential repairs for the policy-violating update.</p>
    <p>At the core of NEAt is a verification and correction layer, which ensures only updates conforming to the network policies are sent onto the network. This layer receives updates from one of two integration modes with the SDN control infrastructure: pass-through and interactive.</p>
    <p>Policy</p>
    <p>X</p>
    <p>X</p>
    <p>NEAt Network Model</p>
    <p>Verication Engine</p>
    <p>Correction Engine</p>
    <p>Compressor</p>
    <p>Optimizer</p>
    <p>Network Events</p>
    <p>Yes</p>
    <p>No</p>
    <p>Updates</p>
    <p>Figure 1: System architecture of NEAt. NEAts verification and correction engines ensure the</p>
    <p>network is always consistent with the defined policy. To start, NEAt takes as input a policy graph ( 1 ), which defines the network policies (e.g., reachability, segmentation, waypointing) in the form of a directed graph. Next, NEAt receives updates (e.g., flow modification messages) from the SDN control infrastructure. With each update ( 2 ), NEAt applies the change to a network model, from which the ECs affected by the update are computed. Using the policy graph, NEAt checks each affected EC in the network model for policy violations using the verification engine ( 3 ). If the update does not introduce any violations, it is sent onto the network. However, if it does introduce a violation, the configuration graph and topology graph are compressed and passed to the correction engine ( 4 ). The optimizer returns a set of edges to be added or removed to the ECs configuration graph, which are then applied to the network model, converted to OpenFlow rules, and sent to the forwarding devices ( 5 ).</p>
    <p>NEAts correction engine models the process of discovering repairs as an optimization problem. Our exploration of alternative approaches guided us toward this optimization problem-based solution for performance con</p>
    <p>siderations. For example, consider a brute force approach that discovers repairs for a given EC by testing all possible permutations of edge additions and removals to the ECs configuration graph. A repair that requires only adding edges, from 10 possible unused topology edges, would need to explore 10! (3.6M) permutations. If the violating property can be checked in just 1ms, each EC could take up to 10 minutes to find a repair. Therefore we use the formulation described in 5 for our repair discovery process.</p>
    <p>Figure 2: Interaction modes of NEAt.</p>
    <p>With each repair, inconsistencies between application state and network state will arise. To prevent applications from diverging from the underlying network state, NEAt exposes two integration modes: pass-through and interactive.</p>
    <p>In pass-through mode, NEAt acts as a transparent layer that sits between the controller and forwarding devices. This mode enforces network policies without modifications to the controller applications. Both the controller and applications are unaware of NEAt in this mode. NEAt intercepts updates from the controller, as well as updates from the network about link and switch state, and passes it to the verification and repair engines.</p>
    <p>Interactive mode enables applications to leverage NEAts verification and repair process by checking proposed updates. An application passes to NEAt a set of updates, which are checked against the current network model. If the updates introduce a violation, NEAt returns a set of repaired updates, which the application can accept or reject. If the application accepts the changes, it can send them onto the network and update its state, ensuring the application and network state are consistent. If the application rejects the changes, it can propose another set of updates to NEAt. Interactive mode requires modifications to applications to update its state with the accepted change.</p>
    <p>NEAt maintains consistency between the interaction modes, allowing applications and the controller to both simultaneously benefit from NEAts automated repair. For example, one application can use NEAts API while another remains unmodified, allowing its updates to be checked by NEAt in pass-through mode.</p>
  </div>
  <div class="page">
    <p>What if we can automatically correct networks on the fly?</p>
    <p>repairs. Furthermore, an interactive mode would allow the application to ensure its state is consistent with that of the network, as it can update its own state after choosing one of several potential repairs for the policy-violating update.</p>
    <p>At the core of NEAt is a verification and correction layer, which ensures only updates conforming to the network policies are sent onto the network. This layer receives updates from one of two integration modes with the SDN control infrastructure: pass-through and interactive.</p>
    <p>Policy</p>
    <p>X</p>
    <p>X</p>
    <p>NEAt Network Model</p>
    <p>Verication Engine</p>
    <p>Correction Engine</p>
    <p>Compressor</p>
    <p>Optimizer</p>
    <p>Network Events</p>
    <p>Yes</p>
    <p>No</p>
    <p>Updates</p>
    <p>Figure 1: System architecture of NEAt. NEAts verification and correction engines ensure the</p>
    <p>network is always consistent with the defined policy. To start, NEAt takes as input a policy graph ( 1 ), which defines the network policies (e.g., reachability, segmentation, waypointing) in the form of a directed graph. Next, NEAt receives updates (e.g., flow modification messages) from the SDN control infrastructure. With each update ( 2 ), NEAt applies the change to a network model, from which the ECs affected by the update are computed. Using the policy graph, NEAt checks each affected EC in the network model for policy violations using the verification engine ( 3 ). If the update does not introduce any violations, it is sent onto the network. However, if it does introduce a violation, the configuration graph and topology graph are compressed and passed to the correction engine ( 4 ). The optimizer returns a set of edges to be added or removed to the ECs configuration graph, which are then applied to the network model, converted to OpenFlow rules, and sent to the forwarding devices ( 5 ).</p>
    <p>NEAts correction engine models the process of discovering repairs as an optimization problem. Our exploration of alternative approaches guided us toward this optimization problem-based solution for performance con</p>
    <p>siderations. For example, consider a brute force approach that discovers repairs for a given EC by testing all possible permutations of edge additions and removals to the ECs configuration graph. A repair that requires only adding edges, from 10 possible unused topology edges, would need to explore 10! (3.6M) permutations. If the violating property can be checked in just 1ms, each EC could take up to 10 minutes to find a repair. Therefore we use the formulation described in 5 for our repair discovery process.</p>
    <p>Figure 2: Interaction modes of NEAt.</p>
    <p>With each repair, inconsistencies between application state and network state will arise. To prevent applications from diverging from the underlying network state, NEAt exposes two integration modes: pass-through and interactive.</p>
    <p>In pass-through mode, NEAt acts as a transparent layer that sits between the controller and forwarding devices. This mode enforces network policies without modifications to the controller applications. Both the controller and applications are unaware of NEAt in this mode. NEAt intercepts updates from the controller, as well as updates from the network about link and switch state, and passes it to the verification and repair engines.</p>
    <p>Interactive mode enables applications to leverage NEAts verification and repair process by checking proposed updates. An application passes to NEAt a set of updates, which are checked against the current network model. If the updates introduce a violation, NEAt returns a set of repaired updates, which the application can accept or reject. If the application accepts the changes, it can send them onto the network and update its state, ensuring the application and network state are consistent. If the application rejects the changes, it can propose another set of updates to NEAt. Interactive mode requires modifications to applications to update its state with the accepted change.</p>
    <p>NEAt maintains consistency between the interaction modes, allowing applications and the controller to both simultaneously benefit from NEAts automated repair. For example, one application can use NEAts API while another remains unmodified, allowing its updates to be checked by NEAt in pass-through mode.</p>
    <p>Policies</p>
    <p>Network abstraction</p>
    <p>?</p>
    <p>repairs. Furthermore, an interactive mode would allow the application to ensure its state is consistent with that of the network, as it can update its own state after choosing one of several potential repairs for the policy-violating update.</p>
    <p>At the core of NEAt is a verification and correction layer, which ensures only updates conforming to the network policies are sent onto the network. This layer receives updates from one of two integration modes with the SDN control infrastructure: pass-through and interactive.</p>
    <p>Policy</p>
    <p>X</p>
    <p>X</p>
    <p>NEAt Network Model</p>
    <p>Verication Engine</p>
    <p>Correction Engine</p>
    <p>Compressor</p>
    <p>Optimizer</p>
    <p>Network Events</p>
    <p>Yes</p>
    <p>No</p>
    <p>Updates</p>
    <p>Figure 1: System architecture of NEAt. NEAts verification and correction engines ensure the</p>
    <p>network is always consistent with the defined policy. To start, NEAt takes as input a policy graph ( 1 ), which defines the network policies (e.g., reachability, segmentation, waypointing) in the form of a directed graph. Next, NEAt receives updates (e.g., flow modification messages) from the SDN control infrastructure. With each update ( 2 ), NEAt applies the change to a network model, from which the ECs affected by the update are computed. Using the policy graph, NEAt checks each affected EC in the network model for policy violations using the verification engine ( 3 ). If the update does not introduce any violations, it is sent onto the network. However, if it does introduce a violation, the configuration graph and topology graph are compressed and passed to the correction engine ( 4 ). The optimizer returns a set of edges to be added or removed to the ECs configuration graph, which are then applied to the network model, converted to OpenFlow rules, and sent to the forwarding devices ( 5 ).</p>
    <p>NEAts correction engine models the process of discovering repairs as an optimization problem. Our exploration of alternative approaches guided us toward this optimization problem-based solution for performance con</p>
    <p>siderations. For example, consider a brute force approach that discovers repairs for a given EC by testing all possible permutations of edge additions and removals to the ECs configuration graph. A repair that requires only adding edges, from 10 possible unused topology edges, would need to explore 10! (3.6M) permutations. If the violating property can be checked in just 1ms, each EC could take up to 10 minutes to find a repair. Therefore we use the formulation described in 5 for our repair discovery process.</p>
    <p>Figure 2: Interaction modes of NEAt.</p>
    <p>With each repair, inconsistencies between application state and network state will arise. To prevent applications from diverging from the underlying network state, NEAt exposes two integration modes: pass-through and interactive.</p>
    <p>In pass-through mode, NEAt acts as a transparent layer that sits between the controller and forwarding devices. This mode enforces network policies without modifications to the controller applications. Both the controller and applications are unaware of NEAt in this mode. NEAt intercepts updates from the controller, as well as updates from the network about link and switch state, and passes it to the verification and repair engines.</p>
    <p>Interactive mode enables applications to leverage NEAts verification and repair process by checking proposed updates. An application passes to NEAt a set of updates, which are checked against the current network model. If the updates introduce a violation, NEAt returns a set of repaired updates, which the application can accept or reject. If the application accepts the changes, it can send them onto the network and update its state, ensuring the application and network state are consistent. If the application rejects the changes, it can propose another set of updates to NEAt. Interactive mode requires modifications to applications to update its state with the accepted change.</p>
    <p>NEAt maintains consistency between the interaction modes, allowing applications and the controller to both simultaneously benefit from NEAts automated repair. For example, one application can use NEAts API while another remains unmodified, allowing its updates to be checked by NEAt in pass-through mode.</p>
    <p>Auto-correct is not a new idea.</p>
  </div>
  <div class="page">
    <p>Network Error Auto-Correct</p>
    <p>What if we can automatically correct networks on the fly?</p>
    <p>repairs. Furthermore, an interactive mode would allow the application to ensure its state is consistent with that of the network, as it can update its own state after choosing one of several potential repairs for the policy-violating update.</p>
    <p>At the core of NEAt is a verification and correction layer, which ensures only updates conforming to the network policies are sent onto the network. This layer receives updates from one of two integration modes with the SDN control infrastructure: pass-through and interactive.</p>
    <p>Policy</p>
    <p>X</p>
    <p>X</p>
    <p>NEAt Network Model</p>
    <p>Verication Engine</p>
    <p>Correction Engine</p>
    <p>Compressor</p>
    <p>Optimizer</p>
    <p>Network Events</p>
    <p>Yes</p>
    <p>No</p>
    <p>Updates</p>
    <p>Figure 1: System architecture of NEAt. NEAts verification and correction engines ensure the</p>
    <p>network is always consistent with the defined policy. To start, NEAt takes as input a policy graph ( 1 ), which defines the network policies (e.g., reachability, segmentation, waypointing) in the form of a directed graph. Next, NEAt receives updates (e.g., flow modification messages) from the SDN control infrastructure. With each update ( 2 ), NEAt applies the change to a network model, from which the ECs affected by the update are computed. Using the policy graph, NEAt checks each affected EC in the network model for policy violations using the verification engine ( 3 ). If the update does not introduce any violations, it is sent onto the network. However, if it does introduce a violation, the configuration graph and topology graph are compressed and passed to the correction engine ( 4 ). The optimizer returns a set of edges to be added or removed to the ECs configuration graph, which are then applied to the network model, converted to OpenFlow rules, and sent to the forwarding devices ( 5 ).</p>
    <p>NEAts correction engine models the process of discovering repairs as an optimization problem. Our exploration of alternative approaches guided us toward this optimization problem-based solution for performance con</p>
    <p>siderations. For example, consider a brute force approach that discovers repairs for a given EC by testing all possible permutations of edge additions and removals to the ECs configuration graph. A repair that requires only adding edges, from 10 possible unused topology edges, would need to explore 10! (3.6M) permutations. If the violating property can be checked in just 1ms, each EC could take up to 10 minutes to find a repair. Therefore we use the formulation described in 5 for our repair discovery process.</p>
    <p>Figure 2: Interaction modes of NEAt.</p>
    <p>With each repair, inconsistencies between application state and network state will arise. To prevent applications from diverging from the underlying network state, NEAt exposes two integration modes: pass-through and interactive.</p>
    <p>In pass-through mode, NEAt acts as a transparent layer that sits between the controller and forwarding devices. This mode enforces network policies without modifications to the controller applications. Both the controller and applications are unaware of NEAt in this mode. NEAt intercepts updates from the controller, as well as updates from the network about link and switch state, and passes it to the verification and repair engines.</p>
    <p>Interactive mode enables applications to leverage NEAts verification and repair process by checking proposed updates. An application passes to NEAt a set of updates, which are checked against the current network model. If the updates introduce a violation, NEAt returns a set of repaired updates, which the application can accept or reject. If the application accepts the changes, it can send them onto the network and update its state, ensuring the application and network state are consistent. If the application rejects the changes, it can propose another set of updates to NEAt. Interactive mode requires modifications to applications to update its state with the accepted change.</p>
    <p>NEAt maintains consistency between the interaction modes, allowing applications and the controller to both simultaneously benefit from NEAts automated repair. For example, one application can use NEAts API while another remains unmodified, allowing its updates to be checked by NEAt in pass-through mode.</p>
    <p>Policies</p>
    <p>Network abstraction</p>
    <p>NEAt</p>
    <p>repairs. Furthermore, an interactive mode would allow the application to ensure its state is consistent with that of the network, as it can update its own state after choosing one of several potential repairs for the policy-violating update.</p>
    <p>At the core of NEAt is a verification and correction layer, which ensures only updates conforming to the network policies are sent onto the network. This layer receives updates from one of two integration modes with the SDN control infrastructure: pass-through and interactive.</p>
    <p>Policy</p>
    <p>X</p>
    <p>X</p>
    <p>NEAt Network Model</p>
    <p>Verication Engine</p>
    <p>Correction Engine</p>
    <p>Compressor</p>
    <p>Optimizer</p>
    <p>Network Events</p>
    <p>Yes</p>
    <p>No</p>
    <p>Updates</p>
    <p>Figure 1: System architecture of NEAt. NEAts verification and correction engines ensure the</p>
    <p>network is always consistent with the defined policy. To start, NEAt takes as input a policy graph ( 1 ), which defines the network policies (e.g., reachability, segmentation, waypointing) in the form of a directed graph. Next, NEAt receives updates (e.g., flow modification messages) from the SDN control infrastructure. With each update ( 2 ), NEAt applies the change to a network model, from which the ECs affected by the update are computed. Using the policy graph, NEAt checks each affected EC in the network model for policy violations using the verification engine ( 3 ). If the update does not introduce any violations, it is sent onto the network. However, if it does introduce a violation, the configuration graph and topology graph are compressed and passed to the correction engine ( 4 ). The optimizer returns a set of edges to be added or removed to the ECs configuration graph, which are then applied to the network model, converted to OpenFlow rules, and sent to the forwarding devices ( 5 ).</p>
    <p>NEAts correction engine models the process of discovering repairs as an optimization problem. Our exploration of alternative approaches guided us toward this optimization problem-based solution for performance con</p>
    <p>siderations. For example, consider a brute force approach that discovers repairs for a given EC by testing all possible permutations of edge additions and removals to the ECs configuration graph. A repair that requires only adding edges, from 10 possible unused topology edges, would need to explore 10! (3.6M) permutations. If the violating property can be checked in just 1ms, each EC could take up to 10 minutes to find a repair. Therefore we use the formulation described in 5 for our repair discovery process.</p>
    <p>Figure 2: Interaction modes of NEAt.</p>
    <p>With each repair, inconsistencies between application state and network state will arise. To prevent applications from diverging from the underlying network state, NEAt exposes two integration modes: pass-through and interactive.</p>
    <p>In pass-through mode, NEAt acts as a transparent layer that sits between the controller and forwarding devices. This mode enforces network policies without modifications to the controller applications. Both the controller and applications are unaware of NEAt in this mode. NEAt intercepts updates from the controller, as well as updates from the network about link and switch state, and passes it to the verification and repair engines.</p>
    <p>Interactive mode enables applications to leverage NEAts verification and repair process by checking proposed updates. An application passes to NEAt a set of updates, which are checked against the current network model. If the updates introduce a violation, NEAt returns a set of repaired updates, which the application can accept or reject. If the application accepts the changes, it can send them onto the network and update its state, ensuring the application and network state are consistent. If the application rejects the changes, it can propose another set of updates to NEAt. Interactive mode requires modifications to applications to update its state with the accepted change.</p>
    <p>NEAt maintains consistency between the interaction modes, allowing applications and the controller to both simultaneously benefit from NEAts automated repair. For example, one application can use NEAts API while another remains unmodified, allowing its updates to be checked by NEAt in pass-through mode.</p>
    <p>Control plane</p>
    <p>Data plane</p>
    <p>Configuration</p>
    <p>Network behavior</p>
    <p>Network Abstraction</p>
    <p>Operating on the data plane simplifies our work</p>
    <p>Diagnose problems as close as possible to actual network behavior</p>
    <p>Data plane is a narrower waist than configuration</p>
  </div>
  <div class="page">
    <p>Challenges</p>
    <p>Goal: Improve upon a manual effort with transparency in both performance and architecture.</p>
    <p>Challenge 1: Repair speed</p>
    <p>Based on real-time verification technique  Derive fixes via linear optimization, with min. changes  Topology limitation &amp; graph compression</p>
    <p>Challenge 2: Zero/minimal architecture/application changes</p>
    <p>Minimal changes  Pass-through mode  Interactive mode</p>
  </div>
  <div class="page">
    <p>Design of NEAt</p>
    <p>Controller</p>
    <p>Policy</p>
    <p>Stream of Updates</p>
    <p>Corrected Updates</p>
    <p>NEAt</p>
  </div>
  <div class="page">
    <p>Design of NEAt</p>
    <p>NEAt</p>
    <p>Correction Engine</p>
    <p>Yes</p>
    <p>Controller</p>
    <p>No</p>
    <p>Policy</p>
    <p>Stream of Updates</p>
    <p>Network Events</p>
    <p>Network Model</p>
    <p>Verification Engine</p>
  </div>
  <div class="page">
    <p>Application Mode</p>
    <p>Controller</p>
    <p>NEAt</p>
    <p>Stream of Updates</p>
    <p>App App</p>
    <p>Suggested</p>
    <p>Changes</p>
    <p>Proposed Updates</p>
    <p>Interactive</p>
    <p>PassThrough</p>
  </div>
  <div class="page">
    <p>Policy as Graphs</p>
    <p>Graphs are neat</p>
    <p>Network state synthesis viewing the network as a whole.  Graphs richer set of policies.</p>
    <p>A policy graph is defined on a packet header pattern</p>
    <p>ip dst 10.0.1.0/24, port 443.</p>
    <p>A B(m,n)</p>
    <p>Reachability m = 1</p>
    <p>Bounded path length (shortest path)</p>
    <p>m =1 n = path_length</p>
    <p>Multipath/Resillience m = k (k &gt; 1)</p>
    <p>Isolation m = 0</p>
    <p>Policy</p>
  </div>
  <div class="page">
    <p>Policy as Graphs (Contd)</p>
    <p>Service Chaining</p>
    <p>A B (1,)</p>
    <p>D C(2,5)</p>
    <p>E</p>
    <p>(0,)</p>
    <p>(1,)</p>
    <p>S1</p>
    <p>S2</p>
    <p>S3</p>
    <p>S4</p>
    <p>S5</p>
    <p>C</p>
    <p>(15,)</p>
    <p>(15,)</p>
    <p>(15,) (15,)</p>
    <p>(15,)</p>
    <p>Use policy graphs to express both qualitative and quantitative reachability constraints</p>
    <p>Load balancing Policy</p>
  </div>
  <div class="page">
    <p>Repair Algorithm</p>
    <p>Cast the problem as an optimization problem:</p>
    <p>Map forwarding graph to policy graph  Minimize # of changes</p>
    <p>Network State</p>
    <p>e</p>
    <p>d</p>
    <p>h</p>
    <p>f i</p>
    <p>m</p>
    <p>l</p>
    <p>g a</p>
    <p>b</p>
    <p>p n</p>
    <p>jc</p>
    <p>k</p>
    <p>Policy Graph</p>
    <p>c</p>
    <p>k j</p>
    <p>Correction Engine</p>
  </div>
  <div class="page">
    <p>Repair - Basic Reachability</p>
    <p>Cast the problem as an optimization problem:</p>
    <p>Map forwarding graph to policy graph  Minimize # of changes  boolean variable xi, j, p, q:</p>
    <p>- topology edge (i, j) policy edge (p, q) - s.t., policy level reachability (p, q)</p>
    <p>Network State</p>
    <p>e</p>
    <p>d</p>
    <p>h</p>
    <p>f i</p>
    <p>m</p>
    <p>l</p>
    <p>g a</p>
    <p>b</p>
    <p>p n</p>
    <p>jc</p>
    <p>k</p>
    <p>Policy Graph</p>
    <p>c</p>
    <p>k j</p>
    <p>Correction Engine</p>
  </div>
  <div class="page">
    <p>Repair - Generalized Reachability</p>
    <p>undirected graph that represents the physical topology of the network.</p>
    <p>Algorithm Overview When the verification engine discovers a violated EC, the algorithm is executed. Its goal is to repair the detected violations optimally, i.e., with the minimum number of changes to the original configuration. Upon receiving the violated EC c together with its configuration graph `c, NEAt formulates the problem as an optimization problem: we aim to add or delete the minimum number of edges on `c so that the modified `c complies with c. c is a subgraph of  that is relevant to EC c. Note that the added or deleted edges are constrained within the topology graph T . We solve the optimization problem using ILP.</p>
    <p>Subsection 5.1 describes the repair algorithm for basic reachability policies, and subsection 5.2 enhances the basic algorithm to cope with the entire set of policies in 4. We complete the section with our repair algorithm for forwarding loops (5.3). Table 1 summarizes the key notations used in this section and the next section 6.</p>
    <p>Symbol Description</p>
    <p>`c The configuration graph for equivalence class c.</p>
    <p>The policy graph. T The topology graph. (i, j) The edge from node i to node j. ri j The paths between node i and node j. Cci The cluster of node i for equivalence class c. ci The compressed node i for Cci . E(a) The set of all edges in graph a. N(E(a)) Number of all edges in graph a.</p>
    <p>NBa(i) The set of all neighbors of node i in graph a.</p>
    <p>Table 1: Key notations in problem formulation.</p>
    <p>After receiving a configuration graph `c that violates the desired policies from the verification engine, the optimizer determines the minimum number of edges that needs to be added or deleted to ensure `c is consistent with the policy graph c using Integer Linear Programming (ILP). We start with the basic case where c contains only reachability constraints.</p>
    <p>Our integer program has a set of binary decision variables xi, j,p,q and xi, j where</p>
    <p>xi, j,p,q,(i, j) 2 ET ,(p,q) 2 Ec (1)</p>
    <p>xi, j,(i, j) 2 ET (2)</p>
    <p>ET and Ec denote the set of all edges in T and c respectively. Variable xi, j,p,q defines the mapping between a physical edge and a policy graph edge. It is 1 if a directed edge (i, j) is mapped to policy edge (p,q) for the current EC c, i.e., the flow from p to q will be forwarded through edge (i, j) from i to j. Variable xi, j defines whether or not edge (i, j) is used for forwarding this ECs traffic regardless of which flow uses it. Edge (i, j) in T is selected if any flow (p,q) is forwarded through (i, j) (Equation 3). Similarly, for the other direction ( j,i), we have Equation 4. No physical link can be selected to forward traffic for the same EC on both directions (Equation 5) to avoid tight loops.</p>
    <p>xi, j,p,q N(E)</p>
    <p>(3)</p>
    <p>x j,i,p,q N(E)</p>
    <p>(4)</p>
    <p>Equations 6-8 are the flow conservation equations for policy level reachability (p,q).</p>
    <p>j2NBT (i) xi, j,p,q = 1  j2NBT (i) x j,i,p,q = 0</p>
    <p>if i = p (6)</p>
    <p>(  j2NBT (i) xi, j,p,q = 0  j2NBT (i) x j,i,p,q = 1</p>
    <p>if i = q (7)</p>
    <p>n  j2NBT (i)(xi, j,p,q  x j,i,p,q) = 0 otherwise (8)</p>
    <p>The optimization objective is to minimize the number of changes (additions and deletions) on the original configuration graph `c.</p>
    <p>min (  (i, j)/2E`c</p>
    <p>xi, j   (i, j)2E`c</p>
    <p>xi, j) (9)</p>
    <p>To support generalized reachability policies as discussed in 4, we encode several additional constraints into the ILP. Isolation We introduce a special DROP node. If two nodes are required to be isolated, i.e., the nodes are connected with a (0,) edge in the policy graph, we change the way flow conservation equations are defined. More specifically, Equation 7 is changed to Equation 10. That is, a flow from p to q should sink at DROP before reaching q.</p>
    <p>undirected graph that represents the physical topology of the network.</p>
    <p>Algorithm Overview When the verification engine discovers a violated EC, the algorithm is executed. Its goal is to repair the detected violations optimally, i.e., with the minimum number of changes to the original configuration. Upon receiving the violated EC c together with its configuration graph `c, NEAt formulates the problem as an optimization problem: we aim to add or delete the minimum number of edges on `c so that the modified `c complies with c. c is a subgraph of  that is relevant to EC c. Note that the added or deleted edges are constrained within the topology graph T . We solve the optimization problem using ILP.</p>
    <p>Subsection 5.1 describes the repair algorithm for basic reachability policies, and subsection 5.2 enhances the basic algorithm to cope with the entire set of policies in 4. We complete the section with our repair algorithm for forwarding loops (5.3). Table 1 summarizes the key notations used in this section and the next section 6.</p>
    <p>Symbol Description</p>
    <p>`c The configuration graph for equivalence class c.</p>
    <p>The policy graph. T The topology graph. (i, j) The edge from node i to node j. ri j The paths between node i and node j. Cci The cluster of node i for equivalence class c. ci The compressed node i for Cci . E(a) The set of all edges in graph a. N(E(a)) Number of all edges in graph a.</p>
    <p>NBa(i) The set of all neighbors of node i in graph a.</p>
    <p>Table 1: Key notations in problem formulation.</p>
    <p>After receiving a configuration graph `c that violates the desired policies from the verification engine, the optimizer determines the minimum number of edges that needs to be added or deleted to ensure `c is consistent with the policy graph c using Integer Linear Programming (ILP). We start with the basic case where c contains only reachability constraints.</p>
    <p>Our integer program has a set of binary decision variables xi, j,p,q and xi, j where</p>
    <p>xi, j,p,q,(i, j) 2 ET ,(p,q) 2 Ec (1)</p>
    <p>xi, j,(i, j) 2 ET (2)</p>
    <p>ET and Ec denote the set of all edges in T and c respectively. Variable xi, j,p,q defines the mapping between a physical edge and a policy graph edge. It is 1 if a directed edge (i, j) is mapped to policy edge (p,q) for the current EC c, i.e., the flow from p to q will be forwarded through edge (i, j) from i to j. Variable xi, j defines whether or not edge (i, j) is used for forwarding this ECs traffic regardless of which flow uses it. Edge (i, j) in T is selected if any flow (p,q) is forwarded through (i, j) (Equation 3). Similarly, for the other direction ( j,i), we have Equation 4. No physical link can be selected to forward traffic for the same EC on both directions (Equation 5) to avoid tight loops.</p>
    <p>xi, j,p,q N(E)</p>
    <p>(3)</p>
    <p>x j,i,p,q N(E)</p>
    <p>(4)</p>
    <p>Equations 6-8 are the flow conservation equations for policy level reachability (p,q).</p>
    <p>j2NBT (i) xi, j,p,q = 1  j2NBT (i) x j,i,p,q = 0</p>
    <p>if i = p (6)</p>
    <p>(  j2NBT (i) xi, j,p,q = 0  j2NBT (i) x j,i,p,q = 1</p>
    <p>if i = q (7)</p>
    <p>n  j2NBT (i)(xi, j,p,q  x j,i,p,q) = 0 otherwise (8)</p>
    <p>The optimization objective is to minimize the number of changes (additions and deletions) on the original configuration graph `c.</p>
    <p>min (  (i, j)/2E`c</p>
    <p>xi, j   (i, j)2E`c</p>
    <p>xi, j) (9)</p>
    <p>To support generalized reachability policies as discussed in 4, we encode several additional constraints into the ILP. Isolation We introduce a special DROP node. If two nodes are required to be isolated, i.e., the nodes are connected with a (0,) edge in the policy graph, we change the way flow conservation equations are defined. More specifically, Equation 7 is changed to Equation 10. That is, a flow from p to q should sink at DROP before reaching q.</p>
    <p>Basic Reachability</p>
    <p>No tight loops</p>
    <p>Flow conservation</p>
    <p>Isolation</p>
    <p>Service Chaining</p>
    <p>Bounded or Equal Path Length</p>
    <p>MultiPath (Resilience)</p>
    <p>Load Balancing</p>
    <p>(  j2NBT (i) xi, j,p,q = 0  j2NBT (i) x j,i,p,q = 1</p>
    <p>if i = DROP (10)</p>
    <p>Service Chaining With service chaining, or waypointing, we enhance our flow conservation equations with Equation 11. This extends it beyond individual reachability requirements in the policy, and takes into account dependencies between policy edges. The resulting mapping is guaranteed to satisfy chaining of reachability requirements. For instance, if a policy node i is required to reach q through p, because of this equation, i cannot be mapped to the path segment (p,q). Otherwise, p might be skipped on the path from i to q. (</p>
    <p>j2NBT (i) xi, j,p,q = 0  j2NBT (i) x j,i,p,q = 0</p>
    <p>if i 2 c and (9ri,por 9rq,i)</p>
    <p>(11) Bounded or Equal Path Length A special case is shortest path policy, where the bounded length is the length of the shortest physical path. If a path length bound n is specified for a policy edge (p,q), then a new constraint is added (Equation 12):</p>
    <p>(i, j)2ET</p>
    <p>(xi, j,p,q + x j,i,p,q)  n (12)</p>
    <p>Multipath If at least m link-disjoint paths are required for flow (p,q), then the flow conservation equations 6 and 7 are updated as Equation 13 and 14 respectively.</p>
    <p>(  j2NBT (i) xi, j,p,q  m  j2NBT (i) x j,i,p,q = 0</p>
    <p>if i = p (13)</p>
    <p>(  j2NBT (i) xi, j,p,q  m  j2NBT (i) x j,i,p,q = 1</p>
    <p>if i = q (14)</p>
    <p>Load Balancing As discussed in 4, policy edges within a load balancing policy are denoted with a decimal path count. Correspondingly, in our optimization problem, variables that map physical edges to policy edges are also decimal values between zero and one, instead of binary values. In addition to that change, We introduce a new equation (Equation 15) to capture how flow distribution propagates.</p>
    <p>xi, j,p,q 6=0</p>
    <p>xi, j,p,q = m (15)</p>
    <p>For example, consider a physical topology shown in Figure 6, where there are two layers of load balancing between client C and servers S1  S5. If the policy in Figure 5 is required, the solutions for variables (xi, j ) are shown in Figure 6.</p>
    <p>Figure 6: Load Balancing Configuration.</p>
    <p>The preceding repair algorithm operates on a loop-free configuration graph. As such, we first check for and remove loops from each configuration graph before compressing and repairing violations of any other property type. Our objective for repairing loops is to minimize change to the network, with a preference to affect few equivalence classes as possible, as well as removed the minimal number of rules. Thus, our algorithm will remove a forwarding rule matching packets destined to 10.0.0.1/32 over one for 10.0.0.0/8. Since loops are repaired first, and NEAt will later check reachability properties on each equivalence class, our loop repair algorithm does not need to consider introducing permanent reachability violations by removing rules.</p>
    <p>Algorithm 1 Loop repair procedure REMOVELOOP(`c, Q(c))</p>
    <p># remove edges appearing in multiple loops remove {(i, j) | (i, j) 2 qk ^(i, j) 2 qm8k,m 2 Q(c)} if N(Q(c)) = 0 then</p>
    <p>return `c for all qi 2 Q(c) do</p>
    <p>while N(qi) &gt; 0 do # remove edges forwarded out the destination remove (i, j) if i is destination</p>
    <p>while N(qi) &gt; 0 do # remove most specific forwarding rule remove (i, j) 2 qi with longest prefix</p>
    <p>return `c</p>
    <p>Algorithm 1 presents our loop repair algorithm. Q(c) denotes the set of all loops appearing in a configuration graph `c and N(Q(c)) the number of loops in `c. qi is a subgraph of `c, and N(qi) = 0 when the subgraph contains no loops. The algorithm begins by finding and removing all intersecting edges across `cs loops. For each loop in `c that is not repaired by removing these edges, next remove an edge (i, j) where is IP address is the des</p>
    <p>(  j2NBT (i) xi, j,p,q = 0  j2NBT (i) x j,i,p,q = 1</p>
    <p>if i = DROP (10)</p>
    <p>Service Chaining With service chaining, or waypointing, we enhance our flow conservation equations with Equation 11. This extends it beyond individual reachability requirements in the policy, and takes into account dependencies between policy edges. The resulting mapping is guaranteed to satisfy chaining of reachability requirements. For instance, if a policy node i is required to reach q through p, because of this equation, i cannot be mapped to the path segment (p,q). Otherwise, p might be skipped on the path from i to q. (</p>
    <p>j2NBT (i) xi, j,p,q = 0  j2NBT (i) x j,i,p,q = 0</p>
    <p>if i 2 c and (9ri,por 9rq,i)</p>
    <p>(11) Bounded or Equal Path Length A special case is shortest path policy, where the bounded length is the length of the shortest physical path. If a path length bound n is specified for a policy edge (p,q), then a new constraint is added (Equation 12):</p>
    <p>(i, j)2ET</p>
    <p>(xi, j,p,q + x j,i,p,q)  n (12)</p>
    <p>Multipath If at least m link-disjoint paths are required for flow (p,q), then the flow conservation equations 6 and 7 are updated as Equation 13 and 14 respectively.</p>
    <p>(  j2NBT (i) xi, j,p,q  m  j2NBT (i) x j,i,p,q = 0</p>
    <p>if i = p (13)</p>
    <p>(  j2NBT (i) xi, j,p,q  m  j2NBT (i) x j,i,p,q = 1</p>
    <p>if i = q (14)</p>
    <p>Load Balancing As discussed in 4, policy edges within a load balancing policy are denoted with a decimal path count. Correspondingly, in our optimization problem, variables that map physical edges to policy edges are also decimal values between zero and one, instead of binary values. In addition to that change, We introduce a new equation (Equation 15) to capture how flow distribution propagates.</p>
    <p>xi, j,p,q 6=0</p>
    <p>xi, j,p,q = m (15)</p>
    <p>For example, consider a physical topology shown in Figure 6, where there are two layers of load balancing between client C and servers S1  S5. If the policy in Figure 5 is required, the solutions for variables (xi, j ) are shown in Figure 6.</p>
    <p>Figure 6: Load Balancing Configuration.</p>
    <p>The preceding repair algorithm operates on a loop-free configuration graph. As such, we first check for and remove loops from each configuration graph before compressing and repairing violations of any other property type. Our objective for repairing loops is to minimize change to the network, with a preference to affect few equivalence classes as possible, as well as removed the minimal number of rules. Thus, our algorithm will remove a forwarding rule matching packets destined to 10.0.0.1/32 over one for 10.0.0.0/8. Since loops are repaired first, and NEAt will later check reachability properties on each equivalence class, our loop repair algorithm does not need to consider introducing permanent reachability violations by removing rules.</p>
    <p>Algorithm 1 Loop repair procedure REMOVELOOP(`c, Q(c))</p>
    <p># remove edges appearing in multiple loops remove {(i, j) | (i, j) 2 qk ^(i, j) 2 qm8k,m 2 Q(c)} if N(Q(c)) = 0 then</p>
    <p>return `c for all qi 2 Q(c) do</p>
    <p>while N(qi) &gt; 0 do # remove edges forwarded out the destination remove (i, j) if i is destination</p>
    <p>while N(qi) &gt; 0 do # remove most specific forwarding rule remove (i, j) 2 qi with longest prefix</p>
    <p>return `c</p>
    <p>Algorithm 1 presents our loop repair algorithm. Q(c) denotes the set of all loops appearing in a configuration graph `c and N(Q(c)) the number of loops in `c. qi is a subgraph of `c, and N(qi) = 0 when the subgraph contains no loops. The algorithm begins by finding and removing all intersecting edges across `cs loops. For each loop in `c that is not repaired by removing these edges, next remove an edge (i, j) where is IP address is the des</p>
    <p>(  j2NBT (i) xi, j,p,q = 0  j2NBT (i) x j,i,p,q = 1</p>
    <p>if i = DROP (10)</p>
    <p>Service Chaining With service chaining, or waypointing, we enhance our flow conservation equations with Equation 11. This extends it beyond individual reachability requirements in the policy, and takes into account dependencies between policy edges. The resulting mapping is guaranteed to satisfy chaining of reachability requirements. For instance, if a policy node i is required to reach q through p, because of this equation, i cannot be mapped to the path segment (p,q). Otherwise, p might be skipped on the path from i to q. (</p>
    <p>j2NBT (i) xi, j,p,q = 0  j2NBT (i) x j,i,p,q = 0</p>
    <p>if i 2 c and (9ri,por 9rq,i)</p>
    <p>(11) Bounded or Equal Path Length A special case is shortest path policy, where the bounded length is the length of the shortest physical path. If a path length bound n is specified for a policy edge (p,q), then a new constraint is added (Equation 12):</p>
    <p>(i, j)2ET</p>
    <p>(xi, j,p,q + x j,i,p,q)  n (12)</p>
    <p>Multipath If at least m link-disjoint paths are required for flow (p,q), then the flow conservation equations 6 and 7 are updated as Equation 13 and 14 respectively.</p>
    <p>(  j2NBT (i) xi, j,p,q  m  j2NBT (i) x j,i,p,q = 0</p>
    <p>if i = p (13)</p>
    <p>(  j2NBT (i) xi, j,p,q  m  j2NBT (i) x j,i,p,q = 1</p>
    <p>if i = q (14)</p>
    <p>Load Balancing As discussed in 4, policy edges within a load balancing policy are denoted with a decimal path count. Correspondingly, in our optimization problem, variables that map physical edges to policy edges are also decimal values between zero and one, instead of binary values. In addition to that change, We introduce a new equation (Equation 15) to capture how flow distribution propagates.</p>
    <p>xi, j,p,q 6=0</p>
    <p>xi, j,p,q = m (15)</p>
    <p>For example, consider a physical topology shown in Figure 6, where there are two layers of load balancing between client C and servers S1  S5. If the policy in Figure 5 is required, the solutions for variables (xi, j ) are shown in Figure 6.</p>
    <p>Figure 6: Load Balancing Configuration.</p>
    <p>The preceding repair algorithm operates on a loop-free configuration graph. As such, we first check for and remove loops from each configuration graph before compressing and repairing violations of any other property type. Our objective for repairing loops is to minimize change to the network, with a preference to affect few equivalence classes as possible, as well as removed the minimal number of rules. Thus, our algorithm will remove a forwarding rule matching packets destined to 10.0.0.1/32 over one for 10.0.0.0/8. Since loops are repaired first, and NEAt will later check reachability properties on each equivalence class, our loop repair algorithm does not need to consider introducing permanent reachability violations by removing rules.</p>
    <p>Algorithm 1 Loop repair procedure REMOVELOOP(`c, Q(c))</p>
    <p># remove edges appearing in multiple loops remove {(i, j) | (i, j) 2 qk ^(i, j) 2 qm8k,m 2 Q(c)} if N(Q(c)) = 0 then</p>
    <p>return `c for all qi 2 Q(c) do</p>
    <p>while N(qi) &gt; 0 do # remove edges forwarded out the destination remove (i, j) if i is destination</p>
    <p>while N(qi) &gt; 0 do # remove most specific forwarding rule remove (i, j) 2 qi with longest prefix</p>
    <p>return `c</p>
    <p>Algorithm 1 presents our loop repair algorithm. Q(c) denotes the set of all loops appearing in a configuration graph `c and N(Q(c)) the number of loops in `c. qi is a subgraph of `c, and N(qi) = 0 when the subgraph contains no loops. The algorithm begins by finding and removing all intersecting edges across `cs loops. For each loop in `c that is not repaired by removing these edges, next remove an edge (i, j) where is IP address is the des</p>
    <p>Algorithm Overview When the verification engine discovers a violated EC, the algorithm is executed. Its goal is to repair the detected violations optimally, i.e., with the minimum number of changes to the original configuration. NEAt formulates the problem as an optimization problem: we aim to add or delete the minimum number of edges on `c so that the modified `c complies with c. c is a subgraph of  that is relevant to EC c. Note that the added edges are constrained within the topology graph T . We solve the optimization problem using ILP.</p>
    <p>Subsection 5.1 describes the repair algorithm for basic reachability policies, and subsection 5.2 enhances the basic algorithm to cope with the entire set of policies in 4. We complete the section with our repair algorithm for forwarding loops (5.3). Table 1 summarizes the key notations used in this section and the next section 6.</p>
    <p>Symbol Description `c The configuration graph for EC c.  The policy graph. T The topology graph. (i, j) The edge from node i to node j. ri j The paths between node i and node j. Cci The cluster of node i for equivalence class c. ci The compressed node i for Cci . Ea The set of all edges in graph a. N(Ea) Number of all edges in graph a. NBa(i) The set of neighbors of node i in graph a.</p>
    <p>Table 1: Key notations in problem formulation.</p>
    <p>We start with the basic case where c contains only reachability constraints. Our integer program has a set of binary decision variables xi, j,p,q and xi, j where</p>
    <p>xi, j,p,q,(i, j) 2 ET ,(p,q) 2 Ec (1)</p>
    <p>xi, j,(i, j) 2 ET (2)</p>
    <p>ET and Ec denote the set of all edges in T and c respectively. Variable xi, j,p,q defines the mapping between a physical edge and a policy graph edge. It is one if a directed edge (i, j) is mapped to policy edge (p,q) for the current EC c, i.e., the flow from p to q will be forwarded through edge (i, j) from i to j. Variable xi, j defines whether edge (i, j) is used for forwarding this ECs traffic regardless of which flow uses it. Edge (i, j) in T is selected if any flow (p,q) is forwarded through (i, j) (Equation 3). Similarly, for the other direction ( j,i), we have Equation 4. No physical link can be selected to forward traffic for the same EC on both directions (Equation 5) to avoid loops.</p>
    <p>xi, j,p,q N(E)</p>
    <p>(3)</p>
    <p>x j,i,p,q N(E)</p>
    <p>(4)</p>
    <p>Equations 6-8 are the flow conservation equations for policy level reachability (p,q). 8(p,q),8i 2 T :(</p>
    <p>j2NBT (i) xi, j,p,q = 1  j2NBT (i) x j,i,p,q = 0</p>
    <p>if i = p (6) (</p>
    <p>j2NBT (i) xi, j,p,q = 0  j2NBT (i) x j,i,p,q = 1</p>
    <p>if i = q (7) n</p>
    <p>j2NBT (i)(xi, j,p,q  x j,i,p,q) = 0 otherwise (8)</p>
    <p>The optimization objective is to minimize the number of changes (additions and deletions) on the original configuration graph `c.</p>
    <p>min (  (i, j)/2E`c</p>
    <p>xi, j   (i, j)2E`c</p>
    <p>xi, j) (9)</p>
    <p>To support generalized reachability policies in 4, we encode several additional constraints into the ILP. Isolation We introduce a special DROP node. If two nodes are required to be isolated, i.e., the nodes are connected with a (0,) edge in the policy graph, we change the way flow conservation equations are defined. In particular, we replace Equation 7 with Equations 10 and 11 below in the flow conservation equations. That is, a flow from p to q should sink at DROP before reaching q.(</p>
    <p>j2NBT (i) xi, j,p,q = 0  j2NBT (i) x j,i,p,q = 1</p>
    <p>if i = DROP (10) n</p>
    <p>j2NBT (i) xi, j,p,q = 0 if i = q (11)</p>
    <p>Service Chaining With service chaining, or waypointing, we enhance our flow conservation equations with Equation 12. It extends the definition beyond individual reachability segments (policy graph edges), by taking into account dependencies between policy edges. The resulting mapping is guaranteed to satisfy chaining of reachability requirements. For instance, if a policy node i is required to reach q through p, because of this equation, node i in the configuration graph is not allowed to carry flow from p to q. Without this equation, p might be skipped on the path from i to q.(</p>
    <p>j2NBT (i) xi, j,p,q = 0  j2NBT (i) x j,i,p,q = 0</p>
    <p>if i 2 c and (9ri,por 9rq,i)</p>
    <p>(12) Bounded or Equal Path Length/Shortest Path If a path length bound n is specified for a policy edge (p,q), then a new constraint is added (Equation 13):</p>
    <p>(i, j)2ET</p>
    <p>(xi, j,p,q + x j,i,p,q)  n (13)</p>
    <p>Multipath If at least m link-disjoint paths are required for flow (p,q), then the flow conservation equations 6 and 7 are updated as Equation 14 and 15 respectively. Multipath requirements are enforced throughout the distance between two end nodes by Equation 8.(</p>
    <p>j2NBT (i) xi, j,p,q  m  j2NBT (i) x j,i,p,q = 0</p>
    <p>if i = p (14) (</p>
    <p>j2NBT (i) xi, j,p,q = 0  j2NBT (i) x j,i,p,q  m</p>
    <p>if i = q (15)</p>
    <p>Load Balancing As discussed in 4, policy edges within a load balancing policy are denoted with a decimal path count. Correspondingly, in our optimization problem, variables that map physical edges to policy edges are also decimal values between zero and one, instead of binary values. In addition, we introduce a new equation (Equation 16) to capture how flow distribution propagates.</p>
    <p>xi, j,p,q 6=0</p>
    <p>xi, j,p,q = m (16)</p>
    <p>For example, consider the network in Figure 6, where there are two layers of load balancing between client C and servers S1 S5. If the policy in Figure 5 is required, the solutions for variables (xi, j ) are shown in Figure 6.</p>
    <p>Figure 6: Load Balancing Configuration.</p>
    <p>The preceding repair algorithm operates on a loop-free configuration graph. As such, we first check for and remove loops from each configuration graph before compressing and repairing violations of any other property type. Our objective for repairing loops is to minimize change to the network, with a preference to affect few equivalence classes as possible, as well as removed the minimal number of rules. Thus, our algorithm will remove a forwarding rule matching packets destined to 10.0.0.1/32 over one for 10.0.0.0/8. Since loops are repaired first, and NEAt will later check reachability properties on each equivalence class, our loop repair algorithm does not need to consider introducing permanent reachability violations by removing rules.</p>
    <p>Algorithm 1 presents our loop repair algorithm. Q(c) denotes the set of all loops appearing in a configuration graph `c and N(Q(c)) the number of loops in `c. qi is a</p>
    <p>Algorithm 1 Loop repair procedure REMOVELOOP(`c, Q(c))</p>
    <p># remove edges appearing in multiple loops remove {(i, j) | (i, j) 2 qk ^(i, j) 2 qm8k,m 2 Q(c)} if N(Q(c)) = 0 then</p>
    <p>return `c for all qi 2 Q(c) do</p>
    <p>while N(qi) &gt; 0 do # remove edges forwarded out the destination remove (i, j) if i is destination</p>
    <p>while N(qi) &gt; 0 do # remove most specific forwarding rule remove (i, j) 2 qi with longest prefix</p>
    <p>return `c</p>
    <p>subgraph of `c, and N(qi) = 0 when the subgraph contains no loops. The algorithm begins by finding and removing all intersecting edges across `cs loops. For each loop in `c that is not repaired by removing these edges, next remove an edge (i, j) where is IP address is the destination, if such an edge exists. While qi still has loops, remove an edge in the loop which has the most specific match rule (e.g., longest prefix). Each edge is mapped to a specific forwarding rule at a particular switch when we compute the equivalence classes.</p>
    <p>Removal of a forwarding rule is accomplished by replace it with a drop rule, to prevent a coarser match from introducing another loop. For example, if a rule matching destination IP 10.0.0.1/32 is simply deleted from a switchs forwarding table, another rule matching 10.0.0.1/31 on the same switch and forwarding to the same next hop could prevent the loop from being repaired. To conserve switch memory during in response repairs, NEAt checks all coarser drop rules to determine if multiple rules can be aggregated together.</p>
    <p>While conceptually straightforward, the repair algorithm in section 5 does not scale to well. In the optimization problem formulation, the number of variables for one EC is approximately the product of the number of topology links and the number of policy graph edges, which can easily exceed 100k. In this section, we present two techniques that dramatically optimize the repair speed.</p>
    <p>This technique aims to slice away irrelevant or redundant part of the network, and thus shrink the size of the optimization problem. After getting a configuration graph that violates some policies, before passing it to the optimizer, we first remove disconnected components on</p>
    <p>Flow sinks at DROP node</p>
    <p>Correct waypoint order</p>
    <p>path length &lt;= n</p>
    <p># of paths &gt;= m</p>
    <p>Flow distribution propagates</p>
  </div>
  <div class="page">
    <p>Repair - Loop Freedom</p>
    <p>The preceding algorithm operates on a loop-free graph.</p>
    <p>First check for and remove loops before repairing other type violations.</p>
    <p>Objective: Minimize changes</p>
    <p>Remove the minimal # of rules.</p>
    <p>Affect few packets as possible. - E.g. remove a rule matching 10.0.0.1/32 over one for 10.0.0.0/8.</p>
    <p>Correction Engine</p>
    <p>Missing anything?</p>
  </div>
  <div class="page">
    <p>Scalability Challenge and Solution Scalability challenge</p>
    <p># of variables  |E(Gtopo)|  |E(Gpolicy)|  Easily exceeds 100k</p>
    <p>Solution: ?</p>
    <p>Network State</p>
    <p>e</p>
    <p>d</p>
    <p>h</p>
    <p>f i</p>
    <p>m</p>
    <p>l</p>
    <p>g a</p>
    <p>b</p>
    <p>p n</p>
    <p>jc</p>
    <p>k</p>
    <p>Policy Graph</p>
    <p>c</p>
    <p>k j</p>
  </div>
  <div class="page">
    <p>A Typical Enterprise Network</p>
  </div>
  <div class="page">
    <p>Scalability Challenge and Solution</p>
    <p>Scalability challenge</p>
    <p># of variables  |E(Gtopo)|  |E(Gpolicy)|  Easily exceeds 100k</p>
    <p>Solution</p>
    <p>Topology Limitation  Graph Compression</p>
    <p>- Key: Compressed graph == original graph - Bisimulation Based Graph Compression</p>
    <p>Correction Engine</p>
    <p>Optimizer</p>
    <p>Compressor</p>
    <p>w.r.t policy</p>
  </div>
  <div class="page">
    <p>Implementation &amp; Evaluation Setup</p>
    <p>Prototype implementation in Python</p>
    <p>Use Gurobi within optimization engine  Pass-through mode: proxy  Interactive mode: XML-RPC API</p>
    <p>Datasets:</p>
    <p>Synthetic fat-tree configurations  SDN applications  244-router enterprise network trace</p>
  </div>
  <div class="page">
    <p>Application End-to-End Delay</p>
    <p>Pox + Mininet</p>
    <p>Learning switch app (pass-through)  Load balancing app (interactive)</p>
    <p>(16, 20, 96)</p>
    <p>(54, 45, 324)</p>
    <p>(128, 80, 768)</p>
    <p>La te</p>
    <p>nc y</p>
    <p>(m s)</p>
    <p>Topology Size (#hosts, #switches, #links)</p>
    <p>comp+limit nocomp+limit comp+nolimit</p>
    <p>nocomp+nolimit</p>
  </div>
  <div class="page">
    <p>Enterprise Network Trace Study</p>
    <p>Policy: loop freedom &amp; reachability</p>
    <p>Issues found and repaired:</p>
    <p>Loops caused by default route  Load balancing shouldnt be turned on</p>
  </div>
  <div class="page">
    <p>Repair vs. Synthesis</p>
    <p>Synthesizer (NetGen) as repair tool</p>
    <p>#TopoLinks NEAt NetGen NetGen-C</p>
    <p>NEAt as synthesizer</p>
    <p>#TopoLinks NEAt NetGen</p>
  </div>
  <div class="page">
    <p>Isnt that NEAt?</p>
    <p>NEAt, a system analogous to a smartphones autocorrect.</p>
    <p>Casting the problem as an optimization problem  Millisecond to second repair speed  Generic policy support</p>
    <p>Future work:</p>
    <p>Evolving &amp; richer policies  Different optimization goals  Repair relevance study</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Graph Compression</p>
    <p>Key: Compressed graph == original graph</p>
    <p>Major building block:</p>
    <p>Bisimulation Based Graph Compression*</p>
    <p>w.r.t policy Correction Engine</p>
    <p>Optimizer</p>
    <p>Compressor</p>
    <p>Core</p>
    <p>HostBHostA</p>
    <p>Firewall1 Firewall2 Firewall3</p>
    <p>Edge1 Edge2 Edge3</p>
  </div>
  <div class="page">
    <p>Customized policy-preserving compression</p>
    <p>Incremental Compression</p>
    <p>Repair compressed graphs</p>
    <p>Mapping back</p>
    <p>Proved Policy Perseverance</p>
    <p>Graph Compression (Contd)</p>
    <p>Bisimulation Based Compression Algorithm 2 presents the compression algorithm on the given graphs `c, c and T . We compute bisimulation relation on `c using the algorithms presented in [9] and then compress the graphs based on the bisimularity. However, unlike `c and c, T is not a directed graph, and thus the original algorithm is not applicable. To compute T cp, we first compress the parts in T that overlap with `c according to the undirected version of `cpc . Then we draw edges between the non-overlapping parts and the compressed parts with their original edges in T . The time complexity of the compression algorithm is O(|E|log|V |). Figure 7(b) shows the compression result on graph `c. Firewall2 and Firewal3 are bisimular and are compressed to a new clustering named FW2. Firewall1 stays by itself as FW1. c is compressed in a similar way.</p>
    <p>Algorithm 2 Graph pattern preserving compression procedure CLUSTERING(`c, c, T )</p>
    <p>compute the maximum bisimulation relation BR of `c compute the clusters clusters = V /BR collapse the nodes in the each cluster 2 clusters compute compressed c, `</p>
    <p>cp c , T cp</p>
    <p>return c, ` cp c , T cp</p>
    <p>We evaluate the compression algorithm on a simulated fattree topology and a large enterprise network. We denotes the compression rate rc as the ratio of the number of the remaining nodes in `cpc to the number of the nodes in the original graph `c. Table 2 shows the compression results. From the result we can conclude that the compression algorithm could result in a much smaller amount of nodes for large-scale networks.</p>
    <p>Topology 1  rc Fattree (6750 hosts, 1125 switches) 99.38% Enterprise (236 routers) 88.98%</p>
    <p>Table 2: Compression results.</p>
    <p>Incremental Compression Further leveraging the incremental compression algorithm from [10], we incrementally maintain the compressed configuration graphs. In response to changes to the original graphs, the incremental algorithm computes the new compressed graph using the changes and the compressed graph as input, independent of the original graph. That is there is no need to decompress the graph to propagate the changes.</p>
    <p>Repair Compressed Graphs With the compression module in place, when a violation is detected, the graphs are compressed first, then passed to the optimizer. Note that one compressed topology graph edge may represent</p>
    <p>a collection of original topology graph edges. This works fine with single-path reachability type of policies, such as reachability, isolation, service chaining. However, it will break equation 13 and 14 for link-disjoint multipath policy. Our solution is to label predecessors of a multipath policy destination (E.g., q for policy edge (p,q)) node differently, such that they are not compressed into one cluster. In addition, the compressed topology graph is modeled as a weight graph, where the weight on each edge is the number of original edges the compressed edge represents. Multipath policy constraint Equation 13 is modified accordingly as Equation 16, where as Equation 14 remains the same because theres never multiple edges pointing to the destination node q.</p>
    <p>(  j2NBT c p (i)(xi, j,p,q  weighti, j) &gt;= m  j2NBT c p (i) x j,i,p,q = 0</p>
    <p>if i = p</p>
    <p>(16)</p>
    <p>Map Back The last step is to map the result back to the original graphs. The optimization result is a set of changes (added or deleted edges) on the compressed graphs. To map back to the original configuration graph, a changed edge (ci,c j) could become a set of changed edges between the cluster Cci and cluster C</p>
    <p>c j . If an edge</p>
    <p>(ci,c j) is supposed to be added to the compressed configuration graph, then on the original configuration graph, for every node i in the source cluster Cci , there should be an edge added from i to one of its neighbor node j that is in the target cluster Ccj . By the definition of bisimulation, such a node j always exists. On the other hand, if an edge (ci,c j) should be removed from the compressed configuration graph, then all the edges between the two clusters should be removed on the original graph.</p>
    <p>Afterwards, those computed changes will be translated into forwarding instructions, and sent to the network devices.</p>
    <p>Policy Perseverance At the end, we prove that the compression algorithm preserves the equivalence between the compressed graph Gc and the original graph G with respect to the scope of policies in section 4. The equivalence is proved in [10] for graph pattern queries. A graph pattern query is effectively asserting single-path type reachability and bounded path length. So here we only need to prove that the conclusion also holds for multipath policies.</p>
    <p>Theorem 1. (Multipath Equivalence): A multipath policy for a flow (p,q) holds on G iff the policy also holds for (p,q) on Gc.</p>
    <p>Proof. Consider a multipath policy that requires at least m path for flow (p,q). Trivially, if a flow (p,q) satisfies</p>
    <p>Optimization Engine</p>
    <p>Optimizer</p>
    <p>Compressor</p>
    <p>Correction Engine</p>
    <p>Optimizer</p>
    <p>Compressor</p>
    <p>Topology Compression Ratio</p>
    <p>Fattree (6750 hosts, 1125 switches) 99.38%</p>
    <p>Enterprise (236 routers) 88.98%</p>
    <p>Modified mutipath constraint</p>
  </div>
  <div class="page">
    <p>Backup: Network Model</p>
    <p>Model packet space as a set of Equivalence Classes</p>
    <p>Equivalence class (EC): Packets experiencing the same forwarding actions throughout the network.</p>
    <p>Model forwarding behavior of each EC as a directed graph</p>
    <p>Correction Engine</p>
    <p>Equiv classes Fwding rules</p>
  </div>
  <div class="page">
    <p>Insights Behind NEAt</p>
    <p>Preventing errors at run-time</p>
    <p>Allow arbitrary SDN applications to run on top  Not restricted to any programming language  Influence updates, rather than synthesize from scratch</p>
    <p>Graphs are neat</p>
    <p>Networks are graphs  Model network forwarding behaviors as directed graphs  Represent operator intents as a policy graph</p>
    <p>Discovering repairs</p>
    <p>Equivalent to modifying network state graph so that there exists a mapping between it and the policy graph</p>
    <p>FW SH1</p>
    <p>H2</p>
  </div>
  <div class="page">
    <p>Policy</p>
    <p>X</p>
    <p>X</p>
    <p>NEAt Network Model</p>
    <p>Verication Engine</p>
    <p>Correction Engine</p>
    <p>Compressor</p>
    <p>Optimizer</p>
    <p>Network Events</p>
    <p>Yes</p>
    <p>No</p>
    <p>Updates</p>
  </div>
  <div class="page">
    <p>Data plane</p>
    <p>Control planeControl plane</p>
    <p>Data plane</p>
    <p>Configuration</p>
    <p>Network behavior</p>
    <p>Approach: Data plane verification &amp; repair</p>
    <p>Configuration Data-plane</p>
    <p>Prediction is difficult: Various configuration languages Dynamic distributed protocols</p>
    <p>Closer to actual network behavior</p>
    <p>Unified analysis for multiple control-plane protocols</p>
    <p>Misses control-plane bugs Can catch control-plane bugs</p>
    <p>Test prior to deployment Only detects bugs that are present in the data plane</p>
    <p>Operating on the data plane simplifies our work</p>
    <p>Diagnose problems as close as possible to actual network behavior  Data plane is a narrower waist than configuration</p>
  </div>
</Presentation>
