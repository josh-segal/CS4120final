<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Deconstructing RDMA-enabled Distributed Transaction Processing:</p>
    <p>Hybrid is Better!</p>
    <p>Xingda Wei, Zhiyuan Dong, Rong Chen, Haibo Chen</p>
    <p>Institute of Parallel and Distributed Systems (IPADS) Shanghai Jiao Tong University</p>
  </div>
  <div class="page">
    <p>Remote Direct Memory Access (RDMA)</p>
    <p>Kernel bypassing network</p>
    <p>Ultra low latency~(5us)</p>
    <p>Ultra high throughput</p>
    <p>!2</p>
    <p>Gain interests from Academia &amp; Industry</p>
    <p>Orders of magnitude improvements on distributed applications</p>
    <p>Available in the public cloud[1]</p>
    <p>[1] https://azure.microsoft.com/en-us/blog/azure-linux-rdma-hpc-available/</p>
    <p>[2] Atomic compare and swap</p>
    <p>Offloading technology (one-sided)</p>
    <p>Bypassing CPU</p>
    <p>Read/Write, CAS[2] servers memory</p>
  </div>
  <div class="page">
    <p>One-sided READ(I) Two-sided RPC()</p>
    <p>On-going debate over how to use RDMA for TXs</p>
    <p>!3</p>
    <p>Performance</p>
    <p>#Round-trips &gt;= 2 1</p>
    <p>Coordinator</p>
    <p>As store</p>
    <p>Get(A)</p>
    <p>RPC reply</p>
    <p>RPC request</p>
    <p>Lookup A Read A</p>
  </div>
  <div class="page">
    <p>TX (e.g. OCC[1]) uses multiple phases for serializability &amp; availability</p>
    <p>Each can be offloaded w one-sided primitive</p>
    <p>Transaction(TX)s are more complex</p>
    <p>Coordinator</p>
    <p>As primary</p>
    <p>As backup</p>
    <p>TX{ A = A + 1} Execution</p>
    <p>Lock Check value</p>
    <p>Validation Logging Commit</p>
    <p>Write value</p>
    <p>!4</p>
    <p>}</p>
    <p>Execute TXs logic</p>
    <p>} Verify executions consistency</p>
    <p>}</p>
    <p>Reliably update the store</p>
    <p>Read value CASs + READs WRITEsWrite logWRITEs</p>
    <p>[1] Optimistic concurrency control</p>
    <p>LookupOne-sided READs</p>
  </div>
  <div class="page">
    <p>!5</p>
    <p>Workloads</p>
    <p>Protocols</p>
    <p>OLTP workloads</p>
    <p>TPC-C, TPC-E, TATP, Smallbank,</p>
    <p>Impl on hardware devices</p>
    <p>One-sided vs. Two-sided,</p>
    <p>CX3, CX4, CX5, ROCE</p>
    <p>Protocols</p>
    <p>OCC, 2PL, SI, .</p>
    <p>Transaction(TX)s are more complex</p>
    <p>Implements &amp; Hardware</p>
  </div>
  <div class="page">
    <p>Well-tuned RDMA execution framework</p>
    <p>Representative RNICs (CX3 - CX5)</p>
    <p>This work: how to use RDMA for TXs</p>
    <p>!6</p>
    <p>Workloads</p>
    <p>Protocol</p>
    <p>Focus on OCC in this work</p>
    <p>Use phase-by-phase approach Optimistic Concurrency Control Widely used in</p>
    <p>Centralized</p>
    <p>Distributed</p>
    <p>Representative OLTP workloads</p>
    <p>TPC-C, TPC-E, and Smallbank</p>
    <p>Silo[SOSP13] Foedus[SIGMOD15]</p>
    <p>FaRM[SOSP15] TAPIR[SOSP15]</p>
    <p>Implements &amp; Hardware</p>
  </div>
  <div class="page">
    <p>Phase-by-phase analysis is effective &amp; useful</p>
    <p>!7</p>
    <p>Coordinator</p>
    <p>As primary</p>
    <p>As backup</p>
    <p>TX{ A = A + 1} Execution</p>
    <p>Lock Read</p>
    <p>Validation Logging Commit</p>
    <p>Write + UnlockWrite</p>
    <p>OCC uses consecutive phases</p>
    <p>Better phase performance -&gt; Better overall performance</p>
    <p>Like query in graph; get() in key-value store</p>
    <p>Like write a file in distributed file system,etc</p>
    <p>Read</p>
  </div>
  <div class="page">
    <p>Deconstructing TX with phase-by-phase analysis</p>
    <p>!8</p>
    <p>Execution</p>
    <p>Lock Check value</p>
    <p>Validation Logging Commit</p>
    <p>Write value</p>
    <p>Read index Read valueOne-sided READs CASs + READs WRITEsWrite logWRITEs    DrTM+H No single primitive wins all the time !</p>
    <p>OCC uses consecutive phases</p>
    <p>Better phase performance -&gt; Better overall performance</p>
    <p>https://github.com/SJTU-IPADS/drtmh</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>RDMA primitive-level analysis</p>
    <p>Phase-by-phase analysis for TX</p>
    <p>DrTM+H: Putting it all together</p>
    <p>!9</p>
  </div>
  <div class="page">
    <p>System model &amp; evaluation setup</p>
    <p>!10</p>
    <p>. . .</p>
    <p>Evaluation setup</p>
    <p>Client TX req</p>
    <p>TX req</p>
    <p>READ/WRITE REQs</p>
    <p>Client</p>
    <p>Symmetric model</p>
  </div>
  <div class="page">
    <p>Primitive analysis</p>
    <p>!11</p>
    <p>One-sided primitive</p>
    <p>Simple implementation (Native verbs API)</p>
    <p>Optimized event loop (Async communication)</p>
    <p>Two-sided (RPC)</p>
    <p>FaSST RPC [OSDI16]</p>
    <p>Fastest in our setting</p>
    <p>Throughput (millon reqs/second)</p>
    <p>READ WRITE</p>
    <p>CAS</p>
    <p>Better</p>
    <p>Client</p>
    <p>Server Req Reply</p>
    <p>READ/WRITE is faster w known address</p>
    <p>Two-sided</p>
    <p>CAS is slower, but w sufficient performance (48M per machine)</p>
  </div>
  <div class="page">
    <p>Passive ACK (PA)</p>
    <p>!12</p>
    <p>One-sided primitive</p>
    <p>Unsignaled requests</p>
    <p>Two-sided primitive</p>
    <p>Batch replies (passively)</p>
    <p>BetterThroughput (millon reqs/second)</p>
    <p>Client</p>
    <p>Server Opt: when the reply is not on the critical path of the execution</p>
    <p>+PA ReplyReq</p>
    <p>+PA</p>
    <p>READ WRITE</p>
    <p>CAS Two-sided</p>
    <p>WRITE Two-sided</p>
    <p>Two-sided is faster w PA</p>
    <p>PA usually not apply to READ/CAS</p>
    <p>Req Reply</p>
  </div>
  <div class="page">
    <p>Towards phase-by-phase analysis</p>
    <p>Workloads</p>
    <p>TPC-C/no: new-order (distributed)</p>
    <p>Smallbank</p>
    <p>TPC-E/cp: custom-position</p>
    <p>!13</p>
    <p>Transactional system</p>
    <p>Built atop of our well-tuned execution framework (primitive analysis)</p>
  </div>
  <div class="page">
    <p>Lookup index cache</p>
    <p>Execution = READs</p>
    <p>!14</p>
    <p>One-sided (I) Two-sided ()</p>
    <p>Coordinator</p>
    <p>As store Lookup Read A</p>
    <p>TX{A = A + 1}</p>
    <p>Optimization for one-sided primitive</p>
    <p>RDMA friendly store (e.g. DrTM-KV) -&gt; ~One-round lookup</p>
    <p>Index cache, cache hot items address -&gt; One-round (lookup + read)</p>
    <p>One-sided (I) Cache</p>
    <p>Read A RPC reply</p>
    <p>RPC request</p>
    <p>Exe Val Log Commit</p>
  </div>
  <div class="page">
    <p>Exe Val Log Commit L</p>
    <p>a te</p>
    <p>n cy</p>
    <p>(m s)</p>
    <p>Throughput (millon TXs/second)</p>
    <p>Two-sided One-sided One-sided/Cache Better</p>
    <p>Execution = READs</p>
    <p>!15</p>
    <p>Better</p>
    <p>Two-sided (II):</p>
    <p>One-sided (I)</p>
    <p>One-sided (I) / Cache</p>
    <p>Hybrid usage of ONE/Cache + Two-sided(miss)</p>
    <p>Two-sided is faster w one round-trip</p>
    <p>One-sided is faster w high CPU utilization</p>
    <p>READs are better with one round-trip.</p>
    <p>OverloadedUnderloaded</p>
  </div>
  <div class="page">
    <p>Validation = LOCKs + READs</p>
    <p>!16</p>
    <p>One-sided (I) Two-sided (II) One-sided (I) Two-sided ()</p>
    <p>Coordinator</p>
    <p>As store</p>
    <p>TX{A = A + 1}</p>
    <p>Optimization for one-sided primitive ( for one round-trip )</p>
    <p>Address known w the execution phase -&gt; no need for lookup</p>
    <p>Locked value cannot be changed -&gt; doorbell batch READs w CASs</p>
    <p>Read RPC reply</p>
    <p>RPC request</p>
    <p>Lookup CAS</p>
    <p>Lock(A) Validate(A)</p>
    <p>CAS + Read</p>
    <p>Exe Val Log Commit</p>
  </div>
  <div class="page">
    <p>!17</p>
    <p>L a</p>
    <p>te n</p>
    <p>cy (m</p>
    <p>s)</p>
    <p>Throughput (millon TXs/second)</p>
    <p>Two-sided One-sidedBetter</p>
    <p>Better</p>
    <p>Two-sided (II):</p>
    <p>One-sided (I)</p>
    <p>CAS + Read batched together</p>
    <p>Validation is suitable for one-sided because of one round-trip</p>
    <p>Exe Val Log CommitValidation = LOCKs + READs</p>
  </div>
  <div class="page">
    <p>RingBuffer</p>
    <p>Logging = WRITEs</p>
    <p>!18</p>
    <p>One round-trip for one-sided primitive</p>
    <p>Ring buffer based log management [FaRM@NSDI14]</p>
    <p>RNIC ack -&gt; logging succeed (Totally bypassing CPU)</p>
    <p>One-sided (I) Two-sided ()</p>
    <p>Coordinator</p>
    <p>As backup</p>
    <p>TX{A = A + 1}</p>
    <p>RPC request</p>
    <p>RPC reply</p>
    <p>Write</p>
    <p>Exe Val Log Commit</p>
  </div>
  <div class="page">
    <p>Logging = WRITEs</p>
    <p>!19</p>
    <p>Two-sided One-sided</p>
    <p>Throughput (millon TXs/second) Better</p>
    <p>L a</p>
    <p>te n</p>
    <p>cy (m</p>
    <p>s)</p>
    <p>Better Two-sided (II):</p>
    <p>One-sided (I)</p>
    <p>rep-factor=2</p>
    <p>LOGGING can be always offloaded w one round-trip</p>
    <p>LOGGING is better w one-sided</p>
    <p>Exe Val Log Commit</p>
  </div>
  <div class="page">
    <p>Commit = WRITEs + UNLOCKs</p>
    <p>!20</p>
    <p>One-sided (I) Two-sided ()</p>
    <p>Coordinator</p>
    <p>As store</p>
    <p>TX{A = A + 1}</p>
    <p>RPC request</p>
    <p>RPC reply</p>
    <p>One round-trip for one-sided primitive</p>
    <p>Address known w the execution phase -&gt; no need for lookup</p>
    <p>Lookup</p>
    <p>Adding passive ACK to both primitives</p>
    <p>Log succeed indicates TXs commit</p>
    <p>Write A</p>
    <p>Exe Val Log Commit</p>
    <p>Unlocks implemented as WRITEs</p>
  </div>
  <div class="page">
    <p>!21</p>
    <p>Two-sided One-sided One + PA Two + PA</p>
    <p>Throughput (millon TXs/second) Better</p>
    <p>L a</p>
    <p>te n</p>
    <p>cy (m</p>
    <p>s)</p>
    <p>Better</p>
    <p>Two-sided (II):</p>
    <p>One-sided (I)</p>
    <p>+PATwo-sided w PA is faster</p>
    <p>Two-sided w PA has higher peak throughput</p>
    <p>Commit RPC costs is small</p>
    <p>Two-sided saves CPU at sender</p>
    <p>Exe Val Log CommitCommit = WRITEs + UNLOCKs</p>
  </div>
  <div class="page">
    <p>DrTM+H: Hybrid is better !</p>
    <p>!22</p>
    <p>Specific optimizations</p>
    <p>Passive ACK to the commit phase ( &amp; log cleaning message)</p>
    <p>Speculative execution to send outstanding requests (OR) from one TX</p>
    <p>Execution(E) Validation(V) Logging (L) Commit (C)</p>
    <p>DrTM+H I +  I I</p>
    <p>Hybrid choice</p>
    <p>Hybrid system supports serializability &amp; high availability</p>
  </div>
  <div class="page">
    <p>Performance &amp; scalability on TPC-C/no</p>
    <p>!23</p>
    <p># Machines</p>
    <p>Throughput (million TXs/second) 4%</p>
    <p>DrTM+H scales well @ an (emulated) 80-node connections</p>
    <p>rep-factor=2</p>
  </div>
  <div class="page">
    <p>End-to-end comparison against prior designs</p>
    <p>!24</p>
    <p>FaSST-OCC FaRM DrTM+R DrTM+H</p>
    <p>Throughput (millon TXs/second) Better L</p>
    <p>a te</p>
    <p>n cy</p>
    <p>(m s)</p>
    <p>BetterE V L C</p>
    <p>FaSST-OCC[1]     DrTM+R I[w cache] I I I</p>
    <p>FaRM I[w/o cache] I+  I  DrTM+H I +  I I</p>
    <p>[1] FaSST uses a simplified OCC protocol compared to FaRM &amp; DrTM+R.</p>
    <p>In the same platform, the same protocol, but w different choices</p>
    <p>+ Offload logging</p>
    <p>+ Index cache + Offload validation</p>
  </div>
  <div class="page">
    <p>Where do the performance gains come from ?</p>
    <p>!25</p>
    <p>Base (Two)</p>
    <p>+ One READ</p>
    <p>+ One Log</p>
    <p>+ Index Cache</p>
    <p>+ One VAL</p>
    <p>+ PA + OR Base (Two)</p>
    <p>+ One READ</p>
    <p>+ One Log</p>
    <p>+ Index Cache</p>
    <p>+ One VAL</p>
    <p>+ PA + OR</p>
    <p>Peak throughput90th Latency (ms)</p>
    <p>phase-by-phase</p>
    <p>Throughput (KTX/sec)</p>
  </div>
  <div class="page">
    <p>Not a hard conclusion !</p>
    <p>May depends on RNICs characteristic &amp; network setting</p>
    <p>!26</p>
    <p>RNICS E V L C</p>
    <p>CX3[1]     CX4[2] I +  I I  CX4-ROCE[1] I +  I I  CX5[1][3] I +  I I</p>
    <p>FaSST-OCC FaRM DrTM+R DrTM+H</p>
    <p>Throughput (millon TXs/second)</p>
    <p>L a</p>
    <p>te n</p>
    <p>cy (m</p>
    <p>s)</p>
    <p>ConnectX-3 ConnectX-4</p>
    <p>ConnectX-5ConnectX-4-ROCE</p>
    <p>[1]1-way replication used due to cluster limitation</p>
    <p>[2] Main results in this talk</p>
    <p>The results start from the primitive level analysis.</p>
    <p>[3]1-RNIC per machine, others uses 2</p>
  </div>
  <div class="page">
    <p>Evaluation summary</p>
    <p>Offloading w one-sided improves the performance</p>
    <p>Especially w/o adding more round-trips</p>
    <p>Less affected by CPU load at the server</p>
    <p>!27</p>
    <p>One-sided primitive has good scalability on modern RNIC</p>
    <p>Especially when RNIC is not the bottleneck of the application</p>
    <p>Although one-sided primitive is restricted by hardware limitation</p>
  </div>
  <div class="page">
    <p>More: check our paper!</p>
    <p>Optimized execution framework</p>
    <p>Results of large scale</p>
    <p>Modern RNIC has good scalability for one-sided primitive</p>
    <p>Read-only Transactions</p>
    <p>A hybrid scheme also wins</p>
    <p>TPC-E, Smallbank</p>
    <p>!28</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>The first systematic study on</p>
    <p>How to use RDMA for OCC TXs</p>
    <p>No single primitive is better!</p>
    <p>Depends on workload pattern &amp; primitive analysis</p>
    <p>Execution framework &amp; DrTM+H are available @</p>
    <p>!29https://github.com/SJTU-IPADS/drtmh</p>
    <p>Thanks &amp; QA</p>
  </div>
  <div class="page">
    <p>Backups</p>
    <p>!30</p>
  </div>
  <div class="page">
    <p>Improved overall systems</p>
    <p>!31</p>
    <p>FaSSTs simplified OCC protocol</p>
    <p>Adding hybrid-schema for logging</p>
    <p>Original-Fasst Emulated-Fasst Emulate-fasst-hybrid Emulated-fasst+pa</p>
    <p># Machines</p>
    <p>Throughput (million TXs/second)</p>
  </div>
  <div class="page">
    <p>Smallbank workloads</p>
    <p>!32</p>
    <p>E V L C</p>
    <p>CX3[1]     CX4 I +  I I  CX4-ROCE[1] I +  I I  CX5[1][2] I +  I I</p>
    <p>FaSST-OCC FaRM DrTM+R DrTM+H</p>
    <p>Throughput (millon TXs/second)</p>
    <p>L a</p>
    <p>te n</p>
    <p>cy (m</p>
    <p>s)</p>
    <p>ConnectX-3 ConnectX-4</p>
    <p>ConnectX-5ConnectX-4-ROCE</p>
    <p>[1]1-way replication used due to cluster limitation</p>
    <p>[2]1-RNIC per machine, others uses 2</p>
  </div>
  <div class="page">
    <p>RDMA based execution framework</p>
    <p>Applied &amp; based RDMA optimizations</p>
    <p>FaRM [NSDI14,SOSP15]</p>
    <p>Herd [NSDI14]</p>
    <p>RDMA guideline [ATC16]</p>
    <p>FaSST [OSDI16]</p>
    <p>!33</p>
    <p>Others</p>
    <p>LITE [SOSP2017] -&gt; Further improve one-sided's scalability</p>
  </div>
  <div class="page">
    <p>Results using large connections</p>
    <p>!34</p>
  </div>
  <div class="page">
    <p>Comparison of two-sided implementations</p>
    <p>FaSST RPC uses UD SEND/RECV</p>
    <p>!35</p>
  </div>
  <div class="page">
    <p>RDMA enabled application</p>
    <p>Load balance framework</p>
    <p>Distributed TXs</p>
    <p>Graph processing systems</p>
    <p>Distributed file system</p>
    <p>!36</p>
  </div>
</Presentation>
