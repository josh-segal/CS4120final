<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>On Dynamic Malware Payloads Aimed at Programmable Logic</p>
    <p>Controllers</p>
    <p>Stephen McLaughlin Penn State</p>
    <p>smclaugh@cse.psu.edu</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>Recommended Best Practice: Defense in Depth</p>
    <p>The new protocols and communication standards that are providing increased interoperability and control in the control system community are the same technologies that have been exploited and compromised in the Internet and networking domains. Historically, control system security meant locating and identifying problems in a closed-loop system; now unauthorized intrusion or attacks are evolving issues to be addressed.</p>
    <p>Figure 1 illustrates the traditional separation of corporate architectures and control domains. This architecture provided means for data sharing, data acquisition, peer-to-peer data exchange, and other business operations. However, the security of any given system was based on the fact that few, if any, understood the intricate architecture or the operational mechanics of the resources on the controls system LAN. This security by obscurity works well for environments that have no external communication connections which allow an organization to focus on physical security.</p>
    <p>Figure 1  Traditional isolation of corporate and control domains</p>
    <p>SCADA and PLCs  PLCs are the lowest level of computation in the SCADA system</p>
    <p>Image source: Control Systems Cyber Security: Defense in Depth Strategies. Idaho National Laboratory. 2006</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>Stuxnets PLC payload</p>
    <p>W32.Stuxnet Dossier</p>
    <p>Page 36</p>
    <p>Security Response</p>
    <p>Sequence blocks Sequences A and B are extremely close and functionally equivalent. They consist of 17 blocks, the malicious DP_RECV replacement block, as well as the infected OB1 and OB35 blocks. Figure 21 shows the connections between the blocks.</p>
    <p>Legend: Arrows between two code blocks mean that a block calls or executes another block. The pink block represents the main block, called from the infected OB1. White blocks are standard Stuxnet code blocks. Yellow blocks are also Stuxnet blocks, but copied from the Simatic library of standard blocks. They execute common functions, such as timestamp comparison. Gray blocks are not part of Stuxnet; theyre system function blocks, part of the operating system running on the PLC. Theyre used to execute system tasks, such as reading the system clock (SFC1).</p>
    <p>Green blocks represent Stuxnet data blocks.</p>
    <p>Note that block names are misleading (except for the yellow and gray blocks), in the sense that they do not reflect the real purpose of the block.</p>
    <p>Sequences A and B intercept packets on the Profibus by using the DP_RECV hooking block. Based on the values found in these blocks, other packets are generated and sent on the wire. This is controlled by a complex state machine, implemented in the various code blocks that make the sequence. One can recognize an infected PLC in a clean environment by examining blocks OB1 and OB35. The infected OB1 starts with the following instructions, meant to start the infection sequence and potentially short-circuit OB1 execution on specific conditions:</p>
    <p>UC FC1865 POP L DW#16#DEADF007 ==D BEC L DW#16#0 L DW#16#0</p>
    <p>Figure 21</p>
    <p>Connections between sequence blocks</p>
    <p>Image source: W32.Stuxnet Dossier. Nicolas Falliere, et al. 2010</p>
    <p>Stuxnet delivered a precompiled payload. The specifics details of the target had to be known ahead of time.</p>
    <p>Against any other target, the payload would have random or no affect.</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>This talk</p>
    <p>Are dynamic payloads for unknown or partially known targets possible?</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>An engineering problem  Writing malware to overcome the obscurity of process</p>
    <p>control systems is an engineering problem.</p>
    <p>This problem can be solved, as can all software engineering problems, through a breaking down into modular steps.</p>
    <p>PLC Plant/Fieldbus Process Analysis</p>
    <p>Payload Generation</p>
    <p>Process Representation</p>
    <p>PLC Code</p>
    <p>Config data</p>
    <p>Malicious PLC Code</p>
    <p>Dynamic Payload</p>
    <p>SCADA MTU Plant</p>
    <p>Delivery Mechanism</p>
    <p>Zero day</p>
    <p>Rootkit</p>
    <p>Insider, etc.</p>
    <p>Internet/ SCADA/</p>
    <p>LAN</p>
    <p>Payload Goal</p>
    <p>Format Library</p>
    <p>Figure 2: The basic steps for constructing a dynamic payload based on observations taken from within a process</p>
    <p>control system.</p>
    <p>Because the payload was precompiled, it is believed</p>
    <p>that Stuxnets authors had previous knowledge of the ex</p>
    <p>act layout of the target process and plant. Thus, it is un</p>
    <p>likely that its attack would succeed against any other fa</p>
    <p>cility besides the intended one. This need for a priori knowledge of the target is assumed to be the main mit</p>
    <p>igating factor against the more common occurrence of</p>
    <p>PLC malware. It is this belief that motivates our inspec</p>
    <p>tion of dynamic payload generation for PLC malware.</p>
    <p>Figure 2 shows the basic steps PLC malware take to dy</p>
    <p>namically construct a payload against an unknown pro</p>
    <p>cess. As with any malware, it must first infect (1) one or more hosts before executing its payload. Infection may occur via viral propagation, Trojan horse, insiders,</p>
    <p>or any other attack vector. PLC malware ultimately tries</p>
    <p>to infect a host that can reach a PLC. Because the details</p>
    <p>of the process are unknown at this point, a payload can</p>
    <p>not yet be directly uploaded. Instead, the PLCs memory</p>
    <p>contents are read (2) for a step called process analysis, which produces a canonical process representation (3). This may require the use of a format library to decode proprietary binary formats. The process representation</p>
    <p>is then used by the subsequent payload generation step to create a payload that will achieve the payload goal in the plant (4). If payload generation is successful, then a</p>
    <p>payload tailored to the specific process may be uploaded</p>
    <p>to the PLC and executed.</p>
    <p>For the remainder of this section, we describe tech</p>
    <p>niques by which each of the above steps may be</p>
    <p>achieved.</p>
    <p>wishes to cause in the plant. It may be as simple as Open</p>
    <p>all breakers in the electrical substation, or as complex</p>
    <p>as Identify all incompatible regions of track and signal</p>
    <p>two trains to enter a conflicting route. It may also be</p>
    <p>very broad in scope, e.g. Identify and violate all safety</p>
    <p>checks maintained by the PLC. Regardless of the ex</p>
    <p>act goal, the dynamic payload will ultimately be a se</p>
    <p>quence of one or more assignments to output variables</p>
    <p>that achieves the goal in the plant. Thus, the payload goal</p>
    <p>can be thought of as a template for the dynamic payload,</p>
    <p>with the specifics being filled in by the steps of process</p>
    <p>analysis and payload generation.</p>
    <p>data read from a PLC into a canonical process represen</p>
    <p>tation. A complete process representation should contain</p>
    <p>both a canonicalization of the PLC code, and the map</p>
    <p>ping from input and output variables to their correspond</p>
    <p>ing sensors and devices in the plant. While the code can</p>
    <p>always be obtained by reading the PLCs function blocks,</p>
    <p>it may not be possible to obtain or infer the device map</p>
    <p>ping. The challenges associated with each task are de</p>
    <p>scribed as follows.</p>
    <p>Recovering the Boolean equations. The first step towards obtaining the process representation is to recover</p>
    <p>the set of Boolean equations  that represents the logic. Similar to the procedure for reverse engineering a typ</p>
    <p>ical computer program, the native code will have to be</p>
    <p>disassembled into mnemonics and then transformed to</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>Code reuse</p>
    <p>PLC Plant/Fieldbus Process Analysis</p>
    <p>Payload Generation</p>
    <p>Process Representation</p>
    <p>PLC Code</p>
    <p>Config data</p>
    <p>Malicious PLC Code</p>
    <p>Dynamic Payload</p>
    <p>SCADA MTU Plant</p>
    <p>Delivery Mechanism</p>
    <p>Zero day</p>
    <p>Rootkit</p>
    <p>Insider, etc.</p>
    <p>Internet/ SCADA/</p>
    <p>LAN</p>
    <p>Payload Goal</p>
    <p>Format Library</p>
    <p>Figure 2: The basic steps for constructing a dynamic payload based on observations taken from within a process</p>
    <p>control system.</p>
    <p>Because the payload was precompiled, it is believed</p>
    <p>that Stuxnets authors had previous knowledge of the ex</p>
    <p>act layout of the target process and plant. Thus, it is un</p>
    <p>likely that its attack would succeed against any other fa</p>
    <p>cility besides the intended one. This need for a priori knowledge of the target is assumed to be the main mit</p>
    <p>igating factor against the more common occurrence of</p>
    <p>PLC malware. It is this belief that motivates our inspec</p>
    <p>tion of dynamic payload generation for PLC malware.</p>
    <p>Figure 2 shows the basic steps PLC malware take to dy</p>
    <p>namically construct a payload against an unknown pro</p>
    <p>cess. As with any malware, it must first infect (1) one or more hosts before executing its payload. Infection may occur via viral propagation, Trojan horse, insiders,</p>
    <p>or any other attack vector. PLC malware ultimately tries</p>
    <p>to infect a host that can reach a PLC. Because the details</p>
    <p>of the process are unknown at this point, a payload can</p>
    <p>not yet be directly uploaded. Instead, the PLCs memory</p>
    <p>contents are read (2) for a step called process analysis, which produces a canonical process representation (3). This may require the use of a format library to decode proprietary binary formats. The process representation</p>
    <p>is then used by the subsequent payload generation step to create a payload that will achieve the payload goal in the plant (4). If payload generation is successful, then a</p>
    <p>payload tailored to the specific process may be uploaded</p>
    <p>to the PLC and executed.</p>
    <p>For the remainder of this section, we describe tech</p>
    <p>niques by which each of the above steps may be</p>
    <p>achieved.</p>
    <p>wishes to cause in the plant. It may be as simple as Open</p>
    <p>all breakers in the electrical substation, or as complex</p>
    <p>as Identify all incompatible regions of track and signal</p>
    <p>two trains to enter a conflicting route. It may also be</p>
    <p>very broad in scope, e.g. Identify and violate all safety</p>
    <p>checks maintained by the PLC. Regardless of the ex</p>
    <p>act goal, the dynamic payload will ultimately be a se</p>
    <p>quence of one or more assignments to output variables</p>
    <p>that achieves the goal in the plant. Thus, the payload goal</p>
    <p>can be thought of as a template for the dynamic payload,</p>
    <p>with the specifics being filled in by the steps of process</p>
    <p>analysis and payload generation.</p>
    <p>data read from a PLC into a canonical process represen</p>
    <p>tation. A complete process representation should contain</p>
    <p>both a canonicalization of the PLC code, and the map</p>
    <p>ping from input and output variables to their correspond</p>
    <p>ing sensors and devices in the plant. While the code can</p>
    <p>always be obtained by reading the PLCs function blocks,</p>
    <p>it may not be possible to obtain or infer the device map</p>
    <p>ping. The challenges associated with each task are de</p>
    <p>scribed as follows.</p>
    <p>Recovering the Boolean equations. The first step towards obtaining the process representation is to recover</p>
    <p>the set of Boolean equations  that represents the logic. Similar to the procedure for reverse engineering a typ</p>
    <p>ical computer program, the native code will have to be</p>
    <p>disassembled into mnemonics and then transformed to</p>
    <p>Ideally, the adversary need only specify the payload goal.</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>Code reuse</p>
    <p>PLC Plant/Fieldbus Process Analysis</p>
    <p>Payload Generation</p>
    <p>Process Representation</p>
    <p>PLC Code</p>
    <p>Config data</p>
    <p>Malicious PLC Code</p>
    <p>Dynamic Payload</p>
    <p>SCADA MTU Plant</p>
    <p>Delivery Mechanism</p>
    <p>Zero day</p>
    <p>Rootkit</p>
    <p>Insider, etc.</p>
    <p>Internet/ SCADA/</p>
    <p>LAN</p>
    <p>Payload Goal</p>
    <p>Format Library</p>
    <p>Figure 2: The basic steps for constructing a dynamic payload based on observations taken from within a process</p>
    <p>control system.</p>
    <p>Because the payload was precompiled, it is believed</p>
    <p>that Stuxnets authors had previous knowledge of the ex</p>
    <p>act layout of the target process and plant. Thus, it is un</p>
    <p>likely that its attack would succeed against any other fa</p>
    <p>cility besides the intended one. This need for a priori knowledge of the target is assumed to be the main mit</p>
    <p>igating factor against the more common occurrence of</p>
    <p>PLC malware. It is this belief that motivates our inspec</p>
    <p>tion of dynamic payload generation for PLC malware.</p>
    <p>Figure 2 shows the basic steps PLC malware take to dy</p>
    <p>namically construct a payload against an unknown pro</p>
    <p>cess. As with any malware, it must first infect (1) one or more hosts before executing its payload. Infection may occur via viral propagation, Trojan horse, insiders,</p>
    <p>or any other attack vector. PLC malware ultimately tries</p>
    <p>to infect a host that can reach a PLC. Because the details</p>
    <p>of the process are unknown at this point, a payload can</p>
    <p>not yet be directly uploaded. Instead, the PLCs memory</p>
    <p>contents are read (2) for a step called process analysis, which produces a canonical process representation (3). This may require the use of a format library to decode proprietary binary formats. The process representation</p>
    <p>is then used by the subsequent payload generation step to create a payload that will achieve the payload goal in the plant (4). If payload generation is successful, then a</p>
    <p>payload tailored to the specific process may be uploaded</p>
    <p>to the PLC and executed.</p>
    <p>For the remainder of this section, we describe tech</p>
    <p>niques by which each of the above steps may be</p>
    <p>achieved.</p>
    <p>wishes to cause in the plant. It may be as simple as Open</p>
    <p>all breakers in the electrical substation, or as complex</p>
    <p>as Identify all incompatible regions of track and signal</p>
    <p>two trains to enter a conflicting route. It may also be</p>
    <p>very broad in scope, e.g. Identify and violate all safety</p>
    <p>checks maintained by the PLC. Regardless of the ex</p>
    <p>act goal, the dynamic payload will ultimately be a se</p>
    <p>quence of one or more assignments to output variables</p>
    <p>that achieves the goal in the plant. Thus, the payload goal</p>
    <p>can be thought of as a template for the dynamic payload,</p>
    <p>with the specifics being filled in by the steps of process</p>
    <p>analysis and payload generation.</p>
    <p>data read from a PLC into a canonical process represen</p>
    <p>tation. A complete process representation should contain</p>
    <p>both a canonicalization of the PLC code, and the map</p>
    <p>ping from input and output variables to their correspond</p>
    <p>ing sensors and devices in the plant. While the code can</p>
    <p>always be obtained by reading the PLCs function blocks,</p>
    <p>it may not be possible to obtain or infer the device map</p>
    <p>ping. The challenges associated with each task are de</p>
    <p>scribed as follows.</p>
    <p>Recovering the Boolean equations. The first step towards obtaining the process representation is to recover</p>
    <p>the set of Boolean equations  that represents the logic. Similar to the procedure for reverse engineering a typ</p>
    <p>ical computer program, the native code will have to be</p>
    <p>disassembled into mnemonics and then transformed to</p>
    <p>The format library contains platform-depended disassemblers and device IDs.</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>Logic programming  Logic programs simulate Boolean circuits.</p>
    <p>A PLC program maps a set of input variables to a set of output variables .</p>
    <p>Values for are received from the sensors in the plant, and values in are sent to the plant to manipulate devices.</p>
    <p>A set of internal state variables and timer variables are also available.</p>
    <p>A logic program is a set of expressions s.t.</p>
    <p>Note that in practice, we can often differentiate the four types of variables.</p>
    <p>I O</p>
    <p>I O</p>
    <p>C T</p>
    <p>(y  )  , Var()  I  O  C  T and y  O  C  T</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>A pedestrian crossing</p>
    <p>Signal Box</p>
    <p>tg, ty, tr pg, pr</p>
    <p>pressed</p>
    <p>(I)</p>
    <p>(O)</p>
    <p>pedestrian</p>
    <p>traffic</p>
    <p>Figure 1: Pedestrian crossing with signal box inputs and</p>
    <p>outputs labeled.</p>
    <p>The problem of autonomously generating a PLC pay</p>
    <p>load is broken down into several steps. First, the mal</p>
    <p>ware author must specify a goal to be carried out in one</p>
    <p>or more target control systems. Once the PLC malware is</p>
    <p>inside the control system, it must at least read the PLCs</p>
    <p>code and data memory to obtain clues about the process</p>
    <p>structure and operations. Examples of such clues that</p>
    <p>will be covered later are the process fieldbus IDs of de</p>
    <p>vices in the plant and the safety interlocks that prevent</p>
    <p>the process from entering unsafe states. If these clues are</p>
    <p>sufficient to carry out the goal, a payload is generated</p>
    <p>and executed on the PLC. Each of these steps will now</p>
    <p>be detailed after a summary of PLC functionality.</p>
    <p>PLCs are the real-time systems that closely monitor and</p>
    <p>control plant devices to keep the process functioning cor</p>
    <p>rectly. Program execution on PLCs differs substantially</p>
    <p>from on general-purpose computers. A PLC program,</p>
    <p>often referred to as the logic, is executed within a loop many times per second. Each execution is called a scan cycle. During each scan cycle, a set of input variables I are read from the sensors in the plant and processed by</p>
    <p>the logic to produce a set of output variables O that dic</p>
    <p>tate the behavior of each physical device. The logic may</p>
    <p>also maintain a set of internal state variables C and a set</p>
    <p>of timer variables T . Often, the addresses referenced by</p>
    <p>variables reveal which class it belongs to. In Siemens S7</p>
    <p>PLCs for example, separate memory areas are used for</p>
    <p>I , O, C , and T .</p>
    <p>While PLCs may be programmed in a number of dif</p>
    <p>ferent languages, e.g. relay ladder logic, most PLC pro</p>
    <p>grams can be represented as a set of Boolean expres</p>
    <p>sions . As this is a commonly used intermediate representation for logic verification [8, 15], we adopt it here</p>
    <p>as well. Each expression in  is of the form yi  i, where yi  O  C  T is the result of evaluation and Var(i)  I  O  C  T is the set of variables in the expression i. With the exception of timers, all expressions are evaluated using the values of variables at the</p>
    <p>beginning of the scan cycle. Thus, if one Boolean ex</p>
    <p>pression depends on the result of another, the value of the</p>
    <p>result from the previous scan cycle is used. In the case</p>
    <p>of timers, the time at the exact moment of evaluation is</p>
    <p>used.</p>
    <p>For illustrative purposes throughout this paper, we use</p>
    <p>a simplified traffic light system for a pedestrian street</p>
    <p>crossing, based on the example in [11]. (See Figure 1.) In</p>
    <p>this system, the only input variable is the button used to</p>
    <p>request pedestrian crossing ( pressed). The output variables control the signals for traffic green, yellow, and red</p>
    <p>(tg,ty,tr ) and pedestrian green and red ( pg, pr ). An example of an expression in  for this system is:</p>
    <p>pg  pressed  tr</p>
    <p>which says that the pedestrian green light should be ac</p>
    <p>tive only if the crossing button has been pressed and traf</p>
    <p>fic has a red light (pg,tr  O and pressed  I ). It is a standard practice that each output variable is only assigned</p>
    <p>once in the logic. Thus, (pressed  tr)  pg. A PLC is typically programmed from commodity sys</p>
    <p>tems over a serial connection. The programming ma</p>
    <p>chine in question is called the Master Terminal Unit or</p>
    <p>MTU. (Note that the MTU need not always be connected</p>
    <p>to the PLC, as this may sometimes only be the case when</p>
    <p>uploading new logic.) Along with uploading code to</p>
    <p>PLCs, MTUs may also upload configuration parameters,</p>
    <p>and collect plant statistics from the PLC. The MTU also</p>
    <p>represents the main entry point for PLC malware. Typ</p>
    <p>ically, the only security present between the MTU and</p>
    <p>PLC is a password-based authentication to the PLC be</p>
    <p>fore uploading new code. One can imagine the myriad</p>
    <p>ways in which malicious code on the MTU could bypass</p>
    <p>such a mechanism.</p>
    <p>Recent concerns surrounding PLC malware were</p>
    <p>spawned from the emergence of the Stuxnet virus [21,</p>
    <p>Without dwelling on the alleged purpose of the</p>
    <p>virus, we briefly describe Stuxnets internal mechanics</p>
    <p>as detailed in [6]. Stuxnet had a sophisticated infec</p>
    <p>tion process which used code signed by two valid cer</p>
    <p>tificates, multivector propagation (including via USB),</p>
    <p>and Microsoft Windows zero-day exploits. The goal</p>
    <p>of Stuxnets propagation is to reach the nodes in the</p>
    <p>SCADA system that are directly connected to the PLCs</p>
    <p>operating the target plant, i.e. the MTUs. Once executing</p>
    <p>on an MTU, Stuxnet uploads its payload of static code</p>
    <p>blocks to the PLC. At this point, the process is under</p>
    <p>malicious control.</p>
    <p>control systems unintentionally [12].</p>
    <p>Traffic green, yellow, and red (output)</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>A pedestrian crossing</p>
    <p>Signal Box</p>
    <p>tg, ty, tr pg, pr</p>
    <p>pressed</p>
    <p>(I)</p>
    <p>(O)</p>
    <p>pedestrian</p>
    <p>traffic</p>
    <p>Figure 1: Pedestrian crossing with signal box inputs and</p>
    <p>outputs labeled.</p>
    <p>The problem of autonomously generating a PLC pay</p>
    <p>load is broken down into several steps. First, the mal</p>
    <p>ware author must specify a goal to be carried out in one</p>
    <p>or more target control systems. Once the PLC malware is</p>
    <p>inside the control system, it must at least read the PLCs</p>
    <p>code and data memory to obtain clues about the process</p>
    <p>structure and operations. Examples of such clues that</p>
    <p>will be covered later are the process fieldbus IDs of de</p>
    <p>vices in the plant and the safety interlocks that prevent</p>
    <p>the process from entering unsafe states. If these clues are</p>
    <p>sufficient to carry out the goal, a payload is generated</p>
    <p>and executed on the PLC. Each of these steps will now</p>
    <p>be detailed after a summary of PLC functionality.</p>
    <p>PLCs are the real-time systems that closely monitor and</p>
    <p>control plant devices to keep the process functioning cor</p>
    <p>rectly. Program execution on PLCs differs substantially</p>
    <p>from on general-purpose computers. A PLC program,</p>
    <p>often referred to as the logic, is executed within a loop many times per second. Each execution is called a scan cycle. During each scan cycle, a set of input variables I are read from the sensors in the plant and processed by</p>
    <p>the logic to produce a set of output variables O that dic</p>
    <p>tate the behavior of each physical device. The logic may</p>
    <p>also maintain a set of internal state variables C and a set</p>
    <p>of timer variables T . Often, the addresses referenced by</p>
    <p>variables reveal which class it belongs to. In Siemens S7</p>
    <p>PLCs for example, separate memory areas are used for</p>
    <p>I , O, C , and T .</p>
    <p>While PLCs may be programmed in a number of dif</p>
    <p>ferent languages, e.g. relay ladder logic, most PLC pro</p>
    <p>grams can be represented as a set of Boolean expres</p>
    <p>sions . As this is a commonly used intermediate representation for logic verification [8, 15], we adopt it here</p>
    <p>as well. Each expression in  is of the form yi  i, where yi  O  C  T is the result of evaluation and Var(i)  I  O  C  T is the set of variables in the expression i. With the exception of timers, all expressions are evaluated using the values of variables at the</p>
    <p>beginning of the scan cycle. Thus, if one Boolean ex</p>
    <p>pression depends on the result of another, the value of the</p>
    <p>result from the previous scan cycle is used. In the case</p>
    <p>of timers, the time at the exact moment of evaluation is</p>
    <p>used.</p>
    <p>For illustrative purposes throughout this paper, we use</p>
    <p>a simplified traffic light system for a pedestrian street</p>
    <p>crossing, based on the example in [11]. (See Figure 1.) In</p>
    <p>this system, the only input variable is the button used to</p>
    <p>request pedestrian crossing ( pressed). The output variables control the signals for traffic green, yellow, and red</p>
    <p>(tg,ty,tr ) and pedestrian green and red ( pg, pr ). An example of an expression in  for this system is:</p>
    <p>pg  pressed  tr</p>
    <p>which says that the pedestrian green light should be ac</p>
    <p>tive only if the crossing button has been pressed and traf</p>
    <p>fic has a red light (pg,tr  O and pressed  I ). It is a standard practice that each output variable is only assigned</p>
    <p>once in the logic. Thus, (pressed  tr)  pg. A PLC is typically programmed from commodity sys</p>
    <p>tems over a serial connection. The programming ma</p>
    <p>chine in question is called the Master Terminal Unit or</p>
    <p>MTU. (Note that the MTU need not always be connected</p>
    <p>to the PLC, as this may sometimes only be the case when</p>
    <p>uploading new logic.) Along with uploading code to</p>
    <p>PLCs, MTUs may also upload configuration parameters,</p>
    <p>and collect plant statistics from the PLC. The MTU also</p>
    <p>represents the main entry point for PLC malware. Typ</p>
    <p>ically, the only security present between the MTU and</p>
    <p>PLC is a password-based authentication to the PLC be</p>
    <p>fore uploading new code. One can imagine the myriad</p>
    <p>ways in which malicious code on the MTU could bypass</p>
    <p>such a mechanism.</p>
    <p>Recent concerns surrounding PLC malware were</p>
    <p>spawned from the emergence of the Stuxnet virus [21,</p>
    <p>Without dwelling on the alleged purpose of the</p>
    <p>virus, we briefly describe Stuxnets internal mechanics</p>
    <p>as detailed in [6]. Stuxnet had a sophisticated infec</p>
    <p>tion process which used code signed by two valid cer</p>
    <p>tificates, multivector propagation (including via USB),</p>
    <p>and Microsoft Windows zero-day exploits. The goal</p>
    <p>of Stuxnets propagation is to reach the nodes in the</p>
    <p>SCADA system that are directly connected to the PLCs</p>
    <p>operating the target plant, i.e. the MTUs. Once executing</p>
    <p>on an MTU, Stuxnet uploads its payload of static code</p>
    <p>blocks to the PLC. At this point, the process is under</p>
    <p>malicious control.</p>
    <p>control systems unintentionally [12].</p>
    <p>Pedestrian green and red (output)</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>A pedestrian crossing</p>
    <p>Signal Box</p>
    <p>tg, ty, tr pg, pr</p>
    <p>pressed</p>
    <p>(I)</p>
    <p>(O)</p>
    <p>pedestrian</p>
    <p>traffic</p>
    <p>Figure 1: Pedestrian crossing with signal box inputs and</p>
    <p>outputs labeled.</p>
    <p>The problem of autonomously generating a PLC pay</p>
    <p>load is broken down into several steps. First, the mal</p>
    <p>ware author must specify a goal to be carried out in one</p>
    <p>or more target control systems. Once the PLC malware is</p>
    <p>inside the control system, it must at least read the PLCs</p>
    <p>code and data memory to obtain clues about the process</p>
    <p>structure and operations. Examples of such clues that</p>
    <p>will be covered later are the process fieldbus IDs of de</p>
    <p>vices in the plant and the safety interlocks that prevent</p>
    <p>the process from entering unsafe states. If these clues are</p>
    <p>sufficient to carry out the goal, a payload is generated</p>
    <p>and executed on the PLC. Each of these steps will now</p>
    <p>be detailed after a summary of PLC functionality.</p>
    <p>PLCs are the real-time systems that closely monitor and</p>
    <p>control plant devices to keep the process functioning cor</p>
    <p>rectly. Program execution on PLCs differs substantially</p>
    <p>from on general-purpose computers. A PLC program,</p>
    <p>often referred to as the logic, is executed within a loop many times per second. Each execution is called a scan cycle. During each scan cycle, a set of input variables I are read from the sensors in the plant and processed by</p>
    <p>the logic to produce a set of output variables O that dic</p>
    <p>tate the behavior of each physical device. The logic may</p>
    <p>also maintain a set of internal state variables C and a set</p>
    <p>of timer variables T . Often, the addresses referenced by</p>
    <p>variables reveal which class it belongs to. In Siemens S7</p>
    <p>PLCs for example, separate memory areas are used for</p>
    <p>I , O, C , and T .</p>
    <p>While PLCs may be programmed in a number of dif</p>
    <p>ferent languages, e.g. relay ladder logic, most PLC pro</p>
    <p>grams can be represented as a set of Boolean expres</p>
    <p>sions . As this is a commonly used intermediate representation for logic verification [8, 15], we adopt it here</p>
    <p>as well. Each expression in  is of the form yi  i, where yi  O  C  T is the result of evaluation and Var(i)  I  O  C  T is the set of variables in the expression i. With the exception of timers, all expressions are evaluated using the values of variables at the</p>
    <p>beginning of the scan cycle. Thus, if one Boolean ex</p>
    <p>pression depends on the result of another, the value of the</p>
    <p>result from the previous scan cycle is used. In the case</p>
    <p>of timers, the time at the exact moment of evaluation is</p>
    <p>used.</p>
    <p>For illustrative purposes throughout this paper, we use</p>
    <p>a simplified traffic light system for a pedestrian street</p>
    <p>crossing, based on the example in [11]. (See Figure 1.) In</p>
    <p>this system, the only input variable is the button used to</p>
    <p>request pedestrian crossing ( pressed). The output variables control the signals for traffic green, yellow, and red</p>
    <p>(tg,ty,tr ) and pedestrian green and red ( pg, pr ). An example of an expression in  for this system is:</p>
    <p>pg  pressed  tr</p>
    <p>which says that the pedestrian green light should be ac</p>
    <p>tive only if the crossing button has been pressed and traf</p>
    <p>fic has a red light (pg,tr  O and pressed  I ). It is a standard practice that each output variable is only assigned</p>
    <p>once in the logic. Thus, (pressed  tr)  pg. A PLC is typically programmed from commodity sys</p>
    <p>tems over a serial connection. The programming ma</p>
    <p>chine in question is called the Master Terminal Unit or</p>
    <p>MTU. (Note that the MTU need not always be connected</p>
    <p>to the PLC, as this may sometimes only be the case when</p>
    <p>uploading new logic.) Along with uploading code to</p>
    <p>PLCs, MTUs may also upload configuration parameters,</p>
    <p>and collect plant statistics from the PLC. The MTU also</p>
    <p>represents the main entry point for PLC malware. Typ</p>
    <p>ically, the only security present between the MTU and</p>
    <p>PLC is a password-based authentication to the PLC be</p>
    <p>fore uploading new code. One can imagine the myriad</p>
    <p>ways in which malicious code on the MTU could bypass</p>
    <p>such a mechanism.</p>
    <p>Recent concerns surrounding PLC malware were</p>
    <p>spawned from the emergence of the Stuxnet virus [21,</p>
    <p>Without dwelling on the alleged purpose of the</p>
    <p>virus, we briefly describe Stuxnets internal mechanics</p>
    <p>as detailed in [6]. Stuxnet had a sophisticated infec</p>
    <p>tion process which used code signed by two valid cer</p>
    <p>tificates, multivector propagation (including via USB),</p>
    <p>and Microsoft Windows zero-day exploits. The goal</p>
    <p>of Stuxnets propagation is to reach the nodes in the</p>
    <p>SCADA system that are directly connected to the PLCs</p>
    <p>operating the target plant, i.e. the MTUs. Once executing</p>
    <p>on an MTU, Stuxnet uploads its payload of static code</p>
    <p>blocks to the PLC. At this point, the process is under</p>
    <p>malicious control.</p>
    <p>control systems unintentionally [12].</p>
    <p>Request to cross button (input)</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>(y  ) = (pg  pressed  tr), Var() = {pressed, tr}</p>
    <p>A pedestrian crossing</p>
    <p>Signal Box</p>
    <p>tg, ty, tr pg, pr</p>
    <p>pressed</p>
    <p>(I)</p>
    <p>(O)</p>
    <p>pedestrian</p>
    <p>traffic</p>
    <p>Figure 1: Pedestrian crossing with signal box inputs and</p>
    <p>outputs labeled.</p>
    <p>The problem of autonomously generating a PLC pay</p>
    <p>load is broken down into several steps. First, the mal</p>
    <p>ware author must specify a goal to be carried out in one</p>
    <p>or more target control systems. Once the PLC malware is</p>
    <p>inside the control system, it must at least read the PLCs</p>
    <p>code and data memory to obtain clues about the process</p>
    <p>structure and operations. Examples of such clues that</p>
    <p>will be covered later are the process fieldbus IDs of de</p>
    <p>vices in the plant and the safety interlocks that prevent</p>
    <p>the process from entering unsafe states. If these clues are</p>
    <p>sufficient to carry out the goal, a payload is generated</p>
    <p>and executed on the PLC. Each of these steps will now</p>
    <p>be detailed after a summary of PLC functionality.</p>
    <p>PLCs are the real-time systems that closely monitor and</p>
    <p>control plant devices to keep the process functioning cor</p>
    <p>rectly. Program execution on PLCs differs substantially</p>
    <p>from on general-purpose computers. A PLC program,</p>
    <p>often referred to as the logic, is executed within a loop many times per second. Each execution is called a scan cycle. During each scan cycle, a set of input variables I are read from the sensors in the plant and processed by</p>
    <p>the logic to produce a set of output variables O that dic</p>
    <p>tate the behavior of each physical device. The logic may</p>
    <p>also maintain a set of internal state variables C and a set</p>
    <p>of timer variables T . Often, the addresses referenced by</p>
    <p>variables reveal which class it belongs to. In Siemens S7</p>
    <p>PLCs for example, separate memory areas are used for</p>
    <p>I , O, C , and T .</p>
    <p>While PLCs may be programmed in a number of dif</p>
    <p>ferent languages, e.g. relay ladder logic, most PLC pro</p>
    <p>grams can be represented as a set of Boolean expres</p>
    <p>sions . As this is a commonly used intermediate representation for logic verification [8, 15], we adopt it here</p>
    <p>as well. Each expression in  is of the form yi  i, where yi  O  C  T is the result of evaluation and Var(i)  I  O  C  T is the set of variables in the expression i. With the exception of timers, all expressions are evaluated using the values of variables at the</p>
    <p>beginning of the scan cycle. Thus, if one Boolean ex</p>
    <p>pression depends on the result of another, the value of the</p>
    <p>result from the previous scan cycle is used. In the case</p>
    <p>of timers, the time at the exact moment of evaluation is</p>
    <p>used.</p>
    <p>For illustrative purposes throughout this paper, we use</p>
    <p>a simplified traffic light system for a pedestrian street</p>
    <p>crossing, based on the example in [11]. (See Figure 1.) In</p>
    <p>this system, the only input variable is the button used to</p>
    <p>request pedestrian crossing ( pressed). The output variables control the signals for traffic green, yellow, and red</p>
    <p>(tg,ty,tr ) and pedestrian green and red ( pg, pr ). An example of an expression in  for this system is:</p>
    <p>pg  pressed  tr</p>
    <p>which says that the pedestrian green light should be ac</p>
    <p>tive only if the crossing button has been pressed and traf</p>
    <p>fic has a red light (pg,tr  O and pressed  I ). It is a standard practice that each output variable is only assigned</p>
    <p>once in the logic. Thus, (pressed  tr)  pg. A PLC is typically programmed from commodity sys</p>
    <p>tems over a serial connection. The programming ma</p>
    <p>chine in question is called the Master Terminal Unit or</p>
    <p>MTU. (Note that the MTU need not always be connected</p>
    <p>to the PLC, as this may sometimes only be the case when</p>
    <p>uploading new logic.) Along with uploading code to</p>
    <p>PLCs, MTUs may also upload configuration parameters,</p>
    <p>and collect plant statistics from the PLC. The MTU also</p>
    <p>represents the main entry point for PLC malware. Typ</p>
    <p>ically, the only security present between the MTU and</p>
    <p>PLC is a password-based authentication to the PLC be</p>
    <p>fore uploading new code. One can imagine the myriad</p>
    <p>ways in which malicious code on the MTU could bypass</p>
    <p>such a mechanism.</p>
    <p>Recent concerns surrounding PLC malware were</p>
    <p>spawned from the emergence of the Stuxnet virus [21,</p>
    <p>Without dwelling on the alleged purpose of the</p>
    <p>virus, we briefly describe Stuxnets internal mechanics</p>
    <p>as detailed in [6]. Stuxnet had a sophisticated infec</p>
    <p>tion process which used code signed by two valid cer</p>
    <p>tificates, multivector propagation (including via USB),</p>
    <p>and Microsoft Windows zero-day exploits. The goal</p>
    <p>of Stuxnets propagation is to reach the nodes in the</p>
    <p>SCADA system that are directly connected to the PLCs</p>
    <p>operating the target plant, i.e. the MTUs. Once executing</p>
    <p>on an MTU, Stuxnet uploads its payload of static code</p>
    <p>blocks to the PLC. At this point, the process is under</p>
    <p>malicious control.</p>
    <p>control systems unintentionally [12].</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>Process analysis</p>
    <p>PLC Plant/Fieldbus Process Analysis</p>
    <p>Payload Generation</p>
    <p>Process Representation</p>
    <p>PLC Code</p>
    <p>Config data</p>
    <p>Malicious PLC Code</p>
    <p>Dynamic Payload</p>
    <p>SCADA MTU Plant</p>
    <p>Delivery Mechanism</p>
    <p>Zero day</p>
    <p>Rootkit</p>
    <p>Insider, etc.</p>
    <p>Internet/ SCADA/</p>
    <p>LAN</p>
    <p>Payload Goal</p>
    <p>Format Library</p>
    <p>Figure 2: The basic steps for constructing a dynamic payload based on observations taken from within a process</p>
    <p>control system.</p>
    <p>Because the payload was precompiled, it is believed</p>
    <p>that Stuxnets authors had previous knowledge of the ex</p>
    <p>act layout of the target process and plant. Thus, it is un</p>
    <p>likely that its attack would succeed against any other fa</p>
    <p>cility besides the intended one. This need for a priori knowledge of the target is assumed to be the main mit</p>
    <p>igating factor against the more common occurrence of</p>
    <p>PLC malware. It is this belief that motivates our inspec</p>
    <p>tion of dynamic payload generation for PLC malware.</p>
    <p>Figure 2 shows the basic steps PLC malware take to dy</p>
    <p>namically construct a payload against an unknown pro</p>
    <p>cess. As with any malware, it must first infect (1) one or more hosts before executing its payload. Infection may occur via viral propagation, Trojan horse, insiders,</p>
    <p>or any other attack vector. PLC malware ultimately tries</p>
    <p>to infect a host that can reach a PLC. Because the details</p>
    <p>of the process are unknown at this point, a payload can</p>
    <p>not yet be directly uploaded. Instead, the PLCs memory</p>
    <p>contents are read (2) for a step called process analysis, which produces a canonical process representation (3). This may require the use of a format library to decode proprietary binary formats. The process representation</p>
    <p>is then used by the subsequent payload generation step to create a payload that will achieve the payload goal in the plant (4). If payload generation is successful, then a</p>
    <p>payload tailored to the specific process may be uploaded</p>
    <p>to the PLC and executed.</p>
    <p>For the remainder of this section, we describe tech</p>
    <p>niques by which each of the above steps may be</p>
    <p>achieved.</p>
    <p>wishes to cause in the plant. It may be as simple as Open</p>
    <p>all breakers in the electrical substation, or as complex</p>
    <p>as Identify all incompatible regions of track and signal</p>
    <p>two trains to enter a conflicting route. It may also be</p>
    <p>very broad in scope, e.g. Identify and violate all safety</p>
    <p>checks maintained by the PLC. Regardless of the ex</p>
    <p>act goal, the dynamic payload will ultimately be a se</p>
    <p>quence of one or more assignments to output variables</p>
    <p>that achieves the goal in the plant. Thus, the payload goal</p>
    <p>can be thought of as a template for the dynamic payload,</p>
    <p>with the specifics being filled in by the steps of process</p>
    <p>analysis and payload generation.</p>
    <p>data read from a PLC into a canonical process represen</p>
    <p>tation. A complete process representation should contain</p>
    <p>both a canonicalization of the PLC code, and the map</p>
    <p>ping from input and output variables to their correspond</p>
    <p>ing sensors and devices in the plant. While the code can</p>
    <p>always be obtained by reading the PLCs function blocks,</p>
    <p>it may not be possible to obtain or infer the device map</p>
    <p>ping. The challenges associated with each task are de</p>
    <p>scribed as follows.</p>
    <p>Recovering the Boolean equations. The first step towards obtaining the process representation is to recover</p>
    <p>the set of Boolean equations  that represents the logic. Similar to the procedure for reverse engineering a typ</p>
    <p>ical computer program, the native code will have to be</p>
    <p>disassembled into mnemonics and then transformed to</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>Process analysis: PLC code  How do we obtain the canonical process representation</p>
    <p>from the binary logic?</p>
    <p>While PLC ISAs differ between vendors, many implement the accumulator based architecture specified by the IEC 61131-3 Instruction List (IL) language.</p>
    <p>Thus, converting code to a canonical format of Boolean expressions requires two steps:</p>
    <p>Binary code IL code Boolean exprs Disassembly: Using a mapping from the format library.</p>
    <p>Logic recovery: We have implemented in &lt; 200 lines of Standard ML.</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>Process analysis: configuration data</p>
    <p>PROFINET and PROFIBUS both network PLCs to devices with some onboard intelligence.</p>
    <p>Each PROFI* compliant product has a unique ID that can be queried.</p>
    <p>Stuxnet looked for centrifuge IDs.</p>
    <p>A database of such IDs can be used to map logic variables to physical devices.</p>
    <p>PROFI* device IDs can be scraped from reseller product list, .GSD files, and profibus.com.</p>
    <p>Collect them all!</p>
    <p>Image source: profibus.com</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>Payload generation</p>
    <p>PLC Plant/Fieldbus Process Analysis</p>
    <p>Payload Generation</p>
    <p>Process Representation</p>
    <p>PLC Code</p>
    <p>Config data</p>
    <p>Malicious PLC Code</p>
    <p>Dynamic Payload</p>
    <p>SCADA MTU Plant</p>
    <p>Delivery Mechanism</p>
    <p>Zero day</p>
    <p>Rootkit</p>
    <p>Insider, etc.</p>
    <p>Internet/ SCADA/</p>
    <p>LAN</p>
    <p>Payload Goal</p>
    <p>Format Library</p>
    <p>Figure 2: The basic steps for constructing a dynamic payload based on observations taken from within a process</p>
    <p>control system.</p>
    <p>Because the payload was precompiled, it is believed</p>
    <p>that Stuxnets authors had previous knowledge of the ex</p>
    <p>act layout of the target process and plant. Thus, it is un</p>
    <p>likely that its attack would succeed against any other fa</p>
    <p>cility besides the intended one. This need for a priori knowledge of the target is assumed to be the main mit</p>
    <p>igating factor against the more common occurrence of</p>
    <p>PLC malware. It is this belief that motivates our inspec</p>
    <p>tion of dynamic payload generation for PLC malware.</p>
    <p>Figure 2 shows the basic steps PLC malware take to dy</p>
    <p>namically construct a payload against an unknown pro</p>
    <p>cess. As with any malware, it must first infect (1) one or more hosts before executing its payload. Infection may occur via viral propagation, Trojan horse, insiders,</p>
    <p>or any other attack vector. PLC malware ultimately tries</p>
    <p>to infect a host that can reach a PLC. Because the details</p>
    <p>of the process are unknown at this point, a payload can</p>
    <p>not yet be directly uploaded. Instead, the PLCs memory</p>
    <p>contents are read (2) for a step called process analysis, which produces a canonical process representation (3). This may require the use of a format library to decode proprietary binary formats. The process representation</p>
    <p>is then used by the subsequent payload generation step to create a payload that will achieve the payload goal in the plant (4). If payload generation is successful, then a</p>
    <p>payload tailored to the specific process may be uploaded</p>
    <p>to the PLC and executed.</p>
    <p>For the remainder of this section, we describe tech</p>
    <p>niques by which each of the above steps may be</p>
    <p>achieved.</p>
    <p>wishes to cause in the plant. It may be as simple as Open</p>
    <p>all breakers in the electrical substation, or as complex</p>
    <p>as Identify all incompatible regions of track and signal</p>
    <p>two trains to enter a conflicting route. It may also be</p>
    <p>very broad in scope, e.g. Identify and violate all safety</p>
    <p>checks maintained by the PLC. Regardless of the ex</p>
    <p>act goal, the dynamic payload will ultimately be a se</p>
    <p>quence of one or more assignments to output variables</p>
    <p>that achieves the goal in the plant. Thus, the payload goal</p>
    <p>can be thought of as a template for the dynamic payload,</p>
    <p>with the specifics being filled in by the steps of process</p>
    <p>analysis and payload generation.</p>
    <p>data read from a PLC into a canonical process represen</p>
    <p>tation. A complete process representation should contain</p>
    <p>both a canonicalization of the PLC code, and the map</p>
    <p>ping from input and output variables to their correspond</p>
    <p>ing sensors and devices in the plant. While the code can</p>
    <p>always be obtained by reading the PLCs function blocks,</p>
    <p>it may not be possible to obtain or infer the device map</p>
    <p>ping. The challenges associated with each task are de</p>
    <p>scribed as follows.</p>
    <p>Recovering the Boolean equations. The first step towards obtaining the process representation is to recover</p>
    <p>the set of Boolean equations  that represents the logic. Similar to the procedure for reverse engineering a typ</p>
    <p>ical computer program, the native code will have to be</p>
    <p>disassembled into mnemonics and then transformed to</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>Inferring device types  Will not always be possible to learn devices from</p>
    <p>PROFIBUS, PROFINET, etc.</p>
    <p>However, if the class of plant under attack is known, certain domain specific invariants will link variables of interest.</p>
    <p>For example:</p>
    <p>A time delay of a few seconds is enforced before a motor can reverse directions.</p>
    <p>Electrical substation switchgear state changes must be executed in specific orders.</p>
    <p>Of course, this requires that the adversary have some domain specific knowledge of the target, but no target specific knowledge is needed.</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>Safety interlocks  Safety interlocks are invariants over the outputs of a</p>
    <p>control system that must never be violated</p>
    <p>Pedestrian crossing interlock:</p>
    <p>Let and be the Boolean variables for the pedestrian green light and the traffic green light respectively</p>
    <p>Regardless of the particulars of the light scheme, the following must hold:</p>
    <p>May be explicit: The property is stated as a check in the logic</p>
    <p>Or implicit: The property is never violated by the logic</p>
    <p>pg tg</p>
    <p>(pg  tg)</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>Exploiting safety interlocks  To exploit a safety interlock, the malware must</p>
    <p>1. Extract the interlock</p>
    <p>2. Find an assignment to some subset of that violates the interlock</p>
    <p>3. Send that assignment to the plant</p>
    <p>Extracting explicit interlocks requires finding the set:</p>
    <p>Extracting implicit interlocks requires verification techniques</p>
    <p>Thus, rewriting logic to contain only implicit interlocks can make interlock exploitation harder</p>
    <p>O</p>
    <p>{(y  )   | y  O and Var()  O = }</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>Inferring process structure  Some processes tend to be more event-driven</p>
    <p>while others are more logic-driven.</p>
    <p>The latter is most common in manufacturing, traffic control, and sequence control applications.</p>
    <p>For logic-driven processes, extracting the main loop can be useful for a number of things:</p>
    <p>Determining where to hook malicious code</p>
    <p>Finding terminal states, especially those that depend only on outputs. (These are indicative of alarm conditions.)</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>Process dependency graph  Data dependency graph for</p>
    <p>logic variables.</p>
    <p>Only the class of a variable is known (input, output, state, or timer).</p>
    <p>In this example (traffic light system):</p>
    <p>The main timing loop can be seen.</p>
    <p>o6 (alarm condition) is interlocked to o4 and o1 (conflicting green lights).</p>
    <p>o0</p>
    <p>t2</p>
    <p>c0</p>
    <p>c1</p>
    <p>c6</p>
    <p>i0</p>
    <p>i1</p>
    <p>t1</p>
    <p>o1</p>
    <p>i2</p>
    <p>i3</p>
    <p>t5</p>
    <p>c3</p>
    <p>o2</p>
    <p>t0</p>
    <p>c7</p>
    <p>c5</p>
    <p>o4</p>
    <p>t4</p>
    <p>t3</p>
    <p>o3</p>
    <p>o6</p>
    <p>o5</p>
    <p>c2</p>
    <p>c4</p>
    <p>Figure 3: Dependency graph for traffic light control.</p>
    <p>to differentiate between the problem of verifying a prop</p>
    <p>erty and finding one. Even if the verification problem is</p>
    <p>tractable, the search space of possible properties can be</p>
    <p>quite large. Because the verification procedure can be</p>
    <p>quite difficult in practice, most safety properties are ex</p>
    <p>plicitly encoded in the process. Though it is worth not</p>
    <p>ing that an equivalent rewriting of a process that contains</p>
    <p>only implicit properties could be an effective measure to</p>
    <p>thwart some dynamic malware payloads.</p>
    <p>Inferring Plant Structure and Purpose. Before delivering a payload, PLC malware may want to test that the</p>
    <p>plant is of a specific class. Causing anomalous but harm</p>
    <p>less behavior due to misunderstanding of the purpose of</p>
    <p>the plant is likely to cause suspicion. The plant structure</p>
    <p>refers to the relationships (e.g. dependencies) between</p>
    <p>plant devices. One tool for achieving this is the depen</p>
    <p>dency graph. Much like dependency graphs are used to</p>
    <p>statically find flows between variables in programs, they</p>
    <p>can be used to identify the flow of work between devices</p>
    <p>in a plant. Questions that a dependency graph can an</p>
    <p>swer include which sensor inputs affect which devices,</p>
    <p>and the ordering of devices in the process sequence of</p>
    <p>events.</p>
    <p>An example of a process dependency graph for a full</p>
    <p>featured traffic light control system (taken from [19]) is</p>
    <p>shown in Figure 3. We assume that it is only known if</p>
    <p>a variable is an input, output, state, or timer, labeled as</p>
    <p>in, on, cn, and tn respectively. There are at least two items of interest in the dependency graph. First, the six</p>
    <p>timers form a cycle, indicating that the process follows</p>
    <p>a set sequence of events in repetition. This means that</p>
    <p>the process is inherently sequential in nature as opposed</p>
    <p>to event driven. Second, the output variable o6 (top) de</p>
    <p>pends on two other output variables, o1 and o4, and is</p>
    <p>not a dependency for any other variable. This suggests</p>
    <p>that o6 is interlocked into o1 and o4 as a terminal condi</p>
    <p>tion in the process. Indeed, inspection of the ladder logic</p>
    <p>reveals that o6 triggers an alarm condition when the two</p>
    <p>opposing green lights controlled by o1 and o4 are simul</p>
    <p>taneously active. Thus, the assignment (o1  1, o4  1, o6  0) will cause an unsafe state in the plant by disabling the alert signal when the green lights are conflict</p>
    <p>ing. We have found that this same pattern reveals alarm</p>
    <p>states in ladder logic programs for industrial processes.</p>
    <p>Compiling The Payload. The malicious payload is a piece of control logic that ultimately assigns values to</p>
    <p>output variables in order to disrupt proper plant behavior</p>
    <p>as described by the adversarial goal. In the absence of a</p>
    <p>specific goal, a measure such as violating all safety in</p>
    <p>terlocks may also prove destructive. If the goal contains</p>
    <p>assignments to devices for which no variables have been</p>
    <p>discovered or inferred, then a payload cannot be com</p>
    <p>piled. Otherwise, a set of Boolean assignments is cre</p>
    <p>ated, and assembled back into the PLCs native format.</p>
    <p>(The format libraries for this step are available from most</p>
    <p>vendors.) As was the case with Stuxnet, the malicious</p>
    <p>assignment may be embedded within the valid logic to</p>
    <p>remain stealthy for some time before executing.</p>
    <p>ploit discovery and execution. Penetration testing frame</p>
    <p>works such as Metasploit [14] and Canvas [2] use collec</p>
    <p>tions of known exploits to test the vulnerability of entire</p>
    <p>networks. Increasingly, these frameworks and tools are</p>
    <p>becoming applicable to process control systems. For ex</p>
    <p>ample, The White Phosphorus and SCADA+ extension</p>
    <p>to the Canvas framework contain modules specifically</p>
    <p>for attacking SCADA networks [13]. Additionally, re</p>
    <p>searchers have consistently identified vulnerabilities in</p>
    <p>SCADA systems. One study found over the course of ten</p>
    <p>years that SCADA systems exhibit all of the vulnerabili</p>
    <p>ties found in IT systems ranging from arbitrary code exe</p>
    <p>cution, to cross site scripting, and denial of service [16].</p>
    <p>Just as recently, a researcher released exploits for 34 new</p>
    <p>vulnerabilities in popular SCADA products [22].</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>Summary  The individual tasks needed for constructing dynamic</p>
    <p>malware payloads seem feasible.</p>
    <p>Arguably, the hardest and most expensive task is the collection of disassemblers and device databases.</p>
    <p>Plants can be forced to behave unsafely even if no device information is available.</p>
    <p>Malware authors can leverage existing program analysis techniques like dependency graphs to design dynamic payload mechanisms.</p>
    <p>We are looking for test cases! 22</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
  <div class="page">
    <p>Thanks!</p>
    <p>smclaugh@cse.psu.edu</p>
    <p>Wednesday, August 10, 2011</p>
  </div>
</Presentation>
