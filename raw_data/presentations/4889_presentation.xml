<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>On Spatial-Range Closest Pair Query</p>
    <p>Jing Shan, Donghui Zhang and Betty Salzberg</p>
    <p>College of Computer and Information Science Northeastern University</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Problem Definition  Straightforward Approach  Existing Technique  Our Method  Performance</p>
  </div>
  <div class="page">
    <p>Problem Definition  Given a spatial data set S, the Range Closest Pair query</p>
    <p>regarding a spatial range R finds a pair of objects (s1, s2) with s1 and s2  R such that the distance between s1 and s2 is the smallest distance between two objects inside range R.</p>
    <p>a b c</p>
    <p>g</p>
    <p>d</p>
    <p>h i</p>
    <p>f e</p>
    <p>j</p>
    <p>Query result is (e, f).</p>
    <p>R</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Problem Definition</p>
    <p>Straightforward Approach  Existing Technique  Our Method  Performance</p>
  </div>
  <div class="page">
    <p>Straightforward Approach</p>
    <p>We could do nested-loop;  Or better approaches e.g. plane sweep with Voronoi diagram method</p>
    <p>is O(n log n).</p>
    <p>Problems: Have to access all data pages of R-tree which intersect the query range. Query range data may not fit in memory</p>
  </div>
  <div class="page">
    <p>Note on Existing Techniques</p>
    <p>[Hjaltason and Samet 98]: incremental join.  [Corral, Manolopoulos, Theodoridis and Vassilakopoulos 00]: an</p>
    <p>improved version, using pruning.  They addressed a slightly different problem:</p>
    <p>No query range.  Joining two different R-trees.</p>
    <p>Existing techniques do not perform well if there is overlap between the two R-trees. In case the two R-trees are identical, there is extensive overlap.</p>
  </div>
  <div class="page">
    <p>MinDist</p>
    <p>Given two MBRs A, B of R-tree nodes, MinDist(A, B) is the smallest distance between A and B boundaries.</p>
    <p>object o1  A and o2  B, distance(o1, o2)  MinDist(A, B).</p>
    <p>MinDist</p>
    <p>A B</p>
  </div>
  <div class="page">
    <p>Existing Technique</p>
    <p>For every child entry se1 in Node(e1) and child entry se2 in Node(e2)</p>
    <p>If MinDist(se1, se2)&lt;T, push (se1, se2) into Q.</p>
    <p>For every object o1 in Node(e1) and object o2 in Node(e2)</p>
    <p>If distance(o1, o2)&lt;T, update T=distance(o1,o2) and closestpair=(o1,o2) and remove pairs from Q with MinDist no smaller than T.</p>
  </div>
  <div class="page">
    <p>a b c</p>
    <p>g</p>
    <p>d</p>
    <p>h i</p>
    <p>f e</p>
    <p>Example</p>
    <p>A</p>
    <p>B</p>
    <p>C D</p>
    <p>a,b f,i c,e,g d,h</p>
    <p>A B C D</p>
    <p>R</p>
    <p>(R,R)</p>
    <p>T = ; closestpair=NULL</p>
    <p>(A,A) (B,B) (C,C) (D,D) (A,C) (B,C) (A,B) (C,D) (A,D) (B,D)</p>
  </div>
  <div class="page">
    <p>a b c</p>
    <p>g</p>
    <p>d</p>
    <p>h i</p>
    <p>f e</p>
    <p>Example</p>
    <p>A</p>
    <p>B</p>
    <p>C D</p>
    <p>a,b f,i c,e,g d,h</p>
    <p>A B C D</p>
    <p>R</p>
    <p>(R,R)</p>
    <p>T = distance(a, b); closestpair=(a, b)</p>
    <p>(A,A) (B,B) (C,C) (D,D) (A,C) (B,C) (A,B) (C,D) (A,D) (B,D)</p>
  </div>
  <div class="page">
    <p>a b c</p>
    <p>g</p>
    <p>d</p>
    <p>h i</p>
    <p>f e</p>
    <p>Example</p>
    <p>A</p>
    <p>B</p>
    <p>C D</p>
    <p>a,b f,i c,e,g d,h</p>
    <p>A B C D</p>
    <p>R</p>
    <p>(R,R)</p>
    <p>T = distance(f, e); closestpair=(f, e)</p>
    <p>(A,A) (B,B) (C,C) (D,D) (A,C) (B,C) (A,B) (C,D) (A,D) (B,D)</p>
  </div>
  <div class="page">
    <p>MinExistDist</p>
    <p>MinDist</p>
    <p>MinExistDist</p>
    <p>A B</p>
    <p>Given two MBRs A, B of R-tree nodes, MinExistDist(A, B) is the minimum distance which guarantees that there exists a pair of objects, one in A and the other in B, with distance closer than the metric.</p>
    <p>object o1  A and o2  B, distance(o1, o2)  MinExistDist(A, B).  Usage [CMT+00]: if MinExistDist(A, B) is smaller than T, update T. This</p>
    <p>can increase the chance of eliminating pairs from Q at early time.</p>
  </div>
  <div class="page">
    <p>Involving a Query Range</p>
    <p>MinDist</p>
    <p>MinExistDist =</p>
    <p>MinDist</p>
    <p>MinExistDist</p>
    <p>We extend the MinExistDist</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Problem Definition  Straightforward Approach  Existing Technique</p>
    <p>Our Method  Performance</p>
  </div>
  <div class="page">
    <p>Motivation for Our Method</p>
    <p>The existing technique joins all self-pairs, e.g. (A,A), (B,B),   Reason: the MinDist of any self pair is 0.  Challenge: is it possible to make it non-zero?</p>
    <p>If MinDist(A,A)  T, no need to process (A,A) !</p>
    <p>We propose two ways to augment the R-tree with additional information. We call the augmented structures the Self-Range Closest-Pair Tree. In short, SRCP-tree.</p>
  </div>
  <div class="page">
    <p>SRCP-tree (version 1)</p>
    <p>Along with each index entry, store the closest pair of objects in the subtree.</p>
    <p>Check the closest pair stored along with the root entry. If both objects are inside the query range R, return.</p>
    <p>Along with each self pair to be pushed into Q, use the distance of the local closest pair (rather than 0) as the MinDist.</p>
    <p>If we encounter an index entry where both objects in the closest pair are inside R, compare their distance with T. May decrease T.</p>
  </div>
  <div class="page">
    <p>Insertion</p>
    <p>When a new object o is inserted, only need to update the augmented information along the insertion path. (But need to visit subtrees.)</p>
    <p>o</p>
    <p>At each such entry, let the original local closest pair be (a,b). Needs to updated only if distance(o, o) &lt; distance (a,b) for some object o in the sub-tree.</p>
    <p>(a,b)</p>
    <p>distance (a,b)</p>
    <p>o</p>
  </div>
  <div class="page">
    <p>SRCP-tree (version 2)</p>
    <p>Idea: while version 1 tries to avoid processing self pairs, version 2 of the structure tries to avoid processing sibling pairs.</p>
    <p>E.g. if R has children A, B, C, D, version 1 cannot avoid pair (A,B), unless MinDist(A,B)  T. Similarly, it has to process (A,C), (A,D), (B,C), (B,D), (C,D).</p>
    <p>In version 2, every index entry e stores the local-parent closest pair: the closest pair between an object in the sub-tree pointed by e and an object in the sub-tree pointed by Parent(e).</p>
    <p>E.g. along with A, we store the closest pair of objects (o1, o2), where o1 is in subtree(A) and o2 is in subtree(R).</p>
    <p>Now, if the distance of object pair stored at A is no smaller than T, no need to process any pair involving A. Namely, (A,A), (A,B), (A,C), (A,D).</p>
  </div>
  <div class="page">
    <p>Performance</p>
    <p>Dell Pentium 4, 2.66GHz CPU  XXL library, Java  Both synthetic and real data:</p>
    <p>uniform data (80,000 objects)  US National Mapping Information (26,700 Massachusetts sites)</p>
    <p>URL = http://mappings. usgs.gov/www/gnis/  Focus on query time.</p>
  </div>
  <div class="page">
    <p>Small Query Range</p>
    <p>Incremental Join</p>
    <p>SRCPV1</p>
    <p>SRCPV2</p>
    <p>query range percentage</p>
    <p>tim e</p>
    <p>( m</p>
    <p>s )</p>
  </div>
  <div class="page">
    <p>Large Query Range</p>
    <p>Incremental Join</p>
    <p>SRCPV1</p>
    <p>SRCPV2</p>
    <p>query range percentage</p>
    <p>tim e</p>
    <p>( m</p>
    <p>s )</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>We have addressed the spatial closest pair query with query range.  We have proposed two versions of an index structure called SRCP-tree.  Our approaches have much better query performance than the existing</p>
    <p>techniques, especially when the query range is large.  In particular, version 2 of the SRCP-tree is universally the best.</p>
  </div>
</Presentation>
