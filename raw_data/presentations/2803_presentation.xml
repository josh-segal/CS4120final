<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Efficient Algorithms for Renewable Energy Allocation to Delay Tolerant Consumers</p>
    <p>Michael J. Neely , Arash Saber Tehrani , Alexandros G. Dimakis University of Southern California</p>
    <p>*Paper to appear at: 1st IEEE International Conf. on Smart Grid Communications, 2010 PDF on Stochastic Network Optimization Homepage: http://ee.usc.edu/stochastic-nets/</p>
    <p>*Sponsored in part by the NSF Career CCF-0747525</p>
    <p>energy requests a(t)</p>
    <p>s(t)</p>
    <p>x(t)</p>
    <p>renewable source</p>
    <p>non-renewable source</p>
  </div>
  <div class="page">
    <p>energy requests a(t)</p>
    <p>s(t)</p>
    <p>renewable source</p>
    <p>non-renewable source</p>
    <p>Renewable sources of energy can have variable and unpredictable supplies s(t). We can integrate renewable sources more easily if consumers tolerate service within some maximum allowable delay Dmax. Might sometimes need to purchase energy from nonrenewable source to meet the deadlines, and purchase price can be highly variable.</p>
  </div>
  <div class="page">
    <p>Example Data: (Top Row) Spot Market Price (Bottom Row) Energy Production in a California Wind Turbine</p>
    <p>El ec</p>
    <p>tr ic</p>
    <p>it y</p>
    <p>Pr ic</p>
    <p>e ($</p>
    <p>) En</p>
    <p>er gy</p>
    <p>P ro</p>
    <p>du cti</p>
    <p>on</p>
    <p>(M W</p>
    <p>/h )</p>
  </div>
  <div class="page">
    <p>First Problem: Minimize time average cost of purchasing non-renewable energy (i.i.d. case)</p>
    <p>Second Problem: Joint pricing of customers and purchasing of non-renewables (i.i.d. case).</p>
    <p>Generalize to arbitrary sample paths using Universal Scheduling Theory of Lyapunov Optimization.</p>
    <p>Simulation results using CAISO spot market prices (t) and 10-minute energy production s(t) from Western Wind resources Dataset (from National Renewable Energy Lab).</p>
    <p>Talk Outline:</p>
    <p>a(t) s(t)</p>
    <p>Renewable source</p>
    <p>Non-Renewable sourcex(t), (t)</p>
  </div>
  <div class="page">
    <p>Slotted Time: t = {0, 1, 2, } a(t) = energy requests on slot t (serve with max delay Dmax). s(t) = renewable energy supply on slot t. (use-it-or-loose-it) x(t) = amount non-renewable energy purchased on slot t. (t) = $$/unit energy price of non-renewables on slot t. Q(t) = Energy request queue</p>
    <p>Problem 1: Minimize Average Cost of Non-Renewable Purchases</p>
    <p>Q(t+1) = max[Q(t)  s(t)  x(t), 0] + a(t) , cost(t) = x(t)(t)</p>
    <p>Renewable supply (random) (use-it-or-loose-it)</p>
    <p>Non-Renewables purchased (decision variable)</p>
    <p>purchase price (random)</p>
    <p>a(t) s(t)</p>
    <p>Renewable source</p>
    <p>Non-Renewable sourcex(t), (t)</p>
    <p>requests (random)</p>
  </div>
  <div class="page">
    <p>Problem 1: Minimize Average Cost of Non-Renewable Purchases</p>
    <p>Q(t+1) = max[Q(t)  s(t)  x(t), 0] + a(t) , cost(t) = x(t)(t)</p>
    <p>a(t) s(t)</p>
    <p>Renewable source</p>
    <p>Non-Renewable sourcex(t), (t)</p>
    <p>Assumptions:  For all slots t we have: 0  a(t)  amax , 0  s(t)  smax , 0  (t)  max , 0  x(t)  xmax</p>
    <p>xmax units of energy always available for purchase from non-renewable (but at variable price (t)).</p>
    <p>amax  xmax (possible to meet all demands in 1 slot at high cost)</p>
    <p>(a(t), s(t), (t)) vector is i.i.d. over slots with unknown distribution</p>
  </div>
  <div class="page">
    <p>Problem 1: Minimize Average Cost of Non-Renewable Purchases</p>
    <p>Q(t+1) = max[Q(t)  s(t)  x(t), 0] + a(t) , cost(t) = x(t)(t)</p>
    <p>Possible formulation via Dynamic Programming (DP):</p>
    <p>Minimize average cost subject to max-delay Dmax.</p>
    <p>This can be written as a DP, but requires distribution knowledge.  Recent work on delay tolerant electricity consumers using DP is: [Papavasiliou and Oren, 2010]</p>
    <p>We will not use DP. We will take a different approach...</p>
  </div>
  <div class="page">
    <p>Problem 1: Minimize Average Cost of Non-Renewable Purchases</p>
    <p>Q(t+1) = max[Q(t)  s(t)  x(t), 0] + a(t) , cost(t) = x(t)(t)</p>
    <p>Relaxed Formulation via Lyapunov Optimization for Queue Networks:</p>
    <p>Minimize: E{cost} (time average) Subject to: (1) E{Q} &lt; infinity (a queue stability constraint) (2) 0  x(t)  xmax for all t</p>
    <p>Define cost* = min cost subject to stability By definition: cost*  cost delivered by any other alg (including DP) We will get within O() of cost*, with worst-case delay of 1/.</p>
    <p>Worst Case Delay</p>
    <p>Avg. Cost</p>
    <p>cost*</p>
    <p>our performance optimal DP</p>
    <p>()</p>
  </div>
  <div class="page">
    <p>Advantages of Lyapunov Optimization for Queueing Networks: No knowledge of distribution information is required.</p>
    <p>Explicit [O(), O(1/)] performance guarantees.</p>
    <p>Robust to changes in statistics, arbitrary correlations, nonergodic, arbitrary sample paths (as we will show in this work).</p>
    <p>Worst case delay bounds (as we will show in this work).</p>
    <p>No curse of dimensionality: Implementation is just as easy in extended formulations with many dimensions:</p>
    <p>Minimize : E{y} Subject to: (1) E{xi}  0 for all i in {1, , N} (2) Queue k is stable for all k in {1, , K} (3) Control action on slot t in ActionSpace(t) (for all t in {0, 1, 2, } )</p>
    <p>General Lyapunov Optimization Problem: [Georgiadis, Neely, Tassiulas, F&amp;T 2006]</p>
  </div>
  <div class="page">
    <p>Virtual Queue for Worst-Case Delay Guarantee (fix &gt;0):</p>
    <p>Z(t)</p>
    <p>Q(t)a(t) s(t)+x(t)</p>
    <p>s(t)+x(t)1{Q(t)&gt;0}</p>
    <p>Actual Queue</p>
    <p>Virtual Queue (enforces -persistent service)</p>
    <p>Theorem: Any algorithm with bounded queues Q(t)  Qmax, Z(t) Zmax for all t yields worst-case delay of:</p>
    <p>Dmax = Qmax + Zmax</p>
    <p>Z(t+1) = max[Z(t)  s(t)  x(t) + 1{Q(t)&gt;0}, 0]</p>
    <p>slots</p>
    <p>Proof Sketch: Suppose not. Consider slot t, a(t):</p>
    <p>a(t)</p>
    <p>tQ (t</p>
    <p>)  Q</p>
    <p>m ax</p>
    <p>t+Dmax</p>
    <p>=t</p>
    <p>t +Dmax [s()+x()]  Qmax</p>
    <p>Implies: Z(t+Dmax) &gt; Zmax (contradiction)</p>
    <p>Then:</p>
  </div>
  <div class="page">
    <p>Stabilize Z(t) and Q(t) while minimizing average cost cost(t):</p>
    <p>Lyapunov Function: L(t) = Z(t)2 + Q(t)2</p>
    <p>Lyapunov Drift: (t) = E{L(t+1)  L(t)|Z(t), Q(t)}</p>
    <p>Take actions to greedily minimize Drift-Plus-Weighted-Penalty:</p>
    <p>Minimize: (t) + V(t)x(t)</p>
    <p>where V is a postiive constant that affects the [O(1/V), O(V)] Cost-delay tradeoff.</p>
    <p>(using V=1/ recovers the [O(), O(1/)] tradeoff.)</p>
    <p>Q(t)</p>
    <p>Z(t)</p>
  </div>
  <div class="page">
    <p>Resulting Algorithm: Every slot t, observe (Z(t), Q(t), (t)). Then:</p>
    <p>Choose x(t) = { 0 , if Q(t) + Z(t)  V(t) { xmax, if Q(t) + Z(t) &gt; V(t)</p>
    <p>Update virtual queues Q(t) and Z(t) according to their equations</p>
    <p>Define: Qmax = Vmax + amax , Zmax = Vmax +</p>
    <p>Theorem: Under the above algorithm: (a) Q(t)  Qmax, Z(t)  Zmax for all t. (b) Delay  (Qmax + Zmax)/ = O(V)</p>
    <p>Further, if (s(t), a(t), (t)) i.i.d. over slots, and if  max[E{a(t)}, E{s(t)}] Then: E{cost}  cost* + B/V [where B = (smax + xmax)</p>
  </div>
  <div class="page">
    <p>Same system model, with following extensions: a(t) = arrivals = Random function of pricing decision p(t) h(t) = additional demand state (e.g. HIGH, MED, LOW) E{a(t)|p(t), h(t), (t)} = F(p(t), h(t), (t)) = Demand Function</p>
    <p>E{a(t)} = F(p(t), y(t), (t))</p>
    <p>s(t) Renewable source</p>
    <p>Non-Renewable sourcex(t), (t)</p>
    <p>p(t)</p>
    <p>Example:</p>
    <p>F (p</p>
    <p>(t ),</p>
    <p>h (t</p>
    <p>),</p>
    <p>(t ))</p>
    <p>price p(t) (t)</p>
    <p>h(t) = HIGH</p>
    <p>h(t) = MED</p>
    <p>h(t) = LOW</p>
    <p>D em</p>
    <p>an d</p>
    <p>Fu nc</p>
    <p>ti on</p>
    <p>Problem 2: Joint Pricing and Energy Allocation</p>
  </div>
  <div class="page">
    <p>Same system model, with following extensions: a(t) = arrivals = Random function of pricing decision p(t) h(t) = additional demand state (e.g. HIGH, MED, LOW) E{a(t)|p(t), h(t), (t)} = F(p(t), h(t), (t)) = Demand Function</p>
    <p>E{a(t)} = F(p(t), y(t), (t))</p>
    <p>s(t) Renewable source</p>
    <p>Non-Renewable sourcex(t), (t)</p>
    <p>p(t)</p>
    <p>New Problem:  Profit(t) = a(t)p(t)  x(t)(t)</p>
    <p>Maximize Time Average Profit!</p>
    <p>Profit* = Optimal Time Avg. Profit Subject to Stability</p>
    <p>Problem 2: Joint Pricing and Energy Allocation</p>
  </div>
  <div class="page">
    <p>Problem 2: Joint Pricing and Energy Allocation E{a(t)} = F(p(t), h(t), (t))</p>
    <p>s(t) Renewable source</p>
    <p>Non-Renewable sourcex(t), (t)</p>
    <p>p(t)</p>
    <p>(t)  VE{Profit(t)|Z(t),Q(t)} = (t)  VE{a(t)p(t)  x(t)(t)|Z(t),Q(t)}</p>
    <p>Every slot t, observe (h(t), Z(t), Q(t),(t)). Then: (Pricing) Choose p(t) in [0, pmax] to solve:</p>
    <p>Maximize: F(p(t),h(t),(t))(Vp(t)  Q(t)) Subject to: 0  p(t)  pmax</p>
    <p>(Purchasing) Choose x(t) same as before. Update queues Q(t), Z(t) same as before.</p>
    <p>Drift-Plus-Penalty for New Problem:</p>
    <p>Resulting Algorithm:</p>
  </div>
  <div class="page">
    <p>E{a(t)} = F(p(t), h(t), (t))</p>
    <p>s(t) Renewable source</p>
    <p>Non-Renewable sourcex(t), (t)</p>
    <p>p(t)</p>
    <p>(t)  VE{Profit(t)|Z(t),Q(t)} = (t)  VE{a(t)p(t)  x(t)(t)|Z(t),Q(t)}</p>
    <p>Every slot t, observe (h(t), Z(t), Q(t),(t)). Then: (Pricing) Choose p(t) in [0, pmax] to solve:</p>
    <p>Maximize: F(p(t),h(t),(t))(Vp(t)  Q(t)) Subject to: 0  p(t)  pmax</p>
    <p>(Purchasing) Choose x(t) same as before. Update queues Q(t), Z(t) same as before.</p>
    <p>*If F(p,h,) = (h)G(p,), dont need to know demand state h(t)!</p>
    <p>Drift-Plus-Penalty for New Problem:</p>
    <p>Resulting Algorithm:</p>
    <p>Problem 2: Joint Pricing and Energy Allocation</p>
  </div>
  <div class="page">
    <p>E{a(t)} = F(p(t), h(t), (t))</p>
    <p>s(t) Renewable source</p>
    <p>Non-Renewable sourcex(t), (t)</p>
    <p>p(t)</p>
    <p>(t)  VE{Profit(t)|Z(t),Q(t)} = (t)  VE{a(t)p(t)  x(t)(t)|Z(t),Q(t)}</p>
    <p>Every slot t, observe (h(t), Z(t), Q(t),(t)). Then: (Pricing) Choose p(t) in [0, pmax] to solve:</p>
    <p>Maximize: (h(t))G(p(t),(t))(Vp(t)  Q(t)) Subject to: 0  p(t)  pmax</p>
    <p>(Purchasing) Choose x(t) same as before. Update queues Q(t), Z(t) same as before.</p>
    <p>*If F(p,h,) = (h)G(p,), dont need to know demand state h(t)!</p>
    <p>Drift-Plus-Penalty for New Problem:</p>
    <p>Resulting Algorithm:</p>
    <p>Problem 2: Joint Pricing and Energy Allocation</p>
  </div>
  <div class="page">
    <p>E{a(t)} = F(p(t), h(t), (t))</p>
    <p>s(t) Renewable source</p>
    <p>Non-Renewable sourcex(t), (t)</p>
    <p>p(t)</p>
    <p>Theorem: Under the joint pricing and energy allocation algorithm:</p>
    <p>(a) Worst case queue bounds Qmax, Zmax same as before.</p>
    <p>(b) Worst case delay bound Dmax same as before, i.e., O(V).</p>
    <p>(c) If (s(t), (t), h(t)) i.i.d. over slots, and   E{s(t)}, then:</p>
    <p>E{profit}  profit* - O(1/V)</p>
    <p>Problem 2: Joint Pricing and Energy Allocation</p>
  </div>
  <div class="page">
    <p>Universal Scheduling for Arbitrary Sample Paths</p>
    <p>Consider the first problem again (x(t) = only decision variable): Suppose (s(t), (t), a(t)) have arbitrary sample path! (assume they are still bounded: [0, smax], [0, max], [0, amax].)</p>
    <p>Universal Scheduling Theorem: (a) Worst case queue bounds Qmax, Zmax same as before. (b) Worst case delay bound Dmax same as before, i.e., O(V). (c) For any integers T&gt;0, R&gt;0:</p>
    <p>a(t) s(t)</p>
    <p>Renewable source</p>
    <p>Non-Renewable sourcex(t), (t)</p>
    <p>x(t)(t)  t=0</p>
    <p>RT-1</p>
    <p>RT 1</p>
    <p>R 1</p>
    <p>r=0</p>
    <p>R-1</p>
    <p>Cr* + BT/V</p>
    <p>Genie-Aided T-Slot Lookahead Cost!</p>
  </div>
  <div class="page">
    <p>x(t)(t)  t=0</p>
    <p>RT-1</p>
    <p>RT 1</p>
    <p>R 1</p>
    <p>r=0</p>
    <p>R-1</p>
    <p>Cr* + BT/V For every R&gt;0, T&gt;0:</p>
    <p>R frames of size T slots:</p>
    <p>Frame 1 Frame 2 Frame 3  Frame R T-Slot Lookahead Problem for frame r in {0, , R-1}: cr* computed below, assuming future values of (a(), s(), ()) are fully known in frame r:</p>
  </div>
  <div class="page">
    <p>Simulations over Real Data Sets: We used 10 minute slot sizes (granularity of the available data) Compare to simple Purchase at Deadline algorithm. We chose V=100  Dmax = 400 slots (70 hours)</p>
  </div>
  <div class="page">
    <p>Same experiment: Histogram of Delay (V=100, = 87.5): Our algorithm yields worst-case delay considerably less than the bound Dmax. Worst case observed delay was 60 slots (10 hours)</p>
  </div>
  <div class="page">
    <p>Some more simulations: Changing the  parameter:</p>
  </div>
  <div class="page">
    <p>Some more simulations: Changing the V parameter:</p>
  </div>
  <div class="page">
    <p>Concluding Slide:</p>
    <p>a(t) s(t)</p>
    <p>Renewable source</p>
    <p>Non-Renewable sourcex(t), (t)</p>
    <p>Lyapunov Optimization for Renewable Energy Allocation No need to know distribution. Robust to arbitrary sample paths. Explicit [O(1/V), O(V)] performance-delay tradeoff</p>
  </div>
  <div class="page">
    <p>Explanation of Why Delay is small even with =0</p>
    <p>=t</p>
    <p>t +T</p>
    <p>[s()+x()]  Q(t)</p>
    <p>Even with =0, we still get the same Qmax bound. (Q(t)  Qmax for all t).</p>
    <p>Delay of requests that arrive on slot t is equal to the smallest integer T such that:</p>
    <p>So delay will be less than or equal to T whenever:</p>
    <p>=t</p>
    <p>t +T</p>
    <p>s()  Qmax</p>
    <p>There is no guarantee on how long this will take for arbitrary s(t) processes, but one can compute probabilities of exceeding a certain value if we try to use a stochastic model for s(t).</p>
  </div>
</Presentation>
