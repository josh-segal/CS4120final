<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Speeding up detection of SHA-1 collision attacks using unavoidable conditions</p>
    <p>Marc Stevens - CWI Dan Shumow  Microsoft Research</p>
    <p>Usenix Security 17</p>
  </div>
  <div class="page">
    <p>Cryptanalytic attack mitigation</p>
    <p>Finding collisions for SHA-1 is now practical [SBKAM2017]  One SHA-1 collision can be reused against many targets</p>
    <p>Best practice: migrate away from broken crypto [duh]  Migration is difficult in practice.  Interoperability  Backwards compatibility  How to handle old signatures</p>
    <p>SHA-1 collisions are a potential threat for many applications  Signatures, GPG, Deduplication (SVN), Git, Content-addressed-storage,</p>
  </div>
  <div class="page">
    <p>MD5 &amp; SHA-1 collision detection</p>
    <p>Temporary solution: counter-cryptanalysis [S13].  Real-time detection of cryptanalytic collision attacks.  Repair security with drop-in strengthened MD5 &amp; SHA-1.</p>
    <p>Detects unavoidable anomalies present due to crucial attack properties  Internal zero difference at some point.  Few feasible message differences.</p>
    <p>Exposed unknown MD5 collision attack in supermalware Flame [S13,FS15].</p>
    <p>MD5 SHA-1</p>
    <p>+ coll. det.</p>
    <p>Attack?: YES/NO</p>
  </div>
  <div class="page">
    <p>MD5 &amp; SHA-1 collision attacks</p>
    <p>Collision attacks use compression function attacks.</p>
    <p>Identical prefix collision.</p>
    <p>Chosen prefix collision.</p>
  </div>
  <div class="page">
    <p>MD5 &amp; SHA-1 collision detection</p>
    <p>Detect collision block Attack class defined by:</p>
    <p>Step with zero working state difference.  Message input difference.</p>
    <p>Detects all variant attacks that use  and have zero difference at step .</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>MD5 &amp; SHA-1 collision detection</p>
    <p>Full collision detection: For each input block *:</p>
    <p>For each attack class , : Detect collision in * with , .</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>MD5 &amp; SHA-1 collision detection  Collision detection has high cost: Every attack class costs an additional hash operation.  SHA-1 is weak: 14 classes</p>
    <p>MD5 is very weak: 223 classes</p>
    <p>MD5 SHA-1</p>
    <p>+ coll. det.</p>
    <p>Attack?: YES/NO</p>
    <p>MD5 MD5</p>
    <p>+ coll. det.</p>
    <p>Attack?: YES/NO</p>
  </div>
  <div class="page">
    <p>MD5 &amp; SHA-1 collision detection</p>
    <p>Strong guarantees 1. False positives occur with negligible probability.</p>
    <p>Conjectured: 2/012 (MD5), 2/034 (SHA-1)</p>
  </div>
  <div class="page">
    <p>Improved collision detection</p>
    <p>Currently each attack class costs 1 full compression.</p>
    <p>Speed up with unavoidable bit conditions (UBC): Conditions on mesage bits that are necessary for an attack class.</p>
    <p>Verify unavoidable conditions quickly, most of the time skip full work.</p>
    <p>Find UBCs by analyzing all feasible attack variants to avoid introducing false negatives.</p>
  </div>
  <div class="page">
    <p>SHA-1 collision detection library</p>
    <p>Collision detection performance:  Original paper: MD5: 224 x (223 attack classes)  Original paper: SHA-1: 15 x (14 attack classes)  This paper: SHA-1: &lt;1.7 x (32 attack classes)</p>
    <p>Implementation of our improved algorithm available: https://github.com/cr-marcstevens/sha1collisiondetection</p>
    <p>Data + code generation tools + verification tools available: https://github.com/cr-marcstevens/sha1collisiondetection-tools</p>
    <p>Deployed:  Git+Github (Released in Git 2.13)  Gmail+Google Drive  Microsoft OneDrive</p>
  </div>
  <div class="page">
    <p>SHA-1 differential cryptanalysis</p>
    <p>Compression function  Processes 512-bit chunk of input.  Updates 160-bit chaining value (CV).  Linearly expands input to words 4,,67.  Non-linearly mixes &amp; into state in 80 rounds.</p>
    <p>F F</p>
    <p>F</p>
    <p>SHA-1 compression function</p>
    <p>CV in</p>
    <p>CV out</p>
    <p>msg in</p>
  </div>
  <div class="page">
    <p>F F</p>
    <p>F</p>
    <p>SHA-1 differential cryptanalysis</p>
    <p>Differential Path  Analyze two different instances.  Describes exact differences in state &amp; msg-input.  Last 60 steps determine most of attacks complexity.  Derive system of equations &amp; solve.</p>
    <p>SHA-1 compression function</p>
    <p>CV in</p>
    <p>CV out</p>
    <p>msg in</p>
  </div>
  <div class="page">
    <p>F F</p>
    <p>F</p>
    <p>SHA-1 differential cryptanalysis</p>
    <p>Disturbance vector (DV).  Differential path DesignPlanTM</p>
    <p>Describes combination of local collisions.  Only known way compatible with msg expansion.  Only two known feasible classes: I(K,b), II(K,b)  Zero difference at step K+9.  Determines message word XOR differences.</p>
    <p>SHA-1 compression function</p>
    <p>CV in</p>
    <p>CV out</p>
    <p>msg in</p>
  </div>
  <div class="page">
    <p>N-dim space</p>
    <p>Computing Unavoidable Bit Conditions</p>
    <p>&amp;  9:; &lt; =0 = (0,1,0,1,1,0)</p>
    <p>k-dim subspace</p>
    <p>Disturbance Vector</p>
    <p>Enumerate all possible diffpath rounds 35-64</p>
    <p>Translate into N-dim vector equation</p>
    <p>possible then  also possible</p>
    <p>vector  and G present</p>
    <p>Determine smallest enveloping affine subspace</p>
    <p>N-k linear equations &amp;,&lt;&amp;  =</p>
    <p>Compute N-k linear equations</p>
    <p>Fast to check unavoidable bit</p>
    <p>conditions for possible attack</p>
    <p>Hard part Efficient exhaustive analysis</p>
    <p>using JLCA [S13,KPS15,SKP16,SBKAM17]</p>
    <p>Easy part Basic linear algebra</p>
  </div>
  <div class="page">
    <p>SHA-1 unavoidable bit conditions</p>
    <p>(46,2): 30 2  31 7 = 1 P6 1  Q0 1 = 1 P2 6  Q0 1 = 0 Q4 6  Q0 1 = 0 P0 1  PR 1 = 1 P0 1  P1 6 = 1 R3 1  R6 6 = 1</p>
    <p>Where W[] denotes the _` bit of the _` block of expanded input.</p>
    <p>Selected the 32 DVs leading to lowest complexity attacks.</p>
    <p>Each DV has 7 to 15 UBC equations.</p>
    <p>373 total overlapping equations.</p>
  </div>
  <div class="page">
    <p>Exploiting overlapping UBCs (48,0): RQ 4  R7 29 = 0 3R 0  3P 5 = 1 P1 4  Q1 29 = 1 P1 4  Q0 29 = 1 P1 4  P7 29 = 0 P1 4  P2 4 = 1 P1 4  P6 29 = 1 P1 4  P3 4 = 0 P1 4  PP 29 = 0 P1 4  PQ 29 = 0 P1 4  PP 4 = 1 R2 4  P1 29 = 0 R2 4  P4 29 = 0 R2 4  P0 29 = 0 PP 29  PQ 29 = 0</p>
    <p>45,0 : R3 4  P4 29 = 0 P0 4  PR[29] = 0 P0 4  PP 29 = 0 P0 4  PQ 29 = 0 Q1 29  QR 29 = 0 Q4 29  QR 29 = 1 34 0  30 5 = 1 3R 1  3P 29 = 1 P6 4  QR 29 = 1 P7 29  QR 29 = 1 P7 4  QR 29 = 0 PP 29  PQ 29 = 0</p>
    <p>Example P1 4  PP 29 = 0 P1 4  PQ 29 = 0 PP 29  PQ 29 = 0</p>
    <p>P0 4  PP 29 = 0 P0 4  PQ[29] = 0 PP 29  PQ 29 = 0</p>
  </div>
  <div class="page">
    <p>Exploiting overlapping UBCs Observations:  The set of equations used to check the UBC for a given DV is not unique.  DVs may have overlapping UBCs. Question: Can we use these observations reduce the total number of equations checked? Greedy selection algorithm:</p>
    <p>completely checks the UBC for each DV. Solution: Reduces 373 UBC equations over 32 DVs to 156 unique equations, each corresponding to anywhere from 1 to 7 DVs. (all of the form: &amp;   W  = )</p>
  </div>
  <div class="page">
    <p>UBC check algorithm</p>
    <p>In our reduced set of equations, we must also keep track of all the corresponding DVs in a 32 bit mask.  If a UBC equation fails to hold, we use this to mask out potentially satisfied UBCs.  After checking all equations we are left with a 32bit word where a 1 bit corresponds to a DV with satisfied UBC.  The C-code for this optimized check is automatically generated by the implementation of our greedy selection algorithm.</p>
  </div>
  <div class="page">
    <p>SHA1 Collision Detection Implementation: Testing and Verification  Optimized UBC checking code compared against unoptimized UBC checking code.  Randomized testing: Hash many random blocks and compare the results of optimized and unoptimized code.</p>
    <p>Known Answer Tests:  Colliding SHA-1 PDFs.  Reduced-round SHA-1 collisions.  Random files (negative test.)</p>
  </div>
  <div class="page">
    <p>UBC check expected performance</p>
    <p>Given the probability that an UBC with  equations is satisfied is 2/p. We estimate that given our set of 32 DVs on average we only check 0.049 DVs per block, or one full check every 20.2 blocks.  We expect that our implementation will run about:</p>
  </div>
  <div class="page">
    <p>SHA1 Collision Detection Implementation: Performance</p>
    <p>SHA1 SHA1DC no UBC Check SHA1DC UBC Check</p>
    <p>gcc x86-64 148.14 3.75 (39.50x) 92.82 (1.60x)</p>
    <p>clang x86-64 226.60 7.58 (29.88x) 136.33 (1.66x)</p>
    <p>msvc x86-64 115.80 2.69 (42.98x) 72.23 (1.60x)</p>
    <p>msvc x86-32 83.42 2.06 (40.58x) 58.14 (1.43x)</p>
    <p>gcc arm 26.11 0.81 (32.04x) 16.30 (1.60x)</p>
    <p>Performance of SHA-1 implementation tuned against Gits previous block-sha implementation.  The performance improvement given by UBC checks made the difference between the code being</p>
    <p>deployed, such as in Git.  Pure C / No Assembler</p>
    <p>Count of 2KB message hashed per millisecond and slowdown over base operation.</p>
  </div>
  <div class="page">
    <p>SHA1 Collision Detection Library</p>
    <p>Implementation of improved algorithm available: https://github.com/cr-marcstevens/sha1collisiondetection</p>
    <p>Deployed:  Git/Github (released in Git 2.13)  Gmail/Google Drive  Microsoft OneDrive</p>
    <p>Data + code generation tools + verification tools available : https://github.com/cr-marcstevens/sha1collisiondetection-tools</p>
  </div>
  <div class="page">
    <p>Ongoing Work</p>
    <p>Constant-time/execution implementation:  Performance improvement using SIMD: SSE128, AVX256, AVX512, NEON.</p>
    <p>Assembler implementation</p>
  </div>
  <div class="page">
    <p>Thank You</p>
  </div>
</Presentation>
