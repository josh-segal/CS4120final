<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Productivity of Stream Definitions</p>
    <p>Jrg Endrullis Clemens Grabmayer Dimitri Hendriks Ariya Isihara Jan Willem Klop</p>
    <p>Vrije Universiteit Amsterdam, Universiteit Utrecht</p>
    <p>Fundamentals of Computation Theory Budapest, August 29, 2007</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Problem Streams Examples</p>
    <p>The Problem</p>
    <p>I when do we accept an infinite object defined in terms of itself? I when does a finite set of equations constructively define a unique</p>
    <p>infinite object? I when is a recursive program productive?</p>
    <p>I if it evaluates to a unique infinite constructor normal form</p>
    <p>Example</p>
    <p>zeros = 0 : zeros zeros  0 : zeros  0 : 0 : zeros    0 : 0 : 0 : . . .</p>
    <p>I other examples: infinite trees, processes, coinductive proofs, . . . I in general, productivity is undecidable</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Problem Streams Examples</p>
    <p>Streams</p>
    <p>I the set A of streams (over set A) is defined by:</p>
    <p>A := { |  : N  A}</p>
    <p>I A is the greatest fixed point of:</p>
    <p>X . A  X</p>
    <p>I : is the stream constructor symbol: a :  denotes the result of prepending a  A to   A</p>
    <p>I a recursive stream specification</p>
    <p>M = . . . M . . .</p>
    <p>is productive if the process of continuously evaluating M results in an infinite constructor normal form:</p>
    <p>M  a0 : a1 : a2 : . . .</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Problem Streams Examples</p>
    <p>Examples</p>
    <p>Example</p>
    <p>read(x :  ) = x : read( ) fast_read(x : y :  ) = x : y : fast_read( )</p>
    <p>fives = 5 : read(fives) productive fives = 5 : fast_read(fives) not productive</p>
    <p>zip(x :  , ) = x : zip(,  ) zip(x :  , y : ) = x : y : zip( , )</p>
    <p>sevens = 7 : zip(sevens, tail(sevens)) productive sevens = 7 : zip(sevens, tail(sevens)) not productive</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Problem Streams Examples</p>
    <p>Examples</p>
    <p>Example</p>
    <p>read(x :  ) = x : read( ) fast_read(x : y :  ) = x : y : fast_read( )</p>
    <p>fives = 5 : read(fives) productive fives = 5 : fast_read(fives) not productive</p>
    <p>zip(x :  , ) = x : zip(,  ) zip(x :  , y : ) = x : y : zip( , )</p>
    <p>sevens = 7 : zip(sevens, tail(sevens)) productive sevens = 7 : zip(sevens, tail(sevens)) not productive</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Problem Streams Examples</p>
    <p>Examples</p>
    <p>Example</p>
    <p>read(x :  ) = x : read( ) fast_read(x : y :  ) = x : y : fast_read( )</p>
    <p>fives = 5 : read(fives) productive fives = 5 : fast_read(fives) not productive</p>
    <p>zip(x :  , ) = x : zip(,  ) zip(x :  , y : ) = x : y : zip( , )</p>
    <p>sevens = 7 : zip(sevens, tail(sevens)) productive sevens = 7 : zip(sevens, tail(sevens)) not productive</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Problem Streams Examples</p>
    <p>Examples</p>
    <p>Example</p>
    <p>read(x :  ) = x : read( ) fast_read(x : y :  ) = x : y : fast_read( )</p>
    <p>fives = 5 : read(fives) productive fives = 5 : fast_read(fives) not productive</p>
    <p>zip(x :  , ) = x : zip(,  ) zip(x :  , y : ) = x : y : zip( , )</p>
    <p>sevens = 7 : zip(sevens, tail(sevens)) productive sevens = 7 : zip(sevens, tail(sevens)) not productive</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Stream Function Specifications Stream Constant Specifications</p>
    <p>Weakly Guarded SFSs</p>
    <p>Definition A weakly guarded stream function specification (SFS) is an orthogonal TRS T = dt ] sf ]{:}, Rdt ] Rsf  such that: I the data part dt , Rdt is strongly normalising I each rule in Rsf is of one of the forms:</p>
    <p>f((x1 : 1), . . . , (xrs : rs ), y )  t : i t : g( (1), . . . ,  (r s ), u)</p>
    <p>where  : {1, . . . , r s}  {1, . . . , rs} is an injection I on every dependency cycle f g  f there is at least one</p>
    <p>guard</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Stream Function Specifications Stream Constant Specifications</p>
    <p>Weakly Guarded SFSs</p>
    <p>Example</p>
    <p>tail(x :  )   inv(x :  )  (1  x ) : inv( )</p>
    <p>zip(x :  , )  x : zip(,  ) even(x :  )  x : odd( ) odd(x :  )  even( ) sum(x :  )  sum_aux( , x )</p>
    <p>sum_aux(y :  , x )  (x + y ) : sum_aux( , y )</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Stream Function Specifications Stream Constant Specifications</p>
    <p>Pure SCSs</p>
    <p>Definition A TRS T = dt ] sf ] sc ]{:}, Rdt ] Rsf ] Rsc is a pure stream constant specification (SCS) if:</p>
    <p>Rsc = {Mi | i  {1, . . . , n}} where Mi the defining rule for Mi :</p>
    <p>Mi  Ci [M1, . . . , Mn]</p>
    <p>where Ci an n-ary stream context in the underlying SFS</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Stream Function Specifications Stream Constant Specifications</p>
    <p>Pure SCSs</p>
    <p>Example</p>
    <p>alt  0 : 1 : alt alt  0 : inv(alt) alt  zip(zeros, ones) fib  0 : 1 : sum(fib) T  0 : zip(inv(T), tail(T)) J  0 : 1 : even(J)</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Intro Pebbleflow Nets A Rewrite System for Pebbleflow</p>
    <p>Modelling SCSs with Pebbleflow Nets</p>
    <p>I Kahn (1974): Networks are devices for computing least fixed points of systems of equations</p>
    <p>Pebbleflow Nets: I a tool for computing the degree of definedness of an SCS I stream elements are abstracted from in favour of pebbles:</p>
    <p>[t : u] = [u] I an SCS is modelled by a pebbleflow net:</p>
    <p>evaluation of an SCS is modelled by the flow of pebbles in a net I an SCS is productive if and only if the net associated to it</p>
    <p>generates an infinite chain of pebbles</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Intro Pebbleflow Nets A Rewrite System for Pebbleflow</p>
    <p>Nets</p>
    <p>I pebbleflow net: network built of pebble processing units connected by wires</p>
    <p>I wire: unidirectional FIFO communication channel with no upper bound to the number of pebbles it can store</p>
    <p>I I/O relations of processing units are functional I processing units are:</p>
    <p>I fans I boxes I meets I sources</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Intro Pebbleflow Nets A Rewrite System for Pebbleflow</p>
    <p>Fan</p>
    <p>I duplicates an incoming pebble along its output ports I explicit sharing device I enables construction of cyclic nets I used to implement recursion, in particular feedback</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Intro Pebbleflow Nets A Rewrite System for Pebbleflow</p>
    <p>Recursion/feedback</p>
    <p>N N</p>
    <p>x .N(x )    x .N(x )</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Intro Pebbleflow Nets A Rewrite System for Pebbleflow</p>
    <p>Box (I)</p>
    <p>N N</p>
    <p>+</p>
    <p>box(+, N)  box(, N)</p>
    <p>I + : a ready state for an output pebble I  : an infinite sequence over {+,}</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Intro Pebbleflow Nets A Rewrite System for Pebbleflow</p>
    <p>Box (II)</p>
    <p>N N</p>
    <p>box(,N)  box(, N)</p>
    <p>I  : a requirement for an input pebble I  : an infinite sequence over {+,}</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Intro Pebbleflow Nets A Rewrite System for Pebbleflow</p>
    <p>I/O sequences</p>
    <p>I I/O sequences contain infinitely many +s:</p>
    <p>:= {  {+,} | n. m. (n + m) = +}</p>
    <p>I    is rational if there exist ,   {+,} such that  =   =     . . . ( non-empty)</p>
    <p>I I/O sequences model quantitative behaviour of stream functions</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Intro Pebbleflow Nets A Rewrite System for Pebbleflow</p>
    <p>Unary Stream Functions to I/O sequences</p>
    <p>Example</p>
    <p>dup(x :  ) = x : x : dup( ) tail(x :  ) =</p>
    <p>even(x :  ) = x : odd( ) odd(x :  ) = even( )</p>
    <p>[dup]1 = ++[dup]1 [dup]1 = ++ [tail]1 = id [tail]1 = +</p>
    <p>[even]1 = +[odd]1 [even]1 = + [odd]1 = [even]1 [odd]1 = +</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Intro Pebbleflow Nets A Rewrite System for Pebbleflow</p>
    <p>Production Function</p>
    <p>} n</p>
    <p>(n) {</p>
    <p>(n)</p>
    <p>+</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Intro Pebbleflow Nets A Rewrite System for Pebbleflow</p>
    <p>Meet</p>
    <p>N2 N1 N2N1</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Intro Pebbleflow Nets A Rewrite System for Pebbleflow</p>
    <p>Gate</p>
    <p>rs1</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Intro Pebbleflow Nets A Rewrite System for Pebbleflow</p>
    <p>Translation of Stream Functions into Gates</p>
    <p>Example</p>
    <p>zip(x :  , ) = x : zip(,  )</p>
    <p>[zip]1 = +[zip]2 [zip]1 = ++ [zip]2 = +[zip]1 [zip]2 = ++</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Intro Pebbleflow Nets A Rewrite System for Pebbleflow</p>
    <p>Source</p>
    <p>kk + 1</p>
    <p>src(k + 1)  src(k )</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Intro Pebbleflow Nets A Rewrite System for Pebbleflow</p>
    <p>Term Representations of Nets</p>
    <p>Definition NET : set of terms for pebbleflow nets generated by:</p>
    <p>N ::= src(k ) | x | N | box(, N) |  x .N | 4(N, N)</p>
    <p>k  N {}, x  VAR,</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Intro Pebbleflow Nets A Rewrite System for Pebbleflow</p>
    <p>Pebbleflow Rewrite System</p>
    <p>Definition</p>
    <p>box(+, N)  box(, N) box(,N)  box(, N)</p>
    <p>src(k + 1)  src(k )</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Intro Pebbleflow Nets A Rewrite System for Pebbleflow</p>
    <p>Pebbleflow Tool</p>
    <p>I net visualization tool I Java applet written by Ariya Isihara, I available via: http://infinity.few.vu.nl/productivity</p>
    <p>T = 0 : zip(inv(T), tail(T)) [T] =  x .4(box(++, box(+, x )), box(++, box(+, x )))</p>
    <p>J = 0 : 1 : even(J) [J] =  x .box(+, x )</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Intro Pebbleflow Nets A Rewrite System for Pebbleflow</p>
    <p>Translation Preserves Production</p>
    <p>I for an SCS T = , R the production T(t) of a stream term t :</p>
    <p>T(t) := sup{n  N | t  s1 : . . . : sn : t}</p>
    <p>I the production (N) of a net N :</p>
    <p>(N) := sup{n  N | N P n N}</p>
    <p>Theorem</p>
    <p>([M]) = T(M)</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Net Reduction Properties of Net Reduction</p>
    <p>Net Reduction</p>
    <p>Definition</p>
    <p>N  box(++, N) box(1, box(2, N))  box(1  2, N) box(,4(N1, N2))  4(box(, N1), box(, N2))</p>
    <p>x .4(N1, N2)  4( x .N1,  x .N2)  x .N  N if x 6 FV(N)</p>
    <p>x .box(, x )  src(fix()) 4(src(k1), src(k2))  src(min(k1, k2))</p>
    <p>box(, src(k ))  src( (k ))  x .x  src(0)</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Net Reduction Properties of Net Reduction</p>
    <p>Box Composition</p>
    <p>2</p>
    <p>1  2 1 (+1)  2 = +(1  2)</p>
    <p>(1)  (+2) = 1  2 (1)  (2) = ((1)  2)</p>
    <p>Properties: I 12 = 1  2 I associative I preserves rationality I rat. rep. of 1  2 can be computed from rat. rep.s of 1 and 2</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Net Reduction Properties of Net Reduction</p>
    <p>Net Reduction Tool</p>
    <p>I net reduction tool I Haskell program written by Jrg Endrullis I available via: http://infinity.few.vu.nl/productivity</p>
    <p>T = 0 : zip(inv(T), tail(T)) J = 0 : 1 : even(J)</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Net Reduction Properties of Net Reduction</p>
    <p>Properties of Net Reduction</p>
    <p>I net reduction is production preserving:</p>
    <p>N R N implies (N) = (N)</p>
    <p>I R is terminating and confluent, hence: every closed net normalises to a unique normal form</p>
    <p>I normal forms are sources I normal forms of rational nets can be computed</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Net Reduction Properties of Net Reduction</p>
    <p>Productivity of Pure SCSs is Decidable</p>
    <p>Theorem Productivity of pure SCSs is decidable</p>
    <p>decision algorithm for stream constant M in SCS T: I translate M to the rational net [M] I reduce [M] to a source src(n) I (recall T(M) = ([M]) = n) I if n = , output: T is productive for M I if n  N, output: T is not productive for M</p>
  </div>
  <div class="page">
    <p>Introduction Stream Specifications</p>
    <p>Modelling with Nets Deciding Productivity</p>
    <p>Conclusion</p>
    <p>Conclusion</p>
    <p>I previous approaches: sufficient conditions for productivity, not automatable or only for a limited subclass</p>
    <p>I our contribution: decision algorithm for rich class of SCSs, only SFS part is restricted</p>
    <p>I current research: SFSs with pattern matching on data lower and upper data-oblivious bounds on the production relation of SFSs that facilitate computable criteria for productivity, and its complement</p>
  </div>
</Presentation>
