<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Stitching the Gadgets On the Ineffectiveness of Coarse-Grained</p>
    <p>Control-Flow Integrity Protection</p>
    <p>Lucas Davi Intel Collaborative Research Institute for Secure</p>
    <p>Computing @ TU Darmstadt, Germany</p>
    <p>Joint Work with Daniel Lehmann, Ahmad-Reza Sadeghi (TU Darmstadt)</p>
    <p>Fabian Monrose (UNC Chapel Hill)</p>
    <p>USENIX Security Symposium 2014, San Diego, CA, USA</p>
  </div>
  <div class="page">
    <p>Open Question: Practical and secure mitigation of code</p>
    <p>reuse attacks</p>
    <p>Turing-completeness of return-oriented programming</p>
  </div>
  <div class="page">
    <p>Hot Research Topic: Practical (coarse-grained) Control Flow Integrity (CFI)</p>
    <p>Recently, many solutions proposed</p>
    <p>kBouncer [USENIX Sec13]</p>
    <p>ROPecker [NDSS14]</p>
    <p>ROPGuard [Microsoft EMET]</p>
    <p>CFI for COTS Binaries</p>
    <p>[USENIX Sec13]</p>
    <p>CCFIR [IEEE S&amp;P13]</p>
    <p>MS BlueHat</p>
    <p>Prize</p>
    <p>MS BlueHat</p>
    <p>Prize</p>
    <p>http://technet.microsoft.com/ en-us/security/jj653751</p>
    <p>EMET</p>
  </div>
  <div class="page">
    <p>This Talk: Negative result  all current (published)</p>
    <p>coarse-grained CFI solutions can be bypassed</p>
  </div>
  <div class="page">
    <p>Our Contributions</p>
    <p>Systematic Security Analysis Pointing out the conceptual weaknesses of coarse-grained</p>
    <p>CFI solutions including Microsofts EMET</p>
    <p>Systematic Security Analysis</p>
    <p>Generic Attack</p>
    <p>Real World Exploits</p>
  </div>
  <div class="page">
    <p>Our Contributions</p>
    <p>Systematic Security Analysis</p>
    <p>Generic Attack</p>
    <p>Real World Exploits</p>
    <p>Our Attack is Generic Only CFI policies considered, not specific CFI solutions,</p>
    <p>bypassing even the ber-CFI that combines all CFI policies</p>
    <p>The only work showing Turing-completeness</p>
  </div>
  <div class="page">
    <p>Our Contributions</p>
    <p>Systematic Security Analysis</p>
    <p>Generic Attack</p>
    <p>Real World Exploits</p>
    <p>Concrete Attack Instantiations under Strong Adversary Model</p>
    <p>Very small code base: 840kb</p>
  </div>
  <div class="page">
    <p>ROP Adversary Model/Assumption</p>
    <p>Data Area</p>
    <p>Code Area</p>
    <p>Application Gadget Space (e.g., Shared</p>
    <p>Libraries)</p>
    <p>MEMORY Application Address Space</p>
    <p>Shared Libraries</p>
    <p>MOV</p>
    <p>ADD</p>
    <p>ESP</p>
    <p>CALL</p>
    <p>LNOP</p>
    <p>XOR</p>
    <p>LOAD</p>
    <p>STORE</p>
    <p>ROP Payload 3</p>
    <p>Adversary can construct gadgets</p>
    <p>See our JIT-ROP attack Snow et al, IEEE S&amp;P 2013 &amp;</p>
    <p>BlackHat USA 8/21/2014</p>
  </div>
  <div class="page">
    <p>Generic ROP Defense: Control-Flow Integrity (CFI)</p>
    <p>Restricting indirect control-flow targets to a pre-defined control-flow graph</p>
  </div>
  <div class="page">
    <p>Original CFI Label Checking [Abadi et al., CCS 2005 &amp; TISSEC 2009]</p>
    <p>label_A ENTRY asm_ins,  EXIT</p>
    <p>BBL A</p>
    <p>A</p>
    <p>C B</p>
    <p>label_B ENTRY asm_ins,  EXIT</p>
    <p>BBL B</p>
    <p>CFI CHECK</p>
    <p>EXIT(A) -&gt; label_B ?</p>
  </div>
  <div class="page">
    <p>Original CFI: Benefits and Limitations</p>
  </div>
  <div class="page">
    <p>Coarse-Grained CFI: Aims at practical CFI for real-world deployment</p>
  </div>
  <div class="page">
    <p>General Idea</p>
    <p>Reducing number of</p>
    <p>labels</p>
  </div>
  <div class="page">
    <p>Coarse-Grained CFI Proposals</p>
    <p>Last Branch Record (LBR)</p>
    <p>Win API / Critical Function</p>
    <p>Application</p>
    <p>POP PUSH</p>
    <p>Stack</p>
    <p>kBouncer [USENIX Sec13]</p>
    <p>ROPecker [NDSS14]</p>
    <p>ROPGuard [Microsoft EMET]</p>
    <p>H O</p>
    <p>O K</p>
    <p>Paging</p>
    <p>H O</p>
    <p>O K</p>
    <p>Binary Instrumentation</p>
    <p>CFI for COTS Binaries</p>
    <p>[USENIX Sec13]</p>
    <p>CCFIR [IEEE S&amp;P13]</p>
  </div>
  <div class="page">
    <p>Main Coarse-Grained CFI Policies</p>
    <p>CFI Policy 1: Call-Preceded Sequences</p>
    <p>Returns need to target a callpreceded instruction</p>
    <p>CFI Policy 2: BehavioralBased Heuristics</p>
    <p>Prohibit a chain of N short sequences each consisting of less than S instructions</p>
    <p>Application</p>
    <p>CALL A</p>
    <p>asm_ins</p>
    <p>asm_ins</p>
    <p>CALL B</p>
    <p>asm_ins</p>
    <p>CALL C</p>
    <p>asm_ins</p>
    <p>RET</p>
    <p>&gt; S</p>
    <p>&lt; S</p>
    <p>&lt; S &lt; S &lt; S</p>
    <p>Threshold Setting kBouncer: (N=8; S&lt;=20) ROPecker: (N=11; S&lt;=6)</p>
  </div>
  <div class="page">
    <p>Most Restrictive Coarse-Grained CFI</p>
    <p>CFI Policy kBouncer ROPecker ROPGuard EMET</p>
    <p>CFI for COTS Binaries</p>
    <p>ber-CFI</p>
    <p>CFI Policy 1 Call-Preceded Sequences</p>
    <p>CFI Policy 2 Behavioral-Based Heuristics</p>
    <p>Time of CFI Check WinAPI 2 Pages Sliding</p>
    <p>Window / Critical</p>
    <p>Functions</p>
    <p>WinAPI/ Critical</p>
    <p>Functions</p>
    <p>Indirect Branch</p>
    <p>Any Time</p>
    <p>No Restriction CFI Policy</p>
    <p>Here only the core policies shown. However, we consider all other deployed policies in our analysis.</p>
  </div>
  <div class="page">
    <p>Our Methodology</p>
    <p>Common Library</p>
    <p>kernel32.dll</p>
    <p>Sequence Finder (IDA Pro)</p>
    <p>Sequence Filter (D Program)</p>
    <p>List of CallPreceded</p>
    <p>Sequences</p>
    <p>Gadget Generation (manual)</p>
    <p>Sequence Subset 1</p>
    <p>Sequence Subset n</p>
    <p>MOV</p>
    <p>ADD</p>
    <p>ESP</p>
    <p>CALL</p>
    <p>LNOP</p>
    <p>XOR</p>
    <p>Provide filters on Reg, Ins, Opnd, Length</p>
    <p>Search for Gadgets</p>
    <p>LOAD</p>
    <p>STORE</p>
  </div>
  <div class="page">
    <p>(Excerpt of) Turing-Complete Gadget Set in CFI-Protected kernel32.dll</p>
    <p>Gadget Type CALL-Preceded Sequence ending in a RET instruction</p>
    <p>LOAD Register</p>
    <p>EBP := pop ebp ESI := pop esi; pop ebp EDI := pop edi; leave ECX := pop ecx; leave EBX := pop edi; pop esi; pop ebx; pop ebp EAX := mov eax,edi; pop edi; leave EDX := mov eax,[ebp-8]; mov edx,[ebp-4]; pop edi; leave</p>
    <p>LOAD/STORE Memory</p>
    <p>LD(EAX) := mov eax,[ebp+8]; pop ebp ST(EAX) := mov [esi],eax; xor eax,eax; pop esi; pop ebp ST(ESI) := mov [ebp-20h],esi ST(EDI) := mov [ebp-20h],edi</p>
    <p>Arithmetic/ Logical</p>
    <p>ADD/SUB := sub eax,esi; pop esi; pop ebp XOR := xor eax,edi; pop edi; pop esi; pop ebp</p>
    <p>Branches unconditional branch 1 := leave unconditional branch 2 := add esp,0Ch; pop ebp conditional LD(EAX) := neg eax; sbb eax,eax; and eax,[ebp-4]; .leave</p>
  </div>
  <div class="page">
    <p>Long NOP Gadget</p>
    <p>ROP Gadget 1</p>
    <p>Store Registers</p>
    <p>Prepare Long NOP</p>
    <p>Long NOP</p>
    <p>Reset Registers</p>
    <p>ROP Gadget 2</p>
    <p>ESI</p>
    <p>EDI</p>
    <p>EBX</p>
    <p>Stack</p>
    <p>Static Constants</p>
    <p>Arbitrary Data Area (36 Bytes)</p>
    <p>ESI</p>
    <p>EDI</p>
  </div>
  <div class="page">
    <p>Real-World Exploitation</p>
    <p>Adobe Reader 9.1 CVE-2010-0188</p>
    <p>MPlayer Lite r33064 m3u Buffer Overflow Exploit</p>
    <p>Both detected by Microsoft EMET and coarse-grained CFI</p>
    <p>Exploit Transformation</p>
    <p>Common Library</p>
    <p>kernel32.dll</p>
    <p>Successful Exploit Details in Paper</p>
  </div>
  <div class="page">
    <p>Lessons Learned</p>
    <p>Fundamental problems of coarse-grained CFI</p>
    <p>Turing-complete gadget set possible on small code base</p>
    <p>Restrict returns to valid/hot call sites (shadow stack)</p>
    <p>Our generic Long NOP evades heuristics and handles all side effects</p>
    <p>Adjusted sequence length leads to high false positive</p>
    <p>Resolving indirect jumps and calls is non-trivial</p>
    <p>Original CFI: Vulcan framework remains blackbox</p>
    <p>Compromise: Compiler support 21 8/21/2014</p>
  </div>
  <div class="page">
    <p>Summary and Future Work  Summary</p>
    <p>We systematically analyze the security of all recently proposed practical defenses against code reuse attacks</p>
    <p>We show Turing-completeness of ROP even over less than 1MB code base</p>
    <p>And, we provide real-world exploits</p>
    <p>Our ongoing work: fine-grained CFI</p>
    <p>Hardware/Software Co-design [DAC 2014]; collaboration with Intel</p>
    <p>Software Solutions; collaboration with Microsoft</p>
    <p>Future work</p>
    <p>CFI for dynamic code or JIT-enabled applications</p>
    <p>Improved code randomization schemes</p>
  </div>
  <div class="page">
    <p>Thank you!</p>
    <p>For more information see</p>
    <p>www.trust.cased.de</p>
  </div>
</Presentation>
