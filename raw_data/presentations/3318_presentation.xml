<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>What Cannot be Read, Cannot be Leveraged?</p>
    <p>Revisiting Assumptions of JIT-ROP Defenses</p>
    <p>Giorgi Maisuradze, Michael Backes, Christian Rossow CISPA, Saarland University, Germany</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>JavaScript</p>
    <p>Native Code</p>
    <p>Code Reuse Attacks/Defenses</p>
    <p>JavaScript JIT Compilation</p>
    <p>Existing JIT Attacks/Defenses</p>
    <p>New JIT Gadget Creation</p>
    <p>New JIT Defense</p>
  </div>
  <div class="page">
    <p>Revisiting Code Reuse</p>
  </div>
  <div class="page">
    <p>Code Reuse</p>
    <p>saved RBP saved RIP</p>
    <p>array[]</p>
    <p>STACK(RW)  Find useful code fragments</p>
    <p>saved RBP @G1</p>
    <p>array[]</p>
    <p>@GN</p>
    <p>STACK(RW)</p>
    <p>libraries</p>
    <p>.text</p>
    <p>...</p>
    <p>pop rcx pop rdx ret</p>
    <p>...4881C791121 009489748C7C0 595AC3 124889 EC5DC3...</p>
    <p>Chain gadgets and functions together</p>
    <p>int execv(..)</p>
    <p>Trigger execution of the gadget chain</p>
  </div>
  <div class="page">
    <p>.text</p>
    <p>pop rcx pop rdx ret</p>
    <p>...4881C791121 009489748C7C0 595AC3 124889 EC5DC3...</p>
    <p>Code Reuse Defenses</p>
    <p>STACK(RW)  Find useful code fragments</p>
    <p>saved RBP @G1</p>
    <p>array[]</p>
    <p>@GN</p>
    <p>STACK(RW) libraries ...</p>
    <p>A S L R</p>
    <p>Fine-grained ASLR</p>
    <p>Chain gadgets and functions together</p>
    <p>int execv(..)</p>
    <p>Trigger execution of the gadget chain</p>
    <p>Defenses:</p>
    <p>Fine-grained code randomization</p>
    <p>Randomize memory segments (ASLR)</p>
    <p>.text</p>
    <p>movb [rax],1</p>
    <p>...?????????? ????????????? c60001 ?????? ??????...</p>
    <p>??????????????</p>
  </div>
  <div class="page">
    <p>JIT-ROP [S&amp;P13]</p>
    <p>Leak and collect code pointers</p>
    <p>Memory Map</p>
    <p>Stack</p>
    <p>Libraries</p>
    <p>Heap</p>
    <p>Executable</p>
    <p>JS</p>
    <p>&amp;</p>
    <p>G1 GN...</p>
    <p>Read code pages to find gadgets and function pointers</p>
    <p>Chain gadgets and functions together</p>
    <p>Trigger execution of the gadget chain G1:</p>
    <p>GN:</p>
    <p>pop rdi; ret</p>
    <p>execv(..)</p>
  </div>
  <div class="page">
    <p>Execute-no-Read (XnR) Schemes</p>
    <p>Memory Map</p>
    <p>JS</p>
    <p>&amp;</p>
    <p>G1 GN...</p>
    <p>Randomize code</p>
    <p>Hide code pointers</p>
    <p>G1:</p>
    <p>GN:</p>
    <p>Stack</p>
    <p>Libraries</p>
    <p>Heap</p>
    <p>Executable</p>
    <p>Mark code pages non-readable [CCS14, S&amp;P15, CCS15, CODASPY15, NDSS16]</p>
    <p>pop rdi; ret</p>
    <p>execv(..)</p>
  </div>
  <div class="page">
    <p>JIT code reuse without reading code?!</p>
  </div>
  <div class="page">
    <p>JIT Spraying [WOOT10]</p>
    <p>Create JS functions containing operations on immediate values</p>
    <p>function f(){ x=0x3C909090&amp; 0x3C909090&amp; ... 0x3C909090; }</p>
    <p>JavaScript</p>
    <p>JIT Compile</p>
    <p>x86</p>
    <p>mov eax,0x3C909090 and eax,0x3C909090 and eax,0x3C909090 ... and eax,0x3C909090 ...</p>
    <p>nop, nop, nop cmp al, 0x25 ... nop, nop, nop cmp al, 0x25</p>
    <p>unaligned</p>
    <p>Unaligned Jump</p>
    <p>Trigger JIT-compilation of created functions</p>
    <p>Divert the CF in the middle of one of the constants</p>
  </div>
  <div class="page">
    <p>Defenses in Browsers</p>
    <p>Store constant XORed with a random key to a register</p>
    <p>XOR the register again with the key</p>
    <p>mov eax,0x3C909090 mov eax,0x2511663f xor eax,0x1981f6af</p>
    <p>mov eax,0x3C909090 and eax,0x3C909090</p>
    <p>mov eax,0x3C909090 lea esp,[esp] and eax,0x3C909090</p>
    <p>Randomly add random number of NOP instructions</p>
    <p>Only large constants (&gt;2B) are blinded</p>
    <p>NOP Insertion (IE)</p>
    <p>Constant Blinding (IE + Chrome)</p>
  </div>
  <div class="page">
    <p>The Devil is in the Constants [NDSS15]</p>
    <p>Encode OPs in 2B unblinded constants</p>
    <p>Use intended return instruction from JIT-compiled code</p>
    <p>Find and use emitted gadgets</p>
    <p>function r8(a){ return a+0x5841; }</p>
    <p>JavaScript JIT</p>
    <p>Compile</p>
    <p>x86</p>
    <p>Limitations:</p>
    <p>Requires readable code to find gadgets</p>
    <p>Aligned return instruction</p>
    <p>x86</p>
    <p>add eax, 0x5841 &lt;epilogue&gt; ret</p>
    <p>pop r8 &lt;epilogue&gt; ret</p>
  </div>
  <div class="page">
    <p>Gadgets via Control Flow Instructions</p>
  </div>
  <div class="page">
    <p>Emitting Gadgets via Control Flow Instructions</p>
    <p>Displacement:  Encodes the offset from a base</p>
    <p>address, e.g., from rax or rip Prefixes Opcode ModR/M SIB ImmediateDisplacement</p>
    <p>DITC, JIT-Spraying</p>
    <p>Constant Blinding</p>
    <p>Used in:  Instructions accessing the memory:</p>
    <p>mov rax, [rbx+0x12345678] ; read memory at rbx+0x12345678</p>
    <p>Control flow instructions (implicit base address is rip) : jz 0x123456 ; jump at address rip+0x123456 if zero flag is set</p>
    <p>call 0x123456 ; call the function at address rip+0x123456</p>
    <p>We will use JavaScript statements that are compiled to conditional jumps and direct calls to emit gadgets</p>
  </div>
  <div class="page">
    <p>Conditional Jumps in JS</p>
    <p>JavaScript if statement:  Emits conditional jumps after compilation</p>
    <p>Displacement field denotes the size of the compiled if body</p>
    <p>Change the size of if body  changes</p>
    <p>the value in the displacement field</p>
    <p>Alternatives to if statement: while/for/switch/break...</p>
    <p>JavaScript</p>
    <p>JIT Compile</p>
    <p>x86 ... test eax, eax jz 0x... ...; Compiled ; If Body ; Size=gadget &lt;epilogue&gt; ret</p>
    <p>The size of the compiled if statement's body determines emitted Gadget</p>
    <p>S i z e = G a d g e t</p>
    <p>function f(c){ if(c) { //Statements //Compiled //Size=Gadget } return; }</p>
  </div>
  <div class="page">
    <p>Create a large JS function:  Use i=i+j (16B) 0x100`000 times  Emitted values [0x000005, 0xFFFFF5]</p>
    <p>Prepend the function with i=1 (8B) to change 5 into 13 (0xD)</p>
    <p>Direct Calls in JS</p>
    <p>Direct calls in JS:  Displacement: the distance between the</p>
    <p>caller and the callee</p>
    <p>Find callee/caller address:  Compilers heap  Return address from stack  JS objects (e.g., from Math.random)</p>
    <p>function f(){ var i, j; i=i+j;</p>
    <p>/* i=i+j 0x100`000 Times */ i=i+j; return; }</p>
    <p>JS</p>
    <p>JIT Compile</p>
    <p>x86</p>
    <p>... call 0x55555555 ... call 0x54C3fff5 ... call 0x54C380C5 ... call 0x54C30005 ... call 0x54555555 ...</p>
    <p>call 0x54C380CDGoal:</p>
    <p>call 0x54XXXXX5Created Calls:</p>
    <p>function f(){ var i, j; i=1; // 8B i=i+j;</p>
    <p>/* i=i+j 0x100`000 Times */ i=i+j; return; }</p>
    <p>JS</p>
    <p>JIT Compile</p>
    <p>x86</p>
    <p>...</p>
    <p>...;8B from i=1 call 0x5555555D ... call 0x54C3FFFD ... call 0x54C380CD ... call 0x54C3000D ... call 0x5455555D ...</p>
    <p>call 0x54C380CDGoal:</p>
    <p>call 0x54XXXXXDCreated Calls:</p>
  </div>
  <div class="page">
    <p>Applying Concepts to Modern Browsers</p>
  </div>
  <div class="page">
    <p>Gadgets in Chrome 51 (64-bit)</p>
    <p>Direct calls (syscall, pop rcx, pop rdx):  Align LSHB of displacements to 0xd  Emit direct calls (j++ 0x80`000 times)</p>
    <p>pop r8; ret</p>
    <p>pop r9; ret</p>
    <p>pop rcx; ret</p>
    <p>pop rdx; ret</p>
    <p>int 0x80; ret</p>
    <p>cd80c3</p>
    <p>function syscall(){ var j=0; // align displacements // LSHB to 0xd j++;j++;j++;j++; // j++ 0x80`000 times }</p>
    <p>JS</p>
    <p>function popr8r9(r8,r9){ var i=0, j=0; if(r9){ // j=0x1010101 7 times // =&gt; 0xbd j++;j=i;j=i; // =&gt; 0xed if(r8){ // =&gt; 0x100 // j=0x1010101 211 times // =&gt; 0x1641 // j++ 399`888 times // =&gt; 0xC35841 } // =&gt; 0xC35941 } }</p>
    <p>Gadget generation time  1.3 seconds 17</p>
    <p>Conditional jumps (pop r8, pop r9):  Stack two if statements (for pop r8 and pop r9)  Fill the inner (pop r8) with 0xc35841 bytes  Add additional 0xed bytes to the outer if body</p>
    <p>+0x13 bytes from if statement=0x100</p>
    <p>Goal:</p>
  </div>
  <div class="page">
    <p>Challenges in IE:</p>
    <p>Limitations in Internet Explorer</p>
    <p>Steps to make direct calls work:</p>
  </div>
  <div class="page">
    <p>IE code-page size is 0x20`000 bytes</p>
    <p>Compile 200 JavaScript functions of size 0x10`000 bytes each to allocate 100 code pages</p>
    <p>Choose the code page at the correct distance</p>
    <p>Allocating Code Page at a Correct Distance Memory Map</p>
    <p>Fn1 | Fn2</p>
    <p>Fn3 | Fn4</p>
    <p>Fn199 | Fn200</p>
    <p>Fn7 | Fn8</p>
    <p>...</p>
    <p>Math.random</p>
    <p>...</p>
  </div>
  <div class="page">
    <p>(5) If yes, then gadget is found, else deallocate the function and goto (3)</p>
    <p>(4) Check if the direct call was emitted at the correct place</p>
    <p>(3) Compile gadget-emitting JS function</p>
    <p>(2) Fill the code page up to the correct distance from the callee</p>
    <p>Gadgets in IE  Emitting Gadgets</p>
    <p>Fn3 | Fn4</p>
    <p>Math.random</p>
    <p>...</p>
    <p>...</p>
    <p>Math.random</p>
    <p>...</p>
    <p>...</p>
    <p>(1)</p>
    <p>(4) Check</p>
    <p>Math.random address</p>
    <p>(5:N)</p>
    <p>(5:Y)</p>
    <p>Found</p>
    <p>Math.random</p>
    <p>...</p>
    <p>...</p>
    <p>f1| f2 |f3</p>
    <p>(1) Deallocate the function</p>
    <p>Math.random</p>
    <p>...</p>
    <p>...</p>
    <p>(2)</p>
    <p>f1| f2 |f3</p>
    <p>Math.random</p>
    <p>...</p>
    <p>...</p>
    <p>(3)</p>
    <p>f1| f2 |f3</p>
    <p>call 0x9BC380CX</p>
  </div>
  <div class="page">
    <p>Gadgets in IE 11 (32-bit)</p>
    <p>Emitting gadgets: (1) Find and fill up the correct code page (4 seconds) (2) Compile syscall and popa at correct places (4 seconds) (3) Recompile syscall until the gadget is emitted (2 seconds)</p>
    <p>popa; ret</p>
    <p>int 0x80; ret</p>
    <p>cd80c3 function syscall(){ var j=0; i=Math.random(); //i=Math.random(); 240x check(Math.random()); //i=Math.random(); 10x }</p>
    <p>JS</p>
    <p>function popa(){ var j=0; i=Math.random(); //i=Math.random(); 232x check(Math.random()); //i=Math.random(); 18x }</p>
    <p>Average gadget generation time  32 seconds</p>
    <p>Goal: Direct calls (syscall, popa):  Use i=Math.random() 250 times ( 0x1`000 bytes )  Check the address of emitted direct call</p>
  </div>
  <div class="page">
    <p>Gadgets in Browsers</p>
    <p>Conditional jumps</p>
    <p>+ Work in Chrome and Firefox</p>
    <p>- Only upto 2B gadgets possible in IE</p>
    <p>Direct calls</p>
    <p>+ Work in Chrome and IE</p>
    <p>- Do not work in Firefox</p>
    <p>Conditional Jumps Direct Calls</p>
  </div>
  <div class="page">
    <p>Removing the Gadgets...</p>
  </div>
  <div class="page">
    <p>For each direct call:</p>
    <p>Defense  Direct Calls</p>
    <p>(1)</p>
    <p>(2.b)</p>
    <p>(2.a) 0x00: lea r10,[rip+ADDRESS] 0x07: call r10</p>
    <p>(1) If the address of the callee is known, replace the call with the indirect call</p>
    <p>(2) If the address is not known: (a) convert the direct call into the indirect one (b) blind the emitted relative address</p>
  </div>
  <div class="page">
    <p>For each conditional jump:</p>
    <p>Defense  Conditional Jumps</p>
    <p>XXXX: &lt;else&gt;</p>
    <p>(1) Convert a direct (relative) jump into an indirect one</p>
    <p>(2) Add the inverted conditional jump to jump into &lt;if_body&gt;</p>
    <p>(1)</p>
    <p>(2)</p>
  </div>
  <div class="page">
    <p>Defense  Overhead Original Modified Overhead</p>
    <p>Richards 36,263 35,555 1.95%</p>
    <p>DeltaBlue 63,641 62,045 2.51%</p>
    <p>Crypto 33,366 32,725 1.92%</p>
    <p>RayTrace 77,198 75,488 2.21%</p>
    <p>EarleyBoyer 44,900 43,700 2.67%</p>
    <p>RegExp 6,525 6,414 1.71%</p>
    <p>Splay 21,095 20,479 2.92%</p>
    <p>NavierStokes 31,924 31,998 -0.23%</p>
    <p>Total 32,255 31,662 1.96%</p>
    <p>Cost of the defense in V8:</p>
    <p>V8s JS Benchmark Suite:  2% performance overhead on average</p>
    <p>Microbenchmarks:  14% and 10% overhead on average</p>
    <p>V8s JS Benchmark Suite (Code-size):  26% overhead (1,123 kB  1,411 kB)</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Displacement fields of x86 instructions can be used to inject arbitrary 3 byte values in JIT-compiled code</p>
    <p>Predictable code output from JIT compilers allows adversaries to generate and reuse gadgets without reading the code</p>
    <p>Gadgets in displacements fields can be removed by converting direct jumps/calls into indirect ones</p>
    <p>Thank you!</p>
  </div>
</Presentation>
