<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>YAPA: A generic tool for computing intruder knowledge</p>
    <p>Mathieu Baudet1</p>
    <p>Joint work with Veronique Cortier2 and Stephanie Delaune3</p>
    <p>RTA2009, Brazlia, June 29.</p>
  </div>
  <div class="page">
    <p>Content of the talk</p>
  </div>
  <div class="page">
    <p>Motivations</p>
    <p>Content of the talk</p>
  </div>
  <div class="page">
    <p>Motivations Why study static equivalence ?</p>
    <p>Static equivalence (teaser)</p>
  </div>
  <div class="page">
    <p>Motivations Why study static equivalence ?</p>
    <p>Algebraic framework</p>
    <p>Consider a set Fpub of first-order symbols f : s  s  s . (Single sort s assumed for simplicity.)</p>
    <p>A Fpub-algebra is a set A together with functions fA : AAA.</p>
    <p>Standard definitions : Fpub-morphisms, generated sub-algebras Fpub[S ] A, free algebra Fpub[X ], . . .</p>
  </div>
  <div class="page">
    <p>Motivations Why study static equivalence ?</p>
    <p>Static equivalence (algebraic definition)</p>
    <p>Consider the tuples  = (t1, . . . , tn) in An, also called frames and written  = {w1 B t1, . . . , wn B tn}.</p>
    <p>A formal equation on An is a pair M1 ./ M2 where M1, M2 Fpub[w1, . . . , wn] are terms built upon special constants wi .</p>
    <p>Definition Two frames 1 and 2 in An are statically equivalent (from [Abadi and Fournet, 2001]), written 1  2, iff</p>
    <p>eq(1) = eq(2)</p>
    <p>where eq() = {M1 ./ M2 | M1 =A M2}.</p>
  </div>
  <div class="page">
    <p>Motivations Why study static equivalence ?</p>
    <p>Static equivalence (algebraic definition)</p>
    <p>Consider the tuples  = (t1, . . . , tn) in An, also called frames and written  = {w1 B t1, . . . , wn B tn}.</p>
    <p>A formal equation on An is a pair M1 ./ M2 where M1, M2 Fpub[w1, . . . , wn] are terms built upon special constants wi .</p>
    <p>Definition Two frames 1 and 2 in An are statically equivalent (from [Abadi and Fournet, 2001]), written 1  2, iff</p>
    <p>eq(1) = eq(2)</p>
    <p>where eq() = {M1 ./ M2 | M1 =A M2}. 7 / 41</p>
  </div>
  <div class="page">
    <p>Motivations Why study static equivalence ?</p>
    <p>A mathematical example</p>
    <p>Example</p>
    <p>Let n = 1, A = C and the terms M  Q[w1] be rational polynomials with single variable w1. We have 1  2 iff 1 and 2 are both transcendental or are conjugated elements (i.e. have the same minimal polynomial over Q).</p>
    <p>For instance,   e and</p>
    <p>We are currently investigating further links with the fundamentals of algebraic geometry. (Ask me for more details !)</p>
  </div>
  <div class="page">
    <p>Motivations Why study static equivalence ?</p>
    <p>Back to logics and security protocols I</p>
    <p>We are interested in modeling cryptographic messages : we let A be an F-algebra of ground terms taken modulo an equational theory E, where Fpub ( F.</p>
    <p>Typically, the symbols in F Fpub are free constants modeling secret keys or random numbers.</p>
    <p>E is generated by a finite set of equations modeling the cryptographic primitives.</p>
  </div>
  <div class="page">
    <p>Motivations Why study static equivalence ?</p>
    <p>Back to logics and security protocols II</p>
    <p>Static equivalence models indistinguishability between messages from an attackers point of view.</p>
    <p>Another classical problem is deducibility :</p>
    <p>Given  An and t A, does there exist M Fpub[w1, . . . , wn] such that M =A t ?</p>
    <p>N.B. Such an M is often called a recipe of t.</p>
  </div>
  <div class="page">
    <p>Motivations Why study static equivalence ?</p>
    <p>Example : deterministic symmetric encryption</p>
    <p>M Fpub[w1, . . . , wn] (recipes) ::= wi | enc(M1, M2) | dec(M1, M2)</p>
    <p>t F[] ::= kj | enc(t1, t2) | dec(t1, t2) (plain terms)  Let E be generated by dec(enc(x, y ), y ) = x .</p>
    <p>Consider 1 = {w1 B enc(k1, k2), w2 B k2} (frames) and 2 = {w1 B enc(k1, k2), w2 B k3}.</p>
    <p>We have 1 6E 2 (1, 2 not E -equivalent) because enc(dec(w1, w2), w2)1 =E w11 but enc(dec(w1, w2), w2)2 6=E w12</p>
  </div>
  <div class="page">
    <p>Motivations Why study static equivalence ?</p>
    <p>Equational approach to security protocols I</p>
    <p>Similar equational settings used in popular specification languages such as the applied pi calculus [Abadi and Fournet, 2001], or Proverifs language [Blanchet, 2001, Blanchet et al., 2008].</p>
    <p>Studying full protocols requires a more general notion of observational equivalence.</p>
  </div>
  <div class="page">
    <p>Motivations Why study static equivalence ?</p>
    <p>Equational approach to security protocols II</p>
    <p>Proof techniques for observational equivalence include</p>
    <p>labelled bisimulations built on the top of static equivalence [Abadi and Fournet, 2001],</p>
    <p>and symbolic semantics based on a generalization of static equivalence [Baudet, 2005, Delaune et al., 2007].</p>
    <p>Static equivalence also applied to characterize guessing attacks [Corin et al., 2004, Baudet, 2005]</p>
    <p>Correspondance between static equivalence and cryptographic (a.k.a. computational) indistinguishability investigated in several papers, e.g. [Abadi et al., 2006].</p>
  </div>
  <div class="page">
    <p>Motivations Why a new tool ?</p>
    <p>More equational theories I  More involved examples of cryptographic equational</p>
    <p>theories include (see e.g. [Cortier et al., 2006])  public-key encryption : pdec(penc(x, pub(y ), z ), y ) = x</p>
    <p>signatures : checksign(sign(x, y ), pub(y )) = ok</p>
    <p>XOR symbol : AC [] x  x = 0  XOR-homomorphic symbols : h(x  y ) = h(x )  h(y )  Diffie-Hellman exponents : (g x )y = (g y )x</p>
    <p>pair-homomorphic encryption : . . . enc(x, y, z ) = enc(x, z ), enc(y , z )</p>
    <p>prefix-homomorphic encryption : . . . pref(enc(x, y, z )) = enc(x, z )</p>
    <p>blind signatures : checksign(sign(x, y ), pub(y )) = ok unblind(blind(x, y ), y ) = x</p>
    <p>unblind(sign(blind(x, y ), z ), y ) = sign(x, z )</p>
  </div>
  <div class="page">
    <p>Motivations Why a new tool ?</p>
    <p>More equational theories I  More involved examples of cryptographic equational</p>
    <p>theories include (see e.g. [Cortier et al., 2006])  public-key encryption : pdec(penc(x, pub(y ), z ), y ) = x</p>
    <p>signatures : checksign(sign(x, y ), pub(y )) = ok</p>
    <p>XOR symbol : AC [] x  x = 0  XOR-homomorphic symbols : h(x  y ) = h(x )  h(y )  Diffie-Hellman exponents : (g x )y = (g y )x</p>
    <p>pair-homomorphic encryption : . . . enc(x, y, z ) = enc(x, z ), enc(y , z )</p>
    <p>prefix-homomorphic encryption : . . . pref(enc(x, y, z )) = enc(x, z )</p>
    <p>blind signatures : checksign(sign(x, y ), pub(y )) = ok unblind(blind(x, y ), y ) = x</p>
    <p>unblind(sign(blind(x, y ), z ), y ) = sign(x, z )</p>
  </div>
  <div class="page">
    <p>Motivations Why a new tool ?</p>
    <p>More equational theories I  More involved examples of cryptographic equational</p>
    <p>theories include (see e.g. [Cortier et al., 2006])  public-key encryption : pdec(penc(x, pub(y ), z ), y ) = x</p>
    <p>signatures : checksign(sign(x, y ), pub(y )) = ok</p>
    <p>XOR symbol : AC [] x  x = 0  XOR-homomorphic symbols : h(x  y ) = h(x )  h(y )  Diffie-Hellman exponents : (g x )y = (g y )x</p>
    <p>pair-homomorphic encryption : . . . enc(x, y, z ) = enc(x, z ), enc(y , z )</p>
    <p>prefix-homomorphic encryption : . . . pref(enc(x, y, z )) = enc(x, z )</p>
    <p>blind signatures : checksign(sign(x, y ), pub(y )) = ok unblind(blind(x, y ), y ) = x</p>
    <p>unblind(sign(blind(x, y ), z ), y ) = sign(x, z )</p>
  </div>
  <div class="page">
    <p>Motivations Why a new tool ?</p>
    <p>More equational theories II</p>
    <p>Each of these theories yields new deduction and static-equivalence problems to decide.</p>
    <p>So far the only applicable tool to static equivalence has been Proverif [Blanchet et al., 2008], but it does not make use of the specialized, existing decision procedures for static equivalence [Abadi and Cortier, 2006, Cortier and Delaune, 2007].</p>
  </div>
  <div class="page">
    <p>Motivations Why a new tool ?</p>
    <p>Our contributions</p>
    <p>Focusing on theories E generated by convergent rewrite systems R :  We present a uniform procedure for deducibility and</p>
    <p>static equivalence, that is  sound and complete, up to explicit failure cases,  provably non failing on a syntactic class of theories called</p>
    <p>layered,  as much terminating as possible in non-failing cases</p>
    <p>(termination implied by finite representation of deducible terms).</p>
    <p>We provide an efficient Ocaml implementation : http://www.lsv.ens-cachan.fr/~baudet/yapa/</p>
  </div>
  <div class="page">
    <p>Results</p>
    <p>Content of the talk</p>
  </div>
  <div class="page">
    <p>Results Overview of the procedure</p>
    <p>Overview of the procedure I</p>
    <p>We saturate a set of deduction facts  = {Mi B ti} and a set of visible equations  = {x.Mj ./ Nj} by means of transformation rules st = st.</p>
    <p>The initial state Init() is (roughly) (0, 0) ' (R,).</p>
    <p>The final state is either  (failure) or a saturated state (1, 1) (success).</p>
  </div>
  <div class="page">
    <p>Results Overview of the procedure</p>
    <p>Overview of the procedure II</p>
    <p>Saturated states are finite syntactic representations of the sets of deducible terms and equations of the initial frame .</p>
    <p>Theorem (soundness and completeness)</p>
    <p>If Init() = (, ) is saturated, then 1 For all recipes M and ground terms t ,</p>
    <p>M =E t  N s.t.  ` M ./ N and N B tR 2 For all recipes M and N ,</p>
    <p>M =E N   ` M ./ N .</p>
    <p>where M B t C , {Mi B ti} ,</p>
    <p>{ M = C [M1, . . . , Mn]</p>
    <p>t = C [t1, . . . , tn] .</p>
  </div>
  <div class="page">
    <p>Results Overview of the procedure</p>
    <p>Overview of the procedure III</p>
    <p>From saturated states Init(i ) = (i, i ), it is easy to deduce procedures to check whether</p>
    <p>(i) t is deducible from 1, that is :</p>
    <p>tR Fpub[im(1)]</p>
    <p>(ii) eqE (1)  eqE (2), that is :</p>
    <p>for all (x.M ./ N )  1, (M2)R = (N2)R.</p>
  </div>
  <div class="page">
    <p>Results Examples</p>
    <p>Simple example</p>
    <p>Let R = {dec(enc(x, y ), y )  x} and 1 = {w1 B enc(k1, k2), w2 B k2}. Deductions steps for saturating 1 :</p>
    <p>w1 B enc(k1, k2) w2 B k2 dec(w1, w2) B k1 x, y. dec(enc(x, y ), y ) ./ x</p>
    <p>dec(w1, w2) B k1 w2 B k2 w1 B enc(k1, k2) enc(dec(w1, w2), w2) ./ w1</p>
  </div>
  <div class="page">
    <p>Results Examples</p>
    <p>Less simple example (with apologies for the wrong definition of Rblind in the proc.)</p>
    <p>Let R =</p>
    <p>checksign(sign(x, y ), pub(y ))  ok unblind(blind(x, y ), y )  x</p>
    <p>unblind(sign(blind(x, y ), z ), y )  sign(x, z )</p>
    <p>and 1 = {w1 B blind(k, r), w2 B r}. (1) Trivial equations :</p>
    <p>x, y. checksign(sign(x, y ), pub(y )) ./ ok</p>
    <p>x, y. unblind(blind(x, y ), y ) ./ x</p>
    <p>x, y. unblind(sign(blind(x, y ), z ), y ) ./ sign(x, z )</p>
  </div>
  <div class="page">
    <p>Results Examples</p>
    <p>Less simple example (with apologies for the wrong definition of Rblind in the proc.)</p>
    <p>Let R =</p>
    <p>checksign(sign(x, y ), pub(y ))  ok unblind(blind(x, y ), y )  x</p>
    <p>unblind(sign(blind(x, y ), z ), y )  sign(x, z )</p>
    <p>and 1 = {w1 B blind(k, r), w2 B r}. (2) Failure case that must be postponed :</p>
    <p>w1 B blind(k, r) w2 B r unblind(sign(w1, z ), w2) B sign(k, z )</p>
    <p>Rationals for failure cases In YAPA, accumulated deduction facts M B t must be ground. Only equations x, y.M ./ N may use quantifiers.</p>
  </div>
  <div class="page">
    <p>Results Examples</p>
    <p>Less simple example (with apologies for the wrong definition of Rblind in the proc.)</p>
    <p>Let R =</p>
    <p>checksign(sign(x, y ), pub(y ))  ok unblind(blind(x, y ), y )  x</p>
    <p>unblind(sign(blind(x, y ), z ), y )  sign(x, z )</p>
    <p>and 1 = {w1 B blind(k, r), w2 B r}. (3) Other deduction steps</p>
    <p>w1 B blind(k, r) w2 B r unblind(w1, w2) B k</p>
    <p>unblind(w1, w2) B k w2 B r w1 B blind(k, r) blind(unblind(w1, w2), w2) ./ w1</p>
  </div>
  <div class="page">
    <p>Results Examples</p>
    <p>Less simple example (with apologies for the wrong definition of Rblind in the proc.)</p>
    <p>Let R =</p>
    <p>checksign(sign(x, y ), pub(y ))  ok unblind(blind(x, y ), y )  x</p>
    <p>unblind(sign(blind(x, y ), z ), y )  sign(x, z )</p>
    <p>and 1 = {w1 B blind(k, r), w2 B r}. (4) Failure case solved !</p>
    <p>w1 B blind(k, r) w2 B r unblind(w1, w2) B k z. unblind(sign(w1, z ), w2) ./ sign(unblind(w1, w2), z )</p>
    <p>Proving non-failure</p>
    <p>We have formalized these observations and defined a general class of non-failing theories, called layered.</p>
  </div>
  <div class="page">
    <p>Results Proving termination and non-failure</p>
    <p>A syntactic criterion for non-failure</p>
    <p>Definition (Layered rewrite system  simplified)</p>
    <p>There exist subsystems  = R0 R1  . . . RN = R such that for every 0  i &lt; N , for every rule l  r in Ri +1 Ri , for every l = D [l1, . . . , ln, x1, . . . , xm], either</p>
    <p>(i) var(r )  var(l1, . . . , ln), or (ii) there exists C such that</p>
    <p>C [l1, . . . , ln, x1, . . . , xm] 1Ri r .</p>
    <p>Proposition</p>
    <p>The procedure never fails on layered convergent theories.</p>
    <p>Note that the union of two layered systems is layered. 28 / 41</p>
  </div>
  <div class="page">
    <p>Results Proving termination and non-failure</p>
    <p>Termination</p>
    <p>Proving termination by hand for one theory is generally easy by standard techniques.</p>
    <p>We provide a semantic criterion ((ii) below) as well.</p>
    <p>Proposition</p>
    <p>Assume Init() 6= . The following are equivalent : (i) There exists a saturated state Init() = (, ).</p>
    <p>(ii) There exists a finite set of deducible terms S such that Fpub[S ] covers every deducible R-normal term.</p>
    <p>(iii) There exists no fair infinite derivation from Init().</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Content of the talk</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Supported theories  Altogether, using [Abadi and Cortier, 2006], we</p>
    <p>deduce termination and non-failure for  subterm convergent theories R :</p>
    <p>l  r in R, r  st(l ) F[]R  pair-homomorphic encryption :</p>
    <p>. . . enc(x, y, z ) = enc(x, z ), enc(y , z )</p>
    <p>prefix-homomorphic encryption (new) : . . . pref(enc(x, y, z )) = enc(x, z )</p>
    <p>blind signatures : checksign(sign(x, y ), pub(y )) = ok unblind(blind(x, y ), y ) = x</p>
    <p>unblind(sign(blind(x, y ), z ), y ) = sign(x, z )</p>
    <p>a simple theory of addition : plus(x, s(y )) = plus(s(x ), y ) plus(x, zero) = x</p>
    <p>pred(s(x )) = x</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Benchmarks</p>
    <p>We have tested the tool on a few examples and obtained good results, usually faster than Proverif.</p>
    <p>This is not surprising as static equivalence is an easier problem than the (in)security of protocols as studied by Proverif.</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Summary</p>
    <p>We have proposed a unifying approach to study intruder knowledge for convergent theories.</p>
    <p>Many equational theories are provably and efficiently supported by the tool YAPA.</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Perspectives</p>
    <p>Better comparison with Proverif and with the recent work of [Ciobaca et al., 2009], which both allow non-ground deduction facts.</p>
    <p>More complex theories e.g. including a XOR symbol (see combination theorem of [Arnaud et al., 2007]).</p>
    <p>More complex algebraic properties, for instance checking whether eq(1)  eq(2)  eq(3).</p>
    <p>Active case, ideally to generalize [Baudet, 2005].</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Thank you !</p>
  </div>
  <div class="page">
    <p>Erratum</p>
    <p>Erratum : Blind signatures</p>
    <p>To see that the (corrected) theory of blind signatures is layered, let</p>
    <p>R1 = {</p>
    <p>checksign(sign(x, y ), pub(y ))  ok unblind(blind(x, y ), y )  x</p>
    <p>} R2 = R1 {unblind(sign(blind(x, y ), z ), y )  sign(x, z )}</p>
  </div>
  <div class="page">
    <p>Link with algebraic geometry</p>
    <p>Link with algebraic geometry (ongoing work)</p>
    <p>Generalize equations by allowing disjunctions :</p>
    <p>F ::= n</p>
    <p>i =1</p>
    <p>(M1 ./ M2) Pfin(Fpub[w1, . . . , wn]2)</p>
    <p>formulas() = {F |  ,  |= F} ( radical ideal)</p>
    <p>points(I ) = { |F  I ,  |= F} ( algebraic set)</p>
    <p>= points(formulas()) ( algebraic closure,  Zariski topology)</p>
    <p>1  2 iff formulas({1}) = formulas({2}). 37 / 41</p>
  </div>
  <div class="page">
    <p>Bibliography</p>
    <p>References I Abadi, M., Baudet, M., and Warinschi, B. (2006).</p>
    <p>Guessing attacks and the computational soundness of static equivalence. In Foundations of Software Science and Computation Structures (FOSSACS06), pages 398412.</p>
    <p>Abadi, M. and Cortier, V. (2006).</p>
    <p>Deciding knowledge in security protocols under equational theories. Theoretical Computer Science, 387(1-2) :232.</p>
    <p>Abadi, M. and Fournet, C. (2001).</p>
    <p>Mobile values, new names, and secure communication. In 28th ACM Symposium on Principles of Programming Languages (POPL01), pages 104115. ACM.</p>
    <p>Anantharaman, S., Narendran, P., and Rusinowitch, M. (2007).</p>
    <p>Intruders with caps. In 18th International Conference on Term Rewriting and Applications (RTA07), volume 4533 of LNCS. Springer.</p>
    <p>Arnaud, M., Cortier, V., and Delaune, S. (2007).</p>
    <p>Combining algorithms for deciding knowledge in security protocols. In Proc. 6th International Symposium on Frontiers of Combining Systems (FroCoS07), volume 4720 of Lecture Notes in Artificial Intelligence, pages 103117. Springer.</p>
    <p>Baudet, M. (2005).</p>
    <p>Deciding security of protocols against off-line guessing attacks. In 12th ACM Conference on Computer and Communications Security (CCS05), pages 1625. ACM Press.</p>
    <p>Baudet, M. (2007).</p>
    <p>Securite des protocoles cryptographiques : aspects logiques et calculatoires. These de doctorat, LSV, ENS Cachan, France.</p>
  </div>
  <div class="page">
    <p>Bibliography</p>
    <p>References II</p>
    <p>Baudet, M., Cortier, V., and Kremer, S. (2005).</p>
    <p>Computationally sound implementations of equational theories against passive adversaries. In 32nd International Colloquium on Automata, Languages and Programming (ICALP05), volume 3580 of LNCS, pages 652663. Springer.</p>
    <p>Blanchet, B. (2001).</p>
    <p>An Efficient Cryptographic Protocol Verifier Based on Prolog Rules. In 14th Computer Security Foundations Workshop (CSFW01), pages 8296. IEEE Comp. Soc. Press.</p>
    <p>Blanchet, B., Abadi, M., and Fournet, C. (2008).</p>
    <p>Automated verification of selected equivalences for security protocols. Journal of Logic and Algebraic Programming, 75(1) :351.</p>
    <p>Chevalier, Y., Kusters, R., Rusinowitch, M., and Turuani, M. (2003).</p>
    <p>An NP decision procedure for protocol insecurity with XOR. In 18th IEEE Symposium on Logic in Computer Science (LICS03). IEEE Comp. Soc. Press.</p>
    <p>Ciobaca, S., Delaune, S., and Kremer, S. (2009).</p>
    <p>Computing knowledge in security protocols under convergent equational theories. In Proc. 22nd International Conference on Automated Deduction (CADE09), Lecture Notes in Artificial Intelligence. Springer. To appear.</p>
    <p>Comon-Lundh, H. and Shmatikov, V. (2003).</p>
    <p>Intruder deductions, constraint solving and insecurity decision in presence of exclusive or. In 18th IEEE Symposium on Logic in Computer Science (LICS03). IEEE Comp. Soc. Press.</p>
  </div>
  <div class="page">
    <p>Bibliography</p>
    <p>References III</p>
    <p>Corin, R., Doumen, J., and Etalle, S. (2004).</p>
    <p>Analysing password protocol security against off-line dictionary attacks. In 2nd International Workshop on Security Issues with Petri Nets and other Computational Models (WISP04), ENTCS.</p>
    <p>Cortier, V. and Delaune, S. (2007).</p>
    <p>Deciding knowledge in security protocols for monoidal equational theories. In 14th International Conference on Logic for Programming, Artificial Intelligence, and Reasoning (LPAR07), LNAI. Springer.</p>
    <p>Cortier, V., Delaune, S., and Lafourcade, P. (2006).</p>
    <p>A survey of algebraic properties used in cryptographic protocols. Journal of Computer Security, 14(1) :143.</p>
    <p>Delaune, S. and Jacquemard, F. (2004).</p>
    <p>A decision procedure for the verification of security protocols with explicit destructors. In 11th ACM Conference on Computer and Communications Security (CCS04), pages 278287.</p>
    <p>Delaune, S., Kremer, S., and Ryan, M. D. (2007).</p>
    <p>Symbolic bisimulation for the applied pi-calculus. In Proceedings of the 27th Conference on Foundations of Software Technology and Theoretical Computer Science (FSTTCS07), volume 4855 of LNCS, pages 133145. Springer.</p>
    <p>Delaune, S., Kremer, S., and Ryan, M. D. (2008).</p>
    <p>Verifying privacy-type properties of electronic voting protocols. Journal of Computer Security. To appear.</p>
  </div>
  <div class="page">
    <p>Bibliography</p>
    <p>References IV</p>
    <p>Lowe, G. (1996).</p>
    <p>Breaking and fixing the Needham-Schroeder public-key protocol using FDR. In Tools and Algorithms for the Construction and Analysis of Systems (TACAS96), volume 1055 of LNCS, pages 147166. Springer-Verlag.</p>
    <p>Millen, J. and Shmatikov, V. (2001).</p>
    <p>Constraint solving for bounded-process cryptographic protocol analysis. In 8th ACM Conference on Computer and Communications Security (CCS01).</p>
  </div>
</Presentation>
