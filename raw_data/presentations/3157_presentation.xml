<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Succinct non-interactive zero knowledge for a</p>
    <p>von Neumann architecture</p>
    <p>Eli Ben-Sasson Alessandro Chiesa</p>
    <p>Eran Tromer Madars Virza</p>
  </div>
  <div class="page">
    <p>A DB DB</p>
    <p>Im a manager at a hospital</p>
    <p>Im a researcher.</p>
    <p>,</p>
  </div>
  <div class="page">
    <p>A DB DB</p>
    <p>Im a manager at a hospital</p>
    <p>,</p>
    <p>Whats A(, )? DB</p>
  </div>
  <div class="page">
    <p>A DB</p>
    <p>Privacy.</p>
    <p>,</p>
  </div>
  <div class="page">
    <p>DB DB</p>
    <p>Verifiability. Privacy.</p>
    <p>A(, ) =  DB</p>
    <p>A ,</p>
  </div>
  <div class="page">
    <p>DB DB</p>
    <p>Verifiability. Privacy.</p>
    <p>,</p>
    <p>A(, ) =  DB</p>
    <p>There is a s.t. A(, ) = . DB DB 6</p>
    <p>A ,</p>
  </div>
  <div class="page">
    <p>DB DB</p>
    <p>h=H( ) DB</p>
    <p>Verifiability. Privacy.</p>
    <p>,</p>
    <p>A(, ) =  DB</p>
    <p>There is a s.t. A(, ) = . DB DB 7</p>
    <p>A ,</p>
    <p>Check: H( )=h DB</p>
  </div>
  <div class="page">
    <p>argument</p>
    <p>A ,</p>
    <p>,</p>
    <p>There is a  s.t. A(, ) = .</p>
    <p>non-interactive</p>
    <p>zero knowledge succinct</p>
    <p>of knowledge</p>
    <p>(zk)SNARK NIZK</p>
    <p>Prover Verifier</p>
  </div>
  <div class="page">
    <p>A ,</p>
    <p>,</p>
    <p>Prover Verifier</p>
    <p>Generator</p>
    <p>Once: initial trusted step</p>
    <p>SNARKs require setup</p>
    <p>CRS</p>
    <p>Many times</p>
  </div>
  <div class="page">
    <p>A ,</p>
    <p>,</p>
    <p>Once: initial trusted step</p>
    <p>SNARKs require setup</p>
    <p>CRS</p>
    <p>Many times</p>
  </div>
  <div class="page">
    <p>[Parno Gentry Howell Raykova 13] [Ben-Sasson Chiesa Genkin Tromer Virza 13] [Braun Feldman Ren Setty Blumberg Walfish 13]</p>
    <p>Prior work on SNARKs</p>
    <p>SNARKs are practically feasible for certain applications!</p>
    <p>Application example: Zerocash relies on a SNARK</p>
    <p>(i) Theoretical constructions</p>
    <p>(ii) Working prototypes</p>
    <p>[Kilian 92] [Micali 94] [Di Crescenzo Lipmaa 08] [Groth 10] [Goldwasser Lin Rubinstein 11] [Lipmaa 12] [Bitansky Chiesa 12] [Bitansky Canetti Chiesa Tromer 12] [Damgrd Faust Hazay 12] [Gennaro Gentry Parno Raykova 13] [Bitansky Chiesa Ishai Ostrovsky Paneth 13]</p>
    <p>[Ben-Sasson Chiesa Garman Green Miers Tromer Virza 2014]</p>
    <p>for a tailored program that only has to check SHA256 computations and integer arithmetic.</p>
  </div>
  <div class="page">
    <p>CRS</p>
    <p>Generator</p>
    <p>Program-specific SNARKs</p>
    <p>Inconvenient: must repeat trusted setup for each</p>
    <p>Ideally: one-time trusted setup that works for any</p>
    <p>Currently: all prior implementations are program-specific</p>
  </div>
  <div class="page">
    <p>Goal: SNARKs with universal trusted setup</p>
    <p>Fix  = interpreter for Python!</p>
    <p>Naive approach:</p>
  </div>
  <div class="page">
    <p>Goal: SNARKs with universal trusted setup</p>
    <p>Fix  = interpreter for Python!</p>
    <p>Naive approach:</p>
  </div>
  <div class="page">
    <p>Our results:</p>
    <p>Both are significantly more efficient than prior work.</p>
    <p>We do so via two independent contributions:</p>
    <p>Goal: SNARKs with universal trusted setup</p>
    <p>Achieve the above goal. *</p>
    <p>(* whenever the computation is suitably bounded)</p>
    <p>Performance for -step programs:</p>
    <p>Time(Prover) Space(Prover)</p>
  </div>
  <div class="page">
    <p>... and create small circuit that can verify any program.</p>
    <p>The high-level picture</p>
    <p>CRS</p>
    <p>Generator</p>
    <p>Best theoretical constructions achieve SNARKs for circuits.</p>
    <p>So we build a highly optimized SNARK for circuits  Circuit</p>
    <p>generator</p>
    <p>: C(A, x, w, z,) = 1</p>
    <p>Contribution 2:</p>
    <p>Contribution 1:</p>
  </div>
  <div class="page">
    <p>Contribution 1: Universal circuit generator</p>
  </div>
  <div class="page">
    <p>Circuit generator</p>
    <p>program size bound  input size bound</p>
    <p>time bound  ,,</p>
    <p>,,,,</p>
    <p>= 1 iff  , =</p>
    <p>Universal.</p>
    <p>Efficient. Asymptotically: |,,| =   +  +  log  +  +</p>
    <p>Expressive.</p>
    <p>(can even support self-modifying code and JIT!)</p>
    <p>* = provided that:   ,   , Time()</p>
    <p>Concretely: ,, /  2000 for reasonable bounds</p>
  </div>
  <div class="page">
    <p>Our circuit generator</p>
    <p>ALU</p>
    <p>t registers</p>
    <p>Check ALU instructions in the straightforward way</p>
    <p>Circuit checks trace of a RAM computation, as follows:</p>
    <p>[BCGTV13]: use multiplexer</p>
    <p>ALU</p>
    <p>ALU</p>
    <p>ALU</p>
    <p>ALU</p>
    <p>MUX MUX MUX MUX MUX MUX</p>
    <p>Cost: (  )! 19</p>
    <p>(based on [BCGTV13])</p>
  </div>
  <div class="page">
    <p>Check ALU instructions in the straightforward way</p>
    <p>Our circuit generator</p>
    <p>ALU</p>
    <p>t registers</p>
    <p>Circuit checks trace of a RAM computation, as follows:</p>
    <p>Perform instruction fetch using non-deterministic routing</p>
    <p>Check read/write instructions using same routing network</p>
    <p>ALU</p>
    <p>ALU</p>
    <p>ALU</p>
    <p>ALU</p>
    <p>Cost: 2 log(  + ) 20</p>
    <p>(based on [BCGTV13])</p>
  </div>
  <div class="page"/>
  <div class="page"/>
  <div class="page"/>
  <div class="page">
    <p>(a) dissect program  into components (loops, branches, )</p>
    <p>(b) separately translate each component into a subcircuit</p>
    <p>Most circuit generators use program analysis: Fairplay</p>
    <p>FairplayMP Ginger Zaatar</p>
    <p>Pinocchio Pantry</p>
    <p>[Malkhi Nisan Pinkas Sella 04] [Ben-David Nisan Pinkas 08]</p>
    <p>[Setty Vu Panpalia Braun Blumberg Walfish 12] [Setty Braun Vu Blumberg Parno Walfish 12]</p>
    <p>[Parno Gentry Howell Raykova 13] [Braun Feldman Ren Setty Blumberg Walfish 13]</p>
    <p>Comparison with program analysis</p>
    <p>Not universal (must know  in advance)</p>
    <p>How to compare?</p>
    <p>Efficiency varies from  to  hard to characterize.</p>
    <p>Roughly, very efficient for circuit-like programs; less efficient for memory-intensive programs.</p>
  </div>
  <div class="page">
    <p>Contribution 2: SNARK implementation for circuits</p>
  </div>
  <div class="page">
    <p>SNARK implementation for circuits  Theoretical protocol based on [PGHR13]</p>
    <p>Generator Prover</p>
    <p>T im</p>
    <p>e (</p>
    <p>s)</p>
    <p>Verifier</p>
    <p>T im</p>
    <p>e (</p>
    <p>m s)</p>
    <p>Pinocchio</p>
    <p>This work</p>
    <p>For 106-gate circuit and 1000-bit input:</p>
    <p>Tailored choices at every level of stack: Finite fields, elliptic curves, pairings, multi-exponentiation, interpolation.</p>
  </div>
  <div class="page">
    <p>libsnark: our SNARK implementation</p>
    <p>github.com/scipr-lab/libsnark</p>
    <p>Open source</p>
    <p>Time to create Zerocash transaction: libsnark</p>
    <p>Practical impact</p>
  </div>
  <div class="page">
    <p>One-time trusted setup to verify any computation in zero-knowledge.</p>
    <p>Universality:</p>
    <p>Fastest zk-SNARK for circuits.</p>
    <p>Efficiency:</p>
    <p>Look at libsnark and come talk to us!</p>
    <p>Applications:</p>
  </div>
  <div class="page">
    <p>Research sponsored by:</p>
    <p>Thank you! ePrint 2013/879</p>
  </div>
  <div class="page"/>
  <div class="page"/>
  <div class="page">
    <p>Case study: memcpy with JIT compilation memcpy(void *dest, const void *src, size_t n)</p>
    <p>Trivial as a circuit only for fixed src, dest and n.</p>
    <p>... _copy: load.b reg, [src] store.b [dest], reg add src, src, 1 add dest, dest, 1 sub n, n, 1 cnjmp _copy ...</p>
    <p>Can be eliminated when unrolling</p>
    <p>With JIT:  Use Newtons method to</p>
    <p>calculate  = 2 7  Unroll regular code k times</p>
    <p>Jump to the generated code</p>
    <p>Total cost:  4 + 11.48  Total cost:  6</p>
  </div>
</Presentation>
