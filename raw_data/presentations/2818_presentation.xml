<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>NetBouncer: Active Device and Link Failure Localization in Data Center Networks</p>
    <p>Cheng Tan1, Ze Jin2, Chuanxiong Guo3, Tianrong Zhang4,</p>
    <p>Haitao Wu5, Karl Deng4, Dongming Bi4, and Dong Xiang4</p>
  </div>
  <div class="page">
    <p>Anna Network operator</p>
  </div>
  <div class="page">
    <p>Anna Network operator</p>
    <p>Customers</p>
    <p>Unstable network High latency Low throughput</p>
  </div>
  <div class="page">
    <p>Spine</p>
    <p>Leaf</p>
    <p>ToR</p>
    <p>Servers</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>Spine</p>
    <p>Leaf</p>
    <p>ToR</p>
    <p>Servers</p>
    <p>?</p>
    <p>x</p>
    <p>Traditional monitoring system queries switches (e.g., SNMP)</p>
  </div>
  <div class="page">
    <p>Spine</p>
    <p>Leaf</p>
    <p>ToR</p>
    <p>Servers</p>
    <p>OK</p>
  </div>
  <div class="page">
    <p>Spine</p>
    <p>Leaf</p>
    <p>ToR</p>
    <p>Servers</p>
    <p>OK</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>Spine</p>
    <p>Leaf</p>
    <p>ToR</p>
    <p>Servers</p>
    <p>OK</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>Spine</p>
    <p>Leaf</p>
    <p>ToR</p>
    <p>Servers</p>
    <p>OK</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>Spine</p>
    <p>Leaf</p>
    <p>ToR</p>
    <p>Servers</p>
    <p>??</p>
    <p>?</p>
    <p>??</p>
    <p>? ? OK</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>Spine</p>
    <p>Leaf</p>
    <p>ToR</p>
    <p>Servers</p>
    <p>??</p>
    <p>?</p>
    <p>??</p>
    <p>? ? OK</p>
    <p>? hours days</p>
  </div>
  <div class="page">
    <p>This is a true story</p>
    <p>Root cause  A firmware bug on a switch link (bit flips of a fabric module)  It silently drops packets without any signal</p>
    <p>Gray failure*  Differential observability  Cause major cloud breakdowns  Localizing gray failures is essential for high availability</p>
    <p>*Huang et al. Gray Failure: The Achilles Heel of Cloud-Scale Systems. HotOS17</p>
    <p>OK</p>
  </div>
  <div class="page">
    <p>Why yet another monitoring system?</p>
    <p>Our response to network gray failures is NetBouncer</p>
    <p>Indeed, many monitoring systems  Academia: LossRadar, Trumpet, deTector, Netscope,   Industry: Pingmesh, NetNORAD, 007, Passive probing,</p>
    <p>In production, there are four requirements: 1. Catch gray failures---from a servers perspective</p>
  </div>
  <div class="page">
    <p>NetBouncer overview</p>
    <p>Spine</p>
    <p>Leaf</p>
    <p>ToR</p>
    <p>Servers</p>
    <p>NetBouncer is an active probing system which infers failures from path probing data.</p>
    <p>Controller Processor Network topology</p>
    <p>Link failure</p>
    <p>Device failure</p>
    <p>Path probing dataProbing plan</p>
    <p>NetBouncer is an active probing system which infers failures from path probing data.NetBouncer is an active probing system which infers failures from path probing data.NetBouncer is an active probing system which infers failures from path probing data</p>
  </div>
  <div class="page">
    <p>Rest of the talk</p>
    <p>How to achieve light-weight and explicit probing?</p>
    <p>Which paths should be probed?</p>
  </div>
  <div class="page">
    <p>Rest of the talk</p>
    <p>How to achieve light-weight and explicit probing?</p>
    <p>How to design an eligible probing plan?</p>
  </div>
  <div class="page">
    <p>Active probing system requires explicit and efficient probing</p>
    <p>Server can choose which links to evaluate with explicit probing  NetBouncer uses IP-in-IP to explicitly probe a path</p>
    <p>IP-in-IP forwarding is implemented in hardware.</p>
  </div>
  <div class="page">
    <p>Active probing system requires explicit and efficient probing</p>
    <p>Server can choose which links to evaluate with explicit probing  NetBouncer uses IP-in-IP to explicitly probe a path</p>
    <p>IP-in-IP forwarding is implemented in hardware.</p>
    <p>A server asks a switch to bounce back probing packets  Simple model and simple fault tolerance</p>
  </div>
  <div class="page">
    <p>Which paths should be probed?</p>
    <p>How to achieve light-weight and explicit probing?</p>
    <p>How to infer failures from path probing data?</p>
  </div>
  <div class="page">
    <p>Observation vs. inference: from path probing to failures</p>
  </div>
  <div class="page">
    <p>Observation vs. inference: from path probing to failures</p>
    <p>Undirected graph (vertex=device, edge=link)  Failures are probabilistic</p>
  </div>
  <div class="page">
    <p>Observation vs. inference: from path probing to failures</p>
    <p>Undirected graph (vertex=device, edge=link)  Failures are probabilistic</p>
    <p>observation</p>
    <p>goal: is this link faulty?</p>
  </div>
  <div class="page">
    <p>Observation vs. inference: from path probing to failures</p>
    <p>Undirected graph (vertex=device, edge=link)  Failures are probabilistic</p>
    <p>observation</p>
    <p>goal: is this link faulty?</p>
    <p>possibility 1</p>
    <p>possibility 2</p>
    <p>possibility 3</p>
  </div>
  <div class="page">
    <p>Observation vs. inference: from path probing to failures</p>
    <p>?</p>
    <p>possibility 1</p>
    <p>possibility 2</p>
    <p>possibility 3</p>
  </div>
  <div class="page">
    <p>Observation vs. inference: from path probing to failures</p>
    <p>Infer the link success probabilities from path probing observations  Report links as faulty with success probability &lt; threshold (e.g., 99%)</p>
    <p>?100%</p>
    <p>possibility 1</p>
    <p>possibility 2</p>
    <p>possibility 3</p>
  </div>
  <div class="page">
    <p>Observation vs. inference: from path probing to failures</p>
    <p>Infer the link success probabilities from path probing observations  Report links as faulty with success probability &lt; threshold</p>
    <p>possibility 1</p>
    <p>possibility 3</p>
    <p>possibility 2</p>
    <p>?100%</p>
    <p>Which paths should be probed, s.t. all link success probabilities can be uniquely determined?</p>
  </div>
  <div class="page">
    <p>Real-world constraints complicate path selection</p>
    <p>Constraint 1: some switches may not bounce the probing  Constraint 2: a probing path starts/ends at the same server</p>
    <p>Sometimes, it is impossible to uniquely identify all links</p>
  </div>
  <div class="page">
    <p>Real-world constraints complicate path selection</p>
    <p>Constraint 1: some switches may not bounce the probing  Constraint 2: a probing path starts/ends at the same server</p>
    <p>Sometimes, it is impossible to uniquely identify all links</p>
    <p>x1 x2</p>
    <p>x3 x4</p>
  </div>
  <div class="page">
    <p>Real-world constraints complicate path selection</p>
    <p>Constraint 1: some switches may not bounce the probing  Constraint 2: a probing path starts/ends at the same server</p>
    <p>Sometimes, it is impossible to uniquely identify all links</p>
    <p>x1 x2</p>
    <p>x3 x4</p>
    <p>y1= x1 x3</p>
  </div>
  <div class="page">
    <p>Real-world constraints complicate path selection</p>
    <p>Constraint 1: some switches may not bounce the probing  Constraint 2: a probing path starts/ends at the same server</p>
    <p>Sometimes, it is impossible to uniquely identify all links</p>
    <p>x1 x2</p>
    <p>x3 x4</p>
    <p>y1= x1  x3</p>
    <p>y2= x1  x4</p>
    <p>y3= x2  x3</p>
    <p>y4= x2  x4</p>
    <p>y1  y4 = y2  y3</p>
  </div>
  <div class="page">
    <p>Real-world constraints complicate path selection</p>
    <p>Constraint 1: some switches may not bounce the probing  Constraint 2: a probing path starts/ends at the same server</p>
    <p>Sometimes, it is impossible to uniquely identify all links</p>
    <p>x1 x2</p>
    <p>x3 x4</p>
    <p>y1= x1  x3</p>
    <p>y2= x1  x4</p>
    <p>y3= x2  x3</p>
    <p>y4= x2  x4</p>
    <p>y1  y4 = y2  y3</p>
    <p>log(y1) = log(x1)+log(x3) log(y2) = log(x1)+log(x4) log(y3) = log(x2)+log(x3) log(y4) = log(x2)+log(x4)</p>
    <p>Not full rank</p>
  </div>
  <div class="page">
    <p>Real-world constraints complicate path selection</p>
    <p>Constraint 1: some switches may not bounce the probing  Constraint 2: a probing path starts/ends at the same server</p>
    <p>Sometimes, it is impossible to uniquely identify all links</p>
    <p>x1 x2</p>
    <p>x3 x4</p>
    <p>y1= x1  x3</p>
    <p>y2= x1  x4</p>
    <p>y3= x2  x3</p>
    <p>y4= x2  x4</p>
    <p>y1  y4 = y2  y3</p>
    <p>log(y1) = log(x1)+log(x3) log(y2) = log(x1)+log(x4) log(y3) = log(x2)+log(x3) log(y4) = log(x2)+log(x4)</p>
    <p>Not full rank</p>
    <p>Links success probabilities (x1-x4) can be arbitrary</p>
  </div>
  <div class="page">
    <p>A condition to uniquely identify link success probabilities</p>
    <p>We proved a theorem (for Clos network), that provides  a simple probing plan: each server probes all top-layer switches  a necessary and sufficient condition for uniquely identifying P(link)</p>
  </div>
  <div class="page">
    <p>A condition to uniquely identify link success probabilities</p>
    <p>We proved a theorem (for Clos network), that provides  a simple probing plan: each server probes all top-layer switches  a necessary and sufficient condition for uniquely identifying P(link)</p>
    <p>each node has at least one good path through it</p>
    <p>Good path (no loss)</p>
    <p>Lossy path</p>
  </div>
  <div class="page">
    <p>Subgraph with unique solutionOriginal graph Unsolvable part</p>
    <p>No good paths pass this switch</p>
  </div>
  <div class="page">
    <p>Device failure detection</p>
    <p>Subgraph with unique solutionOriginal graph Unsolvable partFaulty devices</p>
    <p>No good paths pass this switch</p>
  </div>
  <div class="page">
    <p>Device failure detection</p>
    <p>Subgraph with unique solutionOriginal graph Unsolvable partFaulty devices</p>
    <p>No good paths pass this switch</p>
    <p>How to infer the link failures from this subgraph?</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>How to infer the link failures from the solvable subgraph?</p>
    <p>How to achieve light-weight and explicit probing?</p>
    <p>Which paths should be probed?</p>
  </div>
  <div class="page">
    <p>Link failure inference: an optimization problem</p>
    <p>Given the path probing data (yj), how to infer the link success probabilities (xi) that fits them the best?</p>
    <p>y1= 50/100 = x1  x2  x3</p>
    <p>x1</p>
    <p>x2</p>
    <p>x3</p>
    <p>Assume packet drops are independent events.</p>
  </div>
  <div class="page">
    <p>Real-world data inconsistency induces false positives</p>
  </div>
  <div class="page">
    <p>Real-world data inconsistency induces false positives</p>
  </div>
  <div class="page">
    <p>Real-world data inconsistency induces false positives</p>
    <p>False positive50%</p>
  </div>
  <div class="page">
    <p>Real-world data inconsistency  Measurements do not fully align  Inference results may overfit observations</p>
    <p>Real-world data inconsistency induces false positives</p>
    <p>False positive50%</p>
  </div>
  <div class="page">
    <p>Real-world data inconsistency  Measurements do not fully align  Inference results may overfit observations</p>
    <p>Solution: a specialized regularization</p>
    <p>Real-world data inconsistency induces false positives</p>
    <p>False positive</p>
    <p>better</p>
  </div>
  <div class="page">
    <p>Evaluation questions</p>
    <p>In production, what failures have been detected by NetBouncer?  One real case, more in paper</p>
    <p>How accurate is NetBouncer compared with previous algorithms?</p>
    <p>Whats the performance of NetBouncers algorithm?</p>
  </div>
  <div class="page">
    <p>Observations  Many customers experienced packet drops and latency increases  Traditional monitoring systems cannot pinpoint the failure</p>
    <p>NetBouncer detected this gray failure  One spine router silently dropped packets  Root cause was an issue in one of this</p>
    <p>switchs linecard hardware</p>
    <p>Real case: spine router gray failure</p>
    <p>time</p>
  </div>
  <div class="page">
    <p>Accuracy comparison with previous algorithms  Simulation setup:</p>
    <p>3-layer Clos network with 2.8K switches (48 ports), 27.6K servers and 82.9K links  1% faulty links and 10 faulty devices</p>
    <p>Compare with two algorithms: deTector and NetScope</p>
    <p>#false negative #false positive 7.2k 10.8k</p>
    <p>Hit ratio=0.6 Hit ratio=0.9 =0.1 = 1 = 10</p>
    <p>deTector NetScope</p>
    <p>NetBouncer (=1)</p>
    <p>Cannot guarantee zero-FP/FN; has FP/FN in other experiments</p>
    <p>Number of FP/FN</p>
    <p>better</p>
  </div>
  <div class="page">
    <p>NetBouncer algorithm performance</p>
    <p>Xeon E5 2.4GHz CPU with 128GB memory  One hour trace from 2016 (~130GB)</p>
  </div>
  <div class="page">
    <p>Related work</p>
    <p>Network tomography  Internet failure localization: NetScope, LIA, NetQuest  Heuristic algorithm: Tomo, detector  Require further investigation: Pingmesh, NetSonar, NetNorad</p>
    <p>Other troubleshooting systems  Panorama , Deepview, 007  Trumpet, LossRadar</p>
    <p>Explicit path probing  XPath and other source routing</p>
    <p>Probing plan design  Focus on minimizing number of paths</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>A complete framework for data center network failure localization  An efficient path probing scheme  A necessary and sufficient condition for an eligible probing plan  A link failure inference algorithm</p>
    <p>NetBouncer has been deployed for three years and performs well</p>
  </div>
</Presentation>
