<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>A Lattice Theory for Solving Games of</p>
    <p>Imperfect Information</p>
    <p>Martin De Wulf, Laurent Doyen, and Jean-Franois Raskin</p>
    <p>HSCC06 - March 31st - Santa Barbara,CA</p>
  </div>
  <div class="page">
    <p>Motivation</p>
    <p>Controller Generation</p>
    <p>Two-Player Games :  Controller = Player 1  Environment = Player 2</p>
    <p>We are looking for a winning strategy for Player 1</p>
    <p>? || Env avoid Bad</p>
    <p>Controller</p>
  </div>
  <div class="page">
    <p>Imperfect Information = Finite Precision</p>
    <p>(c ! 1, c + 1) The temperature is in the interval</p>
    <p>Typical Hybrid System</p>
  </div>
  <div class="page">
    <p>b</p>
    <p>a</p>
    <p>b</p>
    <p>c</p>
    <p>b | a</p>
    <p>b | c</p>
    <p>a | c</p>
    <p>A Game Example</p>
    <p>Player 1 chooses a letter Player 2 resolves nondeterminism</p>
  </div>
  <div class="page">
    <p>b</p>
    <p>a</p>
    <p>b</p>
    <p>c</p>
    <p>b | a</p>
    <p>b | c</p>
    <p>a | c</p>
    <p>Imperfect Observations</p>
    <p>Obs 1</p>
    <p>One observation, many possible states</p>
  </div>
  <div class="page">
    <p>b</p>
    <p>a</p>
    <p>b</p>
    <p>c</p>
    <p>b | a</p>
    <p>b | c</p>
    <p>a | c</p>
    <p>Imperfect Observations</p>
    <p>Obs 1</p>
    <p>Obs 2</p>
    <p>One state, many possible observations</p>
  </div>
  <div class="page">
    <p>Memory is needed to win</p>
    <p>Player 1 cannot win with a strategy based only on the current</p>
    <p>observation</p>
    <p>Obs 1</p>
    <p>b</p>
    <p>a</p>
    <p>b</p>
    <p>c</p>
    <p>b | a</p>
    <p>b | c</p>
    <p>a | c</p>
  </div>
  <div class="page">
    <p>Games / Strategies</p>
    <p>Our objective is to find an algorithm to construct strategies that avoid a set of Bad states.</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A )= B &amp; q we have A )$ B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [*] Let q, q! &amp; 22 S</p>
    <p>and define q * q! if and only if</p>
    <p>'s &amp; q : %s! &amp; q! : s $ s!</p>
    <p>.</p>
    <p>!L, *# is a complete lattice. The minimal element is +, the maximal element {S}.</p>
  </div>
  <div class="page">
    <p>Games / Strategies</p>
    <p>Our objective is to find an algorithm to construct strategies that avoid a set of Bad states.</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A )= B &amp; q we have A )$ B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [*] Let q, q! &amp; 22 S</p>
    <p>and define q * q! if and only if</p>
    <p>'s &amp; q : %s! &amp; q! : s $ s!</p>
    <p>.</p>
    <p>!L, *# is a complete lattice. The minimal element is +, the maximal element {S}.</p>
    <p>Those games generalize games of perfect information where and is the identity function</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A )= B &amp; q we have A )$ B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [*] Let q, q! &amp; 22 S</p>
    <p>and define q * q! if and only if</p>
    <p>'s &amp; q : %s! &amp; q! : s $ s!</p>
    <p>.</p>
    <p>!L, *# is a complete lattice. The minimal element is +, the maximal element {S}.</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A )= B &amp; q we have A )$ B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [*] Let q, q! &amp; 22 S</p>
    <p>and define q * q! if and only if</p>
    <p>'s &amp; q : %s! &amp; q! : s $ s!</p>
    <p>.</p>
    <p>!L, *# is a complete lattice. The minimal element is +, the maximal element {S}.</p>
  </div>
  <div class="page">
    <p>Games / Strategies</p>
    <p>Our objective is to find an algorithm to construct strategies that avoid a set of Bad states.</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A )= B &amp; q we have A )$ B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [*] Let q, q! &amp; 22 S</p>
    <p>and define q * q! if and only if</p>
    <p>'s &amp; q : %s! &amp; q! : s $ s!</p>
    <p>.</p>
    <p>!L, *# is a complete lattice. The minimal element is +, the maximal element {S}.</p>
    <p>Those games generalize games of perfect information where and is the identity function</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A )= B &amp; q we have A )$ B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [*] Let q, q! &amp; 22 S</p>
    <p>and define q * q! if and only if</p>
    <p>'s &amp; q : %s! &amp; q! : s $ s!</p>
    <p>.</p>
    <p>!L, *# is a complete lattice. The minimal element is +, the maximal element {S}.</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A )= B &amp; q we have A )$ B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [*] Let q, q! &amp; 22 S</p>
    <p>and define q * q! if and only if</p>
    <p>'s &amp; q : %s! &amp; q! : s $ s!</p>
    <p>.</p>
    <p>!L, *# is a complete lattice. The minimal element is +, the maximal element {S}.</p>
    <p>Those games generalize games of incomplete information: in that case Obs partitions the state space S. [Rei84]</p>
  </div>
  <div class="page">
    <p>Classical Approaches</p>
    <p>For games of perfect information :  fixed point algorithm using a controllable</p>
    <p>predecessor operator</p>
    <p>For games of incomplete information  [Reif84] build a game of perfect information</p>
    <p>using a kind of subset construction</p>
  </div>
  <div class="page">
    <p>(i) s does not intersect with Bad, (ii) there exists s.t. the set of possible successors of s by is covered by q (a) no matter how the adversary resolves non-determinism, (b) no matter the compatible observation Obs</p>
    <p>A fixed point algorithm We define a controllable predecessor operator for a set of sets of states q</p>
    <p>CPre(q) = {s ! Bad | &quot;! # &quot;  $obs # Obs  &quot;s! # q : Post!(s) % #(obs) ! s!}</p>
    <p>CPre(q) = &amp;{s ! Bad | &quot;! # &quot;  $obs # Obs  &quot;s! # q : Post!(s) % #(obs) ! s!}'</p>
    <p>Here we drop the assumption that S is finite. Let R = {r1, r2, . . . , rl} be a finite partition of S.</p>
    <p>Definition 6 [R-stable] A game of imperfect information !S, S0, !, &quot;, Obs, &quot;# is R-stable if for every # $ ! the following conditions hold:</p>
    <p>(i) Enabled(#) is R-definable; (ii) for every r $ R, Post!(r) is R-definable;</p>
    <p>(iii) for any r, r! $ R, if for some x $ r , Post!({x}) % r! &amp;= ' then for any x $ r, Post!({x}) % r! &amp;= ';</p>
    <p>(iv) furthermore, for every obs $ Obs, &quot;(obs) is R-definable.</p>
    <p>Theorem 1. Let G = !S, S0, !, &quot;, Obs, &quot;# be a R-stable game of imperfect information. The greatest fixed point of CPre is a R-definable antichain and is computable.</p>
    <p>Here we drop the assumption that S is finite. Let R = {r1, r2, . . . , rl} be a finite partition of S.</p>
    <p>Definition 6 [R-stable] A game of imperfect information !S, S0, !, &quot;, Obs, &quot;# is R-stable if for every # $ ! the following conditions hold:</p>
    <p>(i) Enabled(#) is R-definable; (ii) for every r $ R, Post!(r) is R-definable;</p>
    <p>(iii) for any r, r! $ R, if for some x $ r , Post!({x}) % r! &amp;= ' then for any x $ r, Post!({x}) % r! &amp;= ';</p>
    <p>(iv) furthermore, for every obs $ Obs, &quot;(obs) is R-definable.</p>
    <p>Theorem 1. Let G = !S, S0, !, &quot;, Obs, &quot;# be a R-stable game of imperfect information. The greatest fixed point of CPre is a R-definable antichain and is computable.</p>
  </div>
  <div class="page">
    <p>a</p>
    <p>b</p>
    <p>b</p>
    <p>c</p>
    <p>c</p>
    <p>b</p>
    <p>b</p>
    <p>Example</p>
    <p>q ={A, B}</p>
    <p>Obs 1</p>
    <p>Obs 2</p>
  </div>
  <div class="page">
    <p>a</p>
    <p>b</p>
    <p>b</p>
    <p>c</p>
    <p>c</p>
    <p>b</p>
    <p>b</p>
    <p>Obs 1</p>
    <p>Obs 2</p>
    <p>Cpre({A,B})= Blue sets</p>
    <p>Example</p>
    <p>q ={A, B}</p>
  </div>
  <div class="page">
    <p>a</p>
    <p>b</p>
    <p>b</p>
    <p>c</p>
    <p>c</p>
    <p>b</p>
    <p>b</p>
    <p>Maximal sets</p>
    <p>It is enough to keep only the maximal sets</p>
    <p>If there is a strategy for set A, there is a strategy for any B included in A</p>
    <p>CPre(q) = {s ! Bad | &quot;! # &quot;  $obs # Obs  &quot;s! # q : Post!(s) % #(obs) ! s!}</p>
    <p>CPre(q) = [{s ! Bad | &quot;! # &quot;  $obs # Obs  &quot;s! # q : Post!(s) % #(obs) ! s!}]</p>
  </div>
  <div class="page">
    <p>Antichains</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %$ &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
  </div>
  <div class="page">
    <p>CPre over antichains</p>
    <p>CPre is a monotone function over the lattice of antichains</p>
    <p>CPre has a least and a greatest fixed point</p>
    <p>Advantage : we only keep the needed information to find a strategy</p>
    <p>CPre(q) = {s ! Bad | &quot;! # &quot;  $obs # Obs  &quot;s! # q : Post!(s) % #(obs) ! s!}</p>
    <p>CPre(q) = [{s ! Bad | &quot;! # &quot;  $obs # Obs  &quot;s! # q : Post!(s) % #(obs) ! s!}]</p>
  </div>
  <div class="page">
    <p>Controllable predecessors For q ! L, define the set of controllable predecessors of q as follows:</p>
    <p>CPre(q) = [{s &quot; S | #! ! &quot;c : s &quot; Enabled(!)</p>
    <p>$%obs ! Obs, #s! ! q : Post!u (Post&quot;(s)) &amp; #(obs) &quot; s !}]</p>
    <p>Let us consider an antichain q = {s!0, s ! 1, . . . }. A set s belongs to CPre(q) iff (i) there</p>
    <p>is a controllable action ! that is enabled in each state of s, (ii) when the controller plays !, any observation compatible with the next state reached by the game (after the environmenthas played) suffices to determine in which set s!i of q that next state lies</p>
    <p>and (iii) s is maximal .</p>
    <p>Lemma 11 The operator CPre : L ' L is monotone for the partial ordering (.</p>
    <p>Remark The controllablepredecessoroperator is also monotone w.r.t. the set of obser</p>
    <p>vations in the following sense: given a two-player game G, let CPre1 (resp. CPre2) be the operator defined on the set of observations (Obs1, #1) (resp. (Obs2, #2)). If {#2(obs) | obs ! Obs2} ( {#1(obs) | obs ! Obs1}, then for any q ! L we have CPre1(q) ( CPre2(q). That corresponds to the informal statement that it is easier to control a system with more precise observations.</p>
    <p>Theorem 12 Let G = )S, S0, &quot; c, &quot;u, ', Obs, #* be a game of imperfect information.</p>
    <p>There exists an observation based strategy winning on G if and only if</p>
    <p>{S0 &amp; #(obs) | obs ! Obs} ( !</p>
    <p>{q | q = CPre(q)}. (1)</p>
    <p>Before proving this theorem, we give some intuition. We denote by Win the set &quot;</p>
    <p>{q | q = CPre(q)} which is the greatest fixed point of CPre. Condition (1) states that any observation of the initial state x0 suffices to determine in which set s of Win the game has been started. Since Win is a fixed point of the controllable predecessor operator, we know that in each set s of Win we have a controllable action that can be played by the controller in every state x ! s such that (i) the state z reached after the move of the environment lies in one of the sets s! of Win whatever the environment does and, such that (ii) the set s! can be determined using any observation compatible with z. Following this, there exists a winning strategy if Condition (1) holds. The other direction of the theorem is a direct consequence of Tarskis Theorem.</p>
    <p>Proof ofTheorem 12.</p>
    <p>First, we give an effective construction of a winning strategy for G. For q ! L and ! ! &quot;c, let $(q, !) = [{s ! S | s &quot; Enabled(!) and %obs ! Obs, #s! ! q : Post!u (Post&quot;(s)) &amp; #(obs) &quot; s</p>
    <p>!}] be the set of controllable predecessors of q for the action !. From the greatest fixed point Win of CPre, we define the finite state automaton A = )Q, q0, L, %* where</p>
    <p>Q = Win + {q0} where q0 /! Win,</p>
    <p>new state, the condition holds trivially.</p>
    <p>Let G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %# &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %# &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>be a two-player game of imperfect information. Player 1 has a winning</p>
    <p>observation based strategy to avoid Bad, iff</p>
    <p>We can extract a strategy from the fixed point</p>
    <p>Main theorem</p>
  </div>
  <div class="page">
    <p>Complexity for finite state games</p>
    <p>The imperfect information control problem is EXPTIME-complete</p>
    <p>There exist finite state games of incomplete information for which the algorithm of [Rei84] requires an exponential time where our algorithm needs only polynomial time</p>
  </div>
  <div class="page">
    <p>Infinite state games We drop the assumption that S if finite</p>
    <p>We can use our fixed point algorithm if</p>
    <p>There exists a finite quotient of the state space</p>
    <p>Post, Enabled, are definable using this quotient</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S.</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Application : Discrete Time Control of RHA</p>
  </div>
  <div class="page">
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p># Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p># aa</p>
    <p>a b Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Discrete time control of RHA</p>
    <p>Player 1 (contr.) must choose an action every 1 time unit Player 2 (env.) resolves nondeterminism (in discrete and continuous steps).</p>
    <p>H : x &gt;=80</p>
    <p>L : x &lt;=85</p>
  </div>
  <div class="page">
    <p>Discrete time control of RHA</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p># Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p># aa</p>
    <p>a b Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>BAD</p>
    <p>Everything else</p>
  </div>
  <div class="page">
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p># Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p># aa</p>
    <p>a b Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Discrete time control of RHA</p>
    <p>H : x &gt;=80</p>
    <p>L : x &lt;=85</p>
  </div>
  <div class="page">
    <p>H</p>
    <p>L</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>a</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>H</p>
    <p>H</p>
    <p>L</p>
    <p>bL</p>
    <p>L</p>
    <p>L</p>
    <p>L L</p>
    <p>H</p>
    <p>L</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>L</p>
    <p>a</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p># Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p># aa</p>
    <p>a b Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>The Strategy</p>
  </div>
  <div class="page">
    <p>H</p>
    <p>L</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>a</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>H</p>
    <p>H</p>
    <p>L</p>
    <p>bL</p>
    <p>L</p>
    <p>L</p>
    <p>L L</p>
    <p>H</p>
    <p>L</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>L</p>
    <p>a</p>
    <p>The symbolic CPre can be encoded in the script language of HyTech</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p># Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p># aa</p>
    <p>a b Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Start x = 0</p>
    <p>x = 100</p>
    <p>x = 100</p>
    <p>Slow x ! [&quot;10, &quot;9]</p>
    <p>Fast x ! [&quot;30, &quot;25]</p>
    <p>Stop</p>
    <p>x = 0</p>
    <p>a</p>
    <p>a</p>
    <p># x $ 60</p>
    <p># x $ 60</p>
    <p>a</p>
    <p>x % 70</p>
    <p>b</p>
    <p>x % 70</p>
    <p>#</p>
    <p>Definition 1 [Two-player games] A two-player game is a tuple !S, S0, !, &quot;#.</p>
    <p>Definition 2 [Observation set] An observation set of S is a couple (Obs, &quot;) where &quot; : Obs &quot; 2S .</p>
    <p>Definition 3 [Observation based strategy] An observation based strategy is a function # : Obs+ &quot; !.</p>
    <p>$</p>
    <p>Obs = s G = !S, S0, !, &quot;, Obs, &quot;#</p>
    <p>CPre(q) = {s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}</p>
    <p>CPre(q) = [{s $ Bad | %% &amp; !  'obs &amp; Obs  %s! &amp; q : Post!(s) ( &quot;(obs) $ s!}]</p>
    <p>Definition 4 [Antichain of sets of states] An antichain on the partially ordered set !2S , $# is a set q $ 2S such that for any A, B &amp; q we have A )* B.</p>
    <p>Let us call L the set of antichains on S.</p>
    <p>Definition 5 [+] Let q, q! &amp; 22 S</p>
    <p>and define q + q! if and only if</p>
    <p>'A &amp; q : %A! &amp; q! : A $ A!</p>
    <p>.</p>
    <p>!L, +# is a complete lattice. The minimal element is ,, the maximal element {S}.</p>
  </div>
  <div class="page">
    <p>Conclusion/Perspectives</p>
    <p>A lattice theory to solve games of imperfect information, those games are needed to make the synthesis of robust controllers (= finite precision).</p>
    <p>Our technique computes only the needed information to find a strategy</p>
    <p>Applicable to discrete time control of RHA  Define games whose controllers are implementable  Are antichains useful for other purposes? The answer</p>
    <p>is YES</p>
  </div>
  <div class="page">
    <p>A Lattice Theory for Solving Games of Imperfect Information 167</p>
    <p>a</p>
    <p>!</p>
    <p>!</p>
    <p>!</p>
    <p>b</p>
    <p>a</p>
    <p>! q0 0</p>
    <p>H H</p>
    <p>L</p>
    <p>H</p>
    <p>L</p>
    <p>L</p>
    <p>L</p>
    <p>L</p>
    <p>H</p>
    <p>L</p>
    <p>H</p>
    <p>L</p>
    <p>H</p>
    <p>Fig. 4. A finite state automaton defining a winning strategy for the cooling system</p>
    <p>mode is Slow. If the first two observations are H, L then the controller knows that the mode is Fast.</p>
    <p>The greatest fixed point, given below, allows the computation of the deterministic strategy depicted in Fig. 4. The whole process has been automated in HYTECH. The correspondence between state numbers in the figure and states of the fixed point is the following:</p>
    <p>State 0 ! (Stop, x = 0), (Slow, 295 &lt; x &quot; 300)  State 1 ! (Slow, 270 &quot; x &quot; 300)  (Not depicted) State 2 ! (Slow, 295 &lt; x &quot; 300), (Fast, 290 &quot; x &quot; 300)  State 3 ! (Slow, 260 &quot; x &quot; 289), (Slow, 295 &lt; x &quot; 300)  State 4 ! (Slow, 295 &lt; x &quot; 300), (Fast, 260 &quot; x &quot; 295)  State 5 ! (Start, x = 300)  State 6 ! (Slow, 250 &quot; x &quot; 280)  State 7 ! (Fast, 210 &quot; x &quot; 270)</p>
    <p>As before, the strategy associates an action to each set of the fixed point and the observations give the next state of the strategy.</p>
    <p>References</p>
    <p>[ACH+95] R. Alur, C. Courcoubetis, N. Halbwachs, T.A. Henzinger, P.-H. Ho, X. Nicollin, A. Olivero, J. Sifakis, and S. Yovine. The algorithmic analysis of hybrid systems. Theoretical Computer Science, 138:334, 1995.</p>
    <p>[AD94] Rajeev Alur and David L. Dill. A theory of timed automata. Theoretical Computer Science, 126(2):183235, 1994.</p>
    <p>[AHK02] R. Alur, T.A. Henzinger, and O. Kupferman. Alternating-time temporal logic. Journal of the ACM, 49:672713, 2002.</p>
    <p>[CC77] Patrick Cousot and Radhia Cousot. Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. In POPL, pages 238252, 1977.</p>
    <p>[DDR06] M. De Wulf, L. Doyen, and J.-F. Raskin. A lattice theory for solving games of imperfect information (extended version). Technical Report 58, U.L.B.  Federated Center in Verification, 2006. http://www.ulb.ac.be/di/ssd/cfv/publications.html.</p>
    <p>[HHWT95] T.A. Henzinger, P.-H. Ho, and H. Wong-Toi. A user guide to HYTECH. In TACAS 95: Tools and Algorithms for the Construction and Analysis of Systems, Lecture Notes in Computer Science 1019, pages 4171. Springer-Verlag, 1995.</p>
    <p>[HK99] T.A. Henzinger and P.W. Kopke. Discrete-time control for rectangular hybrid automata. Theoretical Computer Science, 221:369392, 1999.</p>
    <p>[MPS95] O. Maler, A. Pnueli, and J. Sifakis. On the synthesis of discrete controllers for timed systems. In STACS95, volume 900 of Lecture Notes in Computer Science, pages 229242. Springer, 1995.</p>
    <p>[Rei84] John H. Reif. The complexity of two-player games of incomplete information. Journal of Computer and System Sciences, 29(2):274301, 1984.</p>
  </div>
</Presentation>
