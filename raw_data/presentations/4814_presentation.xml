<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Provably Correct Runtime Monitoring</p>
    <p>Irem Aktug, Mads Dam, Dilian Gurov</p>
    <p>CSC KTH Stockholm, Sweden</p>
    <p>Formal Methods 2008</p>
    <p>Provably Correct Runtime Monitoring 1</p>
  </div>
  <div class="page">
    <p>Runtime Monitoring</p>
    <p>A monitor operates by observing the behavior of a target program and terminating the program when an action that violates the policy is about to occur.</p>
    <p>A policy is a predicate on the set of all possible sequences of actions and selects only the acceptable sequences.</p>
    <p>Monitoring has been implemented in the following two ways:</p>
    <p>external monitoring: external entities that run in parallel with the target program (e.g. firewalls),</p>
    <p>monitor inlining: the program is rewritten to make it self-monitoring (e.g. memory sandboxing).</p>
    <p>Provably Correct Runtime Monitoring 2</p>
  </div>
  <div class="page">
    <p>Monitor Inlining</p>
    <p>General purpose monitor inlining has been introduced by Evans and Twyman 1999/Erlingsson and Schneider 2000.</p>
    <p>Monitor inlining is an active area of research:</p>
    <p>Bauer, Ligatti, Walker 2005 Hamlen, Morrisett 2006 Vanoverberghe, Piessens 2008 Hamlen, Jones 2008</p>
    <p>Yet correctness of inlining is a neglected issue.</p>
    <p>Provably Correct Runtime Monitoring 3</p>
  </div>
  <div class="page">
    <p>Provably Correct Inlining</p>
    <p>An inlined program is correctly inlined for policy P, if the inlined monitor is</p>
    <p>sound, and</p>
    <p>transparent.</p>
    <p>Provably Correct Runtime Monitoring 4</p>
  </div>
  <div class="page">
    <p>Provably Correct Inlining</p>
    <p>An inlined program is correctly inlined for policy P, if the inlined monitor is</p>
    <p>sound, and</p>
    <p>transparent.</p>
    <p>Our mission</p>
    <p>For a given inlined program, we want to create a proof of correct inlining such that:</p>
    <p>can be automatically generated,</p>
    <p>efficiently checkable.</p>
    <p>Provably Correct Runtime Monitoring 4</p>
  </div>
  <div class="page">
    <p>Provably Correct Inlining</p>
    <p>An inlined program is correctly inlined for policy P, if the inlined monitor is</p>
    <p>sound, and</p>
    <p>transparent.</p>
    <p>Our mission</p>
    <p>For a given inlined program, we want to create a proof of correct inlining such that:</p>
    <p>can be automatically generated,</p>
    <p>efficiently checkable.</p>
    <p>Our approach</p>
    <p>Use Floyd-like logic to specify correct inlining!</p>
    <p>Provably Correct Runtime Monitoring 4</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Target programs</p>
    <p>Enforceable policies and the policy language</p>
    <p>Monitor inlining</p>
    <p>A two-stage annotation scheme: 1 Stage 1 specifies policy adherence 2 Stage 2 specifies that the program contains a monitor</p>
    <p>Construction of correctness proofs for inlined programs</p>
    <p>Provably Correct Runtime Monitoring 5</p>
  </div>
  <div class="page">
    <p>Target Programs</p>
    <p>We consider java bytecode programs.</p>
    <p>Our security relevant actions are calls to and returns from a fixed API.</p>
    <p>We handle:</p>
    <p>only sequential programs, exception handling, and inheritance.</p>
    <p>Provably Correct Runtime Monitoring 6</p>
  </div>
  <div class="page">
    <p>Example: Target Program</p>
    <p>L M[L] L1 aload r0 L2 getfield gui L3 dup L4 astore r1 L5 invokevirtual GUI/AskConnect()Z L6 istore r2 L7 aload r1 L8 instanceof GUI L9 ifeq L12 L10 iload r2 L11 putstatic SecState/permission L12 iload r2 L13 ireturn</p>
    <p>Figure: A target application method</p>
    <p>Provably Correct Runtime Monitoring 7</p>
  </div>
  <div class="page">
    <p>Policies Security Automata [Schneider 2000]</p>
    <p>Dont send after read</p>
    <p>read</p>
    <p>send read</p>
    <p>s0 s1</p>
    <p>Figure: Security Automata for The Policy</p>
    <p>Provably Correct Runtime Monitoring 8</p>
  </div>
  <div class="page">
    <p>Policies Security Automata [Schneider 2000]</p>
    <p>Dont send after read</p>
    <p>read</p>
    <p>send read</p>
    <p>s0 s1</p>
    <p>send</p>
    <p>read</p>
    <p>send</p>
    <p>read, send</p>
    <p>Figure: Automata for The Policy</p>
    <p>Provably Correct Runtime Monitoring 8</p>
  </div>
  <div class="page">
    <p>Policies Example: ConSpec Language</p>
    <p>Applications are allowed to access existing files for reading only, and are required, once such a file has been accessed, to obtain</p>
    <p>approval from the user each time a connection is to be opened.</p>
    <p>Provably Correct Runtime Monitoring 9</p>
  </div>
  <div class="page">
    <p>Policies Example: ConSpec Language</p>
    <p>Applications are allowed to access existing files for reading only, and are required, once such a file has been accessed, to obtain</p>
    <p>approval from the user each time a connection is to be opened.</p>
    <p>p = T</p>
    <p>a = Fa = F</p>
    <p>p = F</p>
    <p>p = F</p>
    <p>a = T a = T</p>
    <p>p = T</p>
    <p>File.Open( , Read, OpenRead)</p>
    <p>File.Open( , CreateNew, )</p>
    <p>File.Open( , CreateNew, )</p>
    <p>File.Open( , CreateNew, ) File.Open( , CreateNew, )</p>
    <p>T = GUI.AskConnect( )</p>
    <p>Connection.Open( , )</p>
    <p>Connection.Open( , )</p>
    <p>F = GUI.AskConnect( )</p>
    <p>F = GUI.AskConnect()</p>
    <p>T = GUI.AskConnect()</p>
    <p>Connection.Open( , )</p>
    <p>F = GUI.AskConnect( )</p>
    <p>File.Open( , Read, OpenRead)</p>
    <p>File.Open( , Read, OpenRead)</p>
    <p>F = GUI.AskConnect( )</p>
    <p>File.Open( , Read, OpenRead) T = GUI.AskConnect( )</p>
    <p>T = GUI.AskConnect()</p>
    <p>Figure: Security Automata for The Policy Provably Correct Runtime Monitoring 9</p>
  </div>
  <div class="page">
    <p>Policies Example: ConSpec Language</p>
    <p>Applications are allowed to access existing files for reading only, and are required, once such a file has been accessed, to obtain</p>
    <p>approval from the user each time a connection is to be opened.</p>
    <p>SECURITY STATE</p>
    <p>bool accessed = false;</p>
    <p>bool permission = false;</p>
    <p>BEFORE File.Open(string path, string mode, string access)</p>
    <p>PERFORM mode.equals(CreateNew)  { skip; } mode.equals(Open) &amp;&amp;</p>
    <p>access.equals(OpenRead)  { accessed = true; }</p>
    <p>AFTER bool answer = GUI.AskConnect()</p>
    <p>PERFORM answer  { permission = true; } !answer  { permission = false; }</p>
    <p>BEFORE Connection.Open(string type, string address)</p>
    <p>PERFORM !accessed || permission -&gt; { permission = false; }</p>
    <p>Provably Correct Runtime Monitoring 9</p>
  </div>
  <div class="page">
    <p>Monitor Inlining</p>
    <p>Embedded state: The concrete representation of the monitor state in the program, usually in the form of global program variables.</p>
    <p>Variants include:</p>
    <p>Wrapping (Naccio99) Scattered (PSLang/POet00) Central (Polymer05)</p>
    <p>Provably Correct Runtime Monitoring 10</p>
  </div>
  <div class="page">
    <p>Specifying Correct Monitor Inlining</p>
    <p>The problem</p>
    <p>How can we specify that a program has been correctly inlined for a given policy?</p>
    <p>Provably Correct Runtime Monitoring 11</p>
  </div>
  <div class="page">
    <p>Specifying Correct Monitor Inlining</p>
    <p>The problem</p>
    <p>How can we specify that a program has been correctly inlined for a given policy?</p>
    <p>Reformulation of the Problem</p>
    <p>How can we specify that a program has an embedded monitor for the policy?</p>
    <p>Provably Correct Runtime Monitoring 11</p>
  </div>
  <div class="page">
    <p>Specifying Correct Monitor Inlining</p>
    <p>The target program is annotated in two steps:</p>
    <p>Provably Correct Runtime Monitoring 12</p>
  </div>
  <div class="page">
    <p>Specifying Correct Monitor Inlining</p>
    <p>The target program is annotated in two steps:</p>
    <p>Provably Correct Runtime Monitoring 12</p>
  </div>
  <div class="page">
    <p>Specifying Correct Monitor Inlining</p>
    <p>The target program is annotated in two steps:</p>
    <p>the embedded monitor is in synch with the specified monitor immediately prior to execution of a security relevant action, and the updates to the embedded state are made locally, that is by the method that executes the security relevant method call.</p>
    <p>Provably Correct Runtime Monitoring 12</p>
  </div>
  <div class="page">
    <p>Level I Annotations (Policy Annotations)</p>
    <p>Characterize policy adherence,</p>
    <p>Provably Correct Runtime Monitoring 13</p>
  </div>
  <div class="page">
    <p>Level I Annotations (Policy Annotations)</p>
    <p>Characterize policy adherence,</p>
    <p>Created using the policy:</p>
    <p>The security state is represented by ghost variables (ghost state), updated to mimic the automaton transitions, and set to  if no transition is available.</p>
    <p>The ghost state is asserted to be defined at critical points.</p>
    <p>Provably Correct Runtime Monitoring 13</p>
  </div>
  <div class="page">
    <p>Level I Annotations Policy</p>
    <p>Applications are allowed to access existing files for reading only, and are required, once such a file has been accessed, to obtain</p>
    <p>approval from the user each time a connection is to be opened.</p>
    <p>SECURITY STATE</p>
    <p>bool accessed = false;</p>
    <p>bool permission = false;</p>
    <p>BEFORE File.Open(string path, string mode, string access)</p>
    <p>PERFORM mode.equals(CreateNew)  { skip; } mode.equals(Open) &amp;&amp;</p>
    <p>access.equals(OpenRead)  { accessed = true; }</p>
    <p>AFTER bool answer = GUI.AskConnect()</p>
    <p>PERFORM answer  { permission = true; } !answer  { permission = false; }</p>
    <p>BEFORE Connection.Open(string type, string address)</p>
    <p>PERFORM !accessed || permission -&gt; { permission = false; }</p>
    <p>Provably Correct Runtime Monitoring 14</p>
  </div>
  <div class="page">
    <p>Level I Annotations Target Program</p>
    <p>L M[L] L1 aload r0 L2 getfield gui L3 dup L4 astore r1 L5 invokevirtual GUI/AskConnect()Z L6 istore r2 L7 aload r1 L8 instanceof GUI L9 ifeq L12 L10 iload r2 L11 putstatic SecState/permission L12 iload r2 L13 ireturn</p>
    <p>Figure: An target application method</p>
    <p>Provably Correct Runtime Monitoring 15</p>
  </div>
  <div class="page">
    <p>Level I Annotations Example: Level I Annotations</p>
    <p>AI[L] L M[L] L1 aload r0 L2 getfield gui L3 dup L4 astore r1</p>
    <p>{Defined(gs)} L5 invokevirtual GUI/AskConnect()Z {gs := (gs, a)} L6 istore r2</p>
    <p>L7 aload r1 L8 instanceof GUI L9 ifeq L12 L10 iload r2 L11 putstatic SecState/permission L12 iload r2 L13 ireturn</p>
    <p>Figure: An application method with level I annotations for the example policy</p>
    <p>Provably Correct Runtime Monitoring 16</p>
  </div>
  <div class="page">
    <p>Level I Annotations</p>
    <p>Theorem: Correctness of Level I Annotations</p>
    <p>Program T annotated with level I annotations for policy P is valid, if and only if T adheres to P.</p>
    <p>Provably Correct Runtime Monitoring 17</p>
  </div>
  <div class="page">
    <p>Level II Annotations (Synchronisation Check Annotations)</p>
    <p>Characterize the existence of a concrete monitor in the program</p>
    <p>Obtained by extending level I annotations</p>
    <p>Provably Correct Runtime Monitoring 18</p>
  </div>
  <div class="page">
    <p>Level II Annotations (Synchronisation Check Annotations)</p>
    <p>Characterize the existence of a concrete monitor in the program</p>
    <p>Obtained by extending level I annotations</p>
    <p>Synchronisation Assertion states the equality of the ghost state and the embedded state, and is asserted for every method at:</p>
    <p>method entry (pre-condition),</p>
    <p>method exit (post-condition),</p>
    <p>before each method call.</p>
    <p>Provably Correct Runtime Monitoring 18</p>
  </div>
  <div class="page">
    <p>Level II Annotations Example: Level I Annotations</p>
    <p>AI[L] L M[L] L1 aload r0 L2 getfield gui L3 dup L4 astore r1</p>
    <p>{Defined(gs)} L5 invokevirtual GUI/AskConnect()Z {gs := (gs, a)} L6 istore r2</p>
    <p>L7 aload r1 L8 instanceof GUI L9 ifeq L12 L10 iload r2 L11 putstatic SecState/permission L12 iload r2 L13 ireturn</p>
    <p>Figure: An application method with level I annotations for the example policy</p>
    <p>Provably Correct Runtime Monitoring 19</p>
  </div>
  <div class="page">
    <p>Level II Annotations Example: Level II Annotations</p>
    <p>AII[L] L M[L] {gs = SecState} L1 aload r0</p>
    <p>L2 getfield gui</p>
    <p>L3 dup L4 astore r1</p>
    <p>{Defined(gs)  gs = SecState} L5 invokevirtual GUI/AskConnect()Z {gs := (gs, a)} L6 istore r2</p>
    <p>L7 aload r1 L8 instanceof GUI L9 ifeq L12 L10 iload r2 L11 putstatic SecState/permission L12 iload r2</p>
    <p>{gs = SecState} L13 ireturn</p>
    <p>Figure: An application method with level II annotations for the example policy</p>
    <p>Provably Correct Runtime Monitoring 20</p>
  </div>
  <div class="page">
    <p>Level II Annotations</p>
    <p>Theorem: Level II Characterization</p>
    <p>The level II annotations of T for policy P with the embedded state  ms is valid if, and only if, ms identifies a method-local monitor for P.</p>
    <p>Provably Correct Runtime Monitoring 21</p>
  </div>
  <div class="page">
    <p>Correct Monitor Inlining</p>
    <p>Given a program T, a policy P and an embedded state ms, how do we show that the level II annotated program is valid?</p>
    <p>Provably Correct Runtime Monitoring 22</p>
  </div>
  <div class="page">
    <p>Correct Monitor Inlining</p>
    <p>Given a program T, a policy P and an embedded state ms, how do we show that the level II annotated program is valid?</p>
    <p>If T is a nicely inlined program then level II annotations can be completed to full annotations and the problem is reduced to checking local validity.</p>
    <p>Checking local validity consists of</p>
    <p>constructing verification conditions using the axiomatic semantics of single instructions</p>
    <p>discharging the resulting verification conditions</p>
    <p>Provably Correct Runtime Monitoring 22</p>
  </div>
  <div class="page">
    <p>Correct Monitor Inlining Level III (Full) Annotations for the Inliner</p>
    <p>Full annotations generated by:</p>
    <p>Proof of correct inlining can be constructed for nicely inlined programs.</p>
    <p>Provably Correct Runtime Monitoring 23</p>
  </div>
  <div class="page">
    <p>Correct Monitor Inlining Level III (Full) Annotations for the Inliner</p>
    <p>Full annotations generated by:</p>
    <p>Proof of correct inlining can be constructed for nicely inlined programs.</p>
    <p>A program is nicely inlined if</p>
    <p>the problem of computing the weakest precondition of inlined blocks is decidable,</p>
    <p>the problem of discharging the verification conditions arising from the local validity of the full annotations is decidable</p>
    <p>Provably Correct Runtime Monitoring 23</p>
  </div>
  <div class="page">
    <p>Correctness of an Inliner</p>
    <p>An inliner is a well-behaved inliner if it produces nicely inlined programs.</p>
    <p>Correctness of a well-behaved inliner I can be proven by showing that given any program T and policy P, a proof of inlining correctness can be constructed for the inlined program I(T, P).</p>
    <p>Provably Correct Runtime Monitoring 24</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>In this work we introduce a two-level annotation scheme on java bytecode programs where:</p>
    <p>The annotation scheme can be used to show that a program has been correctly inlined.</p>
    <p>Provably Correct Runtime Monitoring 25</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>In this work we also describe how to compute full annotations for nicely inlined programs which reduce the problem of proving correct inlining to checking local validity of the fully annotated program.</p>
    <p>The annotation scheme can be used in a proof-carrying code setting for certifying monitor compliance to the code consumer.</p>
    <p>The annotation scheme can be used to show correctness of an inliner.</p>
    <p>Provably Correct Runtime Monitoring 26</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Constructing a proof-carrying code framework</p>
    <p>Extending the annotation scheme to handle multi-threaded programs</p>
    <p>Adding new features to the policy language, e.g. to define per-object policies</p>
    <p>Finding abstraction functions that identify the embedded state in unlined but yet self-monitoring programs</p>
    <p>Extending the correctness result to cover transparency</p>
    <p>Provably Correct Runtime Monitoring 27</p>
  </div>
</Presentation>
