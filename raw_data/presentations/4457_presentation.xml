<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Optimal Additive Composition of Abstraction-based Admissible Heuristics</p>
    <p>Michael Katz Carmel Domshlak</p>
    <p>Technion, IE&amp;M</p>
    <p>ICAPS-08</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Context</p>
    <p>Abstraction-based Admissible Heuristics for Cost-Optimal Classical Planning</p>
    <p>Classical Planning</p>
    <p>Planning task is 5-tuple V, A, C, s0, G: V : finite set of finite-domain state variables</p>
    <p>A: finite set of actions of form pre, eff A: (preconditions/effects; partial variable assignments)</p>
    <p>C : A 7 R0+ captures action cost s0: initial state (variable assignment)</p>
    <p>G: goal description (partial variable assignment)</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Context</p>
    <p>Abstraction-based Admissible Heuristics for Cost-Optimal Classical Planning</p>
    <p>Cost-Optimal Planning</p>
    <p>Given: planning task  = V, A, s0, G Find: operator sequence a1 . . . an  A</p>
    <p>transforming s0 into some state sn  G, while minimizing</p>
    <p>n i=1 C(ai)</p>
    <p>Approach: A + admissible heuristic h : S 7 R0+</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Context</p>
    <p>Abstraction-based Admissible Heuristics for Cost-Optimal Classical Planning</p>
    <p>Abstraction heuristics</p>
    <p>Heuristic estimate is goal distance in abstracted state space S</p>
    <p>Examples: h+ (ignore-deletes) NP-hard PDBs (pattern databases)[...,Ed01,...] constrained PDBs [HBG05] merge-and-shrink [HHH07] structural patterns [KD08]</p>
    <p>Examples NOT: hm [HG00] some LP relaxations [...]</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Composing Multiple Heuristics Two heads are better than one</p>
    <p>State of the art</p>
    <p>Input: problem , admissible heuristics h1, . . . , hm, state s</p>
    <p>MAX use maxmi=1 hi(s|)</p>
    <p>ADD use m</p>
    <p>i=1 hi(s|i) for some transformations 1, . . . , m of</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Projections</p>
    <p>Widely-exploited idea: projections ; map states to abstract states with perfect hash function</p>
    <p>Definition (projection)</p>
    <p>Projection [V ] to variables V   V : homomorphism  where</p>
    <p>(s) = (s) iff s and s agree on V</p>
    <p>!/V</p>
    <p>!1/V1 !2/V2 !3/V3</p>
    <p>V1, V2, V3 ! V</p>
    <p>Each a ! A satisfies C(a) &quot; !</p>
    <p>m</p>
    <p>i=1 Ci(a [Vi])</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Action-Cost Partitioning: Back to Projections</p>
    <p>!/V</p>
    <p>!1/V1 !2/V2 !3/V3</p>
    <p>V1, V2, V3 ! V</p>
    <p>C :load(pack, A, L) !&quot; 0.3</p>
    <p>C :drive(A, L, R) !&quot; 0.0</p>
    <p>C3 :load(pack, A, L) !&quot; 0.3</p>
    <p>C3 :drive(A, L, R) !&quot; 0.0</p>
    <p>C2 :load(pack, A, L) !&quot; 1.0</p>
    <p>C2 :drive(A, L, R) !&quot; 31.3</p>
    <p>C1 :load(pack, A, L) !&quot; 4.1</p>
    <p>C1 :drive(A, L, R) !&quot; 31.3</p>
    <p>C :load(pack, A, L) !&quot; 5.4</p>
    <p>C :drive(A, L, R) !&quot; 62.6</p>
    <p>need selecting a good action-cost partition ; optimal action-cost partition?</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Optimizing Action-Cost Partitioning</p>
    <p>Pitfalls</p>
    <p>/ infinite space of choices</p>
    <p>/ decision process should be fully unsupervised</p>
    <p>/ decision process should be state-dependent</p>
    <p>; determining which abstractions [action-cost partitions] will produce additives that are better than max over standards is</p>
    <p>still a big research issue. (Yang et al., JAIR, 2008)</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Composing Multiple Heuristics Two heads are better than one</p>
    <p>State of the art</p>
    <p>Input: problem , admissible heuristics h1, . . . , hm, state s</p>
    <p>MAX use maxmi=1 hi(s|)</p>
    <p>ADD use m</p>
    <p>i=1 hi(s|i) for some transformations 1, . . . , m of</p>
    <p>Major Question</p>
    <p>MAX or ADD, and if ADD, then add what?</p>
    <p>Here we aim at answering this question</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Some Basic Formalism</p>
    <p>Transition graph</p>
    <p>TG-structure T = (S, L, Tr, s0, S?): S: finite set of states</p>
    <p>L: finite set of transition labels</p>
    <p>Tr  S  L  S: labelled transitions s0  S: initial state S?  S: goal states</p>
    <p>Transition graph T, $: T: TG-structure with labels L transition cost function $ : L 7 R0+</p>
    <p>(Transition graph of planning task defined in the obvious way.)</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Some Basic Formalism</p>
    <p>Transition graph</p>
    <p>TG-structure T = (S, L, Tr, s0, S?): S: finite set of states</p>
    <p>L: finite set of transition labels</p>
    <p>Tr  S  L  S: labelled transitions s0  S: initial state S?  S: goal states</p>
    <p>Transition graph T, $: T: TG-structure with labels L transition cost function $ : L 7 R0+</p>
    <p>(Transition graph of planning task defined in the obvious way.)</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Additive Abstractions</p>
    <p>Definition (additive abstractions)</p>
    <p>Additive abstraction of transition graph T, $ is {Ti, $i, i}mi=1 where</p>
    <p>Ti, $i: transition graph i maps states of T to states of Ti such that</p>
    <p>initial state maps to initial state goal states map to goal states</p>
    <p>holds m</p>
    <p>i=1 d(i(s), i(s ))  d(s, s)</p>
    <p>h(s) = m</p>
    <p>i=1 d(i(s), S ? i ) is (trivially) admissible</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Here We Go</p>
    <p>Main Idea</p>
    <p>Instead of searching each abstract transition graph Ti, $i given an action cost partition and using dynamic programming</p>
    <p>m i=1 Ci(a</p>
    <p>[Vi])</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Here We Go</p>
    <p>Main Idea</p>
    <p>Instead of searching each abstract transition graph Ti, $i given an action cost partition and using dynamic programming</p>
    <p>m i=1 Ci(a</p>
    <p>[Vi])</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Single-Source Shortest Paths: LP Formulation</p>
    <p>LP formulation</p>
    <p>Given: digraph G = (N, E), source node v  N LP variables: d(v) ; shortest-path length from v to v</p>
    <p>LP:</p>
    <p>max d</p>
    <p>v</p>
    <p>d(v)</p>
    <p>s.t. d(v) = 0</p>
    <p>d(v)  d(v) + w(v, v), (v, v)  E</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Step 1: Compile SSSP over Ti into Li</p>
    <p>LP formulation</p>
    <p>Given: TG-structure Ti, state s LP variables: {d(s) | s  Si}  {d(S?i )}  {w(a, i)} LP:</p>
    <p>max d(S?i )</p>
    <p>s.t.</p>
    <p>d(s)  d(s) + w(a, i), s, a, s  Tri d(s) = 0, s = s[Vi]</p>
    <p>d(S?i )  d(s ), s  S?i</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Step 2: Properly combine {Li}mi=1</p>
    <p>LP formulation</p>
    <p>Given: TG-structures {Ti}mi=1, state s LP variables:</p>
    <p>m i=1{d(s</p>
    <p>) | s  Si}  {d(S?i )}  {w(a, i)} LP:</p>
    <p>max m</p>
    <p>i=1</p>
    <p>d(S?i )</p>
    <p>s.t. i</p>
    <p>d(s)  d(s) + w(a, i), s, a, s  Tri d(s) = 0, s = s[Vi]</p>
    <p>d(S?i )  d(s ), s  S?i</p>
    <p>a  A : m</p>
    <p>i=1</p>
    <p>w(a, i)  C(a)</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Optimizing Action-Cost Partitioning: Generalization</p>
    <p>General theory of LP-optimizable ensembles of additive heuristic functions</p>
    <p>Warning: Any reduction to LP is not enough ; requires (surprising) relation between polyhedron and planning problem</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Optimizing Action-Cost Partitioning: Generalization</p>
    <p>General theory of LP-optimizable ensembles of additive heuristic functions</p>
    <p>Warning: Any reduction to LP is not enough</p>
    <p>Works as above for</p>
    <p>projection and variable-domain abstraction (PDB) heuristics constrained PDBs heuristics (Haslum et al., 2005) merge-and-shrink abstractions (Helmert et al., 2007)</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Optimizing Action-Cost Partitioning: Generalization</p>
    <p>General theory of LP-optimizable ensembles of additive heuristic functions</p>
    <p>Warning: Any reduction to LP is not enough</p>
    <p>Works as above for</p>
    <p>projection and variable-domain abstraction (PDB) heuristics constrained PDBs heuristics (Haslum et al., 2005) merge-and-shrink abstractions (Helmert et al., 2007)</p>
    <p>Suitable poly-size LPs Li exist also for 1 fork-decomposition structural patterns</p>
    <p>(Katz &amp; Domshlak, 2008) 2 tree-COP reducible fragments of tractable cost-optimal</p>
    <p>planning (Katz &amp; Domshlak, 2007) 3 ...</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Composing Heuristics</p>
    <p>Projections</p>
    <p>Action-Cost Partitioning</p>
    <p>Summary</p>
    <p>Summary</p>
    <p>State of the art</p>
    <p>Input: problem , admissible heuristics h1, . . . , hm, state s</p>
    <p>MAX use maxmi=1 hi(s|)</p>
    <p>ADD use m</p>
    <p>i=1 hi(s|i) for some transformations 1, . . . , m of</p>
    <p>Major Question</p>
    <p>MAX or ADD, and if ADD, then add what?</p>
    <p>For many (all ?) abstraction-based heuristics, the question is closed</p>
  </div>
</Presentation>
