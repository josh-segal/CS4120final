<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Write-Optimized and High-Performance</p>
    <p>Hashing Index Scheme for Persistent Memory</p>
    <p>Pengfei Zuo, Yu Hua, Jie Wu</p>
    <p>Huazhong University of Science and Technology, China</p>
    <p>OSDI 2018</p>
  </div>
  <div class="page">
    <p>Persistent Memory (PM)</p>
    <p>Non-volatile memory as PM is expected to replace</p>
    <p>or complement DRAM as main memory</p>
    <p>Non-volatility, low power, large capacity</p>
    <p>PCM ReRAM DRAM</p>
    <p>Read (ns) 20-70 20-50 10</p>
    <p>Write (ns) 150-220 70-140 10</p>
    <p>Non-volatility</p>
    <p>Standby Power ~0 ~0 High</p>
    <p>Density (Gb/cm2) 13.5 24.5 9.1</p>
    <p>PCM</p>
    <p>ReRAM</p>
    <p>K. Suzuki and S. Swanson. A Survey of Trends in Non-Volatile Memory Technologies: 2000-2014, IMW 2015.</p>
    <p>C. Xu et al. Overcoming the Challenges of Crossbar Resistive Memory Architectures, HPCA, 2015.</p>
  </div>
  <div class="page">
    <p>Index Structures in DRAM vs PM</p>
    <p>Index structures are critical for memory&amp;storage systems</p>
    <p>Traditional indexing techniques originally designed for</p>
    <p>DRAM become inefficient in PM</p>
    <p>Hardware limitations of NVM</p>
    <p>Limited cell endurance</p>
    <p>Asymmetric read/write latency and energy</p>
    <p>Write optimization matters</p>
    <p>The requirement of data consistency</p>
    <p>Data are persistently stored in PM</p>
    <p>Crash consistency on system failures</p>
    <p>P e rs</p>
    <p>is t</p>
    <p>CPU</p>
  </div>
  <div class="page">
    <p>Tree-based vs Hashing Index Structures</p>
    <p>Tree-based index structures  Pros: good for range query</p>
    <p>Cons: O(log(n)) time complexity</p>
    <p>for point query</p>
    <p>Ones for PM have been widely</p>
    <p>studied</p>
    <p>CDDS B-tree [FAST11]</p>
    <p>NV-Tree [FAST15]</p>
    <p>wB+-Tree [VLDB15]</p>
    <p>FP-Tree [SIGMOD16]</p>
    <p>WORT [FAST17]</p>
    <p>FAST&amp;FAIR [FAST18]</p>
  </div>
  <div class="page">
    <p>Tree-based vs Hashing Index Structures</p>
    <p>Tree-based index structures  Pros: good for range query</p>
    <p>Cons: O(log(n)) time complexity</p>
    <p>for point query</p>
    <p>Ones for PM have been widely</p>
    <p>studied</p>
    <p>CDDS B-tree [FAST11]</p>
    <p>NV-Tree [FAST15]</p>
    <p>wB+-Tree [VLDB15]</p>
    <p>FP-Tree [SIGMOD16]</p>
    <p>WORT [FAST17]</p>
    <p>FAST&amp;FAIR [FAST18]</p>
    <p>Hashing index structures  Pros: constant time complexity for</p>
    <p>point query</p>
    <p>Cons: do not support range query</p>
    <p>Widely used in main memory</p>
    <p>Main memory databases</p>
    <p>In-memory key-value stores, e.g.,</p>
    <p>Memcached and Redis</p>
    <p>When maintained in PM, multiple</p>
    <p>non-trivial challenges exist</p>
    <p>Rarely touched by existing work</p>
  </div>
  <div class="page">
    <p>Challenges of Hashing Indexes for PM</p>
    <p>High overhead for consistency guarantee</p>
    <p>Ordering memory writes</p>
    <p>Cache line flush and memory fence instructions</p>
    <p>Avoiding partial updates for non-atomic writes</p>
    <p>Logging or copy-on-write (CoW) mechanisms</p>
    <p>CPU Memory Bus</p>
    <p>Volatile caches Non-volatile memory</p>
  </div>
  <div class="page">
    <p>Challenges of Hashing Indexes for PM</p>
    <p>High overhead for consistency guarantee</p>
    <p>Performance degradation for reducing writes</p>
    <p>Hashing schemes for DRAM usually cause many extra</p>
    <p>writes for dealing with hash collisions [INFLOW15, MSST17]</p>
    <p>Write-friendly hashing schemes reduce writes but at the</p>
    <p>cost of decreasing access performance</p>
    <p>PCM-friendly hash table (PFHT) [INFLOW15]</p>
    <p>Path hashing [MSST17]</p>
  </div>
  <div class="page">
    <p>Challenges of Hashing Indexes for PM</p>
    <p>High overhead for consistency guarantee</p>
    <p>Performance degradation for reducing writes</p>
    <p>Cost inefficiency for resizing hash table</p>
    <p>Double the table size and iteratively rehash all items</p>
    <p>Take O(N) time to complete</p>
    <p>N insertions with cache line flushes &amp; memory fences</p>
    <p>Old Hash Table New Hash Table</p>
    <p>Rehash all items</p>
  </div>
  <div class="page">
    <p>Existing Hashing Index Schemes for PM</p>
    <p>Bucketized</p>
    <p>Cuckoo (BCH)</p>
    <p>PFHT1 Path</p>
    <p>Hashing2</p>
    <p>Memory efficiency</p>
    <p>Search  -- -</p>
    <p>Deletion  -- -</p>
    <p>Insertion  -- -</p>
    <p>NVM writes</p>
    <p>Resizing</p>
    <p>Consistency</p>
    <p>[1] B. Debnath et al. Revisiting hash table design for phase change memory, INFLOW, 2015.</p>
    <p>[2] P. Zuo and Y. Hua. A write-friendly hashing scheme for non-volatile memory systems, MSST, 2017.</p>
    <p>(: bad, : good , --: moderate)</p>
  </div>
  <div class="page">
    <p>Existing Hashing Index Schemes for PM</p>
    <p>Bucketized</p>
    <p>Cuckoo (BCH)</p>
    <p>PFHT1 Path</p>
    <p>Hashing2 Level</p>
    <p>Hashing</p>
    <p>Memory efficiency</p>
    <p>Search  -- --</p>
    <p>Deletion  -- --</p>
    <p>Insertion  -- --</p>
    <p>NVM writes</p>
    <p>Resizing</p>
    <p>Consistency</p>
    <p>[1] B. Debnath et al. Revisiting hash table design for phase change memory, INFLOW, 2015.</p>
    <p>[2] P. Zuo and Y. Hua. A write-friendly hashing scheme for non-volatile memory systems, MSST, 2017.</p>
    <p>(: bad, : good , --: moderate)</p>
  </div>
  <div class="page">
    <p>Level Hashing</p>
    <p>x 0 1 2 3 4 5 N-1N-2N-3N-4</p>
    <p>TL:</p>
    <p>BL:</p>
    <p>One movement</p>
    <p>One movement</p>
    <p>Write-optimized &amp; High-performance Hash Table Structure</p>
    <p>Cost-efficient</p>
    <p>In-place Resizing Scheme</p>
    <p>Low-overhead Consistency</p>
    <p>Guarantee Scheme</p>
    <p>Resizing</p>
    <p>support</p>
    <p>Consistency</p>
    <p>support</p>
  </div>
  <div class="page">
    <p>Write-optimized Hash Table Structure</p>
    <p>Multiple slots per bucket</p>
    <p>Two hash locations for each key</p>
    <p>Sharing-based two-level structure</p>
    <p>At most one movement for each successful insertion</p>
  </div>
  <div class="page">
    <p>Write-optimized Hash Table Structure</p>
    <p>Multiple slots per bucket</p>
    <p>Two hash locations for each key</p>
    <p>Sharing-based two-level structure</p>
    <p>At most one movement for each successful insertion</p>
    <p>x</p>
    <p>TL:</p>
    <p>D1 D1+D2 D1+D2+D3 All</p>
    <p>M a</p>
    <p>x im</p>
    <p>u m</p>
    <p>L o</p>
    <p>a d</p>
    <p>F</p>
    <p>a c to</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>Write-optimized Hash Table Structure</p>
    <p>Multiple slots per bucket</p>
    <p>Two hash locations for each key</p>
    <p>Sharing-based two-level structure</p>
    <p>At most one movement for each successful insertion</p>
    <p>x</p>
    <p>TL:</p>
    <p>D1 D1+D2 D1+D2+D3 All</p>
    <p>M a</p>
    <p>x im</p>
    <p>u m</p>
    <p>L o</p>
    <p>a d</p>
    <p>F</p>
    <p>a c to</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>Write-optimized Hash Table Structure</p>
    <p>Multiple slots per bucket</p>
    <p>Two hash locations for each key</p>
    <p>Sharing-based two-level structure</p>
    <p>At most one movement for each successful insertion</p>
    <p>x</p>
    <p>TL:</p>
    <p>BL:</p>
    <p>D1 D1+D2 D1+D2+D3 All</p>
    <p>M a</p>
    <p>x im</p>
    <p>u m</p>
    <p>L o</p>
    <p>a d</p>
    <p>F</p>
    <p>a c to</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>Write-optimized Hash Table Structure</p>
    <p>Multiple slots per bucket</p>
    <p>Two hash locations for each key</p>
    <p>Sharing-based two-level structure</p>
    <p>At most one movement for each successful insertion</p>
    <p>x</p>
    <p>TL:</p>
    <p>BL:</p>
    <p>One movement</p>
    <p>One movement</p>
    <p>D1 D1+D2 D1+D2+D3 All</p>
    <p>M a</p>
    <p>x im</p>
    <p>u m</p>
    <p>L o</p>
    <p>a d</p>
    <p>F</p>
    <p>a c to</p>
    <p>r</p>
  </div>
  <div class="page">
    <p>Write-optimized Hash Table Structure</p>
    <p>x</p>
    <p>TL:</p>
    <p>BL:</p>
    <p>One movement</p>
    <p>One movement</p>
    <p>Write-optimized: only 1.2% of insertions incur one movement</p>
    <p>High-performance: constant-scale time complexity for all operations</p>
    <p>Memory-efficient: achieve high load factor by evenly distributing items</p>
  </div>
  <div class="page">
    <p>Cost-efficient In-place Resizing</p>
    <p>Put a new level on top of the old hash table and</p>
    <p>only rehash items in the old bottom level</p>
    <p>TL:</p>
    <p>BL:</p>
  </div>
  <div class="page">
    <p>Cost-efficient In-place Resizing</p>
    <p>Put a new level on top of the old hash table and</p>
    <p>only rehash items in the old bottom level</p>
    <p>TL:</p>
    <p>TL:</p>
    <p>BL:</p>
  </div>
  <div class="page">
    <p>Cost-efficient In-place Resizing</p>
    <p>Put a new level on top of the old hash table and</p>
    <p>only rehash items in the old bottom level</p>
    <p>TL:</p>
    <p>BL:</p>
    <p>IL:</p>
    <p>(the interim level ) 20</p>
  </div>
  <div class="page">
    <p>Cost-efficient In-place Resizing</p>
    <p>Put a new level on top of the old hash table and</p>
    <p>only rehash items in the old bottom level</p>
    <p>TL:</p>
    <p>BL:</p>
    <p>IL:</p>
    <p>(the interim level )</p>
    <p>Rehashing</p>
  </div>
  <div class="page">
    <p>Cost-efficient In-place Resizing</p>
    <p>Put a new level on top of the old hash table and</p>
    <p>only rehash items in the old bottom level</p>
    <p>TL:</p>
    <p>BL:</p>
  </div>
  <div class="page">
    <p>Cost-efficient In-place Resizing</p>
    <p>Put a new level on top of the old hash table and</p>
    <p>only rehash items in the old bottom level  The new hash table is exactly double size of the old one</p>
    <p>Only 1/3 buckets (i.e., the old bottom level) are rehashed</p>
    <p>TL:</p>
    <p>BL:</p>
  </div>
  <div class="page">
    <p>Low-overhead Consistency Guarantee</p>
    <p>A token associated with each slot in the open</p>
    <p>addressing hash tables</p>
    <p>Indicate whether the slot is empty</p>
    <p>A token is 1 bit, e.g., 1 for non-empty, 0 for empty</p>
    <p>KV1KV00011</p>
    <p>Tokens</p>
    <p>A bucket:</p>
    <p>Slots 24</p>
  </div>
  <div class="page">
    <p>Low-overhead Consistency Guarantee</p>
    <p>A token associated with each slot in the open</p>
    <p>addressing hash tables</p>
    <p>Indicate whether the slot is empty</p>
    <p>A token is 1 bit, e.g., 1 for non-empty, 0 for empty</p>
    <p>Modifying the token area only needs an atomic write</p>
    <p>Leveraging the token to perform log-free operations</p>
    <p>KV1KV00011</p>
    <p>Tokens Slots</p>
    <p>A bucket:</p>
  </div>
  <div class="page">
    <p>Log-free Deletion</p>
    <p>Delete an existing item</p>
    <p>KV1KV00011</p>
    <p>Delete</p>
  </div>
  <div class="page">
    <p>Log-free Deletion</p>
    <p>Delete an existing item</p>
    <p>KV1KV00011</p>
    <p>Delete</p>
    <p>KV1KV00001</p>
    <p>Modify the token in an</p>
    <p>atomic write</p>
  </div>
  <div class="page">
    <p>Log-free Deletion</p>
    <p>Delete an existing item</p>
    <p>KV1KV00011</p>
    <p>Delete</p>
    <p>KV1KV00001</p>
    <p>Modify the token in an</p>
    <p>atomic write</p>
    <p>Log-free insertion and log-free resizing</p>
    <p>Please find them in our paper 28</p>
  </div>
  <div class="page">
    <p>Consistency Guarantee for Update</p>
    <p>If directly update an existing</p>
    <p>key-value item in place</p>
    <p>Inconsistency on system failures</p>
    <p>KV1KV00011</p>
    <p>Update</p>
  </div>
  <div class="page">
    <p>Consistency Guarantee for Update</p>
    <p>If directly update an existing</p>
    <p>key-value item in place</p>
    <p>Inconsistency on system failures</p>
    <p>A straightforward solution is</p>
    <p>to use logging KV1KV00011</p>
    <p>Update</p>
    <p>Expensive!</p>
  </div>
  <div class="page">
    <p>Opportunistic Log-free Update</p>
    <p>Our scheme: check whether there is an empty slot in the bucket</p>
    <p>storing the old item</p>
    <p>Yes: log-free update</p>
    <p>No: using logging KV1KV00011</p>
    <p>KV1KV1KV00011</p>
    <p>KV1KV1KV00101</p>
    <p>Update</p>
    <p>Write KV1 in an empty slot</p>
    <p>Modify the two tokens in an atomic write</p>
  </div>
  <div class="page">
    <p>Opportunistic Log-free Update</p>
    <p>Our scheme: check whether there is an empty slot in the bucket</p>
    <p>storing the old item</p>
    <p>Yes: log-free update</p>
    <p>No: using logging KV1KV00011</p>
    <p>KV1KV1KV00011</p>
    <p>KV1KV1KV00101</p>
    <p>Update</p>
    <p>Write KV1 in an empty slot</p>
    <p>Modify the two tokens in an atomic write</p>
    <p>L o</p>
    <p>g -f</p>
    <p>re e</p>
    <p>P ro</p>
    <p>b a</p>
    <p>b il it y</p>
    <p>Load Factor</p>
  </div>
  <div class="page">
    <p>Performance Evaluation</p>
    <p>Both in DRAM and simulated PM platforms</p>
    <p>Quartz (Hewlett Packard)</p>
    <p>A DRAM-based performance emulator for PM</p>
    <p>Comparisons  Bucketized cuckoo hashing (BCH) [NSDI13]</p>
    <p>PCM-friendly hash table (PFHT) [INFLOW15]</p>
    <p>Path hashing [MSST17]</p>
    <p>In PM, implement their persistent versions using our</p>
    <p>proposed log-free consistency guarantee schemes</p>
  </div>
  <div class="page">
    <p>Insertion Latency</p>
    <p>Level hashing has the best insertion performance in both DRAM and NVM</p>
    <p>In s e</p>
    <p>rt io</p>
    <p>n L</p>
    <p>a te</p>
    <p>n c y (</p>
    <p>n s )</p>
    <p>Load Factor</p>
    <p>BCH PFHT</p>
    <p>Path Level</p>
    <p>DRAM NVM read/write latency: 200/600</p>
    <p>In s e</p>
    <p>rt io</p>
    <p>n L</p>
    <p>a te</p>
    <p>n c y (</p>
    <p>n s )</p>
    <p>Load Factor</p>
    <p>BCH PFHT</p>
    <p>Path Level</p>
  </div>
  <div class="page">
    <p>Update Latency</p>
    <p>Opportunistic log-free update scheme reduces the update latency by 15% 52%, i.e., speeding up the updates by 1.2 2.1</p>
    <p>U p</p>
    <p>d a</p>
    <p>te L</p>
    <p>a te</p>
    <p>n c y (</p>
    <p>n s )</p>
    <p>Load Factor</p>
    <p>BCH PFHT</p>
    <p>Path Level</p>
    <p>Level w/o Opp</p>
  </div>
  <div class="page">
    <p>Search Latency</p>
    <p>The search latency of level hashing is close to that of BCH, which is much</p>
    <p>lower than PFHT and path hashing</p>
    <p>Negative Search</p>
    <p>S e</p>
    <p>a rc</p>
    <p>h L</p>
    <p>a te</p>
    <p>n c y (</p>
    <p>n s )</p>
    <p>BCH</p>
    <p>PFHT</p>
    <p>Path</p>
    <p>Level</p>
    <p>Positive Search</p>
  </div>
  <div class="page">
    <p>Resizing Time</p>
    <p>Level hashing reduces the resizing time by about 76%, i.e., speeding up</p>
    <p>the resizing by 4.3</p>
    <p>NVM-200ns/600nsDRAM</p>
    <p>T h e R</p>
    <p>e s iz</p>
    <p>in g T</p>
    <p>im e (</p>
    <p>s )</p>
    <p>BCH</p>
    <p>PFHT</p>
    <p>Path</p>
    <p>Level-Trad</p>
    <p>Level</p>
  </div>
  <div class="page">
    <p>Concurrent Throughput</p>
    <p>Concurrent level hashing:</p>
    <p>Support multiple-reader multiple</p>
    <p>writer concurrency via simply</p>
    <p>using fine-grained locking</p>
    <p>Concurrent level hashing has</p>
    <p>fewer slots for insertions 90/10 70/30 50/50 30/70 10/90</p>
    <p>T h</p>
    <p>ro u</p>
    <p>g h</p>
    <p>p u</p>
    <p>t (M</p>
    <p>r e</p>
    <p>q s /s</p>
    <p>)</p>
    <p>Libcu-2 Level-2 Libcu-4 Level-4</p>
    <p>Libcu-8 Level-8 Libcu-16 Level-16</p>
    <p>Search/Insertion Ratio (%)</p>
    <p>[1] X. Li et al.. Algorithmic improvements for fast concurrent cuckoo hashing, Eurosys, 2014. 38</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Traditional indexing techniques originally designed for</p>
    <p>DRAM become inefficient in PM</p>
    <p>We propose level hashing, a write-optimized and high</p>
    <p>performance hashing index scheme for PM</p>
    <p>Write-optimized hash table structure</p>
    <p>Cost-efficient in-place resizing</p>
    <p>Log-free consistency guarantee</p>
    <p>1.43.0 speedup for insertion, 1.22.1 speedup for update, and over 4.3 speedup for resizing</p>
  </div>
  <div class="page">
    <p>Thanks! Q&amp;A (Poster #10)</p>
    <p>Open-source code: https://github.com/Pfzuo/Level-Hashing</p>
  </div>
</Presentation>
