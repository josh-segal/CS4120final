<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>You are Who You Know and How You Behave: Attribute Inference Attacks via Users Social</p>
    <p>Friends and Behaviors</p>
    <p>Bin Liu Rutgers University</p>
    <p>Neil Zhenqiang Gong Iowa State University</p>
  </div>
  <div class="page">
    <p>Online Social Networks are Popular 2</p>
  </div>
  <div class="page">
    <p>OSNs Are a Mixture of Public and Private Information</p>
    <p>Public information o Friends o User behaviors</p>
    <p>n Like/share/review webpages and apps o Self-reported attributes</p>
    <p>n Education, employment, location</p>
    <p>Private information o Personal interests o Sexual orientation o Drug usage o Religious view o</p>
  </div>
  <div class="page">
    <p>Attribute Inference Attacks</p>
    <p>Given public information of some users</p>
    <p>Infer private attributes of some target users</p>
  </div>
  <div class="page">
    <p>Existing Attribute Inference Attacks</p>
    <p>Friend based: you are who you know</p>
    <p>Behavior based: you are how you behave</p>
  </div>
  <div class="page">
    <p>Our Attack</p>
    <p>Combine both friends and behaviors</p>
  </div>
  <div class="page">
    <p>Roadmap</p>
    <p>Threat model</p>
    <p>Our attack algorithm</p>
    <p>Evaluation</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>Threat Model</p>
    <p>Attackers o Cyber criminal o OSN provider o Advertiser o Data broker</p>
    <p>Attack procedure o Attacker collects publicly available friends, user attributes, and behaviors</p>
    <p>o Use our algorithm to infer private attributes of target users</p>
  </div>
  <div class="page">
    <p>Threat Model</p>
    <p>Implication/Application of attribute inference attacks o Privacy threat o Targeted advertisement o Targeted phishing attacks o Breaking security question based user authentication</p>
    <p>Perform further attacks o Help profile users across social networks o Help combine online profile with offline data</p>
  </div>
  <div class="page">
    <p>Our Attack Algorithm:High-Level Overview</p>
    <p>Construct a Social-Behavior-Attribute (SBA) network to unify friends, attributes, and behavior information</p>
    <p>For a target user, find the most similar attributes on the SBA network based on homophily o Homophily: users that have similar attributes share similar friends and behaviors</p>
  </div>
  <div class="page">
    <p>Social-Behavior-Attribute(SBA) Network</p>
    <p>social node attribute node social link attribute link</p>
    <p>u1 u2 u6u5u4u3</p>
    <p>behavior node behavior link</p>
    <p>WhatsApp Messager Facebook PinterestAngry Birds</p>
    <p>Computer Science Male Biology Google Inc.</p>
  </div>
  <div class="page">
    <p>Vote Distribution Attack (VIAL) Algorithm</p>
    <p>Phase I: o Iteratively distribute a fixed vote capacity from the targeted user v to the rest of users</p>
    <p>Phase II: o Each user votes his/her own attributes using his/her vote capacity</p>
    <p>o The target user is predicted to have the attribute values that receive the highest votes</p>
  </div>
  <div class="page">
    <p>Phase I- Distributing Vote Capacity</p>
    <p>A user receives a high vote capacity if the user and the targeted user are structurally similar</p>
    <p>Distribution via three local rules o Dividing o Backtracking o Aggregating</p>
  </div>
  <div class="page">
    <p>Local Rule I: Dividing 14</p>
    <p>Dividing Backtracking Aggregating</p>
    <p>Targeted user</p>
    <p>Figure 2: Illustration of our three local rules.</p>
    <p>the similarity between v and each attribute value, and then we predict that v owns the attribute values that have the highest similarity scores. In a high-level abstraction, VIAL works in two phases.</p>
    <p>Phase I. VIAL iteratively distributes a fixed vote capacity from the targeted user v to the rest of users in Phase I. The intuitions are that a user receives a high vote capacity if the user and the targeted user are structurally similar in the SBA network (e.g., share common friends and behaviors), and that the targeted user is more likely to have the attribute values belonging to users with higher vote capacities. After Phase I, we obtain a vote capacity vector ~sv, where ~svu is the vote capacity of user u.</p>
    <p>Phase II. Intuitively, if a user with a certain vote capacity has more attribute values, then, according to the information of this user alone, the likelihood of each of these attribute values belonging to the targeted user decreases. Moreover, an attribute value should receive more votes if more users with higher vote capacities have the attribute value. Therefore, in Phase II, each social node votes for its attribute values via dividing its vote capacity among them, and each attribute value sums the vote capacities that are divided to it by its social neighbors. We treat the summed vote capacity of an attribute value as its similarity with v. Finally, we predict v has the attribute values that receive the highest votes.</p>
    <p>~s(0)vu =</p>
    <p>( |Vs| if u = v 0 otherwise</p>
    <p>(1)</p>
    <p>In each iteration, VIAL applies three local rules. They are dividing, backtracking, and aggregating. Intuitively,</p>
    <p>if a user u has more (hop-2) social neighbors, then each neighbor could receive less vote capacity from u. Therefore, our dividing rule splits a social nodes vote capacity to its social neighbors and hop-2 social neighbors. The backtracking rule takes a portion of every social nodes vote capacity and assigns them back to the targeted user v, which is based on the intuition that social nodes that are closer to v in the SBA network are likely to be more similar to v and should get more vote capacities. A user could have a higher vote capacity if it is linked to more social neighbors and hop-2 social neighbors with higher vote capacities. Thus, for each user u, the aggregating rule collects the vote capacities that are shared to u by its social neighbors and hop-2 social neighbors. Fig. 2 illustrates the three local rules. Next, we elaborate the three local rules. Dividing: A social node u could have social neighbors, behavior-sharing social neighbors, and attributesharing social neighbors. To distinguish them, we use three weights wS, wBS, and wAS to represent the shares of them, respectively. For instance, the total vote capacity shared to social neighbors of u in the tth iteration is ~s(i1)vu  wSwS+wBS+wAS . Then we further divide the vote capacity among each type of neighbors according to their link weights. We define Iu,Y = 1 if the set of neighbors Gu,Y is non-empty, otherwise Iu,Y = 0, where Y = S,BS,AS. The variables Iu,S, Iu,BS, and Iu,AS are used to consider the scenarios where u does not have some type(s) of neighbors, in which us vote capacity is divided among less than three types of social neighbors. For convenience, we denote wT = wSIu,S + wBSIu,BS + wASIu,AS.</p>
    <p>Social neighbors. A social neighbor x 2 Gu,S receives a higher vote capacity from u if their link weight (e.g., tie strength) is higher. Therefore, we model the vote capacity p(i)v (u,x) that is divided to x by u in the ith iteration as:</p>
    <p>p(i)v (u,x) =~s (i1) vu</p>
    <p>wS wT</p>
    <p>wux du,S</p>
    <p>, (2)</p>
    <p>where du,S is the summation of weights of social links that are incident from u.</p>
    <p>Behavior-sharing social neighbors. A behaviorsharing social neighbor x 2 Gu,BS receives a higher vote capacity from u if they share more behavior neighbors with higher predictiveness. Thus, we model vote capacity q(i)v (u,x) that is divided to x by u in the ith iteration as:</p>
    <p>q(i)v (u,x) =~s (i1) vu</p>
    <p>wBS wT</p>
    <p>wB(u,x), (3)</p>
    <p>where wB(u,x) = y2Gu,B\Gx,B wuy du,B</p>
    <p>wxydy,S , representing the overall share of vote capacity that u divides</p>
    <p>Social neighbors</p>
    <p>Behavior-sharing social neighbors</p>
    <p>Attribute-sharing social neighbors</p>
  </div>
  <div class="page">
    <p>Local Rule II: Backtracking 15</p>
    <p>Dividing Backtracking Aggregating</p>
    <p>Targeted user</p>
    <p>Figure 2: Illustration of our three local rules.</p>
    <p>the similarity between v and each attribute value, and then we predict that v owns the attribute values that have the highest similarity scores. In a high-level abstraction, VIAL works in two phases.</p>
    <p>Phase I. VIAL iteratively distributes a fixed vote capacity from the targeted user v to the rest of users in Phase I. The intuitions are that a user receives a high vote capacity if the user and the targeted user are structurally similar in the SBA network (e.g., share common friends and behaviors), and that the targeted user is more likely to have the attribute values belonging to users with higher vote capacities. After Phase I, we obtain a vote capacity vector ~sv, where ~svu is the vote capacity of user u.</p>
    <p>Phase II. Intuitively, if a user with a certain vote capacity has more attribute values, then, according to the information of this user alone, the likelihood of each of these attribute values belonging to the targeted user decreases. Moreover, an attribute value should receive more votes if more users with higher vote capacities have the attribute value. Therefore, in Phase II, each social node votes for its attribute values via dividing its vote capacity among them, and each attribute value sums the vote capacities that are divided to it by its social neighbors. We treat the summed vote capacity of an attribute value as its similarity with v. Finally, we predict v has the attribute values that receive the highest votes.</p>
    <p>~s(0)vu =</p>
    <p>( |Vs| if u = v 0 otherwise</p>
    <p>(1)</p>
    <p>In each iteration, VIAL applies three local rules. They are dividing, backtracking, and aggregating. Intuitively,</p>
    <p>if a user u has more (hop-2) social neighbors, then each neighbor could receive less vote capacity from u. Therefore, our dividing rule splits a social nodes vote capacity to its social neighbors and hop-2 social neighbors. The backtracking rule takes a portion of every social nodes vote capacity and assigns them back to the targeted user v, which is based on the intuition that social nodes that are closer to v in the SBA network are likely to be more similar to v and should get more vote capacities. A user could have a higher vote capacity if it is linked to more social neighbors and hop-2 social neighbors with higher vote capacities. Thus, for each user u, the aggregating rule collects the vote capacities that are shared to u by its social neighbors and hop-2 social neighbors. Fig. 2 illustrates the three local rules. Next, we elaborate the three local rules. Dividing: A social node u could have social neighbors, behavior-sharing social neighbors, and attributesharing social neighbors. To distinguish them, we use three weights wS, wBS, and wAS to represent the shares of them, respectively. For instance, the total vote capacity shared to social neighbors of u in the tth iteration is ~s(i1)vu  wSwS+wBS+wAS . Then we further divide the vote capacity among each type of neighbors according to their link weights. We define Iu,Y = 1 if the set of neighbors Gu,Y is non-empty, otherwise Iu,Y = 0, where Y = S,BS,AS. The variables Iu,S, Iu,BS, and Iu,AS are used to consider the scenarios where u does not have some type(s) of neighbors, in which us vote capacity is divided among less than three types of social neighbors. For convenience, we denote wT = wSIu,S + wBSIu,BS + wASIu,AS.</p>
    <p>Social neighbors. A social neighbor x 2 Gu,S receives a higher vote capacity from u if their link weight (e.g., tie strength) is higher. Therefore, we model the vote capacity p(i)v (u,x) that is divided to x by u in the ith iteration as:</p>
    <p>p(i)v (u,x) =~s (i1) vu</p>
    <p>wS wT</p>
    <p>wux du,S</p>
    <p>, (2)</p>
    <p>where du,S is the summation of weights of social links that are incident from u.</p>
    <p>Behavior-sharing social neighbors. A behaviorsharing social neighbor x 2 Gu,BS receives a higher vote capacity from u if they share more behavior neighbors with higher predictiveness. Thus, we model vote capacity q(i)v (u,x) that is divided to x by u in the ith iteration as:</p>
    <p>q(i)v (u,x) =~s (i1) vu</p>
    <p>wBS wT</p>
    <p>wB(u,x), (3)</p>
    <p>where wB(u,x) = y2Gu,B\Gx,B wuy du,B</p>
    <p>wxydy,S , representing the overall share of vote capacity that u divides</p>
    <p>Take a portion of a users vote capacity back to the targeted user</p>
  </div>
  <div class="page">
    <p>Local Rule III: Aggregating 16</p>
    <p>Dividing Backtracking Aggregating</p>
    <p>Targeted user</p>
    <p>Figure 2: Illustration of our three local rules.</p>
    <p>the similarity between v and each attribute value, and then we predict that v owns the attribute values that have the highest similarity scores. In a high-level abstraction, VIAL works in two phases.</p>
    <p>Phase I. VIAL iteratively distributes a fixed vote capacity from the targeted user v to the rest of users in Phase I. The intuitions are that a user receives a high vote capacity if the user and the targeted user are structurally similar in the SBA network (e.g., share common friends and behaviors), and that the targeted user is more likely to have the attribute values belonging to users with higher vote capacities. After Phase I, we obtain a vote capacity vector ~sv, where ~svu is the vote capacity of user u.</p>
    <p>Phase II. Intuitively, if a user with a certain vote capacity has more attribute values, then, according to the information of this user alone, the likelihood of each of these attribute values belonging to the targeted user decreases. Moreover, an attribute value should receive more votes if more users with higher vote capacities have the attribute value. Therefore, in Phase II, each social node votes for its attribute values via dividing its vote capacity among them, and each attribute value sums the vote capacities that are divided to it by its social neighbors. We treat the summed vote capacity of an attribute value as its similarity with v. Finally, we predict v has the attribute values that receive the highest votes.</p>
    <p>~s(0)vu =</p>
    <p>( |Vs| if u = v 0 otherwise</p>
    <p>(1)</p>
    <p>In each iteration, VIAL applies three local rules. They are dividing, backtracking, and aggregating. Intuitively,</p>
    <p>if a user u has more (hop-2) social neighbors, then each neighbor could receive less vote capacity from u. Therefore, our dividing rule splits a social nodes vote capacity to its social neighbors and hop-2 social neighbors. The backtracking rule takes a portion of every social nodes vote capacity and assigns them back to the targeted user v, which is based on the intuition that social nodes that are closer to v in the SBA network are likely to be more similar to v and should get more vote capacities. A user could have a higher vote capacity if it is linked to more social neighbors and hop-2 social neighbors with higher vote capacities. Thus, for each user u, the aggregating rule collects the vote capacities that are shared to u by its social neighbors and hop-2 social neighbors. Fig. 2 illustrates the three local rules. Next, we elaborate the three local rules. Dividing: A social node u could have social neighbors, behavior-sharing social neighbors, and attributesharing social neighbors. To distinguish them, we use three weights wS, wBS, and wAS to represent the shares of them, respectively. For instance, the total vote capacity shared to social neighbors of u in the tth iteration is ~s(i1)vu  wSwS+wBS+wAS . Then we further divide the vote capacity among each type of neighbors according to their link weights. We define Iu,Y = 1 if the set of neighbors Gu,Y is non-empty, otherwise Iu,Y = 0, where Y = S,BS,AS. The variables Iu,S, Iu,BS, and Iu,AS are used to consider the scenarios where u does not have some type(s) of neighbors, in which us vote capacity is divided among less than three types of social neighbors. For convenience, we denote wT = wSIu,S + wBSIu,BS + wASIu,AS.</p>
    <p>Social neighbors. A social neighbor x 2 Gu,S receives a higher vote capacity from u if their link weight (e.g., tie strength) is higher. Therefore, we model the vote capacity p(i)v (u,x) that is divided to x by u in the ith iteration as:</p>
    <p>p(i)v (u,x) =~s (i1) vu</p>
    <p>wS wT</p>
    <p>wux du,S</p>
    <p>, (2)</p>
    <p>where du,S is the summation of weights of social links that are incident from u.</p>
    <p>Behavior-sharing social neighbors. A behaviorsharing social neighbor x 2 Gu,BS receives a higher vote capacity from u if they share more behavior neighbors with higher predictiveness. Thus, we model vote capacity q(i)v (u,x) that is divided to x by u in the ith iteration as:</p>
    <p>q(i)v (u,x) =~s (i1) vu</p>
    <p>wBS wT</p>
    <p>wB(u,x), (3)</p>
    <p>where wB(u,x) = y2Gu,B\Gx,B wuy du,B</p>
    <p>wxydy,S , representing the overall share of vote capacity that u divides</p>
    <p>Compute a new vote capacity for a user by aggregating the vote capacities from its neighbors</p>
  </div>
  <div class="page">
    <p>PhaseII:</p>
    <p>In the end of Phase I, each user has a certain vote capacity</p>
    <p>Each user divides its vote capacity to its own attributes</p>
    <p>Each attribute sums the received votes</p>
    <p>Attributes with the highest votes are predicted to belong to the targeted user</p>
  </div>
  <div class="page">
    <p>Evaluation Data</p>
    <p>One snapshot of Google+ from Gong et al. (IMC12) o Friends o Publicly available attributes</p>
    <p>Collect behaviors from Google Play o Liked/reviewed apps, movies, books, etc.</p>
  </div>
  <div class="page">
    <p>Evaluation Data</p>
    <p>Considered attributes o Major (62) o Employer(78) o Cities lived (70)</p>
    <p>and cities lived). Their dataset includes 79 snapshots of Google+ collected from July 6 to October 11, 2011. Each snapshot was a large Weakly Connected Component of Google+ social network at the time of crawling.</p>
    <p>We obtained one collected snapshot from Gong et al. [16, 15]. To better approximate friendships between users, we construct an undirected social network from the crawled Google+ dataset via keeping an undirected link between a user u and v if u is in vs both incoming friend list and outgoing friend list. After preprocessing, our Google+ dataset consists of 1,111,905 users and 5,328,308 undirected social links. User attributes: We consider three attributes, major, employer, and cities lived. We note that, although we focus on these attributes that are available to us at a large scale, our attack is also applicable to infer other attributes such as sexual orientation, political views, and religious views. Moreover, some targeted users might not view inferring these attributes as an privacy attack, but an attacker can leverage these attributes to further link users across online social networks [4, 14, 2, 13] or even link them with offline records to perform more serious security and privacy attacks [38, 32].</p>
    <p>We take the strings input by a user in its Google+ profile as attribute values. We found that most attribute values are owned by a small number of users while some are owned by a large number of users. Users could fill in their profiles freely in Google+, which could be one reason that we observe many infrequent attribute values. Specifically, different users might have different names for the same attribute value. For instance, the major of Computer Science could also be abbreviated as CS by some users. Indeed, we find that 20,861 users have Computer Science as their major and 556 users have CS as their major in our dataset. Moreover, small typos (e.g., one letter is incorrect) in the free-form inputs make the same attribute value be treated as different ones. Therefore, we manually label a set of attribute values.</p>
    <p>Table 1: Basic statistics of our SBA.</p>
    <p>#nodes #links social behavior attri. social behavior attri.</p>
    <p>Summary and limitations: In total, we consider 210 popular distinct attribute values, including 62 majors, 78 employers, and 70 cities. We acknowledge that our Google+ dataset might not be a representative sample of the recent entire Google+ social network, and thus the inference attack success rates obtained in our experiments might not represent those of the entire Google+ social network.</p>
    <p>User reviews are publicly available in Google Play. Specifically, after a user u logs in Google Play, u can view the list of items reviewed by any user v once u can obtain vs Google ID. We crawled the list of items reviewed by each user in the Google+ dataset.</p>
    <p>We find that 33% of users in the Google+ dataset have reviewed at least one item. In total, we collected 260,245 items and 3,954,822 reviews. Since items with too few reviews might not be informative to distinguish users with different attribute values, we use items that were reviewed by at least 5 users. After preprocessing, we have 48,706 items and 3,635,231 reviews.</p>
    <p>Construct a SBA network</p>
  </div>
  <div class="page">
    <p>Evaluation Setting</p>
    <p>Randomly sample a set of users</p>
    <p>Remove their attributes as ground-truth</p>
    <p>Treat them as targeted users</p>
    <p>Predict top-K attributes for each targeted user</p>
    <p>Measure Precision, Recall, and F-Score</p>
  </div>
  <div class="page">
    <p>Comparing with (Best) Friend-based and Behavior-based Attacks 21</p>
    <p>Table 2: Performance gains and relative performance gains of RWwR-SAN over other friend-based attacks, where K = 1. Results are averaged over all attributes. We find that RWwR-SAN is the best friend-based attack.</p>
    <p>Attack DP DP% DR DR% DF DF% CN-SAN 0.07 24% 0.04 24% 0.05 24% AA-SAN 0.08 26% 0.04 26% 0.05 26%</p>
    <p>Table 3: Performance gains and relative performance gains of VIAL-B over other behavior-based attacks, where K = 1. We find that VIAL-B is the best behavior-based attack.</p>
    <p>Attack DP DP% DR DR% DF DF% LG-B-I 0.06 42% 0.04 47% 0.05 45% LG-B-II 0.07 47% 0.05 52% 0.06 50%</p>
    <p>dataset. Specifically, LG-B-I extracts a feature vector whose length is the number of items for each user that has review data, and a feature has a value of the rating score that the user gave to the corresponding item. Google Play allows users to rate or like an item, and we treat a liking as a rating score of 5. For a test user, the learned logistic regression classifier returns a posterior probability distribution over the possible attribute values, which are used as the scores S(v,a). Weinsberg et al. [42] showed that logistic regression classifier outperforms other classifiers including SVM [10] and Naive Bayes [29].</p>
    <p>Logistic regression with binary features (LG-BII) [25]. The difference between LG-B-II and LGB-I is that LG-B-II extracts binary feature vectors for users. Specifically, a feature has a value of 1 if the user has reviewed the corresponding item.</p>
    <p>VIAL-B. A variant of VIAL that only uses behavior data. Specifically, we remove social links from the SBA network and perform our VIAL attack using the remaining links.</p>
    <p>Attacks combining social structures and behaviors: Intuitively, we can combine social structures and behaviors via concatenating social structure features with behavior features. We compare with two such attacks.</p>
    <p>Logistic regression (LG-I). LG-I extracts a binary feature vector whose length is the number of users from social structures for each user, and a feature has a value of 1 if the user is a friend of the person that corresponds to the feature. Then LG-I concatenates this feature vector with the one used in LG-B-I and learns multi-class logistic regression classifiers.</p>
    <p>Table 4: Performance gains and relative performance gains of VIAL over other attacks combining social structures and behaviors, where K = 1. We find that VIAL substantially outperforms other attacks.</p>
    <p>Attack DP DP% DR DR% DF DF% LG-I 0.17 61% 0.10 65% 0.13 63% LG-II 0.18 65% 0.11 69% 0.13 67%</p>
    <p>Table 5: Performance gains and relative performance gains of VIAL over Random, RWwR-SAN (the best friend-based attack), and VIAL-B (the best behaviorbased attack), where K = 1.</p>
    <p>Attack DP DP% DR DR% DF DF% Random 0.36 526% 0.22 535% 0.27 534%</p>
    <p>RWwR-SAN 0.07 20% 0.05 23% 0.06 22% VIAL-B 0.22 102% 0.13 99% 0.16 100%</p>
    <p>Logistic regression with binary features (LG-II). LG-II concatenates the binary social structure feature vector with the binary behavior feature vector used by LG-B-II.</p>
    <p>We use the popular package LIBLINEAR [12] to learn logistic regression classifiers.</p>
    <p>Absolute performance gain Relative performance gain</p>
    <p>Best friend-based attack Best behavior-based attack</p>
    <p>Our attacks are significantly more accurate than existing ones</p>
  </div>
  <div class="page">
    <p>Backtracking is Important 22</p>
    <p>re ci</p>
    <p>si on</p>
    <p>of in</p>
    <p>fe rr</p>
    <p>in g</p>
    <p>ci ti</p>
    <p>es K</p>
    <p>=1</p>
    <p>Figure 6: Impact of the backtracking strength on the Precision of VIAL for inferring cities. We observe that backtracking substantially improves VIALs performance.</p>
    <p>Comparing behavior-based attacks: We find that VIAL-B performs the best among the behavior-based attacks. Table 3 shows the average performance gains and relative performance gains of VIAL-B over other behavior-based attacks. Our results indicate that our graph-based attack is a better way to leverage behavior structures, compared to LG-B-I and LG-B-II, which flatten the behavior structures into feature vectors. Moreover, LG-B-I and LG-B-II achieve very close performances, which indicates that the rating scores carry little information about user attributes. Comparing attacks combining social structure and behavior: We find that VIAL performs the best among the attacks combining social structures and behaviors. Table 4 shows the average performance gains and relative performance gains of VIAL over other attacks. Our results imply that, compared to flattening the structures into feature vectors, our graph-based attack can better integrate social structures and user behaviors. Comparing VIAL with the best friend-based attack and the best behavior-based attack: Table 4 shows the average performance gains and relative performance gains of VIAL over Random, the best friend-based attack, and the best behavior-based attack. We find that VIAL significantly outperforms these attacks, indicating the importance of combining social structures and behaviors to perform attribute inference. This implies that, when an attacker wants to attack user privacy via inferring their private attributes, the attacker can successfully attack substantially more users using VIAL. Impact of backtracking strength: Fig. 6 shows the impact of backtracking strength on the Precision of VIAL for inferring cities. According to Theorem 1, VIAL with a = 1 reduces to random guessing, and thus we do not show the corresponding result in the figure. a = 0 corresponds to the case in which VIAL does not use backtracking. We observe that not using backtracking sub</p>
    <p>Figure 7: Impact of the number of reviewed items on the Precision of our attack VIAL for inferring cities. We observe that, when users share more behaviors, our attack is able to more accurately predict their attributes.</p>
    <p>stantially decreases the performance of VIAL. The reason might be that 1) a = 0 makes VIAL predict the same attribute values for all test users, according to Theorem 2, and 2) a user attributes are close to the user in the SBA network and backtracking makes it more likely for votes to be distributed among these attribute nodes. Moreover, we find that inference accuracies are stable across different backtracking strengths once they are larger than 0. The reason is that when we increase the backtracking strength, attribute values receive different votes, but the ones with top ranked votes only change slightly. We observe similar results for other attributes.</p>
    <p>Impact of the number of reviewed items: Figure 7 shows the Precision as a function of the number of reviewed items for inferring cities lived. We average Precisions for test users whose number of reviewed items falls under a certain interval (i.e., [5,20), [20,35), [35,50), or  50). We observe that our attack can more accurately infer attributes for users who share more digital behaviors (i.e., reviewed items in our case).</p>
    <p>Confidence estimation: Figure 8 shows the trade-off between the Precision and the fraction of users that are attacked via our confidence estimator. We observe that an attacker can increase the Precision (K = 1) of inferring cities from 0.57 to over 0.92 if the attacker attacks a half of the test users that are selected via confidence estimation. We also tried the confidence estimator called gap statistic [34], in which the confidence score for a targeted user is the difference between the score of the highest ranked attribute value and the score of the second highest ranked one. Our confidence estimator slightly outperforms gap statistic because a test user could have multiple attribute values and our attack could produce close scores for them.</p>
    <p>Backtracking substantially improves attack success rates</p>
    <p>Theoretically sound</p>
  </div>
  <div class="page">
    <p>Sharing More Behaviors Makes You More Vulnerable 23</p>
    <p>[5,20) [20,35) [35,50)  50 Number of reviewed items</p>
    <p>A ve</p>
    <p>ra ge</p>
    <p>pr ec</p>
    <p>is io</p>
    <p>n s</p>
    <p>of in</p>
    <p>fe rr</p>
    <p>in g</p>
    <p>ci ti</p>
    <p>es ,K</p>
    <p>=1</p>
    <p>Attack success rates are higher when more behaviors are available</p>
  </div>
  <div class="page">
    <p>Confidence Estimation</p>
    <p>Produce a confidence score for each targeted user to measure how confident we are about its inference</p>
    <p>Choose to attack targeted users whose confidence scores are higher than a threshold</p>
    <p>Trade-off between attack success rates and #attacked targeted users o Higher threshold -&gt; higher success rates &amp; less attacked users</p>
  </div>
  <div class="page">
    <p>Trade-off Result 25</p>
    <p>A ve</p>
    <p>ra ge</p>
    <p>pr ec</p>
    <p>is io</p>
    <p>n s</p>
    <p>of in</p>
    <p>fe rr</p>
    <p>in g</p>
    <p>ci ti</p>
    <p>es ,K</p>
    <p>=1</p>
    <p>Success rates can be significantly improved when selectively attacking half of targeted users</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Attribute inference attacks for online social network users are feasible at large scale</p>
    <p>Fundamental reasons o Private attributes and public information are correlated o Machine learning/Data mining algorithms can capture such correlations</p>
  </div>
</Presentation>
