<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>November 4-5, 2005 ACM GIS'05, Bremen, Germany 1</p>
    <p>Improving the R*-tree with Outlier Handling Techniques</p>
    <p>Tian Xia, Donghui Zhang { tianxia, donghui }@ccs.neu.edu</p>
    <p>College of Computer &amp; Information Science</p>
    <p>Northeastern University</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Talk Outline  Background and Our Motivation  The RO-tree: Structure and Operations  Querying the RO-tree  Experimental Results  Conclusions</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>The R*-tree in Spatial Databases  The R*-tree is a balanced disk-based tree</p>
    <p>structure.  Spatial objects are clustered based on the</p>
    <p>proximity of their locations.  Each sub-tree is bounded by the minimum</p>
    <p>bounding rectangle (MBR) of all object in it.</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>The R*-tree: Example</p>
    <p>R1 R2</p>
    <p>R3 R4 R5 R6</p>
    <p>o1 o2 o4 o5 o6 o7 o9 o10o3 o8</p>
    <p>R1</p>
    <p>R2</p>
    <p>R3</p>
    <p>R4</p>
    <p>R5</p>
    <p>R6</p>
    <p>o1</p>
    <p>o2 o3o4</p>
    <p>o5o6 o7</p>
    <p>o8 o9</p>
    <p>o10</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Our Motivation  Observation: If an object O is far away from</p>
    <p>others (or large), MBRs containing O are large.</p>
    <p>It is inevitable in the R*-tree! All objects have to be contained by some leaf node and every leaf node has a minimum content requirement.</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Our Motivation</p>
    <p>o1</p>
    <p>o2</p>
    <p>o3</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Outlier Objects  Objects far away from other objects (clusters)</p>
    <p>or with large extent are outliers.  Outliers cause the MBRs in the R*-tree to</p>
    <p>become large and badly affect the query performance.  Increase the dead space (space inside MBRs that</p>
    <p>contains no object).  Increase the overlap area</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Range Query</p>
    <p>Q</p>
    <p>o1</p>
    <p>o2</p>
    <p>o3</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Our Solution  We treat outliers separately!</p>
    <p>Q</p>
    <p>o1</p>
    <p>o2</p>
    <p>o3</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Our Goal  Existing query and update algorithms can be</p>
    <p>adapted easily for the new structure.  To see how much performance improvement</p>
    <p>this idea brings, by running extensive experiments.</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Five Popular Queries on the R*-tree  Range query  Aggregation query  Nearest Neighbor query  Skyline query  Spatial Join query.</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Talk Outline  Background and Our Motivation  The RO-tree: Structure and Operations  Querying the RO-tree  Experimental Results  Conclusions</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>The RO-tree: Outlier Handling Tree  The RO-tree is also a height-balanced, disk</p>
    <p>based tree structure, similar to the R*-tree.  In the RO-tree, objects could appear in the</p>
    <p>index nodes, not only in the leaf nodes.  The tree still maintains the minimum fan-out.</p>
    <p>Each index node contains at least m index entries (m = 40% of the node capacity).</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>The RO-tree: Structure Overview</p>
    <p>R2</p>
    <p>o1</p>
    <p>o2</p>
    <p>o3</p>
    <p>R1R3</p>
    <p>R4</p>
    <p>R5R6</p>
    <p>o1 o3R2R1</p>
    <p>R4R3 o2R6R5</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>The RO-tree: Structure  Each index node contains index entry part and</p>
    <p>object part.  How to allocate space between two parts?</p>
    <p>A nave way is to set a fixed cut-off point, e.g. 2m entries store index entry part. Not space efficient!</p>
    <p>Dynamic allocation: as long as there is space, either an index entry or an object entry can be put into the node.</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Insertion in the RO-tree  To insert an object O into the sub-tree rooted</p>
    <p>by node N,  If O is contained in the MBR of an index entry E,</p>
    <p>recursively insert O into the sub-tree rooted by the referenced node of E.</p>
    <p>Otherwise, O is stored in N as an outlier.</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Insertion: Example</p>
    <p>R2</p>
    <p>o1</p>
    <p>o2</p>
    <p>o3</p>
    <p>R1R3</p>
    <p>R4</p>
    <p>R5R6</p>
    <p>o1 o3R2R1</p>
    <p>R4R3 o2R6R5</p>
    <p>o4 o4</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Overflow Treatment (Index nodes)  Two choices: split the node or demote an</p>
    <p>object to lower level?  # index entries is smaller than 2m, demote an</p>
    <p>object. Here, m is the minimum fan-out.  No object: split the node.</p>
    <p>Experimental results showed # index entries = m+M/2 (M is the capacity of a node) is a breaking point.  Split if # index entries  m+M/2.</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Overflow Treatment: Example</p>
    <p>R2</p>
    <p>o1</p>
    <p>o2</p>
    <p>o3</p>
    <p>R1R3</p>
    <p>R4</p>
    <p>R5R6</p>
    <p>o1 o3R2R1</p>
    <p>R4R3 o2R6R5</p>
    <p>o4 o4</p>
    <p>o5</p>
    <p>o5</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Overflow Treatment: Example</p>
    <p>R2</p>
    <p>o1</p>
    <p>o2</p>
    <p>o3</p>
    <p>R1R3</p>
    <p>R4</p>
    <p>R5R6</p>
    <p>o1 o3R2R1</p>
    <p>R4R3 o2R6R5</p>
    <p>o4</p>
    <p>o4</p>
    <p>o5</p>
    <p>o5</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Split of An Index Node  To maintain the minimum fan-out, split is</p>
    <p>based on the index entries only.  Outlier objects in the index node are then</p>
    <p>assigned to one of two new nodes with least expansion of the MBR.</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Re-insertion in the RO-tree  Re-insertion is utilized to identify outliers in a</p>
    <p>page. -- A way to promote objects to higher levels.</p>
    <p>Hidden outliers can be re-identified!</p>
    <p>The RO-tree incorporates the improved reinsertion, proposed in our previous work [ZX, GIS04].</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Deletion and Underflow Treatment  Deletion of objects can happen both in index</p>
    <p>levels and in leaf level.</p>
    <p>To re-insert all entries in an underflow node may be expensive!  E.g., an index node underflows, while it can still</p>
    <p>be fully occupied, as many outlier objects may exist in the node.</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Underflow Treatment  If a leaf node underflows, we first try to drag</p>
    <p>down an outlier object from its parent if possible to resolve the underflow.</p>
    <p>If an index node underflows, we first insert the outlier objects into its sub-trees.  Chances are that, some child page may split and</p>
    <p>the underflow of the parent is resolved.</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Talk Outline  Background and Our Motivation  The RO-tree: Structure and Operations  Querying the RO-tree  Experimental Results  Conclusions</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>In General  Queries on the R*-tree can be easily adapted</p>
    <p>for the RO-tree by considering the objects stored in the index nodes.</p>
    <p>Query performance on the RO-tree is better:  Smaller MBRs in the RO-tree reduce the dead</p>
    <p>space and overlap area.  Some queries can be stopped before reaching the</p>
    <p>leaf level.</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Aggregation Query in the R*-tree</p>
    <p>R2</p>
    <p>R1R3</p>
    <p>R4</p>
    <p>R5R6</p>
    <p>Aggregate operator: count</p>
    <p>Each index entry is augmented with the total number of objects in its sub-tree.</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Aggregation Query in the RO-tree</p>
    <p>R2</p>
    <p>R1R3</p>
    <p>R4</p>
    <p>R5R6</p>
    <p>o4  Aggregate operator: count</p>
    <p>Each index entry is augmented with the total number of objects in its sub-tree.</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Nearest Neighbor Query in the R*-tree</p>
    <p>R2</p>
    <p>R1R3</p>
    <p>R4</p>
    <p>R5R6</p>
    <p>Q</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Nearest Neighbor Query in the RO-tree</p>
    <p>R2</p>
    <p>o1 R1R3</p>
    <p>R4</p>
    <p>R5R6</p>
    <p>Q</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Talk Outline  Background and Our Motivation  The RO-tree: Structure and Operations  Querying the RO-tree  Experimental Results  Conclusions</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Datasets and Setup  NE: 123,593 postal addresses (points).  US: 81,043 railroads (line segments).  CAmix: 62,556 locations (points) and 7,697</p>
    <p>poly-lines (large extent objects).</p>
    <p>Page size: 1KB, 2KB, 3KB, 4KB.  Fan-out for both the RO-tree and the R*-tree is</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Range Query (NE dataset)</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Aggregation Query (NE dataset)</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Nearest Neighbor Query</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Skyline Query</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Spatial Join Query</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Performance Comparison Query Type Performance</p>
    <p>Improvement</p>
    <p>Range Query 48%</p>
    <p>Aggregate Query 49%</p>
    <p>Nearest Neighbor Query 51%</p>
    <p>Skyline Query 40%</p>
    <p>Join Query 46%</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Talk Outline  Background and Our Motivation  The RO-tree: Structure and Operations  Querying the RO-tree  Experimental Results  Conclusions</p>
  </div>
  <div class="page">
    <p>November 4-5 , 2005</p>
    <p>Conclusions  We explored the idea of identification and storing</p>
    <p>outlier objects at higher levels of the spatial tree index.</p>
    <p>We proposed a simple but effective index structure, the RO-tree, which handles outlier objects gracefully.</p>
    <p>We showed how to adapt existing query algorithms on the RO-tree.</p>
    <p>Extensively experiments showed significant query improvements over the R*-tree.</p>
  </div>
  <div class="page">
    <p>November 4-5, 2005 ACM GIS'05, Bremen, Germany 41</p>
    <p>Thank you!</p>
  </div>
</Presentation>
