<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>SHIELDING SOFTWARE FROM PRIVILEGED</p>
    <p>SIDE-CHANNEL ATTACKS Xiaowan Dong University of Rochester</p>
    <p>Zhuojia Shen University of Rochester</p>
    <p>John Criswell University of Rochester</p>
    <p>Alan Cox Rice University</p>
    <p>Sandhya Dwarkadas University of Rochester</p>
  </div>
  <div class="page">
    <p>OS-Launched Side-Channel Attacks</p>
    <p>Applications assume OS is secure, however...</p>
    <p>OS can be compromised  Buffer overflows, information leak</p>
    <p>Shielding systems like Intel SGX can protect confidential application data from direct corruption</p>
    <p>A compromised OS can still launch sidechannel attacks</p>
    <p>Applications</p>
    <p>OS</p>
    <p>Shielding System</p>
    <p>Powerful side-channel attacks</p>
    <p>Operating Sytems</p>
    <p>Applications</p>
  </div>
  <div class="page">
    <p>OS-Launched Side-Channel Attacks</p>
    <p>CPU</p>
    <p>L1 Cache</p>
    <p>TLB</p>
    <p>CPU</p>
    <p>L1 Cache</p>
    <p>TLB</p>
    <p>L2 Cache</p>
    <p>Last-level Cache</p>
    <p>Exacerbate existing side channels  Infer the victims behavior based on</p>
    <p>shared architectural states (caches, TLBs)</p>
    <p>Control system events to alleviate noise</p>
    <p>Introduce new side channels  Trace page faults</p>
    <p>Monitor page table updates</p>
    <p>Core 1 Core 2</p>
  </div>
  <div class="page">
    <p>Why Shielding Systems Dont Help</p>
    <p>Shielding systems are supposed to protect confidential application data from compromised OS, however</p>
    <p>Page table is still managed by untrusted OS</p>
    <p>The OS and other untrusted applications still share architectural states with applications needing protection (Caches, TLB, etc.)</p>
  </div>
  <div class="page">
    <p>We focus on defending against page table sidechannel and Last-level cache (LLC) side-channel attacks from the OS kernel</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Examples of page table and cache side-channel attacks</p>
    <p>Background on Virtual Ghost</p>
    <p>Apparition</p>
    <p>Performance evaluation</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Examples of page table and cache side-channel attacks</p>
    <p>Background on Virtual Ghost</p>
    <p>Apparition</p>
    <p>Performance evaluation</p>
  </div>
  <div class="page">
    <p>Page Table Side Channels</p>
    <p>Infer victims memory access behavior</p>
    <p>Tracing page faults  Trigger page fault on every memory access</p>
    <p>Requires page table modification</p>
    <p>Can be used to recover entire secret document [1]</p>
    <p>Scanning ACCESS/DIRTY bit of page table entries  Monitor first memory read/write</p>
    <p>First memory read/write sets ACCESS/DIRTY bit</p>
    <p>Requires page table reads</p>
    <p>[1] Yuanzhong Xu, Weidong Cui, and Marcus Peinado. Controlled-channel attacks: Deterministic side channels for untrusted operating systems. Oakland. 2015.</p>
  </div>
  <div class="page">
    <p>LLC Side Channel: Prime + Probe Attack</p>
    <p>Attacker Infers the cache line accessed by the victim</p>
    <p>Prime: access</p>
    <p>Idle: while the victim accesses</p>
    <p>Probe: access again  If latency is longer, the victim has</p>
    <p>replaced with</p>
    <p>Flush + Reload has a similar rationale</p>
    <p>Core 1 Core 2</p>
    <p>LLC</p>
    <p>Main Memory Victim</p>
    <p>attacker</p>
  </div>
  <div class="page">
    <p>We Need to Prevent Compromised OS from Reading or Writing  Confidential application data</p>
    <p>Page tables containing translations for confidential application data</p>
    <p>Cache lines of confidential application data</p>
    <p>We leverage a shielding system called Virtual Ghost that already</p>
    <p>Prevents OS from reading and writing confidential application data</p>
    <p>Controls how OS configures page table</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Examples of page table and cache side-channel attacks</p>
    <p>Background on Virtual Ghost</p>
    <p>Apparition</p>
    <p>Performance evaluation</p>
  </div>
  <div class="page">
    <p>Background on Virtual Ghost</p>
    <p>A compiler-based virtual machine to protect application data from OS kernels</p>
    <p>Ports OS to virtual instruction set (V-ISA)</p>
    <p>Uses software fault isolation</p>
    <p>Forces OS kernel to invoke specific instructions to  Manipulate program state (e.g., context switch)</p>
    <p>Configure hardware state (e.g., MMU)</p>
    <p>Does not mitigate side-channel attacks</p>
    <p>Applications</p>
    <p>Virtual Ghost VM</p>
    <p>Processor</p>
    <p>OS Kernel V-ISA</p>
    <p>N-ISA</p>
  </div>
  <div class="page">
    <p>Protected Memory Regions</p>
    <p>OS cannot access protected memory regions  Secure user space</p>
    <p>Private to each application</p>
    <p>Virtual Ghost space</p>
    <p>Only accessible to Virtual Ghost VM</p>
    <p>Used for saving internal data structures</p>
    <p>User Space</p>
    <p>Secure User Space</p>
    <p>Virtual Ghost Space</p>
    <p>Kernel Space</p>
    <p>Virtual address space</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Examples of page table and cache side-channel attacks</p>
    <p>Background on Virtual Ghost</p>
    <p>Apparition</p>
    <p>Performance evaluation</p>
  </div>
  <div class="page">
    <p>Apparition</p>
    <p>Virtual Ghost + page table and LLC side-channel defenses</p>
    <p>Control native code generation of the kernel  Ensure the kernel is instrumented</p>
    <p>Applications</p>
    <p>Apparition VM</p>
    <p>Processor</p>
    <p>OS Kernel V-ISA</p>
    <p>N-ISA</p>
  </div>
  <div class="page">
    <p>PAGE TABLE SIDE-CHANNEL</p>
    <p>DEFENSES</p>
  </div>
  <div class="page">
    <p>Page Table Side-Channel Defenses</p>
    <p>Direct map: a range of virtual memory mapping the entire physical memory as a single block</p>
    <p>Page table pages normally accessed via direct map</p>
    <p>Prevent OS from reading or writing the page table of the protected memory regions</p>
    <p>Remove the entry mapping the page table page from the kernels direct map</p>
    <p>User Space</p>
    <p>Secure User Space</p>
    <p>Virtual Ghost Space</p>
    <p>Kernel Space</p>
    <p>Virtual address space</p>
    <p>Default Direct map used by the kernel</p>
    <p>Apparition VM internal Direct map</p>
    <p>Physical address space</p>
    <p>Page Table Page</p>
    <p>Page table page for protected</p>
    <p>memory regions</p>
  </div>
  <div class="page">
    <p>Paging Side Channels Defenses</p>
    <p>User Space</p>
    <p>Secure User Space</p>
    <p>Virtual Ghost Space</p>
    <p>Kernel Space</p>
    <p>Lazy memory allocation  OS maps the frame to the page when the</p>
    <p>application first reads or writes the page</p>
    <p>Side channel  Reveals paging behavior of the victim</p>
    <p>Defenses  Apparition VM manages secure user</p>
    <p>space memory allocation instead of OS</p>
    <p>Map physical frames upon allocation rather than at access time</p>
    <p>malloc()</p>
  </div>
  <div class="page">
    <p>LLC SIDE-CHANNEL</p>
    <p>DEFENSES</p>
  </div>
  <div class="page">
    <p>Defenses against LLC Side Channels</p>
    <p>Partition LLC to isolate applications from OS</p>
    <p>Assign different cache partitions to OS, Apparition VM, and applications needing protection</p>
    <p>Cache sets</p>
    <p>Cache Ways</p>
    <p>Apparition VMs partition</p>
    <p>Applications partition OSs partition</p>
  </div>
  <div class="page">
    <p>Intel Cache Allocation Technology</p>
    <p>Hardware feature that partitions LLC ways into subsets of smaller associativities</p>
    <p>Code can only evict cache lines in its partition, but can read any part of the LLC (no isolation on reads)</p>
    <p>Secure user space cache lines are not readable by OS</p>
    <p>Cache sets</p>
    <p>Cache Ways</p>
    <p>Apparition VMs partition</p>
    <p>Applications partition OSs partition</p>
  </div>
  <div class="page">
    <p>Cache Partitioning Configuration  Apparition VM</p>
    <p>configures cache partitioning at boot time</p>
    <p>prevents the OS from reconfiguring the partitions via its virtual instruction set</p>
    <p>switches to the corresponding cache partition based on the code running (application, Apparition VM, and OS)</p>
    <p>Cache sets</p>
    <p>Cache Ways</p>
    <p>Apparition VMs partition</p>
    <p>Applications partition OSs partition</p>
    <p>Interrupt, trap, syscall</p>
  </div>
  <div class="page">
    <p>Private Cache Partitions for Applications  Each application needing protection has its own cache partition</p>
    <p>First assign one cache partition to the first application</p>
    <p>Then divide it when more applications are scheduled</p>
    <p>Hardware partitions are shared when they run out  Flush the cache over context switch between two applications sharing partitions</p>
    <p>Cache sets</p>
    <p>Cache Ways</p>
    <p>App AApp A App B</p>
  </div>
  <div class="page">
    <p>Spectre and Meltdown Attacks</p>
    <p>Apparition helps prevent information leak via LLC side channel  Mitigates LLC side-channel attacks</p>
    <p>Our HASP paper [1] presents SFI that mitigates Spectre variant 1 and Meltdown</p>
    <p>[1] Xiaowan Dong, Zhuojia Shen, John Criswell, Alan Cox, and Sandhya Dwarkadas. Spectres, Virtual Ghosts, and Hardware Support. In HASP 18.</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Examples of page table and cache side-channel attacks</p>
    <p>Background on Virtual Ghost</p>
    <p>Apparition</p>
    <p>Performance evaluation</p>
  </div>
  <div class="page">
    <p>Methodology</p>
    <p>Experiment environment</p>
    <p>3.4 GHz Intel i7-6700 hyperthreading quad-core processor</p>
    <p>16-way 8 MB LLC</p>
    <p>16 GB RAM</p>
    <p>256 GB SSD</p>
    <p>FreeBSD 9.0 ported to Apparition</p>
    <p>Applications</p>
    <p>Tested CPU-intensive, network-intensive and file-system benchmarks</p>
    <p>A microbenchmark (that randomly accesses a large array)</p>
    <p>OpenSSH client</p>
    <p>Bzip2</p>
    <p>GnuPG</p>
    <p>Clang</p>
    <p>Highlight the results of a subset of applications evaluated</p>
  </div>
  <div class="page">
    <p>Methodology</p>
    <p>Bzip2:compress a 32 MB file</p>
    <p>Clang: compile gcc-smaller.c from SPEC CPU 2017</p>
    <p>GnuPG: cryptography program signing files of varying sizes</p>
    <p>All the applications put the heap in secure user space  We modified malloc() in libc.so</p>
    <p>User Space</p>
    <p>Secure User Space</p>
    <p>Virtual Ghost Space</p>
    <p>Kernel Space</p>
    <p>Virtual address space</p>
    <p>Heap</p>
  </div>
  <div class="page">
    <p>Page Table Side-Channel Defenses Overheads</p>
    <p>No additional overhead on Bzip2 and Clang</p>
    <p>Disabling lazy memory allocation does not incur overhead</p>
    <p>Bzip2 and Clang access most of the heap allocated at runtime</p>
    <p>Bzip2 Clang</p>
    <p>E xe</p>
    <p>cu ti</p>
    <p>o n</p>
    <p>t im</p>
    <p>e n</p>
    <p>o rm</p>
    <p>a li</p>
    <p>ze d</p>
    <p>to</p>
    <p>t h</p>
    <p>e n</p>
    <p>a ti</p>
    <p>v e</p>
    <p>( x</p>
    <p>)</p>
    <p>Apparition-w/o-def Apparition-PG-def</p>
  </div>
  <div class="page">
    <p>Page Table Side-Channel Defenses Overheads</p>
    <p>File Size Apparitionw/o-def</p>
    <p>ApparitionPG-def</p>
    <p>x ms (x + 14) ms</p>
    <p>A constant overhead of 14 ms due to disabling lazy memory allocation</p>
    <p>Additional cost of allocating and mapping 8 MB physical memory that is not accessed at runtime  Due to alignment issue of the first</p>
    <p>invocation of malloc()</p>
    <p>Overhead negligible as file size increases</p>
    <p>GnuPG signing files results.</p>
  </div>
  <div class="page">
    <p>LLC Side-Channel Defenses</p>
    <p>Simple approach: We statically partition the LLC into three parts  Our processor supports four cache partitions</p>
    <p>Experimentally determined cache partitioning that is close to the baseline performance</p>
    <p>Applications partition Apparition VMs partition</p>
    <p>OSs partition</p>
    <p>Application 12 ways</p>
    <p>Apparition VM 2 ways</p>
    <p>OS kernel 2 ways</p>
  </div>
  <div class="page">
    <p>LLC Side-Channel Defenses Overheads</p>
    <p>No additional overhead to Bzip2 and Clang</p>
    <p>Bzip2 Clang</p>
    <p>E xe</p>
    <p>cu ti</p>
    <p>o n</p>
    <p>t im</p>
    <p>e n</p>
    <p>o rm</p>
    <p>a li</p>
    <p>ze d</p>
    <p>to</p>
    <p>t h</p>
    <p>e n</p>
    <p>a ti</p>
    <p>v e</p>
    <p>( x</p>
    <p>)</p>
    <p>Apparition-w/o-def</p>
    <p>Apparition-LLC-def</p>
  </div>
  <div class="page">
    <p>LLC Side-Channel Defenses Overheads</p>
    <p>Switching among different LLC partitions incurs overhead</p>
    <p>Larger file size more read/write syscalls larger cache partition switching overhead</p>
    <p>For 8 MB to 32 MB files, the overhead is negligible (1.05x on average)</p>
    <p>GnuPG signing files results.</p>
    <p>File Size Apparitionw/o-defenses</p>
    <p>ApparitionLLC-def</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Compromised OS is powerful enough to exacerbate existing side channels and introduce new side channels</p>
    <p>A compiler-based approach like Virtual Ghost can be leveraged to mitigate OS-launched page table and LLC side-channel attacks</p>
    <p>Apparition defends against page table and LLC side-channel attacks with low overhead (1% to 18%)</p>
  </div>
</Presentation>
