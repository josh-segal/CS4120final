<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Early Release:Early Release:</p>
    <p>Friend or Foe?Friend or Foe?</p>
    <p>Travis SkareTravis Skare</p>
    <p>Christos KozyrakisChristos Kozyrakis</p>
    <p>WTW 2006WTW 2006</p>
    <p>Computer Systems LabComputer Systems Lab</p>
    <p>Stanford UniversityStanford University</p>
    <p>http://http://tcc.stanford.edutcc.stanford.edu</p>
  </div>
  <div class="page">
    <p>Motivation for Early ReleaseMotivation for Early Release</p>
    <p>Consider multiple transactions operating on a Consider multiple transactions operating on a</p>
    <p>long singlylong singly--linked listlinked list</p>
    <p>A write to the head of the list can cause a A write to the head of the list can cause a</p>
    <p>transaction working towards the end to abort.transaction working towards the end to abort.</p>
    <p>Violation</p>
  </div>
  <div class="page">
    <p>Early ReleaseEarly Release</p>
    <p>Early release enables transactions to clear Early release enables transactions to clear</p>
    <p>individual elements from their read sets at any individual elements from their read sets at any</p>
    <p>time before commit.time before commit.</p>
    <p>Other transactions writing to the address in the Other transactions writing to the address in the</p>
    <p>future will not cause a violation.future will not cause a violation.</p>
    <p>No Violation</p>
  </div>
  <div class="page">
    <p>Early Release: BenefitsEarly Release: Benefits</p>
    <p>Reduces violationsReduces violations</p>
    <p>Missing an opportunity for release does not affect Missing an opportunity for release does not affect</p>
    <p>original program semantics original program semantics</p>
    <p>A programmer can write an entire program, then go A programmer can write an entire program, then go</p>
    <p>back and implement ER later to increase performance back and implement ER later to increase performance</p>
    <p>Similar to the process of fineSimilar to the process of fine--tuning transactions for tuning transactions for</p>
    <p>speed increasesspeed increases</p>
  </div>
  <div class="page">
    <p>Early Release: DrawbacksEarly Release: Drawbacks</p>
    <p>Added programming complexityAdded programming complexitysimilar in many similar in many</p>
    <p>cases to finecases to fine--grained lockinggrained locking</p>
    <p>Missing a Release() doesnMissing a Release() doesnt cause race conditionst cause race conditions</p>
    <p>But adding too many can break correctnessBut adding too many can break correctness</p>
    <p>Could be used as a compiler optimizationCould be used as a compiler optimization</p>
    <p>Possible implementation overheadPossible implementation overhead</p>
    <p>Further complications if release granularity differs from Further complications if release granularity differs from</p>
    <p>word length (e.g., cacheword length (e.g., cache--line granularity) line granularity)</p>
  </div>
  <div class="page">
    <p>This StudyThis Study</p>
    <p>Will implementing Early Release be beneficial inside Will implementing Early Release be beneficial inside</p>
    <p>a collection of data structures?a collection of data structures?</p>
    <p>Linked ListLinked List</p>
    <p>Hashtable Hashtable</p>
    <p>AVL TreeAVL Tree</p>
    <p>BB--Tree Tree</p>
    <p>ArrayArray--based heap (priority queue)based heap (priority queue)</p>
    <p>Variety of work sizes, benchmark settings Variety of work sizes, benchmark settings</p>
    <p>Code chosen to be beneficial to ERCode chosen to be beneficial to ER</p>
    <p>If no gain here, unlikely to find gain in If no gain here, unlikely to find gain in realreal apps.apps.</p>
  </div>
  <div class="page">
    <p>MethodologyMethodology</p>
    <p>Stanford TCC SystemStanford TCC System</p>
    <p>11--32 Processors32 Processors</p>
    <p>Variable workload in between transactionsVariable workload in between transactions</p>
    <p>Kept small in resultsKept small in results</p>
    <p>30% read, 35% add, 35% remove30% read, 35% add, 35% remove</p>
    <p>6,000 element pre6,000 element pre--populationpopulation  Some affinity for keys that will be added/removed Some affinity for keys that will be added/removed</p>
    <p>88--byte random keys, integer data byte random keys, integer data</p>
  </div>
  <div class="page">
    <p>LinkedLinked--List Example (FG)List Example (FG) int List_Insert_FineGrain(LinkedList *list, string searchKey, int data){</p>
    <p>ListNode *insert = CreateNode(search, data); ListNode *prev = list-&gt;head, *cur=prev-&gt;next;</p>
    <p>Lock(list-&gt;head-&gt;lock); while(cur!=NULL){</p>
    <p>Lock(cur-&gt;lock); // hand-over-hand locking (1) if(searchKey&lt;=cur-&gt;key){</p>
    <p>insert-&gt;next=cur; prev-&gt;next=insert; Unlock(prev-&gt;lock); Unlock(cur-&gt;lock); return 1;</p>
    <p>} Unlock(prev-&gt;lock); // hand-over-hand locking (2) prev=cur; cur=cur-&gt;next;</p>
    <p>} insert-&gt;next=NULL; prev-&gt;next=insert; Unlock(prev-&gt;lock); // release last lock held return 1;</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>LinkedLinked--List Examples (TM/ER)List Examples (TM/ER) int List_Insert_EarlyR(LinkedList *list, string searchKey, int data){</p>
    <p>ListNode *insert = CreateNode(search, data); ListNode *prev=list-&gt;head, *cur=prev-&gt;next;</p>
    <p>while(cur!=NULL){ // &amp;prev-&gt;next has RS bits set by access (Lock) if(searchKey&lt;=cur-&gt;key){</p>
    <p>insert-&gt;next=cur; prev-&gt;next=insert; TCC_Release(&amp;prev-&gt;next); TCC_Release(&amp;insert-&gt;next); return 1;</p>
    <p>} TCC_Release(&amp;prev-&gt;next); // release unused element</p>
    <p>// compare to Unlock() prev=cur; cur=cur-&gt;next;</p>
    <p>} insert-&gt;next=NULL; prev-&gt;next=insert; TCC_Release(&amp;prev-&gt;next); // compare to Unlock TCC_Release(&amp;insert-&gt;next); // but would be correct without ER return 1;</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Results: Linked ListResults: Linked List</p>
    <p>SequentialSequential data structure data structure  single point of entry, single point of entry,</p>
    <p>single path through datasingle path through data</p>
    <p>ER does help here ER does help here  beats out even FG locking beats out even FG locking</p>
    <p>due to lock/unlock overheadsdue to lock/unlock overheads</p>
    <p>Linked List</p>
    <p>TM TM+ER CG FG</p>
    <p>% o f S e q u e n ti a l T im e</p>
    <p>Release</p>
    <p>Violation</p>
    <p>Useful</p>
  </div>
  <div class="page">
    <p>Results: Results: HashtableHashtable</p>
    <p>Most parallelizable data structure Most parallelizable data structure  statistically statistically transactions operate on different buckets transactions operate on different buckets  256 Buckets used in trials256 Buckets used in trials</p>
    <p>ER rarely helps here: ER rarely helps here: nanaveve TM approach is TM approach is even ~1% faster and rivals FG codeeven ~1% faster and rivals FG code</p>
    <p>Hash Table</p>
    <p>TM TM+ER CG FG</p>
    <p>% o f S e q u e n ti a T im e</p>
    <p>Release</p>
    <p>Violation</p>
    <p>Useful</p>
  </div>
  <div class="page">
    <p>Results: ArrayResults: Array--based heapbased heap</p>
    <p>NaNave implementation (though concurrent ones exist)ve implementation (though concurrent ones exist)</p>
    <p>High contention over a few elementsHigh contention over a few elements</p>
    <p>Early release enhances system scalabilityEarly release enhances system scalability</p>
    <p>Violations still occur (bubbleViolations still occur (bubble--up, etc)up, etc)</p>
    <p>Array-based Heap</p>
    <p>TM TM+ER CG FG</p>
    <p>% o f S e q u e n ti a l T Im e</p>
    <p>Release</p>
    <p>Violation</p>
    <p>Useful Scalability?</p>
  </div>
  <div class="page">
    <p>Results: AVL TreeResults: AVL Tree</p>
    <p>There are still violations in the ER caseThere are still violations in the ER case</p>
    <p>Cannot use ER when balancing the tree, etc.Cannot use ER when balancing the tree, etc.</p>
    <p>ER does show some benefit, especially in scalabilityER does show some benefit, especially in scalability</p>
    <p>For less stressful workloads, ER not so beneficial.For less stressful workloads, ER not so beneficial.</p>
    <p>AVL Tree</p>
    <p>TM TM+ER CG FG</p>
    <p>% o f S e q u e n ti a l T im e</p>
    <p>Release</p>
    <p>Violation</p>
    <p>Useful</p>
  </div>
  <div class="page">
    <p>Results: BResults: B--TreeTree</p>
    <p>Very Parallelizable Very Parallelizable</p>
    <p>We still see some violations with splitting, rotationsWe still see some violations with splitting, rotations  Cannot use ER in these casesCannot use ER in these cases</p>
    <p>Not many violations to reduce from the TM caseNot many violations to reduce from the TM case</p>
    <p>B-Tree</p>
    <p>TM TM+ER CG FG</p>
    <p>% o f S e q u e n ti a l T im e</p>
    <p>Release</p>
    <p>Violation</p>
    <p>Useful</p>
  </div>
  <div class="page">
    <p>ConclusionsConclusions</p>
    <p>Studied effects of Early Release on five structuresStudied effects of Early Release on five structures</p>
    <p>No performance boost for parallel structures No performance boost for parallel structures</p>
    <p>HashtableHashtable, Trees, Trees</p>
    <p>Should generalize to most userShould generalize to most user--level application codelevel application code</p>
    <p>There are applications where ER has advantagesThere are applications where ER has advantages</p>
    <p>Heap, rough performance counters, etcHeap, rough performance counters, etc</p>
    <p>ScalabilityScalability</p>
    <p>But programmer could use better structures, nesting, etc.But programmer could use better structures, nesting, etc.</p>
    <p>Also consider programming complexityAlso consider programming complexity</p>
  </div>
</Presentation>
