<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>MoonShine: Optimizing OS Fuzzer Seed Selection with Trace Distillation</p>
    <p>Shankara Pailoor, Andrew Aday, Suman Jana Columbia University</p>
  </div>
  <div class="page">
    <p>Popular technique to find OS vulnerabilities  Primarily tests system-call interface</p>
    <p>Can be invoked by untrusted user programs</p>
    <p>Large surface area for attack</p>
    <p>OS Fuzzing</p>
  </div>
  <div class="page">
    <p>OS Fuzzing - Overview</p>
    <p>Seeds</p>
    <p>Fuzzer OS</p>
    <p>Synthetic Programs</p>
    <p>Feedback</p>
    <p>fd = open() write(fd, ) close(fd)</p>
  </div>
  <div class="page">
    <p>OS Fuzzing - Overview</p>
    <p>Seeds</p>
    <p>Fuzzer OS</p>
    <p>Synthetic Programs</p>
    <p>Feedback</p>
    <p>fd = open() write(fd, ) close(fd)</p>
  </div>
  <div class="page">
    <p>Synthetic Program Generation  Goal  Maximize code coverage  Random generation alone is unlikely to succeed</p>
    <p>Linux Programmers Manual</p>
    <p>#include &lt;unistd.h&gt;</p>
    <p>size_t write(int fd, const void *buf, size_t count);</p>
    <p>Opened with write permissions</p>
    <p>Valid userspace pointer</p>
  </div>
  <div class="page">
    <p>Synthetic Program Generation  Goal  Maximize code coverage  Random generation alone is unlikely to succeed</p>
    <p>o Fuzzer must track and maintain system-call dependencies</p>
  </div>
  <div class="page">
    <p>Synthetic Program Generation  Goal  Maximize code coverage  Random generation alone is unlikely to succeed</p>
    <p>o Fuzzer must track and maintain system-call dependencies  State-of-the-art  Thousands of hardcoded rules!!</p>
    <p>resource fd[int32]  open(file ptr[in], ) fd write(f fd, buf buffer[in], count len[buf])</p>
  </div>
  <div class="page">
    <p>Synthetic Program Generation  Goal  Maximize code coverage  Random generation alone is unlikely to succeed</p>
    <p>o Fuzzer must track and maintain system-call dependencies  State-of-the-art  Templates with thousands of manual rules  Hard to scale</p>
  </div>
  <div class="page">
    <p>MoonShine</p>
    <p>Real Program Traces</p>
    <p>Distilled Seeds</p>
  </div>
  <div class="page">
    <p>Trace Distillation vs. User-Level Seed Selection</p>
    <p>MinSet (Sec14) o Find smallest subset with most coverage o Subset of traces is not good enough! L o Subset of calls is better but we need dependencies!</p>
    <p>Afl-tmin o Dynamically removes blocks of data while preserving coverage o Prohibitively slow with traces! Doesnt scale o Needs to understand system call dependencies!</p>
  </div>
  <div class="page">
    <p>Distillation Challenges</p>
    <p>Minimize trace sizes</p>
    <p>Track dependencies</p>
  </div>
  <div class="page">
    <p>Why does trace size matter?  Fuzzer performance tied to</p>
    <p>program size (# calls)</p>
    <p>10 second trace of Chromium contains 462,225 calls!!</p>
    <p>Traces cant be directly used as seeds</p>
    <p>Measured against Syzkaller</p>
  </div>
  <div class="page">
    <p>Trace Distillation</p>
    <p>Goal  Minimize the traces while preserving coverage</p>
    <p>Strategy  Select calls that contribute most coverage</p>
    <p>strace /bin/ls 359 35 Total Calls New Coverage</p>
  </div>
  <div class="page">
    <p>Dependencies</p>
    <p>Explicit Dependencies o Shared state passed through arguments</p>
    <p>Implicit Dependencies o Modify shared kernel data structure</p>
  </div>
  <div class="page">
    <p>Explicit Dependencies  Call A is explicitly dependent on call B if B produces a result</p>
    <p>used by A</p>
  </div>
  <div class="page">
    <p>Implicit Dependencies  Call A is implicitly dependent on Call B if B affects the execution of A</p>
    <p>by modifying a shared kernel data structure</p>
    <p>mlockall(int lock_flags) msync(void *addr, size_t length, int flags)</p>
    <p>int mlockall() {  void mlock_fixup_lock {</p>
    <p>if (lock)</p>
    <p>vma-&gt;vm_flags = lock_flags }</p>
    <p>int msync() {  if (vma-&gt;vm_flags &amp; VM_LOCKED)</p>
    <p>error = -EBUSY</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Tracking Explicit Dependencies  Statically analyze trace  Return Cache: Map&lt;(Type, Ret-Val), List&lt;Call&gt;&gt;</p>
    <p>o data type or semantic type (e.g., file descriptor)  If (type, value) key in Return Cache, then every call that</p>
    <p>returned this key is marked as explicit dependency.</p>
  </div>
  <div class="page">
    <p>Tracking Implicit Dependencies</p>
    <p>Control and Data Flow Analysis  Call c uses shared variable v in conditional  c is read dependent on v  Call c writes to shared variable v  c is write dependent on v</p>
    <p>Write Read</p>
    <p>If (Overlap != NULL) =&gt; Implicit Dependency</p>
    <p>Call B Call A</p>
  </div>
  <div class="page">
    <p>Working Example Trace Excerpt Distilled Trace</p>
    <p>-EBUSY = msync(0x7b2000, , MS_INVALIDATE)</p>
    <p>mlockall(MCL_FUTURE)</p>
  </div>
  <div class="page">
    <p>Working Example</p>
    <p>-EBUSY = msync(0x7b2000, , MS_INVALIDATE)</p>
    <p>mlockall(MCL_FUTURE)</p>
    <p>Trace Excerpt Distilled Trace</p>
  </div>
  <div class="page">
    <p>Working Example</p>
    <p>-EBUSY = msync(0x7b2000, , MS_INVALIDATE)</p>
    <p>mlockall(MCL_FUTURE)</p>
    <p>Distilled TraceTrace Excerpt</p>
  </div>
  <div class="page">
    <p>Working Example  Explicit Dependencies</p>
    <p>-EBUSY = msync(0x7b2000, , MS_INVALIDATE)</p>
    <p>mlockall(MCL_FUTURE)</p>
    <p>Distilled TraceTrace Excerpt</p>
    <p>Explicit Dependencies</p>
  </div>
  <div class="page">
    <p>Working Example  Implicit Dependencies</p>
    <p>-EBUSY = msync(0x7b2000, , MS_INVALIDATE)</p>
    <p>mlockall(MCL_FUTURE)</p>
    <p>Distilled TraceTrace Excerpt</p>
    <p>Implicit Dependencies</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Linux Kernel  Syzkaller  OS Fuzzer (Google)  Strace  System-call traces  Kcov  Coverage  Smatch  Static analysis framework</p>
    <p>o Read deps. with Condition Hook o Write deps. with Unary Op and Assign. Hooks</p>
    <p>2580 lines of Golang and 640 lines of C 24</p>
  </div>
  <div class="page">
    <p>Evaluation - Setup</p>
    <p>Seed Source Number of Traces</p>
    <p>Glibc Testsuite 1120</p>
    <p>Linux Kernel Selftests 55</p>
    <p>Linux Testing Project (LTP) 390</p>
    <p>Open Posix Testsuite 1630</p>
  </div>
  <div class="page">
    <p>New Vulnerabilities</p>
  </div>
  <div class="page">
    <p>Coverage Improvement  13.1% coverage</p>
    <p>increase over default Syzkaller with implicit + explicit</p>
    <p>9.7% coverage increase over default Syzkaller with only explicit</p>
  </div>
  <div class="page">
    <p>Effectiveness of Distillation</p>
    <p>Total Calls After Distillation Comparison Coverage Preserved</p>
  </div>
  <div class="page">
    <p>Vulnerability Discovered By MoonShine</p>
  </div>
  <div class="page">
    <p>inotify_handle_event(..., file_name) { //file_name is currently HelloWorld len = strlen(file_name); alloc_len += len + 1; event = kmalloc(alloc_len, GFP_KERNEL);</p>
    <p>Exhibit: Buffer Overflow in inotify (CVE-2017-7533) CPU 1</p>
    <p>sys_rename(..., new_name) { //new_name is LongFileName  copy_name(file_name, new_name) //file_name changed to LongFileName</p>
    <p>}</p>
    <p>CPU 2</p>
    <p>strcpy(event-&gt;name, file_name); //strcpy will now overflow event</p>
    <p>}</p>
    <p>Privilege Escalation</p>
  </div>
  <div class="page">
    <p>Exhibit: Buffer Overflow in inotify (CVE-2017-7533)</p>
    <p>Seed Distilled by MoonShine</p>
  </div>
  <div class="page">
    <p>Exhibit: Buffer Overflow in inotify (CVE-2017-7533)</p>
    <p>Seed Distilled by MoonShine</p>
  </div>
  <div class="page">
    <p>Exhibit: Buffer Overflow in inotify (CVE-2017-7533)</p>
    <p>Crash-inducing mutation</p>
  </div>
  <div class="page">
    <p>Conclusion  State-of-the-art OS fuzzers rely on manual rules</p>
    <p>o Hard to scale  MoonShine scalably generates seeds from traces of real-world</p>
    <p>programs o Lightweight static analysis to track explicit and implicit dependencies</p>
    <p>Discovered 17 new vulnerabilities in Linux kernel</p>
    <p>https://github.com/shankarapailoor/moonshine Getting integrated into syzkaller</p>
  </div>
  <div class="page">
    <p>Backup Slides</p>
  </div>
  <div class="page">
    <p>Limitations/Future Work  Support more OS/Fuzzers  No multithreaded dependency tracking  Inter-procedural dependencies</p>
    <p>o Infer that a file must be created from trace  Multiple distillation strategies</p>
    <p>o distillation without code coverage?</p>
  </div>
  <div class="page">
    <p>Static Analysis False Positives/Negatives</p>
    <p>False Positives o Imprecise pointer analysis</p>
    <p>False Negatives o Incomplete AST traversal - function pointers</p>
    <p>o Shared state is not global variable or struct/union field</p>
    <p>o Aliased struct fields get modified  char *p = a-&gt;v; p[0] = 1</p>
  </div>
  <div class="page">
    <p>Coverage Breakdown</p>
  </div>
</Presentation>
