<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>F.F. Dragan F.F. Dragan (Kent State)(Kent State)</p>
    <p>A.B. Kahng A.B. Kahng (UCSD)(UCSD)</p>
    <p>I. Mandoiu I. Mandoiu (UCLA/UCSD)(UCLA/UCSD)</p>
    <p>S. Muddu S. Muddu (Sanera Systems)(Sanera Systems)</p>
    <p>A. Zelikovsky A. Zelikovsky (Georgia State)(Georgia State)</p>
    <p>Practical Approximation Algorithms for Separable Packing LPs</p>
    <p>Practical Approximation Algorithms for Separable Packing LPs</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>VLSI design motivation</p>
    <p>Global routing via buffer-blocks</p>
    <p>Separable packing ILP formulations</p>
    <p>PTAS for separable packing LPs</p>
    <p>Analysis</p>
    <p>Experimental results</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>VLSI design motivation</p>
    <p>Global routing via buffer-blocks</p>
    <p>Separable packing ILP formulations</p>
    <p>PTAS for separable packing LPs</p>
    <p>Analysis</p>
    <p>Experimental results</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>VLSI design motivation</p>
    <p>Global routing via buffer-blocks</p>
    <p>Separable packing ILP formulations</p>
    <p>PTAS for separable packing LPs</p>
    <p>Analysis</p>
    <p>Experimental results</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>VLSI design motivation</p>
    <p>Global routing via buffer-blocks</p>
    <p>Separable packing ILP formulations</p>
    <p>PTAS for separable packing LPs</p>
    <p>Analysis</p>
    <p>Experimental results</p>
  </div>
  <div class="page">
    <p>VLSI Global Routing</p>
  </div>
  <div class="page">
    <p>VLSI Global RoutingBuffered</p>
    <p>Buffer Blocks</p>
  </div>
  <div class="page">
    <p>Problem Formulation</p>
    <p>Global Routing via Buffer-Blocks (GRBB) Problem Given:</p>
    <p>BB locations and capacities  List of multi-pin nets</p>
    <p>upper-bound on #buffers for each source-sink path</p>
    <p>L/U bounds on the wirelength b/w consecutive buffers/pins Find:</p>
    <p>Buffered routing of a maximum number of nets subject to the given constraints</p>
  </div>
  <div class="page">
    <p>Integer Program Formulation</p>
    <p>}],[)(:)({</p>
    <p>BlocksBuffer terminals</p>
    <p>:),(graph Routing</p>
    <p>ULu,vdistu,vE</p>
    <p>V</p>
    <p>EVG</p>
    <p>otherwisecapacity BB terminal,is vif 1 cap(v)</p>
    <p>otherwise 0 , if 1 ),(</p>
    <p>}1,0{)(</p>
    <p>)(cap)(),(..</p>
    <p>)(max</p>
    <p>TvvT</p>
    <p>Tf</p>
    <p>vTfvTts</p>
    <p>Tf</p>
    <p>T</p>
    <p>T</p>
  </div>
  <div class="page">
    <p>Enforcing Parity Constraints</p>
    <p>Inverting buffers change the polarity of the signal  Each sink has a given polarity requirement</p>
    <p>Parity constraints for the #buffers on each routed source-sink path  A path may use two buffers in the same buffer block</p>
    <p>)(cap)()]'',()',([ rTfrTrT T</p>
    <p>Integer program changes  Split each BB vertex r of G into two copies, r and r  Impose capacity constraint on the sets of vertices {r,r}</p>
  </div>
  <div class="page">
    <p>Combining with compaction</p>
  </div>
  <div class="page">
    <p>Combining with compaction</p>
  </div>
  <div class="page">
    <p>Combining with compaction</p>
    <p>Set capacity constraints: cap(BB1) + cap(BB2)  const.</p>
  </div>
  <div class="page">
    <p>GRBB with Buffer Library</p>
    <p>Discrete buffer library: different buffer sizes/driving strengths  Need to allocate BB capacity between different buffer types</p>
    <p>)(cap)()'()',( )('</p>
    <p>rTfrsizerT T rXr</p>
    <p>Integer program changes  Replace each BB vertex r of G by a set X(r) of vertices (one</p>
    <p>for each buffer type)  Modify edge set of G to take into account non-uniform</p>
    <p>driving strengths  Impose capacity constraint on the sets of vertices X(r):</p>
  </div>
  <div class="page">
    <p>Relax+Round Approach to GRBB</p>
    <p>Exact linear programming algorithms are impractical for large instances</p>
    <p>KEY IDEA: use an approximation algorithm</p>
    <p>allows fine-tuning the tradeoff between runtime and solution quality</p>
    <p>Provably good rounding [RT87]</p>
    <p>Practical runtime (random-walk based)</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>VLSI design motivation</p>
    <p>Global routing via buffer-blocks</p>
    <p>Separable packing LP formulations</p>
    <p>PTAS for separable packing LPs</p>
    <p>Analysis</p>
    <p>Experimental results</p>
  </div>
  <div class="page">
    <p>Separable Packing LP</p>
    <p>vZcap</p>
    <p>vvsizeRVsize</p>
    <p>EVG</p>
    <p>V inalevery termfor 1cap({v}) s.t. 2:function Capacity</p>
    <p>inalevery termfor 1)( s.t. :function Size</p>
    <p>),(graph Routing</p>
    <p>X</p>
    <p>T</p>
    <p>T</p>
    <p>vsizevTXT</p>
    <p>Tf</p>
    <p>XTfXTts</p>
    <p>Tf</p>
    <p>)(),( ),(</p>
    <p>)(cap)(),(..</p>
    <p>)(max</p>
  </div>
  <div class="page">
    <p>Previous Work</p>
    <p>MCF and packing/covering LP approximation: [FGK73,SM90, PST91,G92,GK94,KPST94,LMPSTT95,R95,Y95,GK98,F00,]</p>
    <p>Exponential length function to model flow congestion [SM90]</p>
    <p>Shortest-path augmentation + final scaling [Y95]</p>
    <p>Modified routing increment [GK98]</p>
    <p>Fewer shortest-path augmentations [F00]</p>
    <p>We extend speed-up idea of [F00] to separable packing LPs</p>
  </div>
  <div class="page">
    <p>Separable Packing LP Algorithm</p>
    <p>w(X)  , f  0,  =  For i = 1 to N do For k = 1, , #nets do Find min weight feasible Steiner tree T for net k While weight(T) &lt; min{ 1, (1+) } do f(T)= f(T) + 1 For every X do w(X)  ( 1 +  (T,X)/cap(X) ) * w(X) End For Find min weight feasible Steiner tree T for net k End While End For  = (1+) End For Output f/N</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>VLSI design motivation</p>
    <p>Global routing via buffer-blocks</p>
    <p>Separable packing ILP formulations</p>
    <p>PTAS for separable packing LPs</p>
    <p>Analysis</p>
    <p>Experimental results</p>
  </div>
  <div class="page">
    <p>Runtime</p>
    <p>)(cap)(min</p>
    <p>Xf</p>
    <p>XwXTts</p>
    <p>XXw</p>
    <p>X</p>
    <p>X</p>
    <p>Dual LP:</p>
    <p>Choose #iterations N such that all feasible trees have weight 1 after N iterations (i.e.,  1)</p>
    <p>Tree weight lower bound is  initially, and is multiplied by (1+) in each iteration</p>
  </div>
  <div class="page">
    <p>Approximation Guarantee</p>
    <p>)log)nets(#( 2 LTO tree</p>
    <p>Theorem: For every &lt;.15, the algorithm finds factor</p>
    <p>where L is the maximum number of vertices in a</p>
    <p>feasible Steiner tree. For this value of , the running</p>
    <p>time is</p>
    <p>1</p>
    <p>))1)((1(</p>
    <p>L</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>VLSI design motivation</p>
    <p>Global routing via buffer-blocks</p>
    <p>Separable packing ILP formulations</p>
    <p>PTAS for separable packing LPs</p>
    <p>Analysis</p>
    <p>Experimental results</p>
  </div>
  <div class="page">
    <p>Implementation choices</p>
    <p>Decomposition Star, Minimum</p>
    <p>Spanning tree</p>
    <p>Matching, 3-restricted Steiner tree</p>
    <p>Not needed</p>
    <p>Min-weight DRST Shortest path (exact)</p>
    <p>Try all Steiner pts + shortest paths</p>
    <p>(exact)</p>
    <p>Very hard! heuristics</p>
    <p>Rounding Random-walk Backward random-walks</p>
  </div>
  <div class="page">
    <p>Number of routed nets  (1- )OPT</p>
    <p>With high probability, no BB capacity is exceeded</p>
    <p>Problem: Impractical to store all non-zero flow trees</p>
    <p>Provably Good Rounding</p>
  </div>
  <div class="page">
    <p>Number of routed nets  (1- )OPT</p>
    <p>With high probability, no BB capacity is exceeded</p>
    <p>Random-Walk 2-TMCF Rounding</p>
    <p>use random walk from source to sink</p>
    <p>Practical: random walk requires storing only flows on edges</p>
  </div>
  <div class="page">
    <p>Random-Walk MTMCF Rounding</p>
    <p>S T1</p>
    <p>T2</p>
    <p>T3SourceSinks</p>
  </div>
  <div class="page">
    <p>Random-Walk MTMCF Rounding</p>
    <p>S T1</p>
    <p>T2</p>
    <p>T3SourceSinks</p>
  </div>
  <div class="page">
    <p>The MTMCF Rounding Heuristic</p>
    <p>random walks</p>
    <p>No scaling-down, approximate MTMCF &lt; OPT</p>
    <p>Few violations</p>
    <p>Further routing still possible</p>
  </div>
  <div class="page">
    <p>Implemented Heuristics</p>
    <p>Greedy buffered routing: 1. For each net, route sinks sequentially along shortest paths to</p>
    <p>source or node already connected to source</p>
    <p>Generalized MCF approximation + randomized rounding  G2TMCF</p>
    <p>G3TMCF (3-pin decomposition)</p>
    <p>G4TMCF (4-pin decomposition)</p>
    <p>GMTMCF (no decomposition, approximate DRST)</p>
  </div>
  <div class="page">
    <p>Experimental Setup</p>
    <p>Test instances extracted from next-generation SGI microprocessor</p>
    <p>Up to 5,000 nets, ~6,000 sinks</p>
    <p>U=4,000 m, L=500-2,000 m</p>
    <p>50 buffer blocks</p>
    <p>200-400 buffers / BB</p>
  </div>
  <div class="page">
    <p>% Routed Nets vs. Runtime</p>
    <p>CPU Seconds</p>
    <p>% r</p>
    <p>o u</p>
    <p>te d</p>
    <p>n e</p>
    <p>ts</p>
    <p>MT-Greed</p>
    <p>G2TMCF</p>
    <p>G3TMCF</p>
    <p>G4TMCF</p>
    <p>GMTMCF</p>
  </div>
  <div class="page">
    <p>Conclusions and Ongoing Work</p>
    <p>Provably good algorithms and practical heuristics based on separable packing LP approximation  Higher completion rates than previous algorithms</p>
    <p>Extensions:  Combine global buffering with BB planning  Buffer site methodology  tile graph  Routing congestion (channel capacity constraints)  Simultaneous pin assignment</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>% Sinks Connected</p>
    <p>#sinks/ #nets</p>
    <p>Greed</p>
    <p>G2TMCF G3TMCF G4TMCF GMTMCF</p>
    <p>=.6=.6 44</p>
    <p>=.0=.0 44</p>
    <p>=.6=.6 44</p>
    <p>=.0=.0 44</p>
    <p>=.6=.6 44</p>
    <p>=.0=.0 44</p>
    <p>=.6=.6 44</p>
    <p>=.0=.0 44</p>
  </div>
  <div class="page">
    <p>Runtime (sec.)</p>
    <p>#sinks/ #nets</p>
    <p>Greed</p>
    <p>G2TMCF G3TMCF G4TMCF GMTMCF</p>
    <p>=.6=.6 44</p>
    <p>=.0=.0 44</p>
    <p>=.6=.6 44</p>
    <p>=.0=.0 44</p>
    <p>=.6=.6 44</p>
    <p>=.0=.0 44</p>
    <p>=.6=.6 44</p>
    <p>=.0=.0 44</p>
  </div>
  <div class="page">
    <p>Resource Usage</p>
    <p>Greed</p>
    <p>G2TMCF G3TMCF G4TMCF GMTMCF</p>
    <p>=.6=.6 44</p>
    <p>=.0=.0 44</p>
    <p>=.6=.6 44</p>
    <p>=.0=.0 44</p>
    <p>=.6=.6 44</p>
    <p>=.0=.0 44</p>
    <p>=.6=.6 44</p>
    <p>=.0=.0 44</p>
    <p># Conn. Sinks</p>
    <p>% Conn. Sinks</p>
    <p>WL (meters)</p>
    <p>WL/sink (microns)</p>
    <p>#Buff 9037 9,860 10,676 9,591 10,610 9,497 10,507 9,860 10,647</p>
    <p>#Buff/sink 1.60 1.72 1.83 1.66 1.80 1.63 1.77 1.70 1.81</p>
    <p>#nets = 4,764 #sinks = 6,038 400 buffers/BB</p>
  </div>
  <div class="page">
    <p>Resource Usage for 100% Completion</p>
    <p>Greed 4TMCF, =.04=.04</p>
    <p>#buffers/BB 1,000 or INF 500 600 1,000 INF</p>
    <p>WL (meters) 47.89 49.46 49.58 49.98 51.40</p>
    <p>WL/sink (microns)</p>
    <p>#Buff 10,330 11,079 11,115 11,373 11.803</p>
    <p>#Buff/sink 1.71 1.83 1.84 1.88 1.95</p>
    <p>#nets = 4,764 #sinks = 6,038 MTMCF wastes routing resources!</p>
  </div>
</Presentation>
