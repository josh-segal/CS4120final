<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Bounded Model Checking of Concurrent Data Types on Relaxed</p>
    <p>Memory Models: A Case Study</p>
    <p>Sebastian Burckhardt Rajeev Alur</p>
    <p>Milo M. K. Martin</p>
    <p>Department of Computer and Information Science</p>
    <p>University of Pennsylvania</p>
    <p>CAV 2006, Seattle</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-2</p>
    <p>software multiprocessor</p>
    <p>concurrent executions</p>
    <p>bugs</p>
    <p>The General Problem</p>
    <p>concurrency libraries can help</p>
    <p>e.g. Java JSR-166  but how to debug the</p>
    <p>libraries?</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-3</p>
    <p>optimized implementations of concurrent datatypes</p>
    <p>shared-memory multiprocessor with relaxed memory model</p>
    <p>bugs</p>
    <p>The Specific Problem</p>
    <p>case study: use SAT solver to find bugs</p>
    <p>concurrent executions</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-4</p>
    <p>Case Study: Two-Lock Queue  Algorithm published by M. Michael and M. Scott [PODC 1996]</p>
    <p>head</p>
    <p>lock</p>
    <p>tail</p>
    <p>lock</p>
    <p>Singly linked list with head and tail pointers  Dummy node at front  Independent head and tail locks</p>
    <p>allows for concurrent enqueue() and dequeue()  Race condition if queue is empty</p>
    <p>head</p>
    <p>lock</p>
    <p>tail</p>
    <p>lock</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-5</p>
    <p>client program observes  ordering of operation calls within each thread  argument and return values of the operation</p>
    <p>code is correct if and only if all executions are observationally equivalent to some serial execution (def. serial: interleaved at operation boundaries only)</p>
    <p>We assume serial executions are correct (can be verified by convential sequential methods)</p>
    <p>thread 1</p>
    <p>enqueue(1) enqueue(2)</p>
    <p>thread 2</p>
    <p>enqueue(3) dequeue()  1</p>
    <p>thread 3</p>
    <p>dequeue()  3 dequeue()  2</p>
    <p>Case Study: Our Correctness Criterion</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-6</p>
    <p>Finer Interleavings = More Executions</p>
    <p>serial executions threads interleave the operations (operations are atomic)</p>
    <p>(operations are in-order)  sequentially consistent executions</p>
    <p>threads interleave the instructions</p>
    <p>(instructions are atomic)</p>
    <p>(instructions are in-order)  relaxed executions</p>
    <p>hardware makes performance-motivated compromises (stores may be non-atomic)</p>
    <p>(loads/stores may be out-of-order)</p>
    <p>Serial</p>
    <p>SC</p>
    <p>Relaxed</p>
    <p>Reordered Instructions = More Executions</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-7</p>
    <p>Case Study: Relaxed Memory Models  Example:</p>
    <p>output not consistent with any interleaved execution!  can be the result of out-of-order stores  can be the result of out-of-order loads  improves performance (more choices for processor)</p>
    <p>Q: Why doesnt everything break? A: Relaxations are transparent to normal programs  uniprocessor semantics are preserved  library code for lock/unlock contains memory ordering fences</p>
    <p>x = 1 y = 2</p>
    <p>print y print x</p>
    <p>thread 1 thread 2</p>
    <p>2  0</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-8</p>
    <p>Which Memory Model?</p>
    <p>Memory models are platform dependent</p>
    <p>We use a conservative approximation Relaxed to capture common effects</p>
    <p>Once code is correct for Relaxed, it is correct for all models</p>
    <p>See paper for formal spec of Relaxed</p>
    <p>TSO</p>
    <p>PSO</p>
    <p>PPCAlpha</p>
    <p>Relaxed</p>
    <p>RMO</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-9</p>
    <p>Halftime Overview</p>
    <p>General motivation  Case study parameters</p>
    <p>Two-lock queue implementation  Correctness criterion  Relaxed memory models</p>
    <p>Our verification method  Symbolic tests  SAT encoding</p>
    <p>Results  Bugs found  Evaluation &amp; Conclusion</p>
    <p>done</p>
    <p>coming up</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-10</p>
    <p>Our Verification Method</p>
    <p>Encoder SAT solver</p>
    <p>implementation code with commit points</p>
    <p>symbolic test</p>
    <p>pass counterexample</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-11</p>
    <p>thread 1</p>
    <p>enqueue(X)</p>
    <p>thread 2</p>
    <p>dequeue()  Y</p>
    <p>How To Bound Executions</p>
    <p>Verify individual symbolic tests  finite number of operations  nondeterministic instruction order  nondeterministic input values</p>
    <p>Example (this is the smallest one in our test suite)</p>
    <p>User creates suite of tests of increasing size</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-12</p>
    <p>Why symbolic test programs?</p>
    <p>... is bounded for individual test  Sequential consistency is undecidable</p>
    <p>... is decidable for individual test</p>
    <p>.... can directly encode value flow between instructions  Memory model specified by axioms</p>
    <p>.... can directly encode ordering axioms on instructions</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-13</p>
    <p>Implementation code</p>
    <p>we hand-translated Michael &amp; Scotts code (above) into a low-level representation that uses explicit loads, stores</p>
    <p>we added code for dynamic memory allocation and locks</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-14</p>
    <p>Commit points</p>
    <p>designate where the operation commits logically</p>
    <p>given order of commit points, we can construct serial witness execution</p>
    <p>eliminates the  in  executions  equivalent serial execution</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-15</p>
    <p>Counterexample Tracethread 1 enqueue (1)</p>
    <p>thread 2 dequeue()  0</p>
    <p>commit point order (3 &lt; 6) indicates that enqueue precedes dequeue, so we would expect dequeue()  1</p>
    <p>incorrect value (0) of queue element gets read (7) before correct value (1) is being written (11).</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-16</p>
    <p>Encoding</p>
    <p>Given  symbolic test T(A, B)  memory model Y  implementation code &amp; commit point specifications</p>
    <p>Encoding  First step: encode concurrent executions of T on Y as solutions to</p>
    <p>CNF formula Y(A, B, X) (aux vars X)  Second step: encode counterexamples as solutions to</p>
    <p>Y(A, B, X)  Atomic(A, B, X)  (A = A )  (commit point orders match)  ((B  B )  (some operations commit out of order))</p>
    <p>thread 1</p>
    <p>enqueue(A)</p>
    <p>thread 2</p>
    <p>dequeue()  B</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-17</p>
    <p>Encoding Detail: Obtain Symbolic Instruction Stream Finite instruction sequence for each thread  Only loads, stores, moves, and fences  Each register is assigned exactly once  Control flow represented by predicates</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-18</p>
    <p>Encoding Detail: Memory Order Example: two threads:  Encoding variables</p>
    <p>Use bool vars for relative order (x&lt;y) of memory accesses  Use bitvector variables Ax and Dx for address and data values associated with memory access x</p>
    <p>Encode constraints  encode transitivity of memory order  encode ordering axioms of the memory model</p>
    <p>Example (for SC): (s1&lt;s2)(l1&lt;l2)  encode value flow</p>
    <p>Loaded value must match last value stored to same address Example: value must flow from s1 to l1 under following conditions:</p>
    <p>((s1&lt;l1)  (As1 = Al1)  ((s2&lt;s1)(l1&lt;s2)(As2  Al1)))  (Ds1= Dl1)</p>
    <p>s1 store s2 store</p>
    <p>l1 load l2 load</p>
    <p>thread 1 thread 2</p>
    <p>O(n2)</p>
    <p>O(n3)</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-19</p>
    <p>Encoding Detail: The combined formula</p>
    <p>communication formula</p>
    <p>memory order variables input values</p>
    <p>output values</p>
    <p>intermediate values</p>
    <p>thread-local formulas</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-20</p>
    <p>So what did we learn in the case study?</p>
    <p>General motivation  Case study parameters</p>
    <p>Two-lock queue implementation  Correctness criterion  Relaxed memory models</p>
    <p>Our verification method  Symbolic tests  SAT encoding</p>
    <p>Results  Bugs found  Evaluation &amp; Conclusion</p>
    <p>done</p>
    <p>coming up</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-21</p>
    <p>Results: 5 code problems found</p>
    <p>3 were mistakes we made  first commit point guess was wrong  incorrect/insufficient fences in lock/unlock and alloc/free</p>
    <p>2 were caused by missing fences in queue implementation (not fault of authors... were assuming SC multiprocessor)</p>
    <p>---store-store-fence</p>
    <p>---load-load-fence</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-22</p>
    <p>Results: Scalability</p>
    <p>Graph shows tests in our suite (unsatisfiable instances only)  y-axis : runtime in seconds  x-axis : # accesses</p>
    <p>(loads/stores) in test  Fast on small tests, slow</p>
    <p>on long tests  Not sensitive to # threads</p>
    <p>All 5 problems were found on smallest 2 tests... all under 1 sec</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-23</p>
    <p>Conclusion</p>
    <p>quickly finds subtle bugs  supports relaxed memory models  counterexample traces  catches broad range of bugs</p>
    <p>(not limited to deadlocks or data races)</p>
    <p>is more automatic than deductive methods</p>
    <p>not truly scalable (though scalable enough to be useful)</p>
    <p>not fully automatic  does not solve full</p>
    <p>problem (bounded instances, commit points)</p>
    <p>We would recommend this method to designers and implementors of concurrent data types.</p>
    <p>PROs CONs FUTURE WORK &amp;</p>
    <p>CHALLENGES</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-24</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-25</p>
    <p>Ordering/Atomicity Relaxations</p>
    <p>store A, 1 load B, 0</p>
    <p>store B, 1 load A, 0</p>
    <p>processor 1 processor 2 initially A=B=0</p>
    <p>pink numbers = memory order</p>
    <p>store A, 1 load A, reg store reg, B</p>
    <p>load B, 1 load A, 0</p>
    <p>processor 1 processor 2 initially A=B=0</p>
    <p>split store into local / remote components</p>
    <p>EXAMPLE 1 store, load may execute out of order</p>
    <p>EXAMPLE 2 stores are buffered locally before effect is global</p>
    <p>The following 2 examples illustrate the main effects (1. ordering relaxation / 2. atomicity relaxation)</p>
    <p>Where necessary, a programmer can prevent these effects by inserting fence instructions</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-26</p>
    <p>What code? Data type implementations optimized for concurrent execution (Concurrency libraries)</p>
    <p>What machines? Common shared-memory multiprocessors (e.g. PPC, Sparc, Alpha)</p>
    <p>What bugs? Bugs caused by concurrency (We assume code runs fine if single-threaded)</p>
  </div>
  <div class="page">
    <p>Sebastian Burckhardt-27</p>
    <p>Encoding Concurrent Executions</p>
    <p>x1 load a[0], R1 x2 store R1, y</p>
    <p>x3 load y, R2 move R2+1, R3 x4 store 1, a[R3]</p>
    <p>Variables O(n2)  bitvectors R1, R2, R3 for intermediate values  boolean variables Mij to represent memory order xi &lt; xj (for i &lt; j)</p>
    <p>Constraints O(n3)  memory order is transitive: i&lt;j&lt;k (Mij  Mjk)  Mik  loads get latest value stored to same address  memory order must respect memory model axioms and fences</p>
    <p>(e.g. sequential consistency requires M12  M34)  thread-local computations connect values (e.g. R3 = R2 + 1)</p>
    <p>label label</p>
  </div>
</Presentation>
