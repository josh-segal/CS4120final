<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Port Grimaud, FrancePort Grimaud, France</p>
    <p>Stephan Kleber, Henning Kopp, Frank Kargl Institute of Distributed Systems</p>
    <p>August 13, 2018</p>
    <p>NEMESYS Network Message Syntax Reverse Engineering by Analysis of the Intrinsic Structure of Individual Messages</p>
  </div>
  <div class="page">
    <p>Static Traffic Analysis</p>
    <p>Observable in Transit Requires no access to program of entities</p>
    <p>Botnet analysis</p>
    <p>Honeypot setup</p>
    <p>Define input formats for Smart Fuzzing</p>
  </div>
  <div class="page">
    <p>Static Traffic Analysis Observable in Transit</p>
    <p>Requires no access to program of entities</p>
    <p>Botnet analysis</p>
    <p>Honeypot setup</p>
    <p>Define input formats for Smart Fuzzing</p>
  </div>
  <div class="page">
    <p>Static Traffic Analysis Observable in Transit</p>
    <p>Requires no access to program of entities</p>
    <p>Botnet analysis</p>
    <p>Honeypot setup</p>
    <p>Define input formats for Smart Fuzzing</p>
  </div>
  <div class="page">
    <p>A Protocol Specification</p>
    <p>Message Formats</p>
    <p>Message Types | Vocabulary</p>
    <p>Behavior Model | Grammar</p>
    <p>Reverse Engineering of</p>
    <p>Vocabulary: find message type by format similarities Grammar: generalize to sequence of messages types</p>
  </div>
  <div class="page">
    <p>A Protocol Specification</p>
    <p>Message Formats</p>
    <p>Message Types | Vocabulary</p>
    <p>Behavior Model | Grammar</p>
    <p>Reverse Engineering of</p>
    <p>Vocabulary: find message type by format similarities Grammar: generalize to sequence of messages types</p>
  </div>
  <div class="page">
    <p>A Protocol Specification</p>
    <p>Message Formats</p>
    <p>Message Types | Vocabulary</p>
    <p>Behavior Model | Grammar</p>
    <p>Reverse Engineering of</p>
    <p>Vocabulary: find message type by format similarities Grammar: generalize to sequence of messages types</p>
  </div>
  <div class="page">
    <p>Format Inference</p>
    <p>Determine field boundaries</p>
    <p>:</p>
    <p>Textual protocol (SMTP): RCPT TO: &lt;twanda@blue6.ex&gt;</p>
    <p>Binary protocol (DHCP): 638253633501053604ac140301330400000e10</p>
    <p>Key:</p>
    <p>Keyword</p>
    <p>Separator</p>
    <p>Value</p>
  </div>
  <div class="page">
    <p>Format Inference</p>
    <p>Determine field boundaries:</p>
    <p>Textual protocol (SMTP): RCPT TO: &lt;twanda@blue6.ex&gt;</p>
    <p>Binary protocol (DHCP): 638253633501053604ac140301330400000e10</p>
    <p>Key:</p>
    <p>Keyword</p>
    <p>Separator</p>
    <p>Value</p>
  </div>
  <div class="page">
    <p>Format Inference</p>
    <p>Determine field boundaries:</p>
    <p>Textual protocol (SMTP): RCPT TO: &lt;twanda@blue6.ex&gt;</p>
    <p>Binary protocol (DHCP): 638253633501053604ac140301330400000e10</p>
    <p>Key:</p>
    <p>Keyword</p>
    <p>Separator</p>
    <p>Value</p>
  </div>
  <div class="page">
    <p>Format Inference</p>
    <p>Determine field boundaries:</p>
    <p>Textual protocol (SMTP): RCPT TO: &lt;twanda@blue6.ex&gt;</p>
    <p>Binary protocol (DHCP): 638253633501053604ac140301330400000e10</p>
    <p>Key:</p>
    <p>Keyword</p>
    <p>Separator</p>
    <p>Value</p>
  </div>
  <div class="page">
    <p>A New Kind of Feature</p>
    <p>m e ss</p>
    <p>a g</p>
    <p>e</p>
    <p>input/ntp_SMIA-20111010_deduped-100.pcap</p>
    <p>One NTP message per row</p>
    <p>Byte position</p>
    <p>Byte value</p>
  </div>
  <div class="page">
    <p>A New Kind of Feature</p>
    <p>m e ss</p>
    <p>a g</p>
    <p>e</p>
    <p>input/ntp_SMIA-20111010_deduped-100.pcap</p>
    <p>One NTP message per row</p>
    <p>Byte position</p>
    <p>Byte value</p>
  </div>
  <div class="page">
    <p>A New Kind of Feature</p>
    <p>m e ss</p>
    <p>a g</p>
    <p>e</p>
    <p>input/ntp_SMIA-20111010_deduped-100.pcap</p>
    <p>One NTP message per row</p>
    <p>Byte position</p>
    <p>Byte value</p>
  </div>
  <div class="page">
    <p>A New Kind of Feature</p>
    <p>m e ss</p>
    <p>a g</p>
    <p>e</p>
    <p>input/ntp_SMIA-20111010_deduped-100.pcap</p>
    <p>One NTP message per row</p>
    <p>Byte position</p>
    <p>Byte value</p>
  </div>
  <div class="page">
    <p>A New Kind of Feature</p>
    <p>m e ss</p>
    <p>a g</p>
    <p>e</p>
    <p>input/ntp_SMIA-20111010_deduped-100.pcap</p>
    <p>One NTP message per row</p>
    <p>Byte position</p>
    <p>Byte value</p>
  </div>
  <div class="page">
    <p>A New Kind of Feature</p>
    <p>m e ss</p>
    <p>a g</p>
    <p>e</p>
    <p>input/ntp_SMIA-20111010_deduped-100.pcap</p>
    <p>One NTP message per row</p>
    <p>Byte position</p>
    <p>Byte value</p>
  </div>
  <div class="page">
    <p>Observations</p>
    <p>Intrinsic structure observable</p>
    <p>Messages designed for efficient parsing: fixed-length data types</p>
    <p>fields not uniformly filled 00 0a f8 fe</p>
    <p>Counted numbers have specific variance distribution</p>
  </div>
  <div class="page">
    <p>Novel Feature to Pinpoint Boundaries</p>
    <p>Change in the agreement of bits in consecutive bytes throughout ONE single message!</p>
    <p>Deltas of Bit Congruence</p>
  </div>
  <div class="page">
    <p>Deltas of Bit Congruence</p>
    <p>k</p>
    <p>BC = ( BC(mk, mk+1)  BC(mk1, mk)</p>
    <p>) 0&lt;k&lt;n</p>
    <p>Bit Congruence:</p>
    <p>based on similarity measure for bit strings by Sokal and Michener (1958)</p>
    <p>BC(b, b) = cagree(b, b)</p>
    <p>cagree(b, b): number of congruent bits for bytes b and b</p>
  </div>
  <div class="page">
    <p>Deltas of Bit Congruence</p>
    <p>k</p>
    <p>BC = ( BC(mk, mk+1)  BC(mk1, mk)</p>
    <p>) 0&lt;k&lt;n</p>
    <p>Bit Congruence:</p>
    <p>BC(b, b) = cagree(b, b)</p>
    <p>mk: Message ms byte at position k, m has length n + 1</p>
    <p>cagree(b, b): number of congruent bits for bytes b and b</p>
  </div>
  <div class="page">
    <p>Deltas of Bit Congruence</p>
    <p>k</p>
    <p>BC = ( BC(mk, mk+1)  BC(mk1, mk)</p>
    <p>) 0&lt;k&lt;n</p>
    <p>with</p>
    <p>BC(b, b) = cagree(b, b)</p>
    <p>mk: Message ms byte at position k, m has length n + 1 cagree(b, b): number of congruent bits for bytes b and b</p>
  </div>
  <div class="page">
    <p>Deltas of Bit Congruence k</p>
    <p>BC = ( BC(mk, mk+1)  BC(mk1, mk)</p>
    <p>) 0&lt;k&lt;n</p>
    <p>with</p>
    <p>BC(b, b) = cagree(b, b)</p>
    <p>mk: Message ms byte at position k, m has length n + 1 cagree(b, b): number of congruent bits for bytes b and b</p>
  </div>
  <div class="page">
    <p>Deltas of Bit Congruence k k = 1</p>
    <p>BC = ( BC(mk, mk+1)  BC(mk1, mk)</p>
    <p>) 0&lt;k&lt;n</p>
    <p>with</p>
    <p>BC(b, b) = cagree(b, b)</p>
    <p>mk: Message ms byte at position k, m has length n + 1 cagree(b, b): number of congruent bits for bytes b and b</p>
  </div>
  <div class="page">
    <p>Deltas of Bit Congruence k k = 2</p>
    <p>BC = ( BC(mk, mk+1)  BC(mk1, mk)</p>
    <p>) 0&lt;k&lt;n</p>
    <p>with</p>
    <p>BC(b, b) = cagree(b, b)</p>
    <p>mk: Message ms byte at position k, m has length n + 1 cagree(b, b): number of congruent bits for bytes b and b</p>
  </div>
  <div class="page">
    <p>Deltas of Bit Congruence k</p>
    <p>k = 3</p>
    <p>BC = ( BC(mk, mk+1)  BC(mk1, mk)</p>
    <p>) 0&lt;k&lt;n</p>
    <p>with</p>
    <p>BC(b, b) = cagree(b, b)</p>
    <p>mk: Message ms byte at position k, m has length n + 1 cagree(b, b): number of congruent bits for bytes b and b</p>
  </div>
  <div class="page">
    <p>Deltas of Bit Congruence k</p>
    <p>k = 4</p>
    <p>BC = ( BC(mk, mk+1)  BC(mk1, mk)</p>
    <p>) 0&lt;k&lt;n</p>
    <p>with</p>
    <p>BC(b, b) = cagree(b, b)</p>
    <p>mk: Message ms byte at position k, m has length n + 1 cagree(b, b): number of congruent bits for bytes b and b</p>
  </div>
  <div class="page">
    <p>Deltas of Bit Congruence k</p>
    <p>k = 63</p>
    <p>BC = ( BC(mk, mk+1)  BC(mk1, mk)</p>
    <p>) 0&lt;k&lt;n</p>
    <p>with</p>
    <p>BC(b, b) = cagree(b, b)</p>
    <p>mk: Message ms byte at position k, m has length n + 1 cagree(b, b): number of congruent bits for bytes b and b</p>
  </div>
  <div class="page">
    <p>Applying the Feature</p>
    <p>Feature BC: distinctive distribution for binary numbers:</p>
    <p>At field transition: low BC</p>
    <p>Towards field end: high BC</p>
    <p>Gaussian filter g() to reduce noise</p>
    <p>Inflection points of rising edges of g(BC)</p>
  </div>
  <div class="page">
    <p>Applying the Feature</p>
    <p>Feature BC: distinctive distribution for binary numbers:</p>
    <p>At field transition: low BC</p>
    <p>Towards field end: high BC</p>
    <p>Gaussian filter g() to reduce noise</p>
    <p>Inflection points of rising edges of g(BC)</p>
  </div>
  <div class="page">
    <p>Applying the Feature</p>
    <p>Feature BC: distinctive distribution for binary numbers:</p>
    <p>At field transition: low BC</p>
    <p>Towards field end: high BC</p>
    <p>Gaussian filter g() to reduce noise</p>
    <p>Inflection points of rising edges of g(BC)</p>
  </div>
  <div class="page">
    <p>Value Pattern: Feature of one NTP message</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>Value Pattern: Feature of one NTP message</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>Value Pattern: Feature of one NTP message</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>Value Pattern: Feature of one NTP message</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>B C</p>
    <p>Gaussian-smoothed feature</p>
  </div>
  <div class="page">
    <p>Value Pattern: Feature of one NTP message</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>Byte Position</p>
    <p>Message:</p>
    <p>B C</p>
    <p>Gaussian-smoothed feature</p>
    <p>Periodic | Coinciding with fields</p>
  </div>
  <div class="page">
    <p>Value Pattern: Feature of one DNS message</p>
    <p>Byte Position</p>
    <p>e81f 010000010000000000000872656c6561736573076d6f 7a696c6c61036f 726700001c0001 Message:</p>
    <p>Byte Position</p>
    <p>dc d1 81 82 00 01 00 00 00 00 00 00 04 69 63 74 66 02 63 73 04 75 63 73 62 03 65 64 75 00 00 01 00 01 Message:</p>
    <p>Byte Position</p>
    <p>fe 47 81 82 00 01 00 00 00 00 00 00 03 77 77 77 03 69 66 63 03 63 6f 6d 00 00 01 00 01 Message:</p>
    <p>B C</p>
  </div>
  <div class="page">
    <p>Value Pattern: Feature of one DNS message</p>
    <p>Byte Position</p>
    <p>e81f 010000010000000000000872656c6561736573076d6f 7a696c6c61036f 726700001c0001 Message:</p>
    <p>Byte Position</p>
    <p>dc d1 81 82 00 01 00 00 00 00 00 00 04 69 63 74 66 02 63 73 04 75 63 73 62 03 65 64 75 00 00 01 00 01 Message:</p>
    <p>Byte Position</p>
    <p>fe 47 81 82 00 01 00 00 00 00 00 00 03 77 77 77 03 69 66 63 03 63 6f 6d 00 00 01 00 01 Message:</p>
    <p>B C</p>
    <p>Except: char sequences and high-entropy data</p>
  </div>
  <div class="page">
    <p>Value Pattern: Feature of one DNS message</p>
    <p>Byte Position</p>
    <p>e81f 010000010000000000000872656c6561736573076d6f 7a696c6c61036f 726700001c0001 Message:</p>
    <p>Byte Position</p>
    <p>dc d1 81 82 00 01 00 00 00 00 00 00 04 69 63 74 66 02 63 73 04 75 63 73 62 03 65 64 75 00 00 01 00 01 Message:</p>
    <p>Byte Position</p>
    <p>fe 47 81 82 00 01 00 00 00 00 00 00 03 77 77 77 03 69 66 63 03 63 6f 6d 00 00 01 00 01 Message:</p>
    <p>B C</p>
    <p>Except: char sequences and high-entropy data</p>
  </div>
  <div class="page">
    <p>Pinpoint Field Boundaries: DNS</p>
    <p>Aligned Byte Position</p>
    <p>eduped-9911 | distances-distribution_b Messages</p>
  </div>
  <div class="page">
    <p>Pinpoint Field Boundaries: NTP</p>
    <p>ntp_SMIA-20111010_deduped-9995 | distances-distribution_bcDeltaGauss1.2 Messages</p>
  </div>
  <div class="page">
    <p>Quantify Format Inference Quality</p>
    <p>Validate format inference method: Measure correctness by benchmarking with a known protocol</p>
  </div>
  <div class="page">
    <p>Format Match Score</p>
    <p>FMS = exp (  ( |R|  |I|</p>
    <p>|R|</p>
    <p>)2)</p>
    <p>Specificity penalty</p>
    <p>1</p>
    <p>|R|  rR</p>
    <p>exp (  ( r</p>
    <p>)2)</p>
    <p>Match gain</p>
  </div>
  <div class="page">
    <p>Format Match Score</p>
    <p>FMS = exp (  ( |R|  |I|</p>
    <p>|R|</p>
    <p>)2)</p>
    <p>Specificity penalty</p>
    <p>1</p>
    <p>|R|  rR</p>
    <p>exp (  ( r</p>
    <p>)2)</p>
    <p>Match gain</p>
    <p>Quality aspects: |R| Number of real field boundaries |I| Number of inferred field boundaries</p>
    <p>r Distance of real boundary r from next inferred one</p>
    <p>Required accuracy</p>
  </div>
  <div class="page">
    <p>Format Match Score</p>
    <p>FMS = exp (  ( |R|  |I|</p>
    <p>|R|</p>
    <p>)2)</p>
    <p>Specificity penalty</p>
    <p>1</p>
    <p>|R|  rR</p>
    <p>exp (  ( r</p>
    <p>)2)</p>
    <p>Match gain</p>
    <p>Quality aspects: |R| Number of real field boundaries |I| Number of inferred field boundaries r Distance of real boundary r from next inferred one</p>
    <p>Required accuracy</p>
  </div>
  <div class="page">
    <p>Format Match Score</p>
    <p>FMS = exp (  ( |R|  |I|</p>
    <p>|R|</p>
    <p>)2)</p>
    <p>Specificity penalty</p>
    <p>1</p>
    <p>|R|  rR</p>
    <p>exp (  ( r</p>
    <p>)2)</p>
    <p>Match gain</p>
    <p>Weighted distance  = 2</p>
    <p>-4 -3 -2 -1 0 1 2 3 4 r</p>
    <p>r =  no matching inferred field</p>
  </div>
  <div class="page">
    <p>Format Match Score</p>
    <p>FMS = exp (  ( |R|  |I|</p>
    <p>|R|</p>
    <p>)2)</p>
    <p>Specificity penalty</p>
    <p>1</p>
    <p>|R|  rR</p>
    <p>exp (  ( r</p>
    <p>)2)</p>
    <p>Match gain</p>
    <p>Quantify format correctness</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>NEMESYS</p>
    <p>NEtwork MEssage SYntax analysiS</p>
  </div>
  <div class="page">
    <p>NEMESYS Architecture</p>
    <p>SpecimenLoader</p>
    <p>PCAP file</p>
    <p>MessageAnalyzer</p>
    <p>MessageSegmentmessage format</p>
    <p>message</p>
    <p>g(BC) + inflection point approximation</p>
    <p>refinements</p>
  </div>
  <div class="page">
    <p>Evaluation Process</p>
    <p>MessageComparator</p>
    <p>ParsedMessage</p>
    <p>running tshark and parsing its output</p>
    <p>FMS</p>
    <p>inferred MessageSegment</p>
    <p>format comparison</p>
  </div>
  <div class="page">
    <p>Evaluation Results: Quality</p>
    <p>S</p>
    <p>DNS</p>
    <p>NTP</p>
    <p>best case</p>
    <p>FM S</p>
    <p>average case</p>
    <p>Netzob | NEMESYS</p>
  </div>
  <div class="page">
    <p>Evaluation Results: Performance</p>
    <p>Ru nt im e (s ec on ds )</p>
    <p>Netzob</p>
    <p>NEMESYS</p>
    <p>Reduces runtime from exponential to linear</p>
  </div>
  <div class="page">
    <p>Future Work Use characteristic features to recognize field data types</p>
    <p>Integer: 00 0a f8 fe</p>
    <p>String: 69 44 53 00</p>
    <p>Padding: 57 b0 00 00</p>
    <p>Find more data-type-specific patterns: flags | addresses | signed numbers | floats | enumerations</p>
    <p>Message Type Identification: Cluster messages on patterns of segment data types (based on Cui et al., 2007; FieldHunter, 2016)</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>NEMESYS: Novel method for format inference</p>
    <p>Intrinsic message structure</p>
    <p>Binary protocols</p>
    <p>Abstracting from concrete byte values</p>
    <p>Linear time complexity</p>
    <p>Format Match Score: Quality assessment of format inference methods</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>NEMESYS: Novel method for format inference</p>
    <p>Intrinsic message structure</p>
    <p>Binary protocols</p>
    <p>Abstracting from concrete byte values</p>
    <p>Linear time complexity</p>
    <p>Format Match Score: Quality assessment of format inference methods</p>
  </div>
  <div class="page">
    <p>Thank you! Questions?</p>
    <p>web uulm.de?kleber mail stephan.kleber@uni-ulm.de</p>
    <p>Institute of Distributed Systems, Ulm University web uulm.de/in/vs github github.com/vs-uulm</p>
  </div>
</Presentation>
