<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>vTZ: Virtualizing ARM TrustZone</p>
    <p>IPADS, Shanghai Jiao Tong University</p>
    <p>Zhichao Hua, Jinyu Gu, Yubin Xia, Haibo Chen, Binyu Zang, Haibing Guan</p>
  </div>
  <div class="page">
    <p>OTP</p>
    <p>fTPM</p>
    <p>Security systems with TrustZone</p>
    <p>Server SoC With Virtualization</p>
    <p>Can VMs use TrustZone?</p>
  </div>
  <div class="page">
    <p>ARM TrustZone 3</p>
    <p>Normal World Secure World</p>
    <p>Monitor Mode</p>
    <p>OS T-OS</p>
    <p>(Trust OS)</p>
    <p>TA (Trusted APP)</p>
    <p>APP DRAM</p>
    <p>CPU core</p>
    <p>smcsmc</p>
    <p>APP</p>
    <p>Devices</p>
    <p>Two isolated execution environments</p>
    <p>Different worlds switch to each other by smc instruction</p>
    <p>Hardware resources can be partitioned into secure/nonsecure part dynamically</p>
    <p>Secure world can access all  Normal world can only access</p>
    <p>non-secure part B</p>
    <p>u s</p>
  </div>
  <div class="page">
    <p>TrustZone Usage</p>
    <p>TrustZone on mobile phone  Secure storage, key protection, kernel integrity checker,</p>
    <p>malware detector, etc.</p>
    <p>TrustZone on ARM server  Has similar scenarios and requirements</p>
  </div>
  <div class="page">
    <p>TrustZone + Virtualization 5</p>
    <p>Requirements Ideal Reality</p>
    <p>Each guest VM has a secure world</p>
    <p>Guest VM can choose its own trust OS</p>
    <p>Isolation between different guests secure worlds</p>
    <p>Hardware resources partition between guests</p>
    <p>normal world and secure world</p>
  </div>
  <div class="page">
    <p>TrustZone + Virtualization 5</p>
    <p>Requirements Ideal Reality</p>
    <p>Each guest VM has a secure world</p>
    <p>Guest VM can choose its own trust OS</p>
    <p>Isolation between different guests secure worlds</p>
    <p>Hardware resources partition between guests</p>
    <p>normal world and secure world</p>
    <p>The OS in secure world becomes single point of failure  cve-2015-4421, cve-2015-4422, cve-2015-6639</p>
  </div>
  <div class="page">
    <p>Goals</p>
    <p>Multiplexing the secure world for guest VMs  Each guest VM can choose its own trust OS  Isolate each guests secure world  Provide hardware resources partition for each guest</p>
    <p>Compatibility for existing software in secure world  Provide same functionalities and interfaces with real TrustZone  Support existing trust OS</p>
    <p>Minimizing TCB of the new architecture</p>
  </div>
  <div class="page">
    <p>Alternative Designs</p>
    <p>Normal World</p>
    <p>VMM</p>
    <p>T-VMMOS</p>
    <p>VMN VMS</p>
    <p>T-OSuser</p>
    <p>svc</p>
    <p>hyp</p>
    <p>Secure World</p>
    <p>Design Choice I</p>
    <p>mon</p>
    <p>: TCB</p>
    <p>APP TA</p>
    <p>Large TCB</p>
    <p>No compatibility</p>
    <p>Bad performance</p>
    <p>T-VMM (trusted VMM) in the secure world  Virtualize guest secure world with VMS</p>
    <p>VMM in the normal world  Virtualize guest normal world with VMN</p>
    <p>No virtualization extension in secure world  Both guests trust OS and TA run in user mode  ARM has virtualization unfriendly instructions</p>
    <p>Trust OS needs to be modified</p>
    <p>System TCB  T-VMM (~10K of LoC)  VMM (millions of LoC)</p>
  </div>
  <div class="page">
    <p>Alternative Designs</p>
    <p>Normal World</p>
    <p>VMM</p>
    <p>T-VMMOS</p>
    <p>VMN VMS</p>
    <p>user</p>
    <p>svc</p>
    <p>hyp</p>
    <p>Secure World</p>
    <p>Normal World</p>
    <p>OS</p>
    <p>VMN</p>
    <p>Secure World</p>
    <p>VMS</p>
    <p>T-OS</p>
    <p>Design Choice I Design Choice II</p>
    <p>mon VMM</p>
    <p>: TCB</p>
    <p>APP TAAPP TA</p>
    <p>Large TCB</p>
    <p>No compatibility</p>
    <p>Bad performance</p>
    <p>Large TCB</p>
    <p>Has compatibility</p>
    <p>Good performance</p>
    <p>Virtualize guest secure world in real normal world</p>
    <p>Secure world is not used</p>
    <p>System TCB  VMM (millions of LoC)</p>
    <p>T-OS</p>
  </div>
  <div class="page">
    <p>Alternative Designs</p>
    <p>Normal World</p>
    <p>VMM</p>
    <p>T-VMMOS</p>
    <p>VMN VMS</p>
    <p>user</p>
    <p>svc</p>
    <p>hyp</p>
    <p>Secure World</p>
    <p>Normal World</p>
    <p>OS</p>
    <p>VMN</p>
    <p>Secure World</p>
    <p>VMS</p>
    <p>T-OS</p>
    <p>Design Choice I Design Choice II</p>
    <p>mon VMM</p>
    <p>: TCB</p>
    <p>APP TAAPP TA</p>
    <p>Large TCB</p>
    <p>No compatibility</p>
    <p>Bad performance</p>
    <p>Large TCB</p>
    <p>Has compatibility</p>
    <p>Good performance</p>
    <p>Normal World</p>
    <p>VMM</p>
    <p>OS</p>
    <p>VMN</p>
    <p>Secure World</p>
    <p>VMS</p>
    <p>T-OS</p>
    <p>Design Choice III</p>
    <p>CIEEs</p>
    <p>Secured Modules</p>
    <p>CFLock</p>
    <p>Small TCB</p>
    <p>Has compatibility</p>
    <p>T-OS</p>
  </div>
  <div class="page">
    <p>Threat Model</p>
    <p>Any guest may be an attacker</p>
    <p>VMM is buggy, can be compromised</p>
    <p>Code integrity is protected during system boot by secure boot technology</p>
    <p>Side-channel attacks and physical attacks are not considered</p>
    <p>VMN VMS</p>
    <p>Normal World</p>
    <p>VMM</p>
    <p>OS</p>
    <p>Secure World</p>
    <p>T-OS</p>
    <p>Control Flow Lock</p>
    <p>CIEEs Secured Modules</p>
    <p>SMM SWS</p>
    <p>user mode</p>
    <p>svc mode</p>
    <p>hyp mode</p>
    <p>mon mode</p>
    <p>APP TA</p>
  </div>
  <div class="page">
    <p>VMN VMS</p>
    <p>Overview</p>
    <p>Normal World</p>
    <p>VMM</p>
    <p>OS</p>
    <p>Secure World</p>
    <p>T-OS</p>
    <p>Control Flow Lock</p>
    <p>CIEEs Secured Modules</p>
    <p>SMM SWS</p>
    <p>Emulate guest normal world/secure world with different VMs</p>
    <p>World switching is performed by switching between two VMs</p>
    <p>SMM (Secured Memory Mapping)  Memory mapping</p>
    <p>SWS (Secured World Switching)  CPU Context</p>
    <p>CIEE (Constrained Isolated Execution Environment)</p>
    <p>Protect critical logic in hyp mode</p>
    <p>CFLock (Control Flow Lock)</p>
    <p>user mode</p>
    <p>svc mode</p>
    <p>hyp mode</p>
    <p>mon mode</p>
    <p>APP TA</p>
  </div>
  <div class="page">
    <p>TrustZone Features System Properties</p>
    <p>Secure Boot SW must boot before NW.</p>
    <p>Boot image of SW must be checked.</p>
    <p>SW cannot be replaced.</p>
    <p>CPU States Protection smc must switch to the correct world. Protect the integrity of NW CPU states during switching.</p>
    <p>Protect SW CPU states.</p>
    <p>Memory Isolation Only SW can access secure memory.</p>
    <p>Only SW can configure memory partition.</p>
    <p>Peripheral Assignment Secure interrupts must be injected into SW.</p>
    <p>NW cannot access secure peripherals.</p>
    <p>Secure peripherals are trusted for SW</p>
    <p>Only SW can partition interrupt/peripherals.</p>
    <p>Properties need to be enforced by vTZ</p>
  </div>
  <div class="page">
    <p>TrustZone Features System Properties</p>
    <p>Secure Boot SW must boot before NW.</p>
    <p>Boot image of SW must be checked.</p>
    <p>SW cannot be replaced.</p>
    <p>CPU States Protection smc must switch to the correct world. Protect the integrity of NW CPU states during switching.</p>
    <p>Protect SW CPU states.</p>
    <p>Memory Isolation Only SW can access secure memory.</p>
    <p>Only SW can configure memory partition. Peripheral Assignment Secure interrupts must be injected into SW.</p>
    <p>NW cannot access secure peripherals.</p>
    <p>Secure peripherals are trusted for SW</p>
    <p>Only SW can partition interrupt/peripherals.</p>
    <p>Properties need to be enforced by vTZ.</p>
  </div>
  <div class="page">
    <p>P1. Only secure world can access secure memory</p>
    <p>Challenge  Untrusted VMM controls all memory mappings  Map one guests secure memory to its normal world or to another guest  Map one guests secure memory to VMMs address space</p>
    <p>Solution  SMM exclusively controls all memory mappings to physical memory  SMM checks memory mappings</p>
  </div>
  <div class="page">
    <p>Two kinds of mappings to the physical memory  Stage-2 page table maps guest physical address to</p>
    <p>physical address</p>
    <p>Hyp page table maps virtual address to physical address for VMM</p>
    <p>Three ways memory mapping can be modified  Enabling a page table  Disabling the address translation  Changing the entries of page table</p>
    <p>P1. Only secure world can access secure memory</p>
    <p>.text enable_guest_pt: ldr x1, [x0] // load page table MSR VTTBR_EL2, x1 // enable table table</p>
    <p>enable_hyp_pt: ldr x1, [x0] // load page table MSR TTBR0_EL2, x1 // enable table table</p>
    <p>set_pte: str x1, [x0] // change table entry</p>
    <p>hypervisor page table</p>
    <p>Stage-2 page table</p>
  </div>
  <div class="page">
    <p>SMM (Secured Memory Mapping)</p>
    <p>SMM exclusively controls the mapping  Replace all page table maintain instructions  Enforce hypervisors code as read-only (R.O.)  Enforce page table as read-only</p>
    <p>SMM enforces memory mapping policy  E.g., one guests secure memory can only be</p>
    <p>mapped to its own secure world</p>
    <p>P1. Only secure world can access the secure memory</p>
    <p>.text enable_guest_pt: ldr x1, [x0] // load page table MSR VTTBR_EL2, x1 // enable table table</p>
    <p>enable_hyp_pt: ldr x1, [x0] // load page table MSR TTBR0_EL2, x1 // enable table table</p>
    <p>set_pte: str x1, [x0] // change table entry</p>
    <p>hypervisor page table</p>
    <p>Stage-2 page table</p>
    <p>Invoke_SMM</p>
    <p>Invoke_SMM</p>
    <p>Invoke_SMM</p>
  </div>
  <div class="page">
    <p>P2. smc must switch to the correct world</p>
    <p>Challenge  Untrusted VMM controls the scheduleing of all VMs  smc may switch to a malicious VM  smc may switch to a wrong entry of guest secure world  Untrusted VMM may tamper with the CPU context during switching</p>
    <p>Solution  SWS hooks all switching between a VM and the VMM  SWS checks all switching</p>
  </div>
  <div class="page">
    <p>SWS (Secured World Switching)</p>
    <p>SWS Interposes switching between a VM and the VMM  VM_exit is triggered by exception, hooked by CFLock  VM_enter is performed by special instructions, replacing all of them</p>
    <p>E.g., eret</p>
    <p>SWS binds each guests secure world and normal world  Identify VMs presenting guests two worlds by VMID</p>
  </div>
  <div class="page">
    <p>CFLock: hooks the control flow of exception handling</p>
    <p>Ensure the integrity of vector table containing exception handlers  Replace instructions which modify</p>
    <p>vector table base register</p>
    <p>Mark vector table as read-only</p>
    <p>Add hook in each exception handler</p>
    <p>CFLock (Control Flow Lock)</p>
    <p>.text Init_vector: ldr x1, [x0] // load vector table MSR VBAR_EL2, x1 // enable vector table</p>
    <p>handler1:</p>
    <p>b handler1</p>
    <p>vector table</p>
    <p>Invoke_SMM b handler2 b handler3 b handler4 b handler5</p>
    <p>b CFLock</p>
  </div>
  <div class="page">
    <p>P2. smc must switch to the correct world</p>
    <p>Untrusted VMM registers guests two VMs in SWS  SWS only allows entering a registered VM</p>
    <p>Untrusted VMM schedules all VMs</p>
    <p>SWS checks all VM_enter / VM_exit operations</p>
  </div>
  <div class="page">
    <p>P3. Only secure world can partition memory</p>
    <p>Guest configures memory partition in its secure world by accessing a memory partition device (TZASC)</p>
    <p>Challenge  There is only one TZASC  Cannot control TZASC by the untrusted VMM</p>
    <p>Solution  Providing trusted virtual TZASC by trap and emulate</p>
  </div>
  <div class="page">
    <p>P3. Only secure world can partition memory</p>
    <p>CFLock traps memory accesses of virtual TZASC  Memory mapped device  Accessing triggers page fault exception</p>
    <p>SWS identifies current VM  Only guest secure world can do the partitioning</p>
    <p>Need an isolated execution environment to emulate device  Reuse some structure of the VMM  Protected from VMM  Not included in system TCB</p>
  </div>
  <div class="page">
    <p>P3. Only secure world can partition memory</p>
    <p>CIEE (Constrained Isolated Execution Environment)</p>
    <p>Protects a piece of code in the hyp mode</p>
    <p>Excluded from system TCB</p>
  </div>
  <div class="page">
    <p>CIEE (Constrained Isolated Execution Environment)</p>
    <p>Located in the hyp mode</p>
    <p>Prevent against the untrusted VMM  Single entry point  Run-to-completion  No dependence on the hypervisors data  No data exposure to the hypervisor  Unforgeable to the secure world</p>
    <p>Exclude CIEE from system TCB  Isolated privilege</p>
  </div>
  <div class="page">
    <p>CIEE (Constrained Isolated Execution Environment)</p>
    <p>CIEE components  CIEE-Code  Stack page  Secure object</p>
    <p>Enforce five security policies</p>
    <p>Isolated privilege  Diff privilege for each CIEE  Diff copy of secure obj. for each guest</p>
    <p>smc</p>
    <p>smc</p>
    <p>stack page</p>
    <p>r/w</p>
    <p>CIEE-code</p>
    <p>CIEE</p>
    <p>write</p>
    <p>request</p>
    <p>Normal World Secure World</p>
    <p>secure obj.</p>
    <p>secured modules</p>
    <p>read</p>
  </div>
  <div class="page">
    <p>P3. Only secure world can partition memory</p>
    <p>CFLock traps memory accesses of virtual TZASC  Memory mapped device  Accessing triggers page fault exception</p>
    <p>SWS identifies current VM  Only guest secure world can do the partitioning</p>
    <p>Emulate TZASC in an CIEE</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Can vTZ support existing trust OS?</p>
    <p>How is the performance of server applications on vTZ?</p>
    <p>How is the performance of application with multiple VMs?</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Hardware platform  Hikey (ARMv8) with eight 1.2 GHz cores  Exynos (ARMv7) with one 1.7GHz core</p>
    <p>Software environment  Xen 4.4 + Linux 4.1</p>
  </div>
  <div class="page">
    <p>Compatibility</p>
    <p>Port two existing trust OSes on vTZ  seL4 [SOSP2009]  OP-TEE [https://github.com/OP-TEE/]</p>
    <p>Porting effort  Add description file to describe the device base addresses</p>
    <p>Base addresses of memory and devices  Same as porting an OS on an ARM SoC</p>
  </div>
  <div class="page">
    <p>Application Overhead</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut o</p>
    <p>f A pa</p>
    <p>ch e</p>
    <p>(M B</p>
    <p>/s )</p>
    <p>Size of TCP buffer (Bytes)</p>
    <p>Native TZ</p>
    <p>Xen vTZ</p>
    <p>Th ro</p>
    <p>ug hp</p>
    <p>ut o</p>
    <p>f M on</p>
    <p>go D</p>
    <p>B (K</p>
    <p>op s/</p>
    <p>s)</p>
    <p>Size of item value (Bytes)</p>
    <p>Native TZ</p>
    <p>Xen vTZ</p>
  </div>
  <div class="page">
    <p>Application Overhead</p>
    <p>(a) (b)</p>
    <p>GoHttps on ARMv7(a) and ARMv8(b) with different VMs.</p>
    <p>N. :Native TZ :TrustZone X :Xen vTZ :Our system</p>
  </div>
  <div class="page">
    <p>Conclusion  Analyze security properties of TrustZone</p>
    <p>Combine TrustZone and virtualization to multiplex secure world for each guest  SMM exclusively controls the memory mapping  CFLock hooks all exceptions in the hyp mode  SWS checks all switching between a VM and the VMM  CIEEs to protect pieces of code in the hyp mode and exclude them from system TCB</p>
    <p>Small system TCB</p>
    <p>Compatible with existing trust OS  Porting two trust OSes on vTZ</p>
    <p>Acceptable performance overhead</p>
  </div>
  <div class="page">
    <p>Thanks</p>
    <p>Institute of Parallel And Distributed Systems (IPADS) http://ipads.se.sjtu.edu.cn</p>
  </div>
</Presentation>
