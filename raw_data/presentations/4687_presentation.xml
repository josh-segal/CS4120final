<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Progressive Computation Progressive Computation of The Min-Dist of The Min-Dist</p>
    <p>Optimal-Location QueryOptimal-Location Query</p>
    <p>Donghui ZhangDonghui Zhang, , Yang Du, Tian Xia, Yufei Tao*Yang Du, Tian Xia, Yufei Tao*</p>
    <p>Northeastern UniversityNortheastern University</p>
    <p>* Chinese University of Hong Kong* Chinese University of Hong Kong</p>
    <p>VLDB06, Seoul, Korea</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>MotivationMotivation</p>
    <p>What is the optimal location in Boston area to build a new McDonalds store?</p>
    <p>Suppose a customer drives to the closest McDonalds.</p>
    <p>Optimality: Minimize AVG driving distance.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>min-dist OLmin-dist OL</p>
    <p>Without any new site: AD = (200+200+600+600)/4 = 400.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>min-dist OLmin-dist OL</p>
    <p>Without any new site: AD = (200+200+600+600)/4 = 400.  With new site l1: AD(l1) = (30+30+600+600)/4 = 315.</p>
    <p>l1</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>min-dist OLmin-dist OL</p>
    <p>Without any new site: AD = (200+200+600+600)/4 = 400.  With new site l1: AD(l1) = (30+30+600+600)/4 = 315.  With new site l2 : AD(l2) = (200+200+30+30)/4 = 115.</p>
    <p>l2 200</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Formal DefinitionFormal Definition</p>
    <p>Given a set S of sites, a set O of objects, and a query range Q ,</p>
    <p>min-dist OL is a location l  Q which minimizes</p>
    <p>distance between o and its nearest site</p>
    <p>Oo lSodNNO lAD }){,(</p>
    <p>||</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>L1 DistanceL1 Distance</p>
    <p>d(o, s) = |o.x  s.x|+|o.y  s.y|</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>ChallengingChallenging</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Solution HighlightsSolution Highlights</p>
    <p>locations l in a cell C. 4. Progressive algorithm.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Remember</p>
    <p>Define   Oo SodNNO AD ),(</p>
    <p>||</p>
    <p>Oo lSodNNO lAD }){,(</p>
    <p>||</p>
    <p>Let RNN(l) be the objects attracted by l.  AD(l)=AD if RNN(l)=</p>
    <p>l</p>
    <p>RNN(l)= AD=AD(l)</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Remember</p>
    <p>Define   Oo SodNNO AD ),(</p>
    <p>||</p>
    <p>Oo lSodNNO lAD }){,(</p>
    <p>||</p>
    <p>Let RNN(l) be the objects attracted by l.  AD(l)=AD if RNN(l)=</p>
    <p>l</p>
    <p>RNN(l)={o7, o8} AD(l) &lt; AD</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Remember</p>
    <p>Define   Oo SodNNO AD ),(</p>
    <p>||</p>
    <p>Oo lSodNNO lAD }){,(</p>
    <p>||</p>
    <p>AD(l)=AD - ?</p>
    <p>Let RNN(l) be the objects attracted by l.  AD(l)=AD if RNN(l)=</p>
    <p>Average savings for customers in RNN(l)</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Theorem</p>
    <p>)( )),(),((|| 1</p>
    <p>)( lRNNo</p>
    <p>lodSodNN O</p>
    <p>ADlAD</p>
    <p>S and O are static versus l.  AD can be pre-computed.  So is dNN(o, S)</p>
    <p>To compute AD(l):  Find RNN(l)  oRNN(l), compute d(o, l)</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Theorem: within the X/Y range of Q, draw grid lines crossing objects. Only need to consider intersections!</p>
    <p>Q</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Theorem: within the X/Y range of Q, draw grid lines crossing objects. Only need to consider intersections!</p>
    <p>Q</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>will produce a better (or equal) result.</p>
    <p>l</p>
    <p>Consider RNN(l).</p>
    <p>Move to the right  saves total dist.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>A spatial region, enclosing the objects closer to Q than to sites in S.</p>
    <p>Its the Voronoi cell of Q versus sites in S.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Only consider objects in VCU(Q).</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Only consider objects in VCU(Q).</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Only consider objects in VCU(Q).</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Nave AlgorithmNave Algorithm</p>
    <p>Derive candidates.  Compute AD(l) for each.  Pick smallest.</p>
    <p>Not efficient! Too many candidates! To compute AD(l) for each one, need:  compute RNN(l)  retrieve all these objects</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Progressive IdeaProgressive Idea</p>
    <p>Treat Q as a cell and consider its corners.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Progressive IdeaProgressive Idea</p>
    <p>Divide the cell.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Progressive IdeaProgressive Idea</p>
    <p>Divide the cell.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Progressive IdeaProgressive Idea</p>
    <p>Recursively divide a sub-cell.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Progressive IdeaProgressive Idea</p>
    <p>Recursively divide a sub-cell.</p>
    <p>Able to check all candidates.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Progressive IdeaProgressive Idea  Q: What do you save?  A: Cell pruning, if its lower bound  AD(l0) of some candidate l0.</p>
    <p>AD(lo ) =50</p>
    <p>Suppose 60 is a lower bound for AD(l), l C</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>AD(c1)=1000 AD(c2)=3000</p>
    <p>AD(c3)=4000 AD(c4)=2500</p>
    <p>c</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Theorem: 4</p>
    <p>} 2</p>
    <p>)()( ,</p>
    <p>)()( max{ 3241</p>
    <p>pcADcADcADcAD</p>
    <p>AD(c1)=1000 AD(c2)=3000</p>
    <p>AD(c3)=4000 AD(c4)=2500</p>
    <p>is a lower bound, where p is perimeter.</p>
    <p>e.g. LB(C)=3500-p/4</p>
    <p>c</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>A better lower bound Theorem:</p>
    <p>||</p>
    <p>|)(| *</p>
    <p>)()( ,</p>
    <p>)()( max{ 3241</p>
    <p>O</p>
    <p>CVCUpcADcADcADcAD</p>
    <p>Comparing with the previous lower bound:  Higher quality since the lower bound is larger.  More computation.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>partition it. 4. Compute AD() for the corners of sub-cells. 5. Compute LB() for the sub-cells. 6. Insert sub-cell ci to heap if LB(ci)&lt;AD(lopt) 7. Goto 3.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>ProgressivenessProgressiveness</p>
    <p>The algorithm quickly reports a candidate OL with a confidence interval, and keeps refining.</p>
    <p>Time</p>
    <p>AD(best corner of Q)</p>
    <p>LB(Q)</p>
    <p>AD( real OL ) is inside the interval</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>ProgressivenessProgressiveness</p>
    <p>The algorithm quickly reports a candidate OL with a confidence interval, and keeps refining.</p>
    <p>Time</p>
    <p>AD(best candidate)</p>
    <p>LB(Q)</p>
    <p>AD( real OL ) is inside the interval</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>ProgressivenessProgressiveness</p>
    <p>The algorithm quickly reports a candidate OL with a confidence interval, and keeps refining.</p>
    <p>Time</p>
    <p>AD(best candidate)</p>
    <p>Min{ LB(C) | C in heap }</p>
    <p>AD( real OL ) is inside the interval</p>
    <p>User may choose to terminate any time.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Batch PartitioningBatch Partitioning</p>
    <p>To partition a cell, should partition into multiple sub-cells.</p>
    <p>Reason: to compute AD(l), need to access the R*-tree of objects. When access the R*-tree, want to compute multiple AD(l).</p>
    <p>Tradeoff: if partition too much: wasteful! Since some candidates could be pruned.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Performance SetupPerformance Setup</p>
    <p>O: 123,593 postal addresses in Northeastern part of US. Stored using an R*-tree.</p>
    <p>S: randomly select 100 sites from O.  Buffer: 128 pages.  Dell Pentium IV 3.2GHz.  Query size: 1% in each dimension.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Only consider objects in VCU(Q).</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Effect of VCU ComputationEffect of VCU Computation</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Theorem: 4</p>
    <p>} 2</p>
    <p>)()( ,</p>
    <p>)()( max{ 3241</p>
    <p>pcADcADcADcAD</p>
    <p>AD(c1)=1000 AD(c2)=3000</p>
    <p>AD(c3)=4000 AD(c4)=2500</p>
    <p>is a lower bound, where p is perimeter.</p>
    <p>e.g. LB(C)=3500-p/4</p>
    <p>c</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>A better lower bound Theorem:</p>
    <p>||</p>
    <p>|)(| *</p>
    <p>)()( ,</p>
    <p>)()( max{ 3241</p>
    <p>O</p>
    <p>CVCUpcADcADcADcAD</p>
    <p>Comparing with the previous lower bound:  Higher quality since the lower bound is larger.  More computation.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Comparison of Lower BoundsComparison of Lower Bounds</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>Effect of Batch PartitioningEffect of Batch Partitioning</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>ProgressivenessProgressiveness</p>
    <p>The algorithm quickly reports a candidate OL with a confidence interval, and keeps refining.</p>
    <p>Time</p>
    <p>AD(best candidate)</p>
    <p>Min{ LB(C) | C in heap }</p>
    <p>AD( real OL ) is inside the interval</p>
    <p>User may choose to terminate any time.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>ProgressivenessProgressiveness</p>
    <p>Each step: partition a cell to 40 sub-cells. After 200 steps, accurate answer. After 20 steps, answer is 1% away from optimal.</p>
  </div>
  <div class="page">
    <p>Donghui Zhang e t al.</p>
    <p>ConclusionsConclusions</p>
    <p>Introduced the min-dist optimallocation query.</p>
    <p>Proved theorems to limit the number of candidates.</p>
    <p>Presented lower-bound estimators.  Proposed a progressive algorithm.</p>
  </div>
</Presentation>
