<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Raccoon: Closing Digital Side-Channels through Obfuscated Execution</p>
    <p>Ashay Rane, Calvin Lin, Mohit Tiwari</p>
    <p>The University of Texas at Austin</p>
  </div>
  <div class="page">
    <p>if (secret_bit == 1) { z = (msg * z * z) mod n; } else { z = (z * z) mod n; }</p>
    <p>In fact, very insecure!</p>
    <p>Instruction Pointer</p>
    <p>Instruction count</p>
    <p>Address trace</p>
    <p>Cache usage</p>
    <p>Branch predictor</p>
    <p>Power</p>
    <p>EM radiation</p>
    <p>Secure code?</p>
  </div>
  <div class="page">
    <p>Serious Attacks</p>
    <p>Side-channel attacks have been shown to:</p>
    <p>Leak private encryption keys.</p>
    <p>Reveal private medical information.</p>
    <p>Assist in reverse-engineering closed-source processors.</p>
  </div>
  <div class="page">
    <p>if (secret_bit == 1) { z = (msg * z * z) mod n; } else { z = (z * z) mod n; NOP; NOP; }</p>
    <p>An Example Solution</p>
    <p>Solution steps:</p>
  </div>
  <div class="page">
    <p>if (secret_bit == 1) { z = (msg * z * z) mod n; } else { read msg_dummy; z = (z * z) mod n; NOP; NOP; }</p>
    <p>An Example Solution</p>
    <p>Solution steps:</p>
  </div>
  <div class="page">
    <p>An Example Solution</p>
    <p>Problems with this solution:</p>
    <p>if (secret_bit == 1) { z = (msg * z * z) mod n; } else { read msg_dummy; z = (z * z) mod n; NOP; NOP; }</p>
  </div>
  <div class="page">
    <p>Many Point Solutions Each solution closes only a narrow set of side-channels.</p>
    <p>Defenses against cache side-channel: [HPCA-09], [USENIX-12a], [USENIX-12b], [ISCA-07], [S&amp;P-09], [MICRO-08], [S&amp;P-11], [CCS-12].</p>
    <p>Defenses against address-trace side-channel: [ASPLOS-04], [CCS-13a], [STC-12], [ICS-03], [HASP-13], [HPCA-14], [ASPLOS-15], [CCS-13b].</p>
    <p>Defenses against power side-channel: [CHES-01a], [ACISP-01], [CHES-00], [DATE-05], [PKC-02], [ACISP-04], [CHES-01b], [CT-RSA-03].</p>
  </div>
  <div class="page">
    <p>High overhead from composing multiple point solutions together.</p>
    <p>O ve</p>
    <p>rh ea</p>
    <p>d</p>
    <p>Drawbacks of Point Solutions</p>
  </div>
  <div class="page">
    <p>High overhead from composing multiple point solutions together.</p>
    <p>Individual point solutions may negate each others defenses.</p>
    <p>Example: Tradeoff between instruction count and execution time.</p>
    <p>Changing instruction count also changes execution time.</p>
    <p>Drawbacks of Point Solutions</p>
  </div>
  <div class="page">
    <p>Our Solution Do what Raccoons do!</p>
    <p>??!</p>
    <p>Execute multiple program paths  as if the program were executed using many secret values.</p>
    <p>(Assumes memory is encrypted.)</p>
  </div>
  <div class="page">
    <p>Our Solution: Raccoon Execute multiple program paths</p>
    <p>as if the program were executed using many secret values.</p>
    <p>if (secret_bit == 1) { z = (msg * z * z) mod n; } else { z = (z * z) mod n; }</p>
  </div>
  <div class="page">
    <p>Our Solution: Raccoon</p>
    <p>if (secret_bit == 1) { z = (msg * z * z) mod n; } else { z = (z * z) mod n; }</p>
    <p>Execute multiple program paths  as if the program were executed</p>
    <p>using many secret values.</p>
  </div>
  <div class="page">
    <p>Our Solution: Raccoon</p>
    <p>if (secret_bit == 1) { z = (msg * z * z) mod n; } else { z = (z * z) mod n; }</p>
    <p>Execute multiple program paths  as if the program were executed</p>
    <p>using many secret values.</p>
    <p>Adversary sees secret_bit == 1.</p>
  </div>
  <div class="page">
    <p>Our Solution: Raccoon</p>
    <p>if (secret_bit == 1) { z = (msg * z * z) mod n; } else { z = (z * z) mod n; }</p>
    <p>Execute multiple program paths  as if the program were executed</p>
    <p>using many secret values.</p>
    <p>Adversary sees secret_bit == 1 and secret_bit == 0.</p>
  </div>
  <div class="page">
    <p>Our Solution: Raccoon</p>
    <p>if (secret_bit == 1) { z = (msg * z * z) mod n; } else { z = (z * z) mod n; }</p>
    <p>Execute multiple program paths  as if the program were executed</p>
    <p>using many secret values.</p>
    <p>Adversary sees secret_bit == 1 and secret_bit == 0.</p>
  </div>
  <div class="page">
    <p>Key Insight 1. Many side-channels emerge from variations in source-level behavior.</p>
    <p>Branch predictor state affected by program path.  Memory access trace affected by data-flow and control-flow.  Instruction count governed by program path.</p>
  </div>
  <div class="page">
    <p>Raccoons Approach Raccoons static analysis limits explored branches, thus prevents path explosion.</p>
    <p>Raccoon does not simulate paths, Raccoon executes actual instructions.</p>
    <p>if (secret_bit == 1) { z = (msg * z * z) mod n; } else { z = (z * z) mod n; }</p>
  </div>
  <div class="page">
    <p>Raccoons static analysis limits explored branches, thus prevents path explosion.</p>
    <p>Raccoon does not simulate paths, Raccoon executes actual instructions.</p>
    <p>if (secret_bit == 1) { z = (msg * z * z) mod n; } else { z = (z * z) mod n; }</p>
    <p>Which one to update?</p>
    <p>Raccoons Approach</p>
  </div>
  <div class="page">
    <p>Transaction-Like Buffers Raccoon buffers write operations from each path into a separate transaction buffer.</p>
    <p>After both paths finish execution, one buffer is secretly saved to memory, other is discarded.</p>
  </div>
  <div class="page">
    <p>Other Defenses in Raccoon Simply following multiple program paths is insufficient!</p>
    <p>array[secret_index] = 10;</p>
    <p>Memory address reveals value of secret_index.</p>
  </div>
  <div class="page">
    <p>Array Access Obfuscation</p>
    <p>Option 1: Normalize address trace. Access entire array for every load/store operation.</p>
    <p>Option 2: Randomize address trace. Obfuscate addresses using ORAM. Raccoon includes software version of Path ORAM.</p>
  </div>
  <div class="page">
    <p>Benefits of Raccoon</p>
    <p>Expands the threat model: Defends against broader class of side-channels. Code is no longer secret, only data. Hence no need to hide code.</p>
    <p>Does not require special-purpose hardware: Hence backward compatible with older processors.</p>
    <p>Expands the allowed set of language features, when compared with prior work.</p>
  </div>
  <div class="page">
    <p>Security Evaluation Security of obfuscated code. Verified that control flows and data flows are correct and do not leak information.</p>
    <p>Security of obfuscation code. Verified using inference rules over LLVM IR that obfuscation code does not leak secrets.</p>
    <p>Demonstration of side-channel defense.  Adversary process snoops instruction pointer using /proc.  Adversary runs k-fold cross-validation, plots confusion matrix.</p>
    <p>After obfuscation</p>
  </div>
  <div class="page">
    <p>Performance Evaluation</p>
    <p>We evaluate performance overhead on a modern (Intel Xeon) processor.</p>
    <p>To place our work in the context of well-renowned related work, we compare Raccoon with a competing solution called GhostRider.</p>
    <p>We use 15 programs (which includes 8 from GhostRider).</p>
  </div>
  <div class="page">
    <p>GhostRider (ASPLOS 15)</p>
    <p>geometric-mean(ghostrider) = 195x</p>
    <p>ma trix -m ul</p>
    <p>he ap -ad</p>
    <p>d</p>
    <p>he ap -p op</p>
    <p>bin -se arc h</p>
    <p>his tog ram ma</p>
    <p>p</p>
    <p>fin dma x</p>
    <p>dij ks tra</p>
    <p>GhostRider</p>
  </div>
  <div class="page">
    <p>GhostRider v/s Racccon</p>
    <p>geometric-mean(ghostrider) = 195x</p>
    <p>ma trix -m ul</p>
    <p>he ap -ad</p>
    <p>d</p>
    <p>he ap -p op</p>
    <p>bin -se arc h</p>
    <p>his tog ram ma</p>
    <p>p</p>
    <p>fin dma x</p>
    <p>dij ks tra</p>
    <p>geometric-mean(raccoon) = 16x</p>
    <p>GhostRider Raccoon</p>
  </div>
  <div class="page">
    <p>Raccoons Overhead</p>
    <p>geometric-mean(raccoon) = 9x</p>
    <p>rad ixso rt</p>
    <p>ma trix -m ul</p>
    <p>ge ne tic -al go</p>
    <p>me dris ks</p>
    <p>iptre e</p>
    <p>cla ss ifie r</p>
    <p>fin dma x</p>
    <p>he ap -ad</p>
    <p>d crc -32</p>
    <p>dij ks tra</p>
    <p>bin -se arc h ma p</p>
    <p>he ap -p op</p>
    <p>his tog ram ta</p>
    <p>x</p>
    <p>Raccoon</p>
  </div>
  <div class="page">
    <p>Raccoons Overhead</p>
    <p>geometric-mean(raccoon) = 9x</p>
    <p>rad ixso rt</p>
    <p>ma trix -m ul</p>
    <p>ge ne tic -al go</p>
    <p>me dris ks</p>
    <p>iptre e</p>
    <p>cla ss ifie r</p>
    <p>fin dma x</p>
    <p>he ap -ad</p>
    <p>d crc -32</p>
    <p>dij ks tra</p>
    <p>bin -se arc h ma p</p>
    <p>he ap -p op</p>
    <p>his tog ram ta</p>
    <p>x</p>
    <p>Compiler optimizations</p>
    <p>reduce obfuscation candidates.</p>
    <p>Raccoon</p>
  </div>
  <div class="page">
    <p>Raccoons Overhead</p>
    <p>geometric-mean(raccoon) = 9x</p>
    <p>rad ixso rt</p>
    <p>ma trix -m ul</p>
    <p>ge ne tic -al go</p>
    <p>me dris ks</p>
    <p>iptre e</p>
    <p>cla ss ifie r</p>
    <p>fin dma x</p>
    <p>he ap -ad</p>
    <p>d crc -32</p>
    <p>dij ks tra</p>
    <p>bin -se arc h ma p</p>
    <p>he ap -p op</p>
    <p>his tog ram ta</p>
    <p>x</p>
    <p>Overhead dominated by array</p>
    <p>obfuscation Raccoon</p>
  </div>
  <div class="page">
    <p>Raccoons Overhead</p>
    <p>geometric-mean(raccoon) = 9x</p>
    <p>rad ixso rt</p>
    <p>ma trix -m ul</p>
    <p>ge ne tic -al go</p>
    <p>me dris ks</p>
    <p>iptre e</p>
    <p>cla ss ifie r</p>
    <p>fin dma x</p>
    <p>he ap -ad</p>
    <p>d crc -32</p>
    <p>dij ks tra</p>
    <p>bin -se arc h ma p</p>
    <p>he ap -p op</p>
    <p>his tog ram ta</p>
    <p>x</p>
    <p>transactional accesses</p>
    <p>Raccoon</p>
  </div>
  <div class="page">
    <p>Limitations of Raccoon</p>
    <p>Non-digital side-channels are outside of Raccoons scope.</p>
    <p>Cannot obfuscate library calls and system calls.</p>
    <p>Cannot obfuscate all language features of the C99 standard:  Artifactual limitations: break/continue, secret loop trip counts.  Possibly-fundamental limitation: recursion.</p>
  </div>
  <div class="page">
    <p>Theres More! Paper describes:</p>
    <p>How Raccoon does not introduce new termination-channel leaks.</p>
    <p>Obfuscation of multi-threaded programs.</p>
    <p>Optimizations to improve performance.</p>
    <p>Performance evaluation of software Path ORAM.</p>
    <p>Performance comparison with prior work.</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>By applying program-level obfuscation, we can close many side-channels with one solution.</p>
    <p>This approach works in tandem with modern processors, instead of conflicting with them. Hence backward compatible with old hardware.</p>
    <p>Expands threat model, offers stronger protection.</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Scale Raccoon to bigger programs:  Explore the use of special-purpose hardware.  Reduce overhead so that Raccoons use is practical.</p>
    <p>Strengthen Raccoons security guarantees:  Integrate fixed-time arithmetic libraries into Raccoon.  Increase the set of allowed language features.</p>
  </div>
</Presentation>
