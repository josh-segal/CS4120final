<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Tardigrade: Leveraging Lightweight Virtual Machines to Easily and Efficiently Construct Fault-Tolerant Services</p>
    <p>Lisa Glendenning Dutch T. Meyer Andrew Warfield</p>
    <p>Andrew BaumannJacob R. Lorch</p>
  </div>
  <div class="page">
    <p>Jay Lorch, Microsoft Research Tardigrade 2</p>
    <p>Our goal: Turn existing binaries into fault</p>
    <p>tolerant services.</p>
  </div>
  <div class="page">
    <p>Jay Lorch, Microsoft Research Tardigrade 3</p>
    <p>FDS Cluster</p>
    <p>FDS Metadata server</p>
    <p>Example: FDS Metadata Service</p>
    <p>[Nightingale et al., OSDI 2012]</p>
  </div>
  <div class="page">
    <p>Jay Lorch, Microsoft Research Tardigrade 4</p>
    <p>FDS Cluster</p>
    <p>FDS Metadata server</p>
    <p>Example: FDS Metadata Service</p>
    <p>Paxos leader election</p>
    <p>[Nightingale et al., OSDI 2012]</p>
  </div>
  <div class="page">
    <p>Jay Lorch, Microsoft Research Tardigrade 5</p>
    <p>Use state machine replication library</p>
    <p>Explicitly persist state to reliable back-end</p>
    <p>Requires development resources</p>
    <p>Potential for oversight  Non-determinism  Failing to persist state  Exposing non-persisted data  Bugs in crash recovery</p>
    <p>Techniques for making code fault-tolerant</p>
    <p>have limitations</p>
    <p>Better: Transparently make the binary</p>
    <p>fault-tolerant</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation</p>
    <p>Background: Asynchronous VM replication</p>
    <p>Our solution: Lightweight VM replication</p>
    <p>Challenges and solutions</p>
    <p>Evaluation</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 6</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation</p>
    <p>Background: Asynchronous VM replication</p>
    <p>Our solution: Lightweight VM replication</p>
    <p>Challenges and solutions</p>
    <p>Evaluation</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 7</p>
  </div>
  <div class="page">
    <p>Asynchronous virtual machine replication - Remus</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 8</p>
    <p>primary backup</p>
    <p>Primary can crash at any time; backup is always a bit behind.</p>
    <p>[Cully et al., NSDI 2008]</p>
  </div>
  <div class="page">
    <p>Output buffer</p>
    <p>Asynchronous virtual machine replication - Remus</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 9</p>
    <p>primary backup</p>
    <p>[Cully et al., NSDI 2008]</p>
  </div>
  <div class="page">
    <p>Asynchronous virtual machine replication - Remus</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 10</p>
    <p>Output buffer</p>
    <p>Ack()</p>
    <p>primary backup</p>
    <p>[Cully et al., NSDI 2008]</p>
  </div>
  <div class="page">
    <p>High VM activity can delay packets</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 11</p>
    <p>La te</p>
    <p>n cy</p>
    <p>o f</p>
    <p>p in</p>
    <p>g (</p>
    <p>m s)</p>
    <p>Baseline Safety Scan Search Indexer Update Deduplication</p>
    <p>Processes unrelated to the service can balloon client-perceived latency.</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation</p>
    <p>Background: Asynchronous VM replication</p>
    <p>Our solution: Lightweight VM replication</p>
    <p>Challenges and solutions</p>
    <p>Evaluation</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 12</p>
  </div>
  <div class="page">
    <p>Lightweight VM system examples Xax [Douceur et al., OSDI 2008]</p>
    <p>Native Client [Sehr et al., IEEE S&amp;P 2009] Drawbridge [Porter et al., ASPLOS 2011]</p>
    <p>Embassies [Howell et al., NSDI 2013] Bascule [Baumann et al., Eurosys 2013]</p>
    <p>Our solution: Use lightweight VMs instead</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 13</p>
    <p>Service processOther processes LVM host</p>
    <p>Host OS</p>
    <p>Narrow API (e.g., ~45 calls</p>
    <p>in Bascule)</p>
  </div>
  <div class="page">
    <p>Lightweight VMs can support unmodified binaries via a library OS</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 14</p>
    <p>Service process</p>
    <p>LVM host</p>
    <p>LVM API</p>
  </div>
  <div class="page">
    <p>Service process</p>
    <p>Lightweight VMs can support unmodified binaries via a library OS</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 15</p>
    <p>Service binary</p>
    <p>LVM API</p>
    <p>OS API</p>
    <p>Library OS</p>
    <p>LVM host</p>
    <p>Bascule has a Windows LibOS</p>
    <p>and a Linux LibOS</p>
  </div>
  <div class="page">
    <p>A lightweight VM is encapsulated by virtue of having a narrow interface</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 16</p>
    <p>LVM host</p>
    <p>LVM API</p>
    <p>Service process</p>
    <p>Service binary</p>
    <p>OS API</p>
    <p>Library OS</p>
  </div>
  <div class="page">
    <p>Service process</p>
    <p>Our approach: Checkpoint by interposing on existing LVM API</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 17</p>
    <p>Service binary</p>
    <p>LVM API</p>
    <p>OS API</p>
    <p>Library OS</p>
    <p>Checkpointer</p>
    <p>LVM API</p>
    <p>LVM host</p>
    <p>Checkpoint Interposition using existing</p>
    <p>API means LVM and LibOS dont have to</p>
    <p>change</p>
  </div>
  <div class="page">
    <p>Jay Lorch, Microsoft Research Tardigrade 18</p>
    <p>Lightweight Virtual Machine Replication</p>
    <p>Lightweight Virtual Machine Replication</p>
    <p>Asynchronous Virtual Machine Replication</p>
    <p>Asynchronous Virtual Machine Replication</p>
    <p>primary backup primary backup</p>
    <p>Service</p>
    <p>Library OS</p>
    <p>Checkpointing</p>
    <p>Host</p>
    <p>Service</p>
    <p>Library OS</p>
    <p>Checkpointing</p>
    <p>Host</p>
    <p>[Cully et al., NSDI 2008]</p>
  </div>
  <div class="page">
    <p>[Cully et al., NSDI 2008]</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 19</p>
    <p>Lightweight Virtual Machine Replication</p>
    <p>Lightweight Virtual Machine Replication</p>
    <p>Asynchronous Virtual Machine Replication</p>
    <p>Asynchronous Virtual Machine Replication</p>
    <p>primary backup primary backup</p>
    <p>Guest (service+OS)</p>
    <p>Checkpointing</p>
    <p>Host</p>
    <p>Checkpointing</p>
    <p>Host</p>
    <p>Guest (service+OS)</p>
    <p>Our implementation of</p>
    <p>LVMR is called Tardigrade</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation</p>
    <p>Background: Asynchronous VM replication</p>
    <p>Our solution: Lightweight VM replication</p>
    <p>Challenges and solutions</p>
    <p>Evaluation</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 20</p>
  </div>
  <div class="page">
    <p>See paper for details</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 21</p>
    <p>Maintaining consistency across reconfigurations</p>
    <p>Achieving performance potential</p>
    <p>Checkpointing via an existing LVM API</p>
    <p>Vertical Paxos</p>
    <p>Incremental checkpointing, checkpoint capping, parallelism,</p>
    <p>scaling send buffer size</p>
    <p>Quiescing, pre-checkpointing, enforcing determinism,</p>
    <p>terminating connections</p>
    <p>Challenges Solutions</p>
    <p>Practical LVMR poses challenges</p>
    <p>Lessons for LVM API designers</p>
  </div>
  <div class="page">
    <p>Jay Lorch, Microsoft Research Tardigrade 22</p>
    <p>Checkpointing uses certain LVM API features</p>
    <p>Ability to track changed memory pages</p>
    <p>Determinism when API calls are replayed</p>
    <p>Host state either replayable or regeneratable</p>
    <p>Efficiently compute checkpoint deltas</p>
    <p>Capture consistent snapshot</p>
    <p>Prevent divergence on failover</p>
    <p>Feature Purpose</p>
    <p>Ability to suspend and inspect other threads</p>
    <p>Recreate host state on backup</p>
  </div>
  <div class="page">
    <p>Host state either replayable or regeneratable</p>
    <p>Ability to suspend and inspect other threads</p>
    <p>Missing ability to suspend and inspect other threads</p>
    <p>Determinism when API calls are replayed</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 23</p>
    <p>Features may not always be in LVM APIs</p>
    <p>Non-determinism when API calls are replayed</p>
    <p>Host state not replayable or regeneratable</p>
    <p>Use exceptions, precheckpointing</p>
    <p>Hide non-determinism</p>
    <p>Feature Workaround</p>
    <p>Expose divergence as error condition</p>
    <p>Ability to track changed memory pages</p>
  </div>
  <div class="page">
    <p>Checkpointing layer</p>
    <p>Host</p>
    <p>Guest (service + library OS)</p>
    <p>To capture a checkpoint, we must quiesce and capture all threads state.</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 24</p>
    <p>primary</p>
    <p>Memory</p>
    <p>What if the API doesnt let a thread suspend and inspect another thread?</p>
  </div>
  <div class="page">
    <p>Checkpointing layer</p>
    <p>Host</p>
    <p>Guest (service + library OS)</p>
    <p>We can use exceptions to quiesce guest threads</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 25</p>
    <p>primary</p>
    <p>Checkpoint</p>
  </div>
  <div class="page">
    <p>Checkpoint</p>
    <p>Checkpointing layer</p>
    <p>Host</p>
    <p>Guest (service + library OS)</p>
    <p>Exception handler quiesces and captures each guest threads state</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 26</p>
    <p>primary</p>
    <p>ExceptionHandler( , ) Memory</p>
  </div>
  <div class="page">
    <p>Checkpointing layer</p>
    <p>Host</p>
    <p>Guest (service + library OS)</p>
    <p>Synchronous system calls complicate quiescence</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 27</p>
    <p>primary</p>
  </div>
  <div class="page">
    <p>Checkpointing layerCheckpointing layer</p>
    <p>Host</p>
    <p>Guest (service + library OS)</p>
    <p>The wait system call is easy to deal with</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 28</p>
    <p>primary</p>
    <p>select() file descriptor list</p>
    <p>select() file descriptor list</p>
    <p>time-to-checkpoint</p>
  </div>
  <div class="page">
    <p>Checkpointing layerCheckpointing layerCheckpointing layer</p>
    <p>Host</p>
    <p>Guest (service + library OS)</p>
    <p>General synchronous system calls require pre-checkpointing</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 29</p>
    <p>primary</p>
  </div>
  <div class="page">
    <p>API non-determinism undermines replay</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 30</p>
    <p>primary backup</p>
    <p>CreateSemaphore() returns descriptor 0xAAA</p>
    <p>CreateSemaphore() returns descriptor 0xBBB</p>
  </div>
  <div class="page">
    <p>An indirection table can hide nondeterminism</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 31</p>
    <p>primary backup</p>
    <p>Checkpointing layer</p>
    <p>Host</p>
    <p>Guest (service + library OS)</p>
    <p>Checkpointing layer</p>
    <p>Host</p>
    <p>Guest (service + library OS)</p>
    <p>Guest descriptor Host descriptor</p>
    <p>Guest descriptor Host descriptor</p>
  </div>
  <div class="page">
    <p>State external to guest needs to be replayable or regeneratable</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 32</p>
    <p>primary backup</p>
    <p>Checkpointing layer</p>
    <p>Host</p>
    <p>Guest (service + library OS)</p>
    <p>LVM API</p>
    <p>LVM API</p>
    <p>API provides sockets, not packets</p>
    <p>TCP session state</p>
    <p>Checkpointer cant capture TCP session state!</p>
  </div>
  <div class="page">
    <p>System-specific modifications may be necessary</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 33</p>
    <p>primary backup</p>
    <p>Checkpointing layer</p>
    <p>Host</p>
    <p>Guest (service + library OS)</p>
    <p>TCP session state</p>
    <p>Checkpointing layer</p>
    <p>Host</p>
    <p>Guest (service + library OS)</p>
    <p>TCP connections get dropped on a failover.</p>
    <p>Fixing this requires a major API change to make it use packets rather than sockets</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Motivation</p>
    <p>Background: Asynchronous VM replication</p>
    <p>Our solution: Lightweight VM replication</p>
    <p>Challenges and solutions</p>
    <p>Evaluation</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 34</p>
  </div>
  <div class="page">
    <p>Effect of external processes - Remus</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 35</p>
    <p>La te</p>
    <p>n cy</p>
    <p>o f</p>
    <p>p in</p>
    <p>g (</p>
    <p>m s)</p>
    <p>Baseline Safety Scan Search Indexer Update Deduplication</p>
  </div>
  <div class="page">
    <p>Effect of external processes Tardigrade</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 36</p>
    <p>La te</p>
    <p>n cy</p>
    <p>( m</p>
    <p>s)</p>
    <p>Quantile</p>
    <p>Baseline Safety Scan Search Indexer Update Deduplication</p>
  </div>
  <div class="page">
    <p>Effect of external processes Tardigrade</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 37</p>
    <p>La te</p>
    <p>n cy</p>
    <p>( m</p>
    <p>s)</p>
    <p>Quantile</p>
    <p>Baseline Safety Scan Search Indexer Update Deduplication</p>
  </div>
  <div class="page">
    <p>Memory dirtying affects checkpoint latency</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 38</p>
    <p>C D</p>
    <p>F (</p>
    <p>% )</p>
    <p>Latency (ms)</p>
    <p>No dirtying 10% of net b/w 20% of net b/w</p>
  </div>
  <div class="page">
    <p>FDS metadata service</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 39</p>
    <p>C D</p>
    <p>F (</p>
    <p>% )</p>
    <p>Checkpoint interval (ms)</p>
    <p>Metadata server initially idle Cluster starting up</p>
    <p>Cluster operating normally</p>
    <p>Checkpoint delta average size: 0.9 MB</p>
    <p>Checkpoint delta average size: 1.8 MB</p>
  </div>
  <div class="page">
    <p>ZKLite, a simple non-fault-tolerant Java implementation of the Zookeeper API</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 40</p>
    <p>C D</p>
    <p>F (</p>
    <p>% )</p>
    <p>Client request latency (ms)</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>Jay Lorch, Microsoft Research Tardigrade 41</p>
    <p>No changes to binaries needed, making deployment simple</p>
    <p>Replicating processes rather than VMs substantially reduces worst-case latency</p>
    <p>Reasonable performance if memory dirtying rate and load are low</p>
    <p>Lightweight virtual machine API designers should consider effect on replication</p>
    <p>Examples of good targets: Metadata services</p>
    <p>Coordination services Niche web services</p>
    <p>Lightweight VM replication is practical for making existing service binaries fault-tolerant</p>
  </div>
</Presentation>
