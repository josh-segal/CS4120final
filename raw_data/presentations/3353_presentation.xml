<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Technische Universitt Mnchen Fakultt fr Informatik</p>
    <p>Predicting the Resilience of Obfuscated Code Against</p>
    <p>Symbolic Execution Attacks via Machine Learning</p>
    <p>Sebastian Banescu Christian Collberg</p>
    <p>Alexander Pretschner</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Informal Definition of Obfuscation</p>
    <p>To obfuscate a program P means to transform it into an equivalent program P from which it is harder to extract information than from P.</p>
    <p>Informal Definition of Reverse Engineering</p>
    <p>The process of extracting data or a model of the system by inspecting its lower level description and/or behavior.</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Informal Definition of Obfuscation</p>
    <p>To obfuscate a program P means to transform it into an equivalent program P from which it is harder to extract information than from P.</p>
    <p>Informal Definition of Reverse Engineering</p>
    <p>The process of extracting data or a model of the system by inspecting its lower level description and/or behavior.</p>
  </div>
  <div class="page">
    <p>Attacker Models in IT Security</p>
  </div>
  <div class="page">
    <p>Attacker Models in IT Security</p>
  </div>
  <div class="page">
    <p>Attacker Models in IT Security</p>
  </div>
  <div class="page">
    <p>Attacker Models in IT Security</p>
  </div>
  <div class="page">
    <p>Motivation</p>
    <p>Motivational Example</p>
    <p>Problem: Software developer wants to protect software for 100 days</p>
    <p>Current approach: Obfuscate program and run attack (slow)</p>
    <p>Our approach: Obfuscate program and predict effort (fast)</p>
  </div>
  <div class="page">
    <p>Motivation</p>
    <p>Motivational Example</p>
    <p>Problem: Software developer wants to protect software for 100 days</p>
    <p>Current approach: Obfuscate program and run attack (slow)</p>
    <p>Our approach: Obfuscate program and predict effort (fast)</p>
  </div>
  <div class="page">
    <p>Motivation</p>
    <p>Motivational Example</p>
    <p>Problem: Software developer wants to protect software for 100 days</p>
    <p>Current approach: Obfuscate program and run attack (slow)</p>
    <p>Our approach: Obfuscate program and predict effort (fast)</p>
  </div>
  <div class="page">
    <p>Motivation</p>
    <p>Motivational Example</p>
    <p>Problem: Software developer wants to protect software for 100 days</p>
    <p>Current approach: Obfuscate program and run attack (slow)</p>
    <p>Our approach: Obfuscate program and predict effort (fast)</p>
  </div>
  <div class="page">
    <p>Research Questions Answered in This Paper</p>
  </div>
  <div class="page">
    <p>Research Questions Answered in This Paper</p>
  </div>
  <div class="page">
    <p>Research Questions Answered in This Paper</p>
  </div>
  <div class="page">
    <p>Overview of Methodology Steps</p>
    <p>Case study: deobfuscation attack based on symbolic execution</p>
  </div>
  <div class="page">
    <p>Overview of Methodology Steps</p>
    <p>Case study: deobfuscation attack based on symbolic execution</p>
  </div>
  <div class="page">
    <p>Symbolic Execution in a Nutshell</p>
    <p>Interpret program using symbolic values instead of concrete ones</p>
    <p>Fork execution on each branch dependent on symbolic values</p>
    <p>Collect path constraints for each execution path</p>
    <p>Get concrete input values from path conditions using SMT solver</p>
  </div>
  <div class="page">
    <p>Symbolic Execution in a Nutshell</p>
    <p>Interpret program using symbolic values instead of concrete ones Fork execution on each branch dependent on symbolic values</p>
    <p>Collect path constraints for each execution path Get concrete input values from path conditions using SMT solver</p>
  </div>
  <div class="page">
    <p>Symbolic Execution in a Nutshell</p>
    <p>Interpret program using symbolic values instead of concrete ones Fork execution on each branch dependent on symbolic values Collect path constraints for each execution path</p>
    <p>Get concrete input values from path conditions using SMT solver</p>
  </div>
  <div class="page">
    <p>Symbolic Execution in a Nutshell</p>
    <p>Interpret program using symbolic values instead of concrete ones Fork execution on each branch dependent on symbolic values Collect path constraints for each execution path Get concrete input values from path conditions using SMT solver</p>
  </div>
  <div class="page">
    <p>Bypassing License Checks via Symbolic Execution</p>
    <p>Make license input symbolic</p>
    <p>Indicate distinct statement executed when license key is correct</p>
    <p>Symbolic execution finds correct license key (even in obfuscated code)</p>
    <p>Case study in this paper: Predict time of this attack for given program</p>
  </div>
  <div class="page">
    <p>Bypassing License Checks via Symbolic Execution</p>
    <p>Make license input symbolic</p>
    <p>Indicate distinct statement executed when license key is correct</p>
    <p>Symbolic execution finds correct license key (even in obfuscated code)</p>
    <p>Case study in this paper: Predict time of this attack for given program</p>
  </div>
  <div class="page">
    <p>Step 1: Create Dataset of Original Programs</p>
    <p>Need large dataset for training</p>
    <p>Empirically identify features:</p>
    <p>Generate dataset of programs with varying feature values</p>
  </div>
  <div class="page">
    <p>Step 1: Create Dataset of Original Programs</p>
    <p>Need large dataset for training</p>
    <p>Empirically identify features:</p>
    <p>Generate dataset of programs with varying feature values</p>
  </div>
  <div class="page">
    <p>Step 1: Create Dataset of Original Programs</p>
    <p>Need large dataset for training</p>
    <p>Empirically identify features:</p>
    <p>Generate dataset of programs with varying feature values</p>
  </div>
  <div class="page">
    <p>Step 1 (cont): C Program Generator</p>
    <p>Randomly generated function f consists of 3 phases:</p>
    <p>Expansion</p>
    <p>Mixing</p>
    <p>Compression</p>
    <p>Parameters:</p>
    <p>Random seed (3)</p>
    <p>Data types (4)</p>
    <p>Type of loop bounds (3)</p>
    <p>Type of operators (4)</p>
    <p>Control structures (16)</p>
    <p>Size of basic blocks (2)</p>
    <p>Total number of generated programs: 3434162 = 4608</p>
  </div>
  <div class="page">
    <p>Step 1 (cont): C Program Generator</p>
    <p>Randomly generated function f consists of 3 phases:</p>
    <p>Expansion</p>
    <p>Mixing</p>
    <p>Compression</p>
    <p>Parameters:</p>
    <p>Random seed (3)</p>
    <p>Data types (4)</p>
    <p>Type of loop bounds (3)</p>
    <p>Type of operators (4)</p>
    <p>Control structures (16)</p>
    <p>Size of basic blocks (2)</p>
    <p>Total number of generated programs: 3434162 = 4608</p>
  </div>
  <div class="page">
    <p>Step 1 (cont): C Program Generator</p>
    <p>Randomly generated function f consists of 3 phases:</p>
    <p>Expansion</p>
    <p>Mixing</p>
    <p>Compression</p>
    <p>Parameters:</p>
    <p>Random seed (3)</p>
    <p>Data types (4)</p>
    <p>Type of loop bounds (3)</p>
    <p>Type of operators (4)</p>
    <p>Control structures (16)</p>
    <p>Size of basic blocks (2)</p>
    <p>Total number of generated programs: 3434162 = 4608</p>
  </div>
  <div class="page">
    <p>Step 2: Obfuscate Programs</p>
    <p>Each program generated in Step 1 obfuscated with Tigress C Obfuscator</p>
    <p>Transformations used:</p>
    <p>Total number of obfuscated programs: 5  4608 = 23040</p>
  </div>
  <div class="page">
    <p>Step 2: Obfuscate Programs</p>
    <p>Each program generated in Step 1 obfuscated with Tigress C Obfuscator</p>
    <p>Transformations used:</p>
    <p>Total number of obfuscated programs: 5  4608 = 23040</p>
  </div>
  <div class="page">
    <p>Step 2: Obfuscate Programs</p>
    <p>Each program generated in Step 1 obfuscated with Tigress C Obfuscator</p>
    <p>Transformations used:</p>
    <p>Total number of obfuscated programs: 5  4608 = 23040</p>
  </div>
  <div class="page">
    <p>Step 3: Attack Obfuscated Programs</p>
    <p>Attacker goal: bypass license check</p>
    <p>Execute attack based on symbolic execution on programs from Step 2</p>
    <p>Record time of successful attacks</p>
  </div>
  <div class="page">
    <p>Step 4: Feature Extraction</p>
    <p>Extracted 64 features in total:</p>
    <p>Static code metrics Dynamic code metrics SAT metrics</p>
    <p>Graph metrics on a SAT formula represented as a graph</p>
    <p>(x +y +z) (!x+!y +z) (x+!y+!z)</p>
  </div>
  <div class="page">
    <p>Step 4: Feature Extraction</p>
    <p>Extracted 64 features in total:</p>
    <p>Static code metrics Dynamic code metrics SAT metrics</p>
    <p>Graph metrics on a SAT formula represented as a graph</p>
    <p>(x +y +z) (!x+!y +z) (x+!y+!z)</p>
  </div>
  <div class="page">
    <p>Step 4 (cont): SAT Before &amp; After Obfuscation</p>
    <p>Before Obfuscation (7.5 sec) 1 unsigned int SDBMHash(char* str , unsigned int len) 2 { 3 unsigned int hash = 0; 4 unsigned int i = 0; 5 for(i = 0; i &lt; len; str++, i++) 6 hash = (*str) + (hash &lt;&lt; 6) 7 + (hash &lt;&lt; 16) - hash; 8 return hash; 9 }</p>
    <p>Strong obfuscation transformations destroy community structures</p>
  </div>
  <div class="page">
    <p>Step 4 (cont): SAT Before &amp; After Obfuscation</p>
    <p>Before Obfuscation (7.5 sec) After Obfuscation (438 sec)</p>
    <p>Strong obfuscation transformations destroy community structures</p>
  </div>
  <div class="page">
    <p>Step 5: Create Prediction Model for Deobfuscation</p>
    <p>Performed recursive feature selection  15 features</p>
    <p>Most important are SAT features</p>
    <p>These features stem from complexity of path constraints</p>
    <p>Employed different ML algorithms for predicting attacker effort:</p>
    <p>Neural Networks Support Vector Machines Random Forest Genetic Programming</p>
  </div>
  <div class="page">
    <p>Step 5: Create Prediction Model for Deobfuscation</p>
    <p>Performed recursive feature selection  15 features</p>
    <p>Variable Importance</p>
    <p>weight</p>
    <p>sdinter</p>
    <p>ol_coms</p>
    <p>meaninter</p>
    <p>sdedgeratio</p>
    <p>meancom</p>
    <p>meanintra</p>
    <p>sdcom</p>
    <p>sdintra</p>
    <p>ol_q</p>
    <p>edgeratio</p>
    <p>Risk</p>
    <p>L1.Loops</p>
    <p>max_clause</p>
    <p>num_max_inter</p>
    <p>Most important are SAT features</p>
    <p>These features stem from complexity of path constraints</p>
    <p>Employed different ML algorithms for predicting attacker effort:</p>
    <p>Neural Networks Support Vector Machines Random Forest Genetic Programming</p>
  </div>
  <div class="page">
    <p>Step 5: Create Prediction Model for Deobfuscation</p>
    <p>Performed recursive feature selection  15 features</p>
    <p>Most important are SAT features</p>
    <p>These features stem from complexity of path constraints</p>
    <p>Employed different ML algorithms for predicting attacker effort:</p>
    <p>Neural Networks Support Vector Machines Random Forest Genetic Programming</p>
  </div>
  <div class="page">
    <p>Step 5: Create Prediction Model for Deobfuscation</p>
    <p>Performed recursive feature selection  15 features</p>
    <p>Most important are SAT features</p>
    <p>These features stem from complexity of path constraints</p>
    <p>Employed different ML algorithms for predicting attacker effort:</p>
    <p>Neural Networks Support Vector Machines Random Forest Genetic Programming</p>
  </div>
  <div class="page">
    <p>Step 5: Create Prediction Model for Deobfuscation</p>
    <p>Performed recursive feature selection  15 features</p>
    <p>Most important are SAT features</p>
    <p>These features stem from complexity of path constraints</p>
    <p>Employed different ML algorithms for predicting attacker effort:</p>
    <p>Neural Networks Support Vector Machines Random Forest Genetic Programming</p>
  </div>
  <div class="page">
    <p>Step 5: Predict Average Effort Needed by Attack</p>
    <p>Comparison of prediction error from different ML algorithms R</p>
    <p>e la</p>
    <p>tiv e</p>
    <p>e rr</p>
    <p>o r</p>
    <p>Percentage of programs 0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95</p>
    <p>Type of error</p>
    <p>Maximum error with Neural Networks Maximum error with Support Vector Machines Maximum error with Random Forest Maximum error with Genetic Programming Median error with Neural Networks Median error with Support Vector Machines Median error with Random Forest Median error with Genetic Programming</p>
  </div>
  <div class="page">
    <p>Do our results generalize?</p>
    <p>Parameters:</p>
    <p>Random seed (3)</p>
    <p>Data types (4)</p>
    <p>Type of loop bounds (3)</p>
    <p>Type of operators (4)</p>
    <p>Control structures (16)</p>
    <p>Size of basic blocks (2)</p>
    <p>Each program obfuscated with Tigress C Obfuscator</p>
  </div>
  <div class="page">
    <p>Generality of Results</p>
    <p>Collected 11 non-cryptographic hash functions Used them as part of license checking algorithms in C programs Obfuscated using Tigress (2-layers of obfuscation): 275 programs Applied prediction model trained on randomly generated C programs</p>
    <p>R e la</p>
    <p>tiv e e</p>
    <p>rr o r</p>
    <p>Percentage of programs 0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95</p>
    <p>Type of error</p>
    <p>Maximum error with 10% of outliers removed Maximum error with 4% of outliers removed Maximum error with 0% of outliers removed Median error with 10% of outliers removed Median error with 4% of outliers removed Median error with 0% of outliers removed</p>
  </div>
  <div class="page">
    <p>Generality of Results</p>
    <p>Collected 11 non-cryptographic hash functions Used them as part of license checking algorithms in C programs Obfuscated using Tigress (2-layers of obfuscation): 275 programs Applied prediction model trained on randomly generated C programs</p>
    <p>R e</p>
    <p>la tiv</p>
    <p>e e</p>
    <p>rr o</p>
    <p>r</p>
    <p>Percentage of programs 0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95</p>
    <p>Type of error</p>
    <p>Maximum error with 10% of outliers removed Maximum error with 4% of outliers removed Maximum error with 0% of outliers removed Median error with 10% of outliers removed Median error with 4% of outliers removed Median error with 0% of outliers removed</p>
  </div>
  <div class="page">
    <p>Generality of Results (cont)</p>
    <p>Collected 11 SAT-Competition instances corresponding to cryptographic hash functions Trained RF model with top 10 SAT features using SAT instances of randomly generated C programs Applied RF model to SAT instances of cryptographic hash functions</p>
    <p>Instance Name Solver (sec) Predicted (sec) Predicted Solver</p>
    <p>MD5-27-4 25.37 71.56 2.82 mizh-md5-47-3 681.29 950.43 1.39 mizh-md5-47-4 235.53 1069.19 4.53 mizh-md5-47-5 1832.96 437.98 0.23 mizh-md5-48-2 445.19 523.70 1.17 mizh-md5-48-5 227.05 644.38 2.83 mizh-sha0-35-2 330.48 158.57 0.47 mizh-sha0-35-3 139.93 213.03 1.52 mizh-sha0-35-4 97.62 214.61 2.19 mizh-sha0-35-5 164.71 193.49 1.17 mizh-sha0-36-2 85.44 222.07 2.59</p>
  </div>
  <div class="page">
    <p>Generality of Results (cont)</p>
    <p>Collected 11 SAT-Competition instances corresponding to cryptographic hash functions Trained RF model with top 10 SAT features using SAT instances of randomly generated C programs Applied RF model to SAT instances of cryptographic hash functions</p>
    <p>Instance Name Solver (sec) Predicted (sec) Predicted Solver</p>
    <p>MD5-27-4 25.37 71.56 2.82 mizh-md5-47-3 681.29 950.43 1.39 mizh-md5-47-4 235.53 1069.19 4.53 mizh-md5-47-5 1832.96 437.98 0.23 mizh-md5-48-2 445.19 523.70 1.17 mizh-md5-48-5 227.05 644.38 2.83 mizh-sha0-35-2 330.48 158.57 0.47 mizh-sha0-35-3 139.93 213.03 1.52 mizh-sha0-35-4 97.62 214.61 2.19 mizh-sha0-35-5 164.71 193.49 1.17 mizh-sha0-36-2 85.44 222.07 2.59</p>
  </div>
  <div class="page">
    <p>Conclusions and Future Work</p>
    <p>Conclusions</p>
    <p>General approach towards deobfuscation effort prediction</p>
    <p>C code generator: &gt; 4500 non-obfuscated programs</p>
    <p>Obfuscated using 5 transformations: &gt; 23000 obfuscated programs</p>
    <p>SAT features most relevant for prediction</p>
    <p>Prediction models using GP, SVM, NN, RF</p>
    <p>Train using randomly generated functions, predict effort of (non-)cryptographic hash functions</p>
    <p>Future perspectives:</p>
    <p>Apply approach to other auto-MATEd attacks, e.g. CFG simplification, disassembly, etc.</p>
    <p>Extend benchmark program generator</p>
    <p>Use machine learning to derive features</p>
  </div>
  <div class="page">
    <p>Conclusions and Future Work</p>
    <p>Conclusions</p>
    <p>General approach towards deobfuscation effort prediction</p>
    <p>C code generator: &gt; 4500 non-obfuscated programs</p>
    <p>Obfuscated using 5 transformations: &gt; 23000 obfuscated programs</p>
    <p>SAT features most relevant for prediction</p>
    <p>Prediction models using GP, SVM, NN, RF</p>
    <p>Train using randomly generated functions, predict effort of (non-)cryptographic hash functions</p>
    <p>Future perspectives:</p>
    <p>Apply approach to other auto-MATEd attacks, e.g. CFG simplification, disassembly, etc.</p>
    <p>Extend benchmark program generator</p>
    <p>Use machine learning to derive features</p>
  </div>
  <div class="page">
    <p>Thank you for your attention</p>
    <p>C Code Generator: http://tigress.cs.arizona.edu/transformPage/docs/randomFuns</p>
    <p>Datasets and scripts: https://github.com/tum-i22/obfuscation-benchmarks</p>
    <p>Questions ?</p>
  </div>
</Presentation>
