<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>THE COST OF REPAIRING REGULAR SPECIFICATIONS</p>
    <p>Gabriele Puppis LaBRI / CNRS</p>
    <p>based on joint works with</p>
    <p>Michael Benedikt, Cristian Riveros, Slawek Staworko</p>
  </div>
  <div class="page">
    <p>What do you do when a computational object fails a specification?</p>
    <p>Source</p>
    <p>Target</p>
    <p>Worst-case cost of repairing source into target:</p>
    <p>max sS</p>
    <p>min tT</p>
    <p>dist(s,t)</p>
    <p>Depends on distance (e.g., Levenstein distance)</p>
    <p>Can be infinite!</p>
  </div>
  <div class="page">
    <p>What do you do when a computational object fails a specification?</p>
    <p>Source</p>
    <p>Target</p>
    <p>Worst-case cost of repairing source into target:</p>
    <p>max sS</p>
    <p>min tT</p>
    <p>dist(s,t)</p>
    <p>Depends on distance (e.g., Levenstein distance)</p>
    <p>Can be infinite!</p>
  </div>
  <div class="page">
    <p>What do you do when a computational object fails a specification?</p>
    <p>Source</p>
    <p>Target</p>
    <p>Worst-case cost of repairing source into target:</p>
    <p>max sS</p>
    <p>min tT</p>
    <p>dist(s,t)</p>
    <p>Depends on distance (e.g., Levenstein distance)</p>
    <p>Can be infinite!</p>
  </div>
  <div class="page">
    <p>What do you do when a computational object fails a specification?</p>
    <p>Source</p>
    <p>Target</p>
    <p>Worst-case cost of repairing source into target:</p>
    <p>max sS</p>
    <p>min tT</p>
    <p>dist(s,t)</p>
    <p>Depends on distance (e.g., Levenstein distance)</p>
    <p>Can be infinite!</p>
  </div>
  <div class="page">
    <p>Plan</p>
    <p>A. Bounded repairability of regular word languages</p>
    <p>B. Bounded repairability of regular tree languages</p>
  </div>
  <div class="page">
    <p>Part A. Problem setting:</p>
    <p>Given two languages S   and T</p>
    <p>(represented by finite state automata)</p>
    <p>Decide whether max sS</p>
    <p>min tT</p>
    <p>dist(s,t) is finite.</p>
    <p>Examples</p>
    <p>(1 + 0) is not bounded repairable into (1 + 05)</p>
  </div>
  <div class="page">
    <p>Part A. Problem setting:</p>
    <p>Given two languages S   and T</p>
    <p>(represented by finite state automata)</p>
    <p>Decide whether max sS</p>
    <p>min tT</p>
    <p>dist(s,t) is finite.</p>
    <p>Examples</p>
    <p>(1 + 0) is not bounded repairable into (1 + 05)</p>
  </div>
  <div class="page">
    <p>Rule of thumb: If you need to edit, youd better do it outside a loop!</p>
    <p>Source automaton</p>
    <p>X1</p>
    <p>Target automaton</p>
    <p>Y1</p>
    <p>For any strategy that repairs traces of X into traces of Y: 1. either traces(X)  traces(Y ) 2. or the strategy has unbounded cost.</p>
  </div>
  <div class="page">
    <p>Rule of thumb: If you need to edit, youd better do it outside a loop!</p>
    <p>Source automaton</p>
    <p>X1</p>
    <p>Target automaton</p>
    <p>Y1</p>
    <p>For any strategy that repairs traces of X into traces of Y: 1. either traces(X)  traces(Y ) 2. or the strategy has unbounded cost.</p>
  </div>
  <div class="page">
    <p>Rule of thumb: If you need to edit, youd better do it outside a loop!</p>
    <p>Source automaton</p>
    <p>X1</p>
    <p>Target automaton</p>
    <p>Y1</p>
    <p>For any strategy that repairs traces of X into traces of Y: 1. either traces(X)  traces(Y ) 2. or the strategy has unbounded cost.</p>
  </div>
  <div class="page">
    <p>Characterization of bounded repairability of word languages</p>
    <p>S is repairable into T with uniformly bounded cost</p>
    <p>Given some (trimmed) automata for S and T and the DAGs of strongly connected components...</p>
    <p>Source DAG Target DAG</p>
    <p>...every chain of components in the source is covered by a chain of components in the target.</p>
  </div>
  <div class="page">
    <p>Characterization of bounded repairability of word languages</p>
    <p>S is repairable into T with uniformly bounded cost</p>
    <p>Given some (trimmed) automata for S and T and the DAGs of strongly connected components...</p>
    <p>Source DAG Target DAG</p>
    <p>...every chain of components in the source is covered by a chain of components in the target.</p>
  </div>
  <div class="page">
    <p>Characterization of bounded repairability of word languages</p>
    <p>S is repairable into T with uniformly bounded cost</p>
    <p>Given some (trimmed) automata for S and T and the DAGs of strongly connected components...</p>
    <p>Source DAG Target DAG</p>
    <p>...every chain of components in the source is covered by a chain of components in the target.</p>
  </div>
  <div class="page">
    <p>An example</p>
    <p>All chains of source DAG are covered by chains of target DAG  S is repairable into T with uniformly bounded cost.</p>
    <p>S = 301+ 302</p>
    <p>T = 101+ 202</p>
    <p>There is no covering relation compatible with prefixes  the repair strategy is not streaming</p>
    <p>(i.e. implementable by a sequential transducer)</p>
  </div>
  <div class="page">
    <p>An example</p>
    <p>All chains of source DAG are covered by chains of target DAG  S is repairable into T with uniformly bounded cost.</p>
    <p>S = 301+ 302</p>
    <p>T = 101+ 202</p>
    <p>There is no covering relation compatible with prefixes  the repair strategy is not streaming</p>
    <p>(i.e. implementable by a sequential transducer)</p>
  </div>
  <div class="page">
    <p>An example</p>
    <p>All chains of source DAG are covered by chains of target DAG  S is repairable into T with uniformly bounded cost.</p>
    <p>S = 301+ 302</p>
    <p>T = 101+ 202</p>
    <p>There is no covering relation compatible with prefixes  the repair strategy is not streaming</p>
    <p>(i.e. implementable by a sequential transducer)</p>
  </div>
  <div class="page">
    <p>An example</p>
    <p>All chains of source DAG are covered by chains of target DAG  S is repairable into T with uniformly bounded cost.</p>
    <p>S = 301+ 302</p>
    <p>T = 101+ 202</p>
    <p>There is no covering relation compatible with prefixes  the repair strategy is not streaming</p>
    <p>(i.e. implementable by a sequential transducer)</p>
  </div>
  <div class="page">
    <p>An example</p>
    <p>All chains of source DAG are covered by chains of target DAG  S is repairable into T with uniformly bounded cost.</p>
    <p>S = 301+ 302</p>
    <p>T = 101+ 202</p>
    <p>There is no covering relation compatible with prefixes  the repair strategy is not streaming</p>
    <p>(i.e. implementable by a sequential transducer)</p>
  </div>
  <div class="page">
    <p>Complexity of non-streaming bounded repairability problem:</p>
    <p>NFA PTIME co-NP PSPACE</p>
    <p>DFA PTIME co-NP PSPACE</p>
    <p>fixed CONST PTIME PSPACE</p>
    <p>fixed DFA NFA</p>
    <p>Complexity of streaming bounded repairability problem:</p>
    <p>NFA PSPACEPTIME PSPACE PTIME</p>
    <p>EXPTIME PSPACE</p>
    <p>DFA PTIME PTIME PSPACE</p>
    <p>fixed CONST PTIME PSPACE</p>
    <p>fixed DFA NFA</p>
  </div>
  <div class="page">
    <p>Complexity of non-streaming bounded repairability problem:</p>
    <p>NFA PTIME co-NP PSPACE</p>
    <p>DFA PTIME co-NP PSPACE</p>
    <p>fixed CONST PTIME PSPACE</p>
    <p>fixed DFA NFA</p>
    <p>Complexity of streaming bounded repairability problem:</p>
    <p>NFA PSPACEPTIME PSPACE PTIME</p>
    <p>EXPTIME PSPACE</p>
    <p>DFA PTIME PTIME PSPACE</p>
    <p>fixed CONST PTIME PSPACE</p>
    <p>fixed DFA NFA</p>
  </div>
  <div class="page">
    <p>Part B. New tools for a more general setting...</p>
    <p>Languages of words:</p>
    <p>insersions / deletions</p>
    <p>finite state automata</p>
    <p>components &amp; traces</p>
    <p>coverability of chains</p>
    <p>Languages of unranked trees:</p>
    <p>insertions / deletions</p>
    <p>stepwise tree automata</p>
    <p>components &amp; contexts</p>
    <p>coverability of synopsis trees</p>
  </div>
  <div class="page">
    <p>Edit operations on unranked trees: deletions</p>
    <p>. . . . . .</p>
    <p>. . .</p>
    <p>. . . . . . . . .</p>
    <p>. . . . . .</p>
    <p>. . .X</p>
  </div>
  <div class="page">
    <p>Edit operations on unranked trees: deletions</p>
    <p>. . . . . .</p>
    <p>. . .</p>
    <p>. . . . . . . . .</p>
    <p>. . . . . .</p>
    <p>. . .</p>
  </div>
  <div class="page">
    <p>Edit operations on unranked trees: insertions</p>
    <p>. . . . . .</p>
    <p>. . . . . . . . .</p>
    <p>. . . . . . . . .</p>
    <p>. . .</p>
    <p>+</p>
  </div>
  <div class="page">
    <p>Edit operations on unranked trees: insertions</p>
    <p>. . . . . .</p>
    <p>. . . . . . . . .</p>
    <p>. . . . . . . . .</p>
    <p>. . .</p>
  </div>
  <div class="page">
    <p>An example</p>
    <p>Source</p>
    <p>r</p>
    <p>d</p>
    <p>a ... a b .. . b</p>
    <p>c .. . c</p>
    <p>Target</p>
    <p>r</p>
    <p>a ... a e</p>
    <p>b ... b c .. . c</p>
  </div>
  <div class="page">
    <p>An example</p>
    <p>Source</p>
    <p>r</p>
    <p>d</p>
    <p>a ... a b .. . b</p>
    <p>c .. . c</p>
    <p>Target</p>
    <p>r</p>
    <p>a ... a e</p>
    <p>b ... b c .. . c</p>
    <p>r</p>
    <p>d</p>
    <p>a ... a b .. . b</p>
    <p>c .. . cX</p>
  </div>
  <div class="page">
    <p>An example</p>
    <p>Source</p>
    <p>r</p>
    <p>d</p>
    <p>a ... a b .. . b</p>
    <p>c .. . c</p>
    <p>Target</p>
    <p>r</p>
    <p>a ... a e</p>
    <p>b ... b c .. . c</p>
    <p>r</p>
    <p>a ... a b .. . b</p>
    <p>c .. . c +</p>
  </div>
  <div class="page">
    <p>An example</p>
    <p>Source</p>
    <p>r</p>
    <p>d</p>
    <p>a ... a b .. . b</p>
    <p>c .. . c</p>
    <p>Target</p>
    <p>r</p>
    <p>a ... a e</p>
    <p>b ... b c .. . c</p>
    <p>r</p>
    <p>a ... a b .. . b</p>
    <p>c .. . c e</p>
  </div>
  <div class="page">
    <p>Bottom-up automata on ranked (binary) trees:</p>
    <p>. . .</p>
    <p>q1 q2</p>
    <p>(q1,q2)</p>
    <p>How to parse unranked trees?</p>
    <p>Encode them using binary trees!</p>
  </div>
  <div class="page">
    <p>Bottom-up automata on ranked (binary) trees:</p>
    <p>. . .</p>
    <p>q1 q2</p>
    <p>(q1,q2)</p>
    <p>How to parse unranked trees?</p>
    <p>Encode them using binary trees!</p>
  </div>
  <div class="page">
    <p>The curry encoding</p>
    <p>@ ...</p>
    <p>@ @</p>
    <p>n</p>
    <p>n</p>
    <p>@ 0 @</p>
    <p>... n</p>
    <p>Stepwise automata = bottom-up on curry encodings</p>
  </div>
  <div class="page">
    <p>The curry encoding</p>
    <p>@ ...</p>
    <p>@ @</p>
    <p>n</p>
    <p>n</p>
    <p>@ 0 @</p>
    <p>... n</p>
    <p>Stepwise automata = bottom-up on curry encodings</p>
  </div>
  <div class="page">
    <p>The curry encoding</p>
    <p>@ ...</p>
    <p>@ @</p>
    <p>n</p>
    <p>n</p>
    <p>@ 0 @</p>
    <p>... n</p>
    <p>Stepwise automata = bottom-up on curry encodings</p>
  </div>
  <div class="page">
    <p>The curry encoding</p>
    <p>@ ...</p>
    <p>@ @</p>
    <p>n</p>
    <p>n</p>
    <p>@ 0 @</p>
    <p>... n</p>
    <p>Stepwise automata = bottom-up on curry encodings</p>
  </div>
  <div class="page">
    <p>The curry encoding</p>
    <p>@ ...</p>
    <p>@ @</p>
    <p>n</p>
    <p>n</p>
    <p>@ 0 @</p>
    <p>... n</p>
    <p>Stepwise automata = bottom-up on curry encodings</p>
  </div>
  <div class="page">
    <p>An example</p>
    <p>r</p>
    <p>a ... a b</p>
    <p>b</p>
    <p>c</p>
    <p>@</p>
    <p>@</p>
    <p>...</p>
    <p>@ r a</p>
    <p>a</p>
    <p>@</p>
    <p>b ...</p>
    <p>@</p>
    <p>b c qr qa qc</p>
    <p>qfinal</p>
    <p>r  qr a  qa b  qb c  qc</p>
    <p>qr @ qa  qr qb @ qc  qc qr @ qc  qfinal</p>
  </div>
  <div class="page">
    <p>An example</p>
    <p>r</p>
    <p>a ... a b</p>
    <p>b</p>
    <p>c</p>
    <p>@</p>
    <p>@</p>
    <p>...</p>
    <p>@ r a</p>
    <p>a</p>
    <p>@</p>
    <p>b ...</p>
    <p>@</p>
    <p>b c qr qa qc</p>
    <p>qfinal</p>
    <p>r  qr a  qa b  qb c  qc</p>
    <p>qr @ qa  qr qb @ qc  qc qr @ qc  qfinal</p>
  </div>
  <div class="page">
    <p>An example</p>
    <p>r</p>
    <p>a ... a b</p>
    <p>b</p>
    <p>c</p>
    <p>@</p>
    <p>@</p>
    <p>...</p>
    <p>@ r a</p>
    <p>a</p>
    <p>@</p>
    <p>b ...</p>
    <p>@</p>
    <p>b c qr qa</p>
    <p>qa</p>
    <p>qb</p>
    <p>qb</p>
    <p>qc</p>
    <p>qfinal</p>
    <p>r  qr a  qa b  qb c  qc</p>
    <p>qr @ qa  qr qb @ qc  qc qr @ qc  qfinal</p>
  </div>
  <div class="page">
    <p>An example</p>
    <p>r</p>
    <p>a ... a b</p>
    <p>b</p>
    <p>c</p>
    <p>@</p>
    <p>@</p>
    <p>...</p>
    <p>@ r a</p>
    <p>a</p>
    <p>@</p>
    <p>b ...</p>
    <p>@</p>
    <p>b c qr qa</p>
    <p>qa</p>
    <p>qb</p>
    <p>qb</p>
    <p>qc</p>
    <p>qr</p>
    <p>... qr</p>
    <p>qc</p>
    <p>...</p>
    <p>qc</p>
    <p>qfinal</p>
    <p>r  qr a  qa b  qb c  qc</p>
    <p>qr @ qa  qr qb @ qc  qc qr @ qc  qfinal</p>
  </div>
  <div class="page">
    <p>An example</p>
    <p>r</p>
    <p>a ... a b</p>
    <p>b</p>
    <p>c</p>
    <p>@</p>
    <p>@</p>
    <p>...</p>
    <p>@ r a</p>
    <p>a</p>
    <p>@</p>
    <p>b ...</p>
    <p>@</p>
    <p>b c qr qa</p>
    <p>qa</p>
    <p>qb</p>
    <p>qb</p>
    <p>qc</p>
    <p>qr</p>
    <p>... qr</p>
    <p>qc</p>
    <p>...</p>
    <p>qc</p>
    <p>qfinal</p>
    <p>r  qr a  qa b  qb c  qc</p>
    <p>qr @ qa  qr qb @ qc  qc qr @ qc  qfinal</p>
  </div>
  <div class="page">
    <p>Contexts = trees with holes</p>
    <p>?</p>
    <p>@ ...</p>
    <p>@ @</p>
    <p>? 1 2</p>
    <p>n</p>
    <p>?</p>
    <p>n</p>
    <p>@ 0 @</p>
    <p>? @ 2</p>
    <p>... n</p>
    <p>Contexts can be parsed between two states: p C  q</p>
    <p>(accessibility of states and components are defined accordingly)</p>
  </div>
  <div class="page">
    <p>Contexts = trees with holes</p>
    <p>?</p>
    <p>?</p>
    <p>@ ...</p>
    <p>@ @</p>
    <p>? 1 2</p>
    <p>n</p>
    <p>?</p>
    <p>?</p>
    <p>n</p>
    <p>?</p>
    <p>@ 0 @</p>
    <p>? @ 2</p>
    <p>... n</p>
    <p>?</p>
    <p>Contexts can be parsed between two states: p C  q</p>
    <p>(accessibility of states and components are defined accordingly)</p>
  </div>
  <div class="page">
    <p>Contexts = trees with holes</p>
    <p>?</p>
    <p>?</p>
    <p>@ ...</p>
    <p>@ @</p>
    <p>? 1 2</p>
    <p>n</p>
    <p>?</p>
    <p>?</p>
    <p>n</p>
    <p>?</p>
    <p>@ 0 @</p>
    <p>? @ 2</p>
    <p>... n</p>
    <p>?</p>
    <p>Contexts can be parsed between two states: p C  q</p>
    <p>(accessibility of states and components are defined accordingly)</p>
  </div>
  <div class="page">
    <p>Recall: a run of a finite state automaton induces a chain of components...</p>
    <p>Likewise, a run of a stepwise automaton induces a synopsis tree (i.e. a tree of components).</p>
    <p>@</p>
    <p>@</p>
    <p>...</p>
    <p>@ r a</p>
    <p>a</p>
    <p>@</p>
    <p>b ...</p>
    <p>@</p>
    <p>b c qr qa</p>
    <p>qa</p>
    <p>qb</p>
    <p>qb</p>
    <p>qc</p>
    <p>qr</p>
    <p>... qr</p>
    <p>qc</p>
    <p>...</p>
    <p>qc</p>
    <p>qfinal</p>
    <p>@</p>
    <p>qfinal</p>
    <p>qr qc</p>
    <p>?@a b@?</p>
  </div>
  <div class="page">
    <p>Recall: a run of a finite state automaton induces a chain of components...</p>
    <p>Likewise, a run of a stepwise automaton induces a synopsis tree (i.e. a tree of components).</p>
    <p>@</p>
    <p>@</p>
    <p>...</p>
    <p>@ r a</p>
    <p>a</p>
    <p>@</p>
    <p>b ...</p>
    <p>@</p>
    <p>b c qr qa</p>
    <p>qa</p>
    <p>qb</p>
    <p>qb</p>
    <p>qc</p>
    <p>qr</p>
    <p>... qr</p>
    <p>qc</p>
    <p>...</p>
    <p>qc</p>
    <p>qfinal</p>
    <p>@</p>
    <p>qfinal</p>
    <p>qr qc</p>
    <p>?@a b@?</p>
  </div>
  <div class="page">
    <p>Characterization of bounded repairability of tree languages</p>
    <p>S is repairable into T with uniformly bounded cost</p>
    <p>Given some (trimmed) stepwise automata for S and T , all synopsis trees of S are covered by synopsis trees of T</p>
    <p>Source synopsis tree</p>
    <p>@</p>
    <p>@</p>
    <p>covered by</p>
    <p>Target synopsis tree</p>
    <p>@</p>
    <p>@</p>
    <p>i.e. ...</p>
  </div>
  <div class="page">
    <p>Characterization of bounded repairability of tree languages</p>
    <p>S is repairable into T with uniformly bounded cost</p>
    <p>Given some (trimmed) stepwise automata for S and T , all synopsis trees of S are covered by synopsis trees of T</p>
    <p>Source synopsis tree</p>
    <p>@</p>
    <p>@</p>
    <p>covered by</p>
    <p>Target synopsis tree</p>
    <p>@</p>
    <p>@</p>
    <p>i.e.   : cyclic components  cyclic components</p>
  </div>
  <div class="page">
    <p>Characterization of bounded repairability of tree languages</p>
    <p>S is repairable into T with uniformly bounded cost</p>
    <p>Given some (trimmed) stepwise automata for S and T , all synopsis trees of S are covered by synopsis trees of T</p>
    <p>Source synopsis tree</p>
    <p>@</p>
    <p>@</p>
    <p>covered by</p>
    <p>Target synopsis tree</p>
    <p>@</p>
    <p>@</p>
    <p>i.e.   : cyclic components  cyclic components</p>
  </div>
  <div class="page">
    <p>Characterization of bounded repairability of tree languages</p>
    <p>S is repairable into T with uniformly bounded cost</p>
    <p>Given some (trimmed) stepwise automata for S and T , all synopsis trees of S are covered by synopsis trees of T</p>
    <p>Source synopsis tree</p>
    <p>@</p>
    <p>@</p>
    <p>covered by</p>
    <p>Target synopsis tree</p>
    <p>@</p>
    <p>@</p>
    <p>i.e.   : cyclic components  cyclic components</p>
  </div>
  <div class="page">
    <p>Characterization of bounded repairability of tree languages</p>
    <p>S is repairable into T with uniformly bounded cost</p>
    <p>Given some (trimmed) stepwise automata for S and T , all synopsis trees of S are covered by synopsis trees of T</p>
    <p>Source synopsis tree</p>
    <p>@</p>
    <p>@</p>
    <p>covered by</p>
    <p>Target synopsis tree</p>
    <p>@</p>
    <p>@</p>
    <p>i.e.   : cyclic components  cyclic components</p>
  </div>
  <div class="page">
    <p>r</p>
    <p>a ...a d</p>
    <p>b ... b</p>
    <p>c .. . c</p>
    <p>r</p>
    <p>a ...a b .. . b c .. . c delete d</p>
    <p>@ ...</p>
    <p>@</p>
    <p>@</p>
    <p>@ ...</p>
    <p>@</p>
    <p>r</p>
    <p>a</p>
    <p>a @</p>
    <p>...</p>
    <p>@</p>
    <p>d</p>
    <p>b</p>
    <p>b</p>
    <p>c</p>
    <p>c</p>
    <p>@ ...</p>
    <p>@</p>
    <p>@ ...</p>
    <p>@</p>
    <p>@ ...</p>
    <p>@</p>
    <p>r</p>
    <p>a</p>
    <p>a</p>
    <p>b</p>
    <p>b</p>
    <p>c</p>
    <p>c</p>
  </div>
  <div class="page">
    <p>r</p>
    <p>a ...a d</p>
    <p>b ... b</p>
    <p>c .. . c</p>
    <p>r</p>
    <p>a ...a b .. . b c .. . c delete d</p>
    <p>@ ...</p>
    <p>@</p>
    <p>@</p>
    <p>@ ...</p>
    <p>@</p>
    <p>r</p>
    <p>a</p>
    <p>a @</p>
    <p>...</p>
    <p>@</p>
    <p>d</p>
    <p>b</p>
    <p>b</p>
    <p>c</p>
    <p>c</p>
    <p>@ ...</p>
    <p>@</p>
    <p>@ ...</p>
    <p>@</p>
    <p>@ ...</p>
    <p>@</p>
    <p>r</p>
    <p>a</p>
    <p>a</p>
    <p>b</p>
    <p>b</p>
    <p>c</p>
    <p>c</p>
  </div>
  <div class="page">
    <p>r</p>
    <p>a ...a d</p>
    <p>b ... b</p>
    <p>c .. . c</p>
    <p>r</p>
    <p>a ...a b .. . b c .. . c delete d</p>
    <p>@ ...</p>
    <p>@</p>
    <p>@</p>
    <p>@ ...</p>
    <p>@</p>
    <p>r</p>
    <p>a</p>
    <p>a @</p>
    <p>...</p>
    <p>@</p>
    <p>d</p>
    <p>b</p>
    <p>b</p>
    <p>c</p>
    <p>c</p>
    <p>@ ...</p>
    <p>@</p>
    <p>@ ...</p>
    <p>@</p>
    <p>@ ...</p>
    <p>@</p>
    <p>r</p>
    <p>a</p>
    <p>a</p>
    <p>b</p>
    <p>b</p>
    <p>c</p>
    <p>c</p>
  </div>
  <div class="page">
    <p>r</p>
    <p>a ...a d</p>
    <p>b ... b</p>
    <p>c .. . c</p>
    <p>r</p>
    <p>a ...a b .. . b c .. . c delete d</p>
    <p>@ ...</p>
    <p>@</p>
    <p>@</p>
    <p>@ ...</p>
    <p>@</p>
    <p>r</p>
    <p>a</p>
    <p>a @</p>
    <p>...</p>
    <p>@</p>
    <p>d</p>
    <p>b</p>
    <p>b</p>
    <p>c</p>
    <p>c</p>
    <p>@ ...</p>
    <p>@</p>
    <p>@ ...</p>
    <p>@</p>
    <p>@ ...</p>
    <p>@</p>
    <p>r</p>
    <p>a</p>
    <p>a</p>
    <p>b</p>
    <p>b</p>
    <p>c</p>
    <p>c</p>
    <p>C</p>
    <p>A B</p>
    <p>C</p>
    <p>A</p>
    <p>B</p>
  </div>
  <div class="page">
    <p>r</p>
    <p>a ...a d</p>
    <p>b ... b</p>
    <p>c .. . c</p>
    <p>r</p>
    <p>a ...a b .. . b c .. . c delete d</p>
    <p>@ ...</p>
    <p>@</p>
    <p>@</p>
    <p>@ ...</p>
    <p>@</p>
    <p>r</p>
    <p>a</p>
    <p>a @</p>
    <p>...</p>
    <p>@</p>
    <p>d</p>
    <p>b</p>
    <p>b</p>
    <p>c</p>
    <p>c</p>
    <p>@ ...</p>
    <p>@</p>
    <p>@ ...</p>
    <p>@</p>
    <p>@ ...</p>
    <p>@</p>
    <p>r</p>
    <p>a</p>
    <p>a</p>
    <p>b</p>
    <p>b</p>
    <p>c</p>
    <p>c</p>
    <p>C</p>
    <p>A B</p>
    <p>C</p>
    <p>A</p>
    <p>Bhorizontal</p>
    <p>horizontal</p>
  </div>
  <div class="page">
    <p>Some complexity results</p>
    <p>The bounded repairability problem is:</p>
    <p>for source/target stepwise automata</p>
    <p>(  some complexity gaps still remains...)</p>
  </div>
  <div class="page">
    <p>References...</p>
    <p>Regular repair of specifications Benedikt-Riveros-P.  LICS 2011</p>
    <p>The cost of traveling between languages Benedikt-Riveros-P.  ICALP 2011</p>
    <p>Bounded repairability for regular tree languages Riveros-Staworko-P.  ICDT 2012</p>
    <p>...and other related topics</p>
    <p>distance automata and limitedness problem</p>
    <p>repairability of trees in the streaming setting</p>
    <p>energy games with perfect/imperfect information</p>
    <p>normalized edit cost sup sS</p>
    <p>min tT</p>
    <p>dist(s,t)</p>
    <p>s</p>
  </div>
  <div class="page">
    <p>References...</p>
    <p>Regular repair of specifications Benedikt-Riveros-P.  LICS 2011</p>
    <p>The cost of traveling between languages Benedikt-Riveros-P.  ICALP 2011</p>
    <p>Bounded repairability for regular tree languages Riveros-Staworko-P.  ICDT 2012</p>
    <p>...and other related topics</p>
    <p>distance automata and limitedness problem</p>
    <p>repairability of trees in the streaming setting</p>
    <p>energy games with perfect/imperfect information</p>
    <p>normalized edit cost sup sS</p>
    <p>min tT</p>
    <p>dist(s,t)</p>
    <p>s</p>
  </div>
</Presentation>
