<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>COCO N: CORRECT-BY-CONSTRUCTION NETWORKS USING STEPWISE REFINEMENT Leonid Ryzhyk Nikolaj Bjorner Marco Canini Jean-Baptiste Jeannin Cole Schlesinger Douglas Terry George Varghese</p>
  </div>
  <div class="page">
    <p>RUNNING EXAMPLE: CAMPUS NETWORK</p>
    <p>subnet 1 subnet 2</p>
    <p>ACL</p>
    <p>core</p>
    <p>zone 1</p>
    <p>zone 2</p>
    <p>zone 3</p>
  </div>
  <div class="page">
    <p>RUNNING EXAMPLE: CAMPUS NETWORK</p>
    <p>subnet 1</p>
    <p>subnet 2</p>
    <p>subnet 1 gateway router</p>
    <p>subnet 2 gateway router</p>
    <p>switch router (not assigned to a subnet)</p>
    <p>zone 1</p>
    <p>zone 2</p>
    <p>zone 3</p>
    <p>core</p>
  </div>
  <div class="page">
    <p>NETWORK VERIFICATION: CURRENT PRACTICES</p>
    <p>SDN app</p>
    <p>Option 1: Dataplane verification (NetPlumber, HSA, Veriflow)</p>
    <p>Fixing bugs in a deployed network takes time; may not avoid the downtime</p>
    <p>Check for: Loop freedom Black holes Reachability Isolation</p>
    <p>Option 2: Controller verification (Vericon, FlowLog)</p>
    <p>Limited scalability</p>
    <p>Common to both approaches:</p>
    <p>Property-based verification does not guarantee correctness</p>
    <p>OpenFlow</p>
  </div>
  <div class="page">
    <p>NETWORK VERIFICATION IN A NUTSHELL</p>
    <p>Big switch abstraction</p>
    <p>~ Option 1: Dataplane verification (NetKAT)</p>
    <p>Limited scalability</p>
  </div>
  <div class="page">
    <p>REQUIREMENTS</p>
    <p>State of the art: pick 1 out of 3</p>
    <p>Ideally, network verification should be:</p>
  </div>
  <div class="page">
    <p>OBSERVATIONS</p>
    <p>subnet 1 subnet 2</p>
    <p>ACL</p>
    <p>core</p>
    <p>zone 1</p>
    <p>zone 2</p>
    <p>zone 3</p>
    <p>Simple top-level description: the what, not the how</p>
    <p>Design by hierarchical decomposition</p>
    <p>Top-level spec</p>
    <p>Refinement 1 Refinement 2</p>
    <p>Refinement 3</p>
  </div>
  <div class="page">
    <p>DECOMPOSING A WAN</p>
    <p>Internet Data center 1</p>
    <p>Data center 2 switch WAN router</p>
    <p>WAN link local link</p>
    <p>DC3</p>
    <p>Local fabric</p>
    <p>Global fabric</p>
    <p>ToR layer</p>
    <p>Core layer</p>
    <p>Local fabric</p>
  </div>
  <div class="page">
    <p>MORE EXAMPLES</p>
    <p>Virtual network is decomposed into</p>
    <p>Physical fabric</p>
    <p>Virtual fabric</p>
    <p>Cellular network is decomposed into</p>
    <p>Edge (base stations)</p>
    <p>Core</p>
    <p>Internet gateway</p>
    <p>Exposing this structure enables efficient compositional verification</p>
  </div>
  <div class="page">
    <p>COCO N: COrrect by COnstruction Networking</p>
    <p>refine</p>
    <p>implementation</p>
    <p>refine refine</p>
    <p>spec Correct by construction</p>
    <p>We propose Cocoon: SDN design method Programming language Verifier</p>
    <p>Cocoon achieves scalable, static, exhaustive verification (3 out of 3!) via a network design process that focuses on correctness.</p>
    <p>SDN controller</p>
  </div>
  <div class="page">
    <p>EXAMPLE COCOON SPECIFICATIONS</p>
    <p>role HostOut[IP4 addr] | cHost(addr) = filter ip2subnet(pkt.srcIP)==ip2subnet(pkt.dstIP)</p>
    <p>or acl(pkt); filter cHost(pkt.dstIP); send HostIn[pkt.dstIP]</p>
    <p>function cHost(IP4 addr): bool function cSubnet(vid_t vid): bool function acl(Packet p): bool function ip2subnet(IP4 ip): vid_t</p>
    <p>subnet 1 subnet 2</p>
    <p>ACL</p>
    <p>assume(IP4 addr) cHost(addr)=&gt;cSubnet(ip2subnet(addr))</p>
    <p>Assumption:</p>
    <p>Runtime-Defined Functions (RDFs) Must return valid subnet ID</p>
    <p>cHost(addr) = addr=={172.30.0.21}|| addr=={172.30.0.22}|| ...</p>
    <p>cHost(addr) = addr=={172.30.0.21}|| addr=={172.30.0.22}|| ...</p>
    <p>ip2subnet(ip) = 172.30.*.* subnet1 172.20.*.* subnet2 ...</p>
    <p>ip2subnet(ip) = 172.30.*.* subnet1 172.20.*.* subnet2 ...</p>
  </div>
  <div class="page">
    <p>REFINEMENT EXAMPLE</p>
    <p>role HostOut[IP4 addr] | cHost(addr) = filter ip2subnet(pkt.srcIP)==ip2subnet(pkt.dstIP)</p>
    <p>or acl(pkt); filter cHost(pkt.dstIP); send HostIn[pkt.dstIP]</p>
    <p>refine HostOut { role HostOut[IP4 addr] | cHost(addr) = ... send RouterZoneIn[zone(addr)]</p>
    <p>role RouterZoneIn[zid_t] = ... ... }</p>
    <p>subnet 1 subnet 2</p>
    <p>ACL</p>
    <p>core</p>
    <p>zone 1</p>
    <p>zone 2</p>
    <p>zone 3</p>
  </div>
  <div class="page">
    <p>Refinements + assumptions specify static network design</p>
    <p>Verified statically</p>
    <p>RDFs encapsulate runtime configuration</p>
    <p>Checked at runtime against assumptions</p>
  </div>
  <div class="page">
    <p>COCOON ARCHITECTURE</p>
    <p>verifier</p>
    <p>compiler</p>
    <p>assumption checker</p>
    <p>Cocoon spec</p>
    <p>OpenFlow/P4</p>
    <p>Cocoon runtimeexternal apps</p>
    <p>SDN controller</p>
    <p>R D</p>
    <p>F</p>
    <p>d e fi n it</p>
    <p>io n s</p>
  </div>
  <div class="page">
    <p>IMPLEMENTING VERIFICATION</p>
    <p>Role semantics:</p>
    <p>Role refinement:</p>
    <p>We convert this program to Boogie and use the Corral model checker</p>
    <p>Enforce static bound on the number of network hops to achieve completeness</p>
    <p>Assumptions are converted to SMT and checked using Z3</p>
  </div>
  <div class="page">
    <p>CASE STUDIES</p>
    <p>B4-style WAN [Jain et al. B4: Experience with a Globally-Deployed Software Defined WAN]</p>
    <p>NSX-style network virtualization framework [Koponen et al. Network Virtualization in Multi-tenant Datacenters]</p>
    <p>Enterprise network [Sung et al. Towards Systematic Design of Enterprise Networks]</p>
    <p>F10 [Liu et al. F10: A Fault-Tolerant Engineered Network]</p>
    <p>Stag [Lopes et al. Automatically verifying reachability and wellformedness in P4 Networks]</p>
    <p>iSDX [Gupta et al. An Industrial-Scale Software Defined Internet Exchange Point]</p>
  </div>
  <div class="page">
    <p>PERFORMANCE (static verification)</p>
    <p>Compositional:</p>
    <p>Monolithic:</p>
  </div>
  <div class="page">
    <p>PERFORMANCE (runtime verification)</p>
  </div>
  <div class="page">
    <p>subnet 1</p>
    <p>subnet 2</p>
    <p>subnet 1 gateway router</p>
    <p>subnet 2 gateway router</p>
    <p>switch router (not assigned to a subnet)</p>
    <p>zone 1</p>
    <p>zone 2</p>
    <p>zone 3</p>
    <p>core</p>
    <p>COCOON VS TRADITIONAL NETWORK VERIFICATION</p>
    <p>HSA/ Veriflow/ ...</p>
    <p>Correctness spec</p>
    <p>subnet 1 subnet 2</p>
    <p>security policy</p>
  </div>
  <div class="page">
    <p>PERFORMANCE (Cocoon + HSA)</p>
  </div>
  <div class="page">
    <p>CONCLUSION</p>
    <p>Design-by-refinement works well for networks:</p>
    <p>Allow concise high-level specifications</p>
    <p>Well-defined module boundaries</p>
    <p>Verification is feasible for a single refinement: no pointers, concurrency, dynamic memory allocation, etc.</p>
    <p>Source code, case studies:</p>
    <p>https://github.com/ryzhyk/cocoon</p>
    <p>Design-by-refinement works well for networks:</p>
    <p>Allow concise high-level specifications</p>
    <p>Well-defined module boundaries</p>
    <p>Verification is feasible for a single refinement: no pointers, concurrency, dynamic memory allocation, etc.</p>
  </div>
</Presentation>
