<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Compiling Path Queries Princeton University</p>
    <p>Mina Tahmasbi Jen Rexford David WalkerSrinivas Narayana</p>
  </div>
  <div class="page">
    <p>Management = Measure + Control</p>
    <p>Network Controller</p>
    <p>Measure Control Software-Defined Networking (SDN)</p>
  </div>
  <div class="page">
    <p>Enabling Easier Measurement Matters Networks are asked to do a lot! Partition-aggregate applications Growth in traffic demands Stringent performance requirements Avoid expensive outages</p>
    <p>Difficult to know where things go wrong! Humans are slow in troubleshooting Human time is expensive</p>
    <p>Can we build programmatic tools to help?</p>
  </div>
  <div class="page">
    <p>Example: Wheres the Packet Loss?</p>
    <p>A B</p>
    <p>Suspect: Faulty network device(s) along the way.</p>
  </div>
  <div class="page">
    <p>A B</p>
    <p>Idea: Follow the path of packets through the network.</p>
    <p>Example: Wheres the Packet Loss?</p>
    <p>Switch ACL counters</p>
    <p>ip.src==a &amp; ip.dst==b</p>
    <p>ip.src==a &amp; ip.dst==b</p>
    <p>ip.src==a &amp; ip.dst==b  count ip.dst==b  fwd port 2</p>
    <p>Packet rewrite</p>
    <p>NetFlow Sampling Inaccuracy</p>
  </div>
  <div class="page">
    <p>Example: Wheres the Packet Loss?</p>
    <p>Complex &amp; Inaccurate Join with multiple</p>
    <p>datasets: traffic, forwarding, topology</p>
    <p>High Overhead of collecting</p>
    <p>(unnecessary) data to answer a given</p>
    <p>question</p>
  </div>
  <div class="page">
    <p>Example: Wheres the Packet Loss?</p>
    <p>Complex &amp; Inaccurate Join with multiple</p>
    <p>datasets: traffic, forwarding, topology</p>
    <p>High Overhead of collecting</p>
    <p>(unnecessary) data to answer a given</p>
    <p>question</p>
  </div>
  <div class="page">
    <p>Pattern: Combining Traffic &amp; Forwarding Traffic matrix Uneven load balancing DDoS source identification Port-level traffic matrix Congested link diagnosis Slice isolation Loop detection Middlebox traversal order  Incorrect NAT rewrite Firewall evasion  ...</p>
    <p>Resource management Policy enforcement Problem diagnosis</p>
  </div>
  <div class="page">
    <p>Our Approach</p>
    <p>Declarative Query Specification Query-Driven Measurement</p>
    <p>Path Query System</p>
    <p>Independent of Forwarding Independent of Other Measurements Independent of Hardware Details</p>
    <p>Accurate Answers Pay Exactly For What You Query</p>
    <p>Commodity (Match-Action) Hardware</p>
    <p>Path Query Language Query Run-Time System</p>
  </div>
  <div class="page">
    <p>Our Approach</p>
    <p>SDN controller Payloads</p>
    <p>Statistics</p>
    <p>Query Expressions StatisticsForwarding</p>
  </div>
  <div class="page">
    <p>How to design general measurement primitives</p>
    <p>that are efficiently implemented in the network?</p>
  </div>
  <div class="page">
    <p>Measurement Use Cases Traffic matrix Uneven load balancing DDoS source identification Port-level traffic matrix Congested link diagnosis Slice isolation Loop detection Middlebox traversal order  Incorrect NAT rewrite Firewall evasion  ...</p>
    <p>What are the common patterns?</p>
  </div>
  <div class="page">
    <p>(I) Path Query Language Test predicates on packets at single locations:</p>
    <p>srcip=10.0.0.1 port=3 &amp; dstip=10.0.1.10</p>
    <p>Combine tests with regular expression operators! sw=1 ^ sw=4 srcip=A ^ true* ^ sw=3 ingress() ^ ~(sw=firewall)* ^ egress()</p>
    <p>ingress egress</p>
    <p>ingress</p>
    <p>ingress egress</p>
    <p>egress</p>
  </div>
  <div class="page">
    <p>(I) Path Query Language Aggregate results with SQL-like grouping operators</p>
    <p>in_group(ingress(), [sw]) ^ true* ^ out_group(egress(), [sw])</p>
    <p>Return packets, counters, or samples (NetFlow/sFlow)</p>
    <p>ingress() switch #pkts</p>
    <p>S1 1000 S2 500 S5 700 ... ...</p>
    <p>(ingress(), egress()) switch pairs</p>
    <p>#pkts</p>
    <p>(S1, S2) 800 (S1, S5) 200 (S2, S5) 300 ... ...</p>
  </div>
  <div class="page">
    <p>Language: More examples in paper...</p>
  </div>
  <div class="page">
    <p>How do we implement path queries efficiently?</p>
    <p>In general, switches dont know prior or future packet paths.</p>
  </div>
  <div class="page">
    <p>How to observe packet paths? Analyze packet paths in the data plane itself Write path information into packets!</p>
    <p>Pros: accurate trajectory information J Cons: too much per-packet information L</p>
    <p>[{sw: S1 port: 1 srcmac: ... srcip: ... ...}]</p>
    <p>[{sw: S1, ...}, {sw: S2 port: 3 srcmac: ... ...}]</p>
    <p>[{sw: S1, ...}, {sw: S2, ...}, {sw: S3 port: 2 ...}]</p>
  </div>
  <div class="page">
    <p>Reducing Path Information on Packets Observation 1: Queries already tell us whats needed! Only record path state needed by queries</p>
    <p>Observation 2: Queries are regular expressions Regular expressions  Finite automaton (DFA) Distinguish only paths corresponding to DFA states</p>
  </div>
  <div class="page">
    <p>Reducing Path Information on Packets</p>
    <p>Record only DFA state on packets (1-2 bytes)</p>
    <p>Use existing tag fields! (e.g., VLAN)</p>
  </div>
  <div class="page">
    <p>(II) Query Run-Time System (sw=1 &amp; srcip=A)  (sw=4 &amp; dstip=B)</p>
    <p>Q0 Q1 sw=1 &amp; srcip=A</p>
    <p>sw=4 &amp; dstip=B</p>
    <p>Q2</p>
    <p>Switch 1: state=Q0 &amp; srcip=A</p>
    <p>state=Q1</p>
    <p>Switch 4: state=Q1 &amp; dstip=B</p>
    <p>state=Q2 AND count!</p>
  </div>
  <div class="page">
    <p>(II) Query Run-Time System Each packet carries its own DFA state</p>
    <p>Query DFA transitions distributed to switches  as match-action rules!</p>
    <p>Packet satisfies query iff it reaches accepting states  Pay for what you query</p>
  </div>
  <div class="page">
    <p>(II) Run-Time: Juicy details in paper Packet forwarding shouldn't be affected by DFA rules No unnecessary duplicate traffic should be created</p>
    <p>Handle query overlap Predicates can also overlap</p>
    <p>Handle groupby aggregation</p>
    <p>Capture upstream or downstream of queried path Test predicates before or after forwarding on switch</p>
    <p>Optimizations: to make the system practical 22</p>
    <p>srcip=A  dstip=B sw=1 ^ true* ^ sw=4</p>
  </div>
  <div class="page">
    <p>Evaluation Prototype on Pyretic + NetKAT + OpenVSwitch Publicly available: http://frenetic-lang.org/pyretic/</p>
    <p>Queries: traffic matrix, DDoS detection, per-hop packet loss, firewall evasion, slice isolation, congested link</p>
    <p>Results on Stanford backbone (all queries together): Compile time: 5 seconds (from &gt; 2 hours) # Rules: ~ 650 # State bytes: 2 bytes</p>
  </div>
  <div class="page">
    <p>Evaluation: Scaling</p>
    <p>Interactive problem solving (~ 15s)</p>
  </div>
  <div class="page">
    <p>Summary We need good abstractions to measure networks Abstractions must be efficiently implementable</p>
    <p>We implemented declarative queries on packet paths: Packet state akin to a deterministic automaton</p>
    <p>Path queries can simplify network management!</p>
    <p>Queries? J</p>
    <p>http://www.cs.princeton.edu/~narayana/pathqueries https://youtu.be/VxOaN9iGPWc</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>(I) Language: Related Work</p>
    <p>Primitive Description Prior Work Our Extensions</p>
    <p>Atomic Predicates Boolean tests on located packets</p>
    <p>[Foster11] [Monsanto13]</p>
    <p>Switch input and output differentiation</p>
    <p>Packet Trajectories Regular expressions on atomic predicates</p>
    <p>[Tarjan79], [Handigol14]</p>
    <p>Additional regex operators (&amp;, ~)</p>
    <p>ResultAggregation Group results by location or header fields</p>
    <p>SQL groupby, [Foster11]</p>
    <p>Group anywhere along a path</p>
    <p>Capture Location Get packets before or after queried path</p>
    <p>-- N/A</p>
    <p>Capture Result Actions on packets satisfying queries</p>
    <p>[Monsanto13] Sampling (sFlow)</p>
  </div>
  <div class="page">
    <p>(I) Capture locations Capture upstream, downstream or midstream</p>
    <p>Packet flow on query path</p>
    <p>Upstream DownstreamMidstream</p>
  </div>
  <div class="page">
    <p>(II) Run-Time: Data Plane Rule Layout</p>
    <p>state=Q_i &amp; pred: state  Q_j AND</p>
    <p>in_capture forwarding state=Q_i &amp; pred: state  Q_j AND</p>
    <p>out_capture</p>
    <p>In table &gt;&gt; Forwarding &gt;&gt; Out table</p>
  </div>
  <div class="page">
    <p>(II) Query Compilation</p>
    <p>All acting on the same data plane packets!</p>
    <p>Use policy composition operators and compiler</p>
    <p>DFA- Transitioning</p>
    <p>Forwarding DFA- Accepting</p>
    <p>&gt;&gt; +)(</p>
    <p>Composing software-defined networks. Monsanto et al., 2013</p>
  </div>
  <div class="page">
    <p>(II) Query Compilation</p>
    <p>DFA- Transitioning</p>
    <p>Forwarding DFA- Accepting</p>
    <p>&gt;&gt; +)(</p>
    <p>state=Q0 &amp; switch=S1 &amp; srcip=10.0.0.1  stateQ1</p>
    <p>state=Q1 &amp; switch=S2 &amp; dstip=10.0.0.3  stateQ2</p>
    <p>dstip=10.0.0.1  fwd(1)</p>
    <p>dstip=10.0.0.2  fwd(2)</p>
    <p>dstip=10.0.0.3  fwd(3) ...</p>
    <p>&gt;&gt;</p>
    <p>state=Q0 &amp; switch=S1 &amp; srcip=10.0.0.1 &amp; dstip=10.0.0.2  stateQ1, fwd(2)</p>
    <p>Composing software-defined networks. Monsanto et al., 2013</p>
  </div>
  <div class="page">
    <p>(II) Query Compilation</p>
    <p>(DFA-Ingress-Transitioning &gt;&gt; Forwarding &gt;&gt; DFA-Egress-Transitioning) + (DFA-Ingress-Accepting) + (DFA-Ingress-Transitioning &gt;&gt; Forwarding &gt;&gt; DFA-Egress-Accepting)</p>
  </div>
  <div class="page">
    <p>(II) Detecting Query Overlaps Predicate overlaps: q1: srcip=10.0.0.1; q2: dstip=10.0.0.2 Automaton can only have one state!</p>
    <p>Query overlaps: q1: sw=1 ^ sw=2 q2: srcip=10.0.0.1 ^ dstip=10.0.0.2</p>
    <p>q1: in_atom(srcip=10.0.0.1) q2: out_atom(srcip=10.0.0.1)</p>
    <p>Automaton states must distinguish all possibilities! 33</p>
  </div>
  <div class="page">
    <p>(II) Detecting Query Overlaps Predicate overlaps: Generate orthogonal predicates! q1: srcip=10.0.0.1; q2: dstip=10.0.0.2</p>
    <p>Generated predicates:  srcip=10.0.0.1 &amp; dstip=10.0.0.2  srcip=10.0.0.1 &amp; ~dstip=10.0.0.2  ~srcip=10.0.0.1 &amp; dstip=10.0.0.2</p>
  </div>
  <div class="page">
    <p>(II) Detecting Query Overlaps Query Overlaps:</p>
    <p>Convert in_ and out_ atoms to in_out_atoms:</p>
    <p>in_atom(srcip=10.0.0.1)  in_out_atom( srcip=10.0.0.1, true)</p>
    <p>out_atom(dstip=10.0.0.1)  in_out_atom(true, dstip=10.0.0.1)</p>
  </div>
  <div class="page">
    <p>(II) Detecting Query Overlaps Query Overlaps:</p>
    <p>Build one DFA for many expressions together  in_atom(srcip=H1 &amp; sw=1) ^ out_atom(sw=2 &amp; dstip=H2)  in_atom(sw=1) ^ in_out_atom(true, sw=2)</p>
    <p>Q0 a Q5Q1</p>
    <p>[ceg] Q2 Q3 c</p>
    <p>Q8 [ce]</p>
    <p>Q6 Q7 Q4 [ceg]</p>
    <p>d</p>
    <p>[adf]</p>
    <p>[adf] e</p>
  </div>
  <div class="page">
    <p>Optimizations: Summary</p>
    <p>Optimization # Rules? Time? # States?</p>
    <p>Separate query &amp; forwarding actions into separate stages Optimize conditional policy compilation Integrate tagging and capture policies Pre-partition predicates by flow space Cache predicate overlap decisions Decompose query predicates into multiple stages Detect predicate overlaps with Forwarding Decision Diagrams</p>
  </div>
  <div class="page">
    <p>Benefit of Optimizations (Stanford)</p>
    <p>Cumulative Optimization Time (s) # Rules # State Bits None &gt; 7900 DNF DNF</p>
    <p>Separate query &amp; forwarding actions into separate stages</p>
    <p>&gt; 4920 DNF DNF</p>
    <p>Optimize conditional policy compilation</p>
    <p>&gt; 4080 DNF DNF</p>
    <p>Integrate tagging and capture policies</p>
    <p>Pre-partition predicates by flow space</p>
    <p>Cache predicate overlap decisions</p>
    <p>Decompose query predicates into multiple stages</p>
  </div>
  <div class="page">
    <p>A B</p>
    <p>Demo: Wheres the Packet Loss?</p>
  </div>
  <div class="page">
    <p>Demo: Wheres the Packet Loss?</p>
    <p>https://youtu.be/VxOaN9iGPWc</p>
  </div>
  <div class="page">
    <p>Downstream Query Compilation (3/3)</p>
    <p>All acting on the same data plane packets!</p>
    <p>Use policy composition operators and compiler</p>
    <p>DFA- Transitioning</p>
    <p>Forwarding DFA- Accepting</p>
    <p>&gt;&gt; +)(</p>
    <p>Composing software-defined networks. Monsanto et al., 2013</p>
  </div>
  <div class="page">
    <p>Downstream Query Compilation (3/3)</p>
    <p>DFA- Transitioning</p>
    <p>Forwarding DFA- Accepting</p>
    <p>&gt;&gt; +)(</p>
    <p>state=Q0 &amp; switch=S1 &amp; srcip=10.0.0.1  stateQ1</p>
    <p>state=Q1 &amp; switch=S2 &amp; dstip=10.0.0.3  stateQ2</p>
    <p>dstip=10.0.0.1  fwd(1)</p>
    <p>dstip=10.0.0.2  fwd(2)</p>
    <p>dstip=10.0.0.3  fwd(3) ...</p>
    <p>&gt;&gt;</p>
    <p>state=Q0 &amp; switch=S1 &amp; srcip=10.0.0.1 &amp; dstip=10.0.0.2  stateQ1, fwd(2)</p>
    <p>Composing software-defined networks. Monsanto et al., 2013</p>
  </div>
  <div class="page">
    <p>Downstream Query Compilation (3/3)</p>
    <p>(DFA-Ingress-Transitioning &gt;&gt; Forwarding &gt;&gt; DFA-Egress-Transitioning) + (DFA-Ingress-Accepting) + (DFA-Ingress-Transitioning &gt;&gt; Forwarding &gt;&gt; DFA-Egress-Accepting)</p>
  </div>
  <div class="page">
    <p>II. Rule Count</p>
    <p>Switch TCAM capacity: 2K-4K rules</p>
  </div>
  <div class="page">
    <p>III. Packet State Bits</p>
    <p>VLAN</p>
    <p>MPLS</p>
  </div>
</Presentation>
