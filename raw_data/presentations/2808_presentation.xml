<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>FlowBlaze Stateful Packet Processing in Hardware</p>
    <p>Salvatore Pontarelli, Roberto Bifulco, Marco Bonola, Carmelo Cascone, Marco Spaziani, Valerio Bruschi, Davide Sanvito, Giuseppe Siracusano,</p>
    <p>Antonio Capone, Michio Honda, Felipe Huici, Giuseppe Bianchi</p>
  </div>
  <div class="page">
    <p>*Now at ONF</p>
    <p>This work has received funding from the European Unions Horizon 2020 research and innovation programme under grant agreements No 761493 (5GTANGO) and No.762057 (5G-PICTURE)</p>
  </div>
  <div class="page">
    <p>Roberto State</p>
    <p>Machines</p>
  </div>
  <div class="page">
    <p>State Machines</p>
    <p>Kinetic, NSDI15</p>
  </div>
  <div class="page">
    <p>Programmable NICs</p>
    <p>NetFPGA SUME</p>
    <p>Simulate Synthesis</p>
    <p>Network Function Logic</p>
    <p>Code</p>
    <p>NICs with programmable ASICs, SoC, FPGAs E.g., Microsoft [AccelNet NSDI 17, NSDI 18]</p>
    <p>Programming them is Hard!</p>
  </div>
  <div class="page">
    <p>Making programming easier</p>
    <p>NF Logic Code</p>
    <p>Simulation Synthesis</p>
    <p>High-level Synthesis</p>
    <p>Faster programming Expressive</p>
    <p>Hardware expertise</p>
    <p>Match-Action Abstraction</p>
    <p>Faster programming NF Logic focused</p>
    <p>Limited support for state</p>
    <p>ClickNP [Sigcomm 16], Emu [ATC 17]</p>
    <p>P4 [CCR 14], Domino [Sigcomm 16]</p>
  </div>
  <div class="page">
    <p>Match-Action Abstraction Limitations</p>
    <p>Match-Action pipeline</p>
    <p>State in tables</p>
    <p>large</p>
    <p>read only (wr from cplane)</p>
    <p>State in registers</p>
    <p>small</p>
    <p>read/write</p>
  </div>
  <div class="page">
    <p>Extending Match-Action abstractions</p>
    <p>Match-Action pipeline</p>
    <p>FlowBlaze</p>
  </div>
  <div class="page">
    <p>Match-Action vs Finite State Machine (FSM)</p>
    <p>if match then action</p>
    <p>if (match, state) then action</p>
    <p>a table represented by</p>
    <p>a table</p>
    <p>P k</p>
    <p>t h</p>
    <p>e a</p>
    <p>d e</p>
    <p>rs ,</p>
    <p>m e</p>
    <p>ta d</p>
    <p>a ta</p>
    <p>Table</p>
    <p>ALUs</p>
    <p>Global State</p>
    <p>if m</p>
    <p>a t c h</p>
    <p>P k</p>
    <p>t h</p>
    <p>e a</p>
    <p>d e</p>
    <p>rs ,</p>
    <p>m e</p>
    <p>ta d</p>
    <p>a ta</p>
    <p>Table</p>
    <p>ALUs</p>
    <p>Global State</p>
    <p>if m</p>
    <p>a t c h</p>
    <p>if state</p>
  </div>
  <div class="page">
    <p>Multiple state machines?</p>
    <p>Example: Drop a flow after its 10th packet</p>
    <p>S B</p>
    <p>Any pkt, c=10  drop</p>
    <p>Any pkt  c=c+1, fwd Any pkt  drop</p>
    <p>Flow ID State</p>
    <p>IPdst = 192.168.0.1 S</p>
    <p>IPdst = 192.168.0.2 S</p>
    <p>IPdst = 192.168.0.3 B</p>
    <p>Per-flow state is common in network functions</p>
    <p>Each flows FSM evolves on its own</p>
  </div>
  <div class="page">
    <p>Introducing per-flow state P</p>
    <p>k t</p>
    <p>h e</p>
    <p>a d</p>
    <p>e rs</p>
    <p>, m</p>
    <p>e ta</p>
    <p>d a</p>
    <p>ta</p>
    <p>Flow Ctx</p>
    <p>Table</p>
    <p>Flow State</p>
    <p>Table</p>
    <p>ALUs</p>
    <p>Global State</p>
    <p>if m</p>
    <p>a t c h</p>
    <p>if s</p>
    <p>t a t e</p>
    <p>Flow ID (IP dst)</p>
    <p>State Register</p>
    <p>Pkt Header</p>
    <p>State Cond. Action</p>
    <p>* B * drop</p>
    <p>* S c=10 State=B, drop</p>
    <p>* S c&lt;10 fwd</p>
  </div>
  <div class="page">
    <p>Implementation issues</p>
    <p>Insertion in the flow context table</p>
    <p>Variable insertion time</p>
    <p>Insertion = new flow</p>
    <p>Cuckoo hash table</p>
  </div>
  <div class="page">
    <p>Implementation issues</p>
    <p>Insertion in the flow context table</p>
    <p>Variable insertion time</p>
    <p>Insertion = new flow</p>
    <p>Cuckoo hash table</p>
  </div>
  <div class="page">
    <p>Handling variable insertion time</p>
    <p>Flow table: Cuckoo hash</p>
    <p>Constant lookup-time</p>
    <p>Efficient</p>
    <p>Variable insertion-time</p>
    <p>P P P P</p>
    <p>Waiting for Insertion!!</p>
    <p>Throughput reduction</p>
    <p>Latency increase</p>
  </div>
  <div class="page">
    <p>Flow context insertion handling</p>
    <p>Flow Ctx</p>
    <p>Table</p>
    <p>Flow State</p>
    <p>P P P P</p>
    <p>Cuckoo hash table</p>
    <p>Stash</p>
    <p>insertion time scales with</p>
    <p>flow arrival rate</p>
    <p>lookup time scales with</p>
    <p>pkt arrival rate</p>
    <p>insertion logic in hardware r</p>
    <p>e a d</p>
    <p>l o</p>
    <p>g ic</p>
    <p>lookup insertion</p>
    <p>Fast insertion</p>
    <p>Variable Insertion</p>
    <p>speed</p>
    <p>Fast lookup</p>
  </div>
  <div class="page">
    <p>Implementation issues</p>
    <p>Insertion in the flow context table</p>
    <p>Variable insertion time</p>
    <p>Insertion = new flow</p>
    <p>Cuckoo hash table</p>
    <p>State update latency</p>
    <p>Feedback loop Race conditions</p>
  </div>
  <div class="page">
    <p>Avoiding race conditions</p>
    <p>c=9 c=9</p>
    <p>c10</p>
    <p>c=10</p>
    <p>P P P P</p>
    <p>inconsistent state</p>
  </div>
  <div class="page">
    <p>Avoiding race conditions</p>
    <p>P P P P</p>
    <p>c=9</p>
    <p>c10</p>
    <p>Throughput reduction</p>
    <p>Latency increase</p>
    <p>s c h</p>
    <p>e d</p>
    <p>u le</p>
    <p>r</p>
    <p>c=10</p>
  </div>
  <div class="page">
    <p>Avoiding race conditions</p>
    <p>P P P P</p>
    <p>c=9</p>
    <p>c=4</p>
    <p>c=7</p>
    <p>s c h</p>
    <p>e d</p>
    <p>u le</p>
    <p>r Lock pipeline</p>
    <p>for packets from the</p>
    <p>same flow</p>
    <p>Performance degradation only in unlikely cases</p>
  </div>
  <div class="page">
    <p>Implementation issues</p>
    <p>Insertion in the flow context table</p>
    <p>State update latency</p>
    <p>Variable insertion time</p>
    <p>Insertion = new flow</p>
    <p>Cuckoo hash table</p>
    <p>Feedback loop Race conditions</p>
  </div>
  <div class="page">
    <p>Does it work?</p>
    <p>FlowBlaze provides the same performance for all use cases</p>
    <p>FlowBlaze VPP (1 core) VPP (2 core) VPP (3 core)</p>
    <p>Stateless UDP Stateful Firewall</p>
    <p>T p u t</p>
    <p>( M</p>
    <p>p p s )</p>
  </div>
  <div class="page">
    <p>Stress test</p>
    <p>Test: 40Gb/s@64B (NetFPGA line rate)</p>
    <p>Flow distributions</p>
    <p>UNI1 UNI2 MAWI CHI15</p>
    <p>Global IP s IP s/d 5 tuple</p>
    <p>D ro</p>
    <p>p r</p>
    <p>a te</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>FlowBlaze</p>
    <p>FSM Abstraction for packet processing</p>
    <p>Efficient FPGA implementation</p>
    <p>Benefits</p>
    <p>Can keep state for 100Ks flows in flow tables</p>
    <p>Save several CPU cores for stateful NFs</p>
    <p>Power efficient (check the paper!)</p>
    <p>Low latency (check the paper!)</p>
    <p>Check the paper, theres a lot more!</p>
  </div>
  <div class="page">
    <p>FlowBlaze is open</p>
    <p>https://github.com/axbryd/FlowBlaze</p>
    <p>maintained by</p>
    <p>Both software and hardware implementations</p>
    <p>Thank you! visit us and check our demo</p>
    <p>at the poster session</p>
  </div>
  <div class="page"/>
</Presentation>
