<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>BooM: A Decision Procedure for Boolean Matching with A bstraction &amp; Dynamic Learni</p>
    <p>ng</p>
    <p>Chih-Fan Lai1, J.-H. Roland Jiang1, and</p>
    <p>Kuo-Hua Wang2</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Introduction to Boolean matching</p>
    <p>Our formulation and solution</p>
    <p>Experimental evaluation</p>
    <p>Conclusions and future work</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Combinational equivalen ce checking (CEC)  Known input corresponden</p>
    <p>ce  coNP-complete  Well solved in practical</p>
    <p>applications</p>
    <p>x1 x2 xn</p>
    <p>f g</p>
    <p>y1 y2 yn</p>
  </div>
  <div class="page">
    <p>Introduction  Boolean matching</p>
    <p>P-equivalence  Unknown input permutation  O(n!) CEC iterations</p>
    <p>NP-equivalence  Unknown input negation and</p>
    <p>permutation  O(2nn!) CEC iterations</p>
    <p>NPN-equivalence  Unknown input negation, in</p>
    <p>put permutation, and outpu t negation</p>
    <p>O(2n+1n!) CEC iterations</p>
    <p>x1 x2 xn</p>
    <p>f g</p>
    <p>y1 y2 yn</p>
    <p>P N</p>
    <p>N</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Example</p>
    <p>y1 y2 y3</p>
    <p>g</p>
    <p>x1 x2 x3</p>
    <p>f</p>
    <p>x1 x2 x3</p>
    <p>=</p>
  </div>
  <div class="page">
    <p>Introduction  Motivations</p>
    <p>Theoretically  Complexity in between</p>
    <p>coNP (for all ) and 2 (there exists  for all ) in the Polynomial Hierarchy (PH)</p>
    <p>Special candidate to test PH collapse  Known as Boolean congruence/isomorphism dating b</p>
    <p>ack to the 19th century</p>
    <p>Practically  Broad applications</p>
    <p>Library binding  FPGA technology mapping  Detection of generalized symmetry  Logic verification  Design debugging/rectification  Functional engineering change order</p>
    <p>Intensively studied over the last two decades</p>
    <p>P</p>
    <p>PSPACE</p>
    <p>coNP NP</p>
    <p>2 2</p>
  </div>
  <div class="page">
    <p>Introduction  Prior methods</p>
    <p>Complete ?</p>
    <p>Function type</p>
    <p>Equivalence type</p>
    <p>Solution type</p>
    <p>Scalability</p>
    <p>Spectral methods</p>
    <p>yes CS mostly P one</p>
    <p>Signature based methods</p>
    <p>no mostly CS P/NP N/A  ~ ++</p>
    <p>Canonical-form based methods</p>
    <p>yes CS mostly P one +</p>
    <p>SAT based methods</p>
    <p>yes CS mostly P one/all +</p>
    <p>BooM (QBF/SAT-like)</p>
    <p>yes CS / IS NPN one/all ++</p>
    <p>CS: completely specified IS: incompletely specified</p>
  </div>
  <div class="page">
    <p>Main Results</p>
    <p>Features of BooM  General computation framework  Effective search space reduction techniques</p>
    <p>Dynamic learning and abstraction</p>
    <p>Theoretical SAT-iteration upper-bound:</p>
    <p>O(2nn!) O(22n)</p>
  </div>
  <div class="page">
    <p>Formulation  Reduce NPN-equiv to 2 NP-equiv checks</p>
    <p>Matching f and g; matching f and g</p>
    <p>2nd order formula of NP-equivalence</p>
    <p>fc and gc are the care conditions of f and g, respectivel y</p>
    <p>Need 1st order formula instead for SAT solving</p>
    <p>,x ((fc(x)  gc(  (x)))  (f(x)  g(  (x))))</p>
  </div>
  <div class="page">
    <p>Formulation</p>
    <p>0-1 matrix representation of</p>
    <p>=1</p>
    <p>bij  (xj  y</p>
    <p>i)</p>
    <p>aij  (xj  y</p>
    <p>i)</p>
    <p>=1</p>
  </div>
  <div class="page">
    <p>Formulation  Quantified Boolean formula (QBF) for NP-equivalence</p>
    <p>C: cardinality constraint  A: /\i,j (aij  (yi  xj)) (bij  (yi  xj))</p>
    <p>Look for an assignment to a- and b-variables that satisfies C and makes the miter constraint</p>
    <p>= A  (f  g)  fc  gc unsatisfiable</p>
    <p>Refine C iteratively in a sequence 0, 1, , k, for  i+1  i through conflict-based learning</p>
    <p>a,b,x,y (C  A ((fc  gc)  (f  g))</p>
  </div>
  <div class="page">
    <p>BooM Flow f (and f</p>
    <p>c) g (and gc)</p>
    <p>Preprocess (sig., abs.)</p>
    <p>Solve mapping i</p>
    <p>SAT ?</p>
    <p>Solve miter</p>
    <p>SAT ?</p>
    <p>No match</p>
    <p>Match found</p>
    <p>Add learned clause to i</p>
    <p>i characterizes all matches</p>
    <p>How to compute all matches?</p>
    <p>Solve i</p>
    <p>i= 0</p>
    <p>yes</p>
    <p>no</p>
    <p>i=i+1</p>
    <p>no</p>
    <p>yes</p>
  </div>
  <div class="page">
    <p>NP-Equivalence Conflict-based Learning</p>
    <p>Observation</p>
    <p>f g</p>
    <p>From SAT 1</p>
    <p>How to avoid these 6</p>
    <p>mappings at once?</p>
  </div>
  <div class="page">
    <p>a11 b12 a13 b21 a22 b23 b31 a32 b33</p>
    <p>Learnt clause generation ( a11  b12  a13  b21  a22  b23  b31  a32  b33 )</p>
    <p>NP-Equivalence Conflict-based Learning</p>
    <p>f g</p>
  </div>
  <div class="page">
    <p>NP-Equivalence Conflict-based Learning  Proposition:</p>
    <p>If f(u)  g(v) with v =   (u) for some   satisfying i, then the learned clause \/ij lij for literals</p>
    <p>lij = (vi  uj) ? aij : bij excludes from i the mappings {  |   (u) =   (u)}</p>
    <p>Proposition:</p>
    <p>The learned clause prunes n! infeasible mappings</p>
    <p>Proposition:</p>
    <p>The refinement process 0, 1, , k is bounded by 22n it erations</p>
  </div>
  <div class="page">
    <p>NP-Equivalence Abstraction  Abstract Boolean matching</p>
    <p>Abstract f(x1,,xk,xk+1,,x n) to f(x1,,xk,z,,z) = f *(x1,,xk,z)</p>
    <p>Match g(y1,,yn) against f* (x1,,xk,z)</p>
    <p>Infeasible matching solutio ns of f* and g are also inf easible for f and g</p>
    <p>y1 yk yn</p>
    <p>g</p>
    <p>yk+1</p>
    <p>x1 xk</p>
    <p>f*</p>
    <p>z</p>
    <p>x1 xk z</p>
    <p>f</p>
    <p>z</p>
    <p>x1 xk xn</p>
    <p>f</p>
    <p>xk+1</p>
    <p>P N</p>
  </div>
  <div class="page">
    <p>NP-Equivalence Abstraction</p>
    <p>Abstract Boolean matching  Similar matrix representation of</p>
    <p>negation/permutation</p>
    <p>Similar cardinality constraints, except for allowing multiple y-variables mapped to z</p>
    <p>=1</p>
    <p>=1</p>
  </div>
  <div class="page">
    <p>NP-Equivalence Abstraction</p>
    <p>Used for preprocessing</p>
    <p>Information learned for abstract model is valid for concrete model</p>
    <p>Simplified matching in reduced Boolean space</p>
  </div>
  <div class="page">
    <p>P-Equivalence Conflict-based Learning  Proposition:</p>
    <p>If f(u)  g(v) with v = (u) for some  satisfyin g i, then the learned clause \/ij lij for literals</p>
    <p>lij = (vi=0 and uj=1) ? aij :</p>
    <p>excludes from i the mappings { | (u) = (u)}</p>
  </div>
  <div class="page">
    <p>P-Equivalence Abstraction</p>
    <p>Abstraction enforces search in biased truth assignments and makes learning strong  For f* having k support variables, a learned</p>
    <p>clause converted back to the concrete model consists of at most (k1)(nk+1) literals</p>
  </div>
  <div class="page">
    <p>Experimental Setup</p>
    <p>BooM implemented in ABC using MiniSAT  A function is matched against its synthesiz ed, and input-permuted/negated version  Match individual output functions of MCNC, ISCA S, ITC benchmark circuits</p>
    <p>717 functions with 10~39 support variables and 15~2160 AIG nodes</p>
    <p>Time-limit 600 seconds  Baseline preprocessing exploits symmetry, unate ness, and simulation for initial matching</p>
  </div>
  <div class="page">
    <p>Experimental Results</p>
    <p>(P-equivalence; find all matches)</p>
    <p>Learning Abstraction</p>
  </div>
  <div class="page">
    <p>Experimental Results</p>
    <p>P-equivalence NP-equivalence</p>
  </div>
  <div class="page">
    <p>Experimental Results</p>
    <p>(runtime after same preprocessing; P-equivalence; find one match)</p>
    <p>BooM vs. DepQBF</p>
  </div>
  <div class="page">
    <p>Conclusions  Proposed BooM, a dedicated decision procedure for</p>
    <p>Boolean matching  Effective learning and abstraction</p>
    <p>Far faster than state-of-the-art QBF solver  Theoretical upper bound reduced from O(2nn!) to O(22n)</p>
    <p>Empirically exponent ~7 times less for P, ~3 times less for NP</p>
    <p>General computation framework  Handles NPN-equivalence, incompletely specified functions  Allows easy integration with signature based methods</p>
    <p>Anticipate BooM to be a common platform for other Boolean matching developments and to facilitate pr actical applications</p>
  </div>
  <div class="page">
    <p>Ongoing and Future Work</p>
    <p>Generalize to multiple-output functions  Strengthen learning  Customize decision procedures for more comp utation problems</p>
  </div>
  <div class="page">
    <p>Thanks for Your Attention</p>
    <p>Questions?</p>
  </div>
</Presentation>
