<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>SymDrive: Testing Drivers without Devices</p>
    <p>Matthew Renzelmann, Asim Kadav, and Michael Swift</p>
    <p>University of WisconsinMadison</p>
  </div>
  <div class="page">
    <p>Isolating</p>
    <p>Sandboxing</p>
    <p>Splitting</p>
    <p>Formalizing</p>
    <p>Rewriting</p>
    <p>Tolerating Recovering</p>
    <p>Driver Testing Code Review</p>
  </div>
  <div class="page">
    <p>SymDrive: Testing Drivers without Devices</p>
    <p>#1: One Driver, Many Devices static DEFINE_PCI_DEVICE_TABLE(e1000_pci_tbl) = { INTEL_E1000_ETHERNET_DEVICE(0x1000), INTEL_E1000_ETHERNET_DEVICE(0x1001), INTEL_E1000_ETHERNET_DEVICE(0x1004), INTEL_E1000_ETHERNET_DEVICE(0x1008), INTEL_E1000_ETHERNET_DEVICE(0x1009), INTEL_E1000_ETHERNET_DEVICE(0x100C), INTEL_E1000_ETHERNET_DEVICE(0x100D), INTEL_E1000_ETHERNET_DEVICE(0x100E), INTEL_E1000_ETHERNET_DEVICE(0x100F), INTEL_E1000_ETHERNET_DEVICE(0x1010), INTEL_E1000_ETHERNET_DEVICE(0x1011), INTEL_E1000_ETHERNET_DEVICE(0x1012), INTEL_E1000_ETHERNET_DEVICE(0x1013), INTEL_E1000_ETHERNET_DEVICE(0x1014), INTEL_E1000_ETHERNET_DEVICE(0x1015), INTEL_E1000_ETHERNET_DEVICE(0x1016), INTEL_E1000_ETHERNET_DEVICE(0x1017), INTEL_E1000_ETHERNET_DEVICE(0x1018), INTEL_E1000_ETHERNET_DEVICE(0x1019),</p>
    <p>INTEL_E1000_ETHERNET_DEVICE(0x101A), INTEL_E1000_ETHERNET_DEVICE(0x101D), INTEL_E1000_ETHERNET_DEVICE(0x101E), INTEL_E1000_ETHERNET_DEVICE(0x1026), INTEL_E1000_ETHERNET_DEVICE(0x1027), INTEL_E1000_ETHERNET_DEVICE(0x1028), INTEL_E1000_ETHERNET_DEVICE(0x1075), INTEL_E1000_ETHERNET_DEVICE(0x1076), INTEL_E1000_ETHERNET_DEVICE(0x1077), INTEL_E1000_ETHERNET_DEVICE(0x1078), INTEL_E1000_ETHERNET_DEVICE(0x1079), INTEL_E1000_ETHERNET_DEVICE(0x107A), INTEL_E1000_ETHERNET_DEVICE(0x107B), INTEL_E1000_ETHERNET_DEVICE(0x107C), INTEL_E1000_ETHERNET_DEVICE(0x108A), INTEL_E1000_ETHERNET_DEVICE(0x1099), INTEL_E1000_ETHERNET_DEVICE(0x10B5), INTEL_E1000_ETHERNET_DEVICE(0x2E6E), /* required last entry */ {0,} };</p>
    <p>switch (hw-&gt;device_id) { case E1000_DEV_ID_82545GM_SERDES: case E1000_DEV_ID_82546GB_SERDES: hw-&gt;media_type = e1000_media_type_internal_serdes; break; default: switch (hw-&gt;mac_type) { case e1000_82542_rev2_0: case e1000_82542_rev2_1: hw-&gt;media_type = e1000_media_type_fiber; break; case e1000_ce4100: hw-&gt;media_type = e1000_media_type_copper; break; default: status = er32(STATUS); if (status &amp; E1000_STATUS_TBIMODE) { hw-&gt;media_type = e1000_media_type_fiber; hw-&gt;tbi_compatibility_en = false; } else { hw-&gt;media_type = e1000_media_type_copper; } break; } }</p>
    <p>The E1000 driver supports 37 distinct pieces of hardware</p>
    <p>More Hardware  Expensive Testing</p>
    <p>Driver behavior depends on hardware-specific details</p>
    <p>Testing with 37 network cards is expensive and inconvenient</p>
  </div>
  <div class="page">
    <p>SymDrive: Testing Drivers without Devices</p>
    <p>#2: Error Handling ret = lp5523_init_led(&amp;chip-&gt;leds[led], &amp;client-&gt;dev, i, pdata); if (ret) { goto fail3; // Suppose we take this path } // ... INIT_WORK(&amp;(chip-&gt;leds[led].brightness_work), lp5523_led_brightness_work); // ... fail3: for (i = 0; i &lt; chip-&gt;num_leds; i++) { led_classdev_unregister(&amp;chip-&gt;leds[i].cdev);  }</p>
    <p>Error Handling  Expensive Testing</p>
    <p>Example from the Linux 3.1.1 lp5523 LED driver</p>
    <p>void led_classdev_unregister(struct led_classdev *led_cdev) { ... /* Stop blinking */ led_brightness_set(led_cdev, LED_OFF); ...</p>
    <p>static void lp5523_set_brightness( struct led_classdev *cdev, enum led_brightness brightness) { struct lp5523_led *led = cdev_to_led(cdev); led-&gt;brightness = (u8)brightness; schedule_work(&amp;led-&gt;brightness_work); }</p>
    <p>Handling device failures + Handling kernel failures + Cross-file dependencies + Reentrancy</p>
    <p>Difficult Code Review + More Bugs</p>
  </div>
  <div class="page">
    <p>SymDrive: Testing Drivers without Devices</p>
    <p>#3: Kernel Evolution Patch: flush_scheduled_work() is on its way out.  The conversions are mostly straight forward and the only dangers are, *  [list ommitted] Signed-off-by: Tejun Heo &lt;tj@kernel.org&gt; Cc: &quot;David S. Miller&quot; &lt;davem@davemloft.net&gt; Cc: Jay Cliburn &lt;jcliburn@gmail.com&gt; Cc: Michael Chan &lt;mchan@broadcom.com&gt; Cc: Divy Le Ray &lt;divy@chelsio.com&gt; Cc: e1000-devel@lists.sourceforge.net Cc: Vasanthy Kolluri &lt;vkolluri@cisco.com&gt; Cc: Samuel Ortiz &lt;samuel@sortiz.org&gt; Cc: Lennert Buytenhek &lt;buytenh@wantstofly.org&gt; Cc: Andrew Gallatin &lt;gallatin@myri.com&gt; Cc: Francois Romieu &lt;romieu@fr.zoreil.com&gt; Cc: Ramkrishna Vepa &lt;ramkrishna.vepa@exar.com&gt; Cc: Matt Carlson &lt;mcarlson@broadcom.com&gt; Cc: David Brownell &lt;dbrownell@users.sourceforge.net&gt; Cc: Shreyas Bhatewara &lt;sbhatewara@vmware.com&gt;</p>
    <p>Affected Drivers: /8139too.c /atlx/atl2.c /bcm63xx_enet.c /bnx2.c /cassini.c /cxgb3/cxgb3_main.c /e1000e/netdev.c /enic/enic_main.c /ibm_newemac/core.c /irda/mcs7780.c /ixgb/ixgb_main.c /ixgbevf/ixgbevf_main.c /mv643xx_eth.c /myri10ge/myri10ge.c /niu.c /pxa168_eth.c /r8169.c /s2io.c /sis190.c /tg3.c /usb/sierra_net.c /usb/usbnet.c /vmxnet3/vmxnet3_drv.c</p>
    <p>Kernel Evolution  Expensive Testing</p>
    <p>Patch checking often requires considerable human effort</p>
    <p>Patch testing often requires considerable</p>
    <p>hardware</p>
    <p>Hardware costs add up:</p>
    <p>&gt; 200 devices required here</p>
  </div>
  <div class="page">
    <p>Existing Approaches</p>
    <p>SymDrive: Testing Drivers without Devices</p>
    <p>Finds Fewer Bug Types Finds Many Bug Types</p>
    <p>D e ve</p>
    <p>lo p</p>
    <p>e r</p>
    <p>E ffo</p>
    <p>rt</p>
    <p>Standard Testing</p>
    <p>Static Analysis</p>
    <p>Symbolic Execution</p>
    <p>Code Review</p>
    <p>Formal Specification</p>
    <p>SymDrive</p>
  </div>
  <div class="page">
    <p>SymDrive</p>
    <p>Driver testing and validation tool  Runs drivers using symbolic execution: no devices  Reduces effort via static analysis/code generation  Interposes on driver/kernel interface with test framework  Provides broad driver, bus, and platform compatibility</p>
    <p>SymDrive: Testing Drivers without Devices</p>
    <p>Benefits  Facilitates writing better quality code  Allows many people to test and develop drivers</p>
  </div>
  <div class="page">
    <p>SymDrive Outline</p>
    <p>Introduction  Goals and Background  Overview of SymDrive  Problems and Solutions</p>
    <p>What problems does SymDrive solve and how?  Results</p>
    <p>Does SymDrive find deep bugs? Is it easy to use?  Conclusion</p>
    <p>SymDrive: Testing Drivers without Devices 10/10/2012 8</p>
  </div>
  <div class="page">
    <p>Goals of SymDrive</p>
    <p>Find deep bugs</p>
    <p>SymDrive: Testing Drivers without Devices</p>
    <p>Driver</p>
    <p>Kernel</p>
    <p>Bus / Hardware</p>
    <p>[Kadav2012]</p>
    <p>Time</p>
    <p>Be easy to use  Enable broader</p>
    <p>patch testing</p>
  </div>
  <div class="page">
    <p>SymDrive Uses Symbolic Execution</p>
    <p>SymDrive must:  Analyze multiple paths through the driver</p>
    <p>to find deep bugs  Provide a model for device behavior</p>
    <p>to be easy to use  Check driver runtime properties</p>
    <p>to enable broader patch testing</p>
    <p>Symbolic execution can achieve these goals</p>
  </div>
  <div class="page">
    <p>x &gt;= 10 x &lt; 10</p>
    <p>Background: Symbolic Execution</p>
    <p>void f(void) { int x = inb(); // x is symbolic if(x &lt; 10) return EIO; else return 0; }</p>
    <p>SymDrive: Testing Drivers without Devices</p>
    <p>All feasible paths explored</p>
    <p>void f(void) { int x = inb(); if(x &lt; 10) return EIO; else return 0; }</p>
    <p>void f(void) { int x = inb(); if(x &lt; 10) return EIO; else return 0; } void g() { if () {  } else {  } }</p>
    <p>if (x) {} else {  } while (x) {}</p>
    <p>void g() { if () {  } else {  } }</p>
    <p>void h() { if () {  } else {  } }</p>
    <p>void f() { if () {  } else {  } }</p>
    <p>if (x) {} else {  } while (x) {}</p>
    <p>if (x) {} else {  } if (!x) {}</p>
    <p>else {  } while (x) {}</p>
    <p>void g() { if () {  } else {  } }</p>
    <p>void f() { if () {  } else {  } }</p>
    <p>if (x) {} else {  } while (x) {}</p>
    <p>Path explosion</p>
  </div>
  <div class="page">
    <p>Symbolic Execution Challenges</p>
    <p>How should SymDrive 1. Avoid path explosion and execute useful paths? 2. Check driver runtime properties? 3. Achieve high coverage?</p>
    <p>SymDrive: Testing Drivers without Devices 10/10/2012 12</p>
  </div>
  <div class="page">
    <p>SymDrive Outline</p>
    <p>Introduction  Goals and Background  Overview of SymDrive  Problems and Solutions</p>
    <p>Path Explosion  Driver Testing</p>
    <p>Results  Does SymDrive find deep bugs? Is it easy to use?</p>
    <p>Conclusion</p>
    <p>SymDrive: Testing Drivers without Devices 10/10/2012 13</p>
  </div>
  <div class="page">
    <p>Baseline System</p>
    <p>SymDrive: Testing Drivers without Devices 10/10/2012 14</p>
    <p>Runtime (VM)</p>
    <p>S2E Symbolic Execution Engine</p>
    <p>OS Kernel</p>
    <p>Symbolic Device</p>
    <p>Test Programs</p>
    <p>Compile Time</p>
    <p>Driver Source</p>
    <p>Driver Module GCC</p>
    <p>Driver Module Symbolic Bus</p>
    <p>How should SymDrive avoid path explosion?</p>
    <p>How can the developer check runtime properties using SymDrive?</p>
  </div>
  <div class="page">
    <p>Challenge #1: Path Explosion Example #1 (e1000):</p>
    <p>SymDrive: Testing Drivers without Devices</p>
    <p>for (i = 1000; i &gt; 0; i--) { barrier(); if ((read (ChipCmd) &amp; CmdReset) == 0) break; udelay (10); }</p>
    <p>ret_val = e1000_read_phy_reg(hw, , &amp;phy_data); if (ret_val) return ret_val; phy_data |= M88E1000_EPSCR_TX_CLK_25; ret_val = e1000_write_phy_reg(hw, , phy_data); if (ret_val) return ret_val; ret_val = e1000_read_phy_reg(hw, , &amp;phy_data); if (ret_val) return ret_val;</p>
    <p>Example #2 (8139too):</p>
    <p>Loops may induce path explosion</p>
    <p>Symbolic hardware may induce path explosion</p>
  </div>
  <div class="page">
    <p>Solution #1: Inform Runtime</p>
    <p>Inform SymDrive of relevant driver activity  Whether functions are executing successfully  When loops start/iterate/end</p>
    <p>Use source code hints</p>
    <p>Opcode Purpose</p>
    <p>symdrive_prioritize Prioritize current path</p>
    <p>symdrive_deprioritize Deprioritize current path</p>
    <p>symdrive_loop_before Current path is about to enter a loop</p>
    <p>symdrive_loop_body Current path is about to iterate the loop</p>
    <p>symdrive_loop_after Current path exited the loop</p>
  </div>
  <div class="page">
    <p>Solution #1A: Favor-Success Scheduling</p>
    <p>Prioritize execution of paths that return success  Generate code when functions begin/end</p>
    <p>Inform symbolic execution engine of failure</p>
    <p>SymDrive: Testing Drivers without Devices 10/10/2012 17</p>
    <p>Example (all drivers): // This code executes when the driver function returns if (IS_ERR_VALUE(retval)) { // failure //  symdrive_deprioritize(line); } else { // success //  } Deprioritize failing paths</p>
  </div>
  <div class="page">
    <p>Solution #1B: Loop Elision</p>
    <p>SymDrive: Testing Drivers without Devices</p>
    <p>symdrive_loop_before(); while (i &gt; 0) {  if ((ioread8(ioaddr + 55) &amp; 16U) == 0U) break; i--; symdrive_loop_body(); } symdrive_loop_after();</p>
    <p>Example (8139too):</p>
    <p>Instrument loops; prioritize paths that exit loops quickly</p>
    <p>Inform SymDrive of loops to improve scheduling  Prioritize execution of paths that exit loops fast  Generate instrumentation for loops statically</p>
  </div>
  <div class="page">
    <p>Solution #1C: High-Coverage Mode</p>
    <p>Provides additional symbolic data  Favors paths that touch unexecuted code  Makes kernel functions return symbolic values</p>
    <p>Forks execution: once for success, once for failure</p>
    <p>SymDrive: Testing Drivers without Devices</p>
    <p>static int __devinit lp5523_init_led(struct lp5523_led *led, struct device *dev, int ch, struct lp5523_platform_data *dat) {  res = led_classdev_register(dev, &amp;led-&gt;cdev); if (res &lt; 0) return res; res = sysfs_create_group(&amp;led-&gt;cdev.dev-&gt;kobj, &amp;lp5523_led_attribute_group);  return 0;</p>
    <p>Fork failure</p>
    <p>Fork success High-coverage mode improves coverage</p>
  </div>
  <div class="page">
    <p>Implementation: SymGen</p>
    <p>SymDrive: Testing Drivers without Devices 10/10/2012 20</p>
    <p>Runtime (VM)</p>
    <p>S2E Symbolic Execution Engine</p>
    <p>OS Kernel</p>
    <p>Driver Module</p>
    <p>Symbolic Device SymDrive Plugin</p>
    <p>Test Programs</p>
    <p>Compile Time</p>
    <p>Driver Source</p>
    <p>SymGen Driver Module Transformed</p>
    <p>Driver GCC</p>
    <p>Symbolic Bus</p>
    <p>Instrumented C source code</p>
    <p>Static analysis and code generation tool</p>
    <p>Instrumentation notifies SymDrive Plugin of path quality</p>
  </div>
  <div class="page">
    <p>Challenge #2: Testing</p>
    <p>Why?  Linux/FreeBSD do not test driver interfaces well  Developers need a way to specify correct behavior</p>
    <p>S2E can already report hangs/crashes:</p>
    <p>SymDrive: Testing Drivers without Devices</p>
    <p>/* tell stack to leave us alone until e1000_open() is called */ netif_carrier_off(netdev); netif_stop_queue(netdev);  err = register_netdev(netdev);</p>
    <p>Bug</p>
    <p>int f(int *p) {  *p = 0;  } // If p is NULL, S2E reports error</p>
    <p>What about semantic bugs? Example (e1000):</p>
    <p>Semantic bugs are hard to find</p>
  </div>
  <div class="page">
    <p>Solution #2A: Checkers</p>
    <p>Verify kernel/driver pre- and postconditions  Complement symbolic execution</p>
    <p>SymDrive: Testing Drivers without Devices</p>
    <p>static int netif_carrier_off_check( const char *fn, int prepost, struct net_device **dev) { if (prepost == PRECONDITION) { tfassert (ndo_state.register_netdev == CALLED_OK);  } return 0; }</p>
    <p>Checker</p>
    <p>API Call</p>
    <p>driver netif_carrier_off_check</p>
    <p>netif_carrier_off netif_carrier_off_check driver</p>
  </div>
  <div class="page">
    <p>Solution #2B: Interface Interposition</p>
    <p>Determine driver/kernel interface automatically  Find the appropriate checker</p>
    <p>Use the test framework  Example (8139too):</p>
    <p>SymGen interposes on the driver/kernel interface automatically</p>
    <p>// First, look up the checker for this driver function type: check_fn_rtl8139_init_one = lookup_checker(&amp;rtl8139_init_one); // Then, invoke the checker, either as a pre- or postcondition check_fn_rtl8139_init_one();</p>
  </div>
  <div class="page">
    <p>Runtime (VM)</p>
    <p>S2E Symbolic Execution Engine</p>
    <p>Implementation: Checkers</p>
    <p>SymDrive: Testing Drivers without Devices</p>
    <p>OS Kernel Checkers</p>
    <p>Driver Module Test Framework</p>
    <p>Symbolic Device SymDrive Plugin</p>
    <p>Test Programs</p>
    <p>Compile Time</p>
    <p>Driver Source</p>
    <p>SymGen Driver Module Transformed</p>
    <p>Driver GCC</p>
    <p>Support Library</p>
    <p>Symbolic Bus</p>
    <p>Support library simplifies checker development</p>
    <p>SymGen interposes on driver / kernel interface automatically</p>
    <p>Test Framework finds correct checker to execute</p>
  </div>
  <div class="page">
    <p>Example Checkers</p>
    <p>SymDrive: Testing Drivers without Devices</p>
    <p>Checker Category</p>
    <p>Assertion</p>
    <p>Allocator Mismatch</p>
    <p>The dev_id field must match in corresponding calls to request_irq and free_irq.</p>
    <p>Allocator Mismatch</p>
    <p>Calls to pci_map_page/pci_unmap_page and pci_map_single/pci_unmap_single must correspond.</p>
    <p>API Misuse Network drivers must not call netif_stop_queue before calling register_netdev.</p>
    <p>Driver Interface</p>
    <p>Ensure that kmalloc and related functions use appropriate allocation flags for the current context.</p>
    <p>Driver Interface</p>
    <p>Network drivers: dev-&gt;trans_start field is unchanged.</p>
    <p>Leak All allocated memory resources are freed appropriately. 12 allocate/free pairs supported via generic API.</p>
    <p>Limitations: Checkers operate at driver/kernel interface, and do not verify driver/device interaction</p>
  </div>
  <div class="page">
    <p>SymDrive Outline</p>
    <p>Introduction  Goals and Background  Overview of SymDrive  Problems and Solutions</p>
    <p>What problems does SymDrive solve and how?  Results</p>
    <p>Does SymDrive find deep bugs? Is it easy to use?  Conclusion</p>
    <p>SymDrive: Testing Drivers without Devices 10/10/2012 26</p>
  </div>
  <div class="page">
    <p>SymDrive Results</p>
    <p>Goal #1: Find deep bugs  Tested variety of drivers</p>
    <p>Goal #2: Be easy to use  Measured developer effort</p>
    <p>Goal #3: Enable broader patch testing  Measured patch testing effort</p>
    <p>SymDrive: Testing Drivers without Devices 10/10/2012 27</p>
  </div>
  <div class="page">
    <p>Summary of Bugs Found</p>
    <p>39 bugs found across 26 drivers  Kernel developers validated many bugs  Full details at: http://research.cs.wisc.edu/sonar/projects/symdrive</p>
    <p>SymDrive: Testing Drivers without Devices 10/10/2012 28</p>
  </div>
  <div class="page">
    <p>Bug Categories</p>
    <p>SymDrive: Testing Drivers without Devices 10/10/2012 29</p>
    <p>Bug Type Bugs Kernel Checker Cross Entry Point</p>
    <p>Hardware Dependence</p>
    <p>API Misuse 15 7 8 6 Race 3 3 0 3 Allocator Mismatch</p>
    <p>Leak 7 0 7 6 Driver Interface</p>
    <p>Bad Pointer 1 1 0 0 Totals 39 17 22 22</p>
    <p>Bugs span multiple entry point invocations</p>
    <p>Checkers are critical to finding bugs</p>
    <p>Median of 1 annotation, maximum of 7</p>
  </div>
  <div class="page">
    <p>W:9in H:5in 0.5 / 1.5</p>
    <p>P e rc</p>
    <p>e n</p>
    <p>t o</p>
    <p>f D</p>
    <p>ri ve</p>
    <p>r F u</p>
    <p>n c ti</p>
    <p>o n</p>
    <p>s</p>
    <p>Driver Touched Funcs Coverage</p>
    <p>Code Coverage</p>
    <p>SymDrive: Testing Drivers without Devices</p>
    <p>Testing with real hardware and gcov: 77% driver functions executed</p>
    <p>SymDrive can execute drivers with results</p>
    <p>comparable to using real hardware</p>
    <p>Median functions touched and coverage of touched functions is</p>
    <p>greater than 80% 10/10/2012 30</p>
  </div>
  <div class="page">
    <p>Driver Runtimes</p>
    <p>SymDrive: Testing Drivers without Devices</p>
    <p>W:9in H:5in 0.5 / 1.5</p>
    <p>SymDrive is fast enough to test drivers</p>
    <p>System: - 2.5Ghz Core 2 Quad - 8GB memory - Ubuntu 10.10 x64</p>
    <p>T im</p>
    <p>e E</p>
    <p>la p</p>
    <p>s e d</p>
    <p>( h</p>
    <p>h :m</p>
    <p>m )</p>
    <p>Driver</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>SymDrive:  Tests drivers without hardware  Finds bugs in real drivers that are worth patching  Facilitates driver patch testing and refactoring  Supports two OSs and many driver classes</p>
    <p>For more information: http://research.cs.wisc.edu/sonar/projects/symdrive</p>
    <p>&lt;mjr, kadav, swift&gt;@cs.wisc.edu</p>
    <p>SymDrive: Testing Drivers without Devices 10/10/2012 32</p>
  </div>
</Presentation>
