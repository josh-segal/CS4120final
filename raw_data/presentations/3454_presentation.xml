<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>COMPUTER SCIENCE - 1</p>
    <p>James C. Davis Eric R. Williamson</p>
    <p>Dongyoon Lee</p>
    <p>A Sense of Time for JavaScript and Node.js</p>
    <p>First-Class Timeouts as a Cure for Event Handler Poisoning</p>
  </div>
  <div class="page">
    <p>- 2</p>
    <p>Attack: Event Handler Poisoning Definition Analysis</p>
    <p>Detect + recover: First-Class Timeouts Concept Prototype</p>
    <p>Engagement with the Node.js community Guide Core APIs: Documentation and repairs</p>
    <p>Contributions</p>
  </div>
  <div class="page">
    <p>- 3</p>
    <p>Node.js: A JS framework for web services</p>
  </div>
  <div class="page">
    <p>- 4</p>
    <p>Web server architectures</p>
  </div>
  <div class="page">
    <p>- 5</p>
    <p>One Thread per Client Architecture (OTPCA)</p>
    <p>Each client gets its own worker thread  Multithreading enables scalability  Example:</p>
    <p>ClientA</p>
    <p>ResA</p>
    <p>ResB</p>
    <p>Thread pool (1000s of threads)</p>
    <p>ReqA</p>
    <p>ReqB</p>
    <p>Dispatcher</p>
    <p>ClientB</p>
  </div>
  <div class="page">
    <p>- 6</p>
    <p>Event-Driven Architecture (EDA)</p>
    <p>Clients multiplexed; shared threads reduce threading overhead  Cooperative multitasking via (1) Partitioning and (2) Offloading  Example:</p>
    <p>CBA1</p>
    <p>CBB1</p>
    <p>CBA3 ResA</p>
    <p>ResB Task B1</p>
    <p>Event loop (single-threaded)</p>
    <p>Worker pool (k threads)</p>
    <p>Task Q Event Q</p>
    <p>Done Q</p>
    <p>ReqB</p>
    <p>ReqA</p>
  </div>
  <div class="page">
    <p>- 7</p>
    <p>OTPCA</p>
    <p>def serveFile(req): cont = readFile(req.file)</p>
    <p>z = zip(cont) e = encrypt(z) return e</p>
    <p>EDA</p>
    <p>def serveFile(req): cont = await readFile(req.file)</p>
    <p>z = await zip(cont) e = await encrypt(z) return e</p>
    <p>Server architecture dictates programming style</p>
    <p>Preemptive multi-tasking Synchronous</p>
    <p>Cooperative multi-tasking Asynchronous</p>
  </div>
  <div class="page">
    <p>- 8</p>
    <p>Event Handler Poisoning Attacks (EHP)</p>
  </div>
  <div class="page">
    <p>- 9</p>
    <p>The EDA gains efficiency, loses isolation</p>
    <p>Architecture Threads # Threads Multi-tasking OTPCA Dedicated Thousands Preemptive</p>
    <p>EDA Shared Tens Cooperative</p>
    <p>Event Handlers = limited resource Exhaust resource  DoS</p>
  </div>
  <div class="page">
    <p>- 10</p>
    <p>Behavior during EHP attack on the Event Loop</p>
    <p>Event loop is poisoned  Throughput drops to zero</p>
    <p>Event loop (single-threaded)</p>
    <p>Worker pool (k threads)</p>
    <p>Task Q Event Q</p>
    <p>Done Q</p>
    <p>ReqA</p>
    <p>ReqB CBA1</p>
    <p>On the worker pool: k malicious requests</p>
  </div>
  <div class="page">
    <p>- 11</p>
    <p>Vulnerable server</p>
    <p>def serveFile(name): if name.match(/(\/.+)+$/): readFile(name) .then(</p>
    <p>... )</p>
    <p>ReDoS</p>
    <p>IO-DoS Arbitrary file read</p>
    <p>Super-linear regex</p>
  </div>
  <div class="page">
    <p>- 12</p>
    <p>ReDoS-based EHP attack</p>
    <p>T hr</p>
    <p>o ug</p>
    <p>hp ut</p>
    <p>( re</p>
    <p>qs /s</p>
    <p>ec )</p>
    <p>Time (seconds)</p>
    <p>Baseline REDOS</p>
    <p>NodeCure REDOS</p>
    <p>Inject malicious input during steady-state</p>
    <p>TimeoutException delivered</p>
  </div>
  <div class="page">
    <p>- 13</p>
    <p>Other (CWEs 330, 208, 601, 90, )</p>
    <p>Improper Authentication (CWE</p>
    <p>Information Exposure (CWE 201)</p>
    <p>Malicious Package (CWE 506)</p>
    <p>Command Injection (CWE 77)</p>
    <p>Denial of Service (CWE 400)</p>
    <p>Man in the Middle (CWE 300)</p>
    <p>Cross-Site Scripting (CWE 79)</p>
    <p>Directory Traversal (CWE 22)</p>
    <p>EHP Not EHP</p>
  </div>
  <div class="page">
    <p>- 14</p>
    <p>What should we do about EHP?</p>
  </div>
  <div class="page">
    <p>- 15</p>
    <p>Idea  Heartbeat on each Event Handler  If any heartbeats fail, restart the server</p>
    <p>Problems  Every connected client gets DoSd  Repeat attacks</p>
    <p>Nave 1: Restart the server</p>
  </div>
  <div class="page">
    <p>- 16</p>
    <p>Nave 2: Prevent through partitioning</p>
    <p>def sum(L): s = 0 for n in L:</p>
    <p>s += n return s</p>
    <p>async def sum(L): s = 0 until done:</p>
    <p>s += &lt;10 numbers&gt; yield</p>
    <p>return s</p>
    <p>=</p>
    <p>Short L</p>
    <p>Long L</p>
    <p>Long L</p>
    <p>+ Yield! Yield!</p>
  </div>
  <div class="page">
    <p>- 17</p>
    <p>Only protects code under the application dev.s control Not modules Not framework Not language</p>
    <p>Good for algorithms  but how to meaningfully partition I/O?</p>
    <p>Ongoing maintenance burden</p>
    <p>Partitioning is partial and ad hoc</p>
  </div>
  <div class="page">
    <p>- 18</p>
    <p>Our proposed solution:</p>
    <p>First-Class Timeouts</p>
  </div>
  <div class="page">
    <p>- 19</p>
    <p>Analogy Buffer overflow  Out of bounds exception EDA time overflow  Timeout exception</p>
    <p>Idea Time-aware cooperative multi-tasking</p>
    <p>Bound the synchronous time of every Callback and Task  Deliver a TimeoutException if this bound is exceeded</p>
    <p>Analysis  Soundly defeats EHP attacks  Straightforward refactoring: try-catch in Promise chains  Non-destructive: Existing clients unharmed</p>
    <p>First-Class Timeouts</p>
  </div>
  <div class="page">
    <p>- 20</p>
    <p>Node.cure Design and Evaluation</p>
  </div>
  <div class="page">
    <p>- 21</p>
    <p>Desired behavior</p>
    <p>Event Handler Old behavior New behavior</p>
    <p>Event Loop Unbounded execution Throw TimeoutException</p>
    <p>Worker Pool '' Return TimeoutException</p>
  </div>
  <div class="page">
    <p>- 22</p>
    <p>Adding first-class timeouts to Node.js</p>
    <p>Application</p>
    <p>JS Engine</p>
    <p>C++</p>
    <p>JS</p>
    <p>Event-ing</p>
    <p>Node.js libs</p>
    <p>libuv</p>
    <p>Worker poolEvent loop</p>
    <p>V8</p>
    <p>Time-aware JS TimeoutException Interrupt handler</p>
    <p>Time-aware Event Loop Timeout Watchdog Monitor CB entry/exit Set T.E. interrupt</p>
    <p>Time-aware Worker Pool Managers watch for timeouts Disposable Workers</p>
  </div>
  <div class="page">
    <p>- 23</p>
    <p>Built on Node.js v8.8.1 (LTS)  4 KLoC across 50 files</p>
    <p>Compatible  Passes Node.js core test suite*</p>
    <p>Available on GitHub</p>
    <p>Node.cure prototype</p>
  </div>
  <div class="page">
    <p>- 24</p>
    <p>Security guarantees</p>
    <p>Every vulnerable Language and Framework API is safe  Applications built with these APIs are safe, too!</p>
    <p>Passes our EHP test suite  All vulnerable Node.js APIs  Including all used in the npm vulnerabilities</p>
    <p>However  Detect: Must choose timeout thresholds (Goldilocks problem)  Respond: Tight threshold or blacklisting</p>
  </div>
  <div class="page">
    <p>- 25</p>
    <p>Micro-benchmarks Macro-benchmarks (summary)</p>
    <p>Performance penalty</p>
    <p>App. type Overhead</p>
    <p>Server 0-2 %</p>
    <p>Utility 0-8 %</p>
    <p>Middleware 6-24 %</p>
    <p>Component Overhead</p>
    <p>New interrupt 0%</p>
    <p>Instr. CBs 1.01-2.4 x</p>
    <p>I/O buffers 1.3 x</p>
  </div>
  <div class="page">
    <p>- 26</p>
    <p>Community Engagement</p>
  </div>
  <div class="page">
    <p>- 27</p>
    <p>Dont Block the Event Loop (or the Worker Pool) Reviews Node.js architecture EHP attacks + examples Advice about npm module safety</p>
    <p>Guide on nodejs.org</p>
  </div>
  <div class="page">
    <p>- 28</p>
    <p>Documentation fs</p>
    <p>readFile</p>
    <p>crypto randomBytes randomFill</p>
    <p>child_process spawn</p>
    <p>Code fs.readFile</p>
    <p>Changes to Node.js core</p>
  </div>
  <div class="page">
    <p>- 29</p>
    <p>Closing Remarks</p>
  </div>
  <div class="page">
    <p>- 30</p>
    <p>The EDA has an EHP problem.</p>
    <p>First-class timeouts can cure it.</p>
    <p>We:  Defined an attack  Demonstrated its presence in the wild  Designed and prototyped a defense  Disseminated to the practitioner community</p>
    <p>Thank you for your attention!</p>
    <p>COMPUTER SCIENCE</p>
  </div>
  <div class="page">
    <p>- 31</p>
    <p>Bonus Material</p>
  </div>
  <div class="page">
    <p>- 32</p>
    <p>The tighter the timeout, the less effective the EHP attack  Loose timeouts  blacklist attackers  No DDoS (threat model)  Blacklisting is relatively easy with First-Class Timeouts because the TimeoutException is delivered in the context of the malicious request</p>
    <p>Choosing a timeout</p>
  </div>
  <div class="page">
    <p>- 33</p>
    <p>Choose timeout  minimize CB variance during tuning  Goldilocks problem</p>
    <p>Add error handling  a global exception handler and per-request handlers</p>
    <p>New first-class asynchronous primitives like async/await and Promises make this possible</p>
    <p>We only support global timeouts but could refine thresholds on a per-CB and per-Task basis</p>
    <p>Programming with First-Class Timeouts</p>
  </div>
  <div class="page">
    <p>- 34</p>
    <p>Heartbeat  Partitioning  First-class timeouts</p>
    <p>Larger worker pool  Preemptible callbacks and tasks  Speculative concurrent execution  Serverless</p>
    <p>Various ideas towards EHP-safety</p>
    <p>Dedicating resources to each client: OTPCA</p>
    <p>Within the EDA paradigm</p>
  </div>
  <div class="page">
    <p>- 35</p>
    <p>Attacker can trigger worst-case behavior  No DDoS</p>
    <p>Thus:  Include EHP, a problem unique to EDA  Exclude DDoS, a general problem for problem web servers</p>
    <p>Threat model</p>
  </div>
  <div class="page">
    <p>- 36</p>
    <p>More details on time-aware Event Handlers</p>
    <p>Event Loop Worker Pool Executors</p>
    <p>Manager Always has a Worker</p>
    <p>Worker Disposable</p>
    <p>Priority Executor</p>
    <p>uv_queue_work</p>
    <p>uv_queue_work_prio</p>
    <p>Hangman</p>
    <p>Dangling Worker</p>
  </div>
  <div class="page">
    <p>- 37</p>
    <p>Implementation details</p>
    <p>Layer Changes</p>
    <p>Language  Add TimeoutException  Add interrupt</p>
    <p>Framework</p>
    <p>Timeout Watchdog  Handle T.E. from async APIs  Offload sync. APIs  Time-aware C++ add-ons</p>
    <p>Application  Handle T.E.</p>
  </div>
  <div class="page">
    <p>- 38</p>
    <p>Node.js applications can contain:  Pure JavaScript  C++ add-ons</p>
    <p>e.g. for performance or using systems libraries  Application-defined C++ add-ons are unprotected by F.C.T  Must be made time-aware, similar to how we made Node.jss own</p>
    <p>C++ bindings time-aware  Only 0.7% of npm modules have C++ add-ons</p>
    <p>C++ add-ons</p>
  </div>
  <div class="page">
    <p>- 39</p>
    <p>Experimental slides</p>
  </div>
  <div class="page">
    <p>- 40</p>
    <p>Node.js attack  with ReDoS and IO-DoS</p>
    <p>T hr</p>
    <p>ou gh</p>
    <p>pu t</p>
    <p>(r eq</p>
    <p>/s ec</p>
    <p>)</p>
    <p>Time (seconds)</p>
    <p>Baseline REDOS Baseline ReadDOS NodeCure REDOS NodeCure ReadDOS</p>
  </div>
  <div class="page">
    <p>- 41</p>
    <p>Dispatcher</p>
    <p>Handle request</p>
    <p>Handle request</p>
    <p>Thread pool</p>
    <p>One-thread-per-client architecture (OTPCA)</p>
  </div>
  <div class="page">
    <p>- 42</p>
    <p>Event-driven architecture (EDA)</p>
    <p>Event Loop Worker Pool</p>
    <p>offloads</p>
    <p>returns completed work</p>
    <p>Pending events</p>
  </div>
  <div class="page">
    <p>- 43</p>
    <p>Long-running request in OTPCA</p>
    <p>Dispatcher</p>
    <p>Handle request</p>
    <p>Handle request</p>
    <p>Thread pool</p>
  </div>
  <div class="page">
    <p>- 44</p>
    <p>Long-running request in EDA</p>
    <p>offloads</p>
    <p>returns completed work</p>
    <p>Pending events Worker Pool</p>
    <p>Event Loop</p>
  </div>
</Presentation>
