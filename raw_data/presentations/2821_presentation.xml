<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Hyperscan: A Fast Multi-pattern Regex Matcher for Modern CPUs</p>
    <p>Xiang Wang1, Yang Hong1, Harry Chang1, KyoungSoo Park2, Geoff Langdale3, Jiayu Hu1 and Heqing Zhu1</p>
  </div>
  <div class="page">
    <p>Network Platforms Group</p>
    <p>Networking Applications with Regex Matching</p>
    <p>Deep packet inspection (DPI)  key functionality of L7 traffic monitoring</p>
    <p>Regular expression (regex) matching  core element of DPI</p>
    <p>Big problem  regex matching is SLOW</p>
    <p>IPS/IDS WAF</p>
    <p>Application Identification</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 3</p>
    <p>Current Best Practice: Prefilter-based Pattern Matching</p>
    <p>/\sSEARCH\s\w+\s\{\d+\}[\r]?\n[ ^\n]*?%/smi</p>
    <p>/^\w+\s+UNSUBSCRIBE\s[^\n]{1 00}/smi</p>
    <p>content:&quot;SEARCH&quot;;</p>
    <p>pcre:&quot;/\sSEARCH\s\w+\s\{\d+\}[\r]?\n[^\n]*?%/smi&quot;</p>
    <p>content:&quot;UNSUBSCRIBE&quot;;</p>
    <p>pcre:&quot;/^\w+\s+UNSUBSCRIBE\s[^\n]{100}/smi&quot;;</p>
    <p>Rule 0:</p>
    <p>Rule N:</p>
    <p>SEARCH</p>
    <p>UNSUBSCRIBE</p>
    <p>Multi-string matching Single regex matching</p>
    <p>Single regex matching</p>
    <p>Match!</p>
    <p>No Match</p>
    <p>Two-stage Pattern Matching</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 4</p>
    <p>Problems with Prefilter-based Pattern Matching</p>
    <p>.*foo[x]barY+</p>
    <p>XfoZbarY</p>
    <p>Pattern</p>
    <p>Input String Matching for bar</p>
    <p>fX o Z b a r</p>
    <p>Regex Matching</p>
    <p>fX o Z b a r Y</p>
    <p>Manual choice of improper string keywords</p>
    <p>Duplicate matching of the string keywords</p>
    <p>content:/&quot;;</p>
    <p>pcre:&quot;/(?=[defghilmnoqrstwz])(m(ookflolfctm\x2fnmot\.fmu|clvompycem\x2fcen\.vcn)&quot;</p>
    <p>Complex regexes lead to slow NFA</p>
    <p>Slow</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 5</p>
    <p>Contributions</p>
    <p>Novel regex decomposition</p>
    <p>Solutions</p>
    <p>SIMD-based pattern matching</p>
    <p>Efficient multi-string matching</p>
    <p>Fast bit-based NFA</p>
    <p>Issues</p>
    <p>Snort: 8.7x Speedup</p>
    <p>Multi-string matching: 3.2x Speedup over DFC</p>
    <p>Multi-regex matching: 13.5x Speedup over RE2</p>
    <p>Outcome</p>
    <p>Manual choice of improper string keywords</p>
    <p>Duplicate matching of the string keywords</p>
    <p>Complex regexes lead to slow NFA</p>
    <p>Problems with current best practices</p>
    <p>Slow multi-string matching</p>
    <p>Slow NFA matching</p>
    <p>Suboptimal matching performance</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 6</p>
    <p>Wide Adoption of Hyperscan</p>
    <p>Successfully deployed by over 40 commercial projects globally</p>
    <p>In production use by tens of thousands of cloud servers in data centers</p>
    <p>Integrated into 37 open-source projects</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 7</p>
    <p>Regex Decomposition</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 8</p>
    <p>Decomposition-based Matching</p>
    <p>.* [^x] Y+foo bar</p>
    <p>FA2 STR2 FA1 FA0STR1.*foo[x]barY+</p>
    <p>XfoZbarY</p>
    <p>Pattern</p>
    <p>Input</p>
    <p>fX o Z b a r Y</p>
    <p>No duplicate string keyword matching  Smaller FAs with fast DFA matching  Facilitate multi-regex matching</p>
    <p>FA1 is Dead! Dont trigger FA0</p>
    <p>String Matching FA Matching</p>
    <p>Decomposes a pattern into string (STR) and subregex (FA) components</p>
    <p>String matching is the entrance  All components have to be matched</p>
    <p>in order</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 9</p>
    <p>Key Issues with Regex Decomposition</p>
    <p>How to automatically decompose a regex?</p>
    <p>How many real-world regexes can be decomposed?</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 10</p>
    <p>Key Issues with Regex Decomposition</p>
    <p>How to automatically decompose a regex?</p>
    <p>How many real-world regexes can be decomposed?</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 11</p>
    <p>Graph-based Regex Decomposition</p>
    <p>Glushkov NFA 1 a</p>
    <p>Textual regex decomposition is often tricky, e.g. /b[il1]l\s{0,10}/  Graph structure delivers more insights</p>
    <p>(abc|def).*ghiRegex</p>
    <p>Graph-based Decomposition 1) Dominant Path Analysis 2) Dominant Region Analysis 3) Network Flow Analysis</p>
    <p>FA1STR1</p>
    <p>.* abc</p>
    <p>ghi defSTR2</p>
    <p>STR3</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 12</p>
    <p>Graph-based String Extraction</p>
    <p>Dominant Path Analysis</p>
    <p>Dominant Region Analysis</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 13</p>
    <p>Graph-based String Extraction</p>
    <p>Network Flow Analysis  Finds a string (or multiple strings) that ends at the edge  Assigns a score inversely proportional to the length of the string(s) ending at the edge  Runs max-flow min-cut algorithm [1] to find a minimum cut-set</p>
    <p>[1]Jack Edmonds and Richard M Karp. Theoretical improvements in algorithmic efficiency for network flow problems. Journal of the ACM, 19(2):248264, 1972.</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 14</p>
    <p>Key Issues with Regex Decomposition</p>
    <p>How to automatically decompose a regex?</p>
    <p>How many real-world regexes can be decomposed?</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 15</p>
    <p>Effectiveness of Graph Analysis on Real-world Rules</p>
    <p>Ruleset Total All Graph Analyses</p>
    <p>Dominant Path</p>
    <p>Dominant Region</p>
    <p>Network Flow</p>
    <p>Snort Talos (May 2015)</p>
    <p>Snort ET-open 2.9.0 7564 89.3% 86.9% 1.3% 2.7%</p>
    <p>Suricata 4.0.4 7430 87.5% 85.0% 1.3% 2.7%</p>
    <p>Majority of Regex Rules are Decomposable</p>
    <p>Dominant Path Analysis is Effective</p>
  </div>
  <div class="page">
    <p>Network Platforms Group</p>
    <p>Quality of Automatically Extracted Keywords</p>
    <p># of Patterns</p>
    <p>Snort Talos*</p>
    <p>Prefilter-based Hyperscan Reduction</p>
    <p># of Patterns</p>
    <p>Snort ET-Open*</p>
    <p>Prefilter-based Hyperscan Reduction</p>
    <p>* Left vertical axis: # of regex matching process invocations (In logarithmic scale based on 10) * Right vertical axis: reduction of Hyperscan</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 17</p>
    <p>SIMD-based Pattern Matching</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 18</p>
    <p>How to Accelerate Pattern Matching Algorithms?</p>
    <p>Modern CPUs support SIMD (Single Instructions Multiple Data) to exploit data level parallelism</p>
    <p>SIMD instructions can boost database pattern matching by 2x [1]</p>
    <p>Accelerates both multi-string and FA matching with SIMD as the goal</p>
    <p>[1] E. Sitaridi, O. Polychroniou, and K. A. Ross. SIMD-accelerated regular expression matching. In Proceedings of the Workshop on Data Management on New Hardware (DaMoN), 2016</p>
    <p>X2 X1 X0X3</p>
    <p>Y2 Y1 Y0Y3</p>
    <p>X2 OP Y2 X1 OP Y1 X0 OP Y0X3 OP Y3</p>
    <p>OP</p>
    <p>SIMD Register X</p>
    <p>SIMD Register Z</p>
    <p>SIMD Register Y</p>
    <p>OP OP OP</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 19</p>
    <p>Multi-string Pattern Matching Overview</p>
    <p>Extended shift-or matching  Finds candidate input strings that are likely to match some string patterns</p>
    <p>Verification  Filters false positives with hashing  Confirms an exact match with string patterns with the same hash value</p>
    <p>Multi-string Shift-or Matching</p>
    <p>Verification</p>
    <p>Exact Matching</p>
    <p>Candidate Matching Input</p>
    <p>String Pattern</p>
    <p>Hashing</p>
    <p>Input Traffic</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 20</p>
    <p>Shift-or String Matching</p>
    <p>sh-mask(h)</p>
    <p>sh-mask(a)</p>
    <p>sh-mask(p)</p>
    <p>aphp</p>
    <p>lowhigh</p>
    <p>string pattern</p>
    <p>aphpInput</p>
    <p>st-mask 11111111</p>
    <p>m1 (st-mask &lt;&lt; 1) sh-mask(a)</p>
    <p>matching only  Cannot benefit from</p>
    <p>SIMD instructions</p>
    <p>OR</p>
    <p>m2 (m1 &lt;&lt; 1) sh-mask(p)</p>
    <p>m3 (m2 &lt;&lt; 1) sh-mask(h)</p>
    <p>m4 (m3 &lt;&lt; 1) sh-mask(p)</p>
    <p>Match!</p>
    <p>[1] Ricardo A. Baeza-Yates and Gaston H. Gonnet. A new approach to text searching. Communications of the ACM (CACM), 35(10):7482, 1992</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 21</p>
    <p>Multi-string Shift-or Matching</p>
    <p>Pattern grouping: Groups the patterns into N buckets  SIMD acceleration: Uses 128-bit sh-masks with 128-bit SIMD instructions (e.g., pslldq</p>
    <p>for &quot;left shift and por for &quot;or&quot;)</p>
    <p>11111110</p>
    <p>sh-mask(b)</p>
    <p>sh-mask(a)</p>
    <p>sh-mask(c)</p>
    <p>low</p>
    <p>sh-mask(d)</p>
    <p>Padding Bytes</p>
    <p>high</p>
    <p>11111110</p>
    <p>11111110</p>
    <p>11111110</p>
    <p>a b</p>
    <p>c d</p>
    <p>ab</p>
    <p>Bucket 0</p>
    <p>cd</p>
    <p>Bucket 1 Bucket 2 Bucket N</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 22</p>
    <p>Multi-string Shift-or Matching</p>
    <p>hp</p>
    <p>aphp</p>
    <p>sh-mask(a)</p>
    <p>aphp</p>
    <p>sh-mask(p) &lt;&lt; 24</p>
    <p>sh-mask(h) &lt;&lt; 16</p>
    <p>sh-mask(p) &lt;&lt; 8</p>
    <p>sh-mask(a)</p>
    <p>st-mask</p>
    <p>lowhigh</p>
    <p>Bucket 4</p>
    <p>Bucket 0</p>
    <p>Input</p>
    <p>11101110 11111110 11111111 11111111</p>
    <p>11111110 11111110 11101110 11111111</p>
    <p>11111110 11101110 11111111 11101110</p>
    <p>00000000 00000000 00000000 11111111</p>
    <p>11101110 11111111 11101110 00000000</p>
    <p>11101110 11111111 00000000 00000000</p>
    <p>11101110 00000000 00000000 00000000</p>
    <p>sh-mask(h)</p>
    <p>sh-mask(p)</p>
    <p>Match! (bucket = 0, position = 3)Match! (bucket = 4, position = 3)</p>
    <p>11101110 11111110 11111111 11111111</p>
    <p>OR</p>
    <p>Pre-shifting the sh-masks increases instructions per cycle (IPC)!</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 23</p>
    <p>Bit-based NFA Matching</p>
    <p>Uses DFA as much as possible  but often impossible</p>
    <p>Classic NFA is slow - O(m) memory lookups per input character (m = # of current states)</p>
    <p>Represents each state with one bit in a state bit-vector</p>
    <p>Exploits parallel bit operations of SIMD to compute the next states -3</p>
    <p>-1 -13</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 24</p>
    <p>Other Subsystems</p>
    <p>Small string-set (&lt;80) matching</p>
    <p>NFA and DFA cyclic state acceleration</p>
    <p>Small-size DFA matching</p>
    <p>Anchored pattern matching</p>
    <p>Suppression of futile FA matching</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 25</p>
    <p>Evaluation</p>
  </div>
  <div class="page">
    <p>Network Platforms Group</p>
    <p>Evaluation of Hyperscan</p>
    <p>Primary evaluation points:</p>
    <p>Experiment setup:</p>
    <p>Machine: Intel Xeon Platinum 8180 CPU @ 2.50GHz (48 GB of RAM)</p>
    <p>Runs with a single core</p>
    <p>GCC 5.4</p>
    <p>Ruleset: Snort Talos (May 2015), Snort ET-Open 2.9.0, Suricata rulesets 4.0.4</p>
    <p>Workload: random traffic, real-world web traffic</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 27</p>
    <p>Multi-String Matching Performance with Snort ET-Open</p>
    <p>T h</p>
    <p>ro u</p>
    <p>g h</p>
    <p>p u</p>
    <p>t (G</p>
    <p>b p</p>
    <p>s)</p>
    <p>Number of String Patterns1</p>
    <p>T h</p>
    <p>ro u</p>
    <p>g h</p>
    <p>p u</p>
    <p>t (G</p>
    <p>b p</p>
    <p>s)</p>
    <p>Number of String Patterns2</p>
  </div>
  <div class="page">
    <p>Network Platforms Group</p>
    <p>Regex Matching Performance</p>
    <p>Talos ET-Open</p>
    <p>S p</p>
    <p>e e</p>
    <p>d -u</p>
    <p>p b</p>
    <p>y H</p>
    <p>yp e</p>
    <p>rs ca</p>
    <p>n</p>
    <p>Multiple Regex Matching*</p>
    <p>* Test with Snort Talos (1,300 regexes) and ET-Open (2,800 regexes) rulesets under real Web traffic trace.</p>
    <p>Talos ET-Open</p>
    <p>S p</p>
    <p>e e</p>
    <p>d -u</p>
    <p>p b</p>
    <p>y H</p>
    <p>yp e</p>
    <p>rs ca</p>
    <p>n</p>
    <p>Single Regex Matching*</p>
    <p>PCRE RE2 PCRE2</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 29</p>
    <p>Real-world DPI Application - Snort</p>
    <p>Stock Snort (ST-Snort) employs  AC for multi-string matching  PCRE for regex matching  Boyer-Moore algorithm single-string</p>
    <p>matcher</p>
    <p>Hyperscan-ported Snort (HS-Snort) replaced all the algorithms with Hyperscan</p>
    <p>Snort Talos (May 2015) with real-world web traffic</p>
    <p>T h</p>
    <p>ro u</p>
    <p>g h</p>
    <p>p u</p>
    <p>t( M</p>
    <p>b p</p>
    <p>s)</p>
    <p>Snort Performance</p>
    <p>ST-Snort HS-Snort</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 30</p>
    <p>Conclusion</p>
    <p>Regex matching is at the core of DPI applications</p>
    <p>Hyperscans performance advantage is boosted by:</p>
    <p>Novel regex decomposition</p>
    <p>Efficient multi-string matching and bit-based NFA implementation</p>
    <p>Hyperscan achieves significant performance boosts</p>
    <p>3.2x compared to DFC in multi-string matching</p>
    <p>13.5x compared to RE2 in regex matching</p>
    <p>Hyperscan accelerates DPI application Snort by 8.37x</p>
  </div>
  <div class="page">
    <p>Network Platforms Group 31</p>
    <p>Thank You</p>
    <p>Thanks Matt Barr, Alex Coyte and Justin Viiret for their development contribution</p>
    <p>Source code at https://github.com/intel/hyperscan</p>
  </div>
</Presentation>
