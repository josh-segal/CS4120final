<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Approximating Fair Queueing on Reconfigurable Switches</p>
    <p>Naveen Kr. Sharma, Ming Liu, Kishore Atreya, Arvind Krishnamurthy</p>
  </div>
  <div class="page">
    <p>Congestion Control Today</p>
    <p>Primarily achieved using end-to-end protocols (TCP, DCTCP, TIMELY, ..)</p>
    <p>End-hosts react to signals from the network.</p>
    <p>Network does not enforce fair sharing or isolation.</p>
    <p>+ Requires minimal network support</p>
    <p>+ Switches can operate at very high speeds</p>
    <p>- End-host must cooperate to achieve fairness</p>
    <p>- Leads to several inefficiencies and poor isolation</p>
  </div>
  <div class="page">
    <p>Fair Queueing : in-network enforcement</p>
    <p>Enforce fair allocation and isolation at switches</p>
    <p>Provide an illusion that every flow has its own queue</p>
    <p>Proven to have perfect isolation and fairness</p>
    <p>+ Simplifies congestion control at the end-host</p>
    <p>+ Protects against misbehaving traffic</p>
    <p>+ Enables bounded delay guarantees</p>
    <p>However, challenging to realize in high-speed switches.</p>
  </div>
  <div class="page">
    <p>Fair Queueing without per-flow queues</p>
  </div>
  <div class="page">
    <p>Sorted packet buffer</p>
    <p>D</p>
    <p>B</p>
    <p>A</p>
    <p>Fair Queueing without per-flow queues</p>
    <p>Simulates an ideal round-robin scheme where each active flow transmits a single bit of data every round.</p>
    <p>Flow 1</p>
    <p>Flow 2</p>
    <p>Flow 3</p>
    <p>Flow 4</p>
    <p>Ideal fair-queueing</p>
    <p>C</p>
    <p>A, 3B, 5 C, 4</p>
    <p>E</p>
    <p>D, 2E, 7</p>
    <p>Simulated fair-queueing (Demers et.al.)</p>
    <p>Track global round number Round Number</p>
    <p>Flow Counters</p>
  </div>
  <div class="page">
    <p>Rest of the talk</p>
    <p>Background: Reconfigurable Switches</p>
    <p>Our approach: Approximate Fair Queueing</p>
    <p>Optimized End-host Flow Control Protocol</p>
    <p>Prototype Implementation</p>
    <p>Evaluation</p>
  </div>
  <div class="page">
    <p>Reconfigurable Switches</p>
    <p>New class of programmable switches that allow customizable data-plane</p>
    <p>P ro</p>
    <p>g ra</p>
    <p>m m</p>
    <p>a b</p>
    <p>le</p>
    <p>P a</p>
    <p>rs e</p>
    <p>r</p>
    <p>Packet Stream . . .</p>
    <p>TCAM</p>
    <p>SRAM</p>
    <p>REGs .</p>
    <p>. .</p>
    <p>Egress Queues</p>
    <p>TCAM, SRAM for table lookups or matches</p>
    <p>ALUs for modifying headers and registers</p>
    <p>Stateful memory for counter and meters</p>
    <p>port = lookup(eth.dst_mac)</p>
    <p>ipv4.ttl = ipv4.ttl - 1</p>
    <p>counter[ipv4.dst_port]++ .</p>
    <p>. .</p>
    <p>. .</p>
    <p>.</p>
    <p>Match + Action</p>
    <p>ALU</p>
    <p>ALU</p>
    <p>ALU</p>
  </div>
  <div class="page">
    <p>Realizing Fair Queueing on Reconfigurable Switches</p>
    <p>Requirement: O(logN) insertion complexity</p>
    <p>Constraint: Limited operations per packet</p>
    <p>Requirement: Per-flow mutable state</p>
    <p>Constraint: Limited switch memory</p>
    <p>Requirement: Synchronize state across switch modules</p>
    <p>Constraint: Limited cross-module communication</p>
  </div>
  <div class="page">
    <p>Simulated fair-queueing</p>
    <p>Our approach: Approximate Fair Queueing</p>
    <p>Simulate a bit-by-bit round robin scheme with key approximations</p>
    <p>Flow 1</p>
    <p>Flow 2</p>
    <p>Flow 3</p>
    <p>Flow 4</p>
    <p>Ideal fair-queueing</p>
    <p>A</p>
    <p>B</p>
    <p>C</p>
    <p>D</p>
    <p>E ACD</p>
    <p>BE</p>
    <p>Coarse round numbers Limited # of FIFO queues with rotating priorities to approximate a sorted buffer</p>
    <p>Store approximate per-flow counters using a variation of the count-min sketch</p>
  </div>
  <div class="page">
    <p>Storing Approximate Flow Counters</p>
    <p>Variation of count-min sketch to track flows finish round number</p>
    <p>- - - - - - -</p>
    <p>- - - - - - -</p>
    <p>- - - - - - -</p>
    <p>- - - - - - -</p>
    <p>Rpkt</p>
    <p>C hash1( ) % C</p>
    <p>hash2( ) % C</p>
    <p>hashR( ) % C</p>
    <p>update increments all cells; read returns the minimum</p>
    <p>Never under-estimates, has provable space-accuracy trade-off</p>
  </div>
  <div class="page">
    <p>min (0, 1000, 0, 0) = 0 + 500 = 500</p>
    <p>Read Counter</p>
    <p>Find the minimum of all cells</p>
    <p>Bytes sent = minimum + pkt.size</p>
    <p>Update Counter</p>
    <p>Increment all cells upto new value</p>
    <p>cellx,y = max (cellx,y, new value)</p>
    <p>Flow 1</p>
    <p>Flow 2</p>
    <p>size : 1000</p>
    <p>size : 500 500</p>
    <p>Customized to perform combined read-update operation</p>
    <p>Conditional increment upto the new value for better accuracy</p>
    <p>Implemented in hardware using predicated read-write registers</p>
  </div>
  <div class="page">
    <p>Buffering Packets in Approximate Sorted Order</p>
    <p>Coarse rounds: flows transmit a quantum of bytes per round (BpR)</p>
    <p>For each packet, outgoing round number = bytes sent / BpR</p>
    <p>Flow 1</p>
    <p>Flow 2</p>
    <p>Flow N</p>
    <p>Ideal per-flow queues</p>
    <p>A</p>
    <p>B</p>
    <p>D</p>
    <p>C</p>
    <p>K K-1 .. 2 1 0</p>
    <p>AD</p>
    <p>BC</p>
    <p>Round 1</p>
    <p>Round 2</p>
    <p>Round K</p>
    <p>Approximate Fair Queueing</p>
    <p>... K</p>
    <p>FIFO queues</p>
    <p>...</p>
    <p>{BpR</p>
  </div>
  <div class="page">
    <p>Rotating Strict Priority (RSP)</p>
    <p>Drain queue with the lowest round number till it is empty</p>
    <p>Push queue to lowest priority; increment round number by 1</p>
    <p>Flow 1</p>
    <p>Flow 2</p>
    <p>Flow N</p>
    <p>Ideal per-flow queues</p>
    <p>A</p>
    <p>B</p>
    <p>D</p>
    <p>C AD</p>
    <p>BC</p>
    <p>Round 1</p>
    <p>Round 2</p>
    <p>Round K</p>
    <p>...</p>
    <p>Highest Priority</p>
    <p>Lowest Priority</p>
    <p>Approximate Fair Queueing</p>
    <p>K K-1 .. 2 1 0</p>
    <p>...</p>
  </div>
  <div class="page">
    <p>Realizing an RSP Scheduler</p>
    <p>RSP can be implemented in hardware</p>
    <p>Identical complexity to a Deficit Round Robin scheduler</p>
    <p>RSP can be emulated on current switches</p>
    <p>Switch CPU to periodically change priorities</p>
    <p>Hierarchical priority queues</p>
    <p>Avoid explicit round number synchronization by exposing queue metadata</p>
    <p>Utilize dynamic buffer sharing to vary size of individual queues</p>
  </div>
  <div class="page">
    <p>Summary of Techniques</p>
    <p>+ Counters for large number of flows in limited memory</p>
    <p>- Collisions cause packets to enqueue in a later round</p>
    <p>+ Process packets in fixed number of operations</p>
    <p>- Packets can be reordered within a round</p>
    <p>+ Updates to shared state are not per-packet anymore</p>
    <p>- Packets can enqueue in an earlier round</p>
  </div>
  <div class="page">
    <p>Enhancing AFQ with End-host Flow Control</p>
    <p>AFQ can be deployed without modifying end-hosts.</p>
    <p>Adapt the packet-pair algorithm [Keshav, 91] to gain even more benefits.</p>
    <p>Sender transmits a pair of back-to-back packets.</p>
    <p>Inter-arrival delay is an estimate of the bottleneck bandwidth.</p>
    <p>End-hosts send packets at estimated rate.</p>
    <p>Lets us perform fast ramp-up and keep small queue sizes.</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Does AFQ improve overall performance?</p>
    <p>What is the impact of approximations?</p>
    <p>Can AFQ deal with incast traffic patterns?</p>
    <p>How many FIFO queues are sufficient?</p>
    <p>What size count-min sketch is required?</p>
    <p>How do we set the BpR parameter?</p>
    <p>In the paper</p>
    <p>This talk</p>
  </div>
  <div class="page">
    <p>Prototype Implementation</p>
    <p>Built a 4-port AFQ switch atop a Cavium Network Processor.</p>
    <p>Pipelines run on MIPS CPU; packets &amp; counters stored in DRAM.</p>
    <p>Each port runs at 10gbps with 32 FIFO queues and 4x16k sketch.</p>
    <p>Tested on a 2-level fat-tree topology.</p>
    <p>Implemented packet-pair flow control in user space.</p>
  </div>
  <div class="page">
    <p>Testbed Results</p>
    <p>Normalized Flow</p>
    <p>Completion Time</p>
    <p>Flow size (in bytes)</p>
    <p>TCP DCTCP AFQ</p>
    <p>Average</p>
    <p>Compared to TCP, 4x better average FCT, 10x better tail latency.</p>
    <p>Compared to DCTCP, 2x better average FCT, 4x better tail latency.</p>
  </div>
  <div class="page">
    <p>Simulation Results: Comparison to Fair Queueing</p>
    <p>Average FCT in s</p>
    <p>Network Load (%)</p>
    <p>All Flows</p>
    <p>Network Load (%)</p>
    <p>Short Flows &lt; 100 KB</p>
    <p>TCP</p>
    <p>DCTCP</p>
    <p>SFQ</p>
    <p>AFQ</p>
    <p>Ideal FQ</p>
  </div>
  <div class="page">
    <p>Other Results</p>
    <p>Accurate approximation achieved using 12 to 16 FIFO queues.</p>
    <p>Less than 10% extra resource overhead on top of switch.p4.</p>
    <p>Significant improvement even with existing end-host protocols.</p>
    <p>Provides ideal fairness during incast traffic patterns.</p>
    <p>Reduces drops and retransmissions by 10x compared to DCTCP.</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Practical implementation of Fair Queueing at line-rate.</p>
    <p>Use approximation techniques to overcome hardware constraints.</p>
    <p>Modified sketch to store per-flow counters</p>
    <p>Leverage limited FIFO queues to approximate sorted buffer</p>
    <p>Approximations are both effective and accurate.</p>
    <p>Leads to 4-8x improvement in flow completion times.</p>
  </div>
</Presentation>
