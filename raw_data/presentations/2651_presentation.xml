<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Maglev A Fast and Reliable Network Load Balancer</p>
    <p>Daniel E. Eisenbud, Cheng Yi, Carlo Contavalli, Cody Smith,</p>
    <p>Roman Kononov, Eric Mann-Hielscher, Ardas Cilingiroglu,</p>
    <p>Bin Cheyney, Wentao Shang, Jinnah Dylan Hosein</p>
  </div>
  <div class="page">
    <p>Maglev the Network Load Balancer  What is a Network Load Balancer?</p>
    <p>Why Maglev?</p>
    <p>Maglev design</p>
    <p>Evaluation</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>Maglev the Network Load Balancer  What is a Network Load Balancer?</p>
    <p>Why Maglev?</p>
    <p>Maglev design</p>
    <p>Evaluation</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>What is a network load balancer?</p>
    <p>Google</p>
    <p>VIP Endpoints</p>
    <p>DNS</p>
    <p>VIP</p>
  </div>
  <div class="page">
    <p>What is a network load balancer?</p>
    <p>Network Load Balancer</p>
    <p>Google</p>
  </div>
  <div class="page">
    <p>What is a network load balancer?</p>
    <p>Network Load Balancer</p>
    <p>Google</p>
  </div>
  <div class="page">
    <p>What do we need from a network LB?  Balance load evenly</p>
    <p>Reliability: do not reset user connections</p>
    <p>Flexibility: iterate quickly</p>
    <p>Scalability: grow with cloud scale</p>
    <p>Efficiency: deliver high performance per dollar</p>
  </div>
  <div class="page">
    <p>Maglev the Network Load Balancer  What is a Network Load Balancer?</p>
    <p>Why Maglev?</p>
    <p>Maglev design</p>
    <p>Evaluation</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>Limitation of hardware appliances  Poor flexibility</p>
    <p>Scaling is hard</p>
    <p>Active-passive failover</p>
    <p>Expensive at scale</p>
  </div>
  <div class="page">
    <p>Why Maglev?  In 2008, hit wall with existing appliance solution</p>
    <p>Key insight: replace inflexible dedicated hardware</p>
    <p>With software running on existing servers</p>
    <p>Scalable deployment model</p>
    <p>Virtualize the network function</p>
    <p>Global control plane: SDN</p>
  </div>
  <div class="page">
    <p>Runs on existing servers</p>
    <p>Maglev</p>
    <p>Endpoints</p>
    <p>Google</p>
  </div>
  <div class="page">
    <p>Scalability  Huge scale in two dimensions:</p>
    <p>Scale out across many servers with ECMP</p>
    <p>Scale up to 10G line rate with kernel bypass</p>
    <p>Even with very small packets; limited only by NIC</p>
    <p>Enables cloud-scale control plane</p>
  </div>
  <div class="page">
    <p>Scalability</p>
    <p>Maglev</p>
    <p>Endpoints</p>
    <p>Google</p>
  </div>
  <div class="page">
    <p>Scalability</p>
    <p>...</p>
    <p>Maglev</p>
    <p>Endpoints</p>
    <p>Google</p>
  </div>
  <div class="page">
    <p>Maglev the Network Load Balancer  What is a Network Load Balancer?</p>
    <p>Why Maglev?</p>
    <p>Maglev design</p>
    <p>Evaluation</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>Maglev design challenges  Reliability: keep connections alive</p>
    <p>When set of Maglevs changes</p>
    <p>When set of backends changes</p>
    <p>Both at once with consistent hashing!</p>
    <p>Scaling</p>
    <p>Scaling out with ECMP</p>
    <p>Scaling up with kernel bypass 16</p>
  </div>
  <div class="page">
    <p>Maglev design challenges  Reliability: keep connections alive</p>
    <p>When set of Maglevs changes</p>
    <p>When set of backends changes</p>
    <p>Both at once with consistent hashing!</p>
    <p>Scaling</p>
    <p>Scaling out with ECMP</p>
    <p>Scaling up with kernel bypass 17</p>
  </div>
  <div class="page">
    <p>Reliability when set of Maglevs changes  Reasons this happens</p>
    <p>Health change of a Maglev</p>
    <p>Adding or removing Maglev capacity</p>
    <p>ECMP change sends most connections to different Maglev</p>
    <p>Can't share connection state</p>
    <p>Can't do round-robin</p>
    <p>Hashing on 5-tuple solves the problem 18</p>
  </div>
  <div class="page">
    <p>Steady state</p>
    <p>hash1(p) % 4</p>
    <p>hash2(p) % 6</p>
    <p>hash1(p) = 5</p>
    <p>hash2(p) = 7 0 1 2 3</p>
  </div>
  <div class="page">
    <p>Maglev set changes</p>
    <p>hash1(p) % 3</p>
    <p>hash2(p) % 6</p>
    <p>hash1(p) = 5</p>
    <p>hash2(p) = 7 0 1 2 3</p>
  </div>
  <div class="page">
    <p>Reliability when set of backends changes  Reasons this happens</p>
    <p>Health change of a backend</p>
    <p>Adding or removing backend capacity</p>
    <p>Hash space gets remapped</p>
    <p>Need to do connection tracking</p>
    <p>Plenty of memory even in worst case</p>
  </div>
  <div class="page">
    <p>Steady state</p>
    <p>hash1(p) % 4hash1(p) = 5</p>
    <p>hash2(p) = 7 0 1 2 3</p>
    <p>if existing connection: use connection tracking</p>
    <p>else: hash2(p) % 6</p>
  </div>
  <div class="page">
    <p>Backend set changes</p>
    <p>hash1(p) % 4hash1(p) = 5</p>
    <p>hash2(p) = 7 0 1 2 3</p>
    <p>if existing connection: use connection tracking</p>
    <p>else: hash2(p) % 5</p>
  </div>
  <div class="page">
    <p>Both at once!  ECMP change ruins Maglev affinity</p>
    <p>New Maglev does not have connection table entry</p>
    <p>Standard hashing: backend change ruins backend affinity</p>
    <p>Any backend change resets most connections</p>
  </div>
  <div class="page">
    <p>Steady state</p>
    <p>hash1(p) % 4hash1(p) = 5</p>
    <p>hash2(p) = 7 0 1 2 3</p>
    <p>if existing connection: use connection tracking</p>
    <p>else: hash2(p) % 6</p>
  </div>
  <div class="page">
    <p>Everything changes</p>
    <p>if existing connection: use connection tracking</p>
    <p>else: hash2(p) % 5</p>
    <p>hash1(p) % 3hash1(p) = 5</p>
    <p>hash2(p) = 7 0 1 2 3</p>
  </div>
  <div class="page">
    <p>Consistent hashing  Consistent hashing is the answer</p>
    <p>Given similar inputs, will produce similar assignments</p>
    <p>Does not depend on backend history</p>
    <p>ECMP change will not cause many resets</p>
    <p>Even with minor (routine) backend changes</p>
  </div>
  <div class="page">
    <p>Steady state</p>
    <p>hash1(p) % 4</p>
    <p>hash1(p) = 5</p>
    <p>consistent_hash(p) = 1</p>
    <p>if existing connection: use connection tracking</p>
    <p>else: consistent_hash(p)</p>
  </div>
  <div class="page">
    <p>Saved by consistent hashing</p>
    <p>if existing connection: use connection tracking</p>
    <p>else: consistent_hash(p)</p>
    <p>hash1(p) % 3hash1(p) = 5</p>
    <p>consistent_hash(p) = 1 0 1 2 3</p>
  </div>
  <div class="page">
    <p>Operational wins of consistent hashing  Need to be able to upgrade Maglev binary</p>
    <p>With consistent hashing, we can just do a rolling restart</p>
    <p>No need to DNS drain traffic first</p>
    <p>If a backend flaps during this, minimal impact</p>
  </div>
  <div class="page">
    <p>Consistent hashing algorithms  Two good algorithms from '90s</p>
    <p>Work well with small backend sets</p>
    <p>With large backend sets (~1000), require huge tables</p>
    <p>So we invented our own</p>
    <p>Trades off a little consistency for very even balance</p>
  </div>
  <div class="page">
    <p>Maglev Consistent Hashing  Hash every backend to preference list of table positions</p>
    <p>Prime table size P for easy computation</p>
    <p>Hash every backend to (offset, skip)  [0, P-1]  [1, P-1]</p>
    <p>Each backend's i'th preference is (offset + i  skip) mod P</p>
    <p>Backends take turns claiming most-preferred empty bucket</p>
  </div>
  <div class="page">
    <p>Consistent hashing example B0 B1 B2</p>
    <p>Offset 3 0 3</p>
    <p>Skip 4 2 1</p>
    <p>B0 B1 B2</p>
    <p>Permutation Table</p>
    <p>permutation[i] = (offset + i * skip) % 7</p>
  </div>
  <div class="page">
    <p>Consistent hashing example B0 B1 B2</p>
    <p>Offset 3 0 3</p>
    <p>Skip 4 2 1</p>
    <p>B0 B1 B2</p>
    <p>Permutation Table</p>
    <p>permutation[i] = (offset + i * skip) % 7</p>
  </div>
  <div class="page">
    <p>Consistent hashing example B0 B1 B2</p>
    <p>Offset 3 0 3</p>
    <p>Skip 4 2 1</p>
    <p>B0 B1 B2</p>
    <p>Permutation Table</p>
    <p>permutation[i] = (offset + i * skip) % 7</p>
  </div>
  <div class="page">
    <p>Consistent hashing example B0 B1 B2</p>
    <p>Offset 3 0 3</p>
    <p>Skip 4 2 1</p>
    <p>B0 B1 B2</p>
    <p>permutation[i] = (offset + i * skip) % 7</p>
    <p>Permutation Table</p>
  </div>
  <div class="page">
    <p>Consistent hashing example B0 B1 B2</p>
    <p>Offset 3 0 3</p>
    <p>Skip 4 2 1</p>
    <p>B0 B1 B2</p>
    <p>Permutation Table</p>
    <p>permutation[i] = (offset + i * skip) % 7</p>
  </div>
  <div class="page">
    <p>Consistent hashing example</p>
    <p>Lookup Table</p>
    <p>B0 B1 B2</p>
    <p>Permutation Table</p>
  </div>
  <div class="page">
    <p>Consistent hashing example</p>
    <p>Lookup Table</p>
    <p>B0 B1 B2</p>
    <p>Permutation Table</p>
  </div>
  <div class="page">
    <p>Consistent hashing example</p>
    <p>Lookup Table</p>
    <p>B0 B1 B2</p>
    <p>Permutation Table</p>
  </div>
  <div class="page">
    <p>Consistent hashing example</p>
    <p>Lookup Table</p>
    <p>B0 B1 B2</p>
    <p>Permutation Table</p>
  </div>
  <div class="page">
    <p>Consistent hashing example</p>
    <p>Lookup Table</p>
    <p>B0 B1 B2</p>
    <p>Permutation Table</p>
  </div>
  <div class="page">
    <p>Consistent hashing example</p>
    <p>Lookup Table</p>
    <p>B0 B1 B2</p>
    <p>Permutation Table</p>
  </div>
  <div class="page">
    <p>Consistent hashing example</p>
    <p>Lookup Table</p>
    <p>B0 B1 B2</p>
    <p>Permutation Table</p>
  </div>
  <div class="page">
    <p>Consistent hashing example</p>
    <p>Lookup Table</p>
    <p>B0 B1 B2</p>
    <p>Permutation Table</p>
  </div>
  <div class="page">
    <p>Consistent hashing example</p>
    <p>Lookup Table</p>
    <p>B0 B1 B2</p>
    <p>Permutation Table</p>
  </div>
  <div class="page">
    <p>Consistent hashing example Lookup Table</p>
    <p>B0 B1 B2</p>
    <p>Permutation Table</p>
    <p>Before After</p>
  </div>
  <div class="page">
    <p>Maglev design challenges  Reliability: keep connections alive</p>
    <p>When set of Maglevs changes</p>
    <p>When set of backends changes</p>
    <p>Both at once with consistent hashing!</p>
    <p>Scaling</p>
    <p>Scaling out with ECMP</p>
    <p>Scaling up with kernel bypass 48</p>
  </div>
  <div class="page">
    <p>Scaling out with ECMP  Use SDN switches with 256-way L3 ECMP</p>
    <p>Consistent hashing above makes for easy maintenance</p>
  </div>
  <div class="page">
    <p>Scale up with Kernel Bypass  Linux kernel was a bottleneck</p>
    <p>Each machine needs to be fast for Maglev to be cheap</p>
    <p>Send/receive packets directly between user space and NIC</p>
    <p>Can go at 10G line rate</p>
    <p>Hashes packets across multiple queues</p>
    <p>Round robin overflow if queue fills up</p>
  </div>
  <div class="page">
    <p>Bringing it all together</p>
    <p>miss</p>
    <p>activemark</p>
    <p>Drop</p>
    <p>Connection Tracking</p>
    <p>Consistent Hashing</p>
    <p>Encap</p>
    <p>hit miss</p>
    <p>add</p>
    <p>VIP Matching</p>
    <p>Muxing</p>
    <p>Packet Rewriter</p>
    <p>RX Queue</p>
    <p>TX Queue</p>
    <p>NIC</p>
    <p>Steering</p>
  </div>
  <div class="page">
    <p>Maglev the Network Load Balancer  What is a Network Load Balancer?</p>
    <p>Why Maglev?</p>
    <p>Maglev design</p>
    <p>Evaluation</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>Consistent hashing evenness</p>
  </div>
  <div class="page">
    <p>Consistent hashing consistency</p>
  </div>
  <div class="page">
    <p>Load balancing</p>
  </div>
  <div class="page">
    <p>Kernel bypass performance</p>
  </div>
  <div class="page">
    <p>Maglev the Network Load Balancer  What is a Network Load Balancer?</p>
    <p>Why Maglev?</p>
    <p>Maglev design</p>
    <p>Evaluation</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>Conclusion  Maglev is a fast and reliable network load balancer</p>
    <p>ECMP, connection tracking, and consistent hashing</p>
    <p>combine to scale out reliably</p>
    <p>Kernel bypass gives performance needed to make software</p>
    <p>network LB economical</p>
    <p>Software is a good place for stateful network functions</p>
  </div>
</Presentation>
