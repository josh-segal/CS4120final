<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>CONIKS</p>
    <p>Marcela Melara</p>
    <p>Aaron Blankstein, Joseph Bonneau*, Edward W. Felten, Michael J. Freedman</p>
    <p>Princeton University, *Stanford University/EFF</p>
    <p>BRINGING KEY TRANSPARENCY TO END USERS</p>
  </div>
  <div class="page">
    <p>E2E Encrypted Communication Today</p>
    <p>Users growing demand for E2E secure communication</p>
    <p>Known problem: Key management is difficult for users</p>
  </div>
  <div class="page">
    <p>Unsolved: How do users establish trust?</p>
    <p>Trust establishment = Learn &amp; verify the other partys key</p>
    <p>Goal: Establish secure communication channel</p>
  </div>
  <div class="page">
    <p>Out-of-Band Trust Est. = Unintuitive</p>
    <p>Bob, is DEF123 your public key?</p>
    <p>Alice Bob</p>
    <p>Alice, whats a public key?</p>
    <p>Requires users to reason about encryption/keys  unintuitive, error-prone!</p>
  </div>
  <div class="page">
    <p>Trust Est. by the Provider  Better?</p>
    <p>Clients query provider for others keys</p>
    <p>Users dont worry about or see keys</p>
    <p>Caveat: Users must trust provider unconditionally</p>
  </div>
  <div class="page">
    <p>Register (alice  PKA)</p>
    <p>Malicious Provider can Equivocate</p>
    <p>Secure Messaging Provider</p>
    <p>Client A</p>
    <p>Alice</p>
    <p>Client B</p>
    <p>Bob</p>
    <p>Equivocation = Presenting diverging views to different clients.</p>
    <p>This isnt alices real key!</p>
  </div>
  <div class="page">
    <p>Pros/Cons of Existing Trust Establishment</p>
    <p>Users verify keys out of band</p>
    <p>Providers establish trust for users</p>
    <p>Security</p>
    <p>Usability</p>
    <p>Challenge: How can we get the best of both worlds?</p>
  </div>
  <div class="page">
    <p>Ideal Trust Establishment Properties</p>
  </div>
  <div class="page">
    <p>Existing Approach: Verifying Correctness</p>
    <p>Correctness = Expected real-world person controls online nameto-public key binding</p>
    <p>Problem: Requires out-of-band communication</p>
  </div>
  <div class="page">
    <p>Our Approach: Verifying Consistency</p>
    <p>Consistency = 1. Alices key today = Alices key yesterday 2. Alices key seen by Alice = Alices key seen by everyone else</p>
    <p>Benefit: Can be enforced via crypto  Providers manage consistent keys  Automation</p>
  </div>
  <div class="page">
    <p>Solution: CONIKS</p>
    <p>Automated trust establishment with untrusted providers</p>
    <p>Clients verify consistency of bindings</p>
    <p>Goal: Make provider equivocation easily detectable</p>
  </div>
  <div class="page">
    <p>CONIKS  Registering a Key</p>
    <p>Iden:ty Provider</p>
    <p>Client A</p>
    <p>Client B</p>
    <p>Alice Bob</p>
    <p>Register (alice  PKA)</p>
  </div>
  <div class="page">
    <p>CONIKS  Learning a Users Key</p>
    <p>Iden:ty Provider Public key for alice: PKA</p>
    <p>Encrypt msg using PKA</p>
    <p>Client A</p>
    <p>Client B</p>
    <p>Alice Bob</p>
    <p>Verify consistency</p>
    <p>of PKA</p>
  </div>
  <div class="page">
    <p>Strawman Consistency Checks: Verify All Bindings</p>
    <p>Iden:ty Provider</p>
    <p>Client A</p>
    <p>Client B</p>
    <p>Client C</p>
    <p>Client D N = 4</p>
    <p>Unexpected Changes Checks O(N) storage per client</p>
    <p>Consistent View Checks O(N2) downloads per client</p>
  </div>
  <div class="page">
    <p>CONIKS: Efficient Checks thru Summaries</p>
    <p>Providers generate directory summaries  Clients dont verify all bindings</p>
    <p>Bindings stored in Merkle prefix trees  Tree root = Summary of all bindings  Tamper-evident directory</p>
    <p>Non-repudiation: Signed tree root (STR)  Undeniable statement about tree contents</p>
    <p>alices binding</p>
    <p>H(child0) H(child1)</p>
    <p>H(child0) H(child1)</p>
    <p>roott</p>
    <p>H(child0) H(child1)</p>
    <p>bobs binding</p>
    <p>emilys binding</p>
    <p>johns binding</p>
  </div>
  <div class="page">
    <p>CONIKS  Main Security Properties</p>
  </div>
  <div class="page">
    <p>Why? Evidence for fake keys</p>
    <p>How? Authentication path = proof of inclusion  Pruned Merkle tree from binding to root</p>
    <p>Verification: recomputed root = STR  O(log n) for tree with n bindings</p>
    <p>alices binding</p>
    <p>H(child0) H(child1)</p>
    <p>H(child0) H(child1)</p>
    <p>roott</p>
  </div>
  <div class="page">
    <p>Compare PKA to previous version, verify auth path, Verify STR signature</p>
    <p>Iden:ty Provider</p>
    <p>Client B</p>
    <p>Bob</p>
    <p>PKA + Auth Path</p>
    <p>+ Signed Tree Root</p>
    <p>Lookup PK for alice</p>
    <p>Important: Clients also regularly monitor their own users binding.</p>
    <p>Alice</p>
  </div>
  <div class="page">
    <p>Why? Detect provider attempt to MITM</p>
    <p>How? Building verifiable STR history</p>
    <p>Hash chain  commitment to all STRs</p>
    <p>Verification: previous STR is incl. in next STR</p>
    <p>ialice: alices binding</p>
    <p>H(child0) H(child1)</p>
    <p>H(child0) H(child1) roott</p>
    <p>H(child0) H(child1)</p>
    <p>ibob: bobs binding</p>
    <p>iemily: emilys binding</p>
    <p>ijohn: johns binding</p>
    <p>H(seed) root0</p>
    <p>S0</p>
    <p>Sig(S0)</p>
    <p>H(St-2) roott-1</p>
    <p>St-1</p>
    <p>Sig(St-1)</p>
    <p>H(St-1) roott</p>
    <p>St</p>
    <p>Sig(St)</p>
  </div>
  <div class="page">
    <p>Checking hash chain not enough:</p>
    <p>H(seed) root0</p>
    <p>S0 Sig(S0)</p>
    <p>H(St-2) roott-1</p>
    <p>St-1 Sig(St-1)</p>
    <p>H(St-1) roott</p>
    <p>St Sig(St)</p>
    <p>H(St-2) roott-1</p>
    <p>St-1 Sig(St-1)</p>
    <p>H(St-1) roott</p>
    <p>St Sig(St)</p>
    <p>Client A</p>
    <p>Client B</p>
  </div>
  <div class="page">
    <p>Verify hash chain Verify hash chain</p>
    <p>Iden:ty Provider</p>
    <p>Client A</p>
    <p>Client B</p>
    <p>Alice Bob</p>
    <p>H(St-1) roott</p>
    <p>St Sig(St)</p>
    <p>H(St-1) roott</p>
    <p>St Sig(St)</p>
    <p>H(St-1) roott</p>
    <p>St Sig(St)</p>
    <p>H(St-1) roott</p>
    <p>St Sig(St)</p>
    <p>Iden:ty Provider Iden:ty Provider</p>
    <p>Verify hash chain</p>
    <p>St Sig(St)</p>
    <p>Compare different views 4</p>
  </div>
  <div class="page">
    <p>Privacy Challenges in CONIKS</p>
    <p>Addressed through practical crypto tricks!</p>
  </div>
  <div class="page">
    <p>Main Performance Questions</p>
    <p>Does our server design scale to the size of a typical user base</p>
    <p>(thousands  billions)?</p>
    <p>Are CONIKS consistency checks efficient enough to run on todays mobile devices?</p>
    <p>Does CONIKS integrate well with existing E2E services?</p>
  </div>
  <div class="page">
    <p>CONIKS Performance is Practical!</p>
    <p>Server scales to tens of millions of users on single machine  Inserting 1K new bindings into 10M-user tree: 2.6ms</p>
    <p>Client consistency checks need little bandwidth/storage</p>
    <p>Max. bandwidth requirements &lt; 20kB per day  Proof of concept: Integration with Pidgin OTR plug-in</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Main idea: Users should not have to manage keys, but service</p>
    <p>providers should not be trusted either.</p>
    <p>CONIKS: Security through consistency  more practical</p>
    <p>Yahoo &amp; Google adopting CONIKS in their E2E systems</p>
  </div>
  <div class="page">
    <p>Q&amp;A More Info: Website: www.coniks.org Ref. Implementation: github.com/coniks-sys</p>
    <p>We thank: Yan Zhu (Yahoo) Gary Belvin (Google) Trevor Perrin (TextSecure) David Gil (formerly Yahoo)</p>
  </div>
</Presentation>
