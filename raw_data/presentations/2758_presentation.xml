<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>FLP Semantics without Circular Justifications for General Logic Programs</p>
    <p>Yi-Dong Shen 1 Kewen Wang 2</p>
    <p>AAAI 2012, Toronto, Canada</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Answer set programming (ASP) is a major logic programming paradigm for knowledge representation and reasoning.</p>
    <p>As summarized by [Lif10], there have been thirteen different definitions of answer sets in the literature.</p>
    <p>In this paper, we are devoted to a currently widely used definition of answer sets, called</p>
    <p>FLP semantics [FLP04]</p>
    <p>Let  be a normal logic program with rules of the form A0  A1,    , Am, not Am+1,    , not An</p>
    <p>where each Ai is an atom. Given an interpretation I , the FLP reduct of  w.r.t. I , denoted f I , consists of all rules in ground() whose bodies are satisfied by I . I is an FLP answer set of  if I is a minimal model of f I .</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>It was recently observed that when applied to more general logic programs, the FLP semantics may produce unintuitive answer sets with circular justifications caused by self-supporting loops [SY09, LPST10, She11, SW11].</p>
    <p>Circular justifications of the FLP semantics</p>
    <p>Consider the following general logic program [BLM11]:</p>
    <p>1 : p(2)  p(2)  (p(1) p(1)). r1 p(1) p(1) p(1) p(2). r2 p(1)  p(1). r3</p>
    <p>Let I = {p(1), p(1)} be an interpretation. The FLP reduct of 1 w.r.t. I is f I1 = {r2, r3}. I is a minimal model of f</p>
    <p>I 1 and thus is</p>
    <p>an answer set of 1 under the FLP semantics. Observe that this FLP answer set has circular justifications caused by the following self-supporting loop:</p>
    <p>p(1)  p(1) p(1) p(1) p(2)  p(1)</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>In this paper, we address the circular justification problem for general logic programs by enhancing the FLP semantics with a level mapping formalism.</p>
    <p>In particular, we extend the Gelfond-Lifschitz three step definition of the standard answer set semantics from normal logic programs to general logic programs and define for general logic programs the first FLP semantics that is free of circular justifications. We call this FLP semantics the well-justified FLP semantics.</p>
    <p>This method naturally extends to general logic programs with additional constraints like aggregates, thus providing a unifying framework for defining the well-justified FLP semantics for different types of logic programs.</p>
  </div>
  <div class="page">
    <p>General Logic Programs</p>
    <p>Rules</p>
    <p>A rule is of the form H  B, where H and B are first-order formulas. Such a rule r expresses an if-then statement, saying that if the logic property B holds then infer H.</p>
    <p>General logic programs [BLM11]</p>
    <p>A general logic program  (also called a logic program with first-order formulas) consists of a finite set of rules.  is a normal logic program if each rule r is of the form</p>
    <p>A0  A1  ...Am Am+1  ...An where each Ai is an atom without equality and function symbols. A positive logic program is a normal logic program without negative literals.</p>
  </div>
  <div class="page">
    <p>General Logic Programs</p>
    <p>Grounding</p>
    <p>Let C C be a non-empty, finite set of constants including all constants occurring in . A closed instance of a rule is obtained by replacing every free variable in the rule with a constant in C. The grounding of  w.r.t. C, denoted ground(), is the set of closed instances of all rules in .</p>
    <p>Satisfaction</p>
    <p>An interpretation I satisfies a closed instance r of a rule if it satisfies head(r) or it does not satisfy body(r). I is a model of a logic program  if it satisfies all rules in ground().</p>
  </div>
  <div class="page">
    <p>FLP Semantics of General Logic Programs</p>
    <p>Definition 1</p>
    <p>Let  be a general logic program and I an interpretation. The FLP-reduct of  w.r.t. I is</p>
    <p>f I = {r  ground() | I satisfies body(r)}. I is an FLP answer set of  if I is a minimal model of f I .</p>
    <p>** This FLP semantics for general logic programs is reformulated by [BLM11] in terms of a modified circumscription.</p>
  </div>
  <div class="page">
    <p>Well-Justified FLP Answer Sets</p>
    <p>Key points:</p>
    <p>Rules H  B in a logic program differ essentially from implications B  H in classical logic because rules define a level mapping on their answer sets s.t. answers at upper levels are derived from answers at lower levels by applying the rules in the way that if the rule bodies hold then infer the heads.</p>
    <p>However, the FLP semantics is unable to capture such a level mapping. For I to be an answer set of , the FLP semantics only requires I to be a minimal model of f I . This amounts to treating all rules H  B in f I as implications B  H in classical logic because I is a model of the rules H  B in f I if and only if I is a model of the corresponding implications B  H in classical logic. Since classical implications define no level mapping on their models, some minimal models of f I</p>
    <p>may have no level mapping and thus some FLP answer sets may have circular justifications.</p>
  </div>
  <div class="page">
    <p>Well-Justified FLP Answer Sets</p>
    <p>Therefore, the key to overcome the circular justification problem is to enhance the FLP semantics with a level mapping formalism whereby the FLP reduct is treated as rules instead of classical implications.</p>
    <p>To achieve this, let us first look at how the standard answer set semantics builds a level mapping for its answer sets from normal logic programs.</p>
    <p>** For an interpretation I , We denote I for H \ I , and I for {A | A  I}, where H is the set of ground atoms of the signature .</p>
  </div>
  <div class="page">
    <p>Well-Justified FLP Answer Sets</p>
    <p>Let  be a normal logic program and I an interpretation.</p>
    <p>Three step definition of the standard answer set semantics [GL88]</p>
    <p>** All negative literals removed in the second step are in I . The remaining part of ground() after the two steps of transformation is</p>
    <p>called the Gelfond-Lifschitz reduct, denoted I .</p>
    <p>() from I via T i I</p>
    <p>()i=0, where T 0</p>
    <p>I () =  and for i  0 T i+1</p>
    <p>I () = TI (T iI ()).</p>
    <p>** TP (S), where P is a positive logic program and S a set of ground atoms, is the van Emden-Kowalski provability operator [vEK76] defined by</p>
    <p>TP (S) = {head(r)|r  ground(P) such that body(r) is satisfied by S}.</p>
    <p>Then, I is an answer set of  if I = T  I</p>
    <p>(). 10 / 20 Y. D. Shen and K. W. Wang FLP Semantics without Circular Justifications</p>
  </div>
  <div class="page">
    <p>Well-Justified FLP Answer Sets</p>
    <p>Note that the derivation sequence T i I</p>
    <p>()i=0 defines a level mapping on I such that A  I is at level i &gt; 0 if A  T i</p>
    <p>I ()</p>
    <p>but A 6 T i1 I</p>
    <p>(). As a result, for any A  I at level i there is a rule r  ground() whose head is A such that all negative literals in neg(r) are in I and all positive literals in pos(r) are in T i1</p>
    <p>I ().</p>
  </div>
  <div class="page">
    <p>Well-Justified FLP Answer Sets</p>
    <p>The above Gelfond-Lifschitz three step definition of answer sets for normal logic programs is not applicable to general logic programs, since rule heads and bodies of a general logic program are arbitrary first-order formulas.</p>
    <p>To deal with arbitrary first-order formulas in rule heads and bodies in a general logic program, we propose to extend the above Gelfond-Lifschitz three step definition of answer sets to general logic programs.</p>
  </div>
  <div class="page">
    <p>Well-Justified FLP Answer Sets</p>
    <p>Let  be a general logic program and I an interpretation.</p>
    <p>Extension of the three step definition of answer sets</p>
  </div>
  <div class="page">
    <p>Well-Justified FLP Answer Sets</p>
    <p>Define Oii=0 using a one-step provability operator: We extend the van Emden-Kowalski operator TP (S), which is applicable only to a positive logic program P parameterized with a set S of ground atoms, to a new operator T(O, N), which is applicable to a general logic program  parameterized with two first-order theories O and N.</p>
    <p>Intuitively, by applying T(O, N) we infer all rule heads from ground() whose rule bodies are true in O under the constraints N.</p>
    <p>Formally we define</p>
    <p>T(O, N) = {head(r) | r  ground() s.t.O N |= body(r)}. Therefore, we can apply the operator T(O, N) to define Oii=0 by letting O</p>
    <p>i = T i f I</p>
    <p>(,I) and O = T  f I</p>
    <p>(,I).</p>
  </div>
  <div class="page">
    <p>Well-Justified FLP Answer Sets</p>
    <p>Properties of T i f I</p>
    <p>(,I):</p>
    <p>Theorem</p>
    <p>Let I be a model of a general logic program . For any i  0, T i(,I</p>
    <p>) = T i f I</p>
    <p>(,I) and thus T  (,I ) = T</p>
    <p>f I (,I).</p>
    <p>Theorem</p>
    <p>Let I be a model of a normal logic program . For any i  0, T i</p>
    <p>I () = T i(,I</p>
    <p>) and thus T  I</p>
    <p>() = T  (,I ).</p>
    <p>Corollary</p>
    <p>A model I of a normal logic program  is an answer set under the standard answer set semantics if and only if I = T</p>
    <p>I () if and only</p>
    <p>if I = T  (,I ) if and only if I = T</p>
    <p>f I (,I).</p>
  </div>
  <div class="page">
    <p>Well-Justified FLP Answer Sets</p>
    <p>We use T  (,I ) to define answer sets:</p>
    <p>Definition of the well-justified FLP semantics</p>
    <p>Let I be a model of a general logic program . I is a well-justified FLP answer set of  if for each A  I , T</p>
    <p>f I (,I) I |= A.</p>
    <p>Example</p>
    <p>Consider the general logic program 1 in the introduction. I = {p(1), p(1)} is a model of 1 and is also an FLP answer set. I contains p(2). T</p>
    <p>f I1 (,I) = . Neither p(1)  I nor</p>
    <p>p(1)  I can be proved true in T  f I1</p>
    <p>(,I) under the constraints I, so I is not a well-justified FLP answer set of 1.</p>
  </div>
  <div class="page">
    <p>Well-Justified FLP Answer Sets</p>
    <p>Properties of the well-justified FLP semantics:</p>
    <p>Theorem</p>
    <p>If I is a well-justified FLP answer set of a general logic program , then I is an FLP answer set of .</p>
    <p>Level mapping</p>
    <p>Well-justified FLP answer sets have a level mapping, which is built from the FLP reduct f I via the sequence T i</p>
    <p>f I (,I)i=0,</p>
    <p>where for each A  I , A is at level i &gt; 0 if T i f I</p>
    <p>(,I) I |= A but T i1 f I</p>
    <p>(,I) I 6|= A.</p>
    <p>The enhancement of the level mapping makes the resulting FLP answer sets free of circular justifications.</p>
  </div>
  <div class="page">
    <p>Extensions to Logic Programs with Constraints</p>
    <p>The well-justified FLP semantics has been extended to general logic programs with aggregates, and to description logic programs (dl-programs).</p>
    <p>When this method is applied to normal logic programs with aggregates, the well-justified FLP semantics agrees with the conditional satisfaction based semantics defined by [SPT07].</p>
    <p>When applied to dl-programs, the semantics agrees with the strongly well-supported semantics defined by [She11].</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>The FLP semantics is first introduced in [FLP04] for normal (and disjunctive) logic programs with aggregates. It is then extended to dl-programs and Hex programs [EIST05, EIL+08], modular logic programs [DTEFK09], disjunctive dl-programs [Luk10], and general logic programs with aggregates [BLM11]. [Tru10] and [FLL11] also extend the FLP semantics of [FLP04] to propositional formulas and first-order formulas, respectively. As illustrated in [BLM11], these two extensions do not agree with the FLP semantics of [BLM11] (see Definition 1) for general logic programs.</p>
    <p>We observe that the problem of circular justifications with the FLP semantics persists in all the above extensions.</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>For normal logic programs with aggregates, [SY09] observe that answer sets under the FLP semantics of [FLP04] have circular justifications. They propose a default semantics by translating a propositional logic program to a default logic theory and show that the default semantics agrees with the conditional satisfaction based semantics of [SPT07].</p>
    <p>[LPST10] also indicate the circular justification (self-supportedness) problem with the FLP semantics of [FLP04]. They propose a computation based semantics for normal logic programs with aggregates, which proves to coincide with the conditional satisfaction based semantics.</p>
    <p>For dl-programs, [She11] observes the circular justification problem with the FLP semantics defined by [EIST05]. For disjunctive dl-programs, [SW11] notice the circular justification problem with the FLP semantics defined by [Luk10].</p>
  </div>
  <div class="page">
    <p>M. Bartholomew, J. Lee, and Y. Meng. First-order extension of the FLP stable model semantics via modified circumscription. In IJCAI, pages 724730, 2011.</p>
    <p>M. Dao-Tran, T. Eiter, M. Fink, and T. Krennwallner. Modular nonmonotonic logic programming revisited. In ICLP, pages 145159, 2009.</p>
    <p>T. Eiter, G. Ianni, T. Lukasiewicz, R. Schindlauer, and H. Tompits. Combining answer set programming with description logics for the semantic web. Artificial Intelligence, 172(12-13):14951539, 2008.</p>
    <p>T. Eiter, G. Ianni, R. Schindlauer, and H. Tompits. A uniform integration of higher-order reasoning and external evaluations in answer-set programming. In IJCAI, pages 9096, 2005.</p>
  </div>
  <div class="page">
    <p>P. Ferraris, J. Lee, and V. Lifschitz. Stable models and circumscription. Artificial Intelligence, 175(1):236263, 2011.</p>
    <p>W. Faber, N. Leone, and G. Pfeifer. Recursive aggregates in disjunctive logic programs: Semantics and complexity. In Logics in Artificial Intelligence: European Workshop, pages 200212, 2004.</p>
    <p>M. Gelfond and V. Lifschitz. The stable model semantics for logic programming. In ICLP, pages 10701080, 1988.</p>
    <p>V. Lifschitz. Thirteen definitions of a stable model. In Fields of Logic and Computation, pages 488503, 2010.</p>
    <p>L. Liu, E. Pontelli, T.C. Son, and M. Truszczynski.</p>
  </div>
  <div class="page">
    <p>Logic programs with abstract constraint atoms: the role of computations. Artificial Intelligence, 174(3-4):295315, 2010.</p>
    <p>T. Lukasiewicz. A novel combination of answer set programming with description logics for the semantic web. IEEE Transactions on Knowledge and Data Engineering, 22(11):15771592, 2010.</p>
    <p>Y. D. Shen. Well-supported semantics for description logic programs. In IJCAI, pages 10811086, 2011.</p>
    <p>T. C. Son, E. Pontelli, and P. H. Tu. Answer sets for logic programs with arbitrary abstract constraint atoms. Journal of Artificial Intelligence Research, 29:353389, 2007.</p>
    <p>Y. D. Shen and K. W. Wang.</p>
  </div>
  <div class="page">
    <p>Extending logic programs with description logic expressions for the semantic web. In International Semantic Web Conference, pages 633648, 2011.</p>
    <p>Y. D. Shen and J. H. You. A default approach to semantics of logic programs with constraint atoms. In LPNMR, pages 277289, 2009.</p>
    <p>M. Truszczynski. Reducts of propositional theories, satisfiability relations, and generalizations of semantics of logic programs. Artificial Intelligence, 174(16-17):12851306, 2010.</p>
    <p>M. H. van Emden and R. A. Kowalski. The semantics of predicate logic as a programming language. J. ACM, 23(4):733742, 1976.</p>
  </div>
</Presentation>
