<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Finding Fastest Paths on A Road Network</p>
    <p>with Speed Patterns</p>
    <p>Evangelos Kanoulas, Yang Du, Tian Xia, Donghui Zhang</p>
    <p>Northeastern University Boston, USA</p>
  </div>
  <div class="page">
    <p>Outline  Motivation  Problem Definition  Related Work  Query Processing  Travel-Time Estimator  Performance  Conclusions</p>
  </div>
  <div class="page">
    <p>Query: From Alices home to school, which path is the fastest?</p>
    <p>Existing GIS systems  either find shortest path, not consider the</p>
    <p>speed at all  or assume constant speed, such as MapPoint</p>
    <p>Motivation</p>
    <p>Home Scho ol</p>
    <p>Highway, 10 miles</p>
    <p>Local, 15 miles</p>
  </div>
  <div class="page">
    <p>Motivation  In real world</p>
    <p>Highway: 1 hour (10 mph) in rush hours, 10 minutes (60 mph) otherwise</p>
    <p>Local road: 20 minutes (45 mph) anytime  Speed and time do change the fastest path</p>
    <p>Our goal  Consider the speed on a road as a function of</p>
    <p>time  Answer queries within a departure interval</p>
  </div>
  <div class="page">
    <p>Outline  Motivation  Problem Definition  Related Work  Query Processing  Travel-Time Estimator  Performance  Conclusions</p>
  </div>
  <div class="page">
    <p>Daily Speed Pattern on A Road</p>
    <p>The real pattern on a road is a continuous function of time.</p>
    <p>The approximation is a piecewise constant function of time.</p>
    <p>v</p>
    <p>t (a) real pattern</p>
    <p>(b) approximation</p>
    <p>v</p>
    <p>t</p>
  </div>
  <div class="page">
    <p>CapeCod Pattern  CAtegorized PiecewisE COnstant speeD</p>
    <p>pattern  Categorized (e.g. weekday, weekend)  Each day belongs to exactly one category</p>
    <p>The CapeCod pattern of the highway  Weekend: [00:00-24:00) 60mph  Weekday: [07:00-09:00) 10 mph, otherwise</p>
  </div>
  <div class="page">
    <p>CapeCod Network  Model the road network as a directed</p>
    <p>graph</p>
    <p>Each edge (a road segment) is associated with a CapeCod pattern</p>
    <p>Adopt the CCAM storage model [Shekhar &amp; Liu, 1997]  Use a B+-tree to index the nodes by their Z</p>
    <p>ordering (Hilbert values)</p>
  </div>
  <div class="page">
    <p>Fastest Path Queries  Two types of queries:</p>
    <p>SingleFP  AllFP</p>
    <p>Same Inputs:  a CapeCod network  a start node s  an end node e  a departure time interval I</p>
    <p>Different Output</p>
  </div>
  <div class="page">
    <p>SingleFP Queries  Find a single departure time l0 within I and</p>
    <p>the corresponding fastest path</p>
    <p>For example:  Alice may leave for work any time in [7am,</p>
  </div>
  <div class="page">
    <p>AllFP Queries  Find the fastest paths for all departure</p>
    <p>time during I  For example:</p>
    <p>Alice may leave for work any time in [7am, 9am]; please suggest all fastest paths, e.g. take route A if the leaving time is between 7 and 7:45, and take route B otherwise</p>
    <p>The answer to AllFP query contains the answer to the counterpart SingleFP query</p>
  </div>
  <div class="page">
    <p>Outline  Motivation  Problem Definition  Related Work  Query Processing  Travel-Time Estimator  Performance  Conclusions</p>
  </div>
  <div class="page">
    <p>Related Work  Shortest Path</p>
    <p>Classical solutions: Dijkstras Algorithm, A* Algorithm</p>
    <p>Can be straightforwardly extended to solve fastest path problem with constant speed</p>
    <p>Fastest Path with Changing Speed  Discrete Time Model  Continuous Time Model</p>
  </div>
  <div class="page">
    <p>Some Existing Work on Fastest Path  K. Nachtigal, European Journal of</p>
    <p>Opertional Research, 1995  Discrete time  Apply A* algorithm for every time instant</p>
    <p>A. Orda and R. Rom, JACM, 1990  Continuous time  For theoretical interest only</p>
    <p>K. Sung et al, European Journal of Operation Reseach, 2000  Continuous time, piecewise constant speed  Address queries with a given departure time</p>
  </div>
  <div class="page">
    <p>Outline  Motivation  Problem Definition  Related Work  Query Processing  Travel-Time Estimator  Performance  Conclusions</p>
  </div>
  <div class="page">
    <p>The A* Algorithm</p>
    <p>Each node ni has an estimated distance to the end node dest(ni, e)</p>
    <p>If the estimation is a lower-bound, it is guaranteed to find the shortest path</p>
    <p>A simple estimation is Euclidean distance</p>
    <p>s</p>
    <p>e</p>
    <p>dest(n1; e)n2 n1</p>
  </div>
  <div class="page">
    <p>The A* Algorithm (cont.)</p>
    <p>Expand the nodes from s  Each time expand the node which has the</p>
    <p>minimal d(s, ni)+dest(ni, e)  The nodes on the other direction, such as</p>
    <p>n2, may never be expanded</p>
    <p>s</p>
    <p>e</p>
    <p>n2 n1</p>
  </div>
  <div class="page">
    <p>Single Departure Time Instant</p>
    <p>Solution is a simple extension of A*</p>
    <p>Replace distance by travel time</p>
    <p>The travel time along a path can be accurately computed</p>
    <p>Use the lower bound estimation of travel time from ni to e:</p>
    <p>max</p>
    <p>ieuc</p>
    <p>v</p>
    <p>end ),(</p>
  </div>
  <div class="page">
    <p>Challenges for Time Interval  Travel time to each node is a function of</p>
    <p>departure time  Which node do we pick to expand?  How do we expand the nodes and the travel</p>
    <p>time function?</p>
    <p>The lower bound estimation is too inaccurate  How to get better estimation?</p>
  </div>
  <div class="page">
    <p>Overview of Our Solution  Maintain a piecewise-linear function for</p>
    <p>each expanded path in a priority queue  The function is the sum of the accurate</p>
    <p>travel time from start node and the estimated travel time to end node</p>
    <p>Pick the path whose minimum value of the maintained function is the smallest</p>
    <p>Maintain a lower border function for all expanded paths</p>
  </div>
  <div class="page">
    <p>Running Example</p>
    <p>n</p>
    <p>s e 2 miles</p>
    <p>Query time interval [6:50-7:05]</p>
    <p>se: [6-8): 1/3mpm</p>
    <p>sn: [6-7): 1/3mpm,</p>
    <p>[7-8): 1mpm</p>
    <p>ne: [6-7:08): 1/3mpm,</p>
    <p>[7:08-8): 1/10mpm</p>
  </div>
  <div class="page">
    <p>Travel Time on A Road</p>
    <p>Travel time on a road with length d</p>
    <p>],[ if ,))(1(</p>
    <p>],[ if ,</p>
    <p>t v</p>
    <p>d tl</p>
    <p>v</p>
    <p>d lt</p>
    <p>v</p>
    <p>v</p>
    <p>v</p>
    <p>d ttl</p>
    <p>v</p>
    <p>d</p>
  </div>
  <div class="page">
    <p>Travel Time from s to Its Neighbors</p>
    <p>mineslT 6),(</p>
    <p>)05:700:7[ if ,2</p>
    <p>)00:754:6[ if ,2)00:7( 3</p>
    <p>)54:650:6[ if ,6</p>
    <p>),(</p>
    <p>l</p>
    <p>ll</p>
    <p>l</p>
    <p>nslT</p>
  </div>
  <div class="page">
    <p>Functions in The Queue</p>
    <p>Test(ne) = 1 min</p>
    <p>Expand path s to n first</p>
  </div>
  <div class="page">
    <p>Before Expanding Node n to e</p>
    <p>Find the departure time interval of node n: [6:56, 7:07]</p>
    <p>Compute the travel time from n to e during this interval</p>
  </div>
  <div class="page">
    <p>Expanding Node n</p>
    <p>Compound the travel time function of path s to n and n to e</p>
  </div>
  <div class="page">
    <p>The SingleFP Query Result</p>
    <p>Path s to n to e has the global smallest minimum value</p>
    <p>Report this path and interval [7:00, 7:03] as the answer</p>
  </div>
  <div class="page">
    <p>The AllFP Query Result</p>
    <p>In this case, return the lower border function.</p>
    <p>In general cases, more paths may be expanded.</p>
  </div>
  <div class="page">
    <p>Outline  Motivation  Problem Definition  Related Work  Query Processing  Travel-Time Estimator  Performance  Conclusions</p>
  </div>
  <div class="page">
    <p>Travel-time Estimator  The more accurate the estimation, the</p>
    <p>more efficient the algorithm</p>
    <p>Euclidean distance divided by maximum speed is very inaccurate in most cases</p>
    <p>We propose boundary-node estimator  Cell partitioning  Pre-computation</p>
  </div>
  <div class="page">
    <p>Boundary-node Estimator  Space is divided into non-overlapping cells.</p>
    <p>Boundary node: a node directly connected to a node in other cell.</p>
    <p>Pre-computation:  For each pair of cells, precompute the shortest</p>
    <p>path between their boundary nodes.  For each node, precompute the shortest path</p>
    <p>from and to the boundary nodes.</p>
  </div>
  <div class="page">
    <p>Boundary-node Estimator (cont.)</p>
    <p>b1 to b2 is the shortest path between two cells</p>
    <p>b3 is the nearest boundary node from n, and b4 is the nearest to e</p>
    <p>Estimation: dest(n,e) = d(n,b3) + d(b1,b2)+d(b4,e)</p>
  </div>
  <div class="page">
    <p>Outline  Motivation  Problem Definition  Related Work  Query Processing  Travel-Time Estimator  Performance  Conclusions</p>
  </div>
  <div class="page">
    <p>Experiment Setup  Real Road Network</p>
    <p>Extracted from Tiger/Line  Covering the Suffolk County of Massachusetts  20,461 edges and 14,456 nodes</p>
    <p>Synthetic Speed Pattern  Two categories: weekday and weekend  Four types of roads  Speed based on our unofficial experience</p>
  </div>
  <div class="page">
    <p>Efficiency of Estimator</p>
  </div>
  <div class="page">
    <p>Comparison with Discrete Time</p>
  </div>
  <div class="page">
    <p>Comparison with Discrete Time (cont.)</p>
  </div>
  <div class="page">
    <p>Outline  Motivation  Problem Definition  Related Work  Query Processing  Travel-Time Estimator  Performance  Conclusions</p>
  </div>
  <div class="page">
    <p>Conclusions  Proposed the CapeCod pattern, which</p>
    <p>captures the real-life speed information</p>
    <p>Introduced two practical queries and proposed an algorithm to answer both queries based on novel extensions to A* algorithm</p>
    <p>Provided a new lower-bound estimator to improve the efficiency</p>
  </div>
  <div class="page">
    <p>Thank you!Thank you!</p>
    <p>Q &amp; A</p>
  </div>
</Presentation>
