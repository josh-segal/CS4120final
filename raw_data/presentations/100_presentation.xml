<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Towards an algebraic theory of bidirectional transformations</p>
    <p>Perdita Stevens</p>
    <p>Laboratory for Foundations of Computer Science School of Informatics</p>
    <p>University of Edinburgh</p>
    <p>Special thanks to the PC chairs, to Leonid Libkin and to Benjamin Pierce</p>
  </div>
  <div class="page">
    <p>Plan</p>
  </div>
  <div class="page">
    <p>Introduction</p>
  </div>
  <div class="page">
    <p>Why model transformations?</p>
    <p>Model-driven development is fashionable.</p>
    <p>But what is it?</p>
    <p>Whats a model?</p>
    <p>Lets say: a model is any precise representation of some of the information needed to solve a problem using a computer.</p>
    <p>Where do model transformations come in?</p>
    <p>Model transformations are the engine of MDD.</p>
  </div>
  <div class="page">
    <p>Why model transformations?</p>
    <p>Model-driven development is fashionable. But what is it?</p>
    <p>Whats a model?</p>
    <p>Lets say: a model is any precise representation of some of the information needed to solve a problem using a computer.</p>
    <p>Where do model transformations come in?</p>
    <p>Model transformations are the engine of MDD.</p>
  </div>
  <div class="page">
    <p>Why model transformations?</p>
    <p>Model-driven development is fashionable. But what is it?</p>
    <p>Whats a model?</p>
    <p>Lets say: a model is any precise representation of some of the information needed to solve a problem using a computer.</p>
    <p>Where do model transformations come in?</p>
    <p>Model transformations are the engine of MDD.</p>
  </div>
  <div class="page">
    <p>Why model transformations?</p>
    <p>Model-driven development is fashionable. But what is it?</p>
    <p>Whats a model?</p>
    <p>Lets say: a model is any precise representation of some of the information needed to solve a problem using a computer.</p>
    <p>Where do model transformations come in?</p>
    <p>Model transformations are the engine of MDD.</p>
  </div>
  <div class="page">
    <p>Why model transformations?</p>
    <p>Model-driven development is fashionable. But what is it?</p>
    <p>Whats a model?</p>
    <p>Lets say: a model is any precise representation of some of the information needed to solve a problem using a computer.</p>
    <p>Where do model transformations come in?</p>
    <p>Model transformations are the engine of MDD.</p>
  </div>
  <div class="page">
    <p>Why model transformations?</p>
    <p>Model-driven development is fashionable. But what is it?</p>
    <p>Whats a model?</p>
    <p>Lets say: a model is any precise representation of some of the information needed to solve a problem using a computer.</p>
    <p>Where do model transformations come in?</p>
    <p>Model transformations are the engine of MDD.</p>
  </div>
  <div class="page">
    <p>MDD idea(l)</p>
  </div>
  <div class="page">
    <p>Benefits</p>
    <p>I Generate boilerplate code, dont write it: write once</p>
    <p>I Do analysis and design in a graphical language that domain experts can understand</p>
    <p>I Manage commonalities between versions/families of systems</p>
    <p>I Make it easy to adapt to changes in e.g. requirements or e.g. library version</p>
    <p>I Eliminate slips</p>
    <p>See http://www.omg.org/mda/products_success.htm</p>
  </div>
  <div class="page">
    <p>Rising importance of models</p>
    <p>Alan Brown, IBM, An introduction to MDA</p>
  </div>
  <div class="page">
    <p>But inside the black box</p>
    <p>The reality is that any of these models may change, with knock-on effects.</p>
  </div>
  <div class="page">
    <p>Multiple models even not counting code</p>
    <p>For example, heres the classic OMG Model Driven Architecture picture:</p>
    <p>So well (practically) always be in the bidirectional case.</p>
  </div>
  <div class="page">
    <p>Rising importance of models</p>
  </div>
  <div class="page">
    <p>Transformations as restoration of consistency</p>
  </div>
  <div class="page">
    <p>Consistency</p>
    <p>The most basic concept is that of two models being consistent  this is what we want to check, and what we want somehow to enforce.</p>
    <p>Generally, consistency will depend on some, but not all, of the information in the models  to check consistency, you wont usually have to look at every detail.</p>
    <p>It is a relation</p>
    <p>R  M  N</p>
  </div>
  <div class="page">
    <p>Classic examples</p>
    <p>In both cases, each side has information not represented on the other.</p>
  </div>
  <div class="page">
    <p>Simple example (after Foster, Pierce et al.)</p>
  </div>
  <div class="page">
    <p>Simple example (after Foster, Pierce et al.)</p>
  </div>
  <div class="page">
    <p>Simple example (after Foster, Pierce et al.)</p>
  </div>
  <div class="page">
    <p>One of many reasonable choices</p>
  </div>
  <div class="page">
    <p>Good, we restored consistency</p>
    <p>But in doing so, we made choices  there was more than one LH model consistent with the updated RH model.</p>
    <p>To decide which was best, we needed to look at latest available versions of both models.</p>
    <p>Might even use more info, if feasible...</p>
    <p>Not an unfortunate accident, but essential characteristic of the problem area.</p>
    <p>Think about it: if you could get away with modifying only one model, regenerating the other when you wanted, why wouldnt you do that? Unfortunately, important information may simply not be there.</p>
    <p>Moral: if a bidirectional transformation is needed at all, it is probably non-bijective.</p>
  </div>
  <div class="page">
    <p>Good, we restored consistency</p>
    <p>But in doing so, we made choices  there was more than one LH model consistent with the updated RH model.</p>
    <p>To decide which was best, we needed to look at latest available versions of both models.</p>
    <p>Might even use more info, if feasible...</p>
    <p>Not an unfortunate accident, but essential characteristic of the problem area.</p>
    <p>Think about it: if you could get away with modifying only one model, regenerating the other when you wanted, why wouldnt you do that? Unfortunately, important information may simply not be there.</p>
    <p>Moral: if a bidirectional transformation is needed at all, it is probably non-bijective.</p>
  </div>
  <div class="page">
    <p>Systematically, how did that transformation happen?</p>
  </div>
  <div class="page">
    <p>How to deal with non-bijective consistency</p>
    <p>So, consistency will normally be a non-bijective relation: for any source model, there will be a (possibly infinite) set of consistent target models.</p>
    <p>Is it acceptable for the tool to choose any one?</p>
    <p>Absolutely not! Tool must be deterministic.</p>
    <p>Shall we try to make the tool choose the simplest one?</p>
    <p>Thats no better! Mustnt lose the users data.</p>
    <p>Well, shall we just say OK, when theres more than one solution, the tool must be interactive: the user has to choose?</p>
    <p>Sometimes that might be the best we can do.</p>
    <p>But ideally, we should let a programmer specify exactly how consistency should be restored.</p>
  </div>
  <div class="page">
    <p>How to deal with non-bijective consistency</p>
    <p>So, consistency will normally be a non-bijective relation: for any source model, there will be a (possibly infinite) set of consistent target models.</p>
    <p>Is it acceptable for the tool to choose any one?</p>
    <p>Absolutely not! Tool must be deterministic.</p>
    <p>Shall we try to make the tool choose the simplest one?</p>
    <p>Thats no better! Mustnt lose the users data.</p>
    <p>Well, shall we just say OK, when theres more than one solution, the tool must be interactive: the user has to choose?</p>
    <p>Sometimes that might be the best we can do.</p>
    <p>But ideally, we should let a programmer specify exactly how consistency should be restored.</p>
  </div>
  <div class="page">
    <p>How to deal with non-bijective consistency</p>
    <p>So, consistency will normally be a non-bijective relation: for any source model, there will be a (possibly infinite) set of consistent target models.</p>
    <p>Is it acceptable for the tool to choose any one?</p>
    <p>Absolutely not! Tool must be deterministic.</p>
    <p>Shall we try to make the tool choose the simplest one?</p>
    <p>Thats no better! Mustnt lose the users data.</p>
    <p>Well, shall we just say OK, when theres more than one solution, the tool must be interactive: the user has to choose?</p>
    <p>Sometimes that might be the best we can do.</p>
    <p>But ideally, we should let a programmer specify exactly how consistency should be restored.</p>
  </div>
  <div class="page">
    <p>How to deal with non-bijective consistency</p>
    <p>So, consistency will normally be a non-bijective relation: for any source model, there will be a (possibly infinite) set of consistent target models.</p>
    <p>Is it acceptable for the tool to choose any one?</p>
    <p>Absolutely not! Tool must be deterministic.</p>
    <p>Shall we try to make the tool choose the simplest one?</p>
    <p>Thats no better! Mustnt lose the users data.</p>
    <p>Well, shall we just say OK, when theres more than one solution, the tool must be interactive: the user has to choose?</p>
    <p>Sometimes that might be the best we can do.</p>
    <p>But ideally, we should let a programmer specify exactly how consistency should be restored.</p>
  </div>
  <div class="page">
    <p>How to deal with non-bijective consistency</p>
    <p>So, consistency will normally be a non-bijective relation: for any source model, there will be a (possibly infinite) set of consistent target models.</p>
    <p>Is it acceptable for the tool to choose any one?</p>
    <p>Absolutely not! Tool must be deterministic.</p>
    <p>Shall we try to make the tool choose the simplest one?</p>
    <p>Thats no better! Mustnt lose the users data.</p>
    <p>Well, shall we just say OK, when theres more than one solution, the tool must be interactive: the user has to choose?</p>
    <p>Sometimes that might be the best we can do.</p>
    <p>But ideally, we should let a programmer specify exactly how consistency should be restored.</p>
  </div>
  <div class="page">
    <p>How to deal with non-bijective consistency</p>
    <p>So, consistency will normally be a non-bijective relation: for any source model, there will be a (possibly infinite) set of consistent target models.</p>
    <p>Is it acceptable for the tool to choose any one?</p>
    <p>Absolutely not! Tool must be deterministic.</p>
    <p>Shall we try to make the tool choose the simplest one?</p>
    <p>Thats no better! Mustnt lose the users data.</p>
    <p>Well, shall we just say OK, when theres more than one solution, the tool must be interactive: the user has to choose?</p>
    <p>Sometimes that might be the best we can do.</p>
    <p>But ideally, we should let a programmer specify exactly how consistency should be restored.</p>
  </div>
  <div class="page">
    <p>How to deal with non-bijective consistency</p>
    <p>So, consistency will normally be a non-bijective relation: for any source model, there will be a (possibly infinite) set of consistent target models.</p>
    <p>Is it acceptable for the tool to choose any one?</p>
    <p>Absolutely not! Tool must be deterministic.</p>
    <p>Shall we try to make the tool choose the simplest one?</p>
    <p>Thats no better! Mustnt lose the users data.</p>
    <p>Well, shall we just say OK, when theres more than one solution, the tool must be interactive: the user has to choose?</p>
    <p>Sometimes that might be the best we can do.</p>
    <p>But ideally, we should let a programmer specify exactly how consistency should be restored.</p>
  </div>
  <div class="page">
    <p>How to deal with non-bijective consistency</p>
    <p>So, consistency will normally be a non-bijective relation: for any source model, there will be a (possibly infinite) set of consistent target models.</p>
    <p>Is it acceptable for the tool to choose any one?</p>
    <p>Absolutely not! Tool must be deterministic.</p>
    <p>Shall we try to make the tool choose the simplest one?</p>
    <p>Thats no better! Mustnt lose the users data.</p>
    <p>Well, shall we just say OK, when theres more than one solution, the tool must be interactive: the user has to choose?</p>
    <p>Sometimes that might be the best we can do.</p>
    <p>But ideally, we should let a programmer specify exactly how consistency should be restored.</p>
  </div>
  <div class="page">
    <p>No problem!</p>
    <p>Programmers love specifying things. We dont even need special programming languages: models are saved as XML after all...</p>
    <p>Programmer writes one Perl/OCaml/Java program to roll changes forward, another to roll changes backwards... done!</p>
    <p>Umm... programmers (and their managers) never do silly things, do they? Like:</p>
    <p>I writing programs that violate basic sanity conditions;</p>
    <p>I modifying one program, but forgetting to keep something else consistent.</p>
    <p>What should a model transformation (never) be allowed to do?</p>
  </div>
  <div class="page">
    <p>No problem!</p>
    <p>Programmers love specifying things. We dont even need special programming languages: models are saved as XML after all...</p>
    <p>Programmer writes one Perl/OCaml/Java program to roll changes forward, another to roll changes backwards... done!</p>
    <p>Umm... programmers (and their managers) never do silly things, do they? Like:</p>
    <p>I writing programs that violate basic sanity conditions;</p>
    <p>I modifying one program, but forgetting to keep something else consistent.</p>
    <p>What should a model transformation (never) be allowed to do?</p>
  </div>
  <div class="page">
    <p>No problem!</p>
    <p>Programmers love specifying things. We dont even need special programming languages: models are saved as XML after all...</p>
    <p>Programmer writes one Perl/OCaml/Java program to roll changes forward, another to roll changes backwards... done!</p>
    <p>Umm... programmers (and their managers) never do silly things, do they? Like:</p>
    <p>I writing programs that violate basic sanity conditions;</p>
    <p>I modifying one program, but forgetting to keep something else consistent.</p>
    <p>What should a model transformation (never) be allowed to do?</p>
  </div>
  <div class="page">
    <p>What is sanity?</p>
  </div>
  <div class="page">
    <p>Whats a sensible transformation?</p>
    <p>Two conditions are easy to identify and justify, on the basis that</p>
    <p>the job of the transformation is to make those changes which are necessary to restore consistency, and ONLY those changes</p>
    <p>Notice that in the case of a non-bijective consistency relation, this is already restrictive.</p>
    <p>It already proves that no pair of functions M  N can do the job.</p>
  </div>
  <div class="page">
    <p>A pair of functions is not enough</p>
    <p>Suppose we had a non-bijective consistency relation and functions f : M  N g : N  M which are supposed to give a correct and hippocratic transformation.</p>
    <p>Pick (wlog) (m, n) and (m, n) consistent, n 6= n. f (m) = n and f (m) = n by hippocraticness: contradiction!</p>
    <p>This is why we need:</p>
    <p>R  M  N  consistency  R : M  N  N  roll a change in M forward to N  R : M  N  M  roll a change in N backwards to M</p>
  </div>
  <div class="page">
    <p>Example R : same (name, nationality) pairs on both sides  R (m, n) : build n from m and n by:</p>
    <p>take the (name, nationality) pairs from m, take the ordering from n, add newly-named composers at the end of n in alphabetical order by name; return n</p>
    <p>R (m, n) : build m from m and n by:</p>
    <p>take the (name, nationality) pairs from n, take the dates by name from m, use default dates ????-???? for any newly-named composers; return m</p>
  </div>
  <div class="page">
    <p>But thats not enough</p>
    <p>Some utterly insane transformations are correct and hippocratic.</p>
    <p>E.g., in the composers example (consistency as before):  R (m, n) = if R (m, n) then n,</p>
    <p>else (name, nationality) pairs alphabetically ordered by name</p>
    <p>R (m, n) = if R (m, n) then m,</p>
    <p>else a set of composer objects with name and nationality taken from n, and all dates set to 2005-2009</p>
    <p>What else does it take for a transformation to seem reasonable?</p>
  </div>
  <div class="page">
    <p>But thats not enough</p>
    <p>Some utterly insane transformations are correct and hippocratic.</p>
    <p>E.g., in the composers example (consistency as before):  R (m, n) = if R (m, n) then n,</p>
    <p>else (name, nationality) pairs alphabetically ordered by name</p>
    <p>(discarding users chosen order from n).  R (m, n) = if R (m, n) then m,</p>
    <p>else a set of composer objects with name and nationality taken from n, and all dates set to 2005-2009</p>
    <p>(discarding the dates that were already in m).</p>
    <p>What else does it take for a transformation to seem reasonable?</p>
  </div>
  <div class="page">
    <p>Whats wrong here?</p>
    <p>Two ways to look at it (at least):</p>
    <p>Aim: behaviour is reasonably composable and undoable, and if the models get slightly out of sync, then the transformation should propose a small change.</p>
    <p>Existing methods  graph transformations, bidirectional programming languages, etc.  tend to achieve something like this by having big transformations built up from small pieces, each of which will be correct and hippocratic.</p>
    <p>Lets think about undoability first.</p>
  </div>
  <div class="page">
    <p>Whats wrong here?</p>
    <p>Two ways to look at it (at least):</p>
    <p>Aim: behaviour is reasonably composable and undoable, and if the models get slightly out of sync, then the transformation should propose a small change.</p>
    <p>Existing methods  graph transformations, bidirectional programming languages, etc.  tend to achieve something like this by having big transformations built up from small pieces, each of which will be correct and hippocratic.</p>
    <p>Lets think about undoability first.</p>
  </div>
  <div class="page">
    <p>Undoability</p>
    <p>More controversial.</p>
    <p>Suppose you are working with model m, which is consistent with model n.</p>
    <p>You modify m to m.</p>
    <p>You apply the transformation, getting an updated n consistent with m.</p>
    <p>You realise you made a mistake, and revert to m.</p>
    <p>You apply the transformation again.</p>
    <p>Do you expect to get back exactly n, i.e., to where you started?</p>
  </div>
  <div class="page">
    <p>Undoability</p>
    <p>More controversial.</p>
    <p>Suppose you are working with model m, which is consistent with model n.</p>
    <p>You modify m to m.</p>
    <p>You apply the transformation, getting an updated n consistent with m.</p>
    <p>You realise you made a mistake, and revert to m.</p>
    <p>You apply the transformation again.</p>
    <p>Do you expect to get back exactly n, i.e., to where you started?</p>
  </div>
  <div class="page">
    <p>Undoability</p>
    <p>More controversial.</p>
    <p>Suppose you are working with model m, which is consistent with model n.</p>
    <p>You modify m to m.</p>
    <p>You apply the transformation, getting an updated n consistent with m.</p>
    <p>You realise you made a mistake, and revert to m.</p>
    <p>You apply the transformation again.</p>
    <p>Do you expect to get back exactly n, i.e., to where you started?</p>
  </div>
  <div class="page">
    <p>Undoability</p>
    <p>More controversial.</p>
    <p>Suppose you are working with model m, which is consistent with model n.</p>
    <p>You modify m to m.</p>
    <p>You apply the transformation, getting an updated n consistent with m.</p>
    <p>You realise you made a mistake, and revert to m.</p>
    <p>You apply the transformation again.</p>
    <p>Do you expect to get back exactly n, i.e., to where you started?</p>
  </div>
  <div class="page">
    <p>Undoability</p>
    <p>More controversial.</p>
    <p>Suppose you are working with model m, which is consistent with model n.</p>
    <p>You modify m to m.</p>
    <p>You apply the transformation, getting an updated n consistent with m.</p>
    <p>You realise you made a mistake, and revert to m.</p>
    <p>You apply the transformation again.</p>
    <p>Do you expect to get back exactly n, i.e., to where you started?</p>
  </div>
  <div class="page">
    <p>Undoability</p>
    <p>More controversial.</p>
    <p>Suppose you are working with model m, which is consistent with model n.</p>
    <p>You modify m to m.</p>
    <p>You apply the transformation, getting an updated n consistent with m.</p>
    <p>You realise you made a mistake, and revert to m.</p>
    <p>You apply the transformation again.</p>
    <p>Do you expect to get back exactly n, i.e., to where you started?</p>
  </div>
  <div class="page">
    <p>If yes...</p>
    <p>... then you expect transformations to be undoable:</p>
    <p>R (m, n) =  R (m,</p>
    <p>R (m, n)) = n</p>
    <p>R (m, n) =  R (  R (m, n), n) = m</p>
  </div>
  <div class="page">
    <p>Why undoability may be too strong</p>
    <p>Suppose the change you made was to delete some information from m to get m.</p>
    <p>(E.g., you deleted a composer on the LHS)</p>
    <p>When you applied the transformation, it deleted the corresponding information from n, yielding n. (E.g., deleted that composers entry in the ordered list)</p>
    <p>But it also deleted any information which was stuck to that information in n, even if it wasnt represented in m. (It forgot where in the list the composer had been.)</p>
    <p>So when you reverted to m, you restored all the information that was visible to you... (You recreated your composer, dates, and nationality...)</p>
    <p>... but maybe not all the information that had been deleted. Maybe some has to be replaced with default values, so that you dont get back to exactly where you started. (The composer ends up at the end of the list.)</p>
  </div>
  <div class="page">
    <p>Why undoability may be too strong</p>
    <p>Suppose the change you made was to delete some information from m to get m.</p>
    <p>(E.g., you deleted a composer on the LHS)</p>
    <p>When you applied the transformation, it deleted the corresponding information from n, yielding n. (E.g., deleted that composers entry in the ordered list)</p>
    <p>But it also deleted any information which was stuck to that information in n, even if it wasnt represented in m. (It forgot where in the list the composer had been.)</p>
    <p>So when you reverted to m, you restored all the information that was visible to you... (You recreated your composer, dates, and nationality...)</p>
    <p>... but maybe not all the information that had been deleted. Maybe some has to be replaced with default values, so that you dont get back to exactly where you started. (The composer ends up at the end of the list.)</p>
  </div>
  <div class="page">
    <p>Why undoability may be too strong</p>
    <p>Suppose the change you made was to delete some information from m to get m.</p>
    <p>(E.g., you deleted a composer on the LHS)</p>
    <p>When you applied the transformation, it deleted the corresponding information from n, yielding n. (E.g., deleted that composers entry in the ordered list)</p>
    <p>But it also deleted any information which was stuck to that information in n, even if it wasnt represented in m. (It forgot where in the list the composer had been.)</p>
    <p>So when you reverted to m, you restored all the information that was visible to you... (You recreated your composer, dates, and nationality...)</p>
    <p>... but maybe not all the information that had been deleted. Maybe some has to be replaced with default values, so that you dont get back to exactly where you started. (The composer ends up at the end of the list.)</p>
  </div>
  <div class="page">
    <p>Why undoability may be too strong</p>
    <p>Suppose the change you made was to delete some information from m to get m.</p>
    <p>(E.g., you deleted a composer on the LHS)</p>
    <p>When you applied the transformation, it deleted the corresponding information from n, yielding n. (E.g., deleted that composers entry in the ordered list)</p>
    <p>But it also deleted any information which was stuck to that information in n, even if it wasnt represented in m. (It forgot where in the list the composer had been.)</p>
    <p>So when you reverted to m, you restored all the information that was visible to you... (You recreated your composer, dates, and nationality...)</p>
    <p>... but maybe not all the information that had been deleted. Maybe some has to be replaced with default values, so that you dont get back to exactly where you started. (The composer ends up at the end of the list.)</p>
  </div>
  <div class="page">
    <p>Why undoability may be too strong</p>
    <p>Suppose the change you made was to delete some information from m to get m.</p>
    <p>(E.g., you deleted a composer on the LHS)</p>
    <p>When you applied the transformation, it deleted the corresponding information from n, yielding n. (E.g., deleted that composers entry in the ordered list)</p>
    <p>But it also deleted any information which was stuck to that information in n, even if it wasnt represented in m. (It forgot where in the list the composer had been.)</p>
    <p>So when you reverted to m, you restored all the information that was visible to you... (You recreated your composer, dates, and nationality...)</p>
    <p>... but maybe not all the information that had been deleted. Maybe some has to be replaced with default values, so that you dont get back to exactly where you started. (The composer ends up at the end of the list.)</p>
  </div>
  <div class="page">
    <p>Thinking structurally</p>
  </div>
  <div class="page">
    <p>What would an algebraic approach be?</p>
    <p>Would like some more detailed kind of principled way to talk about conditions that are true of transformations</p>
    <p>I that would still be independent of how the transformation is defined;</p>
    <p>I ideally, that would let us do composition, including of transformations written in different languages;</p>
    <p>I that would explain why undoability is so useful but so strong;</p>
    <p>I that would give us some notion of how small changes should correspond to small changes...</p>
    <p>(Dont get your hopes up for today!)</p>
  </div>
  <div class="page">
    <p>How does the transformation structure the model spaces?</p>
    <p>Suppose we have a transformation R : M  N , with forward and backward transformations</p>
    <p>R : M  N  N etc.</p>
    <p>Given m  M , which other elements of M relate to it via R ?</p>
    <p>I the set of elements which are the same from the point of view of N (none of the difference is visible wearing N glasses):</p>
    <p>{m  M : n  N.  R (m, n) =</p>
    <p>R (m, n)}</p>
    <p>I the set of elements all of whose difference from m is visible wearing N glasses:</p>
    <p>{m  M : n  N.  R (m, n) =</p>
    <p>R (m, n)}</p>
    <p>We get two orthogonal equivalence relations.</p>
  </div>
  <div class="page">
    <p>Suggestive picture</p>
    <p>NB in general not every square will be occupied; and the space may in fact be uncountable.</p>
  </div>
  <div class="page">
    <p>Edits</p>
    <p>Edits can be</p>
    <p>I total, or not... but we can fix that by decreeing that if they arent applicable they do nothing.</p>
    <p>I invertible (permutations) or not.</p>
    <p>Doing nothing is an edit; edits can be composed.</p>
    <p>When m is edited to m, there can legitimately be many edits that could have that effect. Some may be permutations, some not.</p>
    <p>Well insist that there should always be at least one  i.e., that the monoid of edits is transitive on the space.</p>
    <p>(Later, well insist that edits be permutations, i.e., invertible.)</p>
  </div>
  <div class="page">
    <p>Corresponding changes</p>
    <p>Suppose we have a consistent pair of models (m, n), and the user edits m.</p>
    <p>The edit is thought of intentionally: e.g. rename all classes named *Impl to *Implementation; add a state diagram to every active object; delete all sequence diagrams; etc.</p>
    <p>What a transformation has to explain is:</p>
    <p>if the user does edit g on model m, what edit should be done on corresponding model n? And vice versa?</p>
    <p>G  H</p>
  </div>
  <div class="page">
    <p>Now restrict to a special case</p>
    <p>in which N is a strict abstraction of M</p>
    <p>This is whats considered in Pierce, Foster et al.s lenses.</p>
    <p>get : C  A put : A  C  C (also create(a) short for put a C )</p>
    <p>R (c, a) get c = a  R (c, a) get c (NB independent of a)  R (c, a) put a c</p>
    <p>Correctness and hippo correspond to the lens laws:</p>
    <p>get C = A</p>
    <p>put (get c ) c = c GetPut</p>
    <p>get (put a c ) = a PutGet</p>
  </div>
  <div class="page">
    <p>Lens programming</p>
    <p>Lens programs built up from basic lenses using combinators.</p>
    <p>Proofs of lots of results like if we combine lenses which satisfy the lens laws using a combinator defined [thus], then the result will satisfy the lens laws.</p>
    <p>Lens programs take models as inputs  they do not talk about edits.</p>
    <p>What do the lens laws look like algebraically?</p>
    <p>Suppose C is a suitable transitive monoid of edits of C .</p>
  </div>
  <div class="page">
    <p>Lifting a lens to the edit monoids</p>
    <p>: C  M (A)</p>
    <p>defined as (g )(a) = get (g (create a))</p>
    <p>is a monoid homomorphism.</p>
    <p>If we write H for the image of , it turns out to act transitively on A. The other way:</p>
    <p>: H  C given by</p>
    <p>(h)(c ) = put h(get c ) c</p>
    <p>is well-defined, and  is the identity on H .</p>
    <p>However  is not necessarily a homomorphism.</p>
  </div>
  <div class="page">
    <p>In other words...</p>
    <p>We have a short exact sequence of monoids</p>
    <p>So what? So nothing useful, so long as it doesnt split.</p>
    <p>That means we need a monoid homomorphism H  C which is a right inverse of .</p>
    <p>would do fine, if only it were a homomorphism...</p>
  </div>
  <div class="page">
    <p>Getting  to be a homomorphism</p>
    <p>In a SES arising from a lens as above,</p>
    <p>is a monoid homomorphism if and only if the transformation is undoable.</p>
    <p>(In lens terminology, iff it is very well-behaved, i.e. satisfies PutPut</p>
    <p>put a (put a c ) = put a c</p>
    <p>the lens analogue of the undoability condition.)</p>
    <p>From now on well work with undoable transformations only.</p>
  </div>
  <div class="page">
    <p>From monoids to groups</p>
    <p>Its convenient to restrict now to considering only the invertible edits, i.e., to work with groups rather than monoids.</p>
    <p>(Possible justification: in practice, we dont get to know what edit the user had in mind, only what it did on the model(s) we see. They may have meant a permutation, so our transformation certainly has to do the right thing if they did. And if that already restricts it enough to be sensible...)</p>
  </div>
  <div class="page">
    <p>So in the special case</p>
    <p>(i.e. 1. one model-space a strict abstraction of the other; 2. undoable transformation; 3. invertible edits)</p>
    <p>we get a split short exact sequence of edit groups:</p>
    <p>and G ' K o H , i.e. K E G , H  G and</p>
    <p>I KH = G</p>
    <p>I K  H = 1G</p>
  </div>
  <div class="page">
    <p>Extremely informal picture!</p>
    <p>Three ways a group G can be built from H together with K E G :</p>
    <p>Not a product Semi-direct product Direct product Dependent Semi-independent Independent Maybe H 6 G H  G H E G</p>
    <p>g = h.k 6= k.h g = h.k = k.h</p>
    <p>Now,</p>
    <p>G acts on (is the edits of) C ,</p>
    <p>H acts on A,</p>
    <p>what does K act on, and how does it fit together?</p>
  </div>
  <div class="page">
    <p>Extremely informal picture!</p>
    <p>Three ways a group G can be built from H together with K E G :</p>
    <p>Not a product Semi-direct product Direct product Dependent Semi-independent Independent Maybe H 6 G H  G H E G</p>
    <p>g = h.k 6= k.h g = h.k = k.h Now,</p>
    <p>G acts on (is the edits of) C ,</p>
    <p>H acts on A,</p>
    <p>what does K act on, and how does it fit together?</p>
  </div>
  <div class="page">
    <p>Structure of the semi-direct action</p>
    <p>Now all grid squares are filled; write C = L  A G permutes the squares, and can be written as K o H</p>
    <p>H acts on A  stabilises rows, simply permutes the elements of each row in the same way: h(l, a) = (l, ha).</p>
    <p>K acts on L  stabilises columns, permuting the elements of each column, maybe not all in the same way.</p>
    <p>And this is why undoability is so strong.</p>
  </div>
  <div class="page">
    <p>Most trivial possible examples</p>
    <p>Any case where a concrete model consists of the abstract model plus some more completely independent information puts us in the direct product case.</p>
    <p>Suppose A comprises UML models, with edit group H</p>
    <p>L comprises nursery rhymes, with edit group K</p>
    <p>Of course C = L  A has edit group K  A, acting pointwise. get (l, a) = a</p>
    <p>put a (l, a) = (l, a)</p>
    <p>Trivial, but at least demonstrates that there are non-bijective undoable transformations!</p>
  </div>
  <div class="page">
    <p>Non-bijective, non-direct-product example</p>
    <p>C : positions of solid wooden equilateral triangle with numbered corners and one red face; edit group G ' S3 A : a single boolean (is the red face uppermost?); edit group H = {1H, h}' C2</p>
  </div>
  <div class="page">
    <p>Non-bijective, non-direct-product example</p>
    <p>C : positions of solid wooden equilateral triangle with numbered corners and one red face; edit group G ' S3 A : a single boolean (is the red face uppermost?); edit group H = {1H, h}' C2 In lens terms:</p>
    <p>get c returns true iff c had red face uppermost</p>
    <p>put a c checks whether a correctly reports whether c has red face uppermost. If so, it does nothing (returns c ); if not, it flips c about its top corner and returns that.</p>
  </div>
  <div class="page">
    <p>Non-bijective, non-direct-product example</p>
    <p>C : positions of solid wooden equilateral triangle with numbered corners and one red face; edit group G ' S3 A : a single boolean (is the red face uppermost?); edit group H = {1H, h}' C2 In algebraic terms:</p>
    <p>g is h iff g involved flipping the triangle, otherwise 1H</p>
    <p>h is flipping the triangle about its top corner.</p>
    <p>Turns out K ' C3, acting on a three-element set L which we can think of as which corner is the number 1 in now?</p>
  </div>
  <div class="page">
    <p>Building a lens from a sequence</p>
    <p>Suppose we have a short exact sequence of edit monoids: can we build a lens from it?</p>
    <p>Well, not necessarily  the sequence must be lens-like, i.e., must not use intentional information about the users edits.</p>
    <p>e.g. if there are two edits g1, g2 which have the same effect on a model c , then for the sequence to be lens-like, (g1) = (g2).</p>
    <p>That given, it works as expected: we can build a lens, and if the sequence originally came from a lens, the one we build is the one we started with.</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>I Bidirectional transformations are interesting and important :-)</p>
    <p>I especially non-bijective ones, which are more than pairs of single-argument functions.</p>
    <p>I They should be correct and hippocratic, and we might want them to be undoable...</p>
    <p>I Lenses, the special transformations that work between a space and a strict abstraction of it,are short exact sequences of edit monoids.</p>
    <p>I Considering only invertible edits, undoability corresponds to the splitting of the sequence, which imposes a semi-direct product structure on the original group of edits.</p>
    <p>I There is lots more still to do...</p>
  </div>
  <div class="page">
    <p>Open questions/ongoing work</p>
    <p>I (How) can we exploit group theory to understand structure of complex transformations?</p>
    <p>I Clarify the roles of the restrictions we imposed.</p>
    <p>I Non-lens-like SESs</p>
    <p>I Topology?</p>
    <p>How does all this relate to:</p>
    <p>I graph transformations?!</p>
    <p>I the database literature on data exchange (recoveries, (quasi-)inverses etc.)?</p>
    <p>I other work from the Harmony group, e.g., quotient lenses?</p>
  </div>
  <div class="page">
    <p>A few references</p>
    <p>The paper in the proceedings, and:</p>
    <p>S., Bidirectional Model Transformations in QVT: Semantic Issues and Open Questions, MODELS07</p>
    <p>S., A landscape of bidirectional model transformations, post-proceedings of GTTSE07</p>
    <p>Foster, Greenwald, Moore, Pierce, Schmitt: Combinators for bidirectional tree transformations: a linguistic approach to the view-update problem, ACM TOPLAS 2007, etc.</p>
    <p>Fagin, Kolaitis, Miller, Popa: Data exchange: semantics and query answering, ICDT03, etc.</p>
    <p>Arenas, Perez, Riveros: The recovery of a schema mapping: bringing exchanged data back, PODS08</p>
  </div>
  <div class="page">
    <p>Extra slides</p>
  </div>
  <div class="page">
    <p>And what about topology?</p>
    <p>Temptingly obvious first thoughts:</p>
    <p>if there is an information order on the models, e.g.</p>
    <p>m1  m2 if m2 contains all the model elements from m1 (with  at the bottom, obviously)</p>
    <p>then its natural to require that the  R and</p>
    <p>R be pointwise</p>
    <p>monotonic; then theres a standard notion of continuity...</p>
    <p>Unfortunately, not that simple :-(</p>
    <p>Consider M class diagrams, N instance diagrams. Consistent iff the instance diagram conforms to the class diagram. Transformations restore consistency. But sometimes adding model elements to the class diagram might necessitate taking some away from the instance diagram: model elements can function as constraints.</p>
  </div>
  <div class="page">
    <p>And what about topology?</p>
    <p>Temptingly obvious first thoughts:</p>
    <p>if there is an information order on the models, e.g.</p>
    <p>m1  m2 if m2 contains all the model elements from m1 (with  at the bottom, obviously)</p>
    <p>then its natural to require that the  R and</p>
    <p>R be pointwise</p>
    <p>monotonic; then theres a standard notion of continuity...</p>
    <p>Unfortunately, not that simple :-(</p>
    <p>Consider M class diagrams, N instance diagrams. Consistent iff the instance diagram conforms to the class diagram. Transformations restore consistency. But sometimes adding model elements to the class diagram might necessitate taking some away from the instance diagram: model elements can function as constraints.</p>
  </div>
  <div class="page">
    <p>And what about topology?</p>
    <p>Temptingly obvious first thoughts:</p>
    <p>if there is an information order on the models, e.g.</p>
    <p>m1  m2 if m2 contains all the model elements from m1 (with  at the bottom, obviously)</p>
    <p>then its natural to require that the  R and</p>
    <p>R be pointwise</p>
    <p>monotonic; then theres a standard notion of continuity...</p>
    <p>Unfortunately, not that simple :-(</p>
    <p>Consider M class diagrams, N instance diagrams. Consistent iff the instance diagram conforms to the class diagram. Transformations restore consistency. But sometimes adding model elements to the class diagram might necessitate taking some away from the instance diagram: model elements can function as constraints.</p>
  </div>
  <div class="page">
    <p>Why cant I just...</p>
    <p>I force bijectivity by hiding the info from one model inside the other? - Commonly done, can be good. But terribly fragile. No good if you dont have complete control of the model.</p>
    <p>I force undoability using standard tool mechanisms  literally remember what changes were made? - Great, do that  provided you have access to all the necessary information (distributed team? using different tools?)</p>
  </div>
</Presentation>
