<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Improving Integer Security for Systems with KINT</p>
    <p>Xi Wang, Haogang Chen, Zhihao Jia, Nickolai Zeldovich, Frans Kaashoek</p>
    <p>MIT CSAIL Tsinghua IIIS</p>
  </div>
  <div class="page">
    <p>Integer error</p>
    <p>Expected result goes out of bounds  Math (-bit): 230  23 = 233  Machine (32-bit): 230  23 = 0</p>
    <p>Can be exploited by aRackers</p>
  </div>
  <div class="page">
    <p>Example: buffer overflow</p>
    <p>Array allocaWon  malloc(n * size)  Overflow: 230  23 = 0  Smaller buffer than expected</p>
    <p>Memory corrupWon  Privilege escalaWon  iPhone jailbreak (CVE-2011-0226)</p>
  </div>
  <div class="page">
    <p>Example: logical bug</p>
    <p>Linux kernel OOM killer (CVE-2011-4097)  Compute memory usage score for each process  Kill process with the highest score</p>
    <p>Score: nr_pages * 1000 / nr_totalpages  Malicious process  Consume too much memory =&gt; a low score  Trick the kernel into killing innocent process</p>
    <p>nr_pages * 1000</p>
  </div>
  <div class="page">
    <p>An emerging threat</p>
    <p>2007 CVE survey: Integer overflows, barely in the top 10 overall in the past few years, are number 2 for OS vendor advisories, behind buffer overflows.</p>
    <p>2010  early 2011 CVE survey: Linux kernel More than 1/3 of [serious bugs] are integer errors.</p>
  </div>
  <div class="page">
    <p>Hard to prevent integer errors</p>
    <p>Arbitrary-precision integers (Python/Ruby)  Performance: require dynamic storage  Their implementaWons (in C) have/had overflows</p>
    <p>Trap on every overflow  False posiWves: overflow checks intenWonally incur overflow</p>
    <p>Linux kernel requires overflow to boot up  Memory-safe languages (C#/Java)  Performance concerns: runWme checks  Not enough: integer errors show up in logical bugs</p>
  </div>
  <div class="page">
    <p>ContribuWons</p>
    <p>A case study of 114 bugs in the Linux kernel  KINT: a staWc analysis tool for C programs  Used to find the 114 bugs</p>
    <p>kmalloc_array: overflow-aware allocaWon API  NaN integer: automated overflow checking</p>
  </div>
  <div class="page">
    <p>Case study: Linux kernel</p>
    <p>Applied KINT to Linux kernel source code  Nov 2011 to Apr 2012  Inspect KINTs bug reports &amp; submit patches</p>
    <p>114 bugs found by KINT  confirmed and fixed by developers  105 exclusively found by KINT  9 simultaneously found by other developers</p>
    <p>Incomplete: more to be discovered  No manpower to inspect all bug reports</p>
  </div>
  <div class="page">
    <p>Most are memory and logic bugs</p>
    <p>Buffer overflow 37%</p>
    <p>Logical bugs 42%</p>
    <p>Other 21%</p>
  </div>
  <div class="page">
    <p>With incorrect checks 67%</p>
  </div>
  <div class="page">
    <p>Example: wrong bounds net/core/net-sysfs.c</p>
    <p>unsigned long n = /* from user space */; if (n &gt; 1&lt;&lt;30) return EINVAL; table = vmalloc(sizeof(struct flow_table) + n * sizeof(struct flow)); for (i = 0; i &lt; n; ++i) table-&gt;entries[i] = ;</p>
    <p>... entries[0] entries[] entries[n-1]</p>
    <p>struct flow_table { ... struct flow entries[0]; };</p>
  </div>
  <div class="page">
    <p>C spec: sWll 32-bit mul!</p>
    <p>Example: wrong type drivers/gpu/drm/vmwgfx/vmwgfx_kms.c</p>
    <p>Patch 1: u32 size = pitch * height; if (size &gt; vram_size) return;</p>
    <p>u32 pitch = /* from user space*/; u32 height = /* from user space */;</p>
    <p>Patch 2: use 64 bits? u64 size = pitch * height; if (size &gt; vram_size) return;</p>
    <p>Patch 3: convert pitch and height to u64 first! u64 size = (u64)pitch * (u64)height; if (size &gt; vram_size) return;</p>
  </div>
  <div class="page">
    <p>WriWng correct checks is non-trivial</p>
    <p>2/3 of the 114 integer errors have checks  One check was fixed 3 Wmes and sWll buggy  Even two CVE cases were fixed incorrectly  Each received extensive review</p>
    <p>How do we find integer errors?</p>
  </div>
  <div class="page">
    <p>Finding integer errors</p>
    <p>Random tesWng  Low coverage: hard to trigger corner cases</p>
    <p>Symbolic model checking  Path explosion  Environment modeling</p>
    <p>KINT: staWc analysis for bug detecWon</p>
  </div>
  <div class="page">
    <p>KINT Overview</p>
    <p>Per-funcWon analysis</p>
    <p>Range analysis (whole-program)</p>
    <p>Taint analysis (whole-program)</p>
    <p>Solving &amp; classificaWon</p>
    <p>LLVM IR (from C code)</p>
    <p>Possible bugs</p>
    <p>User annotaWons</p>
  </div>
  <div class="page">
    <p>KINT Overview</p>
    <p>Per-funcWon analysis</p>
    <p>Range analysis (whole-program)</p>
    <p>Taint analysis (whole-program)</p>
    <p>Solving &amp; classificaWon</p>
    <p>LLVM IR (from C code)</p>
    <p>Possible bugs</p>
    <p>User annotaWons</p>
  </div>
  <div class="page">
    <p>Per-funcWon analysis</p>
    <p>Under what condiWon will n * 8 overflow?  Overflow condi9on: n &gt; MAX / 8</p>
    <p>Under what condiWon will n * 8 execute?  Bypass exisWng check if (n &gt; 1&lt;&lt;30)  Path condi9on: n  1&lt;&lt;30</p>
    <p>int foo(unsigned long n) { if (n &gt; 1&lt;&lt;30) return EINVAL; void *p = vmalloc(n * 8); ... }</p>
  </div>
  <div class="page">
    <p>Solving boolean constraints</p>
    <p>Symbolic query: combine overflow &amp; path condiWons  (n &gt; MAX / 8) AND (n  1&lt;&lt;30)</p>
    <p>Constraint solver: n = 1&lt;&lt;30  KINT: a possible bug</p>
    <p>int foo(unsigned long n) { if (n &gt; 1&lt;&lt;30) return EINVAL; void *p = vmalloc(n * 8); ... }</p>
  </div>
  <div class="page">
    <p>KINT Overview</p>
    <p>Per-funcWon analysis</p>
    <p>Range analysis (whole-program)</p>
    <p>Taint analysis (whole-program)</p>
    <p>Solving &amp; classificaWon</p>
    <p>LLVM IR (from C code)</p>
    <p>Possible bugs</p>
    <p>User annotaWons</p>
  </div>
  <div class="page">
    <p>Checks in caller</p>
    <p>n in [0, 100]  n * 8 cannot overflow</p>
    <p>void bar() { if (x &gt;= 0 &amp;&amp; x &lt;= 100)</p>
    <p>foo(x); }</p>
    <p>int foo(unsigned long n) { if (n &gt; 1&lt;&lt;30) return EINVAL; void *p = vmalloc(n * 8); ... }</p>
  </div>
  <div class="page">
    <p>A whole-program range analysis</p>
    <p>Goals  Reduce false posiWves  Scale to large programs with many funcWons</p>
    <p>Use two constants as bounds for each variable  Example: n in [0, 100]  Simpler to solve than overflow &amp; path condiWons</p>
    <p>IteraWvely propagate ranges across funcWons</p>
  </div>
  <div class="page">
    <p>KINT Overview</p>
    <p>Per-funcWon analysis</p>
    <p>Range analysis (whole-program)</p>
    <p>Taint analysis (whole-program)</p>
    <p>Solving &amp; classificaWon</p>
    <p>LLVM IR (from C code)</p>
    <p>Possible bugs</p>
    <p>User annotaWons</p>
  </div>
  <div class="page">
    <p>Taint analysis for bug classificaWon</p>
    <p>Users can provide annotaWons to classify bugs  OpWonal</p>
    <p>Users annotate untrusted input  Example: copy_from_user()  KINT propagates and labels bugs derived from untrusted input</p>
    <p>Users annotate sensiWve sinks  Example: kmalloc() size  KINT labels overflowed values as allocaWon size</p>
  </div>
  <div class="page">
    <p>KINT ImplementaWon</p>
    <p>LLVM compiler framework  Boolector constraint solver</p>
  </div>
  <div class="page">
    <p>KINT usage $ make CC=kint-gcc # generate LLVM IR *.ll $ kint-range-taint *.ll # whole program $ kint-checker *.ll # solving &amp; classifying bugs ========================================== Unsigned multiplication overflow (32-bit) fs/xfs/xfs_acl.c:199:3 Untrusted source: struct.posix_acl.a_count Sensitive sink: allocation size ==========================================</p>
  </div>
  <div class="page">
    <p>EvaluaWon</p>
    <p>EffecWveness in finding new bugs  False negaWves (missed errors)  False posiWves (not real errors)  Time to analyze Linux kernel</p>
  </div>
  <div class="page">
    <p>KINT finds new bugs</p>
    <p>114 in the Linux kernel shown in case study  5 in OpenSSH  1 in the lighRpd web server  All confirmed and fixed</p>
  </div>
  <div class="page">
    <p>KINT finds most known integer errors</p>
    <p>Test case: all 37 CVE integer bugs in past 3 yrs  Excluding those found by ourselves using KINT</p>
    <p>KINT found 36 out of 37 bugs  1 missing: overflow happens due to loops  KINT unrolls loops once for path condiWon</p>
  </div>
  <div class="page">
    <p>False posiWves (CVE)</p>
    <p>Test case: patches for 37 CVE bugs (past 3 yrs)  AssumpWon: patched code is correct  KINT reports 1 false error (out of 37)  Also found 2 incorrect fixes in CVE  Useful for validaWng patches</p>
  </div>
  <div class="page">
    <p>False posiWves (whole kernel)</p>
    <p>Linux kernel 3.4-rc1 in April 2012  125,172 possible bugs in total  741 ranked as risky  AllocaWon size computed from untrusted input</p>
    <p>Skimmed the 741 bugs in 5 hours  Found 11 real bugs  We dont know if the rest are real bugs</p>
  </div>
  <div class="page">
    <p>KINT analysis Wme</p>
    <p>Linux 3.4-rc1: 8,915 C files  6 CPU cores (w/ 2x SMT)  Total Wme: 3 hours</p>
  </div>
  <div class="page">
    <p>Summary of finding bugs with KINT</p>
    <p>100+ bugs in real-world systems  Linux kernel, OpenSSH, lighRpd</p>
    <p>Could have many more bugs  Difficult to inspect all possible bugs</p>
    <p>How to miWgate integer errors?</p>
  </div>
  <div class="page">
    <p>MiWgaWng allocaWon size overflow</p>
    <p>kmalloc(n * size)  Frequently used in the Linux kernel  Can lead to buffer overflow</p>
    <p>kmalloc_array(n, size)  Return NULL if n * size overflows  Since Linux 3.4-rc1</p>
  </div>
  <div class="page">
    <p>Generalized approach: NaN integer</p>
    <p>SemanWcs  Special NaN value: Not-A-Number  Any overflow results in NaN  Any operaWon with NaN results in NaN</p>
    <p>Easy to check for overflow  Check if final result is NaN</p>
    <p>ImplementaWon: modified Clang C compiler  Negligible overhead on x86: FLAGS register checks</p>
  </div>
  <div class="page">
    <p>Verbose manual check (had 3 bugs) size_t symsz = /* input */; size_t nr_events = /* input */; size_t histsz, totalsz;</p>
    <p>if (symsz &gt; (SIZE_MAX - sizeof(struct hist)) / sizeof(u64)) return -1;</p>
    <p>if (histsz &gt; (SIZE_MAX - sizeof(void *)) / nr_events) return -1;</p>
    <p>histsz = sizeof(struct hist) + symsz * sizeof(u64);</p>
    <p>totalsz = sizeof(void *) + nr_events * histsz; void *p = malloc(totalsz); if (p == NULL) return -1;</p>
  </div>
  <div class="page">
    <p>NaN integer example size_t symsz = /* input */; size_t nr_events = /* input */; size_t histsz, totalsz;</p>
    <p>nan nan nan</p>
    <p>histsz = sizeof(struct hist) + symsz * sizeof(u64); totalsz = sizeof(void *) + nr_events * histsz; void *p = malloc(totalsz); if (p == NULL) return -1;</p>
    <p>void *malloc(nan size_t size) { if (isnan(size)) return NULL; return libc_malloc((size_t)size); }</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Case study of integer errors in the Linux kernel  WriWng correct checks is non-trivial</p>
    <p>KINT: staWc detecWon of integer errors for C  Scalable analysis based on constraint solving  100+ bugs confirmed and fixed upstream</p>
    <p>kmalloc_array: safe array allocaWon  NaN integer: automated bounds checking  hRp://pdos.csail.mit.edu/kint/</p>
  </div>
</Presentation>
