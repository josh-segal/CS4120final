<?xml version="1.0" ?>
<Presentation>
  <div class="page"/>
  <div class="page">
    <p>In the past, people have said, maybe its 50 years away, its a dream,</p>
    <p>maybe itll happen sometime. I used to think it was 50. Now Im</p>
    <p>thinking like its 15 or a little more. Its within reach. Its within our</p>
    <p>lifetime. Its going to happen.</p>
    <p>Mark Ketchen (IBM), Feb. 2012, about quantum computers</p>
  </div>
  <div class="page">
    <p>The end of crypto as we know it</p>
    <p>Shors algorithm (1994)</p>
    <p>Factor integers in polynomial time</p>
    <p>Compute discrete logarithms in polynomial time</p>
    <p>Complete break of RSA, ElGamal, DSA, Diffie-Hellman</p>
    <p>Complete break of elliptic-curve variants (ECSDA, ECDH, . . . )</p>
  </div>
  <div class="page">
    <p>The end of crypto as we know it</p>
    <p>Shors algorithm (1994)</p>
    <p>Factor integers in polynomial time</p>
    <p>Compute discrete logarithms in polynomial time</p>
    <p>Complete break of RSA, ElGamal, DSA, Diffie-Hellman</p>
    <p>Complete break of elliptic-curve variants (ECSDA, ECDH, . . . )</p>
    <p>Forward-secure post-quantum crypto</p>
    <p>Threatening today:  Attacker records encrypted messages now  Uses quantum computer in 1-2 decades to break encryption</p>
  </div>
  <div class="page">
    <p>The end of crypto as we know it</p>
    <p>Shors algorithm (1994)</p>
    <p>Factor integers in polynomial time</p>
    <p>Compute discrete logarithms in polynomial time</p>
    <p>Complete break of RSA, ElGamal, DSA, Diffie-Hellman</p>
    <p>Complete break of elliptic-curve variants (ECSDA, ECDH, . . . )</p>
    <p>Forward-secure post-quantum crypto</p>
    <p>Threatening today:  Attacker records encrypted messages now  Uses quantum computer in 1-2 decades to break encryption</p>
    <p>Perfect forward secrecy (PFS) does not help  Countermeasure against key compromise  Not a countermeasure against cryptographic break</p>
  </div>
  <div class="page">
    <p>The end of crypto as we know it</p>
    <p>Shors algorithm (1994)</p>
    <p>Factor integers in polynomial time</p>
    <p>Compute discrete logarithms in polynomial time</p>
    <p>Complete break of RSA, ElGamal, DSA, Diffie-Hellman</p>
    <p>Complete break of elliptic-curve variants (ECSDA, ECDH, . . . )</p>
    <p>Forward-secure post-quantum crypto</p>
    <p>Threatening today:  Attacker records encrypted messages now  Uses quantum computer in 1-2 decades to break encryption</p>
    <p>Perfect forward secrecy (PFS) does not help  Countermeasure against key compromise  Not a countermeasure against cryptographic break</p>
    <p>Consequence: Want post-quantum PFS crypto today</p>
  </div>
  <div class="page">
    <p>Ring-Learning-with-errors (RLWE)</p>
    <p>Let Rq = Zq[X]/(Xn + 1)  Let  be an error distribution on Rq  Let s Rq be secret  Attacker is given pairs (a,as + e) with</p>
    <p>a uniformly random from Rq  e sampled from</p>
    <p>Task for the attacker: find s</p>
  </div>
  <div class="page">
    <p>Ring-Learning-with-errors (RLWE)</p>
    <p>Let Rq = Zq[X]/(Xn + 1)  Let  be an error distribution on Rq  Let s Rq be secret  Attacker is given pairs (a,as + e) with</p>
    <p>a uniformly random from Rq  e sampled from</p>
    <p>Task for the attacker: find s</p>
    <p>Common choice for : discrete Gaussian</p>
    <p>Common optimization for protocols: fix a</p>
  </div>
  <div class="page">
    <p>A bit of (R)LWE history</p>
    <p>Hoffstein, Pipher, Silverman, 1996: NTRU cryptosystem</p>
    <p>Regev, 2005: Introduce LWE-based encryption</p>
    <p>Lyubashevsky, Peikert, Regev, 2010: Ring-LWE and Ring-LWE encryption</p>
    <p>Ding, Xie, Lin, 2012: Transform to (R)LWE-based key exchange</p>
    <p>Peikert, 2014: Improved RLWE-based key exchange</p>
    <p>Bos, Costello, Naehrig, Stebila, 2015: Instantiate and implement Peikerts key exchange in TLS:</p>
  </div>
  <div class="page">
    <p>A bit of (R)LWE history</p>
    <p>Hoffstein, Pipher, Silverman, 1996: NTRU cryptosystem</p>
    <p>Regev, 2005: Introduce LWE-based encryption</p>
    <p>Lyubashevsky, Peikert, Regev, 2010: Ring-LWE and Ring-LWE encryption</p>
    <p>Ding, Xie, Lin, 2012: Transform to (R)LWE-based key exchange</p>
    <p>Peikert, 2014: Improved RLWE-based key exchange</p>
    <p>Bos, Costello, Naehrig, Stebila, 2015: Instantiate and implement Peikerts key exchange in TLS:</p>
    <p>Rq = Zq[X]/(Xn + 1)  n = 1024  q = 232  1   = DZ, (Discrete Gaussian) with  = 8/</p>
    <p>2  3.192</p>
  </div>
  <div class="page">
    <p>A bit of (R)LWE history</p>
    <p>Hoffstein, Pipher, Silverman, 1996: NTRU cryptosystem</p>
    <p>Regev, 2005: Introduce LWE-based encryption</p>
    <p>Lyubashevsky, Peikert, Regev, 2010: Ring-LWE and Ring-LWE encryption</p>
    <p>Ding, Xie, Lin, 2012: Transform to (R)LWE-based key exchange</p>
    <p>Peikert, 2014: Improved RLWE-based key exchange</p>
    <p>Bos, Costello, Naehrig, Stebila, 2015: Instantiate and implement Peikerts key exchange in TLS:</p>
    <p>Rq = Zq[X]/(Xn + 1)  n = 1024  q = 232  1   = DZ, (Discrete Gaussian) with  = 8/</p>
    <p>2  3.192</p>
    <p>Claimed security level: 128 bits pre-quantum  Failure probability:  2131072</p>
  </div>
  <div class="page">
    <p>BCNS key exchange</p>
    <p>Parameters: q = 232 1,n = 1024 Error distribution:  = DZ,, = 8/</p>
    <p>2</p>
    <p>Global system parameter: a $Rq</p>
    <p>Alice (server) Bob (client)</p>
    <p>s,e $  s,e,e $</p>
    <p>bas + e b uas + e</p>
    <p>vbs + e</p>
    <p>v $ dbl(v)</p>
    <p>u,v</p>
    <p>v = v2 rec(2us,v) v2</p>
    <p>Alice has 2us = 2ass + 2es</p>
    <p>Bob has v  2v = 2(bs + e) = 2((as + e)s + e) = 2ass + 2es + 2e</p>
  </div>
  <div class="page">
    <p>A new hope</p>
    <p>Our contributions</p>
    <p>Improve failure analysis and error reconciliation</p>
    <p>Choose parameters for failure probability  260</p>
  </div>
  <div class="page">
    <p>A new hope</p>
    <p>Our contributions</p>
    <p>Improve failure analysis and error reconciliation</p>
    <p>Choose parameters for failure probability  260  Keep dimension n = 1024</p>
    <p>Drastically reduce q to 12289 &lt; 214</p>
    <p>Higher security, shorter messages, and speedups</p>
  </div>
  <div class="page">
    <p>A new hope</p>
    <p>Our contributions</p>
    <p>Improve failure analysis and error reconciliation</p>
    <p>Choose parameters for failure probability  260  Keep dimension n = 1024</p>
    <p>Drastically reduce q to 12289 &lt; 214</p>
    <p>Higher security, shorter messages, and speedups</p>
    <p>Analysis of post-quantum security</p>
  </div>
  <div class="page">
    <p>A new hope</p>
    <p>Our contributions</p>
    <p>Improve failure analysis and error reconciliation</p>
    <p>Choose parameters for failure probability  260  Keep dimension n = 1024</p>
    <p>Drastically reduce q to 12289 &lt; 214</p>
    <p>Higher security, shorter messages, and speedups</p>
    <p>Analysis of post-quantum security</p>
    <p>Use centered binomial noise k (HW(a)HW(b) for k-bit a,b)</p>
  </div>
  <div class="page">
    <p>A new hope</p>
    <p>Our contributions</p>
    <p>Improve failure analysis and error reconciliation</p>
    <p>Choose parameters for failure probability  260  Keep dimension n = 1024</p>
    <p>Drastically reduce q to 12289 &lt; 214</p>
    <p>Higher security, shorter messages, and speedups</p>
    <p>Analysis of post-quantum security</p>
    <p>Use centered binomial noise k (HW(a)HW(b) for k-bit a,b)  Choose a fresh parameter a for every protocol run</p>
  </div>
  <div class="page">
    <p>A new hope</p>
    <p>Our contributions</p>
    <p>Improve failure analysis and error reconciliation</p>
    <p>Choose parameters for failure probability  260  Keep dimension n = 1024</p>
    <p>Drastically reduce q to 12289 &lt; 214</p>
    <p>Higher security, shorter messages, and speedups</p>
    <p>Analysis of post-quantum security</p>
    <p>Use centered binomial noise k (HW(a)HW(b) for k-bit a,b)  Choose a fresh parameter a for every protocol run</p>
    <p>Encode polynomials in NTT domain</p>
  </div>
  <div class="page">
    <p>A new hope</p>
    <p>Our contributions</p>
    <p>Improve failure analysis and error reconciliation</p>
    <p>Choose parameters for failure probability  260  Keep dimension n = 1024</p>
    <p>Drastically reduce q to 12289 &lt; 214</p>
    <p>Higher security, shorter messages, and speedups</p>
    <p>Analysis of post-quantum security</p>
    <p>Use centered binomial noise k (HW(a)HW(b) for k-bit a,b)  Choose a fresh parameter a for every protocol run</p>
    <p>Encode polynomials in NTT domain</p>
    <p>Multiple implementations</p>
  </div>
  <div class="page">
    <p>A new hope  protocol</p>
    <p>Parameters: q = 12289 &lt; 214, n = 1024</p>
    <p>Error distribution: 16</p>
    <p>Alice (server) Bob (client)</p>
    <p>seed ${0, 1}256</p>
    <p>aParse(SHAKE-128(seed)) s,e</p>
    <p>$ n16 s,e,e $ n16</p>
    <p>bas + e (b,seed) aParse(SHAKE-128(seed)) uas + e</p>
    <p>vbs + e</p>
    <p>v us (u,r) r $ HelpRec(v)</p>
    <p>kRec(v,r) kRec(v,r) SHA3-256(k) SHA3-256(k)</p>
    <p>Alice has v = us = ass + es</p>
    <p>Bob has v = bs + e = (as + e)s + e = ass + es + e</p>
  </div>
  <div class="page">
    <p>Error reconciliation</p>
    <p>After running the protocol  Alice has xA = ass</p>
    <p>+ es  Bob has xB = ass</p>
    <p>+ es + e</p>
    <p>Those elements are similar, but not the same</p>
    <p>Problem: How to agree on the same key from these noisy vectors?</p>
  </div>
  <div class="page">
    <p>Error reconciliation</p>
    <p>After running the protocol  Alice has xA = ass</p>
    <p>+ es  Bob has xB = ass</p>
    <p>+ es + e</p>
    <p>Those elements are similar, but not the same</p>
    <p>Problem: How to agree on the same key from these noisy vectors?</p>
    <p>Known: extract one bit from each coefficient</p>
    <p>Also known: extract multiple bits from each coefficient (decrease security)</p>
  </div>
  <div class="page">
    <p>Error reconciliation</p>
    <p>After running the protocol  Alice has xA = ass</p>
    <p>+ es  Bob has xB = ass</p>
    <p>+ es + e</p>
    <p>Those elements are similar, but not the same</p>
    <p>Problem: How to agree on the same key from these noisy vectors?</p>
    <p>Known: extract one bit from each coefficient</p>
    <p>Also known: extract multiple bits from each coefficient (decrease security)</p>
    <p>NewHope: extract one bit from multiple coefficients (increase security)</p>
    <p>Specifically: 1 bit from 4 coefficients  256-bit key from 1024 coefficients; method inspired by analog error-correcting codes</p>
  </div>
  <div class="page">
    <p>Error reconciliation</p>
    <p>After running the protocol  Alice has xA = ass</p>
    <p>+ es  Bob has xB = ass</p>
    <p>+ es + e</p>
    <p>Those elements are similar, but not the same</p>
    <p>Problem: How to agree on the same key from these noisy vectors?</p>
    <p>Known: extract one bit from each coefficient</p>
    <p>Also known: extract multiple bits from each coefficient (decrease security)</p>
    <p>NewHope: extract one bit from multiple coefficients (increase security)</p>
    <p>Specifically: 1 bit from 4 coefficients  256-bit key from 1024 coefficients; method inspired by analog error-correcting codes</p>
    <p>Generalize Peikerts approach to obtain unbiased keys</p>
  </div>
  <div class="page">
    <p>Post-quantum security</p>
    <p>Consider RLWE instance as LWE instance</p>
    <p>Attack using BKZ</p>
    <p>BKZ uses SVP oracle in smaller dimension</p>
    <p>Consider only the cost of one call to that oracle (core-SVP hardness)</p>
  </div>
  <div class="page">
    <p>Post-quantum security</p>
    <p>Consider RLWE instance as LWE instance</p>
    <p>Attack using BKZ</p>
    <p>BKZ uses SVP oracle in smaller dimension</p>
    <p>Consider only the cost of one call to that oracle (core-SVP hardness)</p>
    <p>Consider quantum sieve as SVP oracle  Best-known quantum cost (BKC): 20.265n</p>
    <p>Best-plausible quantum cost (BPC): 20.2075n</p>
  </div>
  <div class="page">
    <p>Post-quantum security</p>
    <p>Consider RLWE instance as LWE instance</p>
    <p>Attack using BKZ</p>
    <p>BKZ uses SVP oracle in smaller dimension</p>
    <p>Consider only the cost of one call to that oracle (core-SVP hardness)</p>
    <p>Consider quantum sieve as SVP oracle  Best-known quantum cost (BKC): 20.265n</p>
    <p>Best-plausible quantum cost (BPC): 20.2075n</p>
    <p>Obtain lower bounds on the bit security:</p>
    <p>Known Classical Known Quantum Best Plausible</p>
    <p>BCNS 86 78 61</p>
    <p>NewHope 281 255 199</p>
  </div>
  <div class="page">
    <p>Against all authority</p>
    <p>Remember the optimization of fixed a?</p>
    <p>What if a is backdoored?</p>
    <p>Parameter-generating authority can break key exchange</p>
    <p>Solution: Nothing-up-my-sleeves (involves endless discussion!)</p>
  </div>
  <div class="page">
    <p>Against all authority</p>
    <p>Remember the optimization of fixed a?</p>
    <p>What if a is backdoored?</p>
    <p>Parameter-generating authority can break key exchange</p>
    <p>Solution: Nothing-up-my-sleeves (involves endless discussion!)</p>
    <p>Even without backdoor:  Perform massive precomputation based on a  Use precomputation to break all key exchanges  Infeasible today, but who knows. . .  Attack in the spirit of Logjam</p>
  </div>
  <div class="page">
    <p>Against all authority</p>
    <p>Remember the optimization of fixed a?</p>
    <p>What if a is backdoored?</p>
    <p>Parameter-generating authority can break key exchange</p>
    <p>Solution: Nothing-up-my-sleeves (involves endless discussion!)</p>
    <p>Even without backdoor:  Perform massive precomputation based on a  Use precomputation to break all key exchanges  Infeasible today, but who knows. . .  Attack in the spirit of Logjam</p>
    <p>Solution in NewHope: Choose a fresh a every time</p>
    <p>Use SHAKE-128 to expand a 32-byte seed</p>
  </div>
  <div class="page">
    <p>Against all authority</p>
    <p>Remember the optimization of fixed a?</p>
    <p>What if a is backdoored?</p>
    <p>Parameter-generating authority can break key exchange</p>
    <p>Solution: Nothing-up-my-sleeves (involves endless discussion!)</p>
    <p>Even without backdoor:  Perform massive precomputation based on a  Use precomputation to break all key exchanges  Infeasible today, but who knows. . .  Attack in the spirit of Logjam</p>
    <p>Solution in NewHope: Choose a fresh a every time</p>
    <p>Use SHAKE-128 to expand a 32-byte seed</p>
    <p>Server can cache a for some time (e.g., 1h)</p>
  </div>
  <div class="page">
    <p>Against all authority</p>
    <p>Remember the optimization of fixed a?</p>
    <p>What if a is backdoored?</p>
    <p>Parameter-generating authority can break key exchange</p>
    <p>Solution: Nothing-up-my-sleeves (involves endless discussion!)</p>
    <p>Even without backdoor:  Perform massive precomputation based on a  Use precomputation to break all key exchanges  Infeasible today, but who knows. . .  Attack in the spirit of Logjam</p>
    <p>Solution in NewHope: Choose a fresh a every time</p>
    <p>Use SHAKE-128 to expand a 32-byte seed</p>
    <p>Server can cache a for some time (e.g., 1h)</p>
    <p>Must not reuse keys/noise!</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Multiplication in Rq using number-theoretic transform (NTT)  Message format:</p>
    <p>Send polynomials in NTT domain  Eliminate two of the required NTTs</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Multiplication in Rq using number-theoretic transform (NTT)  Message format:</p>
    <p>Send polynomials in NTT domain  Eliminate two of the required NTTs</p>
    <p>C reference implementation:  Arithmetic on 16-bit and 32-bit integers  No division (/) or modulo (%) operator  Use Montgomery reductions inside NTT  Use ChaCha20 for noise sampling</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Multiplication in Rq using number-theoretic transform (NTT)  Message format:</p>
    <p>Send polynomials in NTT domain  Eliminate two of the required NTTs</p>
    <p>C reference implementation:  Arithmetic on 16-bit and 32-bit integers  No division (/) or modulo (%) operator  Use Montgomery reductions inside NTT  Use ChaCha20 for noise sampling</p>
    <p>AVX2 implementation:  Speed up NTT using vectorized double arithmetic  Use AVX2 for centered binomial  Use AVX2 for error reconciliation  Use AES-256 for noise sampling</p>
  </div>
  <div class="page">
    <p>Performance</p>
    <p>BCNS C ref AVX2</p>
    <p>Key generation (server)  2 477 958 258 246 88 920 Key gen + shared key (client)  3 995 977 384 994 110 986 Shared key (server)  481 937 86 280 19 422</p>
    <p>Cycle counts from one core of an Intel i7-4770K (Haswell)</p>
    <p>BCNS benchmarks are derived from openssl speed</p>
    <p>Includes around  37 000 cycles for generation of a on each side  Compare to X25519 elliptic-curve scalar mult: 156 092 cycles</p>
  </div>
  <div class="page">
    <p>NewHope in the real world</p>
    <p>July 7, Google announces 2-year post-quantum experiment  NewHope+X25519 (CECPQ1) in BoringSSL for Chrome Canary  Used in access to select Google services</p>
    <p>Image source: https://security.googleblog.com/2016/07/experimenting-with-post-quantum.html</p>
  </div>
  <div class="page">
    <p>NewHope online Paper: https://cryptojedi.org/papers/#newhope</p>
    <p>Software: https://cryptojedi.org/crypto/#newhope</p>
  </div>
  <div class="page">
    <p>NewHope online Paper: https://cryptojedi.org/papers/#newhope</p>
    <p>Software: https://cryptojedi.org/crypto/#newhope</p>
    <p>Newhope for ARM: https://github.com/newhopearm/newhopearm.git</p>
    <p>(by Erdem Alkim, Philipp Jakubeit, and Peter Schwabe)</p>
    <p>Newhope in Go: https://github.com/Yawning/newhope</p>
    <p>(by Yawning Angel)</p>
    <p>Newhope in Rust: https://code.ciph.re/isis/newhopers</p>
    <p>(by Isis Lovecruft)</p>
    <p>Newhope in Java: https://github.com/rweather/newhope-java</p>
    <p>(by Rhys Weatherley)</p>
    <p>Newhope in Erlang: https://github.com/ahf/luke</p>
    <p>(by Alexander Fry)</p>
    <p>newhope@cryptojedi.org</p>
  </div>
</Presentation>
