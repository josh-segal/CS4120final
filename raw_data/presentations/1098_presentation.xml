<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Touchstone: Generating Enormous Query-Aware Test Databases</p>
    <p>Yuming Li1, Rong Zhang1, Xiaoyan Yang2,</p>
    <p>Zhenjie Zhang2, Aoying Zhou1</p>
  </div>
  <div class="page">
    <p>Test Databases Are Important!</p>
    <p>Application scenarios: DBMS testing, database application testing, application-driven benchmarking.</p>
  </div>
  <div class="page">
    <p>Test Databases Are Important!</p>
    <p>Application scenarios: DBMS testing, database application testing, application-driven benchmarking.</p>
  </div>
  <div class="page">
    <p>Test Databases Are Important!</p>
    <p>Application scenarios: DBMS testing, database application testing, application-driven benchmarking.</p>
  </div>
  <div class="page">
    <p>Test Databases Are Important!</p>
    <p>Application scenarios: DBMS testing, database application testing, application-driven benchmarking.</p>
  </div>
  <div class="page">
    <p>Test Databases Are Important!</p>
    <p>Application scenarios: DBMS testing, database application testing, application-driven benchmarking.</p>
  </div>
  <div class="page">
    <p>Test Databases Are Important!</p>
    <p>Application scenarios: DBMS testing, database application testing, application-driven benchmarking.</p>
  </div>
  <div class="page">
    <p>Random Test Database Is Deficient!</p>
    <p>The random test database has the same database schema and data characteristics as database generated by dbgen.</p>
    <p>There are huge execution cost differences between realistic database (dbgen) and synthetic database (random).</p>
    <p>Comparing the query latencies over database generated by dbgen and database randomly generated.</p>
    <p>The average relative error of query latencies is 175%!!</p>
  </div>
  <div class="page">
    <p>Query-Aware Data Generation</p>
    <p>Input: database schema, data characteristics and workload characteristics.</p>
    <p>Output: test database and instantiated query parameters.</p>
  </div>
  <div class="page">
    <p>Query-Aware Data Generation</p>
    <p>Input: database schema, data characteristics and workload characteristics.</p>
    <p>Output: test database and instantiated query parameters.</p>
  </div>
  <div class="page">
    <p>Query-Aware Data Generation</p>
    <p>Input: database schema, data characteristics and workload characteristics.</p>
    <p>Output: test database and instantiated query parameters.</p>
  </div>
  <div class="page">
    <p>Query-Aware Data Generation</p>
    <p>Input: database schema, data characteristics and workload characteristics.</p>
    <p>Output: test database and instantiated query parameters.</p>
  </div>
  <div class="page">
    <p>Query-Aware Data Generation</p>
    <p>Input: database schema, data characteristics and workload characteristics.</p>
    <p>Output: test database and instantiated query parameters.</p>
  </div>
  <div class="page">
    <p>Query-Aware Data Generation</p>
    <p>Input: database schema, data characteristics and workload characteristics.</p>
    <p>Output: test database and instantiated query parameters.</p>
  </div>
  <div class="page">
    <p>Query-Aware Data Generation</p>
    <p>Input: database schema, data characteristics and workload characteristics.</p>
    <p>Output: test database and instantiated query parameters.</p>
    <p>Parameterized queries</p>
  </div>
  <div class="page">
    <p>Query-Aware Data Generation</p>
    <p>Input: database schema, data characteristics and workload characteristics.</p>
    <p>Output: test database and instantiated query parameters.</p>
    <p>Variable parameters</p>
  </div>
  <div class="page">
    <p>Query-Aware Data Generation</p>
    <p>Input: database schema, data characteristics and workload characteristics.</p>
    <p>Output: test database and instantiated query parameters.</p>
    <p>Cardinality constraints</p>
  </div>
  <div class="page">
    <p>Query-Aware Data Generation</p>
    <p>Input: database schema, data characteristics and workload characteristics.</p>
    <p>Output: test database and instantiated query parameters.</p>
    <p>All 14 cardinality constraints</p>
  </div>
  <div class="page">
    <p>Query-Aware Data Generation</p>
    <p>Input: database schema, data characteristics and workload characteristics.</p>
    <p>Output: test database and instantiated query parameters.</p>
    <p>Cardinality constraints on Q1</p>
    <p>c1 c2</p>
    <p>c3</p>
  </div>
  <div class="page">
    <p>Query-Aware Data Generation</p>
    <p>Input: database schema, data characteristics and workload characteristics.</p>
    <p>Output: test database and instantiated query parameters.</p>
    <p>Output</p>
  </div>
  <div class="page">
    <p>Comparison to Related Works</p>
    <p>The performance of state-of-the-art solutions remains far from satisfactory.</p>
    <p>QAGen SIGMOD 2007</p>
    <p>WAGen VLDB 2010</p>
    <p>DCGen SIGMOD 2011</p>
    <p>MyBenchmark VLDBJ 2014</p>
    <p>Touchstone ATC 2018</p>
    <p>Full Parallelization No No Yes No Yes</p>
    <p>Linear Scalability No No No No Yes</p>
    <p>Austere Mem Consumption No No No No Yes</p>
    <p>Wide Workload Support No No No No Yes</p>
    <p>Minimal Human Effort Yes Yes No Yes Yes</p>
    <p>Touchstone is the first query-aware data generator which can support full parallel data generation on multiple nodes. And Touchstone is capable of supporting industrial scale database generation.</p>
  </div>
  <div class="page">
    <p>Why do Previous Studies not Work?</p>
    <p>Primitive data generation algorithm</p>
    <p>Can not support fully parallel data generation in a distributed environment;</p>
    <p>Can not support the non-equi-join workload.</p>
    <p>Huge intermediate state dataset</p>
    <p>The memory consumption strongly depends on the size of generation outputs;</p>
    <p>Is not scalable in generation database size.</p>
  </div>
  <div class="page">
    <p>How does Touchstone Solve These Problems?</p>
    <p>New query instantiation scheme</p>
    <p>Algorithms: binary search, random sampling;</p>
    <p>Function: instantiating all the variable parameters.</p>
    <p>New data generation scheme</p>
    <p>Algorithms: data generation using constraint chains, data compression on join information table;</p>
    <p>Function: facilitating parallel data generation on multiple nodes with austere memory consumption.</p>
  </div>
  <div class="page">
    <p>Overall Architecture</p>
    <p>Query instantiation  Initialize random column</p>
    <p>generators;  Instantiate symbolic query</p>
    <p>parameters.</p>
    <p>Data generation  Decompose the query trees</p>
    <p>annotated with cardinality constraints into constraint chains;</p>
    <p>Generate data in parallel on multiple nodes.</p>
  </div>
  <div class="page">
    <p>Overall Architecture</p>
    <p>Query instantiation  Initialize random column</p>
    <p>generators;  Instantiate symbolic query</p>
    <p>parameters.</p>
    <p>Data generation  Decompose the query trees</p>
    <p>annotated with cardinality constraints into constraint chains;</p>
    <p>Generate data in parallel on multiple nodes.</p>
    <p>Determine the data distribution of columns</p>
  </div>
  <div class="page">
    <p>Overall Architecture</p>
    <p>Query instantiation  Initialize random column</p>
    <p>generators;  Instantiate symbolic query</p>
    <p>parameters.</p>
    <p>Data generation  Decompose the query trees</p>
    <p>annotated with cardinality constraints into constraint chains;</p>
    <p>Generate data in parallel on multiple nodes.</p>
  </div>
  <div class="page">
    <p>Experiments</p>
    <p>Test environment</p>
    <p>Cluster: 8 nodes</p>
    <p>CPU: 2 * Intel Xeon E5-2620 @ 2.0 GHz</p>
    <p>DRAM: 64GB</p>
    <p>Disk: 3TB HDD configured in RAID-5</p>
    <p>Network: 1 Gigabit Ethernet</p>
    <p>Test workloads</p>
    <p>TPC-H benchmark (the first 16 queries) &amp; Star schema benchmark (all 13 queries)</p>
    <p>Comparison</p>
    <p>MyBenchmark [VLDBJ 2014]</p>
  </div>
  <div class="page">
    <p>Touchstone outperforms MyBenchmark on data generation throughput by orders</p>
  </div>
  <div class="page">
    <p>The memory consumption of Touchstone is minimal</p>
  </div>
  <div class="page">
    <p>Touchstone has linear scalability</p>
  </div>
  <div class="page">
    <p>The workload on synthetic database matches the expectation on result cardinality and query latency</p>
  </div>
  <div class="page">
    <p>Limitations &amp; Conclusion</p>
    <p>Limitations:</p>
    <p>Touchstone does not support filters on key columns;</p>
    <p>Equality constraints over filters involving multiple columns are not supported;</p>
    <p>Equi-joins on columns with no reference constraint are not supported;</p>
    <p>Touchstone does not support the database schema with cyclic reference relationship.</p>
    <p>Conclusion:</p>
    <p>Touchstone is a query-aware data generator with characteristics of completely parallelizable and bounded usage to memory. And Touchstone is linearly scalable to computing resource and data scale.</p>
  </div>
  <div class="page">
    <p>Thank you!! Q &amp; A https://github.com/daseECNU/Touchstone.</p>
  </div>
  <div class="page">
    <p>Test Databases Are Important!</p>
    <p>Applications: DBMS testing, database application testing, applicationdriven benchmarking.</p>
  </div>
  <div class="page">
    <p>Random Column Generator</p>
    <p>Random index generator outputs indexes from 0 to n-1 while n is the specified cardinality, and manipulates the data distribution of column values.</p>
    <p>Index2Value transformer deterministically maps the index to a concrete value in the specified domain of the column.</p>
  </div>
  <div class="page">
    <p>Query Instantiation</p>
    <p>The query instantiation is responsible for handling three types of cardinality constraints, i.e., =</p>
    <p>,   ,</p>
    <p>. The fourth type of constraints =  is taken care of by the data generation process at runtime.</p>
    <p>This is an iterative process!</p>
  </div>
  <div class="page">
    <p>Equality Constraints over Filters</p>
    <p>(40-32) / 40 = 20% Size of table T: 50</p>
    <p>(1) Randomly select an index and obtain the corresponding value for instantiating the parameter;</p>
    <p>(2) Update the occurrence probability of the selected index in the column generator;</p>
    <p>(3) Calculate the cumulative probabilities in the probability table.</p>
  </div>
  <div class="page">
    <p>Non-Equality Constraints over Filters</p>
    <p>Run a binary search over the parameter domain to find the optimal concrete parameter based on the fixed column data distribution.</p>
    <p>Using the random sampling algorithm to evaluate the probability of tuples satisfying the instantiated predicate.</p>
    <p>Parameter searching procedure</p>
  </div>
  <div class="page">
    <p>Non-Equality Constraints over Joins</p>
    <p>We must process the constraints in a bottom-up manner, because the columns involved in constraints</p>
    <p>may overlap with the columns in the child nodes.</p>
    <p>Probability is not independent!</p>
    <p>The processing strategy for each constraint in   is the same as the constraint</p>
    <p>in   (binary search &amp; random sampling).</p>
  </div>
  <div class="page">
    <p>Data Generation</p>
    <p>The data generation component is responsible for assembling tuples based on the outputs of the column generators.</p>
    <p>The key technical challenge here is to meet the equality constraints over the join operators, i.e., =</p>
    <p>, which involve the dependencies among primary and foreign keys from multiple tables.</p>
  </div>
  <div class="page">
    <p>Compilation Step</p>
    <p>Focus on the manipulation of primary key and foreign keys.</p>
  </div>
  <div class="page">
    <p>Assembling Step</p>
    <p>(1) Incrementally assign a primary key;</p>
    <p>(2) Fill values in the non-key columns by calling the random column generators;</p>
    <p>(3) Identify the appropriate candidate referenced keys for each foreign key;</p>
    <p>(4) Maintain the join information of the primary key.</p>
    <p>Store up to L values!</p>
  </div>
  <div class="page">
    <p>Handling Mismatch Cases</p>
    <p>There are some joinability statuses of the primary key that never occur!</p>
    <p>Therefore, in the tuple generation, it should be avoided to search such referenced primary key.</p>
    <p>The main idea is to add rules to manipulate relevant FK constraints. An example of adjustments to FK constraints</p>
  </div>
</Presentation>
