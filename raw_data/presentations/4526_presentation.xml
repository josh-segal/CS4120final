<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Grokking Software Architecture</p>
    <p>Richard C. Holt Software Architecture Group (SWAG)</p>
    <p>School of Computer Science, University of Waterloo, Canada</p>
  </div>
  <div class="page">
    <p>Retrospective 1998</p>
    <p>influential paper. Structural</p>
    <p>Manipulations of Software</p>
    <p>Architecture using Tarski Relational</p>
    <p>Algebra</p>
    <p>Today. Retrospective.</p>
    <p>Grokking Software</p>
    <p>Architecture</p>
  </div>
  <div class="page">
    <p>Grokking Software Architecture</p>
    <p>Grokking</p>
    <p>Software architecture</p>
  </div>
  <div class="page">
    <p>Overview of Talk: 4 Parts</p>
    <p>Part 1. 1998 paper: Hopes &amp; claims</p>
    <p>Part 2. Software Architecture</p>
    <p>Part 3. Formalizing Boxology</p>
    <p>Part 4. ROP: Relation-Oriented Programming &amp; Grok-Like Languages</p>
  </div>
  <div class="page">
    <p>Part 1. 1998 paper: Hopes &amp; claims</p>
    <p>Represent software architecture as a typed graph  Graphs with colors of edges &amp; nodes</p>
    <p>Manipulate &amp; visualize these architectural graphs</p>
    <p>Manipulations can be specified algebraically --- and automatically executed</p>
    <p>In brief: Formalize architectural diagrams and reap the benefits arising from the corresponding mathematics.</p>
  </div>
  <div class="page">
    <p>Top View of As-Built Software Architecture (250KLOC System)</p>
  </div>
  <div class="page">
    <p>View of One Subsystem of the 250 KLOC System</p>
    <p>ds</p>
    <p>dsinit</p>
    <p>mrgs</p>
    <p>dslvbb</p>
    <p>mdlv</p>
    <p>include</p>
    <p>dslvrg dselim</p>
    <p>lvlist</p>
    <p>memuse dbg</p>
    <p>Optimiz</p>
    <p>PL_ GEN VN SUPPORT FLOW</p>
    <p>DS.ss</p>
  </div>
  <div class="page">
    <p>CS 746G Topics in Software Architecture</p>
    <p>University of Waterloo</p>
  </div>
  <div class="page">
    <p>Process of View Creation</p>
    <p>Parser</p>
    <p>Grok: Fact manipulator</p>
    <p>Layouter Browser</p>
    <p>Clustering</p>
    <p>Source code</p>
    <p>Facts extracted from code</p>
    <p>Hierarchic decomposition</p>
    <p>Architectural diagram</p>
  </div>
  <div class="page">
    <p>Transformations to do Hiding</p>
    <p>a</p>
    <p>b</p>
    <p>c d</p>
    <p>e f</p>
    <p>g h</p>
    <p>T</p>
    <p>V S</p>
    <p>b</p>
    <p>a T</p>
    <p>V</p>
    <p>Graph G</p>
    <p>Graph H = hide(hide(G,T),V)</p>
    <p>d</p>
    <p>e f</p>
    <p>Graph I = hideExt(G, S)</p>
  </div>
  <div class="page">
    <p>Lifting Calls Up to File Level</p>
    <p>call is a procedure call fileCall is a file level call</p>
    <p>fileCall := funcDef o call o inv funcDcl</p>
    <p>main.c</p>
    <p>startup</p>
    <p>start.h</p>
    <p>main call</p>
    <p>funcDef funcDcl</p>
    <p>Procedure body Procedure header</p>
    <p>File File fileCall</p>
  </div>
  <div class="page">
    <p>Part 2. Software Architecture: Boxology Approach</p>
    <p>Software architecture:  What is it?  State of practice  How is it represented  Keep It simple  Models &amp; tools  Views of architecture</p>
    <p>Extracting As-Built architecture</p>
  </div>
  <div class="page">
    <p>Software Architecture: What is it?</p>
    <p>Confusion. I have a sneaking suspicion that architecture is one of the most overused and least understood terms in professional software development circles. Gorton</p>
    <p>Consensus. Architecture captures system structure in terms of components [parts] and how they interact. Gorton</p>
  </div>
  <div class="page">
    <p>Software Architecture: State of the Practice</p>
    <p>Its common for there to be little or no documentation covering the architecture in many projects. Gorton</p>
    <p>I'm hopeless when it comes to documentation. Torvalds</p>
    <p>The architecture that actually predominates in practice is the big ball of mud  Foote et al</p>
  </div>
  <div class="page">
    <p>Software as Spaghetti</p>
    <p>Foote et al</p>
  </div>
  <div class="page">
    <p>Software Architecture: How is it Represented in Practice?</p>
    <p>predominant tools used for architecture documentation are Microsoft Word, Visio and Power Point Gorton</p>
    <p>Whats needed: Concepts, notations and tools that are  easy to use and</p>
    <p>help us produce useful, understandable documentation</p>
  </div>
  <div class="page">
    <p>KISS: Keep it Simple Stupid</p>
    <p>Any fool can make things bigger, more complex, and more violent. It takes a touch of genius - and a lot of courage - to move in the opposite direction. Einstein</p>
    <p>Make everything as simple as possible, but not simpler. Einstein</p>
  </div>
  <div class="page">
    <p>Models and Tools for Software Architecture</p>
    <p>UML has, for better or (many would say) worse, become the industry standard ADL [Architecture Design Language] Shaw</p>
    <p>UML lacks, however, a robust suite of tools for analysis, consistency checking Shaw</p>
  </div>
  <div class="page">
    <p>UML Component Diagram: Box and Arrow Diagram</p>
    <p>id Component View</p>
    <p>OrderProcessing</p>
    <p>MailQueue</p>
    <p>SendEmail</p>
    <p>MailServer</p>
    <p>OrderSystem</p>
    <p>CustomerSystem OrderQueue</p>
    <p>table</p>
    <p>NewOrders</p>
    <p>readQ</p>
    <p>read</p>
    <p>writeQ</p>
    <p>Gorton</p>
  </div>
  <div class="page">
    <p>As-Built View</p>
    <p>Views of Software Architecture Kruchten</p>
    <p>Users View</p>
    <p>Deployment View</p>
    <p>Concurrency View</p>
    <p>End user</p>
    <p>System EngineerIntegrator</p>
    <p>Programmers &amp; software managers</p>
    <p>Scenarios</p>
  </div>
  <div class="page">
    <p>Extracting the As-Built Architecture from the Code</p>
    <p>Reverse engineering is the process of analyzing a subject system to create representations of the system at a higher level of abstraction. Chikofsky</p>
    <p>Relational approach.  Parse the code to produce relations, e.g</p>
    <p>(call, P, Q) means proc P calls Q</p>
    <p>Manipulate edges into as-built architecture</p>
  </div>
  <div class="page">
    <p>Boxology as a Central ADL (Architectural Design Language)</p>
    <p>The most widely used design notation [for software architecture] is informal block and arrow diagrams. Gorton</p>
  </div>
  <div class="page">
    <p>Cross Fertilization!! Rev Eng, S/W Arch, Relational Approach</p>
    <p>Reverse engineering  Architecture extraction  As-Built view: Code is king  Traceability</p>
    <p>Software architecture  Need for representation &amp; tools  Simplicity &amp; utility</p>
    <p>Relational approach  Boxology  Formalization --- Tarski algebra</p>
  </div>
  <div class="page">
    <p>Part 3. Formalizing Boxology</p>
    <p>Boxology is the Representation of an organized structure as a graph of labeled nodes (boxes) and connections between them (as lines or arrows). Wikipedia</p>
    <p>Toward boxology: preliminary classification of architectural styles Shaw</p>
  </div>
  <div class="page">
    <p>Example Typed Graph r</p>
    <p>a b</p>
    <p>CC</p>
    <p>v w x y z</p>
    <p>C C C E C C</p>
    <p>I</p>
    <p>U U</p>
    <p>v</p>
    <p>w</p>
    <p>x y</p>
    <p>z a b</p>
    <p>r</p>
    <p>U U</p>
    <p>I</p>
    <p>E</p>
    <p>C = { (r,a), (r,b), (a,v), (a,w) (a,x), (b,y), (b,z) } I = { (a,b) } E = { (b,y) } U = { (v,w), (x,y) }</p>
  </div>
  <div class="page">
    <p>Boxology is Just Scribbling?</p>
    <p>Box &amp; arrow diagrams  Are just scribbles? No</p>
    <p>Formalized by typed graphs</p>
    <p>Visualized as (nested) boxes &amp; arrows</p>
    <p>Manipulated by Tarski algebra etc.</p>
    <p>Exchanged as  Triples (RSF), extended to TA, or GXL or</p>
  </div>
  <div class="page">
    <p>Boxology has Semantics? Yes</p>
    <p>Compare to BNF  Semantics by informal attachment to productions</p>
    <p>Compare to Codds relational approach  Semantics by interpretation of tables.</p>
    <p>Semantics by attributes &amp; descriptions  Separation of concerns  Structure then semantics</p>
    <p>Use box/arrow diagrams as underlying formalism for software architecture (Mini-MOF?)</p>
  </div>
  <div class="page">
    <p>Adding Algebra to Boxology</p>
    <p>Tables then Codd relational algebra  N-ary relations</p>
    <p>Boxes/arrows then Tarski relational algebra  Binary relations</p>
  </div>
  <div class="page">
    <p>Example Typed Graph r</p>
    <p>a b</p>
    <p>CC</p>
    <p>v w x y z</p>
    <p>C C C E C C</p>
    <p>I</p>
    <p>U U</p>
    <p>v</p>
    <p>w</p>
    <p>x y</p>
    <p>z a b</p>
    <p>r</p>
    <p>U U</p>
    <p>I</p>
    <p>E</p>
    <p>C = { (r,a), (r,b), (a,v), (a,w) (a,x), (b,y), (b,z) } I = { (a,b) } E = { (b,y) } U = { (v,w), (x,y) }</p>
  </div>
  <div class="page">
    <p>Tarski Algebraic Operators</p>
    <p>Union I + E = {(a,b), (b,y)} Intersection E ^ C = {(b,y)} Difference C - E = {(r,a), (r,b), (a,v), (a,w), (a,x), (b,z)} Inverse inv E = {(y,b)} Composition I o E = {(a,y)} Identity id = {(r,r), (a, a), (b,b), (w,w)  } Transitive Cl. C+ = {(r,a), (r, b), (r,v), (r,w), (r,x), (r,y),</p>
    <p>(r,z), (a,v), (a,w), (a,x), (b,y), (b,z)} Reflex. T.C. C* = ID + C+</p>
  </div>
  <div class="page">
    <p>A Schema in TA  Determines</p>
    <p>Types of boxes</p>
    <p>Types of edges</p>
    <p>Allowed connectivity between edges</p>
    <p>Supports inheritance in schemas</p>
    <p>Also attributes (strings) on boxes &amp; on edges</p>
    <p>call</p>
    <p>TA Schemas for Box and Arrow Diagrams</p>
    <p>instance</p>
    <p>proc var</p>
    <p>p q x y</p>
    <p>call</p>
    <p>instance instance</p>
    <p>instance</p>
    <p>ref</p>
    <p>ref</p>
    <p>Malton WCRE 2005</p>
  </div>
  <div class="page">
    <p>Why Formalize Boxology?? Cause it Makes Our Life Better</p>
    <p>Clear understanding &amp; clear specification  What does RSF meaning?  Meaning is independent of implementation  Clarifies deeper concepts, e.g., expressiveness</p>
    <p>Generality  Progress in reverse engineering  Progress in software architecture  Not just scribbling</p>
  </div>
  <div class="page">
    <p>Part 4. ROP: Relation-Oriented Programming &amp;</p>
    <p>Grok-Like Languages</p>
    <p>A paradigm shift</p>
  </div>
  <div class="page">
    <p>Example: Mickey Eats Swiss Cheese  Mickey . eat</p>
    <p>Swiss  Roquefort</p>
    <p>eat . Mickey  Garfield  Fluffy</p>
    <p>eat o eat  (Garfield Swiss)  (Garfield Roquefort)  (Fluffy Swiss)  (Fluffy Roquefort)</p>
    <p>eat+  ,,,</p>
    <p>Garfield Fluffy</p>
    <p>NancyMickey</p>
    <p>RoquefortSwiss</p>
    <p>The eat relation</p>
  </div>
  <div class="page">
    <p>Example ROP/Grok Program: Is relation R a tree?</p>
    <p>How you would program this test</p>
  </div>
  <div class="page">
    <p>Grok Program: Is R a Tree?</p>
    <p>if R has no loops &amp;</p>
    <p>R has one root &amp;</p>
    <p>R has only single parents then</p>
    <p>put R is a tree</p>
    <p>Pseudo code</p>
    <p>Assume each node is a source or target of the contain C relation</p>
  </div>
  <div class="page">
    <p>Grok Program: Is R a Tree?</p>
    <p>if R has no loops</p>
    <p>Pseudo code Grok code</p>
    <p>if # ( R+ ^ ID ) = 0</p>
    <p>a b c d R</p>
    <p>R</p>
    <p>R R</p>
    <p>Does transitive closure of R have any self-loops? Yes</p>
  </div>
  <div class="page">
    <p>Grok Program: Is R a Tree?</p>
    <p>if R has no loops &amp;</p>
    <p>R has one root</p>
    <p>Pseudo code Grok code</p>
    <p>if # ( R+ ^ ID ) = 0 &amp;</p>
    <p># (dom R - rng R) = 1</p>
    <p>a</p>
    <p>b c</p>
    <p>d ge f</p>
    <p>dom</p>
    <p>rng</p>
    <p>Does R have exactly one source? Yes</p>
  </div>
  <div class="page">
    <p>Grok Program: Is R a Tree?</p>
    <p>if R has no loops &amp;</p>
    <p>R has one root &amp;</p>
    <p>R has only single parents</p>
    <p>Pseudo code Grok code</p>
    <p>if # ( R+ ^ ID ) = 0 &amp;</p>
    <p># (dom R - rng R) = 1 &amp;</p>
    <p># ((R o inv R) - ID) != 0</p>
    <p>b</p>
    <p>c</p>
    <p>d</p>
    <p>a</p>
    <p>R inv R</p>
    <p>R o inv R</p>
    <p>Does my child have another parent? Yes</p>
  </div>
  <div class="page">
    <p>Grok Program: Is R a Tree?</p>
    <p>if R has no loops &amp;</p>
    <p>R has one root &amp;</p>
    <p>R has only single parents then</p>
    <p>put R is a tree</p>
    <p>Pseudo code Grok code</p>
    <p>if # ( R+ ^ ID ) = 0 &amp;</p>
    <p># (dom R - rng R) = 1 &amp;</p>
    <p># ((R o inv R) - ID) != 0</p>
    <p>then</p>
    <p>put R is a tree</p>
    <p>Moral: Relational progamming is not like low level (Java level) programming. Loops typically disappear.</p>
  </div>
  <div class="page">
    <p>Notation: Does it Matter?</p>
    <p>By relieving the brain of all unnecessary work, a good notation sets it free to concentrate on more advanced problems, and, in effect, increases the mental power of the race. Alfred North Whitehead</p>
  </div>
  <div class="page">
    <p>Wins &amp; Losses Using Tarski Algebra</p>
    <p>Wins  Good for computing new edges, for finding</p>
    <p>properties of edges, eg, nodes in loops, leaves, etc.</p>
    <p>Losses  Not good for locating patterns involving several</p>
    <p>nodes, e.g., find complete connected sub-graphs</p>
  </div>
  <div class="page">
    <p>Notation: Grok (Tarski) vs. Crocopat</p>
    <p>S := P o C S(x,z) := EX(y, P(x,y) &amp; C(y,z))</p>
    <p>y</p>
    <p>zx</p>
    <p>My parents (P) children (C) are my (reflexive) siblings (S)</p>
    <p>Grok Crocopat</p>
    <p>P PC C</p>
    <p>S S</p>
    <p>Should Crocopat add Tarski operators??</p>
  </div>
  <div class="page">
    <p>Characterizing Grok-Like Languages</p>
    <p>Relational  Useful for software analysis  Expressiveness</p>
    <p>How powerful can a query be?  Codd algebra and Crocopat are more powerful.</p>
    <p>How well can a query meet our needs? How writeable? How readable?</p>
    <p>Performance of implementation  Can hold large graphs?  Fast enough to manipulate large graphs?</p>
  </div>
  <div class="page">
    <p>Performance of Grok-Like Languages</p>
    <p>Size &amp; speed: OK for --- Grok &amp; Crocopat  All memory resident, no disk access</p>
    <p>Hundreds of thousands of edges</p>
    <p>Modeling million-line systems</p>
    <p>Most operations not more than a few seconds</p>
    <p>Crocopat scales up a bit more for transitive closure</p>
    <p>House keeping, e.g., time to read files, is critical</p>
    <p>Need to test on 64-bit implementations</p>
  </div>
  <div class="page">
    <p>Data Structures for Binary Relations</p>
    <p>Tables: One for each type of relation DBMS  Single table of triples Grok  Linked lists</p>
    <p>Pointers and nodes Lsedit, JGrok (caches sorted lists)  BDD: Binary Decision Diagram Relview, Crocopat</p>
    <p>Memory efficient storage of binary relations  Works well with dense graphs  Proven useful RelView, Crocopat  Surprising (to me): BDD efficient for transitive closure</p>
  </div>
  <div class="page">
    <p>Grok-Like Languages Language Author Date Prolog Colmerauer</p>
    <p>et al. 1972</p>
    <p>SQL Chamberlin &amp; Boyce</p>
    <p>GraphLog Consens et al.</p>
    <p>Relview Berghammer et al.</p>
    <p>Grok Holt 1996 RPA Feijs et al. 1998 GReQL Kullbach &amp;</p>
    <p>Winter 1999</p>
    <p>JGrok Wu 2001 CrocoPat Beyer 2003</p>
    <p>PS: Paul Klints relational language ...</p>
    <p>Discussion of</p>
    <p>Grok-Like Languages</p>
  </div>
  <div class="page">
    <p>Progress: Using Grok-Like Languages</p>
  </div>
  <div class="page">
    <p>Grokking Software Architecture</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>Typed graphs nicely formalize various software structures  Software architecture can benefit from a ROP approach  Tarski algebra, added to boxology, is elegant</p>
    <p>Does not handle multi-node patterns</p>
    <p>Grok-like (ROP) languages are elegant and sufficiently efficient  ROP is high level, is faster, more reliable, more flexible</p>
    <p>Lots of  Work done so far  Room for more work</p>
  </div>
</Presentation>
