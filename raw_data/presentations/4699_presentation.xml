<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Efficient Complex Query Support For Multi-version XML Documents</p>
    <p>Shu-Yao Chien</p>
    <p>Dept. of CS</p>
    <p>UCLA csy@cs.ucla.edu</p>
    <p>Vassilis J. Tsotras</p>
    <p>Dept. of CS&amp;E</p>
    <p>UC Riverside tsotras@cs.ucr.edu</p>
    <p>Carlo Zaniolo</p>
    <p>Dept. of CS</p>
    <p>UCLA zaniolo@cs.ucla.edu</p>
    <p>Donghui Zhang Dept. of CS&amp;E</p>
    <p>UC Riverside donghui@cs.ucr.edu</p>
  </div>
  <div class="page">
    <p>Motivation  Problem statement  Framework  Problem Reduction  Solutions  Performance  Conclusions</p>
    <p>Content</p>
  </div>
  <div class="page">
    <p>The web changes everything---XML unifies everything.  An assortment of new and old applications seek from</p>
    <p>XML a shared technology and toolset to support their assorted requirements.</p>
    <p>Version management for XML documents is an important topic.</p>
    <p>Main requirements and research challenges:</p>
    <p>Efficient version retrieval.</p>
    <p>Storage efficiency.</p>
    <p>Complex query support.</p>
    <p>Motivation</p>
  </div>
  <div class="page">
    <p>Given an XML document which evolve over time, how to store the whole history of it and perform complex queries on any version efficiently?</p>
    <p>Problem Definition</p>
  </div>
  <div class="page">
    <p>Durable Node Numbering Scheme</p>
    <p>XML document has ordered-tree structure and each element has:  a Durable Node Number (DNN) , and  a Range</p>
    <p>DNN DNN + Range</p>
  </div>
  <div class="page">
    <p>Node Numbering Scheme --- by Example</p>
    <p>Root (1)</p>
    <p>Ch A (2)</p>
    <p>Ch B (5)</p>
    <p>Fig G (9)</p>
    <p>Sec E (4)</p>
    <p>Sec F (6)</p>
    <p>Fig H (8)</p>
    <p>Fig D (3)</p>
    <p>DNN preserves element order as pre-order traversal.  Range preserves parent-child relationship such that:</p>
    <p>dnn(P) &lt; dnn(C) &lt; dnn(C)+range(C) &lt; dnn(P)+range(P).</p>
    <p>dnn=1</p>
    <p>dnn=5 dnn=51</p>
    <p>dnn=61</p>
    <p>dnn=11 dnn=21 dnn=55 dnn=71</p>
    <p>range=100</p>
    <p>range=25 range=30</p>
    <p>range=2</p>
    <p>range=2 range=5 range=10 range=2</p>
  </div>
  <div class="page">
    <p>Version Model</p>
    <p>Each element has:  Lifespan --- (Vstart , Vend)</p>
    <p>SPaR range --- (DNN, Range)  Adding a new version N corresponds to a set of</p>
    <p>changes:  Delete(E)  Set E.Vend to N and free its SPaR range.</p>
    <p>Insert(E)  Set the lifespan of E to (N, now) and assign it an unused SPaR range.</p>
    <p>Update(E, new value)  Delete(E) + Insert(E) using the same SPaR range but the new value.</p>
  </div>
  <div class="page">
    <p>Framework for Storage Schemes</p>
    <p>Two types of tags: individual tag (abstract, conclusion) and list tag (chapter, section, figure).</p>
    <p>User query list tag element by order (e.g. chapter 2) rather than by SPaR (e.g. the chapter whose SPaR range is (128, 512). Need to transform the order to SPaR range. Calls for separate indices.</p>
    <p>Full index</p>
    <p>CH-index FIG-index</p>
  </div>
  <div class="page">
    <p>Problem Reduction</p>
    <p>Complex queries that can be reduced to partial version retrievals:  Structural projection: project the part of</p>
    <p>document between chapter 2 and 5 in version 20;  Path-expression: find the chapter that contains</p>
    <p>figure 7 in version 10.</p>
  </div>
  <div class="page">
    <p>Problem Reduction</p>
    <p>Structural projection: project the part of document between chapter 2 and 5 in version 20:</p>
    <p>Full index</p>
    <p>CH-index FIG-index</p>
    <p>Query CH-index, find all chapters in version 20;  Compute SPaR range between chapter 2 and 5;  Partial version retrieval on full index.</p>
  </div>
  <div class="page">
    <p>Problem Reduction</p>
    <p>Partial version retrieval: given version i and DNN range r, find all elements whose DNNr in version i.</p>
    <p>Full index</p>
    <p>CH-index FIG-index</p>
  </div>
  <div class="page">
    <p>Problem Reduction</p>
    <p>Path-expression: find/construct the chapter that contains figure 7 in version 10;</p>
    <p>Full index</p>
    <p>CH-index FIG-index</p>
    <p>Query FIG-index, find the SPaR for figure 7 in version 10;</p>
    <p>Query CH-index using the SPaR to find the chapter;  To construct, Partial version retrieval on full index.</p>
  </div>
  <div class="page">
    <p>Indexing for List Tags</p>
    <p>The indexing for list tags (CH-index, FIG-index) is trivial: small.</p>
    <p>Multi-version B+-tree (MVBT) [BGO+96]: asymptotically optimal in space, update, partial version retrieval.</p>
    <p>Full index</p>
    <p>CH-index FIG-index</p>
  </div>
  <div class="page">
    <p>Storage and Query Scheme for Full Index</p>
    <p>We examine two schemes:  MVBT Storage/Index  UBCC Storage + secondary index</p>
    <p>Full index</p>
    <p>CH-index FIG-index</p>
  </div>
  <div class="page">
    <p>The MVBT is capable of storing and querying the multi-versioned XML document, and is asymptotically optimal. Why UBCC?</p>
    <p>Motivation for UBCC Storage</p>
    <p>MVBT is designed for handling one-by-one updates, not specialized for the batch update in the document versioning environment.</p>
  </div>
  <div class="page">
    <p>Naive approach stores each version in its entirety: minimizes retrieval but very inefficient storage.</p>
    <p>RCS (Revision Control System) :  stores the latest version in its entirety, and  old versions represented by deltas ---reverse edit script  minimizes storage cost  version retrieval cost grows linearly with version number</p>
    <p>SCCS (Source Code Control System) :  objects time-stamped and stored by their document order  version retrieval cost as high as whole change history</p>
    <p>These schemes are used by most current systems--but need improvements in storage management, retrieval, query, and support for complex objects.</p>
    <p>Traditional Versioning Schemes</p>
  </div>
  <div class="page">
    <p>RCS and SCCS stores major versions and incremental</p>
    <p>modifications. To query, find nearest major version and</p>
    <p>apply incremental changes for multiple versions. Also,</p>
    <p>designed for full version retrieval.</p>
    <p>UBCC [VLDB01]: Usefulness-Based Copy Control, uses</p>
    <p>the concept of Page Usefulness</p>
    <p>UBCC Storage Scheme</p>
  </div>
  <div class="page">
    <p>DELV2</p>
    <p>DEL DELV3</p>
    <p>A B C D 75%</p>
    <p>A B C D 25%</p>
    <p>A B C D V1</p>
    <p>Version Page Usefulness</p>
    <p>We set a minimum usefulness requirement Umin, e.g. 70% (0 &lt; Umin &lt;= 1).</p>
    <p>A page is useful/useless when its usefulness is above/ below Umin .</p>
    <p>Useful</p>
    <p>Useless</p>
    <p>Page Usefulness  by Example</p>
  </div>
  <div class="page">
    <p>Root Ch A Fig D Sec E Ch B Sec F Fig G Fig H</p>
    <p>VERSION 2 INS(Sec J)</p>
    <p>DEL</p>
    <p>INS(Fig M) INS(Sec T) INS(Fig R)</p>
    <p>DEL DEL</p>
    <p>INS(Ch K) INS(Sec L)</p>
    <p>STEP 1 : Determine page usefulness for copying.</p>
    <p>, U(P1)=75%</p>
    <p>VERSION 1</p>
    <p>, U(P2) = 50% &lt; Umin=70%</p>
    <p>STEP 2 : Append new/copied objects into new pages by their logical order.</p>
    <p>P3</p>
    <p>Sec J</p>
    <p>COPY</p>
    <p>Ch B Sec F Fig M</p>
    <p>P4</p>
    <p>Ch K Sec L</p>
    <p>P1 P2</p>
    <p>, U(P3)=100% , U(P4)=100%</p>
    <p>Usefulness Based Copy Control (UBCC)</p>
    <p>Sec T Fig R</p>
  </div>
  <div class="page">
    <p>Version retrieval I/O cost for Version N is bound by</p>
    <p>(SN/Umin).</p>
    <p>SN is the size of Version N</p>
    <p>E.g. Umin = 50% ---&gt; I/O &lt;= 2*SN</p>
    <p>Version file size is linear with the size of change</p>
    <p>history (RCS), and is bound by O(Schg/(1-Umin)), where</p>
    <p>Schg is the size of change history.</p>
    <p>Umin is usefulness requirement.</p>
    <p>Both are optimal!</p>
    <p>Complexity Analysis</p>
  </div>
  <div class="page">
    <p>Using UBCC to cluster the document elements. On</p>
    <p>top of the document file:</p>
    <p>MVBT as a dense index; or</p>
    <p>MVRT as a sparse index.</p>
    <p>Indexing Choices using UBCC</p>
  </div>
  <div class="page">
    <p>Sparse Page Index --- Multi-version R Tree</p>
    <p>Multi-version R-Tree : each record corresponds to a UBCC page:  Life Span : (T1,T2)  Maximum DNN Range : (D1,D2)  UBCC Page-ID</p>
    <p>When retrieve a segment for a version, MVRT is traced to locate useful data pages with an overlapping DNN range.</p>
    <p>DNN range</p>
    <p>Version</p>
    <p>P 5 P 8</p>
    <p>P 11</p>
    <p>P 15</p>
    <p>V 10</p>
    <p>D1 D2</p>
    <p>Retrieve Version 10, Segment (D1,D2)</p>
    <p>P 22</p>
  </div>
  <div class="page">
    <p>Good for sparse MVRT:  small size;  each page is checked at most once.</p>
    <p>Bad for sparse MVRT:  May read unnecessary pages, e.g. :</p>
    <p>Request: Version 3, SPaR = (420,700)  Page P is qualified but contains no valid element.</p>
    <p>Sparse vs. Dense Indexing</p>
    <p>E1 DNN = 200 Life = (1,4)</p>
    <p>E2 DNN = 300 Life = (1,4)</p>
    <p>E3 DNN = 400 Life = (1,2)</p>
    <p>E4 DNN = 500 Life = (1,2)</p>
    <p>Max DNN Range = (200,500) Life Span = (1,4)</p>
    <p>Umin = 50%</p>
    <p>Page P</p>
  </div>
  <div class="page">
    <p>Sun Enterprise 250 Server, Solaris 2.8, 16KB page size, 100 pages buffer size, GNU C++.</p>
    <p>Dataset: 1000 versions; initial version 1000 objects; each object = 200 bytes; change between two versions is 10%.</p>
    <p>Implemented schemes:</p>
    <p>scheme 1: MVBT storage/index</p>
    <p>scheme 2: UBCC storage, dense MVBT index</p>
    <p>scheme 3: UBCC storage, sparse MVRT index</p>
    <p>Experimental Setup</p>
  </div>
  <div class="page">
    <p>Check-In Time</p>
    <p>Scheme 1 Scheme 2 Scheme 3</p>
    <p>C h</p>
    <p>ec k</p>
    <p>-I n</p>
    <p>T im</p>
    <p>e (s</p>
    <p>ec )</p>
    <p>I/O</p>
    <p>CPU</p>
    <p>Performance Comparison --- Check-In Time and Index Size</p>
    <p>Index Size</p>
    <p>Scheme 1 Scheme 2 Scheme 3</p>
    <p>In d</p>
    <p>ex S</p>
    <p>iz e</p>
    <p>(M B</p>
    <p>)</p>
    <p>Index</p>
  </div>
  <div class="page">
    <p>Query Performance</p>
    <p>Size of Query Range</p>
    <p>Q u</p>
    <p>er y</p>
    <p>T im</p>
    <p>e (s</p>
    <p>ec )</p>
    <p>Scheme 1</p>
    <p>Scheme 2</p>
    <p>Scheme 3</p>
    <p>Performance Comparison --- Partial Version Retrieval</p>
  </div>
  <div class="page">
    <p>We proposed a framework for storing and querying multi-versioned XML documents.</p>
    <p>We examined techniques that merges traditional versioning schemes and temporal databases for XML version management.</p>
    <p>Best scheme:  UBCC storage  Sparse MVRT for full index  Dense MVBT for each tag index</p>
    <p>Emerging issues:  Query language support for version queries.  User interface for browsing versions and</p>
    <p>presenting query results</p>
    <p>Conclusions and Future Work</p>
  </div>
  <div class="page"/>
</Presentation>
