<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Black-Box Performance Control for High-Volume Non-Interactive Systems</p>
    <p>Chunqiang (CQ) Tang</p>
    <p>Sunjit Tara</p>
    <p>Rong N. Chang</p>
    <p>Chun Zhang</p>
    <p>UENIX09, June 19, 2009</p>
    <p>IBM T.J. Watson Research Center</p>
    <p>IBM Software Group, Tivoli</p>
    <p>IBM T.J. Watson Research Center</p>
    <p>IBM T.J. Watson Research Center</p>
  </div>
  <div class="page">
    <p>Response Time Driven Performance Control for Interactive Web Applications</p>
    <p>Interactive users are sensitive to sub-second response time</p>
    <p>Naturally, performance control is driven by response time  E.g, stop admitting new requests if response time exceeds a threshold</p>
    <p>Well studied area: admission control, service differentiation, etc.</p>
  </div>
  <div class="page">
    <p>But there are Robots that Impact Perf Control</p>
    <p>Many Web services also provide APIs to explicitly work with robots  Twitter API Traffic was 10x of its Web traffic</p>
    <p>Some applications work with interactive users during daytime, and then are driven by robot tools at nights to perform heavy-duty analytics</p>
    <p>How robots impact performance control  They often have tons of work to do and hence are throughput centric  They may not require sub-second response time, e.g., crawler and analytics</p>
  </div>
  <div class="page">
    <p>IT Monitoring and Mgmt: a World where Robots Rule</p>
    <p>Before an IT service mgmt system (ITSM) can manage a data center, it must manage itself well  Withstand event flash crowd triggered by, e.g., router failure</p>
    <p>Achieve high event-processing throughput by driving up resource utilization</p>
    <p>Avoid resource saturation as sysadmins may want to do manual investigation</p>
    <p>Data center</p>
  </div>
  <div class="page">
    <p>Simplified View of IBM Tivoli Netcool/Impact  It provides a reusable framework for integrating all kinds of siloed monitoring and mgmt tools  It is built atop a J2EE engine but cannot use response-time driven performance control</p>
  </div>
  <div class="page">
    <p>Why Perf Control is Difficult in Netcool/Impact</p>
    <p>Work with third-party software provided by many vendors</p>
    <p>We cannot greedily maximize performance without considering congestion</p>
    <p>Bottleneck can be anything anywhere: CPU, disk, memory, network, etc.</p>
    <p>Bottleneck depends on how users write their code atop Netcool/Impact</p>
    <p>Not a simple static topology like web-&gt;app-&gt;DB</p>
    <p>No simple perf indicator like packet loss or response time violation</p>
  </div>
  <div class="page">
    <p>Black-Box Approach: Throughput-guided Concurrency Control (TCC)</p>
    <p>Why not simply use TCP to maximize throughput  We deal with general distributed systems rather than just network</p>
    <p>No packet loss as performance indicator</p>
    <p>Unlike router, a general servers service time is not a constant</p>
  </div>
  <div class="page">
    <p>Simplified State-Transition Diagram for Thread Tuning</p>
    <p>base state: reduce threads by w%</p>
    <p>add-thread state: repeatedly add threads so long as every p% increase in threads improves throughput by q% or more</p>
    <p>remove-thread state: repeatedly remove threads by r% each time so long as throughput does not decrease significantly</p>
  </div>
  <div class="page">
    <p>Conditions for Friendly Resource Sharing</p>
    <p>Repeatedly add threads so long as every p% increase in threads improves throughput by q% or more</p>
    <p>Reduce threads by w% at the beginning of exploration</p>
    <p>e.g., double threads (p=100%) and then see thruput increases by q=1%. This is no good.</p>
    <p>The base state must be sufficiently low so that it will end up with less threads if resource is saturated</p>
  </div>
  <div class="page">
    <p>Conditions for Friendly Resource Sharing</p>
    <p>If there is an uncontrolled competing program, NCI shares 4449% of the bottleneck resource</p>
    <p>Two instances of NCI share bottleneck resources in a friendly manner</p>
    <p>However, three or more instances of NCI need coordination from the master</p>
  </div>
  <div class="page">
    <p>Drive up Resource Utilization to Achieve High Throughput</p>
    <p>TCC is friendly but also sufficiently aggressive to drive up resource utilization</p>
  </div>
  <div class="page">
    <p>Throughput Measurement 1: Exclude Idle Time from Throughput Calculation</p>
    <p>Throughput =</p>
    <p>Throughput =</p>
  </div>
  <div class="page">
    <p>Throughput Measurement 2: Minimize Measurement Samples</p>
    <p>Minimize the number of measurement samples while ensuring a high probability of making correct decisions</p>
    <p>Solution</p>
    <p>Problem formulation</p>
  </div>
  <div class="page">
    <p>Throughput Measurement 3: Exclude Outliers from Throughput Calculation</p>
    <p>Extreme activities such as Java garbage collection introduce large variance  Sometimes GC can take as long as 20 seconds</p>
    <p>There are many known methods to handle outliers</p>
    <p>We found that simply dropping 1% of the largest samples works well</p>
    <p>This is simple but critical</p>
  </div>
  <div class="page">
    <p>Experimental Setup</p>
    <p>In some experiments, we introduce extra network delay</p>
    <p>In some experiments, we control service time of the Web service and Netcool/Impact user scripts</p>
  </div>
  <div class="page">
    <p>Scalability of NCI Cluster</p>
  </div>
  <div class="page">
    <p>CPU as the Bottleneck Resource</p>
  </div>
  <div class="page">
    <p>Recover from Memory Thrashing</p>
  </div>
  <div class="page">
    <p>Disk as the Bottleneck</p>
    <p>Reducing threads actually improves disk performance</p>
  </div>
  <div class="page">
    <p>Work with an Uncontrolled Competing Program</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>Greedy parameter search  Too greedy without considering resource contention</p>
    <p>TCP-style congestion control, e.g., TCP Vegas  Assume minimum RTT is the mean service time</p>
    <p>In DB, min response time is the best-case cache hit service time. It cannot be used to estimate the congestion-free baseline throughput.</p>
    <p>Control theory  Not sufficiently black-box</p>
    <p>Need to monitor resource utilization if applied to Netcool/Impact</p>
    <p>Queueing theory  Assume a known static topology and a known bottleneck</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Is it possible to get TCP-friendly for general distributed systems?  Currently three or more instances of NCI need coordination</p>
    <p>in order to be friendly to each other</p>
    <p>Can we estimate the utilization of Googles internal servers by observing changes in query response time?  This is possible for restricted queuing models</p>
    <p>Whats the most general model for which this is still doable?</p>
  </div>
  <div class="page">
    <p>Take Home Message</p>
    <p>We need to revisit performance control for systems that handle workloads generated by software tools (robots)  Mixed human/robot worklaod (Twitter fits here)</p>
    <p>Mostly robot workload (Netcool/Impact fits here)</p>
    <p>Robot-only workload (Hardoop fits here)</p>
  </div>
</Presentation>
