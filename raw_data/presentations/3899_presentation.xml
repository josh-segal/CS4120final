<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Hierarchical models of provenance</p>
    <p>Peter Buneman James Cheney Egor Kostylev</p>
    <p>University of Edinburgh TaPP, June 15, 2012</p>
  </div>
  <div class="page">
    <p>Motivation  Many provenance systems track &quot;flat&quot;</p>
    <p>provenance</p>
    <p>Some track provenance at multiple granularity levels (in different ways)</p>
    <p>e.g. ZOOM, Kepler, probably others  Our goals:  Formal, high-level model of &quot;hierarchical&quot; provenance  Understand interplay between control/data</p>
    <p>abstractions and provenance models</p>
  </div>
  <div class="page">
    <p>OPM lite  Simplified OPM: bipartite DAGs  Process nodes P  Artifact nodes A  Edges E  (P  A)  (A  P)  Labels on process, artifacts and edges</p>
  </div>
  <div class="page">
    <p>+</p>
    <p>* *</p>
    <p>+</p>
    <p>def f(x) = x+1 g(x,y) = h(x) + x*y h(z) = z*z in g(f(1), 4)</p>
  </div>
  <div class="page">
    <p>+</p>
    <p>* *</p>
    <p>+</p>
    <p>def f(x) = x+1 g(x,y) = h(x) + x*y h(z) = z*z in g(f(1), 4)</p>
    <p>Note: This discards a lot of</p>
    <p>information!</p>
  </div>
  <div class="page">
    <p>&quot;Hierarchical&quot; OPM  Augment OPM graph structure with call tree  Tree T = (V,F) with nodes labeled by &quot;higher-level&quot;</p>
    <p>processes</p>
    <p>Mapping  : V  (P  A)  Requires if (f,g)  F then (f)  (g)  note reversal!  (root) = (P  A)  Further requirements: (f) is a contiguous, &quot;sub-OPM&quot;</p>
    <p>graph.</p>
    <p>Formalized more carefully in paper.</p>
  </div>
  <div class="page">
    <p>+</p>
    <p>* *</p>
    <p>+</p>
    <p>def f(x) = x+1 g(x,y) = h(x) + x*y h(z) = z*z in g(f(1), 4)</p>
  </div>
  <div class="page">
    <p>g1</p>
    <p>f1</p>
    <p>h1</p>
    <p>+</p>
    <p>* *</p>
    <p>+</p>
    <p>def f(x) = x+1 g(x,y) = h(x) + x*y h(z) = z*z in g(f(1), 4)</p>
  </div>
  <div class="page">
    <p>g1</p>
    <p>f1</p>
    <p>h1</p>
    <p>+</p>
    <p>* *</p>
    <p>+</p>
    <p>def f(x) = x+1 g(x,y) = h(x) + x*y h(z) = z*z in g(f(1), 4)</p>
    <p>main</p>
    <p>f1 g1</p>
    <p>h1</p>
  </div>
  <div class="page">
    <p>Views  Given a prefix-closed subtree S of T  This induces a view of H  that is, an normal OPM graph  obtained by &quot;collapsing&quot; the graph structure</p>
    <p>of calls not in S</p>
    <p>This makes sense (only) because of restrictions on call mapping .</p>
    <p>(details in paper - there are a few subtleties)</p>
  </div>
  <div class="page">
    <p>h1</p>
    <p>+</p>
    <p>* *</p>
    <p>+</p>
    <p>def f(x) = x+1 g(x,y) = h(x) + x*y h(z) = z*z in g(f(1), 4)</p>
    <p>main</p>
    <p>f1 g1</p>
    <p>h1</p>
    <p>g1</p>
    <p>f1</p>
  </div>
  <div class="page">
    <p>h1</p>
    <p>+</p>
    <p>* *</p>
    <p>+</p>
    <p>def f(x) = x+1 g(x,y) = h(x) + x*y h(z) = z*z in g(f(1), 4)</p>
    <p>main</p>
    <p>f1 g1</p>
    <p>h1</p>
    <p>f1</p>
    <p>g1</p>
    <p>g1</p>
    <p>f1</p>
  </div>
  <div class="page">
    <p>g1</p>
    <p>+</p>
    <p>* *</p>
    <p>+</p>
    <p>def f(x) = x+1 g(x,y) = h(x) + x*y h(z) = z*z in g(f(1), 4)</p>
    <p>main</p>
    <p>f1 g1</p>
    <p>h1</p>
    <p>f1</p>
    <p>*</p>
    <p>+</p>
    <p>h1 h1</p>
    <p>f1</p>
  </div>
  <div class="page">
    <p>ProvL: Simple &quot;workflows&quot; (ie functional programs)</p>
    <p>We first consider workflows with function calls but little else...</p>
    <p>denotes an arbitrary primitive function  think +, *, -, etc.  Let-binding allows for sharing  hence, expression basically isomorphic to graph</p>
    <p>expression e ::= c | x | (e) | let x = e1 in e2 (a) | if e1 then e2 else e3 (b) | f (e) (c) | map</p>
    <p>f (e) (d)</p>
    <p>program def f1(x1) = e1,..., fm(xm) = em in e</p>
    <p>Figure 4: Syntax of ProvL</p>
    <p>(a) ProvL0 handles simple workflows involving constant values, primitive operations, variables, and let-binding (expressing sharing). We may take the primitive operations to be the atomic black boxes of any conventional workflow language (e.g. Kepler, VisTrails, Taverna, ZOOM [5]) and represent any straight-line, DAG-shaped computation using these operations as a ProvL0 expression. The corresponding (H)OPM graph is essentially the same DAG with inverted edges.</p>
    <p>(b) ProvLb extends ProvL0 with conditionals (ifthen else). The generated provenance graphs include process nodes to indicate that a conditional was evaluated, and which branch was taken. (This is similar to the approach taken in the model of [2].)</p>
    <p>(c) ProvL f extends ProvLb with user-defined functions, achieving a Turing-complete language (assuming the underlying set of operators includes at least basic arithmetic). The HOPM graph can have nontrivial call trees as described above.</p>
    <p>(d) ProvL, finally, extends ProvL f with support for lists and the map function. The HOPM graph generated for map</p>
    <p>f () consists of the graphs generated for the</p>
    <p>calls f1,..., fn to f on the elements of the list, plus an edge to the input list from a process node for map</p>
    <p>f () itself, plus an edge to this process node from</p>
    <p>the output list node. Also, the map f () process node</p>
    <p>contains all of the calls to f , that is, (map f ()) =</p>
    <p>( f1)  ( fn).</p>
    <p>Some questions for further work: 1. What is the relationship between our notion of</p>
    <p>views and accounts in OPM? It seems that accounts can be used to represent views, but not all accounts correspond to views (for example, accounts can provide conflicting information). How are views of HOPM graphs related to, for example, the traces and trace slicing of Acar et al. [1]?</p>
    <p>into groups to hide details irrelevant to the user.) 3. Our notion of validity for HOPM graphs is basic:</p>
    <p>it does not, for example, require that different calls to the same function have compatible expansions. (That is, it would be legal for one call to f to expand to +1 and for another to expand to 2.) How should validity be made more precise? Can we exactly capture the provenance expressiveness of different workflow languages?</p>
    <p>References [1] U. A. Acar, A. Ahmed, J. Cheney, and R. Perera. A</p>
    <p>core calculus for provenance. In POST, number 7215 in LNCS, pages 410429. Springer, 2012.</p>
    <p>[2] U. A. Acar, P. Buneman, J. Cheney, N. Kwasnikowska, S. Vansummeren, and J. van den Bussche. A graph model for data and workflow provenance. In Workshop on the Theory and Practice of Provenance, 2010.</p>
    <p>[3] Y. Amsterdamer, S. B. Davidson, D. Deutch, T. Milo, J. Stoyanovich, and V. Tannen. Putting lipstick on pig: Enabling database-style workflow provenance. In VLDB, 2012.</p>
    <p>[4] J. Cheney. Causality and the semantics of provenance. In Proceedings of the 2010 Workshop on Developments in</p>
    <p>Computational Models, 2010. [5] S. Davidson, S. Cohen-Boulakia, A. Eyal, B. Ludaescher,</p>
    <p>T. McPhillips, S. Bowers, M. Anand, and J. Freire. Provenance in scientific workflow systems. IEEE Data Engineering Bulletin, 30(4):4450, 2007.</p>
    <p>[6] Z. Liu, S. B. Davidson, and Y. Chen. Generating sound workflow views for correct provenance analysis. ACM Trans. Database Syst., 36(1):6, 2011.</p>
    <p>[7] L. Moreau. The foundations for provenance on the web. Foundations and Trends in Web Science, 2(2-3):99241, 2010.</p>
    <p>[8] L. Moreau. Provenance-based reproducibility in the semantic web. J. Web Sem., 9(2):202221, 2011.</p>
    <p>[9] L. Moreau, B. Clifford, J. Freire, J. Futrelle, Y. Gil, P. T. Groth, N. Kwasnikowska, S. Miles, P. Missier, J. Myers, B. Plale, Y. Simmhan, E. G. Stephan, and J. V. den Bussche. The open provenance model core specification (v1.1). Future Generation Comp. Syst., 27(6):743756, 2011.</p>
    <p>[10] K.-K. Muniswamy-Reddy, U. Braun, D. A. Holland, P. Macko, D. Maclean, D. Margo, M. Seltzer, and R. Smogor. Layering in provenance systems. In Proceedings of the 2009 conference on USENIX Annual techni</p>
    <p>cal conference, USENIX09, pages 1010, Berkeley, CA, USA, 2009. USENIX Association.</p>
  </div>
  <div class="page">
    <p>Adding function calls  We allow (closed, first- order) function</p>
    <p>definitions, with calls:</p>
    <p>Functions can be defined mutually recursively</p>
    <p>Function calls generate call tree nodes (mapped to appropriate subgraphs).</p>
    <p>expression e ::= c | x | (e) | let x = e1 in e2 (a) | if e1 then e2 else e3 (b) | f (e) (c) | map</p>
    <p>f (e) (d)</p>
    <p>program def f1(x1) = e1,..., fm(xm) = em in e</p>
    <p>Figure 4: Syntax of ProvL</p>
    <p>(a) ProvL0 handles simple workflows involving constant values, primitive operations, variables, and let-binding (expressing sharing). We may take the primitive operations to be the atomic black boxes of any conventional workflow language (e.g. Kepler, VisTrails, Taverna, ZOOM [5]) and represent any straight-line, DAG-shaped computation using these operations as a ProvL0 expression. The corresponding (H)OPM graph is essentially the same DAG with inverted edges.</p>
    <p>(b) ProvLb extends ProvL0 with conditionals (ifthen else). The generated provenance graphs include process nodes to indicate that a conditional was evaluated, and which branch was taken. (This is similar to the approach taken in the model of [2].)</p>
    <p>(c) ProvL f extends ProvLb with user-defined functions, achieving a Turing-complete language (assuming the underlying set of operators includes at least basic arithmetic). The HOPM graph can have nontrivial call trees as described above.</p>
    <p>(d) ProvL, finally, extends ProvL f with support for lists and the map function. The HOPM graph generated for map</p>
    <p>f () consists of the graphs generated for the</p>
    <p>calls f1,..., fn to f on the elements of the list, plus an edge to the input list from a process node for map</p>
    <p>f () itself, plus an edge to this process node from</p>
    <p>the output list node. Also, the map f () process node</p>
    <p>contains all of the calls to f , that is, (map f ()) =</p>
    <p>( f1)  ( fn).</p>
    <p>Some questions for further work: 1. What is the relationship between our notion of</p>
    <p>views and accounts in OPM? It seems that accounts can be used to represent views, but not all accounts correspond to views (for example, accounts can provide conflicting information). How are views of HOPM graphs related to, for example, the traces and trace slicing of Acar et al. [1]?</p>
    <p>into groups to hide details irrelevant to the user.) 3. Our notion of validity for HOPM graphs is basic:</p>
    <p>it does not, for example, require that different calls to the same function have compatible expansions. (That is, it would be legal for one call to f to expand to +1 and for another to expand to 2.) How should validity be made more precise? Can we exactly capture the provenance expressiveness of different workflow languages?</p>
    <p>References [1] U. A. Acar, A. Ahmed, J. Cheney, and R. Perera. A</p>
    <p>core calculus for provenance. In POST, number 7215 in LNCS, pages 410429. Springer, 2012.</p>
    <p>[2] U. A. Acar, P. Buneman, J. Cheney, N. Kwasnikowska, S. Vansummeren, and J. van den Bussche. A graph model for data and workflow provenance. In Workshop on the Theory and Practice of Provenance, 2010.</p>
    <p>[3] Y. Amsterdamer, S. B. Davidson, D. Deutch, T. Milo, J. Stoyanovich, and V. Tannen. Putting lipstick on pig: Enabling database-style workflow provenance. In VLDB, 2012.</p>
    <p>[4] J. Cheney. Causality and the semantics of provenance. In Proceedings of the 2010 Workshop on Developments in</p>
    <p>Computational Models, 2010. [5] S. Davidson, S. Cohen-Boulakia, A. Eyal, B. Ludaescher,</p>
    <p>T. McPhillips, S. Bowers, M. Anand, and J. Freire. Provenance in scientific workflow systems. IEEE Data Engineering Bulletin, 30(4):4450, 2007.</p>
    <p>[6] Z. Liu, S. B. Davidson, and Y. Chen. Generating sound workflow views for correct provenance analysis. ACM Trans. Database Syst., 36(1):6, 2011.</p>
    <p>[7] L. Moreau. The foundations for provenance on the web. Foundations and Trends in Web Science, 2(2-3):99241, 2010.</p>
    <p>[8] L. Moreau. Provenance-based reproducibility in the semantic web. J. Web Sem., 9(2):202221, 2011.</p>
    <p>[9] L. Moreau, B. Clifford, J. Freire, J. Futrelle, Y. Gil, P. T. Groth, N. Kwasnikowska, S. Miles, P. Missier, J. Myers, B. Plale, Y. Simmhan, E. G. Stephan, and J. V. den Bussche. The open provenance model core specification (v1.1). Future Generation Comp. Syst., 27(6):743756, 2011.</p>
    <p>[10] K.-K. Muniswamy-Reddy, U. Braun, D. A. Holland, P. Macko, D. Maclean, D. Margo, M. Seltzer, and R. Smogor. Layering in provenance systems. In Proceedings of the 2009 conference on USENIX Annual techni</p>
    <p>cal conference, USENIX09, pages 1010, Berkeley, CA, USA, 2009. USENIX Association.</p>
    <p>expression e ::= c | x | (e) | let x = e1 in e2 (a) | if e1 then e2 else e3 (b) | f (e) (c) | map</p>
    <p>f (e) (d)</p>
    <p>program def f1(x1) = e1,..., fm(xm) = em in e</p>
    <p>Figure 4: Syntax of ProvL</p>
    <p>(a) ProvL0 handles simple workflows involving constant values, primitive operations, variables, and let-binding (expressing sharing). We may take the primitive operations to be the atomic black boxes of any conventional workflow language (e.g. Kepler, VisTrails, Taverna, ZOOM [5]) and represent any straight-line, DAG-shaped computation using these operations as a ProvL0 expression. The corresponding (H)OPM graph is essentially the same DAG with inverted edges.</p>
    <p>(b) ProvLb extends ProvL0 with conditionals (ifthen else). The generated provenance graphs include process nodes to indicate that a conditional was evaluated, and which branch was taken. (This is similar to the approach taken in the model of [2].)</p>
    <p>(c) ProvL f extends ProvLb with user-defined functions, achieving a Turing-complete language (assuming the underlying set of operators includes at least basic arithmetic). The HOPM graph can have nontrivial call trees as described above.</p>
    <p>(d) ProvL, finally, extends ProvL f with support for lists and the map function. The HOPM graph generated for map</p>
    <p>f () consists of the graphs generated for the</p>
    <p>calls f1,..., fn to f on the elements of the list, plus an edge to the input list from a process node for map</p>
    <p>f () itself, plus an edge to this process node from</p>
    <p>the output list node. Also, the map f () process node</p>
    <p>contains all of the calls to f , that is, (map f ()) =</p>
    <p>( f1)  ( fn).</p>
    <p>Some questions for further work: 1. What is the relationship between our notion of</p>
    <p>views and accounts in OPM? It seems that accounts can be used to represent views, but not all accounts correspond to views (for example, accounts can provide conflicting information). How are views of HOPM graphs related to, for example, the traces and trace slicing of Acar et al. [1]?</p>
    <p>into groups to hide details irrelevant to the user.) 3. Our notion of validity for HOPM graphs is basic:</p>
    <p>it does not, for example, require that different calls to the same function have compatible expansions. (That is, it would be legal for one call to f to expand to +1 and for another to expand to 2.) How should validity be made more precise? Can we exactly capture the provenance expressiveness of different workflow languages?</p>
    <p>References [1] U. A. Acar, A. Ahmed, J. Cheney, and R. Perera. A</p>
    <p>core calculus for provenance. In POST, number 7215 in LNCS, pages 410429. Springer, 2012.</p>
    <p>[2] U. A. Acar, P. Buneman, J. Cheney, N. Kwasnikowska, S. Vansummeren, and J. van den Bussche. A graph model for data and workflow provenance. In Workshop on the Theory and Practice of Provenance, 2010.</p>
    <p>[3] Y. Amsterdamer, S. B. Davidson, D. Deutch, T. Milo, J. Stoyanovich, and V. Tannen. Putting lipstick on pig: Enabling database-style workflow provenance. In VLDB, 2012.</p>
    <p>[4] J. Cheney. Causality and the semantics of provenance. In Proceedings of the 2010 Workshop on Developments in</p>
    <p>Computational Models, 2010. [5] S. Davidson, S. Cohen-Boulakia, A. Eyal, B. Ludaescher,</p>
    <p>T. McPhillips, S. Bowers, M. Anand, and J. Freire. Provenance in scientific workflow systems. IEEE Data Engineering Bulletin, 30(4):4450, 2007.</p>
    <p>[6] Z. Liu, S. B. Davidson, and Y. Chen. Generating sound workflow views for correct provenance analysis. ACM Trans. Database Syst., 36(1):6, 2011.</p>
    <p>[7] L. Moreau. The foundations for provenance on the web. Foundations and Trends in Web Science, 2(2-3):99241, 2010.</p>
    <p>[8] L. Moreau. Provenance-based reproducibility in the semantic web. J. Web Sem., 9(2):202221, 2011.</p>
    <p>[9] L. Moreau, B. Clifford, J. Freire, J. Futrelle, Y. Gil, P. T. Groth, N. Kwasnikowska, S. Miles, P. Missier, J. Myers, B. Plale, Y. Simmhan, E. G. Stephan, and J. V. den Bussche. The open provenance model core specification (v1.1). Future Generation Comp. Syst., 27(6):743756, 2011.</p>
    <p>[10] K.-K. Muniswamy-Reddy, U. Braun, D. A. Holland, P. Macko, D. Maclean, D. Margo, M. Seltzer, and R. Smogor. Layering in provenance systems. In Proceedings of the 2009 conference on USENIX Annual techni</p>
    <p>cal conference, USENIX09, pages 1010, Berkeley, CA, USA, 2009. USENIX Association.</p>
    <p>...expression e ::= c | x | (e) | let x = e1 in e2 (a) | if e1 then e2 else e3 (b) | f (e) (c) | map</p>
    <p>f (e) (d)</p>
    <p>program def f1(x1) = e1,..., fm(xm) = em in e</p>
    <p>Figure 4: Syntax of ProvL</p>
    <p>(a) ProvL0 handles simple workflows involving constant values, primitive operations, variables, and let-binding (expressing sharing). We may take the primitive operations to be the atomic black boxes of any conventional workflow language (e.g. Kepler, VisTrails, Taverna, ZOOM [5]) and represent any straight-line, DAG-shaped computation using these operations as a ProvL0 expression. The corresponding (H)OPM graph is essentially the same DAG with inverted edges.</p>
    <p>(b) ProvLb extends ProvL0 with conditionals (ifthen else). The generated provenance graphs include process nodes to indicate that a conditional was evaluated, and which branch was taken. (This is similar to the approach taken in the model of [2].)</p>
    <p>(c) ProvL f extends ProvLb with user-defined functions, achieving a Turing-complete language (assuming the underlying set of operators includes at least basic arithmetic). The HOPM graph can have nontrivial call trees as described above.</p>
    <p>(d) ProvL, finally, extends ProvL f with support for lists and the map function. The HOPM graph generated for map</p>
    <p>f () consists of the graphs generated for the</p>
    <p>calls f1,..., fn to f on the elements of the list, plus an edge to the input list from a process node for map</p>
    <p>f () itself, plus an edge to this process node from</p>
    <p>the output list node. Also, the map f () process node</p>
    <p>contains all of the calls to f , that is, (map f ()) =</p>
    <p>( f1)  ( fn).</p>
    <p>Some questions for further work: 1. What is the relationship between our notion of</p>
    <p>views and accounts in OPM? It seems that accounts can be used to represent views, but not all accounts correspond to views (for example, accounts can provide conflicting information). How are views of HOPM graphs related to, for example, the traces and trace slicing of Acar et al. [1]?</p>
    <p>into groups to hide details irrelevant to the user.) 3. Our notion of validity for HOPM graphs is basic:</p>
    <p>it does not, for example, require that different calls to the same function have compatible expansions. (That is, it would be legal for one call to f to expand to +1 and for another to expand to 2.) How should validity be made more precise? Can we exactly capture the provenance expressiveness of different workflow languages?</p>
    <p>References [1] U. A. Acar, A. Ahmed, J. Cheney, and R. Perera. A</p>
    <p>core calculus for provenance. In POST, number 7215 in LNCS, pages 410429. Springer, 2012.</p>
    <p>[2] U. A. Acar, P. Buneman, J. Cheney, N. Kwasnikowska, S. Vansummeren, and J. van den Bussche. A graph model for data and workflow provenance. In Workshop on the Theory and Practice of Provenance, 2010.</p>
    <p>[3] Y. Amsterdamer, S. B. Davidson, D. Deutch, T. Milo, J. Stoyanovich, and V. Tannen. Putting lipstick on pig: Enabling database-style workflow provenance. In VLDB, 2012.</p>
    <p>[4] J. Cheney. Causality and the semantics of provenance. In Proceedings of the 2010 Workshop on Developments in</p>
    <p>Computational Models, 2010. [5] S. Davidson, S. Cohen-Boulakia, A. Eyal, B. Ludaescher,</p>
    <p>T. McPhillips, S. Bowers, M. Anand, and J. Freire. Provenance in scientific workflow systems. IEEE Data Engineering Bulletin, 30(4):4450, 2007.</p>
    <p>[6] Z. Liu, S. B. Davidson, and Y. Chen. Generating sound workflow views for correct provenance analysis. ACM Trans. Database Syst., 36(1):6, 2011.</p>
    <p>[7] L. Moreau. The foundations for provenance on the web. Foundations and Trends in Web Science, 2(2-3):99241, 2010.</p>
    <p>[8] L. Moreau. Provenance-based reproducibility in the semantic web. J. Web Sem., 9(2):202221, 2011.</p>
    <p>[9] L. Moreau, B. Clifford, J. Freire, J. Futrelle, Y. Gil, P. T. Groth, N. Kwasnikowska, S. Miles, P. Missier, J. Myers, B. Plale, Y. Simmhan, E. G. Stephan, and J. V. den Bussche. The open provenance model core specification (v1.1). Future Generation Comp. Syst., 27(6):743756, 2011.</p>
    <p>[10] K.-K. Muniswamy-Reddy, U. Braun, D. A. Holland, P. Macko, D. Maclean, D. Margo, M. Seltzer, and R. Smogor. Layering in provenance systems. In Proceedings of the 2009 conference on USENIX Annual techni</p>
    <p>cal conference, USENIX09, pages 1010, Berkeley, CA, USA, 2009. USENIX Association.</p>
  </div>
  <div class="page">
    <p>Adding lists, map  Finally we consider lists and mapping</p>
    <p>and allow nil, cons (and maybe others) as built-in functions</p>
    <p>Note that map is second-order - i.e. mapf is a function for any f</p>
    <p>Map nodes link lists to lists, sub-call nodes map elements to elements</p>
    <p>...expression e ::= c | x | (e) | let x = e1 in e2 (a) | if e1 then e2 else e3 (b) | f (e) (c) | map</p>
    <p>f (e) (d)</p>
    <p>program def f1(x1) = e1,..., fm(xm) = em in e</p>
    <p>Figure 4: Syntax of ProvL</p>
    <p>(a) ProvL0 handles simple workflows involving constant values, primitive operations, variables, and let-binding (expressing sharing). We may take the primitive operations to be the atomic black boxes of any conventional workflow language (e.g. Kepler, VisTrails, Taverna, ZOOM [5]) and represent any straight-line, DAG-shaped computation using these operations as a ProvL0 expression. The corresponding (H)OPM graph is essentially the same DAG with inverted edges.</p>
    <p>(b) ProvLb extends ProvL0 with conditionals (ifthen else). The generated provenance graphs include process nodes to indicate that a conditional was evaluated, and which branch was taken. (This is similar to the approach taken in the model of [2].)</p>
    <p>(c) ProvL f extends ProvLb with user-defined functions, achieving a Turing-complete language (assuming the underlying set of operators includes at least basic arithmetic). The HOPM graph can have nontrivial call trees as described above.</p>
    <p>(d) ProvL, finally, extends ProvL f with support for lists and the map function. The HOPM graph generated for map</p>
    <p>f () consists of the graphs generated for the</p>
    <p>calls f1,..., fn to f on the elements of the list, plus an edge to the input list from a process node for map</p>
    <p>f () itself, plus an edge to this process node from</p>
    <p>the output list node. Also, the map f () process node</p>
    <p>contains all of the calls to f , that is, (map f ()) =</p>
    <p>( f1)  ( fn).</p>
    <p>Some questions for further work: 1. What is the relationship between our notion of</p>
    <p>views and accounts in OPM? It seems that accounts can be used to represent views, but not all accounts correspond to views (for example, accounts can provide conflicting information). How are views of HOPM graphs related to, for example, the traces and trace slicing of Acar et al. [1]?</p>
    <p>into groups to hide details irrelevant to the user.) 3. Our notion of validity for HOPM graphs is basic:</p>
    <p>it does not, for example, require that different calls to the same function have compatible expansions. (That is, it would be legal for one call to f to expand to +1 and for another to expand to 2.) How should validity be made more precise? Can we exactly capture the provenance expressiveness of different workflow languages?</p>
    <p>References [1] U. A. Acar, A. Ahmed, J. Cheney, and R. Perera. A</p>
    <p>core calculus for provenance. In POST, number 7215 in LNCS, pages 410429. Springer, 2012.</p>
    <p>[2] U. A. Acar, P. Buneman, J. Cheney, N. Kwasnikowska, S. Vansummeren, and J. van den Bussche. A graph model for data and workflow provenance. In Workshop on the Theory and Practice of Provenance, 2010.</p>
    <p>[3] Y. Amsterdamer, S. B. Davidson, D. Deutch, T. Milo, J. Stoyanovich, and V. Tannen. Putting lipstick on pig: Enabling database-style workflow provenance. In VLDB, 2012.</p>
    <p>[4] J. Cheney. Causality and the semantics of provenance. In Proceedings of the 2010 Workshop on Developments in</p>
    <p>Computational Models, 2010. [5] S. Davidson, S. Cohen-Boulakia, A. Eyal, B. Ludaescher,</p>
    <p>T. McPhillips, S. Bowers, M. Anand, and J. Freire. Provenance in scientific workflow systems. IEEE Data Engineering Bulletin, 30(4):4450, 2007.</p>
    <p>[6] Z. Liu, S. B. Davidson, and Y. Chen. Generating sound workflow views for correct provenance analysis. ACM Trans. Database Syst., 36(1):6, 2011.</p>
    <p>[7] L. Moreau. The foundations for provenance on the web. Foundations and Trends in Web Science, 2(2-3):99241, 2010.</p>
    <p>[8] L. Moreau. Provenance-based reproducibility in the semantic web. J. Web Sem., 9(2):202221, 2011.</p>
    <p>[9] L. Moreau, B. Clifford, J. Freire, J. Futrelle, Y. Gil, P. T. Groth, N. Kwasnikowska, S. Miles, P. Missier, J. Myers, B. Plale, Y. Simmhan, E. G. Stephan, and J. V. den Bussche. The open provenance model core specification (v1.1). Future Generation Comp. Syst., 27(6):743756, 2011.</p>
    <p>[10] K.-K. Muniswamy-Reddy, U. Braun, D. A. Holland, P. Macko, D. Maclean, D. Margo, M. Seltzer, and R. Smogor. Layering in provenance systems. In Proceedings of the 2009 conference on USENIX Annual techni</p>
    <p>cal conference, USENIX09, pages 1010, Berkeley, CA, USA, 2009. USENIX Association.</p>
    <p>expression e ::= c | x | (e) | let x = e1 in e2 (a) | if e1 then e2 else e3 (b) | f (e) (c) | map</p>
    <p>f (e) (d)</p>
    <p>program def f1(x1) = e1,..., fm(xm) = em in e</p>
    <p>Figure 4: Syntax of ProvL</p>
    <p>(a) ProvL0 handles simple workflows involving constant values, primitive operations, variables, and let-binding (expressing sharing). We may take the primitive operations to be the atomic black boxes of any conventional workflow language (e.g. Kepler, VisTrails, Taverna, ZOOM [5]) and represent any straight-line, DAG-shaped computation using these operations as a ProvL0 expression. The corresponding (H)OPM graph is essentially the same DAG with inverted edges.</p>
    <p>(b) ProvLb extends ProvL0 with conditionals (ifthen else). The generated provenance graphs include process nodes to indicate that a conditional was evaluated, and which branch was taken. (This is similar to the approach taken in the model of [2].)</p>
    <p>(c) ProvL f extends ProvLb with user-defined functions, achieving a Turing-complete language (assuming the underlying set of operators includes at least basic arithmetic). The HOPM graph can have nontrivial call trees as described above.</p>
    <p>(d) ProvL, finally, extends ProvL f with support for lists and the map function. The HOPM graph generated for map</p>
    <p>f () consists of the graphs generated for the</p>
    <p>calls f1,..., fn to f on the elements of the list, plus an edge to the input list from a process node for map</p>
    <p>f () itself, plus an edge to this process node from</p>
    <p>the output list node. Also, the map f () process node</p>
    <p>contains all of the calls to f , that is, (map f ()) =</p>
    <p>( f1)  ( fn).</p>
    <p>Some questions for further work: 1. What is the relationship between our notion of</p>
    <p>views and accounts in OPM? It seems that accounts can be used to represent views, but not all accounts correspond to views (for example, accounts can provide conflicting information). How are views of HOPM graphs related to, for example, the traces and trace slicing of Acar et al. [1]?</p>
    <p>into groups to hide details irrelevant to the user.) 3. Our notion of validity for HOPM graphs is basic:</p>
    <p>it does not, for example, require that different calls to the same function have compatible expansions. (That is, it would be legal for one call to f to expand to +1 and for another to expand to 2.) How should validity be made more precise? Can we exactly capture the provenance expressiveness of different workflow languages?</p>
    <p>References [1] U. A. Acar, A. Ahmed, J. Cheney, and R. Perera. A</p>
    <p>core calculus for provenance. In POST, number 7215 in LNCS, pages 410429. Springer, 2012.</p>
    <p>[2] U. A. Acar, P. Buneman, J. Cheney, N. Kwasnikowska, S. Vansummeren, and J. van den Bussche. A graph model for data and workflow provenance. In Workshop on the Theory and Practice of Provenance, 2010.</p>
    <p>[3] Y. Amsterdamer, S. B. Davidson, D. Deutch, T. Milo, J. Stoyanovich, and V. Tannen. Putting lipstick on pig: Enabling database-style workflow provenance. In VLDB, 2012.</p>
    <p>[4] J. Cheney. Causality and the semantics of provenance. In Proceedings of the 2010 Workshop on Developments in</p>
    <p>Computational Models, 2010. [5] S. Davidson, S. Cohen-Boulakia, A. Eyal, B. Ludaescher,</p>
    <p>T. McPhillips, S. Bowers, M. Anand, and J. Freire. Provenance in scientific workflow systems. IEEE Data Engineering Bulletin, 30(4):4450, 2007.</p>
    <p>[6] Z. Liu, S. B. Davidson, and Y. Chen. Generating sound workflow views for correct provenance analysis. ACM Trans. Database Syst., 36(1):6, 2011.</p>
    <p>[7] L. Moreau. The foundations for provenance on the web. Foundations and Trends in Web Science, 2(2-3):99241, 2010.</p>
    <p>[8] L. Moreau. Provenance-based reproducibility in the semantic web. J. Web Sem., 9(2):202221, 2011.</p>
    <p>[9] L. Moreau, B. Clifford, J. Freire, J. Futrelle, Y. Gil, P. T. Groth, N. Kwasnikowska, S. Miles, P. Missier, J. Myers, B. Plale, Y. Simmhan, E. G. Stephan, and J. V. den Bussche. The open provenance model core specification (v1.1). Future Generation Comp. Syst., 27(6):743756, 2011.</p>
    <p>[10] K.-K. Muniswamy-Reddy, U. Braun, D. A. Holland, P. Macko, D. Maclean, D. Margo, M. Seltzer, and R. Smogor. Layering in provenance systems. In Proceedings of the 2009 conference on USENIX Annual techni</p>
    <p>cal conference, USENIX09, pages 1010, Berkeley, CA, USA, 2009. USENIX Association.</p>
  </div>
  <div class="page">
    <p>Map-incr example 1 2 3</p>
    <p>def f(x) = x + 1 in mapf([1,2,3])</p>
    <p>maph</p>
    <p>mapf</p>
    <p>f2 f3f1</p>
    <p>+</p>
    <p>+</p>
    <p>f2 1</p>
    <p>+</p>
    <p>f3</p>
    <p>main</p>
  </div>
  <div class="page">
    <p>Adding conditionals  Next we consider if-then-else</p>
    <p>conditionals.</p>
    <p>The graph marks the conditional and direction taken.</p>
    <p>...expression e ::= c | x | (e) | let x = e1 in e2 (a) | if e1 then e2 else e3 (b) | f (e) (c) | map</p>
    <p>f (e) (d)</p>
    <p>program def f1(x1) = e1,..., fm(xm) = em in e</p>
    <p>Figure 4: Syntax of ProvL</p>
    <p>(a) ProvL0 handles simple workflows involving constant values, primitive operations, variables, and let-binding (expressing sharing). We may take the primitive operations to be the atomic black boxes of any conventional workflow language (e.g. Kepler, VisTrails, Taverna, ZOOM [5]) and represent any straight-line, DAG-shaped computation using these operations as a ProvL0 expression. The corresponding (H)OPM graph is essentially the same DAG with inverted edges.</p>
    <p>(b) ProvLb extends ProvL0 with conditionals (ifthen else). The generated provenance graphs include process nodes to indicate that a conditional was evaluated, and which branch was taken. (This is similar to the approach taken in the model of [2].)</p>
    <p>(c) ProvL f extends ProvLb with user-defined functions, achieving a Turing-complete language (assuming the underlying set of operators includes at least basic arithmetic). The HOPM graph can have nontrivial call trees as described above.</p>
    <p>(d) ProvL, finally, extends ProvL f with support for lists and the map function. The HOPM graph generated for map</p>
    <p>f () consists of the graphs generated for the</p>
    <p>calls f1,..., fn to f on the elements of the list, plus an edge to the input list from a process node for map</p>
    <p>f () itself, plus an edge to this process node from</p>
    <p>the output list node. Also, the map f () process node</p>
    <p>contains all of the calls to f , that is, (map f ()) =</p>
    <p>( f1)  ( fn).</p>
    <p>Some questions for further work: 1. What is the relationship between our notion of</p>
    <p>views and accounts in OPM? It seems that accounts can be used to represent views, but not all accounts correspond to views (for example, accounts can provide conflicting information). How are views of HOPM graphs related to, for example, the traces and trace slicing of Acar et al. [1]?</p>
    <p>into groups to hide details irrelevant to the user.) 3. Our notion of validity for HOPM graphs is basic:</p>
    <p>it does not, for example, require that different calls to the same function have compatible expansions. (That is, it would be legal for one call to f to expand to +1 and for another to expand to 2.) How should validity be made more precise? Can we exactly capture the provenance expressiveness of different workflow languages?</p>
    <p>References [1] U. A. Acar, A. Ahmed, J. Cheney, and R. Perera. A</p>
    <p>core calculus for provenance. In POST, number 7215 in LNCS, pages 410429. Springer, 2012.</p>
    <p>[2] U. A. Acar, P. Buneman, J. Cheney, N. Kwasnikowska, S. Vansummeren, and J. van den Bussche. A graph model for data and workflow provenance. In Workshop on the Theory and Practice of Provenance, 2010.</p>
    <p>[3] Y. Amsterdamer, S. B. Davidson, D. Deutch, T. Milo, J. Stoyanovich, and V. Tannen. Putting lipstick on pig: Enabling database-style workflow provenance. In VLDB, 2012.</p>
    <p>[4] J. Cheney. Causality and the semantics of provenance. In Proceedings of the 2010 Workshop on Developments in</p>
    <p>Computational Models, 2010. [5] S. Davidson, S. Cohen-Boulakia, A. Eyal, B. Ludaescher,</p>
    <p>T. McPhillips, S. Bowers, M. Anand, and J. Freire. Provenance in scientific workflow systems. IEEE Data Engineering Bulletin, 30(4):4450, 2007.</p>
    <p>[6] Z. Liu, S. B. Davidson, and Y. Chen. Generating sound workflow views for correct provenance analysis. ACM Trans. Database Syst., 36(1):6, 2011.</p>
    <p>[7] L. Moreau. The foundations for provenance on the web. Foundations and Trends in Web Science, 2(2-3):99241, 2010.</p>
    <p>[8] L. Moreau. Provenance-based reproducibility in the semantic web. J. Web Sem., 9(2):202221, 2011.</p>
    <p>[9] L. Moreau, B. Clifford, J. Freire, J. Futrelle, Y. Gil, P. T. Groth, N. Kwasnikowska, S. Miles, P. Missier, J. Myers, B. Plale, Y. Simmhan, E. G. Stephan, and J. V. den Bussche. The open provenance model core specification (v1.1). Future Generation Comp. Syst., 27(6):743756, 2011.</p>
    <p>[10] K.-K. Muniswamy-Reddy, U. Braun, D. A. Holland, P. Macko, D. Maclean, D. Margo, M. Seltzer, and R. Smogor. Layering in provenance systems. In Proceedings of the 2009 conference on USENIX Annual techni</p>
    <p>cal conference, USENIX09, pages 1010, Berkeley, CA, USA, 2009. USENIX Association.</p>
    <p>expression e ::= c | x | (e) | let x = e1 in e2 (a) | if e1 then e2 else e3 (b) | f (e) (c) | map</p>
    <p>f (e) (d)</p>
    <p>program def f1(x1) = e1,..., fm(xm) = em in e</p>
    <p>Figure 4: Syntax of ProvL</p>
    <p>(a) ProvL0 handles simple workflows involving constant values, primitive operations, variables, and let-binding (expressing sharing). We may take the primitive operations to be the atomic black boxes of any conventional workflow language (e.g. Kepler, VisTrails, Taverna, ZOOM [5]) and represent any straight-line, DAG-shaped computation using these operations as a ProvL0 expression. The corresponding (H)OPM graph is essentially the same DAG with inverted edges.</p>
    <p>(b) ProvLb extends ProvL0 with conditionals (ifthen else). The generated provenance graphs include process nodes to indicate that a conditional was evaluated, and which branch was taken. (This is similar to the approach taken in the model of [2].)</p>
    <p>(c) ProvL f extends ProvLb with user-defined functions, achieving a Turing-complete language (assuming the underlying set of operators includes at least basic arithmetic). The HOPM graph can have nontrivial call trees as described above.</p>
    <p>(d) ProvL, finally, extends ProvL f with support for lists and the map function. The HOPM graph generated for map</p>
    <p>f () consists of the graphs generated for the</p>
    <p>calls f1,..., fn to f on the elements of the list, plus an edge to the input list from a process node for map</p>
    <p>f () itself, plus an edge to this process node from</p>
    <p>the output list node. Also, the map f () process node</p>
    <p>contains all of the calls to f , that is, (map f ()) =</p>
    <p>( f1)  ( fn).</p>
    <p>Some questions for further work: 1. What is the relationship between our notion of</p>
    <p>views and accounts in OPM? It seems that accounts can be used to represent views, but not all accounts correspond to views (for example, accounts can provide conflicting information). How are views of HOPM graphs related to, for example, the traces and trace slicing of Acar et al. [1]?</p>
    <p>into groups to hide details irrelevant to the user.) 3. Our notion of validity for HOPM graphs is basic:</p>
    <p>it does not, for example, require that different calls to the same function have compatible expansions. (That is, it would be legal for one call to f to expand to +1 and for another to expand to 2.) How should validity be made more precise? Can we exactly capture the provenance expressiveness of different workflow languages?</p>
    <p>References [1] U. A. Acar, A. Ahmed, J. Cheney, and R. Perera. A</p>
    <p>core calculus for provenance. In POST, number 7215 in LNCS, pages 410429. Springer, 2012.</p>
    <p>[2] U. A. Acar, P. Buneman, J. Cheney, N. Kwasnikowska, S. Vansummeren, and J. van den Bussche. A graph model for data and workflow provenance. In Workshop on the Theory and Practice of Provenance, 2010.</p>
    <p>[3] Y. Amsterdamer, S. B. Davidson, D. Deutch, T. Milo, J. Stoyanovich, and V. Tannen. Putting lipstick on pig: Enabling database-style workflow provenance. In VLDB, 2012.</p>
    <p>[4] J. Cheney. Causality and the semantics of provenance. In Proceedings of the 2010 Workshop on Developments in</p>
    <p>Computational Models, 2010. [5] S. Davidson, S. Cohen-Boulakia, A. Eyal, B. Ludaescher,</p>
    <p>T. McPhillips, S. Bowers, M. Anand, and J. Freire. Provenance in scientific workflow systems. IEEE Data Engineering Bulletin, 30(4):4450, 2007.</p>
    <p>[6] Z. Liu, S. B. Davidson, and Y. Chen. Generating sound workflow views for correct provenance analysis. ACM Trans. Database Syst., 36(1):6, 2011.</p>
    <p>[7] L. Moreau. The foundations for provenance on the web. Foundations and Trends in Web Science, 2(2-3):99241, 2010.</p>
    <p>[8] L. Moreau. Provenance-based reproducibility in the semantic web. J. Web Sem., 9(2):202221, 2011.</p>
    <p>[9] L. Moreau, B. Clifford, J. Freire, J. Futrelle, Y. Gil, P. T. Groth, N. Kwasnikowska, S. Miles, P. Missier, J. Myers, B. Plale, Y. Simmhan, E. G. Stephan, and J. V. den Bussche. The open provenance model core specification (v1.1). Future Generation Comp. Syst., 27(6):743756, 2011.</p>
    <p>[10] K.-K. Muniswamy-Reddy, U. Braun, D. A. Holland, P. Macko, D. Maclean, D. Margo, M. Seltzer, and R. Smogor. Layering in provenance systems. In Proceedings of the 2009 conference on USENIX Annual techni</p>
    <p>cal conference, USENIX09, pages 1010, Berkeley, CA, USA, 2009. USENIX Association.</p>
  </div>
  <div class="page">
    <p>def f(x) = if x = 0 then [] else x::f(x-1) h(z) = z*z in maph(f(3))</p>
    <p>main</p>
    <p>f3 maph</p>
    <p>f2</p>
    <p>f1</p>
    <p>f0</p>
    <p>f3</p>
    <p>maph</p>
    <p>h1 h1h1</p>
  </div>
  <div class="page">
    <p>def f(x) = if x = 0 then [] else x::f(x-1) h(z) = z*z in maph(f(3))</p>
    <p>main</p>
    <p>f3 maph</p>
    <p>f2</p>
    <p>f1</p>
    <p>f0</p>
    <p>maph</p>
    <p>h1 h1h1</p>
    <p>iftrue</p>
    <p>=</p>
    <p>f2 true</p>
    <p>cons</p>
  </div>
  <div class="page">
    <p>Next steps  Modeling of granularity in existing WF languages (or D</p>
    <p>OPM)</p>
    <p>expressiveness / query languages?  Extensions to OPM / W3C PROV for hierarchical</p>
    <p>process structure?</p>
    <p>complementing / clarifying work on &quot;collections&quot;, &quot;accounts&quot;  Richer language features  first-class higher-order functions? (cf. Perera et al. 2012)  meta-programming/provenance of provenance (&quot;eval&quot;)  Efficient implementation (exploit redundancy?)</p>
  </div>
  <div class="page">
    <p>Related work  Provenance layering libraries/architecture (Muniswamy-Reddy et</p>
    <p>al. USENIX 2009)</p>
    <p>Builds on / variant of &quot;graph model of workflow and DB prov&quot; (Acar et al. TaPP 2010)</p>
    <p>ZOOM* User Views (Liu et al. TODS 2011)  abstract views based on user preferences  Kepler (Anand et al. EDBT 2010)  data are serialized XML streams, QL supports nesting and process step</p>
    <p>navigation</p>
    <p>and slicing for program comprehension &amp; provenance (Acar et al. 2012, Perera et al. 2012)</p>
    <p>language-based approach, does not (directly) address abstraction/granu</p>
  </div>
  <div class="page">
    <p>Conclusions  Provenance granularity is an important</p>
    <p>feature of several models</p>
    <p>There is no common understanding for what it means or how it should work</p>
    <p>Our contribution: basic model of &quot;hierarchical&quot; OPM</p>
    <p>But mostly open questions</p>
  </div>
  <div class="page">
    <p>Paper/appendix gives operational semantics producing HOPM graphs</p>
    <p>(a := Gena(c)) ,c  H(a,,),a ,x  H(,,),(x)</p>
    <p>,e  H,a (a := Gena((a))) (p := Genp()) ,(e)</p>
    <p>H H(a, p,a),a</p>
    <p>,e  H,a {x/a},e  H,a</p>
    <p>,let x = e in e  H H,a</p>
    <p>(a)</p>
    <p>,e  H,a (a = true) ,e1  H1,a1 (an := Gena(a1)) (pn := Genp(iftrue)) ,if e then e1 else e2  H H1 H(an, pn,(a,a1)),an</p>
    <p>,e  H,a (a = true) ,e2  H2,a2 (an := Gena(a2)) (pn := Genp(iffalse)) ,if e then e1 else e2  H H2 H(an, pn,(a,a2)),an</p>
    <p>(b)</p>
    <p>,e  H,a (( f ) = f (x).e) {x/a},e  H,a , f (e)</p>
    <p>H H f (a,H,a),a</p>
    <p>(c)</p>
    <p>,e  H,a (a = [c1,...,cn]) , f (c1)  H1,a1 ... , f (cn)  Hn,an (a := Gena([a1,...,a  n]))</p>
    <p>,map f (e)  H H f map(a,[H1,...,Hn],a</p>
    <p>),a</p>
    <p>(d)</p>
    <p>{f /f (x).e},e  H,a def f (x) =e in e  Hmain(H)</p>
    <p>Table 1: Semantics of ProvL</p>
    <p>program syntax for ProvL f in the end of Tab. 4 can now contain function definitions, i.e. it can hold that m &gt; 0. Of course, the size ofxi should be equal to the arity of fi.</p>
    <p>The semantics of ProvL f operates now with HOPM graphs with nontrivial call trees and call mappings. The unions of such HOPM graphs work pairwise as expected. The environment  now has heterogeneous structure: it maps not only variables from X to artefacts from A, but also function names from F to expressions of the form f (x).e which represent bodies of these user-defined functions. To produce valid HOPM graphs we of course require that these bodies implement the interpretations of corresponding function names.</p>
    <p>The semantics of a function call is given in Tab. 1(c). It unions the existing HOPM graphs with new constructed graph H f (a,H,a) = G,T,M. This construction is straightforward: the underlying OPM graph G just coincides with underlying graph of H, and the call tree T and the call mapping M extends those of H as expected w.r.t. the function f .</p>
    <p>The semantics of a program in ProvL f is given in the end of Tab. 1. It forms the original environment  with defining function bodies and evaluates the main expression. The resulting HOPM graph H is then enriched by the root of the call tree (labeled with main) and corresponding call mapping in Hmain(H).</p>
    <p>Language with support for lists ProvL Finally, we show how to extend the languages described before with nested lists and map function. The same can be done for other typed structures like sets or graphs and corresponding higher-order functions. For example, it can be done for HOPM graphs and programs as structures, and optimisers and evaluators as higher-order functions.</p>
    <p>In our language ProvL, extending ProvL f with support for lists and maps, we assume that the set of constants C is typed as described before. We may assume that the set of built-in operators B contains special functions manipulating lists: [c], which creates a list of single element, c1  c2, which concatenates two lists, flatten(c) which flattens a list, first(c) which segregates the first element of a list, and rest(c) which removes the first element from a list. Next we implicitly assume that all expressions are well-typed, i.e. these built-in operators indeed have lists as parameters.</p>
    <p>The syntax of expressions in ProvL, extends ProvL f with the higher-order function map f (e), and is given in Fig. 4. In the rule (d) f is a user-defined function from F of arity 1. As above, we assume that this parametrized by f function map f (e) belongs to the set of functions F. Its semantics is shown in Tab. 1(d). Intuitively, it evaluates the body of f with the variable x substituted with each of the elements of the list e, and composes the list of results. It unions the HOPM graph H, which is the result of the</p>
  </div>
</Presentation>
