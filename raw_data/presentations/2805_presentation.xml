<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Soo-Jin Moon Jeffrey Helt, Yifei Yuan, Yves Bieri,</p>
    <p>Sujata Banerjee, Vyas Sekar, Wenfei Wu, Mihalis Yannakakis, Ying Zhang</p>
    <p>Carnegie Mellon Univ., Princeton Univ., Intentionet, ETH Zurich, VMware Research, Tsinghua Univ., Columbia Univ., Facebook, Inc.</p>
    <p>Contributions by Soo-Jin Moon were made in-part during a former internship at Hewlett Packard Labs. Other contributors from former employees at Hewlett Packard Labs include Sujata Banerjee, Ying Zhang and Wenfei Wu.</p>
    <p>ALEMBIC: AUTOMATED MODEL INFERENCE FOR STATEFUL NETWORK FUNCTIONS</p>
  </div>
  <div class="page">
    <p>Stateful Network Functions (NFs) in Modern Networks</p>
    <p>Firewalls and NATs</p>
    <p>Modern networks contain a wide range of complex stateful network functions from many vendors</p>
    <p>IDS/IPSsLoad balancers</p>
  </div>
  <div class="page">
    <p>Motivating Example: Stateful Firewall (FW)</p>
    <p>FW</p>
    <p>If a connection is ESTABLISHED from the LAN, allow TCP traffic from the WAN else DROP</p>
    <p>LAN WAN</p>
    <p>Host A Host B</p>
    <p>SYNSYN</p>
    <p>Connection Map:</p>
  </div>
  <div class="page">
    <p>Motivating Example: Stateful Firewall (FW)</p>
    <p>FW</p>
    <p>If a connection is ESTABLISHED from the LAN, allow TCP traffic from the WAN else DROP</p>
    <p>LAN WAN</p>
    <p>Host A Host B</p>
    <p>SYNSYN SA SA</p>
    <p>Connection Map:</p>
  </div>
  <div class="page">
    <p>Motivating Example: Stateful Firewall (FW)</p>
    <p>FW</p>
    <p>If a connection is ESTABLISHED from the LAN, allow TCP traffic from the WAN else DROP</p>
    <p>LAN WAN</p>
    <p>Host A Host B</p>
    <p>SYNSYN SA SA</p>
    <p>Connection Map:</p>
    <p>ACK ACK</p>
  </div>
  <div class="page">
    <p>Motivating Example: Stateful Firewall (FW)</p>
    <p>FW</p>
    <p>If a connection is ESTABLISHED from the LAN, allow TCP traffic from the WAN else DROP</p>
    <p>LAN WAN</p>
    <p>Host A Host B</p>
    <p>SYNSYN SA SA</p>
    <p>Connection Map:</p>
    <p>ACK ACK DATA DATA</p>
    <p>A  B == ESTABLISHED</p>
  </div>
  <div class="page">
    <p>Motivating Example: Stateful Firewall (FW)</p>
    <p>FW</p>
    <p>If a connection is ESTABLISHED from the LAN, allow TCP traffic from the WAN else DROP</p>
    <p>LAN WAN</p>
    <p>Host A Host B</p>
    <p>SYNSYN SA SA</p>
    <p>ACK ACK DATA DATA</p>
    <p>Connection Map: A  B == ESTABLISHED</p>
    <p>SYN</p>
    <p>Host C</p>
  </div>
  <div class="page">
    <p>Network Testing and Verification</p>
    <p>Stateful NF</p>
    <p>LAN WAN</p>
    <p>Host A Host B</p>
    <p>?  Is the policy implemented correctly?  Can we check before on-boarding?</p>
    <p>We need network testing/verification tools (e.g.,VMN , SYMNET, BUZZ)</p>
    <p>Operator If a connection is ESTABLISHED from the LAN, allow TCP traffic from the WAN else DROP</p>
  </div>
  <div class="page">
    <p>Today: Need NF Models for Testing and Verification</p>
    <p>Stateful NFLAN WAN</p>
    <p>Host A Host B</p>
    <p>Model (e.g., finite state machine)</p>
    <p>Testing Verification On-boarding</p>
    <p>Today, these NF models are handwritten based on manual investigation</p>
    <p>Config with intended policy</p>
  </div>
  <div class="page">
    <p>Limitation of Handwritten Model: Inaccuracy Network testing tool e.g., BUZZ [NSDI 16]</p>
    <p>Test traffic (from BUZZ)</p>
    <p>Intended Policy</p>
    <p>Real FW</p>
    <p>Handwritten Model</p>
    <p>SYN</p>
    <p>SA</p>
    <p>SYN</p>
    <p>SYN</p>
    <p>SA</p>
    <p>SYN</p>
    <p>SA</p>
    <p>SYN</p>
    <p>SA</p>
    <p>SYN</p>
    <p>Error!</p>
    <p>Handwritten FW model</p>
  </div>
  <div class="page">
    <p>Limitation of Handwritten Model: Inaccuracy Network testing tool e.g., BUZZ [NSDI 16]</p>
    <p>Test traffic (from BUZZ)</p>
    <p>Intended Policy</p>
    <p>Real FW</p>
    <p>Handwritten Model</p>
    <p>SYN</p>
    <p>SA</p>
    <p>SYN</p>
    <p>SYN</p>
    <p>SA</p>
    <p>SYN</p>
    <p>SA</p>
    <p>SYN</p>
    <p>SA</p>
    <p>SYN</p>
    <p>Handwritten FW model</p>
  </div>
  <div class="page">
    <p>Limitation of Handwritten Model: Inaccuracy Network testing tool e.g., BUZZ [NSDI 16]</p>
    <p>Handwritten FW model</p>
    <p>Real FW implementation</p>
    <p>/ NULL</p>
    <p>SYN</p>
    <p>SA /</p>
    <p>/ACK</p>
    <p>SYN SENT</p>
    <p>SA SENT</p>
    <p>Else/</p>
    <p>Else/</p>
    <p>. . . .</p>
    <p>*/</p>
    <p>SA</p>
    <p>SYN</p>
    <p>ACK</p>
    <p>EST</p>
    <p>Handwritten FW model (BUZZ, NSDI 16)</p>
    <p>/ NULL</p>
    <p>SYN</p>
    <p>SA /</p>
    <p>SYN SENT</p>
    <p>SA SENT</p>
    <p>Else/</p>
    <p>*/</p>
    <p>SA</p>
    <p>SYN</p>
    <p>= 6</p>
  </div>
  <div class="page">
    <p>Limitation of Handwritten Model: Inaccuracy Network testing tool e.g., BUZZ [NSDI 16]</p>
    <p>Handwritten FW model</p>
    <p>Real FW implementation</p>
    <p>/ NULL</p>
    <p>SYN</p>
    <p>SA /</p>
    <p>/ACK</p>
    <p>SYN SENT</p>
    <p>SA SENT</p>
    <p>Else/</p>
    <p>Else/</p>
    <p>. . . .</p>
    <p>*/</p>
    <p>SA</p>
    <p>SYN</p>
    <p>ACK</p>
    <p>EST</p>
    <p>Handwritten FW model (BUZZ, NSDI 16)</p>
    <p>/ NULL</p>
    <p>SYN</p>
    <p>SA /</p>
    <p>SYN SENT</p>
    <p>SA SENT</p>
    <p>Else/</p>
    <p>*/</p>
    <p>SA</p>
    <p>SYN</p>
    <p>= 6</p>
  </div>
  <div class="page">
    <p>Limitation of Handwritten Model: Inaccuracy Network testing tool e.g., BUZZ [NSDI 16]</p>
    <p>Handwritten FW model</p>
    <p>Real FW implementation</p>
    <p>/ NULL</p>
    <p>SYN</p>
    <p>SA /</p>
    <p>/ACK</p>
    <p>SYN SENT</p>
    <p>SA SENT</p>
    <p>Else/</p>
    <p>Else/</p>
    <p>. . . .</p>
    <p>*/</p>
    <p>SA</p>
    <p>SYN</p>
    <p>ACK</p>
    <p>EST</p>
    <p>Handwritten FW model (BUZZ, NSDI 16)</p>
    <p>/ NULL</p>
    <p>SYN</p>
    <p>SA /</p>
    <p>SYN SENT</p>
    <p>SA SENT</p>
    <p>Else/</p>
    <p>*/</p>
    <p>SA</p>
    <p>SYN</p>
    <p>= 6</p>
  </div>
  <div class="page">
    <p>Test traffic (from BUZZ)</p>
    <p>Untangle FW</p>
    <p>PropNF FW</p>
    <p>SYN</p>
    <p>SA</p>
    <p>SYN</p>
    <p>SYN</p>
    <p>SA</p>
    <p>SYN</p>
    <p>ACK</p>
    <p>Vendor-specific differences</p>
    <p>Limitation of Handwritten Model: Vendor Diversity</p>
    <p>SYN</p>
    <p>SA</p>
    <p>SYN</p>
    <p>Vendors have different implementations!</p>
  </div>
  <div class="page">
    <p>Our Work: Alembic</p>
    <p>Stateful NF</p>
    <p>Config</p>
    <p>Customers: 1) BUZZ [NSDI16] 2) SYMNET [SIGCOMM16] 3) VMN [NSDI17]</p>
    <p>Automatically infer a behavioral model of the NF for a configuration</p>
    <p>Finite State Machine (FSM) Model = NF(config)</p>
    <p>} 8</p>
  </div>
  <div class="page">
    <p>Talk Outline</p>
    <p>Motivation and Goal</p>
    <p>Challenges and Insights</p>
    <p>Overall Workflow</p>
    <p>Evaluation</p>
  </div>
  <div class="page">
    <p>High-Level Challenges</p>
    <p>Stateful NF</p>
    <p>Inferring NF behavior</p>
    <p>Large configuration space</p>
    <p>. . .</p>
    <p>Config N</p>
    <p>Rule 1 Rule 2</p>
    <p>Rule 1000Config 1</p>
  </div>
  <div class="page">
    <p>Challenges on Large Configuration Space</p>
    <p>Configuration ! many rules</p>
    <p>Rule ! IP/port fields take large sets of values (e.g., 232 for IPs)</p>
    <p>Rule ! IP/port fields can be ranges (e.g., /16 for IP prefixes)</p>
  </div>
  <div class="page">
    <p>Rule1</p>
    <p>Rule2</p>
    <p>. . .</p>
    <p>RuleN</p>
    <p>Rule1</p>
    <p>Rule2</p>
    <p>. . .</p>
    <p>RuleN</p>
    <p>Insight 1: We Can Compose Models of Individual Rules</p>
    <p>Stateful NF</p>
    <p>Rule1</p>
    <p>Rule2</p>
    <p>. . . RuleN</p>
    <p>. . .</p>
    <p>Model</p>
    <p>Naive solution</p>
  </div>
  <div class="page">
    <p>Rule1</p>
    <p>Rule2</p>
    <p>. . .</p>
    <p>RuleN</p>
    <p>Rule1</p>
    <p>Rule2</p>
    <p>. . .</p>
    <p>RuleN</p>
    <p>Insight 1: We Can Compose Models of Individual Rules</p>
    <p>Stateful NF</p>
    <p>Rule1</p>
    <p>Rule2</p>
    <p>. . . RuleN</p>
    <p>. . .</p>
    <p>Model2</p>
    <p>Model1</p>
    <p>ModelN</p>
  </div>
  <div class="page">
    <p>Rule1</p>
    <p>Rule2</p>
    <p>. . .</p>
    <p>RuleN</p>
    <p>Rule1</p>
    <p>Rule2</p>
    <p>. . .</p>
    <p>RuleN</p>
    <p>Insight 1: We Can Compose Models of Individual Rules</p>
    <p>Stateful NF</p>
    <p>Rule1</p>
    <p>Rule2</p>
    <p>. . . RuleN</p>
    <p>. . .</p>
    <p>Process Order</p>
    <p>compose per rule models</p>
    <p>Model2</p>
    <p>Model1</p>
    <p>ModelN</p>
  </div>
  <div class="page">
    <p>Challenges on Large Configuration Space</p>
    <p>Configuration ! many rules</p>
    <p>Rule ! IP/port fields take large sets of values (e.g., 232 for IPs)</p>
    <p>Rule ! IP/port fields can be ranges (e.g., /16 for IP prefixes)</p>
  </div>
  <div class="page">
    <p>Insight 2: Use Symbolic Models to represent Large Sets Rule 1: SRC IP:10 DST IP:15</p>
    <p>S0 S1</p>
    <p>Else 1015</p>
    <p>Rule 2: SRC IP:12 DST IP:15</p>
    <p>S0 S1</p>
  </div>
  <div class="page">
    <p>Insight 2: Use Symbolic Models to represent Large Sets Rule 1: SRC IP:10 DST IP:15</p>
    <p>S0 S1</p>
    <p>Else 1015</p>
    <p>Rule 2: SRC IP:12 DST IP:15</p>
    <p>S0 S1</p>
    <p>SRC IP:A DST IP:B</p>
    <p>M(A,B) = S0 S1</p>
    <p>AB</p>
    <p>BA</p>
    <p>Else AB</p>
    <p>BA</p>
  </div>
  <div class="page">
    <p>Insight 2: Use Symbolic Models to represent Large Sets Rule 1: SRC IP:10 DST IP:15</p>
    <p>S0 S1</p>
    <p>Else 1015</p>
    <p>Rule 2: SRC IP:12 DST IP:15</p>
    <p>S0 S1</p>
    <p>M(A,B) where A = 13, B = 16SRC IP:13 DST IP:16If we get a new config:</p>
    <p>SRC IP:A DST IP:B</p>
    <p>M(A,B) = S0 S1</p>
    <p>AB</p>
    <p>BA</p>
    <p>Else AB</p>
    <p>BA</p>
  </div>
  <div class="page">
    <p>Challenges on Large Configuration Space</p>
    <p>Configuration ! many rules</p>
    <p>Rule ! IP/port fields take large sets of values (e.g., 232 for IPs)</p>
    <p>Rule ! IP/port fields can be ranges (e.g., /16 for IP prefixes)</p>
  </div>
  <div class="page">
    <p>Insight 3: Exploit Independence to Create an Ensemble of FSMs SRC IP:10.1.1.0/16DST IP:15.1.1.0/16</p>
  </div>
  <div class="page">
    <p>Insight 3: Exploit Independence to Create an Ensemble of FSMs SRC IP:10.1.1.0/16DST IP:15.1.1.0/16</p>
    <p>Independent packet processing per connection Per-connection</p>
    <p>Conn 1 : 10.1.1.1  15.1.1.1</p>
    <p>Conn 2 : 10.1.1.2  15.1.1.2 States do not interfere}</p>
  </div>
  <div class="page">
    <p>Insight 3: Exploit Independence to Create an Ensemble of FSMs SRC IP:10.1.1.0/16DST IP:15.1.1.0/16</p>
    <p>An ensemble of concrete FSMs can represent a rule with IP/port ranges</p>
    <p>Per-connection</p>
    <p>(symbolic model from insight 2)</p>
    <p>Learn M(A, B)</p>
    <p>[10.1.1.115.1.1.1]</p>
    <p>S0 S1</p>
    <p>Else</p>
    <p>Instantiate</p>
    <p>at runtime</p>
    <p>Ensemble of FSMs</p>
    <p>Independent packet processing per connection</p>
  </div>
  <div class="page">
    <p>Summary of Insights to Address Large Configuration Space</p>
    <p>A configuration is composed of many number of rules</p>
    <p>Compositional Model</p>
    <p>A rule contains IP/port fields which take large sets of values and ranges.</p>
    <p>An Ensemble of FSMsSymbolic Model Instantiation</p>
  </div>
  <div class="page">
    <p>Back to High-Level Challenges</p>
    <p>Stateful NF</p>
    <p>Inferring NF behavior</p>
    <p>Large configuration space</p>
    <p>. . .</p>
    <p>Config N</p>
    <p>Rule 1 Rule 2</p>
    <p>Rule 1000Config 1</p>
  </div>
  <div class="page">
    <p>Inferring the symbolic FSM</p>
    <p>Inferring the state granularity</p>
    <p>Handling dynamic header modification</p>
    <p>Challenges on Inferring NF Behavior</p>
  </div>
  <div class="page">
    <p>Insight: Leverage L* Algorithm to Infer a Symbolic FSM</p>
    <p>NF</p>
    <p>Config</p>
    <p>Alembic</p>
    <p>Blackbox L* algorithm</p>
    <p>FSM representing the blackbox</p>
    <p>We can use the L* algorithm! 20</p>
  </div>
  <div class="page">
    <p>Background on L* for Black-box FSM Inference</p>
    <p>Input Alphabet ( = {a,b})</p>
    <p>Generates sequences (e.g., aa, aba) and probes the blackbox  Builds a hypothesis FSM with input-output pairs seen so far  Queries an Equivalence Oracle (EO) for counterexamples</p>
    <p>Blackbox</p>
    <p>L* Equivalence Oracle</p>
  </div>
  <div class="page">
    <p>Practical Challenges of Applying L* for an NF</p>
    <p>Generate input alphabet</p>
    <p>Classify output of an NF</p>
    <p>Build an Equivalence Oracle</p>
  </div>
  <div class="page">
    <p>Generating Input Alphabet to handle Large Traffic Space</p>
    <p>Stateful NF</p>
    <p>Rule1: SRC IP:ADST IP:B Naive solutions:</p>
    <p>Infeasible</p>
    <p>Does not explore the relevant state space LAN WAN</p>
  </div>
  <div class="page">
    <p>Generating Input Alphabet to handle Large Traffic Space</p>
    <p>To exercise the rule, we generate packets with IP/ports in the rule</p>
    <p>Stateful NF</p>
    <p>Rule1: SRC IP:ADST IP:B Naive solutions:</p>
    <p>Infeasible</p>
    <p>Does not explore the relevant state space</p>
    <p>BA</p>
    <p>AB</p>
    <p>BA</p>
    <p>LAN WAN</p>
  </div>
  <div class="page">
    <p>Generating Input Alphabet to handle Large Traffic Space</p>
    <p>To exercise the rule, we generate packets with IP/ports in the rule</p>
    <p>Stateful NF</p>
    <p>Rule1: SRC IP:ADST IP:B Naive solutions:</p>
    <p>Infeasible</p>
    <p>Does not explore the relevant state space</p>
    <p>BA</p>
    <p>LAN WAN 2) (Optional) Prune based on reachability</p>
  </div>
  <div class="page">
    <p>Generating Input Alphabet to handle Large Traffic Space</p>
    <p>To exercise the rule, we generate packets with IP/ports in the rule</p>
    <p>Stateful NF</p>
    <p>Rule1: SRC IP:ADST IP:B Naive solutions:</p>
    <p>Infeasible</p>
    <p>Does not explore the relevant state space</p>
    <p>LAN WAN 2) (Optional) Prune based on reachability</p>
    <p>SYN, AB</p>
    <p>SYNACK, AB</p>
    <p>SYN, BA</p>
    <p>SA, BA</p>
  </div>
  <div class="page">
    <p>Generate input alphabet</p>
    <p>Classify output of an NF</p>
    <p>Configure the timeout to classify output</p>
    <p>Translating to/from symbolic and concrete packets</p>
    <p>Build an Equivalence Oracle</p>
    <p>Practical Challenges of Applying L* for an NF</p>
  </div>
  <div class="page">
    <p>Challenges on Inferring NF Behavior</p>
    <p>Inferring the symbolic model (FSM)</p>
    <p>Inferring the state granularity</p>
    <p>Handling dynamic header modification</p>
  </div>
  <div class="page">
    <p>Different Types of State Granularity</p>
    <p>Cross-connection One FSM for all connections</p>
    <p>Per-source One FSM for each srcip</p>
    <p>Per-destination One FSM for each dstip</p>
    <p>Per-connection One FSM for every IP-port pair</p>
    <p>State Granularity: the state variables (IP/ports) that the NF uses to keep state</p>
    <p>This is like a key mapping to the FSM 26</p>
  </div>
  <div class="page">
    <p>Learning the State Granularity</p>
    <p>A</p>
    <p>A</p>
    <p>B</p>
    <p>B</p>
    <p>DST IPSRC IP conn1</p>
    <p>conn2 Cross-connection</p>
    <p>Do these affect the same FSM?</p>
    <p>No</p>
    <p>A B</p>
    <p>B</p>
    <p>conn1</p>
    <p>conn2 Per-source</p>
    <p>Do these affect the same FSM?</p>
    <p>No . . .</p>
  </div>
  <div class="page">
    <p>Learning the State Granularity</p>
    <p>A</p>
    <p>A</p>
    <p>B</p>
    <p>B</p>
    <p>DST IPSRC IP conn1</p>
    <p>conn2 Cross-connection</p>
    <p>Do these affect the same FSM?</p>
    <p>No</p>
    <p>A B</p>
    <p>B</p>
    <p>conn1</p>
    <p>conn2 Per-source</p>
    <p>Do these affect the same FSM?</p>
    <p>No . . .Construct test cases for independence across connections</p>
  </div>
  <div class="page">
    <p>Alembic Workflow: Offline</p>
    <p>Library of symbolic models</p>
    <p>RuleType i : (Keyi, SymFSMi)</p>
    <p>KeyLearning</p>
    <p>VendorDoc</p>
    <p>NF</p>
    <p>PacketTypes</p>
    <p>RuleTypeGen</p>
    <p>RuleTypei</p>
    <p>FSMInference (Extended L*)</p>
    <p>Runs once per NF</p>
    <p>Distributed Learning</p>
  </div>
  <div class="page">
    <p>Alembic Workflow: Online Runs for every config</p>
    <p>Concrete config</p>
    <p>Instantiate(Rule1)</p>
    <p>. . .</p>
    <p>Instantiate(Rule2)</p>
    <p>Instantiate(RuleN)</p>
    <p>Rule1 Rule2 . . .</p>
    <p>RuleN</p>
    <p>RuleType i : (Keyi, SymFSMi)</p>
    <p>If packet p match Rule1:</p>
    <p>Ensemble(Rule1)</p>
    <p>Elif packet p match Rule2:</p>
    <p>Ensemble(Rule2)</p>
    <p>. . .</p>
  </div>
  <div class="page">
    <p>Evaluation Summary</p>
    <p>Alembic-generated models are accurate</p>
    <p>Case Studies: Alembic finds differences across NF implementations</p>
    <p>Alembic workflow is scalable</p>
    <p>Alembic-generated models improve the accuracy of network testing/verification tools</p>
  </div>
  <div class="page">
    <p>Evaluation Setup  Validated Alembic using Click-based NFs where we know the ground truth  Real NFs we modeled :</p>
    <p>PfSense (FW, static NAT, random NAT, LB)  Proprietary NF (FW, static NAT)  Untangle (FW)  HAproxy (LB)</p>
    <p>Packet types used:  Correct-Seq: {SYNC, SYN-ACKC, ACKC, FIN-ACKC, RST-ACKC}  Combined-Seq: extend the correct-seq set with incorrect seq and ack,</p>
    <p>{SYN-ACKI, ACKI, FIN-ACKI, RST-ACKI}</p>
  </div>
  <div class="page">
    <p>Accuracy Evaluation</p>
    <p>Config generation: 1 to 100 rules in a configuration  Packet generation: 20 to 300 packets in a sequence</p>
    <p>Since we do not have the ground-truth, we designed complementary testing methodology to test the accuracy of our models</p>
  </div>
  <div class="page">
    <p>Evaluation Summary</p>
    <p>Alembic-generated models are accurate</p>
    <p>Case Studies: Alembic finds differences across NF implementations</p>
    <p>Alembic workflow is scalable</p>
    <p>Alembic-generated models improve the accuracy of network testing/verification tools</p>
  </div>
  <div class="page">
    <p>Firewall Case Study PfSense ProprietaryNF</p>
    <p>Packet sequence before the FW allows TCP traffic from an external host (B ) to an internal host (A)</p>
    <p>Number of states 3 79</p>
    <p>Default behavior Default Drop Default Drop</p>
    <p>SYN, AB</p>
    <p>SYN, AB</p>
    <p>SA, BA</p>
  </div>
  <div class="page">
    <p>Firewall Case Study PfSense ProprietaryNF</p>
    <p>Packet sequence before the FW allows TCP traffic from an external host (B ) to an internal host (A)</p>
    <p>Number of states 3 79</p>
    <p>Default behavior Default Drop Default Drop</p>
    <p>SYN, AB</p>
    <p>SYN, AB</p>
    <p>SA, BA</p>
  </div>
  <div class="page">
    <p>Firewall Case Study PfSense ProprietaryNF</p>
    <p>Packet sequence before the FW allows TCP traffic from an external host (B ) to an internal host (A)</p>
    <p>Number of states 3 79</p>
    <p>Default behavior Default Drop Default Drop</p>
    <p>SYN, AB</p>
    <p>SYN, AB</p>
    <p>SA, BA</p>
  </div>
  <div class="page">
    <p>Implements default allow  Connection-terminating</p>
    <p>Firewall Case Study: Untangle Firewall</p>
    <p>*</p>
    <p>SYN</p>
    <p>/ * /</p>
    <p>SYN / 1</p>
    <p>SYN</p>
    <p>ACK</p>
    <p>/ /</p>
    <p>SYN / SA SA / ACK ACK /</p>
  </div>
  <div class="page">
    <p>Implements default allow  Connection-terminating</p>
    <p>Firewall Case Study: Untangle Firewall</p>
    <p>*</p>
    <p>SYN</p>
    <p>/ * /</p>
    <p>SYN / 1</p>
    <p>SYN</p>
    <p>ACK</p>
    <p>/ /</p>
    <p>SYN / SA SA / ACK ACK /</p>
    <p>When B responds with SA, the FW preemptively responds with ACK</p>
  </div>
  <div class="page">
    <p>Implements default allow  Connection-terminating</p>
    <p>Firewall Case Study: Untangle Firewall</p>
    <p>*</p>
    <p>SYN</p>
    <p>/ * /</p>
    <p>SYN / 1</p>
    <p>SYN</p>
    <p>ACK</p>
    <p>/ /</p>
    <p>SYN / SA SA / ACK ACK /</p>
    <p>When A replies with ACK, the FW drops to prevent duplicates</p>
  </div>
  <div class="page">
    <p>Implements default allow  Connection-terminating</p>
    <p>Firewall Case Study: Untangle Firewall</p>
    <p>*</p>
    <p>SYN</p>
    <p>/ * /</p>
    <p>SYN / 1</p>
    <p>SYN</p>
    <p>ACK</p>
    <p>/ /</p>
    <p>SYN / SA SA / ACK ACK /</p>
    <p>Takeaways: 1) Vendor diversity (no common practice) 2) The real FSMs are complex and are infeasible for humans to manually generate</p>
  </div>
  <div class="page">
    <p>Other Findings</p>
    <p>FW: models with incorrect seq ! large FSM (257 states for PfSense)</p>
    <p>FW: many do not correctly handle out-of-window packets</p>
    <p>LB: HAproxy (connection-terminating) vs. PfSense (destination NAT)</p>
    <p>. . .</p>
  </div>
  <div class="page">
    <p>Evaluation Summary</p>
    <p>Alembic-generated models are accurate</p>
    <p>Case Studies: Alembic finds differences across NF implementations</p>
    <p>Alembic workflow is scalable</p>
    <p>Alembic-generated models improve the accuracy of network testing/verification tools</p>
  </div>
  <div class="page">
    <p>Scalability of Alembic Online</p>
    <p>Number of Rules Runtime</p>
    <p>Alembic can generate concrete models in a few seconds for a large config</p>
  </div>
  <div class="page">
    <p>Limitations and Future Work Assumption on configurations:  Assume at most one rule is applied  States across different state granularities (i.e., keys) are independent  Assume that IP/port fields are treated homogeneously such that we can pick one</p>
    <p>representative sample and infer a model</p>
    <p>Assumption on NF actions:  Focused on modeling TCP-relevant behavior where actions are restricted to</p>
    <p>dropping and forwarding, possibly with IP/port modifications  Do not explicitly model temporal effects  Support the following state granularity types: per-connection, per-source, per</p>
    <p>destination, cross-connection, and stateless</p>
    <p>Future work:  Dealing with more complex NFs (e.g., rate-limiting NF, modeling temporal effects)</p>
  </div>
  <div class="page">
    <p>Conclusions: Alembic can accurately model stateful NFs</p>
    <p>Network testing and verification today need NF models  Handwritten models: tedious, error-prone, and inaccurate  Alembic: infers a high-fidelity NF model given a configuration  Our evaluations show:  Alembic finds implementation-specific behavior of NFs  Alembic-generated models increase the accuracy of testing/</p>
    <p>verification</p>
    <p>Alembic is scalable and accurate Soo-Jin Moon: soojinm@andrew.cmu.edu</p>
  </div>
</Presentation>
