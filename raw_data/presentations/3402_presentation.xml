<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>BootStomp: On the Security of Bootloaders in Mobile Devices</p>
    <p>Nilo Redini, Aravind Machiry, Dipanjan Das, Yanick Fratantonio, Antonio Bianchi, Eric Gustafson, Yan Shoshitaishvili,</p>
    <p>Christopher Kruegel, Giovanni Vigna</p>
    <p>University of California, Santa Barbara</p>
    <p>Presented at USENIX 2017</p>
  </div>
  <div class="page">
    <p>What is a Bootloader?</p>
  </div>
  <div class="page">
    <p>What is a Bootloader?</p>
    <p>Software module which:</p>
    <p>Initializes the device and its peripherals</p>
    <p>Loads the kernel code from secondary storage</p>
    <p>Jumps to it</p>
  </div>
  <div class="page">
    <p>We focused on Android bootloaders</p>
  </div>
  <div class="page">
    <p>Android Bootloaders Overview</p>
    <p>No standard (e.g., ARM gives guidelines)</p>
    <p>Booting through several stages</p>
    <p>Protect integrity of user's device and data:</p>
    <p>Trusted boot</p>
    <p>Bootloader unlocking</p>
  </div>
  <div class="page">
    <p>Why attacking bootloaders?</p>
  </div>
  <div class="page">
    <p>Attacking Bootloaders</p>
    <p>An attacker controlling the bootloader might:</p>
    <p>Boot custom Android OS (bootloader unlocking)</p>
    <p>Persistent rootkit</p>
    <p>Brick the device</p>
    <p>In some cases, achieve controls over peripherals</p>
  </div>
  <div class="page">
    <p>Safety Properties</p>
    <p>Integrity of the booting process</p>
    <p>Android OS is verifiably to be in a non-tampered state</p>
    <p>A root process cannot interfere with peripherals setup</p>
    <p>Unlocking security mechanism</p>
    <p>A root process cannot unlock the bootloader</p>
    <p>Physical attacker cannot unlock the bootloader</p>
  </div>
  <div class="page">
    <p>Threat Model</p>
  </div>
  <div class="page">
    <p>Threat Model</p>
    <p>Attacker has control over the Android OS</p>
    <p>Root privileges</p>
  </div>
  <div class="page">
    <p>Threat Model</p>
    <p>Attacker has control over the Android OS</p>
    <p>Root privileges</p>
    <p>If an attacker has root privileges is game over, why even bother?</p>
    <p>The safety properties should hold anyway</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Booting Process</p>
    <p>Bootloader Unlocking</p>
    <p>BootStomp</p>
    <p>Evaluation</p>
    <p>Mitigations</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Booting Process</p>
    <p>Bootloader Unlocking</p>
    <p>BootStomp</p>
    <p>Evaluation</p>
    <p>Mitigations</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Booting Process God mode Kernel mode User mode</p>
  </div>
  <div class="page">
    <p>Booting Process God mode Kernel mode User mode</p>
  </div>
  <div class="page">
    <p>Booting Process God mode Kernel mode User mode</p>
  </div>
  <div class="page">
    <p>Booting Process God mode Kernel mode User mode</p>
  </div>
  <div class="page">
    <p>Booting Process God mode Kernel mode User mode</p>
  </div>
  <div class="page">
    <p>Booting Process</p>
    <p>Bootloader</p>
    <p>God mode Kernel mode User mode</p>
  </div>
  <div class="page">
    <p>Booting Process</p>
    <p>Android OS</p>
    <p>God mode Kernel mode User mode</p>
  </div>
  <div class="page">
    <p>Booting Process God mode Kernel mode User mode</p>
    <p>Chain of trust</p>
  </div>
  <div class="page">
    <p>Booting Process God mode Kernel mode User mode</p>
    <p>Chain of trust</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Booting Process</p>
    <p>Bootloader Unlocking</p>
    <p>BootStomp</p>
    <p>Evaluation</p>
    <p>Mitigations</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Bootloader Unlocking</p>
    <p>Two steps</p>
  </div>
  <div class="page">
    <p>Bootloader Unlocking</p>
    <p>Against an attacker with physical access Against root process</p>
  </div>
  <div class="page">
    <p>Bootloader Unlocking</p>
    <p>The unlocking state (devices security state) saved on persistent storage</p>
    <p>It should be writable only by high privileged components (e.g.,</p>
    <p>bootloader or secure OS)</p>
  </div>
  <div class="page">
    <p>Can a compromised Android OS affect the booting</p>
    <p>process?</p>
  </div>
  <div class="page">
    <p>Can a compromised Android OS affect the booting</p>
    <p>process?</p>
    <p>Yes!</p>
  </div>
  <div class="page">
    <p>Bootloader</p>
    <p>Android OS</p>
    <p>Persistent Storage</p>
    <p>Read</p>
    <p>Load</p>
  </div>
  <div class="page">
    <p>We need a tool to automatically verify</p>
    <p>the safety properties</p>
  </div>
  <div class="page">
    <p>Towards a Bootloader Analyzer</p>
    <p>Bootloaders are hard to analyze:</p>
    <p>The source code is hardly available</p>
  </div>
  <div class="page">
    <p>Towards a Bootloader Analyzer</p>
    <p>Bootloaders are hard to analyze:</p>
    <p>The source code is hardly available  Binary (blob)</p>
  </div>
  <div class="page">
    <p>Towards a Bootloader Analyzer</p>
    <p>Bootloaders are hard to analyze:</p>
    <p>The source code is hardly available  Binary (blob)</p>
    <p>Dynamic execution is impractical</p>
  </div>
  <div class="page">
    <p>Towards a Bootloader Analyzer</p>
    <p>Bootloaders are hard to analyze:</p>
    <p>The source code is hardly available  Binary (blob)</p>
    <p>Dynamic execution is impractical  Hardware is required</p>
  </div>
  <div class="page">
    <p>Towards a Bootloader Analyzer</p>
    <p>Bootloaders are hard to analyze:</p>
    <p>The source code is hardly available  Binary (blob)</p>
    <p>Dynamic execution is impractical  Hardware is required</p>
    <p>Execute before the Android OS</p>
  </div>
  <div class="page">
    <p>Towards a Bootloader Analyzer</p>
    <p>Bootloaders are hard to analyze:</p>
    <p>The source code is hardly available  Binary (blob)</p>
    <p>Dynamic execution is impractical  Hardware is required</p>
    <p>Execute before the Android OS  Known library/syscall are not in use</p>
  </div>
  <div class="page">
    <p>Towards a Bootloader Analyzer</p>
    <p>Bootloaders are hard to analyze:</p>
    <p>The source code is hardly available  Binary (blob)</p>
    <p>Dynamic execution is impractical  Hardware is required</p>
    <p>Execute before the Android OS  Known library/syscall are not in use</p>
    <p>There is no memcpy!</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Booting Process</p>
    <p>Unlocking Mechanism</p>
    <p>BootStomp</p>
    <p>Evaluation</p>
    <p>Mitigations</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>BootStomp: A Bootloader Analyzer</p>
    <p>Automatic static binary tool for finding security vulnerabilities in bootloaders</p>
  </div>
  <div class="page">
    <p>BootStomp: A Bootloader Analyzer</p>
    <p>Automatic static binary tool for finding security vulnerabilities in bootloaders</p>
    <p>Determine whether attacker-controlled data can influence the bootloader</p>
    <p>intended behavior</p>
    <p>Traceable output</p>
    <p>Verify generated alerts</p>
  </div>
  <div class="page">
    <p>BootStomp: A Bootloader Analyzer</p>
    <p>BootStomp uses multi-tag taint analysis based on under-constrained dynamic</p>
    <p>symbolic execution</p>
  </div>
  <div class="page">
    <p>BootStomp: A Bootloader Analyzer</p>
    <p>BootStomp uses multi-tag taint analysis based on under-constrained dynamic</p>
    <p>symbolic execution</p>
    <p>It uses a fully symbolic taint analysis engine to trace attacker-controlled data</p>
  </div>
  <div class="page">
    <p>BootStomp: A Bootloader Analyzer</p>
    <p>BootStomp uses multi-tag taint analysis based on under-constrained dynamic</p>
    <p>symbolic execution</p>
    <p>Arbitrary memory writes</p>
    <p>Arbitrary memory reads</p>
    <p>Attacker can control loops iterations</p>
    <p>Bypass unlocking mechanism</p>
    <p>Functions overwriting the security state on persistent storage</p>
  </div>
  <div class="page">
    <p>BootStomp: A Bootloader Analyzer</p>
  </div>
  <div class="page">
    <p>BootStomp: A Bootloader Analyzer</p>
    <p>BootStomp uses multi-tag taint analysis based on under-constrained dynamic</p>
    <p>symbolic execution</p>
    <p>Seeds of taint</p>
    <p>Taint propagation and removal</p>
    <p>Sinks of taint</p>
    <p>Taint checking</p>
  </div>
  <div class="page">
    <p>BootStomp: Seeds of Taint</p>
    <p>Data read from persistent storage</p>
    <p>Data used by the unlocking procedure</p>
  </div>
  <div class="page">
    <p>BootStomp: Seeds of Taint</p>
    <p>Data read from persistent storage</p>
    <p>Data used by the unlocking procedure</p>
    <p>BootStomp must find these functions</p>
  </div>
  <div class="page">
    <p>BootStomp: Seeds of Taint</p>
    <p>Automatic detection of functions:</p>
    <p>Identify the functions based on the log strings</p>
    <p>Analysis to identify the arguments to taint</p>
  </div>
  <div class="page">
    <p>BootStomp: Seeds of Taint</p>
    <p>Optionally, provided by the security analyst</p>
    <p>Useful for finding the unlocking function</p>
    <p>Several do not contain log messages</p>
  </div>
  <div class="page">
    <p>BootStomp: Taint Propagation and Removal</p>
    <p>Taints are symbolic expressions encoding how the value is computed</p>
    <p>Propagated and removed implicitly during the dynamic symbolic execution traversal</p>
  </div>
  <div class="page">
    <p>BootStomp: Taint Propagation and Removal</p>
  </div>
  <div class="page">
    <p>BootStomp: Sinks of Taint</p>
    <p>Memcpy-like functions</p>
    <p>Dereference of a tainted variable</p>
    <p>Comparisons of tainted variables in loops conditions</p>
    <p>Write to a persistent storage of a tainted variable</p>
  </div>
  <div class="page">
    <p>BootStomp: Sinks of Taint</p>
    <p>Memcpy-like functions</p>
    <p>Small functions with loop copying data between two buffers</p>
    <p>Many callers (a threshold is used)</p>
    <p>Dereference of a tainted variable</p>
    <p>Comparisons of tainted variables in loops conditions</p>
    <p>Write to a persistent storage of a tainted variable</p>
  </div>
  <div class="page">
    <p>BootStomp: Sinks of Taint</p>
    <p>Memcpy-like functions</p>
    <p>Dereference of a tainted variable</p>
    <p>Comparisons of tainted variables in loops conditions</p>
    <p>Write to a persistent storage of a tainted variable</p>
  </div>
  <div class="page">
    <p>BootStomp: Taint Checking</p>
    <p>An alert is raised when a tainted variable:</p>
    <p>Reaches a memcpy-like function</p>
    <p>Gets dereferenced</p>
    <p>Can control the number of iterations of a loop</p>
    <p>Gets written to a persistent storage</p>
  </div>
  <div class="page">
    <p>BootStomp: Taint Checking</p>
    <p>An alert is raised when a tainted variable:</p>
    <p>Reaches a memcpy-like function</p>
    <p>Gets dereferenced</p>
    <p>Can control the number of iterations of a loop</p>
    <p>Gets written to a persistent storage</p>
    <p>A traceable output is produced</p>
  </div>
  <div class="page">
    <p>Limitation: Path Explosion Problem</p>
    <p>Limited function traversal</p>
  </div>
  <div class="page">
    <p>Limitation: Path Explosion Problem</p>
    <p>Limited function traversal</p>
    <p>Tainted arguments and call stack size &lt; threshold ?</p>
  </div>
  <div class="page">
    <p>Limitation: Path Explosion Problem</p>
    <p>Limited function traversal</p>
    <p>Tainted arguments and call stack size &lt; threshold ?</p>
    <p>Yes  step into</p>
    <p>No  step over</p>
  </div>
  <div class="page">
    <p>Limitation: Path Explosion Problem</p>
    <p>Limited function traversal</p>
    <p>Limited loop iterations</p>
  </div>
  <div class="page">
    <p>Limitation: Path Explosion Problem</p>
    <p>Limited function traversal</p>
    <p>Limited loop iterations</p>
    <p>Threshold used</p>
  </div>
  <div class="page">
    <p>Limitation: Path Explosion Problem</p>
    <p>Limited function traversal</p>
    <p>Limited loop iterations</p>
    <p>Timeout</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Booting Process</p>
    <p>Unlocking Mechanism</p>
    <p>BootStomp</p>
    <p>Evaluation</p>
    <p>Mitigations</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>BootStomp has been evaluated against 4 different</p>
    <p>bootloaders</p>
  </div>
  <div class="page">
    <p>Evaluation: Bugs</p>
    <p>Bootloader Total Alerts Bugs</p>
    <p>Qualcomm (Latest) 4 0</p>
    <p>Qualcomm (Old) 8 1 (already known)</p>
    <p>NVIDIA 7 1</p>
    <p>HiSilicon 17 5</p>
    <p>MediaTek -</p>
    <p>Total 36 7 (6 0days)</p>
    <p>(Further details in the paper)</p>
  </div>
  <div class="page">
    <p>Ok good, but how bad are them?</p>
  </div>
  <div class="page">
    <p>Evaluation: Bugs</p>
  </div>
  <div class="page">
    <p>Evaluation: Bugs</p>
  </div>
  <div class="page">
    <p>Evaluation: Bugs</p>
    <p>Great, but what can you do with it?</p>
  </div>
  <div class="page">
    <p>Evaluation: Bugs</p>
    <p>Great, but what can you do with it?</p>
    <p>A lot! Example: some bootloaders work in EL3</p>
  </div>
  <div class="page">
    <p>Evaluation: Unlocking Bypass</p>
    <p>Bootloader Writes to flash? Potentially vulnerable?</p>
    <p>Qualcomm (Latest) 6 YES*</p>
    <p>Qualcomm (Old) 4 YES*</p>
    <p>NVIDIA 9 NO</p>
    <p>HiSilicon 17 YES*</p>
    <p>MediaTek 1 NO</p>
    <p>(Yes means BootStomp found a write to a persistent storage)</p>
  </div>
  <div class="page">
    <p>Bootloader Unlocking Bypass memcpy(&amp;expected_digest, &amp;from_flash, 32);</p>
    <p>compute_sha(oem_key, input_len, &amp;key_digest); if (memcmp(&amp;key_digest, &amp;expected_digest, 32) ) {</p>
    <p>// Log the result return 1;</p>
    <p>}</p>
    <p>hash_func(&quot;bonaciao&quot;, &amp;key_digest, &amp;hash_output); if (write_to_flash(hash_output, 16) &amp; 0x80000000) ) {</p>
    <p>// Log the result return 0;</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Booting Process</p>
    <p>Unlocking Mechanism</p>
    <p>BootStomp</p>
    <p>Evaluation</p>
    <p>Mitigations</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Mitigations</p>
    <p>Google approach</p>
    <p>The key used to encrypt/decrypt user data contains the security state (locked/unlock)</p>
  </div>
  <div class="page">
    <p>Mitigations</p>
    <p>Google approach</p>
    <p>The key used to encrypt/decrypt user data contains the security state (locked/unlock)</p>
    <p>If the state changes, the key changes  users data cannot be decrypted</p>
  </div>
  <div class="page">
    <p>Mitigations</p>
    <p>Google approach</p>
    <p>The key used to encrypt/decrypt user data contains the security state (locked/unlock)</p>
    <p>If the state changes, the key changes  users data cannot be decrypted</p>
    <p>Our proposal</p>
    <p>Security state stored in the eMMCs Replay Protected Memory Block (RPMB)</p>
  </div>
  <div class="page">
    <p>Mitigations</p>
    <p>Google approach</p>
    <p>The key used to encrypt/decrypt user data contains the security state (locked/unlock)</p>
    <p>If the state changes, the key changes  users data cannot be decrypted</p>
    <p>Our proposal</p>
    <p>Security state stored in the eMMCs Replay Protected Memory Block (RPMB)</p>
    <p>Modify the trusted OS to allow only the bootloader to modify it</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Booting Process</p>
    <p>Unlocking Mechanism</p>
    <p>BootStomp</p>
    <p>Evaluation</p>
    <p>Mitigations</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Responsible Disclosure</p>
    <p>All bugs reported, acknowledged and already fixed</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>First study to explore Android bootloaders</p>
    <p>Automated technique to analyze bootloaders with traceable alerts</p>
    <p>Found 6 zero days in various bootloaders</p>
    <p>https://github.com/ucsb-seclab/bootstomp</p>
  </div>
  <div class="page">
    <p>Thats All</p>
    <p>Questions?</p>
  </div>
  <div class="page"/>
  <div class="page"/>
  <div class="page">
    <p>Buffer overflow // oem_get_info function</p>
    <p>oem_read(block, block_len); buf = malloc(block[0]); // size block</p>
    <p>// .. additional code .. number_or_blocks = block[1]; block_id = block[2];</p>
    <p>if (number_of_blocks == 1 || block_id == number_of_blocks) { return;</p>
    <p>}</p>
    <p>memcpy(buf + off, block[3], 0x300);</p>
  </div>
  <div class="page">
    <p>Buffer overflow // oem_get_info function</p>
    <p>oem_read(block, block_len); buf = malloc(block[0]); // size block</p>
    <p>// .. additional code .. number_or_blocks = block[1]; block_id = block[2];</p>
    <p>if (number_of_blocks == 1 || block_id == number_of_blocks) { return;</p>
    <p>}</p>
    <p>memcpy(buf + off, block[3], 0x300);</p>
  </div>
  <div class="page">
    <p>Buffer overflow // oem_get_info function</p>
    <p>oem_read(block, block_len); buf = malloc(block[0]); // size block</p>
    <p>// .. additional code .. number_or_blocks = block[1]; block_id = block[2];</p>
    <p>if (number_of_blocks == 1 || block_id == number_of_blocks) { return;</p>
    <p>}</p>
    <p>memcpy(buf + off, block[3], 0x300);</p>
  </div>
  <div class="page">
    <p>Buffer overflow // oem_get_info function</p>
    <p>oem_read(block, block_len); buf = malloc(block[0]); // size block</p>
    <p>// .. additional code .. number_or_blocks = block[1]; block_id = block[2];</p>
    <p>if (number_of_blocks == 1 || block_id == number_of_blocks) { return;</p>
    <p>}</p>
    <p>memcpy(buf + off, block[3], 0x300); // buffer overflow!</p>
  </div>
  <div class="page">
    <p>If the bootloader only loads the Android O.S., how can an</p>
    <p>attacker harm the device?</p>
  </div>
  <div class="page">
    <p>If the bootloader only loads the Android O.S., how can an</p>
    <p>attacker harm the device?</p>
    <p>Bootloaders are very diverse</p>
  </div>
  <div class="page">
    <p>BL33 in practice</p>
    <p>Qualcomm and NVIDIAs:</p>
    <p>BL33 conforms very closely to Googles Verified Boot guidelines,</p>
    <p>BL33 runs in EL1</p>
  </div>
  <div class="page">
    <p>BL33 in practice</p>
    <p>Qualcomm and NVIDIAs</p>
    <p>Huawei HiSilicon:</p>
    <p>BL33 is also responsible for initializing modem and peripherals</p>
    <p>BL33 runs in EL3.</p>
  </div>
  <div class="page">
    <p>BL33 in practice</p>
    <p>Qualcomm and NVIDIAs</p>
    <p>Huawei HiSilicon</p>
    <p>MediaTek:</p>
    <p>BL33 is also responsible for initializing modem</p>
    <p>BL33 runs in EL1</p>
  </div>
</Presentation>
