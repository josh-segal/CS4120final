<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Towards a Lightweight Model of BGP Safety</p>
    <p>Matvey Arye Princeton University</p>
    <p>Joint work with: Rob Harrison, Richard Wang, Jennifer Rexford (Princeton)</p>
    <p>Pamela Zave (AT&amp;T Research)</p>
  </div>
  <div class="page">
    <p>Internet is a network of networks  autonomous systems</p>
    <p>BGP is the routing protocol between ASs</p>
    <p>Why is BGP important</p>
  </div>
  <div class="page">
    <p>Each AS has a significant amount of freedom in choosing routes</p>
    <p>Node 1 may prefer the purple path over the orange path to node D</p>
    <p>AS Preferences in BGP</p>
    <p>DD</p>
  </div>
  <div class="page">
    <p>BGP Convergence</p>
    <p>An Instance is a topology and a set of AS preferences</p>
    <p>Some instances dont converge (called Gadgets)  BGPs routing protocol can oscillate.</p>
    <p>Finding gadgets is hard and has previously been done by hand</p>
    <p>We use lightweight modeling to automate gadget generation and analysis</p>
  </div>
  <div class="page">
    <p>Why Lightweight Model</p>
    <p>Formal modeling aids analysis  Requires rigorous definition of concepts</p>
    <p>Encoded in a way that is shareable between researchers</p>
    <p>Automates analysis</p>
    <p>Lightweight modeling is easier  Small model of key concepts  Easier to develop than machine-verified proofs  Push-button analysis</p>
  </div>
  <div class="page">
    <p>Stable Path Problem</p>
    <p>Useful Model  Although static formulation of the BGP, captures</p>
    <p>important properties:  SPP that is solvable is a prerequisite for BGP convergence  Although doesnt capture dynamic properties fully</p>
    <p>Extensively Studied  Used in proofs of a lot of previous work</p>
    <p>Our model of SPP (almost) as compact as original description</p>
    <p>Automatically finding gadgets hard in SPP</p>
  </div>
  <div class="page">
    <p>Alloy</p>
    <p>Wanted a tool to help us generate SPP gadgets</p>
    <p>Alloy is a declarative modeling language  Can test assertions on predicates</p>
    <p>Compiles to SAT problem  SAT solvers are fast (on a lot of cases)</p>
    <p>Given a set of predicates, 2 answers:  Satisfiable  Unsatisfiable &amp; Counterexample</p>
  </div>
  <div class="page">
    <p>Explore All Small SPP Instances</p>
    <p>Small instances are often informative  SPP gives each node a lot of degrees of freedom</p>
    <p>So properties of small instances are often interesting  And often generalize to larger ones</p>
    <p>Counterexamples to assertions really useful</p>
    <p>Explores full search space</p>
    <p>Can make generalized assertions  Although only up to a certain size</p>
  </div>
  <div class="page">
    <p>Contributions  Created lightweight model of SPP</p>
    <p>Model very compact, machine and human readable  Full model in the paper</p>
    <p>Automatically generated unstable SPP gadgets  Bad Gadget, Disagree, many more</p>
    <p>Classified gadgets  Full list of interesting gadgets under 4 source nodes</p>
    <p>Verified new and known solvability predicates  Absence of dispute wheel implies solvability</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Review of SPP and Model</p>
    <p>Use 1: Gadget Generation</p>
    <p>Use 2: Test Known Solvability Predicates</p>
    <p>Discuss Future Work</p>
  </div>
  <div class="page">
    <p>SPP Topology</p>
    <p>DD</p>
    <p>Source Node</p>
    <p>Destination Node</p>
  </div>
  <div class="page">
    <p>SPP Permitted Paths</p>
    <p>DD</p>
    <p>List of Permitted</p>
    <p>Paths</p>
  </div>
  <div class="page">
    <p>Representation In Alloy</p>
    <p>DstNode, SrcNode: Node</p>
    <p>Path: Sequence of Nodes  Sequence is an ordered list</p>
    <p>SrcNode.PermittedPaths: Sequence of Paths  First path in list most preferred</p>
  </div>
  <div class="page">
    <p>Ensure Valid Topology with Facts</p>
    <p>Facts define correctness of construction  Assertions only run on correct constructions</p>
    <p>Example: ValidNonEmptyPath  Sequence has at least one element  No node appears more than once  Last node is DstNode</p>
    <p>Many more</p>
  </div>
  <div class="page">
    <p>SPP Selection</p>
    <p>DD</p>
    <p>Each node selects exactly one path</p>
  </div>
  <div class="page">
    <p>SPP Solution</p>
    <p>DD</p>
    <p>All nodes happy with their selection simultaneously</p>
  </div>
  <div class="page">
    <p>Individual Happiness (within constraints)</p>
    <p>Solution  Each node has selected the best of its choices.</p>
    <p>Why?  No node can pick a better choice.</p>
    <p>Pred SelectionIsSolution[selected] {</p>
    <p>let choices = GetChoices[selected] | selected = GetBest[choices] }</p>
  </div>
  <div class="page">
    <p>Constraint Dependencies</p>
    <p>Choices Node 1 Choices Node 1</p>
    <p>Selection Node 2</p>
    <p>Selection Node 2</p>
    <p>Selection Node 1</p>
    <p>Selection Node 1</p>
    <p>Choices Node 2 Choices Node 2</p>
  </div>
  <div class="page">
    <p>SPP as a Model</p>
    <p>Each SPP instance has 0, 1, or 1+ solutions  Having exactly 1 solution is necessary but not</p>
    <p>sufficient for safety.</p>
    <p>All InstancesAll Instances</p>
    <p>SafetySafety</p>
  </div>
  <div class="page">
    <p>Specify Solvability Predicate</p>
    <p>Logically, Pred OneSolvable: one selection where SelectionIsSolution Pred MultiSolvable: some selection where SelectionIsSolution</p>
    <p>Aside:  Selection is a set</p>
    <p>Quantifying over it requires 2nd order logic  Hard-code quantifications on a set-size basis for 1st order</p>
  </div>
  <div class="page">
    <p>No Solution (Bad Gadget)</p>
    <p>DD</p>
  </div>
  <div class="page">
    <p>Two Solutions (Disagree)</p>
    <p>DD</p>
  </div>
  <div class="page">
    <p>Analysis Using the Model</p>
    <p>We know all instances are one solvable is incorrect =&gt; We use Alloy to give us example instances</p>
    <p>where predicate fails.</p>
    <p>Use model to test solvability predicates  absence of dispute wheel implies one solvable</p>
  </div>
  <div class="page">
    <p>Use 1: Generating Counterexamples</p>
    <p>Have Alloy Generate Counter Examples  Gadgets with no (multiple) solutions  Too Many (10000+ for 4 source nodes)</p>
    <p>Want Interesting Counterexamples</p>
  </div>
  <div class="page">
    <p>Interesting Gadget</p>
    <p>DD</p>
  </div>
  <div class="page">
    <p>Uninteresting Gadget</p>
    <p>DD</p>
  </div>
  <div class="page">
    <p>Gadget Generation</p>
    <p>Intuitively, small gadgets are most interesting</p>
    <p>Start small  Find all gadgets for size</p>
    <p>Size++</p>
    <p>When analyzing bigger gadgets, exclude gadgets similar to those already found</p>
  </div>
  <div class="page">
    <p>Gadget Library</p>
    <p>pred Gadget123{ }</p>
    <p>Predicate detects gadgets similar to the gadget found  Makes path rankings relative  Corrects for isomorphic reordering of node #s</p>
    <p>Eliminate gadgets matching library predicates in future</p>
  </div>
  <div class="page">
    <p>Gadgets Found</p>
    <p>! !</p>
    <p>!&quot;#$$%&quot;#%&amp;'</p>
    <p>&quot; #</p>
    <p>$</p>
    <p>()* (*</p>
    <p>+(* +*</p>
    <p>% )+* )*</p>
    <p>&quot; # (,* (*</p>
    <p>+)(* +*</p>
    <p>% )(*</p>
    <p>&amp; ,+* ,*</p>
    <p>&quot; # (,)* ()*</p>
    <p>+()* +*</p>
    <p>% )*</p>
    <p>&amp; ,+* ,)*</p>
    <p>&quot; # (,)* ()*</p>
    <p>+()* +)*</p>
    <p>% )*</p>
    <p>&amp; ,+)* ,)*</p>
    <p>&quot; # ()* (*</p>
    <p>+(* +,*</p>
    <p>% )+,* )* &amp;</p>
    <p>,*</p>
    <p>$ $ $ $</p>
    <p>&quot; #</p>
    <p>$</p>
    <p>(+* (*</p>
    <p>+(* +*</p>
    <p>#-.&quot;%/ &amp;&amp;</p>
    <p>&quot; #</p>
    <p>$</p>
    <p>(+* (*</p>
    <p>+)(* +*</p>
    <p>% )(*</p>
    <p>&quot; #</p>
    <p>$</p>
    <p>(+* ()*</p>
    <p>+()* +*</p>
    <p>% )*</p>
    <p>&quot; #</p>
    <p>$</p>
    <p>(+)* ()*</p>
    <p>+()* +)*</p>
    <p>% )*</p>
    <p>(),* (*</p>
    <p>+(*</p>
    <p>),* ,+(* ,*</p>
    <p>&quot; #</p>
    <p>$</p>
    <p>()+* (,*</p>
    <p>+(,* +*</p>
    <p>% )+*</p>
    <p>&amp; ,*</p>
    <p>&quot; #(* +*</p>
    <p>% ),+* )(* &amp;</p>
    <p>,)(* ,+*</p>
    <p>&quot; #</p>
    <p>$</p>
    <p>% &amp;</p>
    <p>$</p>
    <p>&quot; # ()* (*</p>
    <p>+,* +*</p>
    <p>% )+* )* &amp;</p>
    <p>,(* ,*</p>
    <p>$</p>
    <p>'()!* +,- ./ (0.1!2 (3415,</p>
    <p>'0)!6 7.589.: !; -./ (0.1!2 (3415,</p>
    <p>! !</p>
    <p>!&quot;#$$%&quot;#%&amp;'</p>
    <p>&quot; #</p>
    <p>$</p>
    <p>()* (*</p>
    <p>+(* +*</p>
    <p>% )+* )*</p>
    <p>&quot; # (,* (*</p>
    <p>+)(* +*</p>
    <p>% )(*</p>
    <p>&amp; ,+* ,*</p>
    <p>&quot; # (,)* ()*</p>
    <p>+()* +*</p>
    <p>% )*</p>
    <p>&amp; ,+* ,)*</p>
    <p>&quot; # (,)* ()*</p>
    <p>+()* +)*</p>
    <p>% )*</p>
    <p>&amp; ,+)* ,)*</p>
    <p>&quot; # ()* (*</p>
    <p>+(* +,*</p>
    <p>% )+,* )* &amp;</p>
    <p>,*</p>
    <p>$ $ $ $</p>
    <p>&quot; #</p>
    <p>$</p>
    <p>(+* (*</p>
    <p>+(* +*</p>
    <p>#-.&quot;%/ &amp;&amp;</p>
    <p>&quot; #</p>
    <p>$</p>
    <p>(+* (*</p>
    <p>+)(* +*</p>
    <p>% )(*</p>
    <p>&quot; #</p>
    <p>$</p>
    <p>(+* ()*</p>
    <p>+()* +*</p>
    <p>% )*</p>
    <p>&quot; #</p>
    <p>$</p>
    <p>(+)* ()*</p>
    <p>+()* +)*</p>
    <p>% )*</p>
    <p>(),* (*</p>
    <p>+(*</p>
    <p>),* ,+(* ,*</p>
    <p>&quot; #</p>
    <p>$</p>
    <p>()+* (,*</p>
    <p>+(,* +*</p>
    <p>% )+*</p>
    <p>&amp; ,*</p>
    <p>&quot; #(* +*</p>
    <p>% ),+* )(* &amp;</p>
    <p>,)(* ,+*</p>
    <p>&quot; #</p>
    <p>$</p>
    <p>% &amp;</p>
    <p>$</p>
    <p>&quot; # ()* (*</p>
    <p>+,* +*</p>
    <p>% )+* )* &amp;</p>
    <p>,(* ,*</p>
    <p>$</p>
    <p>'()!* +,- ./ (0.1!2 (3415,</p>
    <p>'0)!6 7.589.: !; -./ (0.1!2 (3415,</p>
    <p>Unsolvable Gadgets</p>
    <p>Multiply Solvable Gadgets</p>
  </div>
  <div class="page">
    <p>Use 2: Evaluating Constraints</p>
    <p>Test Known Constraints</p>
    <p>Example: Create predicates for the dispute wheel  Verify absence of a DW implies solvability  Get instances that have a DW but are still solvable</p>
    <p>Quickly explore new conditions for solvability  See if they are sufficient or necessary  Get counterexamples of how they dont fully capture</p>
    <p>solvability</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Created a lightweight model of BGP</p>
    <p>Used model to generate gadgets</p>
    <p>Used iterative elimination to get minimal set of interesting gadgets</p>
    <p>Model could be used for quick push button analysis of new constraints</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Develop new solvability predicates and model existing ones</p>
    <p>Apply the model to checking BGP router configurations for solvability</p>
    <p>Model the dynamic SPVP</p>
  </div>
  <div class="page">
    <p>Thanks</p>
  </div>
</Presentation>
