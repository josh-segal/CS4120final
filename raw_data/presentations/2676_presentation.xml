<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Universal Packet Scheduling</p>
    <p>Radhika Mittal, Rachit Agarwal, Sylvia Ratnasamy, Scott Shenker</p>
    <p>UC Berkeley</p>
  </div>
  <div class="page">
    <p>Many different algorithms  FIFO, FQ, virtual clocks, priorities</p>
    <p>Many different goals  fairness, small packet delay, small FCT</p>
    <p>Many different contexts  WAN, datacenters, cellular</p>
    <p>Many Scheduling Algorithms</p>
  </div>
  <div class="page">
    <p>Implemented in router hardware.</p>
    <p>How do we support different scheduling algorithms for different requirements?  Option 1: Change router hardware for each new algorithm  Option 2: Implement all scheduling algorithms in hardware  Option 3: Programmable scheduling hardware*</p>
    <p>Many Scheduling Algorithms</p>
    <p>*Towards Programmable Packet Scheduling, Sivaraman et. al., HotNets 2015</p>
  </div>
  <div class="page">
    <p>Implemented in router hardware.</p>
    <p>How do we support different scheduling algorithms for different requirements?  Option 1: Change router hardware for each new algorithm  Option 2: Implement all scheduling algorithms in hardware  Option 3: Programmable scheduling hardware*</p>
    <p>Many Scheduling Algorithms</p>
    <p>*Towards Programmable Packet Scheduling, Sivaraman et. al., HotNets 2015</p>
  </div>
  <div class="page">
    <p>Implemented in router hardware.</p>
    <p>How do we support different scheduling algorithms for different requirements?  Option 1: Change router hardware for each new algorithm  Option 2: Implement all scheduling algorithms in hardware  Option 3: Programmable scheduling hardware*</p>
    <p>Many Scheduling Algorithms</p>
    <p>*Towards Programmable Packet Scheduling, Sivaraman et. al., HotNets 2015</p>
  </div>
  <div class="page">
    <p>Implemented in router hardware.</p>
    <p>How do we support different scheduling algorithms for different requirements?  Option 1: Change router hardware for each new algorithm  Option 2: Implement all scheduling algorithms in hardware  Option 3: Programmable scheduling hardware*</p>
    <p>Many Scheduling Algorithms</p>
    <p>*Towards Programmable Packet Scheduling, Sivaraman et. al., HotNets 2015</p>
  </div>
  <div class="page">
    <p>Is there a universal packet scheduling algorithm?</p>
    <p>We are asking a new question..</p>
    <p>How do we support different scheduling algorithms for different requirements?</p>
  </div>
  <div class="page">
    <p>UPS: Universal Packet Scheduling Algorithm</p>
    <p>A single scheduling algorithm that can imitate the network-wide output</p>
    <p>produced by any other algorithm.</p>
  </div>
  <div class="page">
    <p>How can a single algorithm imitate all</p>
    <p>others?</p>
  </div>
  <div class="page">
    <p>Network Model</p>
    <p>Input Traffic</p>
    <p>INGRESS</p>
    <p>CORE NETWORK</p>
  </div>
  <div class="page">
    <p>Scheduling Algorithm</p>
    <p>Network Model</p>
    <p>Input Traffic</p>
    <p>INGRESS</p>
    <p>CORE NETWORK</p>
  </div>
  <div class="page">
    <p>Network Model</p>
    <p>INGRESS</p>
    <p>Input Traffic</p>
    <p>(Optional) Header</p>
    <p>Initialization</p>
    <p>Scheduling Algorithm</p>
    <p>Output Traffic</p>
    <p>CORE NETWORK EGRESS</p>
  </div>
  <div class="page">
    <p>Network Model</p>
    <p>INGRESS</p>
    <p>Input Traffic</p>
    <p>(Optional) Header</p>
    <p>Initialization</p>
    <p>Scheduling Algorithm</p>
    <p>Output Traffic</p>
    <p>CORE NETWORK EGRESS</p>
    <p>Output Traffic tied to Scheduling Algorithm</p>
  </div>
  <div class="page">
    <p>Network Model</p>
    <p>INGRESS</p>
    <p>Input Traffic</p>
    <p>(Optional) Header</p>
    <p>Initialization</p>
    <p>Priority Scheduling</p>
    <p>Output Traffic</p>
    <p>CORE NETWORK EGRESS</p>
    <p>Goal: Minimize Mean FCT</p>
    <p>Priority Value</p>
    <p>Flow Size</p>
  </div>
  <div class="page">
    <p>Network Model</p>
    <p>INGRESS</p>
    <p>Input Traffic</p>
    <p>(Optional) Header</p>
    <p>Initialization FQ Output Traffic</p>
    <p>CORE NETWORK EGRESS</p>
    <p>Goal: Fairness</p>
  </div>
  <div class="page">
    <p>Network Model</p>
    <p>INGRESS</p>
    <p>Input Traffic</p>
    <p>(Optional) Header</p>
    <p>Initialization WFQ Output Traffic</p>
    <p>CORE NETWORK EGRESS</p>
    <p>Goal: Weighted Fairness</p>
    <p>Flow Weights</p>
  </div>
  <div class="page">
    <p>Network Model</p>
    <p>* Uses packet header state to make scheduling decisions</p>
    <p>INGRESS</p>
    <p>Input Traffic</p>
    <p>Header Initialization</p>
    <p>Scheduling Algorithm*</p>
    <p>Output Traffic</p>
    <p>CORE NETWORK EGRESS</p>
    <p>Output Traffic tied to Header Initialization</p>
    <p>Header Initialization</p>
  </div>
  <div class="page">
    <p>Network Model</p>
    <p>INGRESS</p>
    <p>Input Traffic</p>
    <p>Smart Header</p>
    <p>Initialization UPS? Output Traffic</p>
    <p>CORE NETWORK EGRESS</p>
    <p>Header Initialization</p>
  </div>
  <div class="page">
    <p>How do we formally define and evaluate</p>
    <p>a UPS?</p>
  </div>
  <div class="page">
    <p>Defining a UPS</p>
    <p>Theoretical Viewpoint: Can it replay a given schedule?</p>
    <p>Practical Viewpoint:</p>
    <p>Can it achieve a given objective?</p>
  </div>
  <div class="page">
    <p>Theoretical Viewpoint Can it replay a given schedule?</p>
  </div>
  <div class="page">
    <p>Original Schedule</p>
    <p>Input Traffic</p>
    <p>(Optional) Header</p>
    <p>Initialization</p>
    <p>INGRESS CORE NETWORK</p>
    <p>Arbitrary Scheduling Algorithm</p>
    <p>Output Times</p>
    <p>o(p) for a packet p EGRESS</p>
    <p>Only requirement from original schedule: Output Times are viable</p>
  </div>
  <div class="page">
    <p>Replaying the Schedule, given o(p)</p>
    <p>Input Traffic</p>
    <p>Header Initialization (using o(p))</p>
    <p>INGRESS CORE NETWORK</p>
    <p>Output Times</p>
    <p>o(p) for a packet p EGRESS</p>
    <p>For every packet p, o(p)  o(p)</p>
    <p>UPS Header</p>
    <p>Initialization</p>
  </div>
  <div class="page">
    <p>Pragmatic Constraints on a UPS</p>
    <p>Input Traffic</p>
    <p>Output Times Header</p>
    <p>Initialization (using o(p)) o(p) for a packet p</p>
    <p>Obliviousness: For initializing ps header, use only o(p) and path(p)</p>
    <p>INGRESS CORE NETWORK EGRESS</p>
    <p>UPS Header</p>
    <p>Initialization</p>
  </div>
  <div class="page">
    <p>Pragmatic Constraints on a UPS</p>
    <p>Input Traffic</p>
    <p>Output Times Header</p>
    <p>Initialization (using o(p)) o(p) for a packet p</p>
    <p>Obliviousness: For initializing ps header, use only o(p) and path(p)</p>
    <p>INGRESS CORE NETWORK EGRESS</p>
    <p>UPS Header</p>
    <p>Initialization</p>
  </div>
  <div class="page">
    <p>Pragmatic Constraints on a UPS</p>
    <p>Input Traffic</p>
    <p>Output Times</p>
    <p>o(p) for a packet p</p>
    <p>Obliviousness: For initializing ps header, use only o(p) and path(p)</p>
    <p>INGRESS CORE NETWORK EGRESS</p>
    <p>UPS Header</p>
    <p>Initialization (using o(p))</p>
    <p>Header Initialization</p>
  </div>
  <div class="page">
    <p>Pragmatic Constraints on a UPS</p>
    <p>Input Traffic</p>
    <p>Output Times</p>
    <p>o(p) for a packet p</p>
    <p>Obliviousness: For initializing ps header, use only o(p) and path(p)</p>
    <p>INGRESS CORE NETWORK EGRESS</p>
    <p>UPS Header</p>
    <p>Initialization (using o(p))</p>
    <p>Header Initialization</p>
  </div>
  <div class="page">
    <p>Pragmatic Constraints on a UPS</p>
    <p>Input Traffic</p>
    <p>Output Times</p>
    <p>o(p) for a packet p</p>
    <p>Obliviousness: For initializing ps header, use only o(p) and path(p)</p>
    <p>Limited State: Scheduling can use only header state and static information</p>
    <p>INGRESS CORE NETWORK EGRESS</p>
    <p>UPS Header</p>
    <p>Initialization (using o(p))</p>
    <p>Header Initialization</p>
  </div>
  <div class="page">
    <p>Pragmatic Constraints on a UPS</p>
    <p>Input Traffic</p>
    <p>Output Times</p>
    <p>o(p) for a packet p</p>
    <p>Obliviousness: For initializing ps header, use only o(p) and path(p)</p>
    <p>Limited State: Scheduling can use only header state and static information</p>
    <p>INGRESS CORE NETWORK EGRESS</p>
    <p>UPS Header</p>
    <p>Initialization (using o(p))</p>
    <p>Header Initialization</p>
  </div>
  <div class="page">
    <p>We call this Blackbox Initialization</p>
    <p>Input Traffic</p>
    <p>Output Times</p>
    <p>o(p) for a packet p</p>
    <p>Limited State: Scheduling can use only header state and static information</p>
    <p>INGRESS CORE NETWORK EGRESS</p>
    <p>Obliviousness: For initializing ps header, use only o(p) and path(p)</p>
    <p>UPS Header</p>
    <p>Initialization (using o(p))</p>
    <p>Header Initialization</p>
  </div>
  <div class="page">
    <p>Basic Existence and Non-existence Results</p>
    <p>There exists a UPS under Omniscient Initialization when scheduling time at every hop is known</p>
    <p>No UPS exists under Blackbox Initialization when only the final output time is known</p>
    <p>See paper for proofs.</p>
  </div>
  <div class="page">
    <p>How close can we get to a UPS?</p>
  </div>
  <div class="page">
    <p>Key Result: Depends on congestion points</p>
    <p>No. of Congestion Points per Packet</p>
    <p>General</p>
    <p>See paper for proofs.</p>
  </div>
  <div class="page">
    <p>Can we achieve this upper bound?</p>
    <p>Yes, LSTF!</p>
  </div>
  <div class="page">
    <p>Can we achieve this upper bound?</p>
    <p>Yes, LSTF!</p>
  </div>
  <div class="page">
    <p>Least Slack Time First</p>
    <p>Packet header initialized with a slack value  slack = maximum tolerable queuing delay</p>
    <p>At the routers  Schedule packet with least slack time first  Update the slack by subtracting the wait time</p>
  </div>
  <div class="page">
    <p>Key Results</p>
    <p>No. of Congestion Points per Packet</p>
    <p>General LSTF</p>
    <p>See paper for proofs.</p>
  </div>
  <div class="page">
    <p>Not all algorithms achieve upper bound</p>
    <p>No. of Congestion Points per Packet</p>
    <p>General LSTF Priorities</p>
    <p>See paper for proofs.</p>
  </div>
  <div class="page">
    <p>How well does LSTF perform empirically?</p>
  </div>
  <div class="page">
    <p>Empirically, LSTF is (almost) universal</p>
    <p>ns-2 simulation results on realistic network settings</p>
    <p>- Less than 3% packets missed their output times</p>
    <p>- Less than 0.1% packets are late by more than one transmission time</p>
  </div>
  <div class="page">
    <p>Summarizing the theoretical viewpoint</p>
    <p>Evaluate the ability to replay a schedule, given its final output times</p>
    <p>Analytical Results: - No UPS exists - LSTF comes as close to a UPS as possible</p>
    <p>Empirical Results: LSTF is almost universal!</p>
  </div>
  <div class="page">
    <p>Practical Viewpoint Can it achieve a given objective?</p>
  </div>
  <div class="page">
    <p>Achieving various network objectives</p>
    <p>Slack assignment based on heuristics</p>
    <p>Comparison with state-of-the-art</p>
    <p>Three objective functions - Tail packet delays - Mean Flow Completion Time - Fairness</p>
  </div>
  <div class="page">
    <p>Tail Packet Delays</p>
    <p>Slack Assignment: Same slack for all packets</p>
    <p>State-of-the-art: FIFO, FIFO+</p>
    <p>Results:  Identical to FIFO+.  Smaller tail packet delays compared to FIFO.</p>
  </div>
  <div class="page">
    <p>Mean Flow Completion Time</p>
    <p>Slack Assignment: Proportional to flow size</p>
    <p>State-of-the-art: SJF, SRPT</p>
    <p>Results:  Mean FCTs comparable to both SJF and SRPT.</p>
  </div>
  <div class="page">
    <p>Fairness Slack Assignment: Inspired by Virtual Clocks slack(p0) = 0</p>
    <p>slack(pi) = max(0, slack(pi-1) + (1/rest)  (i(pi)  i(pi-1)) rest = Estimate of fair share rate</p>
    <p>State-of-the-art: Fair Queuing (FQ)</p>
    <p>Results:  Eventual convergence to fairness for long-lived flows.  FCTs roughly comparable to FQ for short-lived flows.  Higher sensitivity to fair share rate estimate (rest)</p>
  </div>
  <div class="page">
    <p>Active Queue Management (AQM)</p>
    <p>Routers sends feedback in the form of dropping or marking appropriate packets.</p>
    <p>LSTF facilitates AQM from the edge:  It does not matter where the packets are dropped or</p>
    <p>marked.  Used slack value can be used for deciding which packets</p>
    <p>are to be dropped or marked.</p>
    <p>Performs comparable to FQ-CoDel and DCTCP (ECN).</p>
  </div>
  <div class="page">
    <p>Results Summary</p>
    <p>Theoretical results show that - There is no UPS under blackbox initialization - LSTF comes as close to a UPS as possible - Empirically, LSTF is very close</p>
    <p>LSTF can be used in practice to achieve a variety of network-wide objectives.</p>
  </div>
  <div class="page">
    <p>Implication</p>
    <p>Less need for many different scheduling and queue management algorithms.</p>
    <p>Can just use LSTF, with varying initializations.</p>
  </div>
  <div class="page">
    <p>There are still a bunch of</p>
    <p>open questions!</p>
  </div>
  <div class="page">
    <p>Open Questions What is the least amount of information needed to achieve universality?</p>
    <p>Are there tractable bounds for the degree of lateness with LSTF?</p>
    <p>How do we achieve multiple objectives simultaneously?</p>
    <p>What is the class of objectives that can be achieved with LSTF in practice?</p>
  </div>
  <div class="page">
    <p>Conclusion  Theoretical results show that - There is no UPS under blackbox initialization. - LSTF comes as close to a UPS as possible. - Empirically, LSTF is very close.</p>
    <p>LSTF can be used in practice to achieve a variety of network-wide objectives.</p>
    <p>Contact: radhika@eecs.berkeley.edu</p>
    <p>Code: http://netsys.github.io/ups/</p>
    <p>Thank You!</p>
  </div>
</Presentation>
