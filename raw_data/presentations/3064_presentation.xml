<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Sledgehammer: Cluster-Fueled Debugging</p>
    <p>Andrew Quinn, Jason Flinn, and Michael Cafarella</p>
  </div>
  <div class="page">
    <p>What was your most challenging bug?</p>
    <p>Debugging</p>
  </div>
  <div class="page">
    <p>Tracing Tools</p>
    <p>[1] Where is the Bug and How Is It Fixed? An Experiment with Practitioners (FSE 17) [2] Characterizing Logging Practices in Open-Source Software (ICSE 12)</p>
    <p>Source Code Invariant</p>
    <p>Log</p>
    <p>Inject logic into software to track program state [1][2]  Re-create failing execution and analyze tracing output</p>
    <p>Inject</p>
    <p>Execute</p>
    <p>Analyze Result</p>
    <p>Tracing output</p>
  </div>
  <div class="page">
    <p>Tracing Tools  Tradeoff between amount of tracing and overhead</p>
    <p>Amount of Tracing</p>
    <p>Tr ac</p>
    <p>in g</p>
    <p>O ve</p>
    <p>rh ea</p>
    <p>d</p>
    <p>Simple Bugs Challenging Bugs</p>
    <p>Low Overhead</p>
    <p>High Overhead</p>
  </div>
  <div class="page">
    <p>Tracing Tools  Tradeoff between amount of tracing and overhead</p>
    <p>Amount of Tracing</p>
    <p>Tr ac</p>
    <p>in g</p>
    <p>O ve</p>
    <p>rh ea</p>
    <p>d</p>
    <p>Simple Bugs Challenging Bugs</p>
    <p>Low Overhead</p>
    <p>High Overhead</p>
  </div>
  <div class="page">
    <p>Cluster-Fueled Debugging  Accelerate complex debugging queries  Shared cluster =&gt; on-demand debugging tool</p>
  </div>
  <div class="page">
    <p>Tracing Tools</p>
    <p>Analyzer</p>
    <p>AnalysisOutput</p>
    <p>Tracing Tracing</p>
    <p>Execution</p>
    <p>But, the work of these tools are sequential!</p>
    <p>? ?</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>Sledgehammer</p>
    <p>Analyzer</p>
    <p>AnalysisOutput</p>
    <p>Tracing</p>
    <p>Execution</p>
    <p>Tracing Tracing</p>
    <p>Analyzer Analyzer</p>
    <p>Tracing</p>
    <p>Replay-Based: queries run over past execution</p>
  </div>
  <div class="page">
    <p>Sledgehammer</p>
    <p>Analyzer</p>
    <p>AnalysisOutput</p>
    <p>Tracing</p>
    <p>Execution</p>
    <p>Tracing Tracing</p>
    <p>Analyzer Analyzer</p>
    <p>Tool Scales to 1024 cores (speedup 416x)</p>
    <p>Replay-Based: queries run over past execution</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Debugging Scenario  Parallelizing a Query  Evaluation</p>
  </div>
  <div class="page">
    <p>Whats the root cause? What line of code?</p>
    <p>Scenario - memcached</p>
    <p>corrupt cache</p>
    <p>Developer</p>
  </div>
  <div class="page">
    <p>Scenario  Todays Tools</p>
    <p>corrupt cache</p>
    <p>//walk cache data-structure Char *checkCache ();</p>
    <p>// find invalidion points: void invalidInsts(int fd, int out);</p>
    <p>Analyzers</p>
    <p>checkCache();</p>
    <p>Instrumentation</p>
    <p>Tracing</p>
    <p>Developer</p>
  </div>
  <div class="page">
    <p>Scenario  Todays Tools</p>
    <p>corrupt cache</p>
    <p>//walk cache data-structure Char *checkCache ();</p>
    <p>// find invalidion points: void invalidInsts(int fd, int out);</p>
    <p>Analyzers</p>
    <p>checkCache();</p>
    <p>Instrumentation</p>
    <p>Tracing</p>
    <p>Developer</p>
    <p>Amount of Tracing</p>
    <p>Tr ac</p>
    <p>in g</p>
    <p>O ve</p>
    <p>rh ea</p>
    <p>d</p>
    <p>Acceptable Overhead</p>
    <p>Limited Tracing Full Tracing</p>
    <p>Infeasible Overhead</p>
    <p>Continuous Function</p>
    <p>Evaluation</p>
  </div>
  <div class="page">
    <p>Scenario - Sledgehammer</p>
    <p>corrupt cache</p>
    <p>//walk cache data-structure Char *checkCache ();</p>
    <p>// find invalidion points: void invalidInsts(int fd, int out);</p>
    <p>Analyzers</p>
    <p>SH_Cont(checkCache)</p>
    <p>Annotations</p>
    <p>Tracing</p>
    <p>(New Debugging Tool) Continuous Function</p>
    <p>Evaluation: execute tracing after</p>
    <p>each instruction</p>
    <p>SledgehammerDeveloper</p>
    <p>CFE Log: inst1, valid</p>
    <p>inst2, invalid</p>
  </div>
  <div class="page">
    <p>Scenario - Sledgehammer</p>
    <p>corrupt cache</p>
    <p>//walk cache data-structure Char *checkCache ();</p>
    <p>// find invalidion points: void invalidInsts(int fd, int out);</p>
    <p>Analyzers</p>
    <p>SH_Cont(checkCache)</p>
    <p>Annotations</p>
    <p>Tracing</p>
    <p>(New Debugging Tool) Continuous Function</p>
    <p>Evaluation: execute tracing after</p>
    <p>each instruction</p>
    <p>SledgehammerDeveloper</p>
    <p>CFE Log: inst1, valid</p>
    <p>inst2, invalid</p>
    <p>inst1 inst2</p>
  </div>
  <div class="page">
    <p>Scenario - Sledgehammer</p>
    <p>corrupt cache</p>
    <p>//walk cache data-structure Char *checkCache ();</p>
    <p>// find invalidion points: void invalidInsts(int fd, int out);</p>
    <p>Analyzers</p>
    <p>SH_Cont(checkCache)</p>
    <p>Annotations</p>
    <p>Tracing</p>
    <p>(New Debugging Tool) Continuous Function</p>
    <p>Evaluation: execute tracing after</p>
    <p>each instruction</p>
    <p>SledgehammerDeveloper</p>
    <p>CFE Log: inst1, valid</p>
    <p>inst2, invalid</p>
    <p>inst1 inst2</p>
    <p>Does the lock protect the cache?</p>
  </div>
  <div class="page">
    <p>Scenario - memcached</p>
    <p>corrupt cache</p>
    <p>//walk cache data-structure Char *checkCache (); void lockAcquire(mutex *m); void lockRelease(mutex *m);</p>
    <p>// find invalid and unlocked: void badUpdate(int fd, int out);</p>
    <p>Analyzers</p>
    <p>SH_Cont(checkCache) SH_Hook(lock, lockAcquire) SH_Hook(unlock, lockRelease)</p>
    <p>Annotations</p>
    <p>Tracing</p>
    <p>(New Debugging Tool) Continuous Function</p>
    <p>Evaluation: Track tracing output</p>
    <p>after every instruction</p>
    <p>(Cutting-edge Tool) Retro-Logging:</p>
    <p>Inject new logging into past execution</p>
    <p>SledgehammerDeveloper</p>
    <p>Introvirt SOSP 05</p>
  </div>
  <div class="page">
    <p>Scenario - Sledgehammer</p>
    <p>corrupt cache</p>
    <p>//walk cache data-structure Char *checkCache (); void lockAcquire(mutex *m); void lockRelease(mutex *m);</p>
    <p>// find invalid and unlocked: void badUpdate(int fd, int out);</p>
    <p>Analyzers</p>
    <p>SH_Cont(checkCache) SH_Hook(lock, lockAcquire) SH_Hook(unlock, lockRelease)</p>
    <p>Annotations</p>
    <p>Tracing</p>
    <p>(New Debugging Tool) Continuous Function</p>
    <p>Evaluation: Track tracing output</p>
    <p>after every instruction</p>
    <p>(Cutting-edge Tool) Retro-Logging:</p>
    <p>Inject new logging into past execution</p>
    <p>SledgehammerDeveloper</p>
    <p>Inst1 (initialization) Inst2 (BUG)</p>
    <p>Introvirt SOSP 05</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Parallelizing a Query  Evaluation</p>
  </div>
  <div class="page">
    <p>Parallelizing a Query</p>
    <p>Analyzer</p>
    <p>AnalysisOutput</p>
    <p>Execution</p>
    <p>TracingTracing Tracing TracingTracingTracing</p>
    <p>Tracing</p>
    <p>Epoch parallelism  leverage deterministic replay</p>
    <p>Doubleplay (ASPLOS 12)</p>
  </div>
  <div class="page">
    <p>TracingTracing</p>
    <p>Parallelizing a Query</p>
    <p>Analyzer</p>
    <p>AnalysisOutput</p>
    <p>Execution</p>
    <p>Unconstrained tracing code causes divergences</p>
    <p>Tracing Tracing</p>
    <p>Crash or corrupt output!</p>
  </div>
  <div class="page">
    <p>Tracing Isolation</p>
    <p>Heavyweight Lightweight</p>
    <p>Poor Scalability Pin / Valgrind</p>
    <p>Good Scalability</p>
    <p>Checkpointing (Introvirt SOSP 05)</p>
    <p>Compiler-based Isolation</p>
    <p>Prevent tracing code from updating replay state  Requires scalability and lightweight technique</p>
  </div>
  <div class="page">
    <p>Compiler-based Isolation  Instrument tracing code to log updates  Revert updates using log</p>
    <p>Undo-log Write Write</p>
    <p>WriteWrite</p>
  </div>
  <div class="page">
    <p>Compiler-based Isolation  Instrument tracing code to log updates  Revert updates using log</p>
    <p>Undo-log Write WriteScalable and Lightweight!</p>
  </div>
  <div class="page">
    <p>Parallelizing a query</p>
    <p>Analyzer</p>
    <p>AnalysisOutput</p>
    <p>Tracing</p>
    <p>Execution</p>
    <p>Multi-tiered approach to parallelize analysis</p>
    <p>Tracing Tracing</p>
    <p>Tracing</p>
  </div>
  <div class="page">
    <p>Parallelizing a query</p>
    <p>Analyzer</p>
    <p>AnalysisOutput</p>
    <p>Tracing</p>
    <p>Execution</p>
    <p>Multi-tiered approach to parallelize analysis</p>
    <p>Tracing Tracing</p>
    <p>Analyzer Analyzer</p>
    <p>Tracing</p>
  </div>
  <div class="page">
    <p>Analysis</p>
    <p>Tree</p>
    <p>Developers construct  Local runs on each core in parallel  Stream passes information over chain  Tree combines input from multiple analyzers</p>
    <p>Local Local Local</p>
    <p>Stream StreamStream</p>
    <p>Output</p>
    <p>Tracing Tracing Tracing</p>
  </div>
  <div class="page">
    <p>Analysis</p>
    <p>Tree</p>
    <p>Developers construct  Local runs on each core in parallel  Stream passes information over chain  Tree combines input from multiple analyzers</p>
    <p>Local Local Local</p>
    <p>Stream StreamStream</p>
    <p>Output</p>
    <p>Tracing Tracing TracingParallel faster by up to 4x (mean 2x)</p>
  </div>
  <div class="page">
    <p>Parallelizing a query</p>
    <p>Analyzer</p>
    <p>AnalysisOutput</p>
    <p>Tracing</p>
    <p>Execution</p>
    <p>Tracing Tracing</p>
    <p>Analyzer Analyzer</p>
    <p>Tracing</p>
  </div>
  <div class="page">
    <p>Sledgehammer Tools</p>
    <p>Analyzer</p>
    <p>AnalysisOutput</p>
    <p>Tracing</p>
    <p>Execution</p>
    <p>Tracing Tracing</p>
    <p>Analyzer Analyzer</p>
    <p>Tool</p>
    <p>Continuous Function Evaluation: Run after every instruction</p>
    <p>Retro-Timing: Query timing information</p>
    <p>Retro-Logging: Inject new logging code</p>
  </div>
  <div class="page">
    <p>Continuous Function Evaluation  Logically, execute function after each instruction  Instead, force determinism and trigger on input changes</p>
    <p>Valid ValidInvalid</p>
  </div>
  <div class="page">
    <p>Continuous Function Evaluation  Static instrumention produces input set  Memory page protections track updates to input set</p>
    <p>Valid Valid</p>
    <p>Input Set</p>
    <p>Input Set</p>
    <p>Input Set</p>
    <p>Invalid</p>
    <p>Protect Protect Protect</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Evaluation</p>
  </div>
  <div class="page">
    <p>Scenarios Name Benchmark Replay</p>
    <p>Time Tracing</p>
    <p>(millions) 1-Core Latency</p>
    <p>Data Corruption</p>
    <p>Nginx 2s 8 5m25s 1s</p>
    <p>Wild Store MongoDB 30s 3 2h8m8s 17s</p>
    <p>Atomicity Violation</p>
    <p>Memcached 1m38s 43 2h10m52s 14s</p>
    <p>Memory Leak Nginx 1m16s 4 26m15s 3s</p>
    <p>Lock Contention</p>
    <p>Memcached 1m33s 76 54m42s 11s</p>
    <p>Apache 45605 Apache 51s 2 4m10s 1s</p>
    <p>Apache 25520 Apache 60s 4 11m57s 1s</p>
  </div>
  <div class="page">
    <p>Scalability</p>
    <p>N or</p>
    <p>m al</p>
    <p>iz ed</p>
    <p>S pe</p>
    <p>ed up</p>
    <p>Number of Cores</p>
    <p>Ideal Data corruption Wild store Atomicity violation Memory leak Lock contention Apache 45605 Apache 25520</p>
  </div>
  <div class="page">
    <p>Why does Sledgehammer not scale perfectly?</p>
    <p>Initialization (tracer injection, restoring epoch start)  Outliers (latency of slowest vs. average epoch)</p>
    <p>More analysis in the paper</p>
    <p>Scalability</p>
  </div>
  <div class="page">
    <p>Cluster-Fueled Debugging</p>
    <p>Accelerate complex queries to interactive latencies</p>
  </div>
  <div class="page">
    <p>Sledgehammer</p>
    <p>Analyzer</p>
    <p>AnalysisOutput</p>
    <p>Tracing</p>
    <p>Execution</p>
    <p>Tracing Tracing</p>
    <p>Analyzer Analyzer</p>
    <p>Tracing</p>
  </div>
  <div class="page">
    <p>Sledgehammer</p>
    <p>Analyzer</p>
    <p>AnalysisOutput</p>
    <p>Tracing</p>
    <p>Execution</p>
    <p>Tracing Tracing</p>
    <p>Analyzer Analyzer</p>
    <p>Tool</p>
    <p>Scales to 1024 cores (speedup 416x) Faster than without debugging!</p>
  </div>
  <div class="page">
    <p>Questions</p>
    <p>Poster #13</p>
  </div>
</Presentation>
