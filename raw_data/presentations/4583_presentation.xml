<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Jos</p>
    <p>Eduardo Rivera Esther Guerra Juan de Lara Antonio Vallecillo</p>
    <p>Analyzing</p>
    <p>Rule-Based Behavioural</p>
    <p>Semantics</p>
    <p>of</p>
    <p>Visual</p>
    <p>Modeling</p>
    <p>Languages</p>
    <p>with</p>
    <p>Maude</p>
    <p>Universidad de Mlaga Universidad Carlos III de Madrid Universidad Autnoma de Madrid Universidad de Mlaga</p>
  </div>
  <div class="page">
    <p>A motivating</p>
    <p>example Meta-model</p>
    <p>of</p>
    <p>DSVL for</p>
    <p>production</p>
    <p>systems</p>
    <p>Different kinds of machines connected through trays Trays contain parts and can be interconnected Operators transfer parts between connected trays</p>
  </div>
  <div class="page">
    <p>A model</p>
    <p>of</p>
    <p>a production</p>
    <p>system Concrete syntax</p>
    <p>Nice picture! But how does the system actually works? How can I check that it does work well?</p>
    <p>op</p>
    <p>capacity</p>
    <p>= 4 nelems</p>
    <p>= 0</p>
    <p>capacity</p>
    <p>= 4 nelems</p>
    <p>= 0</p>
    <p>from</p>
    <p>to</p>
    <p>capacity</p>
    <p>= 4 nelems</p>
    <p>= 0</p>
    <p>counter = 6</p>
    <p>counter = 6</p>
    <p>capacity</p>
    <p>= 4 nelems</p>
    <p>= 0</p>
  </div>
  <div class="page">
    <p>MDE is more than Conceptual Modeling!!!</p>
    <p>Current DSLs Unanimated (mostly static) Limited analysis capabilities</p>
    <p>Almost inexistent Tool Support Simulation Analysis Estimation Quality evaluation and control</p>
    <p>Almost inexistent proven methodologies For neither development nor modernization</p>
  </div>
  <div class="page">
    <p>A model</p>
    <p>of</p>
    <p>a production</p>
    <p>system</p>
    <p>How to specify</p>
    <p>the behavioral semantics</p>
    <p>of Visual DSLs</p>
    <p>in a precise, intuitive, yet formal</p>
    <p>way</p>
    <p>How to analyze</p>
    <p>the behavior of a given system?</p>
    <p>op</p>
    <p>capacity</p>
    <p>= 4 nelems</p>
    <p>= 0</p>
    <p>capacity</p>
    <p>= 4 nelems</p>
    <p>= 0</p>
    <p>from</p>
    <p>to</p>
    <p>capacity</p>
    <p>= 4 nelems</p>
    <p>= 0</p>
    <p>counter = 6</p>
    <p>counter = 6</p>
    <p>capacity</p>
    <p>= 4 nelems</p>
    <p>= 0</p>
    <p>Key</p>
    <p>issues:</p>
  </div>
  <div class="page">
    <p>Why should we?</p>
    <p>Animate models Define the behavioral semantics of DSLs</p>
    <p>so that models can be understood, manipulated and maintained by both users and machines (i.e. Tools!)</p>
    <p>Conduct simulations</p>
    <p>Analyze models Define different semantics to a DSL (depending on our focus: performance, deadlock-freedom, simulation,) Make effective use of specific Analysis Tools</p>
  </div>
  <div class="page">
    <p>How do we</p>
    <p>do that?</p>
    <p>Option#1: Use a single language/notation/ Weve tried that for years</p>
    <p>Option#2: Use different DSLs and define semantic bridges between them</p>
    <p>Each DSL is more apt for expressing some concerns Each DSL has a precise semantics and set of (specific and very efficient) associated tools Bridges provide semantic mappings semantic domains (and analysis tools)</p>
  </div>
  <div class="page">
    <p>How do we</p>
    <p>do that?</p>
  </div>
  <div class="page">
    <p>In this paper</p>
    <p>GT is used to specify behavioral semantics GT semantics are then translated (encoded) into Maude specs Maude specs can be analyzed using the Maude tool-kit</p>
    <p>Benefits Additional analysis techniques to GT specs Intuitive representation of Maude specs</p>
  </div>
  <div class="page">
    <p>Why?</p>
    <p>Graph transformation Benefits: visual, declarative, rule-based way to specify behavior, very close to the domain expert Drawbacks: limited analysis capabilities in some cases (e.g., if dealing with attributes)</p>
    <p>Maude Benefits: many formal analysis methods and tools Drawbacks: specialized knowledge and expertise</p>
  </div>
  <div class="page">
    <p>GT for</p>
    <p>Behavioral</p>
    <p>Specifications</p>
    <p>Graph transformation rules use the concrete syntax to express how a model can evolve through time, i.e. its behavioral semantics</p>
    <p>op</p>
    <p>capacity</p>
    <p>= 4 nelems</p>
    <p>= 0</p>
    <p>capacity</p>
    <p>= 4 nelems</p>
    <p>= 0</p>
    <p>from</p>
    <p>to</p>
    <p>capacity</p>
    <p>= 4 nelems</p>
    <p>= 0</p>
    <p>counter = 6</p>
    <p>counter = 6</p>
    <p>capacity</p>
    <p>= 4 nelems</p>
    <p>= 0</p>
  </div>
  <div class="page">
    <p>Graph</p>
    <p>transformation Graph</p>
    <p>transformation</p>
    <p>rules</p>
    <p>LHS: pre-conditions (including attribute conditions) RHS: post-conditions (including attribute computacions) NAC: additional negative application condition</p>
    <p>LHS assemble</p>
    <p>h1 h2</p>
    <p>ATTRIBUTE CONDITION: t2.nelems</p>
    <p>&lt; t2.capacity</p>
    <p>a t1 t2</p>
    <p>RHS</p>
    <p>ATTRIBUTE COMPUTATION: t1.nelems</p>
    <p>= t1.nelems-2 t2.nelems</p>
    <p>= t2.nelems+1</p>
    <p>a t1 t2</p>
    <p>h3</p>
    <p>l:[NAC] x LHS  RHS</p>
  </div>
  <div class="page">
    <p>Graph</p>
    <p>transformation Graph</p>
    <p>transformation</p>
    <p>rules</p>
    <p>l:[NAC] x LHS  RHS</p>
    <p>moveOperator</p>
    <p>RHS:</p>
    <p>p * op</p>
    <p>from to</p>
    <p>t1 t2</p>
    <p>t3 t4 p</p>
    <p>LHS:</p>
    <p>*</p>
    <p>op</p>
    <p>from tot1 t2</p>
    <p>t3 t4</p>
    <p>ATT. CONDITION: t4.nelems</p>
    <p>&lt; t4.capacity</p>
    <p>NAC: op2 from to</p>
    <p>t3 t4</p>
  </div>
  <div class="page">
    <p>Graph</p>
    <p>transformation Derivation</p>
    <p>While</p>
    <p>some</p>
    <p>rule</p>
    <p>is</p>
    <p>applicable</p>
    <p>do: 1.</p>
    <p>Find</p>
    <p>a morphism</p>
    <p>from</p>
    <p>the</p>
    <p>LHS to</p>
    <p>the</p>
    <p>host</p>
    <p>graph</p>
    <p>NACs</p>
    <p>and</p>
    <p>attribute</p>
    <p>conditions</p>
    <p>must</p>
    <p>be satisfied</p>
    <p>as well 2.</p>
    <p>Substitute</p>
    <p>the</p>
    <p>match by the</p>
    <p>RHS</p>
    <p>Elements</p>
    <p>in the</p>
    <p>LHS and</p>
    <p>not</p>
    <p>in the</p>
    <p>RHS are deleted 2.</p>
    <p>Elements</p>
    <p>in the</p>
    <p>RHS and</p>
    <p>not</p>
    <p>in the</p>
    <p>LHS are created</p>
    <p>Calculate</p>
    <p>attribute</p>
    <p>computations</p>
    <p>There are two main algebraic formalizations of GT: DPO (double pushout) and SPO (single pushout) The chosen semantics will affect the Maude equivalent representation</p>
  </div>
  <div class="page">
    <p>Graph</p>
    <p>constraints</p>
    <p>A graph constraint is made of a set of graphs related through morphisms It demands the existence or absence of a certain graph structure in a model We use graph constraints to express model properties to be analyzed in an intuitive way</p>
    <p>Container Parts</p>
    <p>p *</p>
    <p>PartOverflow</p>
    <p>O</p>
    <p>ATTRIBUTE CONDITION: O.nelems</p>
    <p>&gt; O.capacity</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>to</p>
    <p>Maude</p>
    <p>It support equational logic and rewriting logic specification and programming of systems A system is axiomatized by an equational theory describing its states and a collection of rewrite rules</p>
    <p>Rule syntax: crl</p>
    <p>[l] : t =&gt; t</p>
    <p>if</p>
    <p>Cond</p>
    <p>mod</p>
    <p>BANK is class</p>
    <p>Account</p>
    <p>| balance : Int</p>
    <p>.</p>
    <p>class</p>
    <p>Deposit</p>
    <p>| account</p>
    <p>: Oid, amount</p>
    <p>: Int</p>
    <p>. vars</p>
    <p>N M : nat</p>
    <p>. vars</p>
    <p>A D : Oid</p>
    <p>.</p>
    <p>crl</p>
    <p>[deposit] : &lt; A : Account</p>
    <p>| balance : N &gt;</p>
    <p>&lt; D : Deposit</p>
    <p>| account</p>
    <p>: A, amount</p>
    <p>: M &gt; =&gt; &lt; A : Account</p>
    <p>| balance : N + M &gt;</p>
    <p>if</p>
    <p>(M &gt; 0) endm</p>
  </div>
  <div class="page">
    <p>From</p>
    <p>graph</p>
    <p>transformation</p>
    <p>to</p>
    <p>Maude Encoding</p>
    <p>models</p>
    <p>Nodes represented by objects Attributes and edges represented by object attributes</p>
    <p>Meta-models  a sort for each element (e.g. @Class)</p>
    <p>ProductionSystem</p>
    <p>{ &lt; t1 : Tray</p>
    <p>| parts</p>
    <p>: empty,</p>
    <p>next</p>
    <p>: t3, prev</p>
    <p>: empty, min</p>
    <p>: empty, mout</p>
    <p>: empty,</p>
    <p>capacity</p>
    <p>: 4, nelems</p>
    <p>: 0 &gt; &lt; t3 : Tray</p>
    <p>| parts</p>
    <p>: empty,</p>
    <p>next</p>
    <p>: empty, prev</p>
    <p>: t2, min</p>
    <p>: empty, mout</p>
    <p>: empty,</p>
    <p>capacity</p>
    <p>: 4, nelems</p>
    <p>: 0 &gt; &lt; op</p>
    <p>: Operator</p>
    <p>| from</p>
    <p>: t1, to</p>
    <p>: t3 &gt;</p>
    <p>}</p>
    <p>op</p>
    <p>capacity</p>
    <p>= 4 nelems</p>
    <p>= 0</p>
    <p>capacity</p>
    <p>= 4 nelems</p>
    <p>= 0</p>
    <p>from to</p>
  </div>
  <div class="page">
    <p>From</p>
    <p>graph</p>
    <p>transformation</p>
    <p>to</p>
    <p>Maude Encoding</p>
    <p>LHS of</p>
    <p>rules</p>
    <p>crl</p>
    <p>[MoveOperator] : ProductionSystem</p>
    <p>{</p>
    <p>&lt; T1 : Tray</p>
    <p>| SFS@T1</p>
    <p>&gt; &lt; T2 : Tray</p>
    <p>| SFS@T2</p>
    <p>&gt;</p>
    <p>&lt; OP : Operator</p>
    <p>| from</p>
    <p>: T1,</p>
    <p>to</p>
    <p>: T2, SFS@OP</p>
    <p>&gt; &lt; T3 : Tray</p>
    <p>|</p>
    <p>next</p>
    <p>: (T4, NEXT@T3), parts</p>
    <p>: (P, PARTS@T3),</p>
    <p>SFS@T3</p>
    <p>&gt; &lt; T4 : Tray</p>
    <p>|</p>
    <p>prev</p>
    <p>: (T3, NEXT@T4), capacity</p>
    <p>: CAPT@T4,</p>
    <p>nelems</p>
    <p>: NEL@T4, SFS@T4</p>
    <p>&gt;</p>
    <p>&lt; P : X:Part</p>
    <p>| SFS@P</p>
    <p>&gt; OBJSET }</p>
    <p>moveOperator</p>
    <p>p</p>
    <p>LHS:</p>
    <p>*</p>
    <p>op</p>
    <p>from tot1 t2</p>
    <p>t3 t4</p>
    <p>(graph</p>
    <p>constraints</p>
    <p>expressing model</p>
    <p>properties</p>
    <p>are</p>
    <p>transformed</p>
    <p>in the</p>
    <p>same</p>
    <p>way)</p>
  </div>
  <div class="page">
    <p>From</p>
    <p>graph</p>
    <p>transformation</p>
    <p>to</p>
    <p>Maude Encoding</p>
    <p>RHS of</p>
    <p>rules</p>
    <p>=&gt; ProductionSystem</p>
    <p>{</p>
    <p>&lt; T1 : Tray</p>
    <p>| SFS@T1</p>
    <p>&gt; &lt; T2 : Tray</p>
    <p>| SFS@T2</p>
    <p>&gt;</p>
    <p>&lt; OP : Operator</p>
    <p>| from</p>
    <p>: T3,</p>
    <p>to</p>
    <p>: T4, SFS@OP</p>
    <p>&gt; &lt; T3 : Tray</p>
    <p>|</p>
    <p>next</p>
    <p>: (T4, NEXT@T3), parts</p>
    <p>: (P, PARTS@T3),</p>
    <p>SFS@T3</p>
    <p>&gt; &lt; T4 : Tray</p>
    <p>|</p>
    <p>prev</p>
    <p>: (T3, NEXT@T4), capacity</p>
    <p>: CAPT@T4,</p>
    <p>nelems</p>
    <p>: NEL@T4, SFS@T4</p>
    <p>&gt;</p>
    <p>&lt; P : X:Part</p>
    <p>| SFS@P</p>
    <p>&gt; OBJSET }</p>
    <p>moveOperator</p>
    <p>p</p>
    <p>LHS:</p>
    <p>*</p>
    <p>op</p>
    <p>from tot1 t2</p>
    <p>t3 t4 p</p>
    <p>RHS:</p>
    <p>* op</p>
    <p>from to</p>
    <p>t1 t2</p>
    <p>t3 t4</p>
  </div>
  <div class="page">
    <p>From</p>
    <p>graph</p>
    <p>transformation</p>
    <p>to</p>
    <p>Maude Encoding</p>
    <p>attribute</p>
    <p>conditions</p>
    <p>of</p>
    <p>rules</p>
    <p>if</p>
    <p>(NEL@T4</p>
    <p>&lt; CAP@T4)</p>
    <p>moveOperator</p>
    <p>p</p>
    <p>LHS:</p>
    <p>*</p>
    <p>op</p>
    <p>from tot1 t2</p>
    <p>t3 t4 p</p>
    <p>RHS:</p>
    <p>* op</p>
    <p>from to</p>
    <p>t1 t2</p>
    <p>t3 t4</p>
    <p>ATT. CONDITION: t4.nelems</p>
    <p>&lt; t4.capacity</p>
  </div>
  <div class="page">
    <p>From</p>
    <p>graph</p>
    <p>transformation</p>
    <p>to</p>
    <p>Maude Encoding</p>
    <p>negative</p>
    <p>app. conditions</p>
    <p>of</p>
    <p>rules</p>
    <p>if</p>
    <p>(NEL@T4</p>
    <p>&lt; CAP@T4)</p>
    <p>/ \ LHS := &lt; T1 : Tray</p>
    <p>| SFS@T1</p>
    <p>&gt;</p>
    <p>&lt; T2 : Tray</p>
    <p>| SFS@T2</p>
    <p>&gt;  &lt; P : X:PartS</p>
    <p>| SFS@P</p>
    <p>&gt;</p>
    <p>/ \ MODEL := ProductionSystem(LHS</p>
    <p>OBJECT SET)</p>
    <p>/ \ not NAC@MoveOperator(LHS, MODEL)</p>
    <p>moveOperator</p>
    <p>p</p>
    <p>LHS:</p>
    <p>*</p>
    <p>op</p>
    <p>from tot1 t2</p>
    <p>t3 t4 p</p>
    <p>RHS:</p>
    <p>* op</p>
    <p>from to</p>
    <p>t1 t2</p>
    <p>t3 t4</p>
    <p>ATT. CONDITION: t4.nelems</p>
    <p>&lt; t4.capacity</p>
    <p>NAC: op2 from to</p>
    <p>t3 t4</p>
  </div>
  <div class="page">
    <p>Analyzing</p>
    <p>behavior</p>
    <p>with</p>
    <p>Maude Simulation</p>
    <p>Maude specifications can be executed</p>
    <p>Maude commands: rewrite: top-down rule-fair strategy frewrite: depth-first position-fair strategy</p>
    <p>It is possible to specify upper bounds for the number of rule applications (useful for non-terminating systems)</p>
    <p>rewrite</p>
    <p>initModel</p>
    <p>.</p>
  </div>
  <div class="page">
    <p>Analyzing</p>
    <p>behavior</p>
    <p>with</p>
    <p>Maude Reachability</p>
    <p>analysis</p>
    <p>We can explore the reachable state space</p>
    <p>Maude commands: search: breadth-first strategy to a specified bound</p>
    <p>input: model</p>
    <p>properties</p>
    <p>to</p>
    <p>be satisfied</p>
    <p>for</p>
    <p>the</p>
    <p>reachable</p>
    <p>states</p>
    <p>output: reachable</p>
    <p>states</p>
    <p>satisfying</p>
    <p>the</p>
    <p>model</p>
    <p>properties</p>
    <p>E.g. deadlock states where there is a container without parts Container Parts</p>
    <p>p *</p>
    <p>search</p>
    <p>[10 ] initModel</p>
    <p>=&gt;! ProductionSystem</p>
    <p>{</p>
    <p>&lt; co</p>
    <p>: Container | parts</p>
    <p>: empty, SFS &gt; OBJSET } .</p>
  </div>
  <div class="page">
    <p>Analyzing</p>
    <p>behavior</p>
    <p>with</p>
    <p>Maude LTL model</p>
    <p>checking</p>
    <p>Linear temporal logic explicit-state model checker (useful to check temporal logic properties, safety and liveness properties)</p>
    <p>State predicates: exist, stored, operated, eventually (&lt;&gt;), henceforth ([])...</p>
    <p>E.g. check whether a given hammer is eventually stored reduce modelCheck(initModel,</p>
    <p>[](exist(hammer1) -&gt; &lt;&gt;stored(hammer1)) .</p>
    <p>result Bool: true</p>
  </div>
  <div class="page">
    <p>Tool</p>
    <p>support AToM3</p>
    <p>+ Maude</p>
    <p>Front-end: AToM3 for the specification of the modeling language, the GT rules and the model properties Back-end: Maude for the analysis</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>Keep the best of GT and Maude: Visual and intuitive specification of DSVL semantics by GT rules</p>
    <p>Analysis using the Maude toolkit</p>
    <p>Reachability</p>
    <p>Analysis</p>
    <p>Model</p>
    <p>checking</p>
    <p>Usable approach: Verification mechanisms are hidden Transformations from GT systems to Maude (and back)</p>
  </div>
  <div class="page">
    <p>Future</p>
    <p>work/issues</p>
    <p>GT &lt;-&gt; Maude Annotation of some analysis results to the original modeling language Termination of a rule-based specification Strategies for setting the order in which GT rules are selected and executed Scalability and efficiency</p>
    <p>More bridges From/to GT to Petri-Nets, pre-post, etc. From/to Maude to other rule-based visual notations</p>
    <p>Add NFP to behavioral specifications (time, probabilities,)</p>
  </div>
  <div class="page">
    <p>Thanks!</p>
    <p>Jos</p>
    <p>Eduardo Rivera Esther Guerra Juan de Lara Antonio Vallecillo</p>
    <p>Analyzing</p>
    <p>Rule-Based Behavioural</p>
    <p>Semantics</p>
    <p>of</p>
    <p>Visual</p>
    <p>Modeling</p>
    <p>Languages</p>
    <p>with</p>
    <p>Maude</p>
    <p>Universidad de Mlaga Universidad Carlos III de Madrid Universidad Autnoma de Madrid Universidad de Mlaga</p>
  </div>
</Presentation>
