<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>U N D E R - C O N S T R A I N E D S Y M B O L I C E X E C U T I O N : C O R R E C T N E S S C H E C K I N G F O R R E A L C O D E</p>
    <p>D A V I D A . R A M O S A N D D A W S O N E N G L E R S T A N F O R D U N I V E R S I T Y</p>
  </div>
  <div class="page">
    <p>C O N T R I B U T I O N S</p>
    <p>Technique + tool for finding deep bugs in real, open source C/C++ code  No manual testcases</p>
    <p>No functional specification</p>
    <p>Bugs reported may have security implications; exploitability must be determined manually</p>
    <p>Memory access, heap management, assertion failures, division-by-zero</p>
    <p>Found 77 new bugs in BIND, OpenSSL, Linux kernel</p>
    <p>2 OpenSSL DoS vulnerabilities: CVE-2014-0198, CVE-2015-0292</p>
    <p>14 Linux kernel vulnerabilities (mostly minor DoS issues)</p>
  </div>
  <div class="page">
    <p>M O T I V A T I O N : C U R R E N T P R A C T I C E</p>
    <p>Code reviews</p>
    <p>Safer languages</p>
    <p>Manual (regression) testing</p>
    <p>Static analysis (Coverity, clang static analyzer, etc.)</p>
    <p>Bugs are everywhere!</p>
  </div>
  <div class="page">
    <p>S Y M B O L I C E X E C U T I O N</p>
    <p>Provide symbolic rather than concrete inputs</p>
    <p>Conceptually: explore all paths through a program</p>
    <p>Accurately track all memory values (bit precision)</p>
    <p>Report paths/inputs that crash</p>
    <p>Generate concrete testcase</p>
    <p>KLEE tool (prior work: OSDI 2008)</p>
  </div>
  <div class="page">
    <p>int foo(int x) { if (x) return x/10; else return 10/x; }</p>
    <p>x is symbolic input</p>
    <p>E X A M P L E</p>
  </div>
  <div class="page">
    <p>int foo(int x) { if (x) return x/10; else return 10/x; }</p>
    <p>symbolic branch</p>
    <p>E X A M P L E</p>
  </div>
  <div class="page">
    <p>E X A M P L E</p>
    <p>if (x) return x/10;</p>
    <p>else return 10/x;</p>
    <p>x != 0 x == 0</p>
    <p>State 1 State 2</p>
    <p>Division: OK</p>
  </div>
  <div class="page">
    <p>E X A M P L E</p>
    <p>Division: ERROR</p>
  </div>
  <div class="page">
    <p>P R O B L E M : S C A L A B I L I T Y</p>
    <p>Path explosion</p>
    <p>| paths | ~ 2 | if-statements |</p>
    <p>Path length and complexity</p>
    <p>Undecidable: infinite-length paths (halting problem)</p>
    <p>SMT query complexity (NP-complete)</p>
  </div>
  <div class="page">
    <p>S O L U T I O N : U N D E R - C O N S T R A I N E D</p>
    <p>Directly execute individual functions within a program</p>
    <p>Less code = Fewer paths</p>
    <p>Function calls executed (inter-procedural)</p>
    <p>Able to test previously-unreachable code</p>
    <p>Challenges</p>
    <p>Complex inputs (e.g., pointer-rich data structures)</p>
    <p>Under-constrained: inputs have unknown preconditions</p>
    <p>- False positives</p>
  </div>
  <div class="page">
    <p>U C - K L E E T O O L</p>
    <p>Extends KLEE tool (OSDI 2008)</p>
    <p>Runs LLVM bitcode compiled from C/C++ source</p>
    <p>Automatically synthesizes complex inputs</p>
    <p>Based on lazy initialization (Java PathFinder)</p>
    <p>Supports pointer manipulation and casting in C/C++ (no type safety)</p>
    <p>User-specified input depth (k-bound) [Deng 2006]</p>
  </div>
  <div class="page">
    <p>L A Z Y I N I T I A L I Z A T I O N</p>
    <p>Symbolic (input) pointers initially unbound</p>
    <p>On first dereference:</p>
    <p>New object allocated</p>
    <p>Symbolic pointer bound to new objects address</p>
    <p>Assume no aliasing (i.e., no cyclical data structures)</p>
    <p>On subsequent dereferences:</p>
    <p>Pointer resolves to object allocated above</p>
  </div>
  <div class="page">
    <p>int listSum(node *n) { int sum = 0; while (n) { sum += n-&gt;val; n = n-&gt;next; } return sum; }</p>
    <p>E X A M P L E unbound symbolic input</p>
  </div>
  <div class="page">
    <p>int listSum(node *n) { int sum = 0; while (n) { sum += n-&gt;val; n = n-&gt;next; } return sum; }</p>
    <p>E X A M P L E</p>
  </div>
  <div class="page">
    <p>int listSum(node *n) { int sum = 0; while (n) { sum += n-&gt;val; n = n-&gt;next; } return sum; }</p>
    <p>E X A M P L E</p>
  </div>
  <div class="page">
    <p>int listSum(node *n) { int sum = 0; while (n) { sum += n-&gt;val; n = n-&gt;next; } return sum; }</p>
    <p>n N U L Ln == 0E X A M P L E</p>
    <p>n</p>
    <p>n != 0</p>
  </div>
  <div class="page">
    <p>int listSum(node *n) { int sum = 0; while (n) { sum += n-&gt;val; n = n-&gt;next; } return sum; }</p>
    <p>n N U L Ln == 0E X A M P L E</p>
    <p>n</p>
    <p>n != 0</p>
  </div>
  <div class="page">
    <p>int listSum(node *n) { int sum = 0; while (n) { sum += n-&gt;val; n = n-&gt;next; } return sum; }</p>
    <p>n N U L Ln == 0E X A M P L E</p>
    <p>n</p>
    <p>n != 0</p>
    <p>uc_node1</p>
    <p>next</p>
    <p>val</p>
    <p>n == &amp;uc_node1</p>
  </div>
  <div class="page">
    <p>int listSum(node *n) { int sum = 0; while (n) { sum += n-&gt;val; n = n-&gt;next; } return sum; }</p>
    <p>n N U L Ln == 0E X A M P L E</p>
    <p>n</p>
    <p>n != 0</p>
    <p>uc_node1</p>
    <p>next</p>
    <p>val</p>
    <p>n == &amp;uc_node1</p>
  </div>
  <div class="page">
    <p>int listSum(node *n) { int sum = 0; while (n) { sum += n-&gt;val; n = n-&gt;next; } return sum; }</p>
    <p>n N U L L</p>
    <p>n</p>
    <p>n == 0</p>
    <p>n != 0</p>
    <p>uc_node1</p>
    <p>next</p>
    <p>val</p>
    <p>n == &amp;uc_node1</p>
    <p>E X A M P L E</p>
  </div>
  <div class="page">
    <p>int listSum(node *n) { int sum = 0; while (n) { sum += n-&gt;val; n = n-&gt;next; } return sum; }</p>
    <p>n N U L L</p>
    <p>n</p>
    <p>n == 0</p>
    <p>n != 0</p>
    <p>uc_node1</p>
    <p>next</p>
    <p>val</p>
    <p>n == &amp;uc_node1</p>
    <p>n</p>
    <p>n != 0 uc_node1</p>
    <p>next</p>
    <p>val</p>
    <p>n == &amp;uc_node1</p>
    <p>N U L L</p>
    <p>uc_node1.next == 0</p>
    <p>E X A M P L E</p>
  </div>
  <div class="page">
    <p>int listSum(node *n) { int sum = 0; while (n) { sum += n-&gt;val; n = n-&gt;next; } return sum; }</p>
    <p>n N U L L</p>
    <p>n</p>
    <p>n == 0</p>
    <p>n != 0</p>
    <p>uc_node1</p>
    <p>next</p>
    <p>val</p>
    <p>n == &amp;uc_node1</p>
    <p>n</p>
    <p>n != 0 uc_node1</p>
    <p>next</p>
    <p>val</p>
    <p>n == &amp;uc_node1</p>
    <p>N U L L</p>
    <p>uc_node1.next == 0</p>
    <p>E X A M P L E</p>
  </div>
  <div class="page">
    <p>int listSum(node *n) { int sum = 0; while (n) { sum += n-&gt;val; n = n-&gt;next; } return sum; }</p>
    <p>n N U L L</p>
    <p>n</p>
    <p>n == 0</p>
    <p>n != 0</p>
    <p>uc_node1</p>
    <p>next</p>
    <p>val</p>
    <p>n == &amp;uc_node1</p>
    <p>n</p>
    <p>n != 0 uc_node1</p>
    <p>next</p>
    <p>val</p>
    <p>n == &amp;uc_node1</p>
    <p>N U L L</p>
    <p>uc_node2</p>
    <p>next</p>
    <p>val</p>
    <p>uc_node1.next == &amp;uc_node2</p>
    <p>uc_node1.next == 0</p>
    <p>E X A M P L E</p>
  </div>
  <div class="page">
    <p>int listSum(node *n) { int sum = 0; while (n) { sum += n-&gt;val; n = n-&gt;next; } return sum; }</p>
    <p>n N U L L</p>
    <p>n</p>
    <p>n == 0</p>
    <p>n != 0</p>
    <p>uc_node1</p>
    <p>next</p>
    <p>val</p>
    <p>n == &amp;uc_node1</p>
    <p>n</p>
    <p>n != 0 uc_node1</p>
    <p>next</p>
    <p>val</p>
    <p>n == &amp;uc_node1</p>
    <p>N U L L</p>
    <p>uc_node2</p>
    <p>next</p>
    <p>val</p>
    <p>uc_node1.next == &amp;uc_node2</p>
    <p>uc_node1.next == 0</p>
    <p>E X A M P L E</p>
  </div>
  <div class="page">
    <p>int listSum(node *n) { int sum = 0; while (n) { sum += n-&gt;val; n = n-&gt;next; } return sum; }</p>
    <p>n N U L L</p>
    <p>n</p>
    <p>n == 0</p>
    <p>n != 0</p>
    <p>uc_node1</p>
    <p>next</p>
    <p>val</p>
    <p>n == &amp;uc_node1</p>
    <p>n</p>
    <p>n != 0 uc_node1</p>
    <p>next</p>
    <p>val</p>
    <p>n == &amp;uc_node1</p>
    <p>N U L L</p>
    <p>uc_node2</p>
    <p>next</p>
    <p>val</p>
    <p>uc_node1.next == &amp;uc_node2</p>
    <p>uc_node1.next == 0</p>
    <p>E X A M P L E</p>
  </div>
  <div class="page">
    <p>int listSum(node *n) { int sum = 0; while (n) { sum += n-&gt;val; n = n-&gt;next; } return sum; }</p>
    <p>n N U L L</p>
    <p>n</p>
    <p>n == 0</p>
    <p>n != 0</p>
    <p>uc_node1</p>
    <p>next</p>
    <p>val</p>
    <p>n == &amp;uc_node1</p>
    <p>n</p>
    <p>n != 0 uc_node1</p>
    <p>next</p>
    <p>val</p>
    <p>n == &amp;uc_node1</p>
    <p>N U L L</p>
    <p>uc_node2</p>
    <p>next</p>
    <p>val</p>
    <p>N U L L</p>
    <p>uc_node1.next == &amp;uc_node2 uc_node2.next == 0</p>
    <p>uc_node1.next == 0</p>
    <p>E X A M P L E</p>
  </div>
  <div class="page">
    <p>int listSum(node *n) { int sum = 0; while (n) { sum += n-&gt;val; n = n-&gt;next; } return sum; }</p>
    <p>n N U L L</p>
    <p>n</p>
    <p>n == 0</p>
    <p>n != 0</p>
    <p>uc_node1</p>
    <p>next</p>
    <p>val</p>
    <p>n == &amp;uc_node1</p>
    <p>n</p>
    <p>n != 0 uc_node1</p>
    <p>next</p>
    <p>val</p>
    <p>n == &amp;uc_node1</p>
    <p>N U L L</p>
    <p>uc_node2</p>
    <p>next</p>
    <p>val</p>
    <p>N U L L</p>
    <p>uc_node1.next == &amp;uc_node2 uc_node2.next == 0</p>
    <p>uc_node1.next == 0</p>
    <p>E X A M P L E</p>
  </div>
  <div class="page">
    <p>U S E C A S E S</p>
    <p>Equivalence checking: patches  Yesterdays code vs. todays code (i.e., fewer bugs today)</p>
    <p>Goal: detect (and prevent!) new crashes introduced by patches</p>
    <p>Other uses discussed in CAV 2011 paper</p>
  </div>
  <div class="page">
    <p>P A T C H E S</p>
    <p>Source: https://twitter.com/phabricator</p>
  </div>
  <div class="page">
    <p>U S E C A S E S</p>
    <p>Equivalence checking: patches  Yesterdays code vs. todays code (i.e., fewer bugs today)</p>
    <p>Goal: detect (and prevent!) new crashes introduced by patches</p>
    <p>Other uses discussed in CAV 2011 paper</p>
    <p>General bug-finding: rule-based checkers  Single version of a function; under-constrained + additional checker rules</p>
    <p>Memory leaks, uninitialized data, unsafe user input</p>
    <p>Simple interface for adding new checkers</p>
  </div>
  <div class="page">
    <p>E Q U I V A L E N C E C H E C K I N G</p>
    <p>retA = fooA(x); retB = fooB(x);</p>
    <p>assert(retA == retB);</p>
    <p>identical input (symbolic)</p>
    <p>assert equivalence</p>
  </div>
  <div class="page">
    <p>E Q U I V A L E N C E C H E C K I N G</p>
    <p>Value equivalence</p>
    <p>Return value</p>
    <p>Arguments passed by reference</p>
    <p>Global/static variables</p>
    <p>System call effects (modeled)</p>
    <p>Error (crash) equivalence</p>
    <p>Both versions typically have the same same (unknown) preconditions!</p>
    <p>Neither version crashes on an input</p>
    <p>Both versions crash on an input</p>
    <p>USE CASE: whether patches introduce</p>
    <p>crashes</p>
  </div>
  <div class="page">
    <p>E Q U I V A L E N C E C H E C K I N G</p>
    <p>Check per path equivalence of two functions</p>
    <p>If all paths exhausted, equivalence verified (up to input bound)</p>
  </div>
  <div class="page">
    <p>E V A L U A T I O N</p>
    <p>BIND, OpenSSL</p>
    <p>Mature, security-critical codebases (~400 KLOC each)</p>
    <p>Patches</p>
    <p>BIND: 487 patches to 9.9 stable (14 months)</p>
    <p>OpenSSL: 324 patches to 1.0.1 stable (27 months)</p>
    <p>Ran UC-KLEE for 1 hour on each patched function</p>
  </div>
  <div class="page">
    <p>E V A L U A T I O N : P A T C H E S</p>
    <p>Discovered 10 new bugs (4 in BIND, 6 in OpenSSL)  2 OpenSSL DoS vulnerabilities:</p>
    <p>- CVE-2014-0198: NULL pointer dereference</p>
    <p>- CVE-2015-0292: Out-of-bounds memcpy read</p>
    <p>Verified (w/ caveats) that patches do not introduce crashes</p>
    <p>67 (13.8%) for BIND, 48 (14.8%) for OpenSSL</p>
    <p>Caveat: max. input size (25KB), tool limitations/bugs</p>
  </div>
  <div class="page">
    <p>O P E N S S L C V E - 2 0 1 4 - 0 1 9 8</p>
    <p>do_ssl3_write(): 1 if (wb-&gt;buf == NULL) 2 if (!ssl3_setup_write_buffer(s)) 3 return -1; 4 ... 5 /* If we have an alert to send, lets send it */ 6 if (s-&gt;s3-&gt;alert_dispatch) { 7 i=s-&gt;method-&gt;ssl_dispatch_alert(s); 8 if (i &lt;= 0) 9 return(i); 10 /* if it went, fall through and send more stuff */ 11 } 12 ... 13 unsigned char *p = wb-&gt;buf; 14 *(p++)=type&amp;0xff;</p>
    <p>NULL pointer check</p>
    <p>call sets wb-&gt;buf to NULL</p>
    <p>NULL pointer dereference</p>
  </div>
  <div class="page">
    <p>O P E N S S L C V E - 2 0 1 4 - 0 1 9 8</p>
    <p>Uncommon code path</p>
    <p>SSL_MODE_RELEASE_BUFFERS runtime option (used by Apache mod_ssl)</p>
    <p>SSL alert pending (could be triggered by attacker)</p>
    <p>Difficult to consider this case with traditional testing</p>
  </div>
  <div class="page">
    <p>F A L S E P O S I T I V E S</p>
    <p>Functions inputs have unknown preconditions</p>
    <p>Partial solutions</p>
    <p>Automated heuristics</p>
    <p>Manual annotations (lazily, as needed)</p>
    <p>- Written in C/C++, separate from codebase</p>
    <p>- Simple annotation can silence many errors</p>
  </div>
  <div class="page">
    <p>F A L S E P O S I T I V E S : E X A M P L E ( B I N D )</p>
    <p>INVARIANT(r-&gt;length &lt;= OBJECT_SIZE(r-&gt;base));</p>
  </div>
  <div class="page">
    <p>M A N U A L A N N O T A T I O N S</p>
    <p>BIND: 400 lines of annotation code (~0.1%)</p>
    <p>OpenSSL: 60 lines of annotation code (~0.02%)</p>
    <p>Reasonable effort relative to code size (~400 KLOC) and importance</p>
  </div>
  <div class="page">
    <p>G E N E R A L B U G - F I N D I N G</p>
    <p>Run single version of a function (w/ lazy initialization)</p>
    <p>Individual checkers look for specific types of bugs:</p>
    <p>Leak checker</p>
    <p>Uninitialized data checker</p>
    <p>User input checker</p>
    <p>Like Valgrind but applied to all execution paths</p>
  </div>
  <div class="page">
    <p>E V A L U A T I O N</p>
    <p>20,000+ functions: BIND, OpenSSL, Linux kernel (~12 MLOC)</p>
    <p>Found 67 new bugs</p>
    <p>37 memory leaks</p>
    <p>- Linux kernel: exploitable AUTH_GSS leak in NFS SunRPC layer</p>
    <p>19 uses of uninitialized data</p>
    <p>- BIND: DNS UDP port PRNG selected by uninitialized value</p>
    <p>- Linux kernel: leak of private kernel stack data via firewire ioctl</p>
    <p>11 unsafe user input (Linux kernel only)</p>
    <p>- VMware VMCI driver: unchecked memcpy length (~Heartbleed)</p>
    <p>- CEPH distributed file system: division-by-zero (kernel FPE)</p>
  </div>
  <div class="page">
    <p>U S E R I N P U T C H E C K E R</p>
    <p>User input is fully-constrained (an attacker may supply any value); no unknown input preconditions</p>
    <p>Checker tracks whether each symbolic byte is UC/FC</p>
    <p>Checker emits UNSAFE_INPUT flag if error is caused by FC input</p>
    <p>Suppresses flag for inputs possibly sanitized (false pos. trade-off)</p>
    <p>C annotations: specify functions returning user input</p>
    <p>Linux: get_user, copy_from_user, syscall args</p>
    <p>BIND: isc_buffer_getuint8</p>
    <p>OpenSSL: byte-swaps (n2s, n2l, etc.) [Chou]</p>
  </div>
  <div class="page">
    <p>K E R N E L V M C I V U L N E R A B I L I T Y</p>
    <p>copy_from_user()Fully constrained</p>
    <p>Unchecked memcpy length</p>
    <p>Send up to 69,632 bytes from host private kernel memory to guest OS</p>
    <p>Similar to Heartbleed! (much lower impact)</p>
  </div>
  <div class="page">
    <p>C O N C L U S I O N</p>
    <p>Under-constrained symbolic execution</p>
    <p>Equivalence checking: patches</p>
    <p>General bug-finding: rule-based checkers</p>
    <p>Experimental results: BIND, OpenSSL, Linux kernel</p>
  </div>
  <div class="page">
    <p>@ramosbugs</p>
    <p>Q U E S T I O N S ?</p>
  </div>
</Presentation>
