<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Formalizing ODP Computational Viewpoint</p>
    <p>Specification in Maude</p>
    <p>Ral Romero and Antonio VallecilloRal Romero and Antonio Vallecillo</p>
    <p>EDOC 2004</p>
    <p>Dpto. Lenguajes y Ciencias de la ComputacinDpto. Lenguajes y Ciencias de la Computacin</p>
    <p>Universidad de Mlaga, SpainUniversidad de Mlaga, Spain</p>
    <p>{jrromero, av}@lcc.uma.es{jrromero, av}@lcc.uma.es</p>
  </div>
  <div class="page">
    <p>Contents 1. Motivation</p>
  </div>
  <div class="page">
    <p>Motivation: RM-ODP</p>
    <p>RM-ODP is a framework for ODP standardization and system spe</p>
    <p>cification covering all aspects of distributed systems: enterprise b</p>
    <p>usiness, system, technology, distribution,</p>
    <p>comprehensive and coherent object-oriented modelling concepts</p>
    <p>viewpoints  viewpoint specifications</p>
    <p>Transparencies</p>
    <p>Common functions</p>
    <p>Viewpoints</p>
    <p>Different abstractions of the same system</p>
    <p>Reflect different concerns</p>
    <p>Expressed in terms of specific viewpoint languages</p>
    <p>Powerful mechanism for dealing with the complexity of distributed systems!</p>
  </div>
  <div class="page">
    <p>Motivation: ODP Viewpoints</p>
    <p>ODPODP SystemSystem</p>
    <p>EnterpriseEnterprise</p>
    <p>ComputationComputation</p>
    <p>InformationInformation</p>
    <p>TechnologyTechnology</p>
    <p>EngineeringEngineering</p>
  </div>
  <div class="page">
    <p>Motivation: The</p>
    <p>Computational</p>
    <p>Viewpoint</p>
    <p>The Computational Viewpoint describes the functionality of</p>
    <p>the ODP system and its environment through the</p>
    <p>decomposition of the system into objects which interact at</p>
    <p>interfaces  in a distribution transparent manner</p>
  </div>
  <div class="page">
    <p>Motivation: The</p>
    <p>Computational</p>
    <p>Viewpoint</p>
    <p>Computational objects and interfaces are usually specified by Co mputational Object Templates and Computational Interface Tem</p>
    <p>plates (*)</p>
    <p>Binding Objects are computational objects which support a bindi ng between a set of other computational objects.</p>
    <p>A computational interface template comprises  an interface signature  a behaviour specification  an environment contract</p>
    <p>(*) A Template is the specification of the common features of a collection of &lt;X&gt;s in sufficient detail that an &lt;X&gt; can instantiated using it.</p>
  </div>
  <div class="page">
    <p>Computation al Viewpoint Specification s</p>
    <p>A Computational Specification describes the functional</p>
    <p>decomposition of an ODP system, in distribution transparent</p>
    <p>terms, as:</p>
    <p>Configuration of computational objects</p>
    <p>Internal actions of those objects</p>
    <p>Interactions among those objects</p>
    <p>Environment contracts</p>
  </div>
  <div class="page">
    <p>The</p>
    <p>Computational</p>
    <p>Viewpoint</p>
    <p>[[ METAMODEL ]]</p>
    <p>CV Metamodel</p>
  </div>
  <div class="page">
    <p>Motivation</p>
    <p>ODP Viewpoint languages are abstract, i.e., ODP does not prescribe any particular notation for expressing Viewpoint specifications</p>
    <p>Without a concrete syntax</p>
    <p>it is difficult to write ODP specifications</p>
    <p>There is no tool support</p>
    <p>No analysis of the specifications (formal or informal)</p>
    <p>Formal methods are convenient/needed for enabling</p>
    <p>Precise, unambiguous, and abstract interpretation of</p>
    <p>ODP concepts and specifications</p>
    <p>The development of tools that support writing and</p>
    <p>analyzing ODP specifications</p>
    <p>but traditionally useless</p>
  </div>
  <div class="page">
    <p>Maude</p>
    <p>Formal notation (and system) that supports equational and rewriti</p>
    <p>ng logic specification and programming</p>
    <p>Supports OO specifications and computations</p>
    <p>Classes: class C | a1 : S1, ., an : Sn</p>
    <p>Objects: &lt; O : C | a1 : v1, ., an : vn &gt;</p>
    <p>Messages: msg m : S1  Sn -&gt; Msg .</p>
    <p>A configuration is a multiset of objects and messages that evolves</p>
    <p>by rewriting rules:</p>
    <p>crl [r] : M1, Mm &lt; O1 : C1 | atts1 &gt;  &lt; On : Cn | attsn &gt;</p>
    <p>=&gt; &lt; Oi1 : C1 | attsi1 &gt; &lt; Oin : Cn | attsin &gt;</p>
    <p>&lt; Q1 : C1 | atts1 &gt; &lt; Qp : Cp | attsp &gt;</p>
    <p>M1  Mq</p>
    <p>if Cond .</p>
  </div>
  <div class="page">
    <p>Maude</p>
    <p>A simple example</p>
    <p>class Account | balance : Int . msg deposit : Oid Int -&gt; Msg . msg transfer : Oid Oid Int -&gt; Msg .</p>
    <p>crl [1] : &lt; O : Account | balance : N &gt; deposit(O,M)</p>
    <p>=&gt; &lt; O : Account | balance : N + M &gt; if M &gt; 0 .</p>
    <p>crl [2] : &lt; A : Account | balance : N &gt; &lt; B : Account | balance : M &gt; transfer(A,B,X)</p>
    <p>=&gt; &lt; A : Account | balance : N -X &gt; &lt; B : Account | balance : M + X &gt;</p>
    <p>if X &lt;= M .</p>
  </div>
  <div class="page">
    <p>Modeling the CV in Maude</p>
    <p>Mappings</p>
    <p>ODP conceptODP concept Maude conceptMaude concept Computational object template Maude class</p>
    <p>(inheriting from CV-Object)</p>
    <p>Computational object Maude object</p>
    <p>Computational object configuration</p>
    <p>Maude Configuration</p>
    <p>Binding object Maude object</p>
    <p>Signals Maude messages</p>
    <p>Operations and Flows In terms of signals</p>
    <p>Computational interfaces Maude object (inheriting from class CVInterface)</p>
    <p>Behaviour specification Rewrite rules</p>
    <p>Environment contracts a) Guards on rewrite rules b) Invariants</p>
  </div>
  <div class="page">
    <p>Modeling the CV in Maude</p>
    <p>An abstract platform (CV</p>
    <p>Infrastructure) provides the basic</p>
    <p>concepts and mechanisms</p>
    <p>defined in the ODP Computational</p>
    <p>Viewpoint</p>
    <p>CV Infrastructure (I)</p>
    <p>class CV-Object | conf : Configuration .</p>
    <p>class CV-Interface | uniqueId : Oid,</p>
    <p>objectRole : Causality, bind : Oid, input : Configuration, output : Configuration .</p>
    <p>Two basic classes: CV-Object and CV-Interface.</p>
  </div>
  <div class="page">
    <p>Modeling the CV in Maude</p>
    <p>The CV Infrastructure also provides some predefined operations to Maude objects representing computational objects:</p>
    <p>CV Infrastructure (and II)</p>
    <p>Initiate signal (message M) at interface I:</p>
    <p>send(I, M)  Signal (message M) from object O at I received at local</p>
    <p>interface I:</p>
    <p>receive(O, I, I, M) Instantiate computational interface template: instantiateInterface(..)</p>
    <p>Create binding from interface I to I and destroy a binding in I: bind(I, I) unBind(I)</p>
    <p>Use Trading Function to search for an interface: lookup(UID, IFClass, O) lookupResponse(UID, IFClass, O, I)</p>
    <p>Instantiate computational object template:</p>
    <p>instantiateObject(..)</p>
  </div>
  <div class="page">
    <p>Exampl e</p>
    <p>A multimedia system composed by listeners who want to receive a</p>
    <p>udio frames from an audio streamer (i.e. Internet radio station).</p>
    <p>A binding object manages the multicast of audio frames from a a</p>
    <p>udio streamer to its registered listeners. It control QoS parameters.</p>
    <p>A service manager object de-/registers and manages the listener s</p>
    <p>elections.</p>
    <p>Description</p>
  </div>
  <div class="page">
    <p>Exampl e</p>
    <p>The Maude specification  same as the CV specification</p>
    <p>is divided into three parts: 1. Computational templates 2. Behaviour specifications 3. Initial configuration</p>
    <p>Maude modules provide the mechanisms to support</p>
    <p>them</p>
    <p>An example of a computational interface template is:</p>
    <p>Formalizing Objects and Interfaces</p>
    <p>(omod IAUDIOCHANNEL-TEMPLATE is pr CV-INTERFACE .</p>
    <p>class IAudioChannel . subclass IAudioChannel &lt; CV-Interface .</p>
    <p>msg selectAudioStreamer : Qid -&gt; Msg . msg selectAudioStreamerResponse : Qid Oid -&gt; Msg . msg selectAudioStreamerFailure : Qid -&gt; Msg .</p>
    <p>endom)</p>
  </div>
  <div class="page">
    <p>Exampl e</p>
    <p>For each computational object, we specify (in terms</p>
    <p>of Maude rules) how interactions are achieved and</p>
    <p>how the system evolves</p>
    <p>Formalizing Behaviour</p>
    <p>crl [selectAudioStreamer-failure]: &lt; O : ServiceMgr | streams : PF, conf : ( receive(O, I, I, selectAudioStreamer (Q))</p>
    <p>&lt; I : IAudioChannel | bind : BO, objectRole : server, uniqueId : IAudioChannel &gt;</p>
    <p>CONF ) &gt; =&gt; &lt; O : ServiceMgr | conf : ( send(I, selectAudioStreamerFailure(Q))</p>
    <p>&lt; I : IAudioChannel | &gt; CONF ) &gt;</p>
    <p>if BO =/= nil and search(PF, Q) == null .</p>
    <p>A failure indication is A failure indication is returned to the returned to the listenerlistener</p>
    <p>A listener requests its A listener requests its service manager to service manager to select the channel select the channel defined by parameter defined by parameter QQ</p>
    <p>Only if the binding is established and the service Only if the binding is established and the service manager does not know anything about channel manager does not know anything about channel QQ</p>
  </div>
  <div class="page">
    <p>Why should we?</p>
    <p>Maude is executable and counts with a toolkit that allows formal</p>
    <p>reasoning of the specifications produced:</p>
    <p>Run-time verification</p>
    <p>Model checking</p>
    <p>Monitoring</p>
    <p>Theorem proving</p>
    <p>etc</p>
    <p>We can see how the system behaves based on its specifications (more than 3 million rewrites per second on standard PCs)</p>
    <p>We can check some properties of the system</p>
    <p>We can make the Maude specifications co-exist with partial impl</p>
    <p>ementations</p>
    <p>Advantages of Maude</p>
  </div>
  <div class="page">
    <p>Example s</p>
    <p>We can (model)check whether a given predicate will hold for t</p>
    <p>he system:</p>
    <p>Maude&gt; (mc initState |=t &gt; [] ~ duplicatedFrame in time &lt; 1000 .) Result Bool :</p>
    <p>true</p>
    <p>Maude&gt; (mc initState |=t &gt; [] ~ unOrderedFrame in time &lt; 1000 .) Result ModelCheckResult :</p>
    <p>counterexample(  )</p>
    <p>Maude&gt; (mc initState |=t &gt; &lt;&gt; allFramesArrive with no time limit .) Result Bool :</p>
    <p>true</p>
    <p>Reasoning about the system</p>
  </div>
  <div class="page">
    <p>Conclusions  Maude seems to be a good alternative for specifying the ODP CV</p>
    <p>More expressive than other formal languages</p>
    <p>(Z,Object-Z)</p>
    <p>Executable specifications</p>
    <p>Counts with a Toolkit for formal analysis of</p>
    <p>systems Use Maude to support (i.e., provide some semantics for)</p>
    <p>other graphical notations that can be more sexy for</p>
    <p>specifying ODP systems (e.g. UML!)</p>
    <p>Make the Maude toolkit available from a UML</p>
    <p>environment</p>
    <p>Prototyping of UML specs of ODP systems</p>
    <p>Model checking of UML specs of ODP systems</p>
    <p>Our plans now</p>
    <p>It is verbose and not very appealing, though.</p>
    <p>Tool Support for ODP!</p>
  </div>
  <div class="page">
    <p>Thanks!</p>
    <p>Ral Romero and Antonio Vallecillo</p>
    <p>Dpto. Lenguajes y Ciencias de la Computacin</p>
    <p>Universidad de Mlaga, Spain</p>
    <p>{jrromero, av}@lcc.uma.es</p>
    <p>EDOC 2004</p>
  </div>
</Presentation>
