<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Constant-Time Callees with Variable-Time Callers</p>
    <p>Cesar Pereida Garca Billy Bob Brumley</p>
    <p>Tampere University of Technology Finland</p>
  </div>
  <div class="page">
    <p>Enabling Cache-Timing Attacks</p>
    <p>Outline</p>
    <p>Motivation  Brief History of Cache-Timing Attacks</p>
    <p>Recipe for Side-Channel Attacks  Step 1, 2, 3, 4 and 5</p>
    <p>End-to-End Cache-Attack  TLS &amp; SSH  Crypto libraries</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Enabling Cache-Timing Attacks</p>
    <p>https://source.ggy.bris.ac.uk/mediawiki/index.php?title=File:Memory-Hierarchy.jpg&amp;limit=500</p>
  </div>
  <div class="page">
    <p>Brief History of Cache-Timing Attacks</p>
    <p>for Public Key Cryptography in OpenSSL</p>
  </div>
  <div class="page">
    <p>ECDSA DSARSA</p>
    <p>ECDSA</p>
    <p>DSA RSA</p>
    <p>O p</p>
    <p>e n S</p>
    <p>S L</p>
    <p>V e</p>
    <p>rs io</p>
    <p>n</p>
    <p>Year</p>
    <p>Cryptosystem</p>
    <p>Cache-Timing Attacks for Public Key Cryptography</p>
  </div>
  <div class="page">
    <p>ECDSA</p>
    <p>DSA RSA</p>
    <p>O p</p>
    <p>e n</p>
    <p>S S</p>
    <p>L V</p>
    <p>e rs</p>
    <p>io n</p>
    <p>Year</p>
    <p>Cryptosystem</p>
    <p>Relevant Changes Introduced due to Cache-Timing Attacks</p>
    <p>EC_GFp_nistp256_method: Constant-time scalar multiplication (fixed window &amp; masking)</p>
    <p>Research shifts to secp256k1 (wNAF)</p>
  </div>
  <div class="page">
    <p>Recipe for Side-Channel Attacks on Digital</p>
    <p>Signatures</p>
  </div>
  <div class="page">
    <p>Recipe for a Side-Channel Attack</p>
    <p>Et voil, you have a private key.</p>
  </div>
  <div class="page">
    <p>Step 1 Take a primitive and an</p>
    <p>algorithm that uses confidential data</p>
  </div>
  <div class="page">
    <p>Signing:</p>
    <p>Given:</p>
    <p>Constant-Time Scalar by Point Multiplication</p>
    <p>ECDSA</p>
    <p>Note: Nonce k is recoverable if at least 3 bits are leaked for each signature.</p>
    <p>Modular Inversion?</p>
  </div>
  <div class="page">
    <p>Modular Inversion (OpenSSL 1.0.1)</p>
  </div>
  <div class="page">
    <p>Binary Extended Euclidean Algorithm</p>
    <p>Fact Cache-Attack</p>
    <p>OpenSSL BBEA</p>
    <p>Number of right-shifts on v</p>
    <p>Number of right-shifts on u</p>
    <p>Number and order of subtractions on v</p>
    <p>Number and order of subtractions on u</p>
    <p>Only one loop per iteration</p>
    <p>U loop is the only loop that can be executed during the first iteration</p>
    <p>k is protected, i.e. padded with modulus n</p>
    <p>BN_rshift1</p>
    <p>BN_usub</p>
  </div>
  <div class="page">
    <p>Step 2 Measure the</p>
    <p>Side-Channel Leakage</p>
  </div>
  <div class="page">
    <p>Flush+Reload[1] on the BEEA</p>
    <p>[1] Yarom, Yuval, and Katrina Falkner. &quot;FLUSH+ RELOAD: A High Resolution, Low Noise, L3 Cache Side-Channel Attack.&quot; USENIX. 2014.</p>
    <p>BN_rshift1</p>
    <p>BN_usub</p>
  </div>
  <div class="page">
    <p>Improved Performance Degradation</p>
    <p>Objective: Identify the addresses with the highest impact  Better probing  Better degradation</p>
    <p>BN_mod_inverse  0xE7940 BN_rshift1  0xE48E0 BN_usub  0xD7B00 BN_uadd  0xD7800 BN_rshift  0xDDFC0</p>
    <p>counters (perf).</p>
  </div>
  <div class="page">
    <p>Setup and Attack Scenario</p>
    <p>Setup  Intel Core i5-2400</p>
    <p>Sandy Bridge 3.10 GHz</p>
    <p>8 GB memory  Ubuntu 16.04 LTS</p>
    <p>Xenial 64-bits  OpenSSL 1.0.1u</p>
  </div>
  <div class="page">
    <p>Step 3 Apply Signal Processing</p>
  </div>
  <div class="page">
    <p>Signal Processing Trace  Template &amp;</p>
    <p>Cross-correlation  Apply moving average.  Raw  Clean  Translate to LS sequence</p>
    <p>LSLLSLSL...</p>
  </div>
  <div class="page">
    <p>Step 4 Recover Bits</p>
  </div>
  <div class="page">
    <p>Bit Recovery</p>
    <p>LSLLSLSL... 01001010...</p>
    <p>SLLLLL... 100000...</p>
  </div>
  <div class="page">
    <p>Bit Recovery</p>
    <p>Bits &gt;= 3 Length L=5</p>
  </div>
  <div class="page">
    <p>Bit Recovery</p>
  </div>
  <div class="page">
    <p>Step 5 Lattice Attack</p>
  </div>
  <div class="page">
    <p>Lattice Attack Input parameters to Lattice:  Bits recovered  Messages  Signatures</p>
    <p>Lattice information:  Dimension d + 2  Implemented in Sage  BKZ reduction (block size 30)</p>
    <p>[8] Cabrera Aldaya et al. &quot;SPA vulnerabilities of the binary extended Euclidean algorithm.&quot; Journal of Cryptographic Engineering (2016): 1-13.</p>
  </div>
  <div class="page">
    <p>End-to-End Protocol Attack</p>
  </div>
  <div class="page">
    <p>End-to-End Protocol Attack</p>
  </div>
  <div class="page">
    <p>Crypto libraries are a prime target for CTA!  We offered a patch to the libraries  OpenSSL 1.0.1 development reached EOL starting January 2017.  OpenSSL 1.0.1 shipped with Ubuntu LTS 12.04 and 14.04; Debian</p>
    <p>Cryptographic Libraries</p>
  </div>
  <div class="page">
    <p>Constant-time implementations need to be tested.  The BEEA modular inversion enables practical</p>
    <p>cache-timing attacks.  The performance degradation technique improves</p>
    <p>trace quality.  Different key bit recovery approaches are possible.  Cache-Timing attacks are increasing in popularity and</p>
    <p>complexity every year.</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Thank you Questions?</p>
  </div>
</Presentation>
