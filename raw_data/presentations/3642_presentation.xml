<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Pancake: Frequency Smoothing for Encrypted</p>
    <p>Data Stores</p>
    <p>Paul Grubbs*,2, Anurag Khandelwal*,1, Marie-Sarah Lacharit*,2, Lloyd Brown4, Lucy Li2, Rachit Agrawal3, Thomas Ristenpart2</p>
    <p>*Equal contribution authors</p>
  </div>
  <div class="page">
    <p>Cloud Data Stores</p>
  </div>
  <div class="page">
    <p>Cloud Data Stores</p>
    <p>Cloud Storage (Key-Value Store, e.g., ElastiCache, Amazon S3)</p>
    <p>Transition to cloud hosted data stores for ease-ofmanagement, scalability &amp; cost-efficiency</p>
  </div>
  <div class="page">
    <p>Cloud Data Stores</p>
    <p>Cloud Storage (Key-Value Store, e.g., ElastiCache, Amazon S3)</p>
    <p>KV1</p>
    <p>KV2</p>
    <p>KV3</p>
    <p>KV4</p>
    <p>Transition to cloud hosted data stores for ease-ofmanagement, scalability &amp; cost-efficiency</p>
  </div>
  <div class="page">
    <p>Cloud Data Stores</p>
    <p>Client</p>
    <p>Client</p>
    <p>Client</p>
    <p>Cloud Storage (Key-Value Store, e.g., ElastiCache, Amazon S3)</p>
    <p>KV1</p>
    <p>KV2</p>
    <p>KV3</p>
    <p>KV4</p>
    <p>Transition to cloud hosted data stores for ease-ofmanagement, scalability &amp; cost-efficiency</p>
  </div>
  <div class="page">
    <p>Cloud Data Stores</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Client</p>
    <p>Client</p>
    <p>Cloud Storage (Key-Value Store, e.g., ElastiCache, Amazon S3)</p>
    <p>KV1</p>
    <p>KV2</p>
    <p>KV3</p>
    <p>KV4</p>
    <p>Transition to cloud hosted data stores for ease-ofmanagement, scalability &amp; cost-efficiency</p>
  </div>
  <div class="page">
    <p>Cloud Data Stores</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Client</p>
    <p>Client</p>
    <p>Untrusted</p>
    <p>Cloud Storage (Key-Value Store, e.g., ElastiCache, Amazon S3)</p>
    <p>KV1</p>
    <p>KV2</p>
    <p>KV3</p>
    <p>KV4</p>
    <p>Transition to cloud hosted data stores for ease-ofmanagement, scalability &amp; cost-efficiency</p>
  </div>
  <div class="page">
    <p>Cloud Data Stores</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Client</p>
    <p>Client</p>
    <p>Untrusted</p>
    <p>Cloud Storage (Key-Value Store, e.g., ElastiCache, Amazon S3)</p>
    <p>KV1</p>
    <p>KV2</p>
    <p>KV3</p>
    <p>KV4</p>
    <p>Transition to cloud hosted data stores for ease-ofmanagement, scalability &amp; cost-efficiency</p>
    <p>Key-value pairs encrypted for security</p>
  </div>
  <div class="page">
    <p>Access Pattern Attacks</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Client</p>
    <p>Client</p>
    <p>Untrusted</p>
    <p>KV1</p>
    <p>KV2</p>
    <p>KV3</p>
    <p>KV4</p>
    <p>Cloud Storage (Key-Value Store, e.g., ElastiCache, Amazon S3)</p>
  </div>
  <div class="page">
    <p>Access Pattern Attacks</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Client</p>
    <p>Client</p>
    <p>Untrusted</p>
    <p>KV1</p>
    <p>KV2</p>
    <p>KV3</p>
    <p>KV4</p>
    <p>Cloud Storage (Key-Value Store, e.g., ElastiCache, Amazon S3)</p>
    <p>Key: Patient Condition Value: Patient Record</p>
  </div>
  <div class="page">
    <p>Access Pattern Attacks</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Client</p>
    <p>Client</p>
    <p>Untrusted</p>
    <p>KV1</p>
    <p>KV2</p>
    <p>KV3</p>
    <p>KV4</p>
    <p>Cloud Storage (Key-Value Store, e.g., ElastiCache, Amazon S3)</p>
    <p>A ccess Freq</p>
    <p>uencies</p>
    <p>Key: Patient Condition Value: Patient Record</p>
  </div>
  <div class="page">
    <p>Prior Knowledge</p>
    <p>Access Pattern Attacks</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Client</p>
    <p>Client</p>
    <p>Untrusted</p>
    <p># C</p>
    <p>as es</p>
    <p>D ia</p>
    <p>b et</p>
    <p>es</p>
    <p>C an</p>
    <p>ce r</p>
    <p>A st</p>
    <p>hm a</p>
    <p>Ep ile</p>
    <p>p sy</p>
    <p>KV1</p>
    <p>KV2</p>
    <p>KV3</p>
    <p>KV4</p>
    <p>Cloud Storage (Key-Value Store, e.g., ElastiCache, Amazon S3)</p>
    <p>A ccess Freq</p>
    <p>uencies</p>
    <p>Key: Patient Condition Value: Patient Record</p>
  </div>
  <div class="page">
    <p>Prior Knowledge</p>
    <p>Access Pattern Attacks</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Client</p>
    <p>Client</p>
    <p>Untrusted</p>
    <p># C</p>
    <p>as es</p>
    <p>D ia</p>
    <p>b et</p>
    <p>es</p>
    <p>C an</p>
    <p>ce r</p>
    <p>A st</p>
    <p>hm a</p>
    <p>Ep ile</p>
    <p>p sy</p>
    <p>KV1</p>
    <p>KV2</p>
    <p>KV3</p>
    <p>KV4</p>
    <p>Cloud Storage (Key-Value Store, e.g., ElastiCache, Amazon S3)</p>
    <p>A ccess Freq</p>
    <p>uencies</p>
    <p>Key: Patient Condition Value: Patient Record</p>
  </div>
  <div class="page">
    <p>Prior Knowledge</p>
    <p>Access Pattern Attacks</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Client</p>
    <p>Client</p>
    <p>Untrusted</p>
    <p># C</p>
    <p>as es</p>
    <p>D ia</p>
    <p>b et</p>
    <p>es</p>
    <p>C an</p>
    <p>ce r</p>
    <p>A st</p>
    <p>hm a</p>
    <p>Ep ile</p>
    <p>p sy</p>
    <p>KV1</p>
    <p>KV2</p>
    <p>KV3</p>
    <p>KV4</p>
    <p>Cancer Patient</p>
    <p>Cloud Storage (Key-Value Store, e.g., ElastiCache, Amazon S3)</p>
    <p>A ccess Freq</p>
    <p>uencies</p>
    <p>Key: Patient Condition Value: Patient Record</p>
  </div>
  <div class="page">
    <p>Prior Knowledge</p>
    <p>Access Pattern Attacks</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Client</p>
    <p>Client</p>
    <p>Untrusted</p>
    <p># C</p>
    <p>as es</p>
    <p>D ia</p>
    <p>b et</p>
    <p>es</p>
    <p>C an</p>
    <p>ce r</p>
    <p>A st</p>
    <p>hm a</p>
    <p>Ep ile</p>
    <p>p sy</p>
    <p>KV1</p>
    <p>KV2</p>
    <p>KV3</p>
    <p>KV4</p>
    <p>Cancer Patient</p>
    <p>Cloud Storage (Key-Value Store, e.g., ElastiCache, Amazon S3)</p>
    <p>Many practical attacks: [IKK NDSS12], [CGPR CCS15], [KKNO CCS16], [GLMP S&amp;P19], [KPT S&amp;P19]</p>
    <p>A ccess Freq</p>
    <p>uencies</p>
    <p>Key: Patient Condition Value: Patient Record</p>
  </div>
  <div class="page">
    <p>Existing Solutions</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>KV1 KV2 KV3 KV4</p>
  </div>
  <div class="page">
    <p>Existing Solutions</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Active AdversaryThreat model</p>
    <p>ORAM, PIRApproach</p>
  </div>
  <div class="page">
    <p>Existing Solutions</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Active AdversaryThreat model</p>
    <p>ORAM, PIR</p>
    <p>Poor</p>
    <p>Strong</p>
    <p>Approach</p>
    <p>Security</p>
    <p>Performance</p>
  </div>
  <div class="page">
    <p>Existing Solutions</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Active AdversaryThreat model</p>
    <p>ORAM, PIR</p>
    <p>Poor</p>
    <p>Strong</p>
    <p>Approach</p>
    <p>Security</p>
    <p>Performance O(log n) bandwidth lower bound [BN ITCS16, LN CRYPTO19, ]</p>
  </div>
  <div class="page">
    <p>Snapshot Adversary</p>
    <p>SSE</p>
    <p>Existing Solutions</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Active AdversaryThreat model</p>
    <p>ORAM, PIR</p>
    <p>Poor</p>
    <p>Strong</p>
    <p>Approach</p>
    <p>Security</p>
    <p>Performance</p>
  </div>
  <div class="page">
    <p>Snapshot Adversary</p>
    <p>Weak</p>
    <p>High</p>
    <p>SSE</p>
    <p>Existing Solutions</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Active AdversaryThreat model</p>
    <p>ORAM, PIR</p>
    <p>Poor</p>
    <p>Strong</p>
    <p>Approach</p>
    <p>Security</p>
    <p>Performance</p>
  </div>
  <div class="page">
    <p>Snapshot Adversary</p>
    <p>Weak</p>
    <p>High</p>
    <p>SSE</p>
    <p>Existing Solutions</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Active AdversaryThreat model</p>
    <p>ORAM, PIR</p>
    <p>Poor</p>
    <p>Strong</p>
    <p>Approach</p>
    <p>Security</p>
    <p>Performance</p>
    <p>Unrealistic threat model [GRS HotOS17]</p>
  </div>
  <div class="page">
    <p>Snapshot Adversary</p>
    <p>Weak</p>
    <p>High</p>
    <p>SSE</p>
    <p>Existing Solutions</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Persistent Passive AdversaryActive AdversaryThreat model</p>
    <p>ORAM, PIR</p>
    <p>Poor</p>
    <p>Strong</p>
    <p>Approach</p>
    <p>Security</p>
    <p>Performance</p>
  </div>
  <div class="page">
    <p>Snapshot Adversary</p>
    <p>Weak</p>
    <p>High</p>
    <p>SSE</p>
    <p>Existing Solutions</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Persistent Passive AdversaryActive AdversaryThreat model</p>
    <p>ORAM, PIR</p>
    <p>Poor</p>
    <p>Captures many real-world cloud deployments</p>
    <p>Strong</p>
    <p>Approach</p>
    <p>Security</p>
    <p>Performance</p>
  </div>
  <div class="page">
    <p>Snapshot Adversary</p>
    <p>Weak</p>
    <p>High</p>
    <p>SSE</p>
    <p>Existing Solutions</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Persistent Passive AdversaryActive AdversaryThreat model</p>
    <p>ORAM, PIR</p>
    <p>Poor</p>
    <p>Captures many real-world cloud deployments</p>
    <p>Strong</p>
    <p>Can we achieve low performance overheads?</p>
    <p>?Approach Security</p>
    <p>Performance</p>
  </div>
  <div class="page">
    <p>KV1 KV2 KV3 KV4</p>
    <p>Can we do better?</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>KV1 KV2 KV3 KV4</p>
  </div>
  <div class="page">
    <p>KV1 KV2 KV3 KV4</p>
    <p>Can we do better?</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>KV1 KV2 KV3 KV4</p>
  </div>
  <div class="page">
    <p>KV1 KV2 KV3 KV4</p>
    <p>Can we do better?</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
  </div>
  <div class="page">
    <p>KV1 KV2 KV3 KV4</p>
    <p>Can we do better?</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
    <p>KV store clients already maintain statistics about access distributions (e.g., for caching)</p>
  </div>
  <div class="page">
    <p>KV1 KV2 KV3 KV4</p>
    <p>Can we do better?</p>
    <p>Key Contributions</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
  </div>
  <div class="page">
    <p>KV1 KV2 KV3 KV4</p>
    <p>Can we do better?</p>
    <p>Pancake: use frequency smoothing over known access distribution to provide security against access pattern attacks with constant server storage &amp; bandwidth overheads</p>
    <p>Key Contributions</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
  </div>
  <div class="page">
    <p>KV1 KV2 KV3 KV4</p>
    <p>Can we do better?</p>
    <p>Pancake: use frequency smoothing over known access distribution to provide security against access pattern attacks with constant server storage &amp; bandwidth overheads</p>
    <p>Key Contributions</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
    <p>KV1 KV2 KV3 KV4KV1</p>
  </div>
  <div class="page">
    <p>KV1 KV2 KV3 KV4</p>
    <p>Can we do better?</p>
    <p>Pancake: use frequency smoothing over known access distribution to provide security against access pattern attacks with constant server storage &amp; bandwidth overheads</p>
    <p>Formal security analysis showing passive persistent security  Comprehensive evaluation shows throughput &gt; 2 orders of magnitude higher than</p>
    <p>state-of-the art (PathORAM)!</p>
    <p>Key Contributions</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
    <p>KV1 KV2 KV3 KV4KV1</p>
  </div>
  <div class="page">
    <p>Model: Queries drawn from distribution over keys, known to both system &amp; adversary</p>
    <p>Frequency Smoothing</p>
  </div>
  <div class="page">
    <p>Model: Queries drawn from distribution over keys, known to both system &amp; adversary</p>
    <p>Approach: Transform to a smooth distribution over (potentially larger set of) encrypted items</p>
    <p>Frequency Smoothing</p>
  </div>
  <div class="page">
    <p>KV1 KV2 KV3 KV4</p>
    <p>A cc</p>
    <p>es s</p>
    <p>D is</p>
    <p>tr ib</p>
    <p>ut io</p>
    <p>n</p>
    <p>Model: Queries drawn from distribution over keys, known to both system &amp; adversary</p>
    <p>Approach: Transform to a smooth distribution over (potentially larger set of) encrypted items</p>
    <p>Frequency Smoothing</p>
  </div>
  <div class="page">
    <p>KV1 KV2 KV3 KV4</p>
    <p>A cc</p>
    <p>es s</p>
    <p>D is</p>
    <p>tr ib</p>
    <p>ut io</p>
    <p>n</p>
    <p>Idea#1: Replication Replicate popular items  uniform distribution across replicas</p>
    <p>Model: Queries drawn from distribution over keys, known to both system &amp; adversary</p>
    <p>Approach: Transform to a smooth distribution over (potentially larger set of) encrypted items</p>
    <p>Frequency Smoothing</p>
  </div>
  <div class="page">
    <p>KV1 KV2 KV3 KV4</p>
    <p>A cc</p>
    <p>es s</p>
    <p>D is</p>
    <p>tr ib</p>
    <p>ut io</p>
    <p>n</p>
    <p>KV1KV1KV1 KV1 KV3 KV3 KV3 KV3KV2 KV2 KV2 KV2</p>
    <p>Idea#1: Replication Replicate popular items  uniform distribution across replicas</p>
    <p>Model: Queries drawn from distribution over keys, known to both system &amp; adversary</p>
    <p>Approach: Transform to a smooth distribution over (potentially larger set of) encrypted items</p>
    <p>Frequency Smoothing</p>
  </div>
  <div class="page">
    <p>KV1 KV2 KV3 KV4</p>
    <p>A cc</p>
    <p>es s</p>
    <p>D is</p>
    <p>tr ib</p>
    <p>ut io</p>
    <p>n</p>
    <p>KV1KV1KV1 KV1 KV3 KV3 KV3 KV3KV2 KV2 KV2 KV2</p>
    <p>Idea#1: Replication Replicate popular items  uniform distribution across replicas</p>
    <p>Problem: May need a lot of server-side storage</p>
    <p>Model: Queries drawn from distribution over keys, known to both system &amp; adversary</p>
    <p>Approach: Transform to a smooth distribution over (potentially larger set of) encrypted items</p>
    <p>Frequency Smoothing</p>
  </div>
  <div class="page">
    <p>KV1 KV2 KV3 KV4</p>
    <p>A cc</p>
    <p>es s</p>
    <p>D is</p>
    <p>tr ib</p>
    <p>ut io</p>
    <p>n</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>A cc</p>
    <p>es s</p>
    <p>D is</p>
    <p>tr ib</p>
    <p>ut io</p>
    <p>n</p>
    <p>KV1KV1KV1 KV1 KV3 KV3 KV3 KV3KV2 KV2 KV2 KV2</p>
    <p>Idea#1: Replication Replicate popular items  uniform distribution across replicas</p>
    <p>Problem: May need a lot of server-side storage</p>
    <p>Idea#2: Fake Accesses Fake accesses to unpopular items  uniform distribution across items 7</p>
    <p>Model: Queries drawn from distribution over keys, known to both system &amp; adversary</p>
    <p>Approach: Transform to a smooth distribution over (potentially larger set of) encrypted items</p>
    <p>Frequency Smoothing</p>
  </div>
  <div class="page">
    <p>KV1 KV2 KV3 KV4</p>
    <p>A cc</p>
    <p>es s</p>
    <p>D is</p>
    <p>tr ib</p>
    <p>ut io</p>
    <p>n</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>A cc</p>
    <p>es s</p>
    <p>D is</p>
    <p>tr ib</p>
    <p>ut io</p>
    <p>n</p>
    <p>KV1KV1KV1 KV1 KV3 KV3 KV3 KV3KV2 KV2 KV2 KV2</p>
    <p>Idea#1: Replication Replicate popular items  uniform distribution across replicas</p>
    <p>Problem: May need a lot of server-side storage</p>
    <p>Idea#2: Fake Accesses Fake accesses to unpopular items  uniform distribution across items 7</p>
    <p>Model: Queries drawn from distribution over keys, known to both system &amp; adversary</p>
    <p>Approach: Transform to a smooth distribution over (potentially larger set of) encrypted items</p>
    <p>Frequency Smoothing</p>
  </div>
  <div class="page">
    <p>KV1 KV2 KV3 KV4</p>
    <p>A cc</p>
    <p>es s</p>
    <p>D is</p>
    <p>tr ib</p>
    <p>ut io</p>
    <p>n</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>A cc</p>
    <p>es s</p>
    <p>D is</p>
    <p>tr ib</p>
    <p>ut io</p>
    <p>n</p>
    <p>KV1KV1KV1 KV1 KV3 KV3 KV3 KV3KV2 KV2 KV2 KV2</p>
    <p>Idea#1: Replication Replicate popular items  uniform distribution across replicas</p>
    <p>Problem: May need a lot of server-side storage</p>
    <p>Idea#2: Fake Accesses Fake accesses to unpopular items  uniform distribution across items</p>
    <p>Problem: May add a lot of bandwidth overheads</p>
    <p>Model: Queries drawn from distribution over keys, known to both system &amp; adversary</p>
    <p>Approach: Transform to a smooth distribution over (potentially larger set of) encrypted items</p>
    <p>Frequency Smoothing</p>
  </div>
  <div class="page">
    <p>Pancake</p>
    <p>Combine replication and fake accesses!</p>
    <p>Model: Queries drawn from distribution over keys, known to both system &amp; adversary</p>
  </div>
  <div class="page">
    <p>Pancake</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Combine replication and fake accesses!</p>
    <p>Model: Queries drawn from distribution over keys, known to both system &amp; adversary</p>
  </div>
  <div class="page">
    <p>Pancake</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Combine replication and fake accesses!</p>
    <p>KV1 KV1 KV2 KV2 KV3 KV3 KV4</p>
    <p>KV1 KV1 KV1 KV2 KV3 KV4</p>
    <p>Step 1: Replication - Create just enough replicas to partially smooth out distribution with bounded storage</p>
    <p>Model: Queries drawn from distribution over keys, known to both system &amp; adversary</p>
  </div>
  <div class="page">
    <p>Pancake</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Combine replication and fake accesses!</p>
    <p>KV1 KV1 KV2 KV2 KV3 KV3 KV4</p>
    <p>KV1 KV1 KV1 KV2 KV3 KV4</p>
    <p>Step 1: Replication - Create just enough replicas to partially smooth out distribution with bounded storage</p>
    <p>At most 2x total KV pairs</p>
    <p>Model: Queries drawn from distribution over keys, known to both system &amp; adversary</p>
  </div>
  <div class="page">
    <p>Pancake</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Combine replication and fake accesses!</p>
    <p>KV1 KV1 KV2 KV2 KV3 KV3 KV4</p>
    <p>KV1 KV1 KV1 KV2 KV3 KV4</p>
    <p>Step 1: Replication - Create just enough replicas to partially smooth out distribution with bounded storage</p>
    <p>Step 2: Add fake access distribution to smooth out the resulting distribution completelyf</p>
    <p>At most 2x total KV pairs</p>
    <p>Model: Queries drawn from distribution over keys, known to both system &amp; adversary</p>
  </div>
  <div class="page">
    <p>Pancake</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>KV1 KV2 KV3 KV4</p>
    <p>Combine replication and fake accesses!</p>
    <p>KV1 KV1 KV2 KV2 KV3 KV3 KV4</p>
    <p>KV1 KV1 KV1 KV2 KV3 KV4</p>
    <p>Step 1: Replication - Create just enough replicas to partially smooth out distribution with bounded storage</p>
    <p>Step 2: Add fake access distribution to smooth out the resulting distribution completelyf</p>
    <p>At most 2x total KV pairs</p>
    <p>At most one fake access (from ) per real access (from )f  8</p>
    <p>Model: Queries drawn from distribution over keys, known to both system &amp; adversary</p>
  </div>
  <div class="page">
    <p>Pancake Combine replication and fake accesses!</p>
  </div>
  <div class="page">
    <p>Pancake Combine replication and fake accesses!</p>
    <p>Pancake Logic</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
  </div>
  <div class="page">
    <p>Challenge: How to issue fake+real accesses without revealing which is which?</p>
    <p>Pancake Combine replication and fake accesses!</p>
    <p>Pancake Logic</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
  </div>
  <div class="page">
    <p>Challenge: How to issue fake+real accesses without revealing which is which?</p>
    <p>Approach: Send fi xed-size batches of real+fake accesses per query</p>
    <p>Pancake Combine replication and fake accesses!</p>
    <p>Pancake Logic</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
  </div>
  <div class="page">
    <p>Pancake Combine replication and fake accesses!</p>
    <p>Pancake Logic</p>
    <p>Every time a new query arrives, enqueue it</p>
    <p>q1</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
  </div>
  <div class="page">
    <p>Pancake Combine replication and fake accesses!</p>
    <p>Pancake Logic</p>
    <p>Every time a new query arrives, enqueue it</p>
    <p>q1</p>
    <p>and flip B coins</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
  </div>
  <div class="page">
    <p>Pancake Combine replication and fake accesses!</p>
    <p>Pancake Logic</p>
    <p>Every time a new query arrives, enqueue it</p>
    <p>q1</p>
    <p>B=3</p>
    <p>TTH</p>
    <p>and flip B coins</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
  </div>
  <div class="page">
    <p>Pancake Combine replication and fake accesses!</p>
    <p>Pancake Logic</p>
    <p>Every time a new query arrives, enqueue it If heads, dequeue a real query (or draw from )</p>
    <p>q1</p>
    <p>B=3</p>
    <p>TTH</p>
    <p>and flip B coins</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
  </div>
  <div class="page">
    <p>Pancake Combine replication and fake accesses!</p>
    <p>Pancake Logic</p>
    <p>Every time a new query arrives, enqueue it If heads, dequeue a real query (or draw from )</p>
    <p>q1</p>
    <p>B=3</p>
    <p>TTH</p>
    <p>and flip B coins</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
  </div>
  <div class="page">
    <p>Pancake Combine replication and fake accesses!</p>
    <p>Pancake Logic</p>
    <p>Every time a new query arrives, enqueue it If heads, dequeue a real query (or draw from ) Else, draw a fake access from f</p>
    <p>q1</p>
    <p>B=3</p>
    <p>TTH</p>
    <p>and flip B coins</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
  </div>
  <div class="page">
    <p>Pancake Combine replication and fake accesses!</p>
    <p>Pancake Logic</p>
    <p>Every time a new query arrives, enqueue it If heads, dequeue a real query (or draw from ) Else, draw a fake access from f</p>
    <p>q1</p>
    <p>B=3</p>
    <p>TTH</p>
    <p>q2 q3</p>
    <p>and flip B coins</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
  </div>
  <div class="page">
    <p>Pancake Combine replication and fake accesses!</p>
    <p>Pancake Logic</p>
    <p>Every time a new query arrives, enqueue it If heads, dequeue a real query (or draw from ) Else, draw a fake access from f</p>
    <p>q1 q2 q3</p>
    <p>and flip B coins</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
  </div>
  <div class="page">
    <p>Pancake Combine replication and fake accesses!</p>
    <p>Pancake Logic</p>
    <p>Every time a new query arrives, enqueue it If heads, dequeue a real query (or draw from ) Else, draw a fake access from f</p>
    <p>bandwidth overhead, storage overhead3   2</p>
    <p>q1 q2 q3</p>
    <p>and flip B coins</p>
    <p>Key-Value Store (e.g., ElastiCache, Amazon S3)</p>
    <p>Untrusted</p>
    <p>Client</p>
    <p>Trusted</p>
    <p>Proxy</p>
  </div>
  <div class="page">
    <p>Pancake Security</p>
  </div>
  <div class="page">
    <p>Pancake Security Assumptions:</p>
  </div>
  <div class="page">
    <p>Pancake Security Assumptions:</p>
    <p>Persistent passive adversary: can observe, but not inject or tamper with accesses</p>
  </div>
  <div class="page">
    <p>Pancake Security Assumptions:</p>
    <p>Persistent passive adversary: can observe, but not inject or tamper with accesses  Pancake has a reasonable estimate of</p>
  </div>
  <div class="page">
    <p>Pancake Security Assumptions:</p>
    <p>Persistent passive adversary: can observe, but not inject or tamper with accesses  Pancake has a reasonable estimate of   Fake &amp; real accesses cannot be distinguished by server (e.g., using timing analysis)</p>
  </div>
  <div class="page">
    <p>Pancake Security Assumptions:</p>
    <p>Persistent passive adversary: can observe, but not inject or tamper with accesses  Pancake has a reasonable estimate of   Fake &amp; real accesses cannot be distinguished by server (e.g., using timing analysis)</p>
    <p>Formal guarantee: Real-versus-random indistinguishability under chosen distribution attack (ROR-CDA)</p>
  </div>
  <div class="page">
    <p>Pancake Security Assumptions:</p>
    <p>Persistent passive adversary: can observe, but not inject or tamper with accesses  Pancake has a reasonable estimate of   Fake &amp; real accesses cannot be distinguished by server (e.g., using timing analysis)</p>
    <p>Formal guarantee: Real-versus-random indistinguishability under chosen distribution attack (ROR-CDA)</p>
    <p>Real world N Pancake replicated + encrypted KV pairs</p>
    <p>KV1</p>
    <p>KV2</p>
    <p>KVN</p>
  </div>
  <div class="page">
    <p>Pancake Security Assumptions:</p>
    <p>Persistent passive adversary: can observe, but not inject or tamper with accesses  Pancake has a reasonable estimate of   Fake &amp; real accesses cannot be distinguished by server (e.g., using timing analysis)</p>
    <p>Formal guarantee: Real-versus-random indistinguishability under chosen distribution attack (ROR-CDA)</p>
    <p>Real world</p>
    <p>+</p>
    <p>N Pancake replicated + encrypted KV pairs</p>
    <p>KV1</p>
    <p>KV2</p>
    <p>KVN</p>
    <p>T encrypted Pancake real + fake KV accesses</p>
    <p>q1 q2 q3 qT</p>
  </div>
  <div class="page">
    <p>Pancake Security Assumptions:</p>
    <p>Persistent passive adversary: can observe, but not inject or tamper with accesses  Pancake has a reasonable estimate of   Fake &amp; real accesses cannot be distinguished by server (e.g., using timing analysis)</p>
    <p>Formal guarantee: Real-versus-random indistinguishability under chosen distribution attack (ROR-CDA)</p>
    <p>Ideal worldReal world</p>
    <p>+</p>
    <p>N Pancake replicated + encrypted KV pairs</p>
    <p>KV1</p>
    <p>KV2</p>
    <p>KVN</p>
    <p>T encrypted Pancake real + fake KV accesses</p>
    <p>q1 q2 q3 qT</p>
    <p>N random bit strings</p>
    <p>s3@#$</p>
    <p>#1j%f</p>
  </div>
  <div class="page">
    <p>Pancake Security Assumptions:</p>
    <p>Persistent passive adversary: can observe, but not inject or tamper with accesses  Pancake has a reasonable estimate of   Fake &amp; real accesses cannot be distinguished by server (e.g., using timing analysis)</p>
    <p>Formal guarantee: Real-versus-random indistinguishability under chosen distribution attack (ROR-CDA)</p>
    <p>Ideal worldReal world</p>
    <p>+</p>
    <p>N Pancake replicated + encrypted KV pairs</p>
    <p>KV1</p>
    <p>KV2</p>
    <p>KVN</p>
    <p>T encrypted Pancake real + fake KV accesses</p>
    <p>q1 q2 q3 qT +</p>
    <p>N random bit strings</p>
    <p>s3@#$</p>
    <p>#1j%f</p>
    <p>T uniform random accesses over N random bit strings</p>
    <p>q1 q2 q3 qT</p>
  </div>
  <div class="page">
    <p>Pancake Security Assumptions:</p>
    <p>Persistent passive adversary: can observe, but not inject or tamper with accesses  Pancake has a reasonable estimate of   Fake &amp; real accesses cannot be distinguished by server (e.g., using timing analysis)</p>
    <p>Formal guarantee: Real-versus-random indistinguishability under chosen distribution attack (ROR-CDA)</p>
    <p>Ideal worldReal world</p>
    <p>Indistinguishable</p>
    <p>+</p>
    <p>N Pancake replicated + encrypted KV pairs</p>
    <p>KV1</p>
    <p>KV2</p>
    <p>KVN</p>
    <p>T encrypted Pancake real + fake KV accesses</p>
    <p>q1 q2 q3 qT +</p>
    <p>N random bit strings</p>
    <p>s3@#$</p>
    <p>#1j%f</p>
    <p>T uniform random accesses over N random bit strings</p>
    <p>q1 q2 q3 qT</p>
  </div>
  <div class="page">
    <p>Pancake: Additional Challenges</p>
  </div>
  <div class="page">
    <p>Pancake: Additional Challenges</p>
    <p>Update KV pair with replicas? Buffer updates to KV replicas</p>
    <p>until next access</p>
  </div>
  <div class="page">
    <p>Pancake: Additional Challenges</p>
    <p>Update KV pair with replicas? Buffer updates to KV replicas</p>
    <p>until next access</p>
    <p>Dynamic access patterns? Adjust fake distribution &amp;</p>
    <p>reassign replicas</p>
  </div>
  <div class="page">
    <p>Pancake: Additional Challenges</p>
    <p>Update KV pair with replicas? Buffer updates to KV replicas</p>
    <p>until next access</p>
    <p>Dynamic access patterns? Adjust fake distribution &amp;</p>
    <p>reassign replicas</p>
    <p>Estimate access distribution, detect distribution changes?</p>
    <p>Sliding-window histograms, two-sample KS test</p>
  </div>
  <div class="page">
    <p>Pancake: Additional Challenges</p>
    <p>Update KV pair with replicas? Buffer updates to KV replicas</p>
    <p>until next access</p>
    <p>Dynamic access patterns? Adjust fake distribution &amp;</p>
    <p>reassign replicas</p>
    <p>Estimate access distribution, detect distribution changes?</p>
    <p>Sliding-window histograms, two-sample KS test</p>
    <p>Details in the paper!</p>
  </div>
  <div class="page">
    <p>Pancake Performance</p>
  </div>
  <div class="page">
    <p>Pancake Performance Cloud Storage: Redis on t3.2xlarge Amazon EC2 instances, Client/Proxy: Amazon EC2 r4.8xlarge instances</p>
  </div>
  <div class="page">
    <p>Pancake Performance Cloud Storage: Redis on t3.2xlarge Amazon EC2 instances, Client/Proxy: Amazon EC2 r4.8xlarge instances</p>
    <p>Dataset: 106 x 1KB key-value pairs, Workload: YCSB Workload A (50% reads + 50% writes)</p>
  </div>
  <div class="page">
    <p>Pancake Performance Cloud Storage: Redis on t3.2xlarge Amazon EC2 instances, Client/Proxy: Amazon EC2 r4.8xlarge instances</p>
    <p>Dataset: 106 x 1KB key-value pairs, Workload: YCSB Workload A (50% reads + 50% writes)</p>
    <p>Takeaways</p>
    <p>Approach Insecure Baseline PathORAM Pancake</p>
    <p>Server Storage 1 GB 8 GB 2 GB</p>
    <p>Proxy Storage 0 GB 8 MB 24 MB</p>
    <p>Server storage 4x lower than PathORAM, low proxy storage (~1% of server storage)</p>
  </div>
  <div class="page">
    <p>Pancake Performance Cloud Storage: Redis on t3.2xlarge Amazon EC2 instances, Client/Proxy: Amazon EC2 r4.8xlarge instances</p>
    <p>Dataset: 106 x 1KB key-value pairs, Workload: YCSB Workload A (50% reads + 50% writes)</p>
    <p>Takeaways</p>
    <p>Approach Insecure Baseline PathORAM Pancake</p>
    <p>Server Storage 1 GB 8 GB 2 GB</p>
    <p>Proxy Storage 0 GB 8 MB 24 MB</p>
    <p>Latency 1.15 ms 31.32 ms 2.61 ms</p>
    <p>Throughput 50,990 Op/s 32 Op/s 6,718 Op/s</p>
    <p>Throughput 220x higher and latency 12x lower than PathORAM Server storage 4x lower than PathORAM, low proxy storage (~1% of server storage)</p>
  </div>
  <div class="page">
    <p>Pancake Performance Cloud Storage: Redis on t3.2xlarge Amazon EC2 instances, Client/Proxy: Amazon EC2 r4.8xlarge instances</p>
    <p>Dataset: 106 x 1KB key-value pairs, Workload: YCSB Workload A (50% reads + 50% writes)</p>
    <p>Takeaways</p>
    <p>Many more results in the paper! 12</p>
    <p>Approach Insecure Baseline PathORAM Pancake</p>
    <p>Server Storage 1 GB 8 GB 2 GB</p>
    <p>Proxy Storage 0 GB 8 MB 24 MB</p>
    <p>Latency 1.15 ms 31.32 ms 2.61 ms</p>
    <p>Throughput 50,990 Op/s 32 Op/s 6,718 Op/s</p>
    <p>Throughput 220x higher and latency 12x lower than PathORAM Server storage 4x lower than PathORAM, low proxy storage (~1% of server storage)</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Pancake: first system that protects data stores against access pattern attacks at constant factor server storage &amp; bandwidth overheads</p>
    <p>Formal security analysis showing passive persistent security</p>
    <p>Comprehensive evaluation shows throughput &gt; 2 orders of magnitude higher than state-of-the art (PathORAM)!</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Pancake: first system that protects data stores against access pattern attacks at constant factor server storage &amp; bandwidth overheads</p>
    <p>Formal security analysis showing passive persistent security</p>
    <p>Comprehensive evaluation shows throughput &gt; 2 orders of magnitude higher than state-of-the art (PathORAM)!</p>
    <p>Thank You! Questions?</p>
  </div>
</Presentation>
