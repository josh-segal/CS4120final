<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Cliffhanger: Scaling Performance Cliffs in Web Memory Caches</p>
    <p>Asaf Cidon, Assaf Eisenman, Mohammad Alizadeh and Sachin Katti</p>
  </div>
  <div class="page">
    <p>Memory Caches are Essential to Webscale Application Performance</p>
  </div>
  <div class="page">
    <p>Memory Cache Hit Rate Drives Performance</p>
    <p>Memcached most widely used cache in large data centers</p>
    <p>Small improvements are important, especially when hit rates are high</p>
    <p>+1% cache hit-rate  35% speedup  Old latency: 374 s  New latency: 278 s  Facebook study: Atikoglu et al [Sigmetrics 12]</p>
  </div>
  <div class="page">
    <p>Memory Caches not Optimized for Maximizing Hit Rate</p>
    <p>Does not optimize for hit rate across different request sizes and applications  Cache greedily assigns memory to different</p>
    <p>request sizes and applications  Memory assignment remains static</p>
  </div>
  <div class="page">
    <p>Memcacheds Static Cache Allocation</p>
    <p>Item 1 35 bytes</p>
    <p>Memcached ServerMemcached Server</p>
  </div>
  <div class="page">
    <p>Memcached ServerMemcached Server</p>
    <p>Memcacheds Static Cache Allocation</p>
    <p>Item 1 35 bytes</p>
  </div>
  <div class="page">
    <p>Memcached ServerMemcached Server</p>
    <p>Item 2 60 bytes</p>
    <p>Item 8 60 bytes</p>
    <p>Memcacheds Static Cache Allocation</p>
  </div>
  <div class="page">
    <p>Memcached ServerMemcached Server</p>
    <p>Item 9 100 bytes</p>
    <p>Item 13 378 bytes</p>
    <p>Memcacheds Static Cache Allocation</p>
  </div>
  <div class="page">
    <p>Memcached ServerMemcached Server</p>
    <p>Memcacheds Static Cache Allocation</p>
    <p>Item 10 100 bytes</p>
    <p>Item 12 100 bytes</p>
    <p>Item 14 433 bytes</p>
    <p>Item 20 510 bytes</p>
  </div>
  <div class="page">
    <p>Memcached ServerMemcached Server</p>
    <p>Item 10 100 bytes</p>
    <p>Item 12 100 bytes</p>
    <p>Memcacheds Static Cache Allocation</p>
    <p>Item 14 433 bytes</p>
    <p>Item 20 510 bytes</p>
  </div>
  <div class="page">
    <p>Memcached ServerMemcached Server</p>
    <p>Memcacheds Static Cache Allocation</p>
    <p>Item 9 120 bytes</p>
  </div>
  <div class="page">
    <p>Memcached ServerMemcached Server</p>
    <p>slab2345678</p>
    <p>Memcacheds Static Cache Allocation</p>
    <p>Item 9 120 bytes</p>
  </div>
  <div class="page">
    <p>Memcached ServerMemcached Server</p>
    <p>Memcacheds Static Cache Allocation</p>
    <p>Item 21 43 bytes</p>
  </div>
  <div class="page">
    <p>Memcached ServerMemcached Server</p>
    <p>Memcacheds Static Cache Allocation</p>
    <p>Item 21 43 bytes</p>
  </div>
  <div class="page">
    <p>Memcached ServerMemcached Server</p>
    <p>Memcacheds Static Cache Allocation</p>
  </div>
  <div class="page">
    <p>Memcached ServerMemcached Server</p>
    <p>Memcacheds Static Cache Allocation</p>
  </div>
  <div class="page">
    <p>Problems with Memcached Static Cache Allocation</p>
    <p>Can we do better?</p>
  </div>
  <div class="page">
    <p>Understanding Memcached Workloads With MemCachier Traces</p>
    <p>Weeklong trace taken from MemCachier  490 applications on 30 Memcached servers  Each application has its own pages</p>
  </div>
  <div class="page">
    <p>Profiling Hit Rate Curves</p>
    <p>Stack distances: 5 1</p>
    <p>LRU Queue</p>
    <p>Hit: position 1</p>
    <p>Miss</p>
  </div>
  <div class="page">
    <p>Hit Rate Curve Profiling</p>
  </div>
  <div class="page">
    <p>Optimizing Hit Rate Curves</p>
  </div>
  <div class="page">
    <p>Memory Allocation Solver Using Hitrate Curves</p>
    <p>frequency of requests h  hit-rate of requests m  memory allocated to slab class M  memory allocated to application</p>
  </div>
  <div class="page">
    <p>Solver Output</p>
    <p>Allocate 1178 Items Allocate 41381 Items</p>
  </div>
  <div class="page">
    <p>Solver is Expensive and Not Dynamic</p>
    <p>Solver is expensive  Requires estimating stack distances for each curve  Requires centralized solver</p>
    <p>Solver is static  How frequently should we optimize?</p>
    <p>Instead of optimizing entire hit rate curve, we can optimize incrementally  Estimate local gradient for each curve  Increase memory for curve with highest gradient</p>
  </div>
  <div class="page">
    <p>Using Shadow Queues to Estimate Local Gradient</p>
    <p>Queue 1</p>
    <p>Queue 2</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Credits</p>
    <p>Queue 1 0</p>
    <p>Queue 2 0</p>
  </div>
  <div class="page">
    <p>Using Shadow Queues to Estimate Local Gradient</p>
    <p>Queue 1</p>
    <p>Queue 2</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Credits</p>
    <p>Queue 1 0</p>
    <p>Queue 2 0</p>
  </div>
  <div class="page">
    <p>Using Shadow Queues to Estimate Local Gradient</p>
    <p>Queue 1</p>
    <p>Queue 2</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Credits</p>
    <p>Queue 1 0</p>
    <p>Queue 2 0</p>
    <p>Miss</p>
  </div>
  <div class="page">
    <p>Using Shadow Queues to Estimate Local Gradient</p>
    <p>Queue 1</p>
    <p>Queue 2</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Credits</p>
    <p>Queue 1 0</p>
    <p>Queue 2 0</p>
  </div>
  <div class="page">
    <p>Using Shadow Queues to Estimate Local Gradient</p>
    <p>Queue 1</p>
    <p>Queue 2</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Credits</p>
    <p>Queue 1 1</p>
    <p>Queue 2 -1</p>
    <p>Shadow Queue Hit</p>
  </div>
  <div class="page">
    <p>Using Shadow Queues to Estimate Local Gradient</p>
    <p>Queue 1</p>
    <p>Queue 2</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Credits</p>
    <p>Queue 1 1</p>
    <p>Queue 2 -1</p>
  </div>
  <div class="page">
    <p>Using Shadow Queues to Estimate Local Gradient</p>
    <p>Queue 1</p>
    <p>Queue 2</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Credits</p>
    <p>Queue 1 1</p>
    <p>Queue 2 -1</p>
  </div>
  <div class="page">
    <p>Using Shadow Queues to Estimate Local Gradient</p>
    <p>Queue 1</p>
    <p>Queue 2</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Credits</p>
    <p>Queue 1 2</p>
    <p>Queue 2 -2</p>
    <p>Shadow Queue Hit</p>
  </div>
  <div class="page">
    <p>Using Shadow Queues to Estimate Local Gradient</p>
    <p>Queue 1</p>
    <p>Queue 2</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Credits</p>
    <p>Queue 1 2</p>
    <p>Queue 2 -2</p>
    <p>Resize Queues</p>
  </div>
  <div class="page">
    <p>Using Shadow Queues to Estimate Local Gradient</p>
    <p>Queue 1</p>
    <p>Queue 2</p>
    <p>Physical Queue</p>
    <p>Physical Queue Shadow Queue</p>
    <p>Credits</p>
    <p>Queue 1 0</p>
    <p>Queue 2 0</p>
    <p>Shadow Queue</p>
  </div>
  <div class="page">
    <p>Algorithm 1: Hill-climbing</p>
  </div>
  <div class="page">
    <p>Algorithm 1: Hill-climbing</p>
    <p>Approximates optimization</p>
    <p>At optimal memory allocation:  Credit increase rate = credit decrease rate for each queue</p>
  </div>
  <div class="page">
    <p>Hill Climbing Algorithm Over Time (Application 5)</p>
  </div>
  <div class="page">
    <p>Performance Cliffs Hurt Local Optimization</p>
  </div>
  <div class="page">
    <p>Talus: Simulating Two Queues</p>
  </div>
  <div class="page">
    <p>Simulated Right Queue 13,000 items</p>
    <p>Simulated Left Queue 2000 items</p>
    <p>Talus: Simulating Two Queues</p>
  </div>
  <div class="page">
    <p>Algorithm 2: Cliff Scaling</p>
    <p>Talus requires knowledge of hitrate curve  Where the performance cliff starts and ends</p>
    <p>Algorithm 2 locally estimates where the performance cliff starts and ends  Estimate the second derivative with shadow</p>
    <p>queues</p>
  </div>
  <div class="page">
    <p>Estimating Second Derivative with Shadow Queues</p>
    <p>N u m b e r o f I t e m s i n L R U Q u e u e</p>
    <p>H it</p>
    <p>ra te</p>
    <p>C o n c a v e H u l l</p>
    <p>A p p l i c a t i o n 1 9 , S l a b 0</p>
    <p>Shadow'Queues' Le- 'Queue'</p>
    <p>Shadow'Queues' Right'Queue'Queue'Size'</p>
  </div>
  <div class="page">
    <p>Cliffhanger Runs Both Algorithms in Parallel</p>
    <p>Par$$oned)</p>
    <p>Original)Queue)</p>
    <p>Par$$oned) Queues)</p>
    <p>Track)le4 )of)pointer)</p>
    <p>Track)le4 )of)pointer)</p>
    <p>Track)right)of)pointer) Track)right)of)pointer)</p>
    <p>Track)hill)climbing)</p>
    <p>Track)hill)climbing)</p>
    <p>Algorithm 1: incrementally optimize memory across queues  Across slab classes  Across applications</p>
    <p>Algorithm 2: scales performance cliffs</p>
  </div>
  <div class="page">
    <p>Cliffhanger Reduces Misses and Can Save Memory</p>
    <p>Average misses reduced: 36.7%  Average potential memory savings: 45%</p>
  </div>
  <div class="page">
    <p>Cliffhanger Outperforms Default and Optimized Schemes</p>
    <p>Average Cliffhanger hit rate increase: 1.2%</p>
  </div>
  <div class="page">
    <p>Low Overheads  Latency overhead:</p>
    <p>Throughput overhead:</p>
    <p>Memory overhead: 500KB for each application</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>Web-scale applications heavily reliant on memory cache hit rate</p>
    <p>But, existing cache allocation is not optimized for max hit rate</p>
    <p>Cliffhangers incremental dynamic cache allocation using shadow queues maximizes hit rates and addresses performance cliffs</p>
  </div>
  <div class="page">
    <p>Appendix</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>Cache partitioning for performance cliffs  Talus: Beckmann et al [HPCA 15]</p>
    <p>Optimizing memory allocation across applications based on hitrate curves  Mimir: Saemundsson et al [SOCC 14]</p>
    <p>Rebalancing slabs to reduce slab calcification  Twitter: Rajashekhar et al [Twitter blog 12]  Facebook: Nishtala et al [NSDI 13]</p>
    <p>Optimizing Memcached multi-threaded performance  MICA: Lim et al [NSDI 14]</p>
  </div>
  <div class="page">
    <p>Comparison with Facebook LRU</p>
  </div>
  <div class="page">
    <p>Log Structured Memory is Still Greedy</p>
  </div>
  <div class="page">
    <p>Algorithms are Complementary (Memcachiers Application 19)</p>
  </div>
  <div class="page">
    <p>Why Do Performance Cliffs Occur?</p>
    <p>Applications issues requests 1, 2, 3, 4, 5  Queue size = 4</p>
    <p>0% hitrate</p>
  </div>
  <div class="page">
    <p>Intuition Behind Talus</p>
    <p>2 queues with size = 2  First queue gets 1, 2, 3  Second queue gets 4, 5  First queue hitrate: 0%  Second queue hitrate: 100%  Overall hitrate: 40%</p>
  </div>
  <div class="page">
    <p>Solvers Potential for Improvement</p>
  </div>
  <div class="page">
    <p>Solvers Potential for Improvement</p>
    <p>+19% Hit Rate +66% Hit Rate +45% Hit Rate</p>
  </div>
</Presentation>
