<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Extending Logic Programs with Description</p>
    <p>Logic Expressions for the Semantic Web</p>
    <p>ISWC 2011, Bonn, Germany</p>
    <p>Yi-Dong Shen</p>
    <p>Chinese Academy of Sciences</p>
    <p>Beijing, China</p>
    <p>http://lcs.ios.ac.cn/~ydshen</p>
    <p>Kewen Wang</p>
    <p>Griffith University</p>
    <p>Brisbane, Australia</p>
    <p>http://www.ict.griffith.edu.au/~kewen</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>I. Background and Motivation</p>
    <p>II. Logic Programs and DL Knowledge Bases</p>
    <p>III. Normal DL Logic Programs</p>
    <p>Syntax</p>
    <p>Semantics</p>
    <p>IV. Related Work</p>
    <p>V. Summary and Future Work</p>
  </div>
  <div class="page">
    <p>Semantic Web Stack</p>
    <p>Ontologies:</p>
    <p>OWL</p>
    <p>Rules:</p>
    <p>RIF</p>
  </div>
  <div class="page">
    <p>Ontologies and Rules</p>
    <p>Ontologies describe terminological knowledge.</p>
    <p>Rules model constraints and exceptions over the</p>
    <p>ontologies.</p>
    <p>The two components provide complementary</p>
    <p>descriptions of the same problem domain, so it is</p>
    <p>necessary to integrate them in some ways (a unifying</p>
    <p>logic).</p>
  </div>
  <div class="page">
    <p>Logic Program Rules</p>
    <p>The integration depends on what knowledge</p>
    <p>representation formalisms are used to represent rules.</p>
    <p>Logic programming is a KR language paradigm widely</p>
    <p>used for representing and reasoning with rules.</p>
    <p>Therefore, recently much attention has been directed</p>
    <p>to using logic programs to represent rules in the</p>
    <p>integration for the Semantic Web.</p>
  </div>
  <div class="page">
    <p>Logic Programs with DL Expressions</p>
    <p>A normal logic program consists of if-then rules</p>
    <p>1,  , ,  1,  ,</p>
    <p>where , each  and  are atoms.</p>
    <p>Under the integration, logic programs are extended by</p>
    <p>allowing description logic (DL) expressions to</p>
    <p>appear in rules, so that logic programs have access</p>
    <p>to DL knowledge bases (ontologies) and thus are able</p>
    <p>to reason with ontologies in the Semantic Web.</p>
  </div>
  <div class="page">
    <p>Major Existing Proposals</p>
    <p>(Eiter et al., AIJ2008).</p>
    <p>(Rosati, KR2006).</p>
    <p>(Lukasiewicz, TKDE2010).</p>
  </div>
  <div class="page">
    <p>dl-Programs (Eiter et al., AIJ2008)</p>
    <p>Given an external DL knowledge base L, a dl-program</p>
    <p>extends a normal logic program  by</p>
    <p>adding dl-atoms to rule bodies as an interface to access to L.</p>
    <p>L and  share no predicate symbols in their vocabularies,</p>
    <p>so a mapping of predicate symbols between L and  is</p>
    <p>required.</p>
    <p>DL atoms are not allowed to appear in rule heads.</p>
  </div>
  <div class="page">
    <p>DL+log (Rosati, KR2006)</p>
    <p>DL+log extends a normal logic program  by</p>
    <p>letting L and  share some predicate symbols in their</p>
    <p>vocabularies, and</p>
    <p>allowing atomic DL expressions (i.e. atomic concepts and atomic</p>
    <p>roles) to appear either in bodies or heads of rules without using</p>
    <p>any predicate mapping operators.</p>
    <p>One restriction is that DL expressions are not allowed to</p>
    <p>appear behind the negation operator .</p>
  </div>
  <div class="page">
    <p>Disjunctive dl-Programs (Lukasiewicz, TKDE2010)</p>
    <p>A disjunctive dl-program extends a normal logic program</p>
    <p>by</p>
    <p>letting L and  share some predicate symbols in their</p>
    <p>vocabularies, and</p>
    <p>allowing atomic DL expressions to appear anywhere in a rule.</p>
  </div>
  <div class="page">
    <p>Complementary Features</p>
    <p>In syntax</p>
    <p>dl-programs allow arbitrary DL expressions in rule bodies.</p>
    <p>DL+log and disjunctive dl-programs allow atomic DL expressions</p>
    <p>in rule heads.</p>
    <p>In semantics</p>
    <p>dl-programs and DL+log: DL concepts and roles occurring in</p>
    <p>are all interpreted against L under the first-order semantics.</p>
    <p>disjunctive dl-programs: DL concepts and roles occurring in  are</p>
    <p>all included in the Herbrand base of  and interpreted under the</p>
    <p>answer set semantics.</p>
  </div>
  <div class="page">
    <p>Complementary Features</p>
    <p>It is desirable to have a new extension of logic</p>
    <p>programs with DL expressions, which combines the</p>
    <p>complementary features of dl-programs, DL+log and</p>
    <p>disjunctive dl-programs.</p>
    <p>This motivates the work of our current paper.</p>
  </div>
  <div class="page">
    <p>Our Contributions</p>
    <p>We propose a new extension, called a normal DL logic</p>
    <p>program, which combines the complementary features of</p>
    <p>dl-programs, DL+log and disjunctive dl-programs by</p>
    <p>allowing arbitrary DL expressions to appear in rule bodies and</p>
    <p>atomic DL expressions in rule heads;</p>
    <p>allowing to interpret DL concepts and roles occurring in  flexibly</p>
    <p>either in first-order semantics or answer set semantics; and</p>
    <p>having a well-supported answer set semantics, so that its answer</p>
    <p>sets are free of circular justifications.</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>I. Background and Motivation</p>
    <p>II. Logic Programs and DL Knowledge Bases</p>
    <p>III. Normal DL Logic Programs</p>
    <p>Syntax</p>
    <p>Semantics</p>
    <p>IV. Related Work</p>
    <p>V. Summary and Future Work</p>
  </div>
  <div class="page">
    <p>Logic Programs</p>
    <p>A vocabulary  = (, )</p>
    <p>: a finite set of predicate symbols.</p>
    <p>: a nonempty finite set of constants.</p>
    <p>A normal logic program  is a finite set of rules</p>
    <p>1,  , ,  1,  ,</p>
    <p>where ,  and  are atoms built over .</p>
    <p>ground  : all ground instances of  obtained by</p>
    <p>replacing all variables in  with constants in .</p>
  </div>
  <div class="page">
    <p>Logic Programs</p>
    <p>Herbrand base</p>
    <p>All ground atoms p(1,  , ), where p   occurs in  and   .</p>
    <p>Herbrand interpretation</p>
    <p>Any subset of . Let   =  \ and</p>
    <p>= {|  }.</p>
    <p>Standard answer set semantics (Gelfond and Lifschitz, NJC1991)</p>
    <p>is an answer set of  if  is the least model of  , where</p>
    <p>= {         ,    ground  and  satisfies ()}.</p>
  </div>
  <div class="page">
    <p>DL Knowledge Bases</p>
    <p>A description logic SHOIN (Horrocks et al., JWS2003) with a</p>
    <p>vocabulary  =   ,</p>
    <p>A, R, I: atomic concepts, atomic roles, and individuals.</p>
    <p>A DL knowledge base  is a finite set of axioms over</p>
    <p>: concept inclusion axiom.</p>
    <p>1: role inclusion axiom.</p>
    <p>(): transitivity axiom.</p>
    <p>: concept membership axiom.</p>
    <p>,  : role membership axiom.</p>
    <p>= (, ) or  ,  :.equality/inequality axiom.</p>
    <p>where ,  are concepts; , 1 atomic roles; ,  individuals.</p>
  </div>
  <div class="page">
    <p>DL Knowledge Bases</p>
    <p>Since DLs are fragments of first-order logic, a DL</p>
    <p>knowledge base  has first-order semantics.</p>
    <p>is consistent (or satisfiable) if  has a first-order model.</p>
    <p>For an axiom ,  entails , denoted   , if all first</p>
    <p>order models of  are first-order models of .</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>I. Background and Motivation</p>
    <p>II. Logic Programs and DL Knowledge Bases</p>
    <p>III. Normal DL Logic Programs</p>
    <p>Syntax</p>
    <p>Semantics</p>
    <p>IV. Related Work</p>
    <p>V. Summary and Future Work</p>
  </div>
  <div class="page">
    <p>Syntax</p>
    <p>Let  be a DL knowledge base built over  =   ,</p>
    <p>We develop a logic program  over  = ,  with DL</p>
    <p>expressions relative to , called a normal DL logic</p>
    <p>program, where</p>
    <p>, i.e. constants come from individuals; and</p>
    <p>and  share a set  =      of predicate symbols</p>
    <p>(atomic concepts and roles).</p>
    <p>Note: Concepts and roles in  shared by  are intended to be</p>
    <p>interpreted in Herbrand models under answer set semantics.</p>
  </div>
  <div class="page">
    <p>DL Expressions</p>
    <p>A DL expression or DL query (Eiter et al., AIJ2008), which is</p>
    <p>allowed to appear in rules of a logic program, is</p>
    <p>a concept inclusion axiom    or its negation;</p>
    <p>() or (), where  is a concept and  a term (variable or constant);</p>
    <p>(1, 2) or (1, 2), where  is an atomic role or its inverse, and</p>
    <p>1, 2 are terms; or</p>
    <p>= (1, 2) or  (1, 2), where 1, 2 are terms.</p>
    <p>An atomic DL expression is either   or (1, 2),</p>
    <p>where  is an atomic concept and  is an atomic role.</p>
  </div>
  <div class="page">
    <p>Normal DL Logic Programs</p>
    <p>Definition Given a DL knowledge base , a normal DL logic</p>
    <p>program  with DL expressions relative to  is a finite set of rules</p>
    <p>1,  , ,  1,  ,</p>
    <p>where  is an atom, and each  and  are either atoms or DL</p>
    <p>expressions.</p>
    <p>Note:</p>
    <p>Arbitrary DL expressions can occur in rule bodies.</p>
    <p>Atomic DL expressions can occur in rule heads. When the predicate symbol</p>
    <p>of an atom in  is in , the atom is also an atomic DL expression.</p>
  </div>
  <div class="page">
    <p>Normal DL Logic Programs</p>
    <p>Example 1 Let  = {  } and</p>
    <p>:   ,</p>
    <p>,</p>
    <p>, (    )().</p>
    <p>Let  = {, , },  = {} and  = {, }. Then</p>
    <p>ground  :   ,</p>
    <p>,</p>
    <p>, (    )().</p>
  </div>
  <div class="page">
    <p>Semantics</p>
    <p>Herbrand base  of  relative to</p>
    <p>All ground atoms p(1,  , ),</p>
    <p>where p   occurs in  or  and   .</p>
    <p>For a Herbrand interpretation   , let</p>
    <p>| = A   the predicate symbol of  is in  .</p>
    <p>| = {A     the predicate symbol of  is in }.</p>
    <p>is consistent with  if   |   | is consistent.</p>
  </div>
  <div class="page">
    <p>Extended Satisfaction</p>
    <p>Satisfaction of a Herbrand interpretation  relative to</p>
    <p>Definition  satisfies  under , denoted   :</p>
    <p>For a ground atom   , which is not an atomic DL</p>
    <p>expression,    if   .</p>
    <p>For a ground DL expression ,    if   |   |  .</p>
    <p>For a ground atom or a ground DL expression ,     if</p>
    <p>.</p>
  </div>
  <div class="page">
    <p>Herbrand Models</p>
    <p>Definition A Herbrand interpretation  is a model of  relative to  if</p>
    <p>is consistent with  and    for all rules   ground  .</p>
    <p>We are interested in well-supported models, a key characterization of the</p>
    <p>standard answer set semantics (Fages 1994, JMLCS):</p>
    <p>A model  of a normal logic program  is well-supported if there is a level</p>
    <p>mapping on  such that for every   , there is a rule in ground</p>
    <p>1,  , ,  1,  ,</p>
    <p>where I satisfies the rule body and the level of each  is below the level of .</p>
    <p>A model of a normal logic program is an answer set under the standard</p>
    <p>answer set semantics iff it is well-supported.</p>
  </div>
  <div class="page">
    <p>up to Satisfaction (, )</p>
    <p>To define well-supported models for normal DL logic programs, we</p>
    <p>introduce  up to  satisfies  under , denoted ,   :</p>
    <p>,    implies that the truth of  depends only on  and  , and</p>
    <p>is independent of \E.</p>
    <p>For instance, if  = {},  = {, , } and  =   ,</p>
    <p>then for every  with     ,   . Thus, ,   .</p>
    <p>Definition Let  be a ground atom or DL expression and     .</p>
    <p>,    if for every  with     ,   ;</p>
    <p>,     if for no such ,   .</p>
  </div>
  <div class="page">
    <p>Monotonicity of (, )</p>
    <p>Theorem Let  be a ground atom or DL expression, and</p>
    <p>1  2    .</p>
    <p>If 1,   , then 2,   ;</p>
    <p>If 1,    , then 2,    .</p>
  </div>
  <div class="page">
    <p>Well-Supported Models</p>
    <p>Definition A model I of a normal DL logic program is well-supported</p>
    <p>if there is a level mapping on I such that for every    there exists</p>
    <p>, where the level of each    is below the level of , such that</p>
    <p>|   |   or</p>
    <p>there is      ground  such that ,   ().</p>
    <p>The above well-supportedness condition guarantees:</p>
    <p>the truth of each    is supported by some    and ,</p>
    <p>where no    is circularly supported by a.</p>
    <p>So well-supported models are free of circular justifications.</p>
  </div>
  <div class="page">
    <p>A Fixpoint Semantics</p>
    <p>Consequence operator  ,</p>
    <p>Definition Let  be a normal DL logic program relative to a DL</p>
    <p>knowledge base , and  a Herbrand interpretation consistent with</p>
    <p>. For   , define</p>
    <p>,  = {|     ground  and ,     }</p>
  </div>
  <div class="page">
    <p>A Fixpoint Semantics</p>
    <p>Monotonicity property of  ,</p>
    <p>Fixpoint   ,  from the monotone sequence</p>
    <p>,  =0</p>
    <p>where</p>
    <p>0 ,  =  and</p>
    <p>+1 ,  =</p>
    <p>,  ,</p>
    <p>Theorem Let  be a model of  relative to . For any 1  2  ,</p>
    <p>1,    2,   .</p>
  </div>
  <div class="page">
    <p>A Fixpoint Semantics</p>
    <p>We use   ,  to define a fixpoint semantics</p>
    <p>Definition Let  be a model of a normal DL logic program</p>
    <p>relative to a DL knowledge base .  is an answer set of  relative</p>
    <p>to  if for every a  , either</p>
    <p>,  , or</p>
    <p>,  |</p>
    <p>|  .</p>
  </div>
  <div class="page">
    <p>A Fixpoint Semantics</p>
    <p>Example 1 Let  = {  } and</p>
    <p>:   ,</p>
    <p>,</p>
    <p>, (    )().</p>
    <p>Let  = {, , },  = {} and  = {, }. Then</p>
    <p>= ( ,   , ()}.</p>
    <p>= ( ,   , ()} is the only model of  relative to .</p>
    <p>is not an answer set of  relative to  since   ,  = {  },</p>
    <p>and neither ()    ,  nor</p>
    <p>,  |   |  ().</p>
    <p>Note:  is not a well-supported model of  relative to .</p>
  </div>
  <div class="page">
    <p>Properties of the Semantics</p>
    <p>Answer sets are minimal and well-supported models</p>
    <p>Theorem 1 If  is an answer set of  relative to , then  is an</p>
    <p>minimal model of  relative to .</p>
    <p>Theorem 2  is an answer set of  relative to  iff  is a well</p>
    <p>supported model of  relative to .</p>
    <p>Theorem 3 Let  =  and  be a normal DL logic program</p>
    <p>without DL expressions.  is an answer set of  relative to  iff  is</p>
    <p>an answer set of  under the standard answer set semantics.</p>
  </div>
  <div class="page">
    <p>Decidability of the Semantics</p>
    <p>The decidability of computing answer sets of  relative</p>
    <p>to  depends on the decidability of satisfiability of .</p>
    <p>Since DLs are fragments of first-order logic, the</p>
    <p>satisfiability of  is undecidable in general cases.</p>
    <p>If  is built from SHOIN or SROIQ, the satisfiability of</p>
    <p>is decidable (Horrocks et al., JWS2003; KR2006). Therefore, it</p>
    <p>is decidable to compute all such answer sets.</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>I. Background and Motivation</p>
    <p>II. Logic Programs and DL Knowledge Bases</p>
    <p>III. Normal DL Logic Programs</p>
    <p>Syntax</p>
    <p>Semantics</p>
    <p>IV. Related Work</p>
    <p>V. Summary and Future Work</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>We focus on enhancing logic program rules with DL expressions so</p>
    <p>that logic programs are able to access to external DL knowledge</p>
    <p>bases and thus able to reason with ontologies in the Semantic Web.</p>
    <p>This differs fundamentally from modal logic based embeddings of</p>
    <p>rules and DLs, such as (de Bruijn et al., KR2008) and (Motik and Rosati,</p>
    <p>JACM2010), which</p>
    <p>transform rules  and DL axioms  into modal logic formulas</p>
    <p>and , and</p>
    <p>use the modal logic semantics of    as the semantics of</p>
    <p>and .</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>Three closely related approaches to extending logic</p>
    <p>programs with DL expressions:</p>
    <p>dl-programs (Eiter et al., AIJ2008),</p>
    <p>DL+log (Rosati, KR2006) and its variant called guarded</p>
    <p>hybrid knowledge bases (Heymans et al., TPLP2008).</p>
    <p>disjunctive dl-programs (Lukasiewicz, TKDE2010).</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>dl-programs DL+log Disjunctive dl-programs</p>
    <p>Normal DL logic programs</p>
    <p>Arbitrary or atomic DL expressions</p>
    <p>Rule body arbitrary atomic atomic arbitrary</p>
    <p>Rule head X atomic atomic atomic</p>
    <p>Need predicate mapping yes no no no</p>
    <p>Interpretation of DL predicates occurring in rules</p>
    <p>first-order only*</p>
    <p>first-order only*</p>
    <p>Herbrand only**</p>
    <p>flexible***</p>
    <p>Well-supported semantics free of circular justifications</p>
    <p>yes (Shen, IJCAI2011)</p>
    <p>no no yes</p>
    <p>* First-order interpretation against the external DL knowledge base.</p>
    <p>** Herbrand interpretation under the answer set semantics.</p>
    <p>*** When being included in , Herbrand only; otherwise, first-order only.</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>I. Background and Motivation</p>
    <p>II. Logic Programs and DL Knowledge Bases</p>
    <p>III. Normal DL Logic Programs</p>
    <p>Syntax</p>
    <p>Semantics</p>
    <p>IV. Related Work</p>
    <p>V. Summary and Future Work</p>
  </div>
  <div class="page">
    <p>Summary</p>
    <p>We presented normal DL logic programs, a new</p>
    <p>extension of logic programs with DL expressions, which</p>
    <p>combine the complementary features of dl-programs,</p>
    <p>DL+log and disjunctive dl-programs by</p>
    <p>allowing arbitrary DL expressions to appear in rule bodies and</p>
    <p>atomic DL expressions in rule heads;</p>
    <p>allowing to interpret DL concepts and roles occurring in rules</p>
    <p>either in first-order semantics or answer set semantics; and</p>
    <p>having a well-supported answer set semantics, so that their</p>
    <p>answer sets are free of circular justifications.</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Study computational properties of the semantics for</p>
    <p>normal DL logic programs w.r.t. different DLs.</p>
    <p>Extend the work to disjunctive DL logic programs, where</p>
    <p>rule heads are a disjunction of atoms or atomic DL</p>
    <p>expressions.</p>
    <p>Methods for implementing the fixpoint semantics for</p>
    <p>normal DL logic programs present interesting future</p>
    <p>work.</p>
  </div>
  <div class="page">
    <p>Thanks !</p>
    <p>Yi-Dong Shen</p>
    <p>ydshen@ios.ac.cn</p>
    <p>http://lcs.ios.ac.cn/~ydshen</p>
  </div>
</Presentation>
