<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Implementing a Language with Flow-Sensitive and Structural</p>
    <p>Subtyping on the JVM</p>
    <p>David J. Pearce and James Noble Victoria University of Wellington</p>
  </div>
  <div class="page">
    <p>void buildLabelMap(List&lt;Bytecode&gt; bytecodes) {</p>
    <p>HashMap&lt;String,Integer&gt; labels = new HashMap&lt;String,Integer&gt;();</p>
    <p>int idx = 0</p>
    <p>for(Bytecode b : bytecodes) {</p>
    <p>if(b instanceof Bytecode.Label) {</p>
    <p>Bytecode.Label lab = (Bytecode.Label) b;</p>
    <p>labels.put(lab.name, idx);</p>
    <p>}</p>
    <p>idx = idx + 1;</p>
    <p>} }</p>
    <p>def buildLabelMap(bytecodes):</p>
    <p>labels = {}</p>
    <p>idx = 0</p>
    <p>for b in bytecodes:</p>
    <p>if type(b) == Label:</p>
    <p>labels[b.name] = idx</p>
    <p>idx = idx + 1</p>
    <p>Python:</p>
    <p>Java:</p>
  </div>
  <div class="page">
    <p>The Whiley Language</p>
    <p>Design Goals:</p>
    <p>Look and feel of a dynamically typed language</p>
    <p>But, still provide static type checking</p>
    <p>Simple programming model</p>
    <p>Amenable to program verification</p>
    <p>void buildLabelMap([Bytecode] bytecodes):</p>
    <p>labels = {}</p>
    <p>idx = 0</p>
    <p>for b in bytecodes:</p>
    <p>if b ~= Label:</p>
    <p>labels[b.name] = idx</p>
    <p>idx = idx + 1</p>
    <p>Whiley:</p>
  </div>
  <div class="page">
    <p>The Whiley Language</p>
    <p>Design Goals:</p>
    <p>Look and feel of a dynamically typed language</p>
    <p>But, still provide static type checking</p>
    <p>Simple programming model</p>
    <p>Amenable to program verification</p>
    <p>void buildLabelMap([Bytecode] bytecodes):</p>
    <p>labels = {}</p>
    <p>idx = 0</p>
    <p>for b in bytecodes:</p>
    <p>if b ~= Label:</p>
    <p>labels[b.name] = idx</p>
    <p>idx = idx + 1</p>
    <p>Whiley:</p>
  </div>
  <div class="page">
    <p>The Whiley Language</p>
    <p>Design Goals:</p>
    <p>Look and feel of a dynamically typed language</p>
    <p>But, still provide static type checking</p>
    <p>Simple programming model</p>
    <p>Amenable to program verification</p>
    <p>void buildLabelMap([Bytecode] bytecodes):</p>
    <p>labels = {}</p>
    <p>idx = 0</p>
    <p>for b in bytecodes:</p>
    <p>if b ~= Label:</p>
    <p>labels[b.name] = idx</p>
    <p>idx = idx + 1</p>
    <p>Whiley:</p>
  </div>
  <div class="page">
    <p>Union Types</p>
    <p>Union types have many uses  Such as neatly handling null references  Or, combining different kinds (i.e. unions of structs)</p>
    <p>null|int indexOf(string str, char c):</p>
    <p>[string] split(string str, char c):</p>
    <p>idx = indexOf(str,c)</p>
    <p>if idx ~= int:</p>
    <p>below = str[0..idx]</p>
    <p>above = str[idx..]</p>
    <p>return [below,above]</p>
    <p>else:</p>
    <p>return [str]</p>
  </div>
  <div class="page">
    <p>Union Types</p>
    <p>Union types have many uses  Such as neatly handling null references  Or, combining different kinds (i.e. unions of structs)</p>
    <p>null|int indexOf(string str, char c):</p>
    <p>[string] split(string str, char c):</p>
    <p>idx = indexOf(str,c)</p>
    <p>if idx ~= int:</p>
    <p>below = str[0..idx]</p>
    <p>above = str[idx..]</p>
    <p>return [below,above]</p>
    <p>else:</p>
    <p>return [str]</p>
  </div>
  <div class="page">
    <p>Structural Subtyping</p>
    <p>Defined types are not nominal  i.e. LinkedList is just a name that expands</p>
    <p>define LinkedList as null | {int dat, LinkedList nxt}</p>
    <p>define NonEmptyList as {int dat, LinkedList nxt}</p>
    <p>int sum(LinkedList l):</p>
    <p>if !(l ~= NonEmptyList):</p>
    <p>return 0</p>
    <p>else:</p>
    <p>return l.dat + sum(l.nxt)</p>
    <p>void main([string] args):</p>
    <p>l={dat: 1, nxt: null}</p>
    <p>l={dat: 2, nxt: l}</p>
    <p>out-&gt;println(sum(l))</p>
  </div>
  <div class="page">
    <p>Structural Subtyping</p>
    <p>Defined types are not nominal  i.e. LinkedList is just a name that expands</p>
    <p>define LinkedList as null | {int dat, LinkedList nxt}</p>
    <p>define NonEmptyList as {int dat, LinkedList nxt}</p>
    <p>int sum(LinkedList l):</p>
    <p>if l ~= NonEmptyList:</p>
    <p>return 0</p>
    <p>else:</p>
    <p>return l.dat + sum(l.nxt)</p>
    <p>void main([string] args):</p>
    <p>l={dat: 1, nxt: null} // l-&gt;{int dat, null nxt}</p>
    <p>l={dat: 2, nxt: l} // l-&gt;{int dat, {int dat, null nxt} nxt}}</p>
    <p>out-&gt;println(sum(l))</p>
  </div>
  <div class="page">
    <p>Implementation</p>
  </div>
  <div class="page">
    <p>Numbers</p>
    <p>Unbounded Integers &amp; Rationals</p>
    <p>How to implement efficiently on JVM?</p>
    <p>Adding 100,000 random (small) ints</p>
    <p>BigInteger(11ms), SmallInt/BigInt (1ms), int[] (1ms)</p>
    <p>real weird(real x, [int] map):</p>
    <p>if x ~= int:</p>
    <p>// convert x to int</p>
    <p>x = map[x]</p>
    <p>// convert x back to real</p>
    <p>return x</p>
  </div>
  <div class="page">
    <p>Records</p>
    <p>HashMap implementation:  Map field names to objects  Record access are HashMap lookups</p>
    <p>Array implementation  Fields allocated to array elements  Faster lookup times  Problem with width subtyping of records</p>
    <p>define Point as {int x, int y}</p>
    <p>define Point3D as {int x, int y, int z}</p>
    <p>int weird(Point p):</p>
    <p>return p.x + p.y</p>
    <p>int alsoWierd(Point3D p3d):</p>
    <p>return weird(p3d)</p>
    <p>x</p>
    <p>y</p>
  </div>
  <div class="page">
    <p>Runtime Type Tests</p>
    <p>Type testing without names is difficult!</p>
    <p>Elements may require recursive type test</p>
    <p>void f([real] xs):</p>
    <p>if xs ~= [int]:</p>
    <p>else:</p>
    <p>void f(List xs):</p>
    <p>for(Object _x : xs) {</p>
    <p>Number x = (Number) x;</p>
    <p>if(!x.isInteger()) {</p>
    <p>goto elseLab;</p>
    <p>} }</p>
    <p>return</p>
    <p>elseLab:</p>
    <p>return</p>
  </div>
  <div class="page">
    <p>Type Testing Records</p>
    <p>Type testing records == checking for fields</p>
    <p>Can do better than brute-force check all approach</p>
    <p>Test smallest set of uniquely identifying fields</p>
    <p>define Point as {int x, int y}</p>
    <p>define Point3D as {int x, int y, int z}</p>
    <p>int weird(Point p):</p>
    <p>if p ~= Point3D:</p>
    <p>else:</p>
  </div>
  <div class="page">
    <p>Testing Recursive Types</p>
    <p>Recursive types are also awkward</p>
    <p>Must recursively check every node  Potentially expensive  like for lists</p>
    <p>define LinkedList as {int data, LinkedList y}</p>
    <p>define WeirdList as {null|int data, WeirdList y}</p>
    <p>int weird(WeirdList p):</p>
    <p>if p ~= LinedList:</p>
    <p>else:</p>
  </div>
  <div class="page">
    <p>JVM not fully flow-sensitive!!!</p>
    <p>JVM uses flow-sensitive typing algorithm</p>
    <p>Doesnt account for instanceof tests</p>
    <p>Have to insert casts to keep verifier happy</p>
    <p>define nstring as null|string</p>
    <p>int length(nstring ns):</p>
    <p>if ns ~= string:</p>
    <p>return |ns|</p>
    <p>else:</p>
    <p>return 0</p>
  </div>
  <div class="page">
    <p>Cloning</p>
    <p>Data types have value semantics:</p>
    <p>i.e. lists are not references (as in Java)</p>
    <p>E.g. must clone lists on assignment</p>
    <p>This is inefficient  want to reduce number of clones</p>
    <p>E.g. 28125 clones in Chess benchmark (508LOC)</p>
    <p>void System::main([string] args):</p>
    <p>xs = [1,2,3]</p>
    <p>ys = xs // clone required</p>
    <p>ys[0] = 2</p>
    <p>out-&gt;println(str(xs))</p>
    <p>out-&gt;println(str(ys))</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Design Goals:</p>
    <p>Look and feel of a dynamically typed language</p>
    <p>But, still provide static type checking</p>
    <p>Implementation on JVM  Efficient representation of integers / rationals  Efficient representation of records  Efficient type testing  ?  Efficient value semantics  ?</p>
  </div>
  <div class="page">
    <p>http://whiley.org</p>
  </div>
</Presentation>
