<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>InsectJ: A Generic Instrumentation Framework for Collecting Dynamic</p>
    <p>Information within Eclipse</p>
    <p>Arjan Seesing and Alessandro Orso</p>
    <p>Georgia Institute of Technology</p>
    <p>This work was supported in part by an IBM Eclipse Innovation Grant.</p>
  </div>
  <div class="page">
    <p>Instrumentation Overview</p>
    <p>int i=4; o.foo(i); i++</p>
    <p>P</p>
    <p>Instrumenter</p>
    <p>int i=4; &lt;probe1&gt; o.foo(i); &lt;probe2&gt; i++</p>
    <p>P</p>
    <p>Monitor</p>
    <p>Log</p>
  </div>
  <div class="page">
    <p>Motivation</p>
    <p>Increasing interest in programs dynamic behavior</p>
    <p>Instrumentation commonly used for supporting dynamic analyses  Coverage</p>
    <p>Program tracing</p>
    <p>Profiling</p>
    <p>Runtime checking</p>
    <p>Mixed static and dynamic analyses</p>
    <p>Many issues to address</p>
  </div>
  <div class="page">
    <p>Key Instrumentation Challenges</p>
    <p>Overhead =&gt; Number of probes</p>
    <p>=&gt; Cost of probes</p>
    <p>Complexity =&gt; User unfriendliness</p>
    <p>=&gt; Low level details</p>
    <p>Non-customizability =&gt; Ad-hoc solutions</p>
    <p>=&gt; Difficult to modify and adapt</p>
  </div>
  <div class="page">
    <p>What is InsECT-J?</p>
    <p>Flexible, efficient bytecode instrumentation tool for collecting dynamic information  GUI-based instrumentation</p>
    <p>(static and on the fly)</p>
    <p>GUI-based monitor creation</p>
    <p>Support for collection of new kinds of data</p>
    <p>INStrumentation, Execution, and Collection Tool for Java</p>
  </div>
  <div class="page">
    <p>Monitor</p>
    <p>Probe</p>
    <p>GUI-based Instrumentation</p>
    <p>void foo {  } void bar {  }</p>
    <p>P</p>
  </div>
  <div class="page">
    <p>Method exit</p>
    <p>Method entry</p>
    <p>Monitor</p>
    <p>Probe</p>
    <p>GUI-based Instrumentation</p>
    <p>void foo {  } void bar {  }</p>
    <p>P</p>
  </div>
  <div class="page">
    <p>Method profiling</p>
    <p>Method exit</p>
    <p>Method entry</p>
    <p>Monitor</p>
    <p>Probe void foo {  } void bar {  }</p>
    <p>P</p>
    <p>GUI-based Instrumentation</p>
  </div>
  <div class="page">
    <p>Method profiling</p>
    <p>Method exit</p>
    <p>Method entry</p>
    <p>Monitor</p>
    <p>Probe void foo {  } void bar {  }</p>
    <p>P</p>
    <p>GUI-based Instrumentation</p>
  </div>
  <div class="page">
    <p>Method profiling</p>
    <p>Method exit</p>
    <p>Method entry</p>
    <p>Monitor</p>
    <p>Probe void foo { &lt;m.en.probe&gt;</p>
    <p>&lt;m.ex.probe&gt;</p>
    <p>} void bar {  }</p>
    <p>P</p>
    <p>GUI-based Instrumentation</p>
    <p>Method profiling monitor</p>
  </div>
  <div class="page">
    <p>GUI-based Instrumentation</p>
    <p>Let users select 1. Which information</p>
    <p>to collect</p>
  </div>
  <div class="page">
    <p>GUI-based Instrumentation</p>
    <p>Let users select 1. Which information</p>
    <p>to collect</p>
    <p>Extensible probe library  Basic block  Branch  Cast  Call  Return  Field read/write  Method entry/exit  Throw  Catch  Acyclic paths (WIP)</p>
    <p>Extensible monitor library  Block coverage</p>
    <p>Block profiling</p>
    <p>Branch coverage</p>
    <p>Branch profiling</p>
    <p>Method profiling</p>
    <p>Cast monitoring (downcasting)</p>
    <p>DefUse tracing</p>
    <p>Throw/catch coverage</p>
  </div>
  <div class="page">
    <p>GUI-based Monitor Creation</p>
    <p>void foo {  } void bar {  }</p>
    <p>P</p>
    <p>Monitor</p>
    <p>Field Def</p>
    <p>Field Use</p>
    <p>Probe</p>
  </div>
  <div class="page">
    <p>GUI-based Monitor Creation</p>
    <p>void foo {  } void bar {  }</p>
    <p>P</p>
    <p>New DefUse Monitor</p>
    <p>Monitor</p>
    <p>Field Def</p>
    <p>Field Use</p>
    <p>Probe</p>
  </div>
  <div class="page">
    <p>Monitors implement interfaces for the corresponding probe(s)</p>
    <p>Monitor wizard creates monitor stub classes</p>
    <p>GUI-based Monitor Creation Automated monitor stub creation through a wizard</p>
  </div>
  <div class="page">
    <p>Monitors implement interfaces for the corresponding probe(s)</p>
    <p>Monitor wizard creates monitor stub classes</p>
    <p>GUI-based Monitor Creation Automated monitor stub creation through a wizard</p>
    <p>public final class MyMonitor extends AbstractMonitorObject implements MonitorObject, DefMonitorInterface UseMonitorInterface {</p>
    <p>public void processData() {</p>
    <p>// TODO Auto-generated method stub } public void reportDef(Object newValue, Object oldValue,</p>
    <p>int srcLine, int probeId) { // TODO Auto-generated method stub</p>
    <p>} public void reportUse(Object value, int srcLine,</p>
    <p>int probeId) { // TODO Auto-generated method stub</p>
    <p>}</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Monitor</p>
    <p>Probe</p>
    <p>Support for Collection of New Kinds of Data</p>
    <p>void foo {  } void bar {  }</p>
    <p>P</p>
  </div>
  <div class="page">
    <p>Monitor</p>
    <p>Probe</p>
    <p>Support for Collection of New Kinds of Data</p>
    <p>void foo {  } void bar {  }</p>
    <p>P</p>
  </div>
  <div class="page">
    <p>Monitor</p>
    <p>New Cast Probe</p>
    <p>Support for Collection of New Kinds of Data</p>
    <p>void foo {  } void bar {  }</p>
    <p>P</p>
    <p>Probe</p>
  </div>
  <div class="page">
    <p>Support for Collection of New Kinds of Data</p>
    <p>Allow for easier creation of new types of instrumentation  Create extension to Probe plug-in  Define monitor interface  Implement probe inserter that (1) collects</p>
    <p>information of interest and (2) calls monitor</p>
    <p>Provide higher-level abstractions for common operations</p>
    <p>Simple instrumentations require only a few lines of code (e.g., cast probe is 6 lines of code)</p>
  </div>
  <div class="page">
    <p>InsectJ Architecture</p>
    <p>InsectJ implemented as a set of plug-ins  Core plugin:</p>
    <p>Instruments based on a configuration file  Provides common functionality for monitors and probe</p>
    <p>inserters</p>
    <p>Probe inserter plug-ins:  Collect different kinds of dynamic data</p>
    <p>Monitor Classes:  Predefined  User-defined</p>
  </div>
  <div class="page">
    <p>How Did Eclipse Help (or Did not)</p>
    <p>The good:  Powerful java parser</p>
    <p>Extensible</p>
    <p>Extensive, high-quality documentation</p>
    <p>Developer friendly</p>
    <p>Deployment/technology transfer</p>
    <p>The bad:  Complicated API</p>
    <p>Hard to reuse some high-level elements (JDT-UI)</p>
    <p>Error prone plug-in build process</p>
  </div>
  <div class="page">
    <p>Future Work</p>
    <p>Instrumentation at lower granularity  Statements  Context</p>
    <p>Addition of new probes (e.g., local defs and uses, assignments)</p>
    <p>Use of analysis to optimize (e.g., points-to analysis)  Tighter integration with Eclipse</p>
    <p>Visualization  Navigation  Information report</p>
  </div>
  <div class="page">
    <p>For More Information</p>
    <p>InsectJs web site http://www.cc.gatech.edu/~orso/software/insectj</p>
    <p>See demo and poster tonight</p>
    <p>Send us email {orso|zeikerd}@cc.gatech.edu</p>
    <p>?</p>
  </div>
</Presentation>
