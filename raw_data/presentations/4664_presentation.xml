<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Towards Effective Partition Ma nagement for Large Graphs</p>
    <p>Project Homepage http://grafia.cs.ucsb.edu/sedge</p>
    <p>Shengqi Yang, Xifeng Yan, Bo Zong and Arijit Khan</p>
    <p>Computer Science, UC Santa Barbara {sqyang, xyan, bzong, arijitkhan}@cs.ucsb.edu</p>
  </div>
  <div class="page">
    <p>Motivation - Challenges  New requirements for data processing</p>
    <p>Ubiquitous demands on graph data management.  Information Networks</p>
    <p>Social Networks</p>
    <p>Biological systems</p>
    <p>Communication Networks</p>
    <p>Efficient data processing in extremely large graphs.  Google: 1 trillion indexed pages</p>
    <p>Facebook: &gt;500 million active users</p>
    <p>De Bruijn: 500 million vertices</p>
  </div>
  <div class="page">
    <p>Motivation  Existed solutions</p>
    <p>Memory-resident solution  Running on single server.  Difficult/Impossible to accommodate the content of an</p>
    <p>extremely large graph.  Low concurrency.</p>
    <p>Simple distributed solution (e.g., Hadoop)  Running on commodity cluster  High concurrency and enough memory space  Some successful applications  Not ideal (poor locality and little work per vertex)</p>
  </div>
  <div class="page">
    <p>Pregel from Google (2010)</p>
    <p>Graph partitioning and distribution</p>
  </div>
  <div class="page">
    <p>Is Pregel suitable?</p>
    <p>How Pregel works (BSP model)  Distribution Model: Graph partitioning  Computational model: run on each partition (vert</p>
    <p>ex)  Communication model: message passing</p>
    <p>Why Not Pregel?  Limitations</p>
  </div>
  <div class="page">
    <p>Unbalanced work load</p>
    <p>Inter-machine co mmunication</p>
    <p>Pregel: Limitations</p>
  </div>
  <div class="page">
    <p>Our Solution: Sedge</p>
    <p>SEDGE: a Self Evolving Distributed Graph Processing</p>
    <p>Environment</p>
    <p>Solving the problems facing Pregel</p>
    <p>Workload balancing (replication)</p>
    <p>Communication reduction</p>
    <p>Novel partitioning techniques.</p>
    <p>2-level partition architecture that supports the new generat</p>
    <p>ed partitions. 2/5/19 7</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Partitioning techniques  Complementary partitioning  On-demand partitioning  Two-level partition management</p>
    <p>System Architecture  Experiments  Conclusions</p>
  </div>
  <div class="page">
    <p>Techniques: Complementary partitioning Complementary partitioning : repartition the graph wit</p>
    <p>h region constraint</p>
    <p>These two sets of partitions will run independently. 2/5/19 9</p>
  </div>
  <div class="page">
    <p>An Iterative Solution</p>
    <p>Iteratively repartition the graph  Pros</p>
    <p>Effective communication reduction</p>
    <p>Cons  Space limitation2/5/19 10</p>
  </div>
  <div class="page">
    <p>Cross-partition query profiling</p>
    <p>Blocks: coarse-granularity units that trace the path of cr oss-partition queries. e.g., C1,C2 and C3.</p>
    <p>Advantages:  Query generalization.  Profile a query with fewer features.</p>
    <p>P1 P2</p>
    <p>C1 C2 C3</p>
    <p>v1 v2</p>
    <p>v3</p>
    <p>v4</p>
    <p>v5</p>
  </div>
  <div class="page">
    <p>Techniques: On-demand partitioning</p>
    <p>P1 P2</p>
    <p>C1 C2 C3</p>
    <p>v1 v2</p>
    <p>v3</p>
    <p>v4</p>
    <p>v5</p>
    <p>P3</p>
    <p>Envelope: a sequence of blocks that covers a cross p artition query.</p>
    <p>Envelope Collection: put the maximized number of env elopes into a new partition wrt. space constraint.</p>
  </div>
  <div class="page">
    <p>A Similarity-Based Greedy Algorithm</p>
    <p>The algorithm intends to combine similar envelo pes sharing many common color-blocks.</p>
    <p>2-step greedy algorithm: 1) Similarity search (nearest neighbor search).</p>
    <p>Locality Sensitive Hashing (LSH): Min-Hash, in O(n) 2) Envelope combining</p>
  </div>
  <div class="page">
    <p>Two-level partition architecture  Primary partitions. e.g., A, B, C and D. They are inter-c</p>
    <p>onnected in two-way  Secondary partitions. e.g., B and E. They are connecte</p>
    <p>d with primary partitions in one-way</p>
    <p>Two-level partition architectur e</p>
  </div>
  <div class="page">
    <p>Sedge: System Architecture</p>
  </div>
  <div class="page">
    <p>System Evaluation: RDF gra phs</p>
    <p>SP2Bench  Employ the DBLP library as its simulation basis.  100M tuples (11.24GB).  Query templates (5 of 12): Q2, Q4, Q6, Q7, Q8.</p>
    <p>E.g. Q4: Given a journal, select all distinct pairs of article autho r names for authors that have published in the journal.</p>
    <p>Cluster environment  31 computing nodes.</p>
    <p>Among these nodes, one serves as the master and the rest as workers.</p>
  </div>
  <div class="page">
    <p>Effect of complementary partitioning</p>
    <p>Experiment setting  Partition</p>
    <p>configuration: CP1~CP5</p>
    <p>Workload: 104 Random queries</p>
    <p>Result  Significant cross</p>
    <p>query reduction  Cross query</p>
    <p>vanishes for Q2,Q4 and Q6</p>
  </div>
  <div class="page">
    <p>Evolving query workload</p>
    <p>Experiment setting  Partition configuration:</p>
    <p>CP1*5, CP5 and CP4+DP  Workload: evolving 104</p>
    <p>random queries</p>
    <p>Result  CP1*5 vs. CP5: effect of</p>
    <p>complementary partitioning</p>
    <p>CP5 vs. CP4+DP: effect of on demand partitioning</p>
  </div>
  <div class="page">
    <p>System Evaluation: real grap hs  Datasets</p>
    <p>Web graph: 30M vertices, 956M edges.  Twitter: 15M users, 57M edges.  Bio graph: 50M vertices, 51M edges.  Synthetic graph: 0.5B vertices, 2 Billion edges.</p>
    <p>Query workload  neighbor search.  random walk.  random walk with restart.</p>
  </div>
  <div class="page">
    <p>Scalability Cross-partiti0n queries vs. Avg. response time</p>
    <p>Experiment setting  Partition configuration:</p>
    <p>CP1+DP.  Workload: 104 random</p>
    <p>queries with 0%, 25%, 75% and 100% cross queries.</p>
    <p>Result  Effective for cross</p>
    <p>queries.  Effective for</p>
    <p>partitioning difficult graphs, i.e., Twitter and Bio graphs.</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>Conclusions Partitioning techniques</p>
    <p>Complementary partitioning  On-demand partitioning</p>
    <p>Two-level partition management</p>
    <p>Future work Efficient distributed RDF data storage Distributed query processing</p>
  </div>
  <div class="page">
    <p>Thank You!</p>
  </div>
</Presentation>
