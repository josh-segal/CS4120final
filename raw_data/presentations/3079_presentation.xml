<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Win32 API Emulation on UNIX for Software DSM</p>
    <p>Sven M. Paas, Thomas Bemmerl, Karsten Scholtyssik</p>
    <p>Lehrstuhl fr Betriebssysteme, RWTH Aachen, Germany</p>
    <p>http://www.lfbs.rwth-aachen.de/</p>
    <p>contact@lfbs.rwth-aachen.de</p>
    <p>Agenda:</p>
    <p>Background</p>
    <p>Our approach: emulating a reasonable Win32 API subset</p>
    <p>Implementation details of nt2unix (multithreading, memory mapped I/O, ...)</p>
    <p>A case study: SVMlib: Shared Virtual Memory Library</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Background</p>
    <p>The Problem:</p>
    <p>Given a console application written in C / C++ for Win32;</p>
    <p>--&gt; Visual C++ 5.0 + STL, Windows NT 4.0 / Windows 95</p>
    <p>Compile (and execute) the same code on a UNIX system</p>
    <p>--&gt; gcc 2.8.1 + STL, Solaris 2.6 [SPARC/x86], Linux 2.0 [x86]</p>
    <p>Available Solutions:</p>
    <p>Wind/U (Bristol Technology, Inc., http://www.bristol.com/)</p>
    <p>MainWin XDE (MainSoft Corp., http://www.mainsoft.com/)</p>
    <p>Willows Twin API (Canopy Group, http://www.willows.com/)</p>
  </div>
  <div class="page">
    <p>A reasonable Win32 Subset</p>
    <p>NT Multithreading</p>
    <p>Creating / Destroying / Suspending / Resuming preemptive threads Synchronization and Thread Local Storage (TLS) functions;</p>
    <p>Virtual Memory (VM) Management</p>
    <p>Allocating / Committing / Protecting VM on page level Memory Mapping I/O, File Mapping</p>
    <p>NT Structured Exception Handling (SEH)</p>
    <p>User Level Page Fault Handling by SEH</p>
    <p>Networking using WinSock</p>
    <p>Windows Sockets API for TCP/IP</p>
  </div>
  <div class="page">
    <p>Windows NT Multithreading</p>
    <p>Creating a Thread under NT:</p>
    <p>WINBASEAPI HANDLE WINAPI CreateThread(</p>
    <p>LPSECURITY_ATTRIBUTES lpThreadAttributes,</p>
    <p>DWORD dwStackSize,</p>
    <p>LPTHREAD_START_ROUTINE lpStartAddress,</p>
    <p>LPVOID lpParameter, DWORD dwCreationFlags,</p>
    <p>LPDWORD lpThreadId);</p>
    <p>with</p>
    <p>typedef DWORD (WINAPI *PTHREAD_START_ROUTINE)(</p>
    <p>LPVOID lpThreadParameter);</p>
    <p>typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;</p>
  </div>
  <div class="page">
    <p>UNIX Multithreading</p>
    <p>Creating a Thread using POSIX API:</p>
    <p>int pthread_create(</p>
    <p>pthread_t *new_thread_ID,</p>
    <p>const pthread_attr_t *attr,</p>
    <p>void *(*start_func)(void *), void *arg);</p>
    <p>... and using the Solaris Thread API:</p>
    <p>int thr_create(void *stack_base, size_t stack_size,</p>
    <p>void *(*start_func)(void *), void *arg, long flags,</p>
    <p>thread_t *new_thread_ID);</p>
    <p>--&gt; we must ignore LPSECURITY_ATTRIBUTES. (like Windows 95 / 98 does)</p>
  </div>
  <div class="page">
    <p>NT Thread Synchronization</p>
    <p>Problems:</p>
    <p>Susending / Resuming Threads is not possible within the POSIX Thead API! (-&gt; SuspendThread(), ResumeThread())</p>
    <p>This fact implies that some Win32 thread concepts are hard to implement efficiently within POSIX environments:</p>
    <p>struct ThreadInfo {</p>
    <p>DWORD state, suspendCount, exitCode;</p>
    <p>#ifdef __POSIX_THREADS__</p>
    <p>pthread_cond_t cond, pthread_mutex_t mutex;</p>
    <p>#else</p>
    <p>volatile BOOL threadHasBeenResumed;</p>
    <p>#endif</p>
    <p>};</p>
  </div>
  <div class="page">
    <p>Virtual Memory (VM) Management</p>
    <p>Emulating a Windows NT File Mapping Object:</p>
    <p>struct FileMapping { LPVOID lpBaseAddress; // the virtual base address of the mapping DWORD dwNumberOfBytesToMap; // the mapping size in bytes HANDLE hFileMappingObject; // the file handle char FileName[MAX_PATH]; // the file name DWORD refcnt; // the number of references to the mapping</p>
    <p>}; static vector&lt;FileMapping&gt; FileMappings;</p>
  </div>
  <div class="page">
    <p>NT Structured Exception Handling</p>
    <p>Two methods:</p>
    <p>by embracing code with a __try{} ... __except(){} block;</p>
    <p>by installing a user level exception handler by calling SetUnhandledExceptionFilter().</p>
    <p>Translation of NT Exception Codes to UNIX signals:</p>
    <p>Windows NT EXCEPTION_* Code UNIX Signal ACCESS_VIOLATION SIGSEGV</p>
    <p>FLT_INVALID_OPERATION SIGFPE ILLEGAL_INSTRUCTION SIGILL</p>
    <p>IN_PAGE_ERROR SIGBUS SINGLE_STEP SIGTRAP</p>
  </div>
  <div class="page">
    <p>Catching Page Faults</p>
    <p>ExceptionInfo.ExceptionRecord-&gt; ExceptionInformation[0] =</p>
    <p>#if defined(__SPARC) (*(unsigned *)((ucontext_t*)uap) -&gt;uc_mcontext.gregs[REG_PC] &amp; (1&lt;&lt;21));</p>
    <p>#elif defined(__X86) (((ucontext_t*)uap)-&gt; uc_mcontext.gregs[ERR] &amp; 2);</p>
    <p>#elif defined(__LINUXX86) stack[14] &amp; 2;</p>
    <p>#endif</p>
  </div>
  <div class="page">
    <p>Catching Page Faults (contd)</p>
    <p>ExceptionInfo.ExceptionRecord-&gt; ExceptionInformation[1] =</p>
    <p>#ifdef __LINUXX86 stack[22];</p>
    <p>#else (DWORD)sip-&gt;si_addr;</p>
    <p>#endif break;</p>
    <p>// other signals processed here ... }</p>
  </div>
  <div class="page">
    <p>TCP/IP Networking using WinSock</p>
    <p>Ideas: - Restrict WinSock 2.0 to BSD Socket API</p>
    <p>- Translate data types, definitions, and error codes</p>
    <p>For example:</p>
    <p>typedef int SOCKET;</p>
    <p>#define INVALID_SOCKET(SOCKET)(-1)</p>
    <p>#define SOCKET_ERROR (-1)</p>
    <p>Pitfalls: - some types are hard to map (e.g. fd_set)</p>
    <p>- WinSocks select() is not BSD select()!</p>
  </div>
  <div class="page">
    <p>A Case Study: SVMlib</p>
    <p>SVMlib: Shared Virtual Memory Library</p>
    <p>all software, user-level, page based</p>
    <p>about 15.000 lines of (Visual) C++ code, natively for Win32</p>
    <p>SVMlib API [SMI, SPLASH, CVM...]</p>
    <p>MemoryManager LockManager</p>
    <p>Communicator</p>
    <p>Page Fault</p>
    <p>Handling</p>
    <p>IntervalManager</p>
    <p>Win32 API</p>
    <p>Windows NT 4.0 nt2unix</p>
  </div>
  <div class="page">
    <p>SVMlib Performance (1)</p>
    <p>Page Fault Detection Time:</p>
    <p>--&gt; UNIX Signal handling is expensive.</p>
    <p>SuperSPARC, 50 MHz</p>
    <p>Pentium, 133 MHz</p>
    <p>Pentium Pro,</p>
    <p>Server / WS - 28 s 19 s</p>
    <p>Solaris 2.5.1 (native)</p>
    <p>Solaris 2.5.1 &amp; nt2unix</p>
  </div>
  <div class="page">
    <p>SVMlib Performance (2)</p>
    <p>Page Fault Handling Times:</p>
    <p>Test Application: FFT</p>
    <p>N o d e s</p>
    <p>R / W / Avrg Fault Time [ms] CVM on Solaris</p>
    <p>(Sun SS20)</p>
    <p>R / W / Avrg Fault Time [ms]</p>
    <p>SVMlib on nt2unix (Sun SS20)</p>
    <p>R / W / Avrg Fault Time [ms]</p>
    <p>SVMlib on Windows NT (Intel Pentium 133)</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>Win32 API Emulation under UNIX is possible.</p>
    <p>If the Emulation is application driven, it can be implemented within finite time (3 MM for SVMlib);</p>
    <p>nt2unix is a reasonable first step to develop portable low level applications.</p>
    <p>Next Steps:</p>
    <p>More complete implementation of Win32 base services;</p>
    <p>More applications (NT Services &lt;-&gt; UNIX Daemons)</p>
  </div>
  <div class="page">
    <p>Further Information</p>
    <p>nt2unix Project Homepage:</p>
    <p>http://www.lfbs.rwth-aachen.de/~sven/nt2unix/</p>
    <p>SVMlib Project Homepage:</p>
    <p>http://www.lfbs.rwth-aachen.de/~sven/SVMlib/</p>
    <p>E-Mail:</p>
    <p>contact@lfbs.rwth-aachen.de</p>
    <p>Phone/Fax:</p>
    <p>+49-241-7634, +49-241-8888-339</p>
  </div>
</Presentation>
