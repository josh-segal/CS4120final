<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>FaSST: Fast, Scalable, and Simple Distributed Transactions</p>
    <p>with Two-Sided (RDMA) Datagram RPCs</p>
    <p>Anuj Kalia (CMU) Michael Kaminsky (Intel Labs)</p>
    <p>David Andersen (CMU)</p>
  </div>
  <div class="page">
    <p>One-slide summary</p>
    <p>CPU</p>
    <p>NIC DRAM</p>
    <p>Node 2Node 1 One-sided (READ)</p>
    <p>Two-sided (SEND)</p>
    <p>Existing systems</p>
    <p>Use one-sided RDMA (READs and WRITEs) for transactions</p>
    <p>FaSST</p>
    <p>Uses RPCs over two-sided ops</p>
    <p>~2x faster than existing systems</p>
    <p>Fast, scalable, simple</p>
    <p>RECV</p>
  </div>
  <div class="page">
    <p>In-memory distributed transactions</p>
    <p>Distributed ACID transactions can be fast in datacenters FaRM [SOSP 15, NSDI 14], DrTM [SOSP 15, EuroSys 15], RSI [VLDB 16]</p>
    <p>Enablers:</p>
  </div>
  <div class="page">
    <p>Transaction environment</p>
    <p>Node 1 Node 2 Node NNode 3 x y y x</p>
    <p>How to access remote data structures?</p>
    <p>Existing systems FaSST</p>
    <p>Method One-sided READs Two-sided RPCs</p>
    <p>Round trips 2 1</p>
    <p>Hash table</p>
    <p>x</p>
    <p>Node 1</p>
    <p>Node 2</p>
    <p>READ (pointer)</p>
    <p>READ (value)</p>
    <p>RPC request RPC response</p>
  </div>
  <div class="page">
    <p>Experiment: Fetch 32-byte chunks with READs, or RPCs</p>
    <p>Tp ut</p>
    <p>/m ac</p>
    <p>hi ne</p>
    <p>(M /s</p>
    <p>)</p>
    <p>O(1,0) tput</p>
    <p>READs GETs/s (2 READs) RPCs</p>
    <p>READs GETs/s (2 READs) RPCs</p>
    <p>FaRM [SOSP 15, Fig 2] (2x ConnectX-3 NICs)</p>
    <p>CPU-limited Tp</p>
    <p>ut /m</p>
    <p>ac hi</p>
    <p>ne (M</p>
    <p>/s )</p>
    <p>O(1,0) tput</p>
    <p>READs Effective GETs/s w/ READs RPCs</p>
    <p>FaSST (1x Connect-IB NIC)</p>
    <p>NIC-limited</p>
    <p>RPC v/s READs microbenchmark</p>
    <p>FaSST RPCs make transactions faster</p>
  </div>
  <div class="page">
    <p>Existing systems FaSST</p>
    <p>Method One-sided READs Two-sided RPCs</p>
    <p>Round trips 2 1</p>
    <p>Scalable transport Effect: NIC cache misses</p>
    <p>Lock-free I/O Effect: Low per-thread tput</p>
    <p>Reasons for slow RPCS</p>
  </div>
  <div class="page">
    <p>One-sided RDMA does not scale</p>
    <p>Node 3</p>
    <p>Node N</p>
    <p>Node 2</p>
    <p>Node 1</p>
    <p>Thread</p>
    <p>Thread Re</p>
    <p>q ra</p>
    <p>te /n</p>
    <p>od e</p>
    <p>(M /s</p>
    <p>)</p>
    <p>Number of nodes (N)</p>
    <p>READs FaSST RPCs</p>
    <p>NIC cache</p>
    <p>Problem: Cache overflow</p>
    <p>READs &amp; WRITEs must use a connected transport layer</p>
    <p>Node 1 Node 2 One-sided</p>
    <p>systems</p>
    <p>READ (Reliable Connected)</p>
    <p>RPC req WRITE (Reliable Connected)</p>
    <p>RPC resp WRITE (Reliable Connected)</p>
  </div>
  <div class="page">
    <p>CPU overhead of connection sharing</p>
    <p>Problem: Connection sharing</p>
    <p>Re q</p>
    <p>ra te</p>
    <p>/t hr</p>
    <p>ea d</p>
    <p>(M /s</p>
    <p>)</p>
    <p>Sequencer throughput</p>
    <p>No sharing Sharing</p>
    <p>Single-thread tput w/ sharing</p>
    <p>Node 3</p>
    <p>Node N</p>
    <p>Node 2</p>
    <p>Node 1</p>
    <p>Thread</p>
    <p>Thread</p>
    <p>Problem: Cache overflow</p>
    <p>NIC cache</p>
    <p>Local overhead of remote bypass = 5x</p>
  </div>
  <div class="page">
    <p>Node 1 Node 2</p>
    <p>Connectionless transport scales</p>
    <p>Req SEND (Unreliable Datagram)</p>
    <p>Resp SEND (Unreliable Datagram) FaSST</p>
    <p>But it supports only two-sided (SEND/RECV) operations</p>
    <p>NIC cache</p>
    <p>Node 3</p>
    <p>Node N</p>
    <p>Node 2</p>
    <p>Node 1</p>
    <p>Thread</p>
    <p>Thread Re</p>
    <p>q ra</p>
    <p>te /t</p>
    <p>hr ea</p>
    <p>d (M</p>
    <p>/s )</p>
    <p>Sequencer throughput</p>
    <p>READs (sharing)</p>
    <p>FaSST RPCs</p>
    <p>READs vs FaSST RPCsFaSST RPCs make transactions scalable</p>
    <p>READs dont use fewer CPU cycles than RPCs! Local overhead offsets remote gains</p>
  </div>
  <div class="page">
    <p>FaSST RPCs make transactions Simpler</p>
    <p>Remote bypassing designs are complex  Redesign and rewrite data stores</p>
    <p>Hash table [FaRM-KV, NSDI 14], B-Tree [Cell, ATC 15]</p>
    <p>RPC-based designs are simple  Reuse existing data stores</p>
    <p>Hash table [MICA, NSDI 14], B-Tree [Masstree, EuroSys 12] 10</p>
  </div>
  <div class="page">
    <p>UD does not provide reliability. But the link layer does!</p>
    <p>No packet loss in</p>
    <p>69 nodes, 46 hours</p>
    <p>100 trillion packets</p>
    <p>50 PB transferred</p>
    <p>Node 2 Node 1</p>
    <p>Switch</p>
    <p>- No end-to-end reliability + Link layer flow control + Link layer retransmission</p>
    <p>Handle packet loss similar to machine failure: See paper</p>
  </div>
  <div class="page">
    <p>Performance comparison Tp</p>
    <p>ut /m</p>
    <p>ac hi</p>
    <p>ne</p>
    <p>(M /s</p>
    <p>)</p>
    <p>TAPT tput</p>
    <p>FaRM FaSST</p>
    <p>TATP benchmark (80% rdonly txns)</p>
    <p>Nodes NICs Cores FaRM 50 2x ConnectX-3 16</p>
    <p>DrTM+R 6 1x ConnectX-3 10 FaSST 50 1x ConnectX-3 8</p>
    <p>vs FaRM: FaSST uses 50% fewer h/w resources</p>
    <p>vs DrTM+R: FaSST makes no data locality assumptions</p>
    <p>Tp ut</p>
    <p>/m ac</p>
    <p>hi ne</p>
    <p>(M</p>
    <p>/s )</p>
    <p>TAPT tput</p>
    <p>DrTM+R FaSST</p>
    <p>SmallBank benchmark (85% rw txns)</p>
  </div>
  <div class="page">
    <p>Transactions with one-sided RDMA are: 1. Slow: Data access requires multiple round trips 2. Non-scalable: Connected transports 3. Complex: Redesign data stores</p>
    <p>Transactions with two-sided datagram RPCs are: 1. Fast: One round trip 2. Scalable: Datagram transport + link layer reliability 3. Simple: Re-use existing data stores</p>
    <p>Conclusion</p>
    <p>Code: https://github.com/efficient/fasst</p>
  </div>
</Presentation>
