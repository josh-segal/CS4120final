<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Combinations of theories and the Bernays-Schnfinkel-Ramsey class</p>
    <p>Pascal Fontaine</p>
    <p>Verify07</p>
    <p>July 15-16</p>
    <p>Bremen, Germany</p>
    <p>Verify07 - July 15-16 1 / 18</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Outline</p>
    <p>Verify07 - July 15-16 2 / 18</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Introduction</p>
    <p>Formal development frameworks (e.g. B, TLA+,. . . )</p>
    <p>generate a lot of proof obligations</p>
    <p>on expressive languages (for instance, set theory)</p>
    <p>Validation platforms</p>
    <p>automation (for simple proofs)</p>
    <p>interactive tools (for difficult proofs)</p>
    <p>SMT solvers?</p>
    <p>Verify07 - July 15-16 3 / 18</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Introduction</p>
    <p>Formal development frameworks (e.g. B, TLA+,. . . )</p>
    <p>generate a lot of proof obligations</p>
    <p>on expressive languages (for instance, set theory)</p>
    <p>Validation platforms</p>
    <p>automation (for simple proofs)</p>
    <p>interactive tools (for difficult proofs)</p>
    <p>SMT solvers?</p>
    <p>Verify07 - July 15-16 3 / 18</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>SMT solvers expressivity</p>
    <p>SMT solvers: incremental approach to raise expressivity</p>
    <p>SAT solvers</p>
    <p>[</p>
    <p>(p  q)  [</p>
    <p>(p  q)  q ]]</p>
    <p>Congruence closure (uninterpreted symbols + equality)</p>
    <p>a = b  [</p>
    <p>f (a) 6= f (b)  (p(a)  p(b)) ]</p>
    <p>Some arithmetic</p>
    <p>a  b  b  a + x  x = 0  [</p>
    <p>f (a) 6= f (b)  (p(a)  p(b + x)) ]</p>
    <p>. . . (Combination of theories)</p>
    <p>Sets</p>
    <p>a  b  b  a + x  x = 0  f (a)  (A  B)  [</p>
    <p>f (a)  A \ B  f (b) 6 B ]</p>
    <p>Verify07 - July 15-16 4 / 18</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Bernays-Schnfinkel-Ramsey (BSR) theories</p>
    <p>BSR class:</p>
    <p>decidable</p>
    <p>conjunction of  formulas</p>
    <p>quantifier-free, function-free</p>
    <p>=, predicates, constants, and Boolean connectives allowed</p>
    <p>Examples :</p>
    <p>x, y.p(x, y)  p(y, x)</p>
    <p>a 6= b  a 6= c  b 6= c  x.x = a  x = b  x = c</p>
    <p>Goal</p>
    <p>Combining BSR (decidable) theories with other theories Using linear arithmetic, uninterpreted symbols,. . . and predicates defined by a BSR theory</p>
    <p>Verify07 - July 15-16 5 / 18</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>SMT solvers expressivity</p>
    <p>SMT solvers: incremental approach to raise expressivity</p>
    <p>SAT solvers</p>
    <p>[</p>
    <p>(p  q)  [</p>
    <p>(p  q)  q ]]</p>
    <p>Congruence closure (uninterpreted symbols + equality)</p>
    <p>a = b  [</p>
    <p>f (a) 6= f (b)  (p(a)  p(b)) ]</p>
    <p>Some arithmetic</p>
    <p>a  b  b  a + x  x = 0  [</p>
    <p>f (a) 6= f (b)  (p(a)  p(b + x)) ]</p>
    <p>. . . (Combination of theories)</p>
    <p>Sets, relations, . . .</p>
    <p>a  b  b  a + x  x = 0  f (a)  (A  B)  [</p>
    <p>f (a)  A \ B  f (b) 6 B ]</p>
    <p>Verify07 - July 15-16 6 / 18</p>
  </div>
  <div class="page">
    <p>Combining BSR theories</p>
    <p>Outline</p>
    <p>Verify07 - July 15-16 7 / 18</p>
  </div>
  <div class="page">
    <p>Combining BSR theories Combining disjoint decision procedures</p>
    <p>Combining disjoint decision procedures (1)</p>
    <p>A combination of disjoint languages:</p>
    <p>L = {</p>
    <p>x  y, y  x + f (x), P(h(x)  h(y)), P(0), f (x) = 0 }</p>
    <p>uninterpreted symbols (P, f , h), and arithmetic (+, , , 0).</p>
    <p>Combination of disjoint decision procedures</p>
    <p>Combination of the empty theory and theory for linear arithmetic (both stably-infinite)</p>
    <p>Separation using new variables:</p>
    <p>L1 = {</p>
    <p>x  y, y  x + v1, v1 = 0, v2 = v3  v4, v5 = 0 }</p>
    <p>L2 = {</p>
    <p>P(v2), P(v5), v1 = f (x), v3 = h(x), v4 = h(y) }</p>
    <p>.</p>
    <p>L and L1  L2 both satisfiable or both unsatisfiable.</p>
    <p>Verify07 - July 15-16 8 / 18</p>
  </div>
  <div class="page">
    <p>Combining BSR theories Combining disjoint decision procedures</p>
    <p>Combining disjoint decision procedures (2)</p>
    <p>Cooperation by exchanging equalities: L1 = {x  y, y  x + v1, v1 = 0, v2 = v3  v4, v5 = 0}</p>
    <p>L2 = {P(v2), P(v5), v1 = f (x), v3 = h(x), v4 = h(y)}</p>
    <p>From L1, x = y: L1 = {x  y, y  x + v1, v1 = 0, v2 = v3  v4, v5 = 0}</p>
    <p>L2 = {P(v2), P(v5), v1 = f (x), v3 = h(x), v4 = h(y), x = y}</p>
    <p>From L2, v3 = v4: L1 = {x  y, y  x + v1, v1 = 0, v2 = v3  v4, v5 = 0, v3 = v4}</p>
    <p>L2 = {P(v2), P(v5), v1 = f (x), v3 = h(x), v4 = h(y), x = y}</p>
    <p>From L1, v2 = v5: L1 = {x  y, y  x + v1, v1 = 0, v2 = v3  v4, v5 = 0, v3 = v4}</p>
    <p>L2 = {P(v2), P(v5), v1 = f (x), v3 = h(x), v4 = h(y), x = y, v2 = v5}</p>
    <p>L2 is unsatisfiable.</p>
    <p>Verify07 - July 15-16 9 / 18</p>
  </div>
  <div class="page">
    <p>Combining BSR theories Combining disjoint decision procedures</p>
    <p>Combining disjoint decision procedures (2)</p>
    <p>Cooperation by exchanging equalities: L1 = {x  y, y  x + v1, v1 = 0, v2 = v3  v4, v5 = 0}</p>
    <p>L2 = {P(v2), P(v5), v1 = f (x), v3 = h(x), v4 = h(y)}</p>
    <p>From L1, x = y: L1 = {x  y, y  x + v1, v1 = 0, v2 = v3  v4, v5 = 0}</p>
    <p>L2 = {P(v2), P(v5), v1 = f (x), v3 = h(x), v4 = h(y), x = y}</p>
    <p>From L2, v3 = v4: L1 = {x  y, y  x + v1, v1 = 0, v2 = v3  v4, v5 = 0, v3 = v4}</p>
    <p>L2 = {P(v2), P(v5), v1 = f (x), v3 = h(x), v4 = h(y), x = y}</p>
    <p>From L1, v2 = v5: L1 = {x  y, y  x + v1, v1 = 0, v2 = v3  v4, v5 = 0, v3 = v4}</p>
    <p>L2 = {P(v2), P(v5), v1 = f (x), v3 = h(x), v4 = h(y), x = y, v2 = v5}</p>
    <p>L2 is unsatisfiable.</p>
    <p>Verify07 - July 15-16 9 / 18</p>
  </div>
  <div class="page">
    <p>Combining BSR theories Combining disjoint decision procedures</p>
    <p>Combining disjoint decision procedures (2)</p>
    <p>Cooperation by exchanging equalities: L1 = {x  y, y  x + v1, v1 = 0, v2 = v3  v4, v5 = 0}</p>
    <p>L2 = {P(v2), P(v5), v1 = f (x), v3 = h(x), v4 = h(y)}</p>
    <p>From L1, x = y: L1 = {x  y, y  x + v1, v1 = 0, v2 = v3  v4, v5 = 0}</p>
    <p>L2 = {P(v2), P(v5), v1 = f (x), v3 = h(x), v4 = h(y), x = y}</p>
    <p>From L2, v3 = v4: L1 = {x  y, y  x + v1, v1 = 0, v2 = v3  v4, v5 = 0, v3 = v4}</p>
    <p>L2 = {P(v2), P(v5), v1 = f (x), v3 = h(x), v4 = h(y), x = y}</p>
    <p>From L1, v2 = v5: L1 = {x  y, y  x + v1, v1 = 0, v2 = v3  v4, v5 = 0, v3 = v4}</p>
    <p>L2 = {P(v2), P(v5), v1 = f (x), v3 = h(x), v4 = h(y), x = y, v2 = v5}</p>
    <p>L2 is unsatisfiable.</p>
    <p>Verify07 - July 15-16 9 / 18</p>
  </div>
  <div class="page">
    <p>Combining BSR theories Combining disjoint decision procedures</p>
    <p>Combining disjoint decision procedures (2)</p>
    <p>Cooperation by exchanging equalities: L1 = {x  y, y  x + v1, v1 = 0, v2 = v3  v4, v5 = 0}</p>
    <p>L2 = {P(v2), P(v5), v1 = f (x), v3 = h(x), v4 = h(y)}</p>
    <p>From L1, x = y: L1 = {x  y, y  x + v1, v1 = 0, v2 = v3  v4, v5 = 0}</p>
    <p>L2 = {P(v2), P(v5), v1 = f (x), v3 = h(x), v4 = h(y), x = y}</p>
    <p>From L2, v3 = v4: L1 = {x  y, y  x + v1, v1 = 0, v2 = v3  v4, v5 = 0, v3 = v4}</p>
    <p>L2 = {P(v2), P(v5), v1 = f (x), v3 = h(x), v4 = h(y), x = y}</p>
    <p>From L1, v2 = v5: L1 = {x  y, y  x + v1, v1 = 0, v2 = v3  v4, v5 = 0, v3 = v4}</p>
    <p>L2 = {P(v2), P(v5), v1 = f (x), v3 = h(x), v4 = h(y), x = y, v2 = v5}</p>
    <p>L2 is unsatisfiable.</p>
    <p>Verify07 - July 15-16 9 / 18</p>
  </div>
  <div class="page">
    <p>Combining BSR theories Combining disjoint decision procedures</p>
    <p>Combining disj. DPs : unsatisfiable scenario</p>
    <p>deduced (disj. of) equality</p>
    <p>deduced (disj. of) equality</p>
    <p>deduced (disj. of) equality</p>
    <p>Dec. Proc. 2Dec. Proc. 1</p>
    <p>UNSAT</p>
    <p>OK : every deduced fact is a consequence of the original set of formulas</p>
    <p>Verify07 - July 15-16 10 / 18</p>
  </div>
  <div class="page">
    <p>Combining BSR theories Combining disjoint decision procedures</p>
    <p>Combining disj. DPs : satisfiable scenario</p>
    <p>deduced (disj. of) equality</p>
    <p>deduced (disj. of) equality</p>
    <p>deduced (disj. of) equality</p>
    <p>Dec. Proc. 2Dec. Proc. 1</p>
    <p>No more deducible (disj. of) eq.</p>
    <p>Model 1 Model 2</p>
    <p>Model 1 + 2</p>
    <p>Really SAT?</p>
    <p>all disjunctions of equalities propagated</p>
    <p>models agree on cardinalities</p>
    <p>Verify07 - July 15-16 11 / 18</p>
  </div>
  <div class="page">
    <p>Combining BSR theories Combining disjoint decision procedures</p>
    <p>Combining disj. DPs : satisfiable scenario</p>
    <p>deduced (disj. of) equality</p>
    <p>deduced (disj. of) equality</p>
    <p>deduced (disj. of) equality</p>
    <p>Dec. Proc. 2Dec. Proc. 1</p>
    <p>No more deducible (disj. of) eq.</p>
    <p>Model 1</p>
    <p>Model 1 + 2</p>
    <p>Model 2</p>
    <p>Really SAT?</p>
    <p>all disjunctions of equalities propagated</p>
    <p>models agree on cardinalities</p>
    <p>Verify07 - July 15-16 11 / 18</p>
  </div>
  <div class="page">
    <p>Combining BSR theories Combining non-stably infinite theories</p>
    <p>Ensuring agreement on cardinalities?</p>
    <p>Different frameworks (and capabilities)</p>
    <p>Nelson-Oppen: requirement on theories: stably infinite (not suitable for BSR) if satisfiable, there is an infinite model (FOL theories  0)</p>
    <p>Combining with the empty theory (and some others): the empty theory does not constraint much the cardinalities</p>
    <p>BSR theory and theory with only finite models: check every finite model against BSR theory</p>
    <p>We show:</p>
    <p>possible to know exactly accepted cardinalities for BSR theory</p>
    <p>thus, combination possible if other theory can say if it accepts given cardinality</p>
    <p>Verify07 - July 15-16 12 / 18</p>
  </div>
  <div class="page">
    <p>Combining BSR theories BSR theories and cardinalities</p>
    <p>BSR theories and cardinalities</p>
    <p>Well-known result:</p>
    <p>Finite model property</p>
    <p>If a BSR theory has a model, it has a finite model Size: at most the number of ground terms k</p>
    <p>Simple property</p>
    <p>If it has a model with cardinality j, it has a model for every j such that k  j  j</p>
    <p>Verify07 - July 15-16 13 / 18</p>
  </div>
  <div class="page">
    <p>Combining BSR theories BSR theories and cardinalities</p>
    <p>BSR theories and cardinalities (2)</p>
    <p>Two scenarios for a given BSR theory</p>
    <p>has infinite model, and accepts models for every cardinality  k</p>
    <p>Combination? Check if other theory accepts model greater than k</p>
    <p>has no infinite model, and accepts a finite number of cardinalities, all cardinalities between k and the max j being accepted</p>
    <p>Combination? Finite number of cardinalities to check</p>
    <p>How to know which scenario occurs? Does a BSR theory has an infinite model?</p>
    <p>Verify07 - July 15-16 14 / 18</p>
  </div>
  <div class="page">
    <p>Combining BSR theories BSR theories and cardinalities</p>
    <p>BSR theories and cardinalities (3)</p>
    <p>Theorem</p>
    <p>A BSR-theory has an infinite model if and only if it has a finite model with some (see paper) symmetry properties</p>
    <p>Checking if such a finite model exists is decidable</p>
    <p>Verify07 - July 15-16 15 / 18</p>
  </div>
  <div class="page">
    <p>Combining BSR theories BSR theories and cardinalities</p>
    <p>From set (or relation) operators to BSR</p>
    <p>For instance:</p>
    <p>a = b  ({f (a)}  E)  A  f (b) 6 C  A  B = C  D</p>
    <p>becomes</p>
    <p>a = b  x[(x = f (a)  E(x))  A(x)]  C(f (b))</p>
    <p>x. [A(x)  B(x)]  [C(x)  D(x)]</p>
    <p>with separation variables:</p>
    <p>a = b  y = f (a)  z = f (b)</p>
    <p>x[(x = y  E(x))  A(x)]  C(z)  x. [A(x)  B(x)]  [C(x)  D(x)]</p>
    <p>Finally: combination of a BSR theory with empty theory</p>
    <p>Verify07 - July 15-16 16 / 18</p>
  </div>
  <div class="page">
    <p>Combining BSR theories BSR theories and cardinalities</p>
    <p>From set (or relation) operators to BSR</p>
    <p>For instance:</p>
    <p>a = b  ({f (a)}  E)  A  f (b) 6 C  A  B = C  D</p>
    <p>becomes</p>
    <p>a = b  x[(x = f (a)  E(x))  A(x)]  C(f (b))</p>
    <p>x. [A(x)  B(x)]  [C(x)  D(x)]</p>
    <p>with separation variables:</p>
    <p>a = b  y = f (a)  z = f (b)</p>
    <p>x[(x = y  E(x))  A(x)]  C(z)  x. [A(x)  B(x)]  [C(x)  D(x)]</p>
    <p>Finally: combination of a BSR theory with empty theory</p>
    <p>Verify07 - July 15-16 16 / 18</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Outline</p>
    <p>Verify07 - July 15-16 17 / 18</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Conclusion</p>
    <p>BSR theory has an infinite model? decidable</p>
    <p>decidability result on combining BSR theories removing strong requirements from previous combination frameworks</p>
    <p>BSR + theories with infinite models BSR + linear arithmetic + uninterpreted symbols + arrays +. . .</p>
    <p>Adding set (relation,. . . ) operators to language of SMT solvers</p>
    <p>First prototype for the combination with the empty theory</p>
    <p>Future work: the general case in practice, proof reconstruction (w.i.p.)</p>
    <p>Verify07 - July 15-16 18 / 18</p>
  </div>
</Presentation>
