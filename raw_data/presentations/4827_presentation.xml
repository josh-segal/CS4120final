<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Leveraging New Plans in AgentSpeak(PL)</p>
    <p>Felipe Meneguzzi felipe.meneguzzi@kcl.ac.uk</p>
    <p>Michael Luck michael.luck@kcl.ac.uk</p>
    <p>Declarative Agent Languages and Technologies AAMAS 2008  Estoril, Portugal</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 1 / 18</p>
  </div>
  <div class="page">
    <p>. . .1 Background</p>
    <p>. . .2 AgentSpeak(PL)</p>
    <p>. . .3 Leveraging new plans</p>
    <p>. . .4 Experiments and Results</p>
    <p>. . .5 Conclusions and Future Work</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 2 / 18</p>
  </div>
  <div class="page">
    <p>AgentSpeak(L)</p>
    <p>Procedural agent language Based on the BDI model Designer specifies plans in a library</p>
    <p>I Plans encode procedures I Plans are characterised</p>
    <p>by trigger and context condition</p>
    <p>I Goals are implicit in the plans</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 3 / 18</p>
  </div>
  <div class="page">
    <p>Planning in AgentSpeak(PL) AgentSpeak(L) + Planning</p>
    <p>I Standard AgentSpeak(L) language I Planner invoked through an atomic action</p>
    <p>In principle, any state-space planner can be used</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 4 / 18</p>
  </div>
  <div class="page">
    <p>AgentSpeak(L) to STRIPS</p>
    <p>&lt; at(A);</p>
    <p>: at(O, A) &amp; not at(O, B)</p>
    <p>+!move(O, A, B)</p>
    <p>at(B)</p>
    <p>at(A)</p>
    <p>at(A) &amp; not at(B)</p>
    <p>move(O, A, B)</p>
    <p>add:</p>
    <p>del:</p>
    <p>pre:</p>
    <p>operator:</p>
    <p>+at(B).</p>
    <p>Relies on clear similarities between AgentSpeak plans and STRIPS operators Desired world state becomes the planners goal Belief base becomes the planners start state</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 5 / 18</p>
  </div>
  <div class="page">
    <p>STRIPS to AgentSpeak(L)</p>
    <p>STRIPS plan to achieve battery(full):</p>
    <p>move(1,1) move(1,2) charge</p>
    <p>AgentSpeak(L): +!goal conj([battery(full)]) : true &lt;- !move(1,1);</p>
    <p>!move(1,2); !charge.</p>
    <p>Each STRIPS action correspond to a low-level AgentSpeak(L) plan Plans amount to a series of AgentSpeak(L) subgoals</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 6 / 18</p>
  </div>
  <div class="page">
    <p>Executing Plans and Limitations</p>
    <p>Generated plan is executed as a regular AgentSpeak(L) plan Planning is computationally expensive New plans should be added to the plan library However this is not so trivial:</p>
    <p>I How should a new plan be added? I What should the context condition be?</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 7 / 18</p>
  </div>
  <div class="page">
    <p>Leveraging new plans</p>
    <p>Key aspects: I Ordering of the plan library - new plans must come before</p>
    <p>planning plan I Generation of minimum context condition</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 8 / 18</p>
  </div>
  <div class="page">
    <p>Ordering Example - Pseudo PL</p>
    <p>+!move(P,A,B) : empty(B) &amp; over(P,A) &lt;- ...</p>
    <p>+!process(P,A) : over(P,A) &lt;- ...</p>
    <p>+!goal_conj([over(p1,u1)]) : over(p1,u2) &lt;- !move(p1,u2,u1).</p>
    <p>// Place new plans here</p>
    <p>+!goal_conj(Goals) : true &lt;- .plan(Goals).</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 9 / 18</p>
  </div>
  <div class="page">
    <p>Planning Graph</p>
    <p>Context generation algorithm uses planning graph Directed levelled graph Interleaved proposition and action levels Preconditions and Effect arcs connect levels</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 10 / 18</p>
  </div>
  <div class="page">
    <p>Generating Context Information</p>
    <p>Preconditions of a plan step must be true earlier in the graph Need to propagate preconditions back to previous operators, or to the first level Intuitively:</p>
    <p>I Create a planning graph with the target plan I Connect preconditions of each action level to the previous</p>
    <p>one I If no action causes the precondition in that level, add a noop I Propositions propagated to the first level become the context</p>
    <p>condition</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 11 / 18</p>
  </div>
  <div class="page">
    <p>A Production Cell Example</p>
    <p>Production cell with four processing units and a crane Parts can be moved around to processing units Processing units can process parts</p>
    <p>Operator Preconditions Effects move(P,A,B) empty(B) empty(B)</p>
    <p>over(P,A) over(P,A) over(P,B) empty(A)</p>
    <p>process(P,A) over(P,A) processed(P)</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 12 / 18</p>
  </div>
  <div class="page">
    <p>A Production Cell Example: Part II</p>
    <p>Generating context condition for plan: move(p1,u1,u2) process(p1,u2) move(p1,u2,u3)</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 13 / 18</p>
  </div>
  <div class="page">
    <p>Experiments</p>
    <p>Uses production cell scenario Large numbers of parts coming in for processing Three types of parts, different sequences of processing Measure agent reaction time as new plans are created AgentSpeak(L) versus Naive AgentSpeak(PL) versus AgentSpeak(PL)</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 14 / 18</p>
  </div>
  <div class="page">
    <p>Results</p>
    <p>Naive AgentSpeak(PL) very inefficient Plan reuse strategy amortises cost of planning Over time, computational cost of planning approximates traditional AgentSpeak(L)</p>
    <p>T im</p>
    <p>e</p>
    <p>Parts</p>
    <p>Runtime</p>
    <p>ASPL NaiveAS</p>
    <p>AS</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 15 / 18</p>
  </div>
  <div class="page">
    <p>Conclusions and Future Work</p>
    <p>Conclusions: I Plan reuse bridges performance gap introduced by planning I Algorithm has polynomial complexity (like graph construction</p>
    <p>in GraphPlan) I More complex than necessary, but extensible</p>
    <p>Future Work: I Extending algorithm to handle richer operators</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 16 / 18</p>
  </div>
  <div class="page">
    <p>Questions?</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 17 / 18</p>
  </div>
  <div class="page">
    <p>Surprise Slide - Alternative algorithm</p>
    <p>A simpler algorithm may be possible</p>
    <p>Open =  for i = n to 2 do</p>
    <p>Open = Open  preconditions(ai ) Open = Open  postcondition(ai  1)</p>
    <p>end forOpen = Open  preconditions(a1)</p>
    <p>F. Meneguzzi and M. Luck (KCL) Leveraging New Plans in AgentSpeak(PL) DALT 2008 18 / 18</p>
  </div>
</Presentation>
