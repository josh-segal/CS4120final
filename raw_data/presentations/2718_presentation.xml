<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>I Cant Believe Its Not Causal ! Scalable Causal Consistency with No Slowdown Cascades</p>
    <p>Syed Akbar Mehdi1, Cody Littley1, Natacha Crooks1, Lorenzo Alvisi1,4, Nathan Bronson2, Wyatt Lloyd3</p>
  </div>
  <div class="page">
    <p>Causal Consistency: Great In Theory</p>
    <p>Lots of exciting research building scalable causal data-stores, e.g.,</p>
    <p>Causal Consistency Eventual Consistency</p>
    <p>Strong Consistency</p>
    <p>H ig he</p>
    <p>r P er f.</p>
    <p>Stronger Guarantees</p>
    <p>COPS [SOSP 11]  Bolt-On [SIGMOD 13]  Chain Reaction [EuroSys 13]</p>
    <p>Eiger [NSDI 13]  Orbe [SOCC 13]  GentleRain [SOCC 14]</p>
    <p>Cure [ICDCS 16]  TARDiS [SIGMOD 16]</p>
  </div>
  <div class="page">
    <p>Causal Consistency: But In Practice</p>
    <p>The middle child of consistency models</p>
    <p>Espresso TAO Manhattan Reality: Largest web apps use eventual consistency, e.g.,</p>
  </div>
  <div class="page">
    <p>Key Hurdle: Slowdown Cascades</p>
    <p>Enforce</p>
    <p>Consistency</p>
    <p>Implicit Assumption of Current Causal Systems</p>
    <p>Reality at Scale Slowdown Cascade</p>
    <p>Wait</p>
    <p>Wait</p>
  </div>
  <div class="page">
    <p>Datacenter A Datacenter B</p>
    <p>Replicated and sharded storage for a social network</p>
  </div>
  <div class="page">
    <p>W1</p>
    <p>Datacenter A Datacenter B</p>
    <p>Writes causally ordered as &quot;  $  %</p>
  </div>
  <div class="page">
    <p>W1</p>
    <p>Buffered</p>
    <p>Buffered</p>
    <p>Datacenter A Datacenter B</p>
    <p>Applied ?W2</p>
    <p>Applied ?W1</p>
    <p>Current causal systems enforce consistency as a datastore invariant</p>
    <p>W2</p>
    <p>W3</p>
  </div>
  <div class="page">
    <p>W1</p>
    <p>Buffered</p>
    <p>Buffered</p>
    <p>Datacenter A Datacenter B</p>
    <p>Applied ?W2</p>
    <p>Applied ?W1</p>
    <p>Alices advisor unnecessarily waits for Justin Biebers update despite not reading it</p>
    <p>W2</p>
    <p>W3</p>
    <p>Delayed</p>
    <p>Slowdown Cascade</p>
    <p>W1</p>
  </div>
  <div class="page">
    <p>W1</p>
    <p>Buffered</p>
    <p>Buffered</p>
    <p>Datacenter A Datacenter B</p>
    <p>Applied ?W2</p>
    <p>Applied ?W1</p>
    <p>Alices advisor unnecessarily waits for Justin Biebers update despite not reading it</p>
    <p>W2</p>
    <p>W3</p>
    <p>Delayed</p>
    <p>Slowdown Cascade</p>
    <p>W1</p>
    <p>Slowdown cascades affect all previous causal systems because they enforce consistency inside the data store</p>
  </div>
  <div class="page">
    <p>Slowdown Cascades in Eiger (NSDI 13)</p>
    <p>Bu ff</p>
    <p>er ed</p>
    <p>R ep</p>
    <p>lic at</p>
    <p>ed W</p>
    <p>rit es</p>
    <p>Replicated writes received</p>
    <p>Normal Slowdown</p>
    <p>Replicated write buffers grow arbitrarily because Eiger enforces consistency</p>
    <p>inside the datastore</p>
  </div>
  <div class="page">
    <p>OCCULT Observable Causal Consistency Using Lossy Timestamps</p>
  </div>
  <div class="page">
    <p>Causal Consistency guarantees that each client observes a monotonically non-decreasing set of updates (including its own) in</p>
    <p>an order that respects potential causality between operations</p>
    <p>Observable Causal Consistency</p>
    <p>Key Idea: Dont implement a causally consistent data store Let clients observe a causally consistent data store</p>
  </div>
  <div class="page">
    <p>How do clients observe a causally consistent datastore ?</p>
    <p>Datacenter A Datacenter B</p>
  </div>
  <div class="page">
    <p>Master</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Writes accepted only by master shards and then replicated asynchronously in-order to slaves</p>
    <p>Datacenter A Datacenter B</p>
  </div>
  <div class="page">
    <p>Master</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Each shard keeps track of a shardstamp which counts the writes it has applied</p>
    <p>Datacenter A Datacenter B</p>
  </div>
  <div class="page">
    <p>Master</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Causal Timestamp: Vector of shardstamps which identifies a global state across all shards</p>
    <p>Client 1</p>
    <p>Client 2</p>
    <p>Client 3</p>
    <p>Datacenter A Datacenter B</p>
  </div>
  <div class="page">
    <p>Master</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Client 1</p>
    <p>Client 2</p>
    <p>Client 3</p>
    <p>Datacenter A Datacenter B</p>
    <p>Write Protocol: Causal timestamps stored with objects to propagate dependencies</p>
  </div>
  <div class="page">
    <p>Master</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Client 1</p>
    <p>Client 2</p>
    <p>Client 3</p>
    <p>Write Protocol: Server shardstamp is incremented and merged into causal timestamps</p>
    <p>Datacenter A Datacenter B</p>
  </div>
  <div class="page">
    <p>Master</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Client 1</p>
    <p>Client 2</p>
    <p>Client 3</p>
    <p>Read Protocol: Always safe to read from master</p>
    <p>Datacenter A Datacenter B</p>
  </div>
  <div class="page">
    <p>Master</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Client 1</p>
    <p>Client 2</p>
    <p>Client 3</p>
    <p>Read Protocol: Objects causal timestamp merged into clients causal timestamp</p>
    <p>Datacenter A Datacenter B</p>
  </div>
  <div class="page">
    <p>Master</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Client 1</p>
    <p>Client 2</p>
    <p>Client 3</p>
    <p>Datacenter A Datacenter B</p>
    <p>Read Protocol: Causal timestamp merging tracks causal ordering for writes following reads</p>
  </div>
  <div class="page">
    <p>a</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Client 1</p>
    <p>Client 2</p>
    <p>Client 3</p>
    <p>Delayed!</p>
    <p>Datacenter A Datacenter B</p>
    <p>Replication: Like eventual consistency; asynchronous, unordered, writes applied immediately</p>
  </div>
  <div class="page">
    <p>a</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Client 1</p>
    <p>Client 2</p>
    <p>Client 3</p>
    <p>Delayed!</p>
    <p>Replication: Slaves increment their shardstamps using causal timestamp of a replicated write</p>
    <p>Datacenter A Datacenter B</p>
  </div>
  <div class="page">
    <p>Master</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Client 1</p>
    <p>Client 2</p>
    <p>Client 3</p>
    <p>Read Protocol: Clients do consistency check when reading from slaves</p>
    <p>Datacenter A Datacenter B</p>
  </div>
  <div class="page">
    <p>Master</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Client 1</p>
    <p>Client 2</p>
    <p>Client 3</p>
    <p>Delayed!</p>
    <p>Read Protocol: Clients do consistency check when reading from slaves</p>
    <p>Datacenter A Datacenter B</p>
    <p>bs dependencies are delayed, but we can read it anyway!</p>
  </div>
  <div class="page">
    <p>Master</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Client 1</p>
    <p>Client 2</p>
    <p>Client 3</p>
    <p>?7 8</p>
    <p>Stale Shard !</p>
    <p>Delayed!</p>
    <p>Read Protocol: Clients do consistency check when reading from slaves</p>
    <p>Datacenter A Datacenter B</p>
  </div>
  <div class="page">
    <p>Master</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Master</p>
    <p>Client 1</p>
    <p>Client 2</p>
    <p>Client 3</p>
    <p>?7 8</p>
    <p>Stale Shard !</p>
    <p>Delayed!</p>
    <p>Options: 1. Retry locally 2. Read from master</p>
    <p>Read Protocol: Resolving stale reads</p>
    <p>Datacenter A Datacenter B</p>
  </div>
  <div class="page">
    <p>Causal Timestamp Compression  What happens at scale when number of shards is (say) 100,000 ?</p>
    <p>Size(Causal Timestamp) == 100,000 ?</p>
  </div>
  <div class="page">
    <p>Causal Timestamp Compression: Strawman  To compress down to n, conflate shardstamps with same ids modulo n</p>
    <p>Compress</p>
    <p>Problem: False Dependencies  Solution:  Use system clock as the next value of shardstamp on a write  Decouples shardstamp value from number of writes on each shard</p>
  </div>
  <div class="page">
    <p>Causal Timestamp Compression: Strawman  To compress down to n, conflate shardstamps with same ids modulo n</p>
    <p>Compress</p>
    <p>Problem: Modulo arithmetic still conflates unrelated shardstamps</p>
  </div>
  <div class="page">
    <p>Causal Timestamp Compression  Insight: Recent shardstamps more likely to create false dependencies  Use high resolution for recent shardstamps and conflate the rest</p>
    <p>Shardstamps</p>
    <p>Shard IDs</p>
    <p>Catch-all shardstamp</p>
    <p>0.01 % false dependencies with just 4 shardstamps and 16K logical shards</p>
  </div>
  <div class="page">
    <p>Transactions in OCCULT Scalable causally consistent general purpose transactions</p>
  </div>
  <div class="page">
    <p>A. Atomicity B. Read from a causally consistent snapshot C. No concurrent conflicting writes</p>
    <p>Properties of Transactions</p>
  </div>
  <div class="page">
    <p>A. Observable Atomicity B. Observably Read from a causally consistent snapshot C. No concurrent conflicting writes</p>
    <p>Properties of Transactions</p>
  </div>
  <div class="page">
    <p>A. Observable Atomicity B. Observably Read from a causally consistent snapshot C. No concurrent conflicting writes</p>
    <p>Properties of Transactions</p>
    <p>Properties of Protocol</p>
  </div>
  <div class="page">
    <p>A. Observable Atomicity B. Observably Read from a causally consistent snapshot C. No concurrent conflicting writes</p>
    <p>Properties of Transactions</p>
    <p>Three Phase Protocol</p>
  </div>
  <div class="page">
    <p>c = [Cal]</p>
    <p>a = []</p>
    <p>Master</p>
    <p>Master</p>
    <p>b = [Bob]</p>
    <p>a = []</p>
    <p>b = [Bob]</p>
    <p>c = [Cal]</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Alice and her advisor are managing lists of students for three courses</p>
    <p>Datacenter A Datacenter B</p>
  </div>
  <div class="page">
    <p>c = [Cal]</p>
    <p>a = []</p>
    <p>Master</p>
    <p>Master</p>
    <p>b = [Bob]</p>
    <p>a = []</p>
    <p>b = [Bob]</p>
    <p>c = [Cal]</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Observable atomicity and causally consistent snapshot reads enforced by single mechanism</p>
    <p>Datacenter A Datacenter B</p>
  </div>
  <div class="page">
    <p>c = [Cal]</p>
    <p>a = []</p>
    <p>Master</p>
    <p>Master</p>
    <p>b = [Bob]</p>
    <p>a = []</p>
    <p>b = [Bob]</p>
    <p>c = [Cal]</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Datacenter A Datacenter B</p>
    <p>Start T1 r(a) = []</p>
    <p>w(a = [Abe])</p>
    <p>Transaction T1 : Alice adding Abe to course a</p>
  </div>
  <div class="page">
    <p>c = [Cal]</p>
    <p>a = [Abe]</p>
    <p>Master</p>
    <p>Master</p>
    <p>b = [Bob]</p>
    <p>a = []</p>
    <p>b = [Bob]</p>
    <p>c = [Cal]</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Datacenter A Datacenter B</p>
    <p>Start T1 r(a) = []</p>
    <p>w(a = [Abe]) Commit T1</p>
    <p>Transaction T1 : After Commit</p>
  </div>
  <div class="page">
    <p>c = [Cal]</p>
    <p>a = [Abe]</p>
    <p>Master</p>
    <p>Master</p>
    <p>b = [Bob]</p>
    <p>a = []</p>
    <p>b = [Bob]</p>
    <p>c = [Cal]</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Transaction T2 : Alice moving Bob from course b to course c</p>
    <p>Datacenter A Datacenter B</p>
    <p>Start T1 r(a) = []</p>
    <p>w(a = [Abe]) Commit T1</p>
    <p>Start T2 r(b) = [Bob] r(c) = [Cal]</p>
  </div>
  <div class="page">
    <p>c = [Cal]</p>
    <p>a = [Abe]</p>
    <p>Master</p>
    <p>Master</p>
    <p>b = [Bob]</p>
    <p>a = []</p>
    <p>b = [Bob]</p>
    <p>c = [Cal]</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Observable Atomicity: Make writes causally dependent on each other</p>
    <p>Datacenter A Datacenter B</p>
    <p>Start T1 r(a) = []</p>
    <p>w(a = [Abe]) Commit T1</p>
    <p>Start T2 r(b) = [Bob] r(c) = [Cal]</p>
    <p>Atomicity through causality: Make writes dependent on each other</p>
  </div>
  <div class="page">
    <p>c = [Bob, Cal]</p>
    <p>a = [Abe]</p>
    <p>Master</p>
    <p>Master</p>
    <p>b = []</p>
    <p>a = []</p>
    <p>b = [Bob]</p>
    <p>c = [Cal]</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Observable Atomicity: Same commit timestamp makes writes causally dependent on each other</p>
    <p>Datacenter A Datacenter B</p>
    <p>Start T1 r(a) = []</p>
    <p>w(a = [Abe]) Commit T1</p>
    <p>Start T2 r(b) = [Bob] r(c) = [Cal] w(b = [])</p>
    <p>w(c = [Bob, Cal]) Commit T2</p>
  </div>
  <div class="page">
    <p>c = [Bob, Cal]</p>
    <p>a = [Abe]</p>
    <p>Master</p>
    <p>Master</p>
    <p>b = []</p>
    <p>a = []</p>
    <p>b = [Bob]</p>
    <p>c = [Bob, Cal]</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Transaction writes replicate asynchronously</p>
    <p>Datacenter A Datacenter B</p>
    <p>Start T1 r(a) = []</p>
    <p>w(a = [Abe]) Commit T1</p>
    <p>Start T2 r(b) = [Bob] r(c) = [Cal] w(b = [])</p>
    <p>w(c = [Bob, Cal]) Commit T2</p>
    <p>Delayed!</p>
  </div>
  <div class="page">
    <p>c = [Bob, Cal]</p>
    <p>a = [Abe]</p>
    <p>Master</p>
    <p>Master</p>
    <p>b = []</p>
    <p>a = []</p>
    <p>b = [Bob]</p>
    <p>c = [Bob, Cal]</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Datacenter A Datacenter B</p>
    <p>Start T1 r(a) = []</p>
    <p>w(a = [Abe]) Commit T1</p>
    <p>Start T2 r(b) = [Bob] r(c) = [Cal] w(b = [])</p>
    <p>w(c = [Bob, Cal]) Commit T2</p>
    <p>Delayed!</p>
    <p>Alices advisor reads the lists in a transaction</p>
    <p>Start T3</p>
  </div>
  <div class="page">
    <p>c = [Bob, Cal]</p>
    <p>c = [Bob, Cal]</p>
    <p>a = [Abe]</p>
    <p>Master</p>
    <p>Master</p>
    <p>b = []</p>
    <p>a = []</p>
    <p>b = [Bob]</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Datacenter A Datacenter B</p>
    <p>Start T1 r(a) = []</p>
    <p>w(a = [Abe]) Commit T1</p>
    <p>Start T2 r(b) = [Bob] r(c) = [Cal] w(b = [])</p>
    <p>w(c = [Bob, Cal]) Commit T2</p>
    <p>Start T3 r(b) = [Bob]</p>
    <p>Delayed!</p>
    <p>Delayed!</p>
    <p>T3 Read Set</p>
    <p>Transactions maintain a Read Set to validate atomicity and read from causal snapshot</p>
    <p>b = [Bob] 1 0 1 0</p>
  </div>
  <div class="page">
    <p>c = [Bob, Cal]</p>
    <p>c = [Bob, Cal]</p>
    <p>a = [Abe]</p>
    <p>Master</p>
    <p>Master</p>
    <p>b = []</p>
    <p>a = []</p>
    <p>b = [Bob]</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Datacenter A Datacenter B</p>
    <p>Start T1 r(a) = []</p>
    <p>w(a = [Abe]) Commit T1</p>
    <p>Start T2 r(b) = [Bob] r(c) = [Cal] w(b = [])</p>
    <p>w(c = [Bob, Cal]) Commit T2</p>
    <p>Start T3 r(b) = [Bob]</p>
    <p>r(c) = [Bob,Cal]</p>
    <p>Delayed!</p>
    <p>Delayed!</p>
    <p>T3 Read Set b = [Bob]</p>
    <p>c = [Bob, Cal] 1 22</p>
    <p>Transactions maintain a Read Set to validate atomicity and read from causal snapshot</p>
  </div>
  <div class="page">
    <p>c = [Bob, Cal]</p>
    <p>c = [Bob, Cal]</p>
    <p>a = [Abe]</p>
    <p>Master</p>
    <p>Master</p>
    <p>b = []</p>
    <p>a = []</p>
    <p>b = [Bob]</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Datacenter A Datacenter B</p>
    <p>Start T1 r(a) = []</p>
    <p>w(a = [Abe]) Commit T1</p>
    <p>Start T2 r(b) = [Bob] r(c) = [Cal] w(b = [])</p>
    <p>w(c = [Bob, Cal]) Commit T2</p>
    <p>Start T3 r(b) = [Bob]</p>
    <p>r(c) = [Bob,Cal]</p>
    <p>Delayed!</p>
    <p>Delayed!</p>
    <p>T3 Read Set</p>
    <p>Validation failure: c knows more writes from grey shard than applied at the time b was read</p>
    <p>b = [Bob] 0 1 0</p>
    <p>c = [Bob, Cal] 1 22 2</p>
  </div>
  <div class="page">
    <p>c = [Bob, Cal]</p>
    <p>c = [Bob, Cal]</p>
    <p>a = [Abe]</p>
    <p>Master</p>
    <p>Master</p>
    <p>b = []</p>
    <p>a = []</p>
    <p>b = [Bob]</p>
    <p>Master</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Slave</p>
    <p>Datacenter A Datacenter B</p>
    <p>Start T1 r(a) = []</p>
    <p>w(a = [Abe]) Commit T1</p>
    <p>Start T2 r(b) = [Bob] r(c) = [Cal] w(b = [])</p>
    <p>w(c = [Bob, Cal]) Commit T2</p>
    <p>Start T3 r(b) = [Bob]</p>
    <p>r(c) = [Bob,Cal] r(a) = []</p>
    <p>Delayed!</p>
    <p>Delayed!</p>
    <p>T3 Read Set</p>
    <p>Ordering Violation: Detected in the usual way. Red Shard is stale !</p>
    <p>b = [Bob] 1 0 1 0</p>
    <p>c = [Bob, Cal] 1 2 22</p>
  </div>
  <div class="page">
    <p>A. Observable Atomicity B. Observably Read from a causally consistent snapshot C. No concurrent conflicting writes</p>
    <p>Properties of Transactions</p>
    <p>Three Phase Protocol 2. Validation Phase</p>
    <p>a. Validate Read Set to verify A and B b. Validate Overwrite Set to verify C</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
  </div>
  <div class="page">
    <p>Evaluation Setup</p>
    <p>Occult implemented by modifying Redis Cluster (baseline)  Evaluated on CloudLab  Two datacenters in WI and SC  20 server machines (4 server processes per machine)  16K logical shards</p>
    <p>YCSB used as the benchmark  For graphs shown here read-heavy (95% reads) workload with zipfian distribution</p>
    <p>We show cost of providing consistency guarantees</p>
  </div>
  <div class="page">
    <p>Goodput Comparison</p>
    <p>G oo</p>
    <p>dp ut (m</p>
    <p>ill io n op</p>
    <p>s/ s)</p>
    <p>Num Ops per Transaction (Tsize)</p>
    <p>Occult Transactions Occult Single-Key Redis Cluster</p>
  </div>
  <div class="page">
    <p>Effect of slow nodes on Occult Latency</p>
    <p>Lo g 1</p>
    <p>at en</p>
    <p>cy u</p>
    <p>s)</p>
    <p>Percentiles</p>
    <p>s</p>
    <p>s</p>
    <p>s</p>
    <p>s47.1ms</p>
    <p>s</p>
  </div>
  <div class="page">
    <p>Conclusions  Enforcing causal consistency in the data store is vulnerable to slowdown cascades</p>
    <p>Sufficient to ensure that clients observe causal consistency:  Use lossy timestamps to provide the guarantee  Avoid slowdown cascades</p>
    <p>Observable enforcement can be extended to causally consistent transactions  Make writes causally dependent on each other to observe atomicity  Also avoids slowdown cascades</p>
  </div>
</Presentation>
