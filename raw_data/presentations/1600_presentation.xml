<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Clay Codes: Moulding MDS Codes to Yield an MSR Code</p>
    <p>Myna Vajha, Vinayak Ramkumar, Bhagyashree Puranik, Ganesh Kini, Elita Lobo, Birenjith Sasidharan Indian Institute of Science (IISc)</p>
    <p>P. Vijay Kumar (IISc and USC)</p>
    <p>Alexander Barg, Min Ye (UMD)</p>
    <p>Srinivasan Narayanamurthy, Syed Hussain, Siddhartha Nandi (NetApp)</p>
  </div>
  <div class="page">
    <p>Erasure Coding for Fault Tolerance</p>
    <p>Fault tolerance is key to making data loss a very remote possibility</p>
    <p>Fault tolerance is achieved using erasure coding</p>
    <p>File or Object</p>
    <p>Split it into chunks</p>
    <p>Ak</p>
    <p>Store the n chunks in different nodes of the storage network</p>
    <p>A2A1</p>
    <p>(n,k) erasure code n=k+m</p>
    <p>P1 P2 Pm</p>
    <p>k data chunks m parity chunks</p>
    <p>The n chunks taken together, form a stripe.</p>
    <p>Two Key Performance Measures</p>
    <p>MDS Codes</p>
  </div>
  <div class="page">
    <p>Erasure Coding for Fault Tolerance</p>
    <p>Fault tolerance is key to making data loss a very remote possibility</p>
    <p>Fault tolerance is achieved using erasure coding</p>
    <p>File or Object</p>
    <p>Split it into chunks</p>
    <p>Ak</p>
    <p>Store the n chunks in different nodes of the storage network</p>
    <p>A2A1</p>
    <p>(n,k) erasure code n=k+m</p>
    <p>P1 P2 Pm</p>
    <p>k data chunks m parity chunks</p>
    <p>The n chunks taken together, form a stripe.</p>
    <p>Two Key Performance Measures</p>
    <p>MDS Codes</p>
  </div>
  <div class="page">
    <p>Erasure Coding for Fault Tolerance</p>
    <p>Fault tolerance is key to making data loss a very remote possibility</p>
    <p>Fault tolerance is achieved using erasure coding</p>
    <p>File or Object</p>
    <p>Split it into chunks</p>
    <p>Ak</p>
    <p>Store the n chunks in different nodes of the storage network</p>
    <p>A2A1</p>
    <p>(n,k) erasure code n=k+m</p>
    <p>P1 P2 Pm</p>
    <p>k data chunks m parity chunks</p>
    <p>The n chunks taken together, form a stripe.</p>
    <p>Two Key Performance Measures</p>
    <p>MDS Codes</p>
  </div>
  <div class="page">
    <p>Erasure Coding for Fault Tolerance</p>
    <p>Fault tolerance is key to making data loss a very remote possibility</p>
    <p>Fault tolerance is achieved using erasure coding</p>
    <p>File or Object</p>
    <p>Split it into chunks</p>
    <p>Ak</p>
    <p>Store the n chunks in different nodes of the storage network</p>
    <p>A2A1</p>
    <p>(n,k) erasure code n=k+m</p>
    <p>P1 P2 Pm</p>
    <p>k data chunks m parity chunks</p>
    <p>The n chunks taken together, form a stripe.</p>
    <p>Two Key Performance Measures</p>
    <p>MDS Codes</p>
  </div>
  <div class="page">
    <p>Erasure Codes and Node Failures</p>
    <p>A median of 50 nodes are unavailable per day.</p>
    <p>A median of 180TB of network traffic per day is generated in order to reconstruct the RS coded data corresponding to unavailable machines.</p>
    <p>Thus there is a strong need for erasure codes that can efficiently recover from single-node failures.</p>
    <p>Image courtesy: Rashmi et al.: A Solution to the Network Challenges of Data Recovery in Erasure-coded Distributed Storage Systems: A Study on the Facebook</p>
    <p>Warehouse Cluster, USENIX Hotstorage, 2013.</p>
  </div>
  <div class="page">
    <p>Erasure Codes and Node Failures</p>
    <p>A median of 50 nodes are unavailable per day.</p>
    <p>A median of 180TB of network traffic per day is generated in order to reconstruct the RS coded data corresponding to unavailable machines.</p>
    <p>Thus there is a strong need for erasure codes that can efficiently recover from single-node failures.</p>
    <p>Image courtesy: Rashmi et al.: A Solution to the Network Challenges of Data Recovery in Erasure-coded Distributed Storage Systems: A Study on the Facebook</p>
    <p>Warehouse Cluster, USENIX Hotstorage, 2013. 3 / 28</p>
  </div>
  <div class="page">
    <p>Conventional Node Repair of an RS Code</p>
    <p>The conventional repair of an RS code is inefficient</p>
    <p>Data Chunk Parity Chunk Erased Chunk</p>
    <p>In the example (14, 10) RS code,</p>
    <p>clearly, there is room for improvement...</p>
  </div>
  <div class="page">
    <p>Conventional Node Repair of an RS Code</p>
    <p>The conventional repair of an RS code is inefficient</p>
    <p>Data Chunk Parity Chunk Erased Chunk</p>
    <p>In the example (14, 10) RS code,</p>
    <p>clearly, there is room for improvement...</p>
  </div>
  <div class="page">
    <p>Conventional Node Repair of an RS Code</p>
    <p>The conventional repair of an RS code is inefficient</p>
    <p>Data Chunk Parity Chunk Erased Chunk</p>
    <p>In the example (14, 10) RS code,</p>
    <p>clearly, there is room for improvement...</p>
  </div>
  <div class="page">
    <p>Conventional Node Repair of an RS Code</p>
    <p>The conventional repair of an RS code is inefficient</p>
    <p>Data Chunk Parity Chunk Erased Chunk</p>
    <p>In the example (14, 10) RS code,</p>
    <p>clearly, there is room for improvement...</p>
  </div>
  <div class="page">
    <p>Regenerating Codes 1 We will deal here only in the subclass of regenerating codes known as Minimum Storage Regeneration</p>
    <p>(MSR) codes</p>
    <p>Data Chunk Parity Chunk Erased Chunk</p>
  </div>
  <div class="page">
    <p>Regenerating Codes 1 We will deal here only in the subclass of regenerating codes known as Minimum Storage Regeneration</p>
    <p>(MSR) codes</p>
    <p>Data Chunk Parity Chunk Erased Chunk</p>
  </div>
  <div class="page">
    <p>Key to the Impressive, Low-Repair BW of MSR Codes</p>
    <p>In a nutshell: sub-packetization... we explain...</p>
  </div>
  <div class="page">
    <p>Key to the Impressive, Low-Repair BW of MSR Codes</p>
    <p>In a nutshell: sub-packetization... we explain...</p>
  </div>
  <div class="page">
    <p>n = k+m</p>
    <p>Chunk</p>
    <p>k data chunks m parity chunks</p>
  </div>
  <div class="page">
    <p>n = k+m</p>
    <p>Chunk</p>
    <p>k data chunks m parity chunks</p>
    <p>k</p>
  </div>
  <div class="page">
    <p>n = k+m</p>
    <p>Chunk</p>
    <p>k data chunks m parity chunks</p>
    <p>k</p>
    <p>sub-chunk</p>
    <p>sub-packetization level</p>
  </div>
  <div class="page">
    <p>n = k+m</p>
    <p>Chunk</p>
    <p>k data chunks m parity chunks</p>
    <p>k</p>
    <p>sub-chunk</p>
    <p>sub-packetization level &lt;</p>
    <p>d k&lt;d&lt;n</p>
  </div>
  <div class="page">
    <p>n = k+m</p>
    <p>Chunk</p>
    <p>k data chunks m parity chunks</p>
    <p>k</p>
    <p>sub-chunk</p>
    <p>sub-packetization level &lt;</p>
    <p>d k&lt;d&lt;n</p>
    <p>k (1GB)</p>
    <p>d &lt;&lt; k</p>
    <p>(325MB)</p>
  </div>
  <div class="page">
    <p>n = k+m</p>
    <p>Chunk</p>
    <p>k data chunks m parity chunks</p>
    <p>k</p>
    <p>sub-chunk</p>
    <p>sub-packetization level &lt;</p>
    <p>d k&lt;d&lt;n</p>
    <p>k (1GB)</p>
    <p>d &lt;&lt; k</p>
    <p>(325MB)</p>
    <p>= /(d-k+1) is a fraction of</p>
    <p>Repair BW = d We consider d=n-1, then Repair BW = (n-1)/(n-k)</p>
  </div>
  <div class="page">
    <p>n = k+m</p>
    <p>Chunk</p>
    <p>k data chunks m parity chunks</p>
    <p>k</p>
    <p>sub-chunk</p>
    <p>sub-packetization level &lt;</p>
    <p>d k&lt;d&lt;n</p>
    <p>k (1GB)</p>
    <p>d &lt;&lt; k</p>
    <p>(325MB)</p>
    <p>Larger the m=n-k, larger the savings!!</p>
    <p>= /(d-k+1) is a fraction of</p>
    <p>Repair BW = d We consider d=n-1, then Repair BW = (n-1)/(n-k)</p>
  </div>
  <div class="page">
    <p>Additional Properties Desired of an MSR Code</p>
    <p>I sub-chunk size = chunk size</p>
    <p>= N bytes. I During repair,  sub-chunks are read. I If sub-chunks are not contiguous, only N bytes are read sequentially. I Smaller the  better the sequentiality!!</p>
  </div>
  <div class="page">
    <p>Additional Properties Desired of an MSR Code</p>
    <p>I sub-chunk size = chunk size</p>
    <p>= N bytes. I During repair,  sub-chunks are read. I If sub-chunks are not contiguous, only N bytes are read sequentially. I Smaller the  better the sequentiality!!</p>
  </div>
  <div class="page">
    <p>Additional Properties Desired of an MSR Code</p>
    <p>I sub-chunk size = chunk size</p>
    <p>= N bytes. I During repair,  sub-chunks are read.</p>
    <p>I If sub-chunks are not contiguous, only N bytes are read sequentially. I Smaller the  better the sequentiality!!</p>
  </div>
  <div class="page">
    <p>Additional Properties Desired of an MSR Code</p>
    <p>I sub-chunk size = chunk size</p>
    <p>= N bytes. I During repair,  sub-chunks are read. I If sub-chunks are not contiguous, only N bytes are read sequentially. I Smaller the  better the sequentiality!!</p>
  </div>
  <div class="page">
    <p>Additional Properties Desired of an MSR Code</p>
    <p>I sub-chunk size = chunk size</p>
    <p>= N bytes. I During repair,  sub-chunks are read. I If sub-chunks are not contiguous, only N bytes are read sequentially. I Smaller the  better the sequentiality!!</p>
  </div>
  <div class="page">
    <p>Least possible storage overhead (MDS Codes)</p>
    <p>Least possible repair bandwidth (MSR Codes)</p>
    <p>Least possible disk read (Optimal access MSR Codes)</p>
    <p>Least possible sub-packetization (Clay Codes)</p>
    <p>among the class of MSR codes, the Clay code is arguably a champion...</p>
    <p>Image courtesy: denverpost.com</p>
  </div>
  <div class="page">
    <p>Least possible storage overhead (MDS Codes)</p>
    <p>Least possible repair bandwidth (MSR Codes)</p>
    <p>Least possible disk read (Optimal access MSR Codes)</p>
    <p>Least possible sub-packetization (Clay Codes)</p>
    <p>among the class of MSR codes, the Clay code is arguably a champion...</p>
    <p>Image courtesy: denverpost.com</p>
  </div>
  <div class="page">
    <p>Placing the Clay Code in Perspective</p>
    <p>Comparing the Clay code with repair-efficient codes that have undergone systems implementation</p>
    <p>Code MDS Least</p>
    <p>Repair BW</p>
    <p>Least Disk Read</p>
    <p>Least  Restrictions</p>
    <p>Implemented Distributed</p>
    <p>Systems</p>
    <p>Piggybacked RS (Sigcomm 2014)</p>
    <p>- None HDFS</p>
    <p>Product Matrix (FAST 2015)</p>
    <p>Limited to Storage</p>
    <p>Overhead &gt; 2</p>
    <p>Own System</p>
    <p>Butterfly Code (FAST 2016)</p>
    <p>Limited to the 2 parity nodes</p>
    <p>HDFS, Ceph</p>
    <p>HashTag Code (Trans. on Big Data</p>
    <p>- Only systematic node</p>
    <p>repair</p>
    <p>HDFS</p>
    <p>Clay (FAST 2018)</p>
    <p>None! Ceph</p>
    <p>The Butterfly, HashTag codes have least disk read for systematic node repair.</p>
    <p>#HT: A similar table given in the paper and the poster had erroneous information on HT codes. 9 / 28</p>
  </div>
  <div class="page">
    <p>Clay Code Construction</p>
  </div>
  <div class="page">
    <p>Moulding an MDS Code to Yield a (4, 2) Clay Code</p>
    <p>(0,0) (0,1) (1,0) (1,1)</p>
    <p>Parity Data</p>
    <p>Two sub-chunks are encoded using (4, 2) scalar MDS code.</p>
    <p>z=0</p>
    <p>x y</p>
    <p>z=1</p>
    <p>z=2</p>
    <p>z=3</p>
    <p>Layer four such units.</p>
    <p>z= (0,0)</p>
    <p>z= (1,1)</p>
    <p>z= (1,0)</p>
    <p>z= (0,1)</p>
    <p>Index each layer z using two bits (corresponding to the location of the two</p>
    <p>red dots in that layer).</p>
    <p>U* U</p>
    <p>sub-chunks such as (U, U) are paired (yellow rectangles connected by a dotted</p>
    <p>line).</p>
    <p>Pairwise Forward Transform (PFT)</p>
    <p>C C*</p>
    <p>U</p>
    <p>U*= A</p>
    <p>Any two sub-chunks out of {U, U, C, C} can be computed</p>
    <p>from remaining two.</p>
    <p>C C*</p>
    <p>Perform PFT on paired sub-chunks and copy the unpaired sub-chunks to get the</p>
    <p>Clay code.</p>
    <p>Can be generalized to any (n, k, d)!!</p>
  </div>
  <div class="page">
    <p>Moulding an MDS Code to Yield a (4, 2) Clay Code</p>
    <p>(0,0) (0,1) (1,0) (1,1)</p>
    <p>Parity Data</p>
    <p>Two sub-chunks are encoded using (4, 2) scalar MDS code.</p>
    <p>z=0</p>
    <p>x y</p>
    <p>z=1</p>
    <p>z=2</p>
    <p>z=3</p>
    <p>Layer four such units.</p>
    <p>z= (0,0)</p>
    <p>z= (1,1)</p>
    <p>z= (1,0)</p>
    <p>z= (0,1)</p>
    <p>Index each layer z using two bits (corresponding to the location of the two</p>
    <p>red dots in that layer).</p>
    <p>U* U</p>
    <p>sub-chunks such as (U, U) are paired (yellow rectangles connected by a dotted</p>
    <p>line).</p>
    <p>Pairwise Forward Transform (PFT)</p>
    <p>C C*</p>
    <p>U</p>
    <p>U*= A</p>
    <p>Any two sub-chunks out of {U, U, C, C} can be computed</p>
    <p>from remaining two.</p>
    <p>C C*</p>
    <p>Perform PFT on paired sub-chunks and copy the unpaired sub-chunks to get the</p>
    <p>Clay code.</p>
    <p>Can be generalized to any (n, k, d)!!</p>
  </div>
  <div class="page">
    <p>Moulding an MDS Code to Yield a (4, 2) Clay Code</p>
    <p>(0,0) (0,1) (1,0) (1,1)</p>
    <p>Parity Data</p>
    <p>Two sub-chunks are encoded using (4, 2) scalar MDS code.</p>
    <p>z=0</p>
    <p>x y</p>
    <p>z=1</p>
    <p>z=2</p>
    <p>z=3</p>
    <p>Layer four such units.</p>
    <p>z= (0,0)</p>
    <p>z= (1,1)</p>
    <p>z= (1,0)</p>
    <p>z= (0,1)</p>
    <p>Index each layer z using two bits (corresponding to the location of the two</p>
    <p>red dots in that layer).</p>
    <p>U* U</p>
    <p>sub-chunks such as (U, U) are paired (yellow rectangles connected by a dotted</p>
    <p>line).</p>
    <p>Pairwise Forward Transform (PFT)</p>
    <p>C C*</p>
    <p>U</p>
    <p>U*= A</p>
    <p>Any two sub-chunks out of {U, U, C, C} can be computed</p>
    <p>from remaining two.</p>
    <p>C C*</p>
    <p>Perform PFT on paired sub-chunks and copy the unpaired sub-chunks to get the</p>
    <p>Clay code.</p>
    <p>Can be generalized to any (n, k, d)!!</p>
  </div>
  <div class="page">
    <p>Moulding an MDS Code to Yield a (4, 2) Clay Code</p>
    <p>(0,0) (0,1) (1,0) (1,1)</p>
    <p>Parity Data</p>
    <p>Two sub-chunks are encoded using (4, 2) scalar MDS code.</p>
    <p>z=0</p>
    <p>x y</p>
    <p>z=1</p>
    <p>z=2</p>
    <p>z=3</p>
    <p>Layer four such units.</p>
    <p>z= (0,0)</p>
    <p>z= (1,1)</p>
    <p>z= (1,0)</p>
    <p>z= (0,1)</p>
    <p>Index each layer z using two bits (corresponding to the location of the two</p>
    <p>red dots in that layer).</p>
    <p>U* U</p>
    <p>sub-chunks such as (U, U) are paired (yellow rectangles connected by a dotted</p>
    <p>line).</p>
    <p>Pairwise Forward Transform (PFT)</p>
    <p>C C*</p>
    <p>U</p>
    <p>U*= A</p>
    <p>Any two sub-chunks out of {U, U, C, C} can be computed</p>
    <p>from remaining two.</p>
    <p>C C*</p>
    <p>Perform PFT on paired sub-chunks and copy the unpaired sub-chunks to get the</p>
    <p>Clay code.</p>
    <p>Can be generalized to any (n, k, d)!!</p>
  </div>
  <div class="page">
    <p>Moulding an MDS Code to Yield a (4, 2) Clay Code</p>
    <p>(0,0) (0,1) (1,0) (1,1)</p>
    <p>Parity Data</p>
    <p>Two sub-chunks are encoded using (4, 2) scalar MDS code.</p>
    <p>z=0</p>
    <p>x y</p>
    <p>z=1</p>
    <p>z=2</p>
    <p>z=3</p>
    <p>Layer four such units.</p>
    <p>z= (0,0)</p>
    <p>z= (1,1)</p>
    <p>z= (1,0)</p>
    <p>z= (0,1)</p>
    <p>Index each layer z using two bits (corresponding to the location of the two</p>
    <p>red dots in that layer).</p>
    <p>U* U</p>
    <p>sub-chunks such as (U, U) are paired (yellow rectangles connected by a dotted</p>
    <p>line).</p>
    <p>Pairwise Forward Transform (PFT)</p>
    <p>C C*</p>
    <p>U</p>
    <p>U*= A</p>
    <p>Any two sub-chunks out of {U, U, C, C} can be computed</p>
    <p>from remaining two.</p>
    <p>C C*</p>
    <p>Perform PFT on paired sub-chunks and copy the unpaired sub-chunks to get the</p>
    <p>Clay code.</p>
    <p>Can be generalized to any (n, k, d)!!</p>
  </div>
  <div class="page">
    <p>Moulding an MDS Code to Yield a (4, 2) Clay Code</p>
    <p>(0,0) (0,1) (1,0) (1,1)</p>
    <p>Parity Data</p>
    <p>Two sub-chunks are encoded using (4, 2) scalar MDS code.</p>
    <p>z=0</p>
    <p>x y</p>
    <p>z=1</p>
    <p>z=2</p>
    <p>z=3</p>
    <p>Layer four such units.</p>
    <p>z= (0,0)</p>
    <p>z= (1,1)</p>
    <p>z= (1,0)</p>
    <p>z= (0,1)</p>
    <p>Index each layer z using two bits (corresponding to the location of the two</p>
    <p>red dots in that layer).</p>
    <p>U* U</p>
    <p>sub-chunks such as (U, U) are paired (yellow rectangles connected by a dotted</p>
    <p>line).</p>
    <p>Pairwise Forward Transform (PFT)</p>
    <p>C C*</p>
    <p>U</p>
    <p>U*= A</p>
    <p>Any two sub-chunks out of {U, U, C, C} can be computed</p>
    <p>from remaining two.</p>
    <p>C C*</p>
    <p>Perform PFT on paired sub-chunks and copy the unpaired sub-chunks to get the</p>
    <p>Clay code.</p>
    <p>Can be generalized to any (n, k, d)!!</p>
  </div>
  <div class="page">
    <p>Moulding an MDS Code to Yield a (4, 2) Clay Code</p>
    <p>(0,0) (0,1) (1,0) (1,1)</p>
    <p>Parity Data</p>
    <p>Two sub-chunks are encoded using (4, 2) scalar MDS code.</p>
    <p>z=0</p>
    <p>x y</p>
    <p>z=1</p>
    <p>z=2</p>
    <p>z=3</p>
    <p>Layer four such units.</p>
    <p>z= (0,0)</p>
    <p>z= (1,1)</p>
    <p>z= (1,0)</p>
    <p>z= (0,1)</p>
    <p>Index each layer z using two bits (corresponding to the location of the two</p>
    <p>red dots in that layer).</p>
    <p>U* U</p>
    <p>sub-chunks such as (U, U) are paired (yellow rectangles connected by a dotted</p>
    <p>line).</p>
    <p>Pairwise Forward Transform (PFT)</p>
    <p>C C*</p>
    <p>U</p>
    <p>U*= A</p>
    <p>Any two sub-chunks out of {U, U, C, C} can be computed</p>
    <p>from remaining two.</p>
    <p>C C*</p>
    <p>Perform PFT on paired sub-chunks and copy the unpaired sub-chunks to get the</p>
    <p>Clay code.</p>
    <p>Can be generalized to any (n, k, d)!! 11 / 28</p>
  </div>
  <div class="page">
    <p>Encoding the Clay Code</p>
    <p>The previous slide did not explain how encoding takes place as the code was not in systematic form.</p>
    <p>We will now explain encoding data under the Clay Code.</p>
  </div>
  <div class="page">
    <p>Consider a file of size 64MB</p>
    <p>We show encoding of the file using (n = 4, k = 2) Clay code.</p>
  </div>
  <div class="page">
    <p>Break the file into k = 2 data chunks each of 32MB. 32MB 32MB</p>
  </div>
  <div class="page">
    <p>z = (0,0)</p>
    <p>z = (1,1)</p>
    <p>z</p>
    <p>y x The cube has:</p>
    <p>4 columns, which correspond to the 4 chunks (each of size 32MB, stored in a different disk/node).</p>
    <p>4 horizontal planes.</p>
    <p>Each column has 4 points that correspond to sub-chunks of size 8MB</p>
  </div>
  <div class="page">
    <p>Place two 32MB chunks in two data nodes 32MB</p>
    <p>z = (0,0)</p>
    <p>z</p>
    <p>y x</p>
    <p>z = (1,1)</p>
  </div>
  <div class="page">
    <p>Place two 32MB chunks in two data nodes</p>
    <p>z = (0,0)</p>
    <p>z = (1,1)</p>
    <p>z</p>
    <p>yx</p>
  </div>
  <div class="page">
    <p>We now have the data nodes</p>
  </div>
  <div class="page">
    <p>We will now compute the parity nodes</p>
  </div>
  <div class="page">
    <p>Will get there through an intermediate Uncoupled data cube</p>
  </div>
  <div class="page">
    <p>Start filling the Uncoupled data cube on the right as follows</p>
  </div>
  <div class="page">
    <p>C C*</p>
    <p>Certain pairs of points in the cube are coupled</p>
  </div>
  <div class="page">
    <p>C C*</p>
    <p>U U*</p>
    <p>PRT</p>
    <p>C C*</p>
    <p>PRT is a 2x2 matrix transform, It is reverse of PFT</p>
  </div>
  <div class="page">
    <p>C C* U U*</p>
    <p>Place the sub-chunks obtained in the uncoupled data cube</p>
  </div>
  <div class="page">
    <p>C C*</p>
    <p>U U*</p>
    <p>Place the sub-chunks obtained in the uncoupled data cube</p>
  </div>
  <div class="page">
    <p>C C*</p>
    <p>Place the sub-chunks obtained in the uncoupled data cube</p>
  </div>
  <div class="page">
    <p>C C*</p>
    <p>U U*</p>
    <p>PRT</p>
    <p>C C*</p>
    <p>Place the sub-chunks obtained in the uncoupled data cube</p>
  </div>
  <div class="page">
    <p>C C*</p>
    <p>U U*</p>
    <p>Place the sub-chunks obtained in the uncoupled data cube</p>
  </div>
  <div class="page">
    <p>C C*</p>
    <p>U U*</p>
    <p>Place the sub-chunks obtained in the uncoupled data cube</p>
  </div>
  <div class="page">
    <p>Place the sub-chunks obtained in the uncoupled data cube</p>
  </div>
  <div class="page">
    <p>Copy</p>
    <p>Red dotted sub-chunks are not paired, they are simply carried over</p>
  </div>
  <div class="page">
    <p>Red dotted sub-chunks are not paired, they are simply carried over</p>
    <p>Copy</p>
  </div>
  <div class="page">
    <p>We now have data-part of the uncoupled data cube</p>
  </div>
  <div class="page">
    <p>z = (0,0)</p>
    <p>Each plane is Reed-Solomon encoded to obtain parity points (sub-chunks)</p>
  </div>
  <div class="page">
    <p>z = (0,0)</p>
    <p>RS Encode</p>
    <p>(4,2)</p>
    <p>Each plane is Reed-Solomon encoded to obtain parity points (sub-chunks)</p>
  </div>
  <div class="page">
    <p>z = (0,0)</p>
    <p>RS Encode</p>
    <p>(4,2)</p>
    <p>Each plane is Reed-Solomon encoded to obtain parity points (sub-chunks)</p>
  </div>
  <div class="page">
    <p>z = (0,0)</p>
    <p>Each plane is Reed-Solomon encoded to obtain parity points (sub-chunks)</p>
  </div>
  <div class="page">
    <p>z = (1,0)</p>
    <p>RS Encode</p>
    <p>(4,2)</p>
    <p>Each plane is Reed-Solomon encoded to obtain parity points (sub-chunks)</p>
  </div>
  <div class="page">
    <p>z = (0,1)</p>
    <p>RS Encode</p>
    <p>(4,2)</p>
    <p>Each plane is Reed-Solomon encoded to obtain parity points (sub-chunks)</p>
  </div>
  <div class="page">
    <p>z = (1,1)</p>
    <p>RS Encode</p>
    <p>(4,2)</p>
    <p>Each plane is Reed-Solomon encoded to obtain parity points (sub-chunks)</p>
  </div>
  <div class="page">
    <p>Now we have the complete Uncoupled data cube</p>
  </div>
  <div class="page">
    <p>Parity sub-chunks of Coupled data cube can now be computed</p>
  </div>
  <div class="page">
    <p>U</p>
    <p>U*</p>
    <p>Perform PFT</p>
  </div>
  <div class="page">
    <p>C C*</p>
    <p>PFT</p>
    <p>U U* U</p>
    <p>U*</p>
    <p>Perform PFT</p>
  </div>
  <div class="page">
    <p>C C*</p>
    <p>Perform PFT</p>
  </div>
  <div class="page">
    <p>Perform PFT</p>
  </div>
  <div class="page">
    <p>C C*</p>
    <p>PFT</p>
    <p>U U*</p>
    <p>U</p>
    <p>U*</p>
    <p>Perform PFT</p>
  </div>
  <div class="page">
    <p>C C*</p>
    <p>Perform PFT</p>
  </div>
  <div class="page">
    <p>Perform PFT</p>
  </div>
  <div class="page">
    <p>Copy</p>
    <p>Red dotted sub-chunks are simply carried over</p>
  </div>
  <div class="page">
    <p>Red dotted sub-chunks are simply carried over</p>
    <p>Copy</p>
  </div>
  <div class="page">
    <p>The encoding is now complete!</p>
  </div>
  <div class="page">
    <p>Recovery from single node failure</p>
  </div>
  <div class="page">
    <p>Node Repair: One node fails</p>
  </div>
  <div class="page">
    <p>Only half of planes participate in repair</p>
    <p>Total Helper Data = 8MB X 3 X 2 = 48MB</p>
    <p>As opposed to RS code = 8MB X 2 X 4 = 64MB</p>
    <p>Much larger savings seen for m &gt; 2</p>
  </div>
  <div class="page">
    <p>Perform PRT to get possible uncoupled sub-chunks</p>
    <p>PRT</p>
  </div>
  <div class="page">
    <p>Run RS decoding on each of the selected planes</p>
    <p>PRT</p>
    <p>RS Decode</p>
  </div>
  <div class="page">
    <p>Run RS decoding on each of the selected planes</p>
    <p>PRT</p>
    <p>RS Decode</p>
  </div>
  <div class="page">
    <p>Run RS decoding on each of the selected planes</p>
    <p>PRT</p>
    <p>RS Decode</p>
  </div>
  <div class="page">
    <p>PRT</p>
    <p>Run RS decoding on each of the selected planes</p>
    <p>RS Decode</p>
  </div>
  <div class="page">
    <p>We now have the following sub-chunks available</p>
  </div>
  <div class="page">
    <p>Half the number of required sub-chunks are now already computed</p>
    <p>Copy</p>
  </div>
  <div class="page">
    <p>Compute C* from C and U</p>
    <p>C,UC*</p>
  </div>
  <div class="page">
    <p>Compute C* from C and U</p>
    <p>C,UC*</p>
  </div>
  <div class="page">
    <p>Compute C* from C and U</p>
    <p>C,UC*</p>
  </div>
  <div class="page">
    <p>Compute C* from C and U</p>
    <p>C,UC*</p>
  </div>
  <div class="page">
    <p>Replacement node</p>
    <p>Content of failed node is now completely recovered</p>
  </div>
  <div class="page">
    <p>MDS Property of Clay Code</p>
    <p>Any n k node failures can be recovered from.</p>
    <p>The decoding algorithm recovers the lost symbols layer by layer sequentially.</p>
    <p>It uses functions scalar MDS decode, PFT, PRT and the function that computes U from {U,C}.</p>
    <p>Decoding algorithm involves  scalar MDS decode operations along with 2n Galois field scalar multiplications and n Galois XOR operations.</p>
    <p>RS decode for the same amount of data involve  scalar MDS decode operations.</p>
  </div>
  <div class="page">
    <p>Implementation and Evaluation of Clay Code</p>
  </div>
  <div class="page">
    <p>Ceph: Architecture Object Storage Daemon (OSD): process of Ceph, associated with a storage unit.</p>
    <p>Pool: Logical partitions, associated with an erasure-code profile.</p>
    <p>Placement Group(PG): Collection of n OSDs.</p>
    <p>Each pool can have a single or multiple PGs associated with it.</p>
    <p>PG1</p>
    <p>OSD7 OSD1OSD4</p>
    <p>OSD5OSD2</p>
    <p>POOL</p>
    <p>OSD3</p>
    <p>p-OSD</p>
    <p>PG2</p>
    <p>OSD4 OSD3OSD5</p>
    <p>OSD1OSD7 OSD6</p>
    <p>p-OSD</p>
    <p>Erasure Code Profile</p>
    <p>OBJECT</p>
    <p>OBJECT OBJECT</p>
  </div>
  <div class="page">
    <p>Ceph: Contributions</p>
    <p>We introduced the notion of sub-chunking to enable use of vector erasure codes with Ceph.</p>
    <p>It is now part of Cephs master codebase :)</p>
    <p>Clay code will soon be available as an erasure code plugin 1 in Ceph for all parameters (n, k, d)</p>
  </div>
  <div class="page">
    <p>Evaluation of the Clay Code</p>
    <p>Evaluated on a 26 node (m4.xlarge) AWS cluster.</p>
    <p>One node hosts Monitor (MON) process of Ceph.</p>
    <p>Remaining 25 nodes host one OSD each.</p>
    <p>Each node has 500GB SSD type volume attached.</p>
    <p>Two workloads</p>
    <p>I Workload W1: fixed size 64MB objects  stripe size 64MB I Workload W2: mixture of 1MB, 32MB, and 64MB size objects,  stripe size 1MB</p>
    <p>Both single PG and multiple PG (512 PG) experiments.</p>
    <p>Codes evaluated: (6, 4, 5), (12, 9, 11) and (20, 16, 19).</p>
  </div>
  <div class="page">
    <p>Network Traffic and Disk Read : W1 Workload, 1 PG</p>
    <p>Network traffic reduced to 75%, 48%, 34% of that of RS as predicted by theory.</p>
    <p>Repair disk read reduced to 62%, 41%, 29% of that of RS as predicted by theory.</p>
  </div>
  <div class="page">
    <p>Network Traffic and Disk Read : W2 Workload, 1 PG</p>
    <p>Network traffic reduced to 75%, 48%, 34% of that of RS matching the theoretical values.</p>
    <p>Reductions same as that for W1.</p>
    <p>Disk read for (6, 4, 5) code is optimal</p>
    <p>For (12, 9, 11) and (20, 16, 19) codes effect of fragmented read is observed.</p>
  </div>
  <div class="page">
    <p>Fragmented Read</p>
    <p>Best and worst case, disk read during repair of (20,16,19) code for stripe sizes 1MB, 64MB</p>
    <p>During repair of a chunk only  &lt;  sub-chunks are read from each helper nodes.</p>
    <p>During worst case failures, the sub-chunks needed in repair are not located contiguously.</p>
    <p>sub-chunk size = stripe size/k</p>
    <p>For (20,16,19) code  = 1024, k = 16. Therefore, for stripe sizes 64MB and 1MB, the sub-chunk sizes are 4KB, 64B respectively.</p>
    <p>If sub-chunk size is aligned to 4kB (SSD page granularity), the fragmented-read problem can be avoided.</p>
  </div>
  <div class="page">
    <p>Repair Time and Encoding Time: W1 Workload, 1 PG</p>
    <p>Repair time reduced by 1.49x, 2.34x, 3x of that of RS.</p>
    <p>The total encoding time remains almost same as that of RS.</p>
    <p>While, encode computation time of Clay code is higher than that of RS code by 70%.</p>
    <p>This is due to the additional PFT and PRT operations.</p>
  </div>
  <div class="page">
    <p>Normal and Degraded I/O : W1 workload, 1 PG</p>
    <p>Better degraded read 16.24%, 9.9%, 27.17% and write throughput increased by 4.52%, 13.58%, 106.68% of that of RS.</p>
    <p>Normal read and write throughput same as that of RS.</p>
  </div>
  <div class="page">
    <p>Network Traffic and Disk Read : W1 workload, 512 PG</p>
    <p>Assignment of OSDs and objects to PGs is dynamic.</p>
    <p>I Number of objects affected by failure of an OSD can vary across different runs of multiple-PG</p>
    <p>experiment.</p>
    <p>Sometimes an OSD that is already part of the PG can get reassigned as replacement for the failed OSD.</p>
    <p>I Number of failures are treated as two resulting in inferior network-traffic performance in multiple-PG</p>
    <p>setting.</p>
  </div>
  <div class="page">
    <p>Multiple Node Failures</p>
    <p>Average theoretical network traffic during repair of 64MB object.</p>
    <p>Workload W1, 512 PG</p>
    <p>Network traffic increases with increase in number of failed chunks.</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>We provide an open-source implementation of Clay code for any (n, k, d) parameters.</p>
    <p>The theoretical promise of the Clay code is reflected in the evaluation presented here</p>
    <p>Specifically, for Workloads with large sized objects, the Clay code (20, 16, 19):</p>
    <p>I resulted in repair time reduction by 3x.</p>
    <p>I Improved degraded read and write performance by 27.17% and 106.68% respectively.</p>
    <p>In summary, Clay Codes are well</p>
    <p>poised to make the leap from theory to</p>
    <p>practice!!!</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>We provide an open-source implementation of Clay code for any (n, k, d) parameters.</p>
    <p>The theoretical promise of the Clay code is reflected in the evaluation presented here</p>
    <p>Specifically, for Workloads with large sized objects, the Clay code (20, 16, 19):</p>
    <p>I resulted in repair time reduction by 3x.</p>
    <p>I Improved degraded read and write performance by 27.17% and 106.68% respectively.</p>
    <p>In summary, Clay Codes are well</p>
    <p>poised to make the leap from theory to</p>
    <p>practice!!!</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>We provide an open-source implementation of Clay code for any (n, k, d) parameters.</p>
    <p>The theoretical promise of the Clay code is reflected in the evaluation presented here</p>
    <p>Specifically, for Workloads with large sized objects, the Clay code (20, 16, 19):</p>
    <p>I resulted in repair time reduction by 3x.</p>
    <p>I Improved degraded read and write performance by 27.17% and 106.68% respectively.</p>
    <p>In summary, Clay Codes are well</p>
    <p>poised to make the leap from theory to</p>
    <p>practice!!!</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>We provide an open-source implementation of Clay code for any (n, k, d) parameters.</p>
    <p>The theoretical promise of the Clay code is reflected in the evaluation presented here</p>
    <p>Specifically, for Workloads with large sized objects, the Clay code (20, 16, 19):</p>
    <p>I resulted in repair time reduction by 3x.</p>
    <p>I Improved degraded read and write performance by 27.17% and 106.68% respectively.</p>
    <p>In summary, Clay Codes are well</p>
    <p>poised to make the leap from theory to</p>
    <p>practice!!!</p>
  </div>
  <div class="page">
    <p>Thank You!</p>
  </div>
  <div class="page">
    <p>Backup Slides!</p>
  </div>
  <div class="page">
    <p>Decode: Two nodes fail</p>
  </div>
  <div class="page">
    <p>Assign Intersection Score to each plane</p>
    <p>z = (0,0) z = (1,0)</p>
    <p>z = (0,1) z = (1,1)</p>
    <p>Intersection score is given by the number of hole-dot pairs</p>
  </div>
  <div class="page">
    <p>Assign Intersection Score to each plane</p>
    <p>z = (0,0) z = (1,0)</p>
    <p>z = (0,1) z = (1,1)</p>
    <p>IS=1</p>
    <p>IS=0</p>
    <p>IS=2</p>
    <p>IS=1</p>
    <p>Intersection score is given by the number of hole-dot pairs</p>
  </div>
  <div class="page">
    <p>For non erased nodes, get the uncoupled sub-chunks for planes with IS=0</p>
    <p>IS=1</p>
    <p>IS=2</p>
    <p>IS=0</p>
    <p>IS=1</p>
  </div>
  <div class="page">
    <p>RS decode to get the remaining uncoupled-subchunks</p>
    <p>IS=1</p>
    <p>IS=2</p>
    <p>IS=0</p>
    <p>IS=1</p>
    <p>RS Decode</p>
  </div>
  <div class="page">
    <p>IS=1</p>
    <p>IS=2</p>
    <p>IS=0</p>
    <p>IS=1</p>
    <p>U2* U1*</p>
    <p>C1</p>
    <p>C2</p>
    <p>Known sub-chunks</p>
    <p>We now have following sub-chunks</p>
  </div>
  <div class="page">
    <p>IS=1</p>
    <p>IS=2</p>
    <p>IS=0</p>
    <p>IS=1</p>
    <p>U2* U1*</p>
    <p>C1</p>
    <p>C2 U2</p>
    <p>U1</p>
    <p>Known sub-chunks</p>
    <p>Get U2 from U2* and C2</p>
    <p>Get U1 from U1* and C1</p>
    <p>For non erased nodes, get the uncoupled sub-chunks for planes with IS=1</p>
  </div>
  <div class="page">
    <p>IS=1</p>
    <p>IS=2</p>
    <p>IS=0</p>
    <p>IS=1</p>
    <p>U2* U1*</p>
    <p>C1</p>
    <p>C2 U2</p>
    <p>U1</p>
    <p>RS decode to get the remaining uncoupled-subchunks</p>
    <p>RS Decode</p>
    <p>RS Decode</p>
    <p>Known sub-chunks</p>
  </div>
  <div class="page">
    <p>IS=1</p>
    <p>IS=2</p>
    <p>IS=0</p>
    <p>IS=1</p>
    <p>C1 C2</p>
    <p>U1*</p>
    <p>Known sub-chunks</p>
    <p>We now have the following sub-chunks</p>
    <p>U2*</p>
  </div>
  <div class="page">
    <p>IS=1</p>
    <p>IS=2</p>
    <p>IS=0</p>
    <p>IS=1</p>
    <p>C1 C2</p>
    <p>U1*</p>
    <p>Known sub-chunks</p>
    <p>U2*</p>
    <p>Get U2 from U2* and C2</p>
    <p>Get U1 from U1* and C1</p>
    <p>U2</p>
    <p>U1</p>
    <p>For non erased nodes, get the uncoupled sub-chunks for planes with IS=2</p>
  </div>
  <div class="page">
    <p>IS=1</p>
    <p>IS=2</p>
    <p>IS=0</p>
    <p>IS=1</p>
    <p>C1 C2</p>
    <p>U1*</p>
    <p>RS Decode</p>
    <p>Known sub-chunks</p>
    <p>Get the uncoupled sub-chunks for planes with IS=2</p>
    <p>U2*</p>
    <p>Get U2 from U2* and C2</p>
    <p>Get U1 from U1* and C1</p>
    <p>U2</p>
    <p>U1</p>
  </div>
  <div class="page">
    <p>We now have all the uncoupled sub chunks</p>
  </div>
  <div class="page">
    <p>The coupled sub chunks can now be computed using PFT</p>
    <p>PFT</p>
  </div>
  <div class="page">
    <p>The decoding is now complete</p>
  </div>
</Presentation>
