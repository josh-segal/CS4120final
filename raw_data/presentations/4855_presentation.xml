<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Implementing and Evaluating Nested Parallel Transactions in STM</p>
    <p>Woongki Baek, Nathan Bronson,</p>
    <p>Christos Kozyrakis, Kunle Olukotun</p>
    <p>Stanford University</p>
  </div>
  <div class="page">
    <p>Introduction</p>
    <p>Transactional Memory (TM) simplifies parallel programming</p>
    <p>Atomic and isolated execution of transactions</p>
    <p>Current practice: Most TMs do not support nested parallelism</p>
    <p>Nested parallelism in TM is becoming more important</p>
    <p>To fully utilize the increasing number of cores  To integrate well with programming models (e.g., OpenMP)</p>
    <p>// Parallelize the outer loop</p>
    <p>for(i=0;i&lt;numCustomer;i++){</p>
    <p>atomic{</p>
    <p>// Can we parallelize the inner loop?</p>
    <p>for(j=0;j&lt;numOrders;j++)</p>
    <p>processOrder(i,j,);</p>
    <p>}}</p>
  </div>
  <div class="page">
    <p>Previous Work: NP in STM</p>
    <p>[ECOOP 09] NePaLTM with practical support for nested parallelism</p>
    <p>Serialize nested transactions</p>
    <p>[PPoPP 08] CWSTM that supports nested parallel transactions</p>
    <p>With the lowest upper bound of time complexity of TM barriers</p>
    <p>No (actual) implementation / (quantitative) evaluation</p>
    <p>[PPoPP 10] a practical, concrete implementation of CWSTM</p>
    <p>With depth-independent time complexity of TM barriers</p>
    <p>Use rather complicated data structures such as concurrent stack</p>
    <p>Remaining question: Extend a timestamp-based, eager-versioning STM</p>
    <p>To support nested parallel transactions</p>
  </div>
  <div class="page">
    <p>Contributions</p>
    <p>Propose NesTM with support for nested parallel transactions</p>
    <p>Extend a timestamp-based, eager-versioning STM</p>
    <p>Discuss complications of concurrent nesting</p>
    <p>Describe subtle correctness issues</p>
    <p>Motivate further research on proving / verifying nested STMs</p>
    <p>Quantify NesTM across different use scenarios</p>
    <p>Admittedly, substantial runtime overheads to nested transactions E.g., Repeated read-set validation</p>
    <p>Motivate further research on performance optimizations</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Introduction</p>
    <p>Background</p>
    <p>NesTM Algorithm</p>
    <p>Complications of Nesting</p>
    <p>Evaluation</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Background: Semantics of Nesting</p>
    <p>Definitions</p>
    <p>Transactional hierarchy has a tree structure Ancestors(T) = Parent(T) Ancestors(Parent(T))</p>
    <p>Readers(o): a set of active transactions that read o</p>
    <p>Writers(o): a set of active transactions that wrote to o</p>
    <p>Conflicts</p>
    <p>T reads from o: R/W conflict If there exists T such that T writers(o), T T, and T ancestors(T)</p>
    <p>T writes to o: R/W or W/W conflict If there exists T such that T readers(o) writers(o), T T, and</p>
    <p>T ancestors(T)</p>
  </div>
  <div class="page">
    <p>Background: Example of Nesting</p>
    <p>T1 and T2 are top-level</p>
    <p>T1.1, T1.2: T1s children</p>
    <p>T=6: R/W conflict</p>
    <p>T2 writes to A</p>
    <p>T1.1 Readers(A)</p>
    <p>T1.1 Ances(T2)</p>
    <p>T=8: No conflict</p>
    <p>T1.2 writes to A</p>
    <p>Readers(A)=Writers(A)=</p>
    <p>Serialization order</p>
    <p>T2 T1</p>
    <p>st A</p>
    <p>T1 T2</p>
    <p>T1.2 T1.1</p>
    <p>st A</p>
    <p>ld B</p>
    <p>ld A</p>
    <p>ld A</p>
    <p>T1.1</p>
  </div>
  <div class="page">
    <p>NesTM Overview</p>
    <p>Extend an eager data-versioning STM</p>
    <p>In-place update No need to look up parents write buffer  Useful property: Once acquire ownership, keep it until commit / abort</p>
    <p>Global data structures</p>
    <p>A global version clock (GC)</p>
    <p>A set of version-owner locks (voLocks): T LSBs: Owners TID / Remaining bits: Version Number</p>
    <p>Transaction descriptor</p>
    <p>Read-version (RV): GC value sampled when the txn starts  R/W sets: Implemented using a doubly linked list  Pointer to parents transaction descriptor</p>
    <p>Commit-lock: to synchronize concurrent commits of children</p>
  </div>
  <div class="page">
    <p>TxLoad</p>
    <p>If the owner (of the memory object) is the transaction itself</p>
    <p>Read the memory value</p>
    <p>Else if the owner is an ancestor of the transaction</p>
    <p>If the version number is newer than the transactions RV Abort</p>
    <p>Else Read the memory value</p>
    <p>Else Abort</p>
    <p>TxLoad(Self,addr){</p>
    <p>vl=getVoLock(addr);</p>
    <p>owner=getOwner(vl);</p>
    <p>if(owner==Self){ // Read data }</p>
    <p>} else if(isAnces(Self,owner)){</p>
    <p>cv=getTS(vl);</p>
    <p>if(cv&gt;Self.rv){ // Abort }</p>
    <p>else{ // Read data }</p>
    <p>} else{ // Abort }}</p>
  </div>
  <div class="page">
    <p>TxStore</p>
    <p>If the owner is the transaction itself Write</p>
    <p>Else if the owner is an ancestor of the transaction</p>
    <p>If the atomic acquisition of the ownership is successful If the validation of all the readers in the hierarchy is successful Write</p>
    <p>Else Abort</p>
    <p>Else Abort</p>
    <p>Else Abort</p>
    <p>TxStore(Self,addr,val){</p>
    <p>owner=getOwner(addr);</p>
    <p>if(owner==Self){ // Write data }</p>
    <p>else if(isAnces(Self,owner)){</p>
    <p>if(atomicAcqOwnership(Self,owner,addr)==success){</p>
    <p>if(validateReaders(Self,owner,addr)==success){</p>
    <p>// Write data }</p>
    <p>else{ // Abort }</p>
    <p>} else { // Abort }}</p>
    <p>else { // Abort }}</p>
  </div>
  <div class="page">
    <p>TxCommit</p>
    <p>Validate every memory object in RS</p>
    <p>Using the same conditions checked in TxLoad If fails, abort Merge R/W sets to the parent Linking the pointers</p>
    <p>Loss of temporal locality on these entries Validation / Merging is protected by parents commit-lock</p>
    <p>To address the issue with non-atomic commit (See the paper) Increment version number / transfer ownership for the objects in WS</p>
    <p>TxCommit(Self){</p>
    <p>wv=IncrementGC();</p>
    <p>for each e in Self.RS {</p>
    <p>// Perform the same check in TxLoad</p>
    <p>// If fails, the transaction aborts }</p>
    <p>mergeRWSetsToParent(Self);</p>
    <p>for each e in Self.WS {</p>
    <p>// Increment version number using wv and</p>
    <p>// transfer ownership to parent }</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>TxAbort</p>
    <p>For every memory object in WS</p>
    <p>Restore the memory value to the previous value</p>
    <p>For every memory object in WS</p>
    <p>Restore the voLock value to the previous value Refer to the paper for the invalid read problem</p>
    <p>Retry the transaction</p>
    <p>TxAbort(Self){</p>
    <p>for each e in Self.WS {</p>
    <p>// Restore the memory value to the previous value</p>
    <p>}</p>
    <p>for each e in Self.WS {</p>
    <p>// Restore the voLock value to the previous value</p>
    <p>}</p>
    <p>// Retry the transaction</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Introduction</p>
    <p>Background</p>
    <p>NesTM Algorithm</p>
    <p>Complications of Nesting</p>
    <p>Evaluation</p>
    <p>Conclusions</p>
  </div>
  <div class="page">
    <p>Complications of Nesting</p>
    <p>Subtle correctness issues discovered while developing NesTM</p>
    <p>Invalid read, non-atomic commit, zombie transactions</p>
    <p>Current status: No hand proof of correctness/liveness of NesTM</p>
    <p>Model checking: ChkTM [ICECCS 10]</p>
    <p>Checked correctness with a very small configuration Thread configuration: [1, 2, 1.1, 1.2] / Two memory ops per txn</p>
    <p>Failed to check with larger configurations due to large state space Motivate reduction theorem / partial order reduction techniques</p>
    <p>Random tests: Using the implemented NesTM code</p>
    <p>Tested with larger configurations (e.g., nesting depth of 3)</p>
  </div>
  <div class="page">
    <p>Evaluating NesTM</p>
    <p>Q1: Runtime overhead for top-level parallelism</p>
    <p>Used STAMP applications (Baseline STM vs. NesTM)</p>
    <p>Maximum performance difference is ~25% Due to the extra code in NesTM barriers</p>
    <p>Q2: Performance of nested transactions</p>
    <p>More in the following slides</p>
    <p>Q3: Using nested parallelism to improve performance</p>
    <p>Used a u-benchmark based on two-level hash tables</p>
    <p>If single-level parallelism is limited (e.g., frequent conflicts) Exploiting nested parallelism can be beneficial</p>
  </div>
  <div class="page">
    <p>Q2: Performance of Nested Txns</p>
    <p>hashtable: perform operations on a concurrent hash table</p>
    <p>Two types of operations: Look-up (reads) / Insert (reads/writes)</p>
    <p>Subsumed: Sequentially perform all the operations in a single txn</p>
    <p>Emulate an STM that flattens and serializes nested transactions</p>
    <p>Flat: Concurrently perform operations using top-level txns</p>
    <p>Nested: Repeatedly add outer-level transactions</p>
    <p>N1, N2, and N3 versions</p>
    <p>// Parallelize this loop</p>
    <p>for(i=0;i&lt;numOps;i+=C){</p>
    <p>atomic{</p>
    <p>for(j=0;j&lt;C;j++){</p>
    <p>accessHT(i,j,);}</p>
    <p>}</p>
    <p>}</p>
    <p>Flat version atomic{</p>
    <p>// Parallelize this loop</p>
    <p>for(i=0;i&lt;numOps;i+=C){</p>
    <p>atomic{</p>
    <p>for(j=0;j&lt;C;j++){</p>
    <p>accessHT(i,j,);}</p>
    <p>}}</p>
    <p>}</p>
    <p>Nested version (N1)</p>
  </div>
  <div class="page">
    <p>Q2: Performance of Nested Txns</p>
    <p>Scale up to 16 threads (N1 with 16 threads 3x faster)</p>
    <p>Performance issues</p>
    <p>Non-parallelizable, linearly-increasing overheads E.g., Repeated read-set validation</p>
    <p>More expensive read/write barriers (loss of temporal locality)  Contention on commit-lock (Many nested txns simultaneously commit)</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Propose NesTM with support for nested parallel transactions</p>
    <p>Extend a timestamp-based, eager-versioning STM</p>
    <p>Discuss complications of concurrent nesting</p>
    <p>Describe subtle correctness issues</p>
    <p>Motivate further research on proving / verifying nested STMs</p>
    <p>Quantify NesTM across different use scenarios</p>
    <p>Admittedly, substantial runtime overheads to nested transactions E.g., Repeated read-set validation</p>
    <p>Motivate further research on performance optimizations Software: more efficient algorithm / implementation</p>
    <p>Hardware: cost-effective hardware acceleration [ICS 10]</p>
  </div>
</Presentation>
