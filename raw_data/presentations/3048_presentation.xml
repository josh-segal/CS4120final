<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Proving Confidentiality in a File System Using DiskSec</p>
    <p>(Poster #2)</p>
    <p>Atalay Mert leri, Tej Chajed, Adam Chlipala, Frans Kaashoek, Nickolai Zeldovich</p>
    <p>MIT CSAIL</p>
    <p>OSDI 18</p>
  </div>
  <div class="page">
    <p>Storage Systems Contain Confidential Data</p>
    <p>Users rely on the storage system to maintain their confidentiality.</p>
    <p>A file system will be used as a case study in this talk.</p>
  </div>
  <div class="page">
    <p>Confidentiality in a File System</p>
    <p>Alice and Bob share a file-system on the same machine</p>
    <p>Bob tries to learn the content of Alices files</p>
    <p>Threat model: Bob can call the file-system interface and cannot bypass it.</p>
    <p>cant steal the disk  cant read or write directly to the disk etc.</p>
  </div>
  <div class="page">
    <p>Bugs May Leak Confidential Data</p>
    <p>File-systems are also subject to confidentiality bugs.</p>
    <p>Examples  Crash can expose deleted data (ext4 - 2017)  Anyone can change POSIX ACLs (NFS - 2016)  Truncated data can be accessed (btrfs - 2015)  Crash can expose data (ext4 - 2014)  Anyone can change POSIX ACLs (btrfs, gfs2 - 2010)  ...</p>
  </div>
  <div class="page">
    <p>Approach: Formal Verification</p>
    <p>Write a specification that captures the desired behavior of the system.</p>
    <p>Prove that implementation satisfies the specification.</p>
    <p>As long as specification accurately captures the desired behavior, implementation details are irrelevant.</p>
    <p>We have verified file systems with correctness specifications (e.g. DFSCQ [SOSP17]).</p>
  </div>
  <div class="page">
    <p>dir_b, dir_a</p>
    <p>dir_a, dir_b</p>
    <p>Functional Specifications Do Not Ensure Confidentiality</p>
    <p>Example: Specification for readdir readdir can return entries in any order.</p>
    <p>/dir_a /dir_b</p>
    <p>readdir(...)</p>
    <p>Functional specifications ensure many security properties. (e.g. no memory corruption, no disk corruption etc.)</p>
  </div>
  <div class="page">
    <p>Functional Specifications Do Not Ensure Confidentiality</p>
    <p>Meets specification</p>
    <p>Leaks confidential data</p>
    <p>Nondeterministic functional specifications allow breach of confidentiality.</p>
    <p>Confidentiality requires better specifications.</p>
    <p>def readdir(...) dirs = get_dirlist(...) if (alice.txt file contains a) return sort(dirs) else return reverse_sort(dirs)</p>
  </div>
  <div class="page">
    <p>State of the Art in Verifying Confidentiality Existing Systems</p>
    <p>seL4 [SSP13]  Ironclad [OSDI14]  CertiKOS [PLDI16]  Komodo [SOSP17]  Nickel [OSDI18]</p>
    <p>Above systems use non-interference for their confidentiality specifications. Non-interference does not allow any data exposure from Alice to Bob.</p>
  </div>
  <div class="page">
    <p>Non-interference is Not Suitable for File System Confidentiality.</p>
    <p>File systems have discretionary access control</p>
    <p>File systems intentionally expose metadata.</p>
  </div>
  <div class="page">
    <p>Contributions</p>
    <p>DiskSec Framework for proving confidentiality of storage systems.</p>
    <p>File-system confidentiality specification.  Proof technique to track ownership of the data.  DiskSec implemented and proven in Coq Proof Assistant.</p>
    <p>Evaluation  SFSCQ file system: extension of DFSCQ with</p>
    <p>confidentiality theorem  Confidentiality for simple app on top of SFSCQ</p>
  </div>
  <div class="page">
    <p>Bob Cannot Infer Alices Confidential Data</p>
    <p>World 2World 1</p>
    <p>write(f, a) write(f, b) Alice:Alice:</p>
    <p>Bob Bob</p>
    <p>Data is confidential: observes same results</p>
  </div>
  <div class="page">
    <p>Confidentiality Means Other Users See Same Thing Regardless of Your Data</p>
    <p>s1</p>
    <p>s2</p>
    <p>s1</p>
    <p>s2</p>
    <p>p</p>
    <p>Bob</p>
    <p>p</p>
    <p>Bob</p>
    <p>ret 1</p>
    <p>ret 2</p>
    <p>s w rit</p>
    <p>e(a )</p>
    <p>write(b)</p>
    <p>Confidentiality requires that ret</p>
    <p>World 1</p>
    <p>World 2</p>
    <p>Two states are equivalent with respect to a user (user), if all the data visible to that user is the same in both states.</p>
  </div>
  <div class="page">
    <p>Our Confidentiality Specification: Data Non-interference</p>
    <p>s0 s1 s2</p>
    <p>s0 s1 s2</p>
    <p>Bob Bob</p>
    <p>p</p>
    <p>p</p>
    <p>syscall Bob</p>
    <p>ret 1</p>
    <p>syscall Bob</p>
    <p>ret 2</p>
    <p>=</p>
    <p>Return Non-interferenceState Non-interference</p>
  </div>
  <div class="page">
    <p>Data Non-interference is a Good Confidentiality Specification for File Systems</p>
    <p>Data non-interference</p>
    <p>allows discretionary access control,</p>
    <p>allows exposing of metadata,</p>
    <p>forbids exposing of user data  even indirectly (e.g. readdir)</p>
  </div>
  <div class="page">
    <p>How can We Prove Data Non-interference?</p>
    <p>Data non-interference require more complicated proofs than functional correctness.</p>
    <p>Require reasoning about behavior of two executions.</p>
    <p>Insight: File systems mostly does not inspect user data.  Suffices to reason about where user data is accessed in one</p>
    <p>execution.</p>
  </div>
  <div class="page">
    <p>Our Approach: Sealed Blocks</p>
    <p>Pretend that all disk blocks are logically sealed.</p>
    <p>Function needs to request an unseal to access the data content.</p>
    <p>Functions can be analyzed to prove that they do not unseal user data.</p>
  </div>
  <div class="page">
    <p>Standard Disk Infrastructure</p>
    <p>File system implementation</p>
    <p>read(a: addr) -&gt; data write(a: addr, b: data)</p>
    <p>Disk</p>
    <p>data data data</p>
  </div>
  <div class="page">
    <p>read(a: addr) -&gt; data write(a: addr, b: data)</p>
    <p>DiskSec Infrastructure</p>
    <p>File system implementation</p>
    <p>read(a: addr) -&gt; sblock write(a: addr, b: sblock)</p>
    <p>Sec logical disk</p>
    <p>data owner</p>
    <p>u1, u2, ...</p>
    <p>data owner</p>
    <p>sealed block (sblock)</p>
    <p>seal(d: data, u: user) -&gt; sblock unseal(b: sblock) -&gt; data</p>
    <p>unseal owner trace</p>
    <p>data owner</p>
    <p>data owner</p>
    <p>Disk</p>
  </div>
  <div class="page">
    <p>How to Use DiskSec?</p>
    <p>DiskSec Implementation def read (f,...)</p>
    <p>if (can_access(f)) sealed_data = read_disk(f,...) data = unseal(sealed_data) return data</p>
    <p>else return error</p>
    <p>Standard Implementation def read(f,...) data = read_disk(f,...) return data</p>
  </div>
  <div class="page">
    <p>Sealed Blocks Simplify Confidentiality Proofs</p>
    <p>Unseal Secure Function only unseals data accessible to the current user</p>
    <p>Unseal Secure  Return Non-interference</p>
    <p>Unseal Public Function only unseals data accessible to every user.</p>
    <p>Unseal Public  Data Non-interference</p>
    <p>In this case, state non-interference needs to be proven separately. 20</p>
  </div>
  <div class="page">
    <p>DiskSec Summary</p>
    <p>Provides infrastructure for access control in storage systems.</p>
    <p>Formalizes data non-interference as a confidentiality specification.</p>
    <p>Simplifies proof effort by reducing data non-interference proofs to unseal trace proofs.</p>
  </div>
  <div class="page">
    <p>Applying DiskSec: SFSCQ Overview</p>
    <p>Based on DFSCQ [SOSP17]</p>
    <p>Supports multiple users</p>
    <p>Simplified permission model  All metadata, including file names, are public.  File contents may be public or private.  File owner is set upon creation.</p>
    <p>Fully implemented and verified in Coq Proof Assistant</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Did we prove DFSCQ satisfies data non-interference?  Not completely.  Needed to remove an advanced feature.</p>
    <p>Is performance the same as DFSCQ?  SFSCQ code = DFSCQ code + access control checks</p>
    <p>How much effort did it require?  Took one author ~3 months</p>
  </div>
  <div class="page">
    <p>Conclusions  Correctness specifications are not enough for confidentiality.</p>
    <p>Data non-interference is a suitable confidentiality specification for file systems.</p>
    <p>We designed and implemented DiskSec, a framework for confidentiality proofs for storage systems.</p>
    <p>We implemented SFSCQ, the first file system with machine-checkable confidentiality proofs, using DiskSec.</p>
    <p>https://github.com/mit-pdos/fscq/tree/security</p>
  </div>
</Presentation>
