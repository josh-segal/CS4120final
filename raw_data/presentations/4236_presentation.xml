<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>High-Performance Complex Event Processing over Streams</p>
    <p>Eugene Wu Yanlei Diao Shariq Rizvi UC Berkeley UMass Amherst Google Inc.</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>Complex Event Processing</p>
    <p>Sensor and RFID (Radio Frequency Identification) technologies are gaining mainstream adoption Emerging applications: retail management, food &amp; drug distribution, healthcare, library, postal services High volume of events with complex processing  filtered  correlated for complex pattern detection  transformed to reach an appropriate semantic level</p>
    <p>A new class of queries  translate data of a physical world to useful information</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>+</p>
    <p>A Retail Management Scenario</p>
    <p>RFID tag SHELF-READINGtag id: 01.01298.6EF.0A time: 06-27-2006:15:40:05 location: shelf 2</p>
    <p>EXIT-READING tag id: 01.01298.6EF.0A time: 06-27-2006:16:00:00 location: exit1</p>
    <p>Shelves Checkout counters Exits</p>
    <p>Shoplifting: an item was first read at a shelf and then at an exit but not at any checkout counter in between.</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>Misplaced inventory: an item was first read at shelf 1, then at shelf 2, without being read at any checkout counter or back at shelf 1 afterwards.</p>
    <p>Shoplifting: an item was first read at a shelf and then at an exit but not at any checkout counter in between.</p>
    <p>A Retail Management Scenario</p>
    <p>SHELF-READING tag id: 01.01298.6EF.0A time: 06-27-2006:15:40:05 location: shelf 2</p>
    <p>EXIT-READING tag id: 01.01298.6EF.0A time: 06-27-2006:16:00:00 location: exit1</p>
    <p>Shelves Checkout counters Exits</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>Semantic Complexity</p>
    <p>Time</p>
    <p>Value</p>
    <p>Shoplifting</p>
    <p>Misplaced inventory</p>
    <p>(Id1, Shelf1) (Id1, shelf2) (Id1, Counter3) (Id1, Exit4) (Id2, Shelf1) (Id2, Shelf2) (Id2, Counter3) (Id2, Exit4) (Id3, Shelf1) (Id3, Shelf2) (Id3, Counter3) (Id3, Exit4)</p>
    <p>(Id, Location)</p>
    <p>Patterns span time-value dimensions</p>
    <p>Shelf-reading No counter-reading Exit-reading</p>
    <p>Relevant events are scattered, not continuous</p>
    <p>Shelf-reading1</p>
    <p>No exit-reading</p>
    <p>No shelf-reading1</p>
    <p>Shelf-reading2</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>Performance Requirements</p>
    <p>Low-latency  Up-to-the-second information  Time-critical actions</p>
    <p>Scalability  High-volume event streams  Large monitoring windows</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>Language structure EVENT &lt;event pattern&gt; :structure of an event pattern [WHERE &lt;qualification&gt;] :value-based predicates over the pattern [WITHIN &lt;sliding window&gt;] :sliding window over the pattern</p>
    <p>SASE: Complex Event Language</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>SASE: Complex Event Language</p>
    <p>EVENT SEQ(SHELF-READING s, ! (COUNTER-READING c), EXIT-READING e) WHERE s.tag_id=c.tag_id  s.tag_id=e.tag_id /* equivalence test [tag_id] */ WITHIN 12 hours</p>
    <p>Shoplifting Query</p>
    <p>Input Events s1 c2 s3 s4 s5 s6 e7 c8 e9</p>
    <p>(s3 , e7) (s6 , e9) Output Events</p>
    <p>Timeline</p>
    <p>Closure Property</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>Abstraction of Complex Event Processing</p>
    <p>How can the language be efficiently implemented? Query plan-based approach  Dataflow paradigm with pipelined operators: flexible,</p>
    <p>optimizable, extensible  Existing event systems use fixed data structures</p>
    <p>New abstraction for complex event processing  Native sequence operators, pipelining query-defined</p>
    <p>sequences to subsequent relational style operators  Existing stream systems use relational joins</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>A Basic Query Plan</p>
    <p>Transformation (TF)  Negation (NG)  Window (WD)  Selection ()</p>
    <p>EVENT SEQ(A a, B b, !(C c), D d) WHERE [attr1, attr2]</p>
    <p>a.attr4 &lt; d.attr4 WITHIN W</p>
    <p>Sequence scan &amp; construction (SSC)</p>
    <p>Native Sequence</p>
    <p>Relational</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>Sequence Scan &amp; Construction</p>
    <p>Finite Automata are a natural formalism for sequences Two phases of processing  Sequence Scan (SS): scans input stream to detect matches  Sequence Construction (SC): searches backward (in a</p>
    <p>summary of the stream) to create event sequences.  Some techniques adapted from YFilter [Diao et al. 2003]</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>Illustration of SSC</p>
    <p>*</p>
    <p>*</p>
    <p>A B D</p>
    <p>Sub-sequence type (A, B, D)</p>
    <p>Nondeterministic Finite Automaton (NFA)</p>
    <p>a1 c2 b3 a4 d5 b6 d7 c8 d9</p>
    <p>Runtime stack</p>
    <p>Event Stream</p>
    <p>a1 b6 d9 a4 b6 d9</p>
    <p>Sequence scanSequence scan</p>
    <p>Sequence constructionSequence construction</p>
    <p>O( SeqLen * Window )</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>Optimization Issues</p>
    <p>What are the key issues for optimization?  Large sliding windows: e.g., within past 12 hours  Large intermediate result sizes: may cause wasteful work</p>
    <p>Intra-operator optimization to expedite SSC  Cost of sequence construction depends on the window size.</p>
    <p>Inter-operator optimizations to reduce intermediate results  How to evaluate predicates early in SSC?  How to evaluate windows early in SSC?</p>
    <p>Indexing relevant events in SSC both in temporal order and across value-based partitions</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>*</p>
    <p>*</p>
    <p>A B DNFA</p>
    <p>a1 c2 b3 a4 d5 b6 d7 c8 d9</p>
    <p>Sequence Index</p>
    <p>Events</p>
    <p>(.) a1 (.) a4</p>
    <p>(a1) b3 (a4) b6</p>
    <p>(b3) d5 (b6) d7 (b6) d9</p>
    <p>Optimizing SSC</p>
    <p>Sequence index integrated with the NFA model</p>
    <p>a1 b3 d9 a1 b6 d9 a4 b6 d9</p>
    <p>SS builds the index in NFA execution  SC searches the sequence index for event sequences</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>Pushing An Equivalence Test To SSC Equivalence test: equality across all events in a sequence Partitioned sequence index: sequence + value</p>
    <p>NFA</p>
    <p>Partitioned Sequence Index(PASI)</p>
    <p>a1 c2 b3 a4 d5 b6 d7 c8 d9Events Values of attr1 1 1 1 2 1 2 1 2 2</p>
    <p>(.) a1 (a1) b3 (b3) d5 (b3) b7</p>
    <p>(bb) d9(.) a4 (a4) b6 a4 b6 d9</p>
    <p>partition 1</p>
    <p>partition 2</p>
    <p>*</p>
    <p>* A B D</p>
    <p>attr1</p>
    <p>SS is extended with transition filtering &amp; stack maintenance  SC searches only in a partitioned sequence index</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>Other Inter-Operator Optimizations</p>
    <p>Evaluating additional equivalence tests in SSC  Multi-attribute partitions: high memory overhead</p>
    <p>Single-attribute partitions &amp; cross filtering in SS  Dynamic filtering in SC</p>
    <p>Evaluating windows in SSC  Windows in SS: coarse grained filtering, pruning  Windows in SC: precise checking</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>Performance Evaluation (1)</p>
    <p>Effectiveness of query processing in SASE  Sequence index offers an order-of-magnitude</p>
    <p>improvement with large windows &amp; query result sizes.  Partitioned sequence index is highly effective. Pushing</p>
    <p>one equivalence test to SSC is a must!  Dynamic Filtering in SC is memory economical and</p>
    <p>best performing for additional equivalence tests.  Pushing windows down  Cost of negation</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>Performance Evaluation (2) Comparison to a stream system using joins</p>
    <p>SASE: EVENT SEQ(E1, E2, , EL) WHERE [attr1 (, attr2)?] WITHIN W</p>
    <p>Parameters: L  Sequence length W  Window size in # events V1  domain size of attr1 V2  domain size of attr2</p>
    <p>Join-based Stream Processor: L=3, W=10000, [attr1] With R As (Select * From ES e Where e.type = E1) S As (Select * From ES e Where e.type = E2) T As (Select * From ES e Where e.type = E3) ( Select * From R r [range by 10000]</p>
    <p>S s [range by 10000] T t [range by 10000]</p>
    <p>Where r.attr1 = s.attr1 and r.attr1 = t.attr1 and s.time &gt; r.time and t.time &gt; s.time )</p>
    <p>Offered hint on the most selective predicate to the stream optimizer  Performance metric is throughput</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>Varying Sequence Length EVENT SEQ(E1, E2, , EL) WHERE [attr1] WITHIN W Parameters: L = 2-6 W = 10,000 [Attr1] V1 = 100</p>
    <p>SASE scales better than Stream-Join for longer sequences.  Stream Join: N-way joins, postponed temporal predicates  SASE: NFA for sequences, value index for predicates, both in SSC</p>
    <p>Sequence Length N</p>
    <p>o rm</p>
    <p>al iz</p>
    <p>ed T</p>
    <p>h ro</p>
    <p>u g</p>
    <p>h p</p>
    <p>u t</p>
    <p>SASE TCQ SASE Stream-Join</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>Varying Selectivity of Predicates EVENT SEQ(E1, E2, , EL) WHERE [attr1 (, attr2)?] WITHIN W Parameters: L = 3 W = 10,000 [Attr1] V1 = 10  10,000</p>
    <p>[Attr2] V2 = 20</p>
    <p>SASE produces fewer intermediate results than Stream-Join.  Stream-Join: cascading joins, postponed temporal predicates  SASE: both sequencing and predicates in SSC, before producing</p>
    <p>any intermediate results</p>
    <p>Domain Size of the 1st Equivalence Attribute N</p>
    <p>o rm</p>
    <p>al iz</p>
    <p>ed T</p>
    <p>h ro</p>
    <p>u g</p>
    <p>h p</p>
    <p>u t</p>
    <p>SASE 1 equiv TCQ 1 equiv SASE 1 equiv Stream-Join 1 equiv</p>
    <p>Domain Size of the 1st Equivalence Attribute N</p>
    <p>o rm</p>
    <p>al iz</p>
    <p>ed T</p>
    <p>h ro</p>
    <p>u g</p>
    <p>h p</p>
    <p>u t</p>
    <p>SASE 2 equivs SASE 1 equiv TCQ 2 equivs TCQ 1 equiv</p>
    <p>SASE 1 equiv Stream-Join 2 equivs Stream-Join 1 equiv</p>
    <p>SASE 2 equivs</p>
  </div>
  <div class="page">
    <p>Yanlei Diao, University of Massachusetts Amherst</p>
    <p>Conclusions Compact, expressive complex event language  Sequence, negation, predicates, sliding windows</p>
    <p>Query processing approach with a new abstraction  Native sequence operators + subsequent relational-style operators</p>
    <p>Optimization Techniques  Handling large slide windows  Reducing intermediate result sizes</p>
    <p>Summary of results  Relational stream systems not suited for complex event processing  Native sequence operators + optimized plans efficient and scalable  Our event processing technology can be integrated into stream systems.</p>
  </div>
</Presentation>
