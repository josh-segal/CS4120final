<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>AuthentiCall: Efficient Identity and Content Authentication for</p>
    <p>Brad Reaves, Logan Blue, Hadi Abdullah, Luis Vargas, Patrick Traynor, and Tom Shrimpton</p>
    <p>North Carolina State University University of Florida</p>
  </div>
  <div class="page">
    <p>Problems with Phone Calls</p>
    <p>All of these problems have a single root cause: Users cannot authenticate the calls they place or receive</p>
  </div>
  <div class="page">
    <p>The root of the problem  In general, neither carriers nor end users can provide guarantees about</p>
    <p>who is on a call or where the call is coming from  Faking a Caller ID is easy</p>
    <p>What is at the root of this problem? 3</p>
  </div>
  <div class="page">
    <p>IP Networks</p>
    <p>PSTN</p>
    <p>Cell Network</p>
    <p>Gateway</p>
    <p>Gateway</p>
    <p>Intermediary Telco</p>
    <p>Networks</p>
    <p>Internet</p>
    <p>VOIP Carrier</p>
    <p>Web Services</p>
    <p>VOIP Proxy</p>
    <p>Modern Telephone Systems</p>
  </div>
  <div class="page">
    <p>IP Networks</p>
    <p>PSTN</p>
    <p>Cell Network</p>
    <p>Gateway</p>
    <p>Gateway</p>
    <p>Intermediary Telco</p>
    <p>Networks</p>
    <p>Internet</p>
    <p>VOIP Carrier</p>
    <p>Web Services</p>
    <p>VOIP Proxy</p>
    <p>Modern Telephone Systems</p>
  </div>
  <div class="page">
    <p>Along the way:</p>
    <p>No guaranteed shared data path between endpoints</p>
    <p>What happens to the call</p>
    <p>IP Networks</p>
    <p>PSTN</p>
    <p>Cell Network</p>
    <p>Gateway</p>
    <p>Gateway</p>
    <p>Intermediary Telco</p>
    <p>Networks</p>
    <p>Internet</p>
    <p>VOIP Carrier</p>
    <p>Web Services</p>
    <p>VOIP Proxy</p>
    <p>The heterogeneity of the network complicates authentication</p>
  </div>
  <div class="page">
    <p>Insight: Use data channels  Most phones now have access to an (often low-bitrate) Internet connection</p>
    <p>Data channel may not support bandwidth or quality of the phone network  How can this data channel be used to authenticate phone</p>
    <p>calls? 7</p>
    <p>Cellular: 2G, 3G, 4G data</p>
    <p>VoIP: Inherent data</p>
    <p>Landline: Ubiquitous</p>
    <p>WiFi</p>
  </div>
  <div class="page">
    <p>AuthentiCall  AuthentiCall cryptographically authenticates both call parties</p>
    <p>and call content end-to-end for regular phone calls through an auxiliary data channel</p>
    <p>Before the Call: AuthentiCall verifies identity before the call, making call experience similar to what users already do</p>
    <p>Fast: AuthentiCall adds 1-1.4 seconds to call setup  Mutual authentication: Both caller and callee are identified  Protects content: Call content can be verified as authentic  Protects against abuse: Protects callee privacy and can prevent abuse by users</p>
  </div>
  <div class="page">
    <p>AuthentiCall Mechanisms  Protocols to enroll phones and authenticate</p>
    <p>incoming calls using a data channel</p>
    <p>Audio Authentication Techniques to protect call content and ensure call integrity</p>
    <p>Existing content authentication techniques will not solve this problem</p>
  </div>
  <div class="page">
    <p>AuthentiCall Protocols  We need to provide authentication  In a setting where neither party is likely to have a public-facing IP  And in which adversaries have a strong incentive to flood the system with</p>
    <p>connection requests  And may lie about owning a particular phone  A trusted intermediary can solve these issues</p>
    <p>But at a risk of compromise of the intermediary itself  We need custom protocols to address these issues</p>
  </div>
  <div class="page">
    <p>AuthentiCall issues certificates to authenticate users</p>
    <p>Need protocol to ensure the client actually owns the phone number</p>
    <p>No human in the loop!  Limitations: similar to the Internet</p>
    <p>CA model</p>
    <p>AuthentiCall Enrollment</p>
    <p>C lie</p>
    <p>nt (</p>
    <p>C )</p>
    <p>C A</p>
    <p>Server (SC A</p>
    <p>)</p>
    <p>Data Channel Audio Channel</p>
    <p>(1)</p>
    <p>ID(C), PhNum(C), ID(SCA), K + C</p>
    <p>NNet, ID(C), PhNum(C),</p>
    <p>ID(SCA), PhNum(SCA), TS (2)</p>
    <p>N Audio</p>
    <p>(3)</p>
    <p>N Audio</p>
    <p>, N Net</p>
    <p>, ID(C), PhNum(C)ID(S</p>
    <p>CA</p>
    <p>), TS, Sign k</p>
    <p>C</p>
    <p>(4) Cert(ID(C), PhNum(C),</p>
    <p>K+C , SignKSCA )</p>
    <p>(5)</p>
  </div>
  <div class="page">
    <p>AuthentiCall Handshake</p>
    <p>Handshake complete Both sides authenticated</p>
    <p>Information to establish a key end-to-end securely in</p>
    <p>presence of adversary</p>
    <p>Normal Voice Call Can Proceed</p>
    <p>Server (S)Caller (R) Callee (E)</p>
    <p>(1)</p>
    <p>Call PhNum(E)</p>
    <p>E 2 AuthentiCall Users Incoming call from R</p>
    <p>(2) (3)</p>
    <p>ID(E), PhNum(E), ID(R), PhNum(R)</p>
    <p>Cert(E), TS2, NE, DHE, SignKE (4a) (4b)</p>
    <p>ID(R), PhNum(R), ID(E), PhNum(E)</p>
    <p>Cert(R), TS1, NR, DHR, SignKR</p>
    <p>HMACKER1 (msg4a, msg4b, Caller) HMACKER2 (msg4a, msg4b, Callee)</p>
    <p>(5a) (5b)</p>
    <p>TLS to Server Voice CallMessage via Server TLS</p>
  </div>
  <div class="page">
    <p>Performance = How long to authenticate a phone call</p>
    <p>Regular calls take many seconds to set up with high variance</p>
    <p>AuthentiCall calls experience a negligible 1-1.4 additional seconds for call establishment</p>
    <p>Handshake Performance</p>
    <p>Fig. 10. Enrollment takes less than 30 seconds and is a one time process that may be done in the background.</p>
    <p>they are faithfully transmitted through every telephone system and were simple to send and detect. There are 16 touch-tone digits6, so each tone can represent an encoded hexadecimal digit. These tones are transmitted for 200ms each with a 100ms pause between tones. This provides a bit rate of 53.3 bits per second for a nonce transmission time of 9.6 seconds. This transmission time comprises the bulk of the time spent in the enrollment protocol.</p>
    <p>VII. RESULTS</p>
    <p>Now that we have described our AuthentiCall implementation, we can evaluate its performance in enrollment, conducting call handshakes, and comparing digests in real phone calls.</p>
    <p>A. Experiment Setup Before describing individual experiments, we briefly de</p>
    <p>scribe our experiment testbed. The AuthentiCall server was placed on an Amazon Web Services (AWS) server located in Northern Virginia to model a realistic round trip time (RTT). We used the same network provider, AT&amp;T, and the same cellular devices, Samsung Galaxy Note II N7100s, across all experiments. The enrollment and handshake experiments were carried out 20 times over both WiFi and 3G, and digest exchange tests were done 10 times using a WiFi data channel. Digest exchange was only done over WiFi as this experiment was used compare content of the messages and not the delivery speed. In all experiments, voice was sent over a 3G voice channel while the protocol messages and data were sent over the selected data channel.</p>
    <p>B. Enrollment Protocol Our first experiments measure the time it will take the user</p>
    <p>to enroll. We measure the time from the instant a user begins</p>
    <p>Fig. 11. AuthentiCall adds 1 to 1.41 seconds to the phone call establishment. Note that this overhead is about the same as the standard error mean for 3G call establishment time. This makes the overhead effectively unnoticeable to users.</p>
    <p>enrollment to when the user receives the signed certificate in the last protocol message. This includes time taken to exchange protocol messages and to transmit and receive an audio nonce. For clients, enrollment is a one-time process that is done before the first call can be placed. It is analogous to activating a credit card with a bank, but in our case it requires no direct user input. Figure 10 shows the average time of enrollment using the 3G and WiFi networks data channel to exchange protocol messages. The main contributor to the enrollment time comes from the transmission of the audio nonce which is used to establish ownership. Though the enrollment times over 3G and WiFi are 25 and 22 seconds respectively, these can be done in the background without any user interaction.</p>
    <p>C. Handshake Protocol</p>
    <p>We next measure the time taken to complete an entire handshake on a single client, including data messages and voice call set up time. We note that voice call set up time is substantial, and requires many seconds even without AuthentiCall. We believe the most important performance metric is additional latency experienced by the end user. As shown in Figure 11, AuthentiCall only adds 1.07 seconds for WiFi or 1.41 seconds on 3G data to the total call establishment time. We believe that this will be unnoticeable to the user for several reasons. First, call establishment varies significantly in the time it takes, and this is normal network behavior, not an artifact introduced by AuthentiCall. In our 3G experiments our additional handshake time is approximately equal to the standard error in voice call establishment. We also note that our test phones were in the same location connected to the same tower, so the voice call setup time is likely lower than a typical call. This means that the additional time AuthentiCall adds to calls is likely far lower for typical calls. Finally, we note that this is substantially</p>
  </div>
  <div class="page">
    <p>But what about this one?</p>
    <p>Telephony Core</p>
    <p>Telephony Core</p>
    <p>HI CC#?</p>
    <p>Content Injection</p>
    <p>The Handshake deals with this attack:</p>
    <p>Telephony Core</p>
    <p>Caller ID Spoofing</p>
    <p>BankFBI</p>
    <p>Telephony Core</p>
    <p>Call Race Condition</p>
    <p>Bank</p>
    <p>AuthentiCall</p>
    <p>Or this one?</p>
    <p>FBI</p>
  </div>
  <div class="page">
    <p>Call Content Protection  We need to bind the voice and data channel and assure liveness</p>
    <p>and content integrity  How do we use a low bandwidth side channel to authenticate call audio?</p>
  </div>
  <div class="page">
    <p>SHA256SHA256</p>
    <p>Mr. Watson: come here.</p>
    <p>Phone Network</p>
    <p>Mr. Watson: come here.</p>
    <p>Phone Network</p>
    <p>Solution: send digests of the call audio  Digesting is not simple because call audio is</p>
    <p>legitimately modified in transit  Cryptographic hashes wont work here!</p>
    <p>We need a robust digest that preserves audio semantics while ignoring legitimate modifications</p>
    <p>Cryptographically authenticating data that can change in unknown ways is hard</p>
    <p>Solution: Robust Digests</p>
    <p>DigestDigest</p>
  </div>
  <div class="page">
    <p>RSH: The Robust Hash</p>
    <p>r0,0 r0,1 r1,0</p>
    <p>r0,10</p>
    <p>r200,0</p>
    <p>..</p>
    <p>r200,10</p>
    <p>DCT DCT</p>
    <p>&gt;</p>
    <p>Index l1</p>
    <p>Index l2</p>
    <p>Audio Features (once per second)</p>
    <p>Compression Function (64 times per second)</p>
    <p>.</p>
    <p>Index l1 + w</p>
    <p>Index l2 + w</p>
    <p>Matrix L</p>
    <p>B1</p>
    <p>B2</p>
    <p>Fig. 6. This figure illustrates the digest construction described in Section V-A. Audio digests summarize call content by taking one second of speech data, deriving audio features from the data, and compressing blocks of those features into a bit string.</p>
    <p>which they call RSH. We chose this technique over others because it provides good performance on speech at a lowbitrate, among other properties. We note that the original work did not evaluate the critical case where an adversary can control the audio being hashed. Our evaluation shows that RSH maintains audio integrity in this crucial case. The construction also selects audio probabilistically; we show in Appendix A that the digest indeed protects all of the semantic content in the input audio. Finally, to our knowledge we are the first to use any robust speech digest for an authentication and integrity scheme.</p>
    <p>Figure 6 illustrates how RSH computes a 512-bit digest for one second of audio. In the first step of calculating a digest, feature computation, RSH computes the Line Spectral Frequencies (LSFs) of the input audio. LSFs are commonly used in speech compression algorithms to represent the major frequency components of human voice (known as formants), which contain the majority of semantic information in speech. That is, LSFs represent phonemes  the individual sound units present in speech. While pitch is useful for speaker recognition, LSFs are not a perfect representation of all of the nuances of human voice. This is one reason why it is sometimes difficult for humans to confidently recognize voices over the phone. This means that the digest more accurately represents semantic content rather than the speakers voice characteristics. This is important because a number of techniques are able to synthesize new speech that evades speaker recognition from existing voice samples [48], [80]. Finally, LSFs are numerically stable and robust to quantization  meaning that modest changes in input yield small changes in output. In RSH, the input audio is grouped into 30ms frames with 25ms audio overlap between frames, and 10 line spectral frequencies are computed for each frame to create a matrix L.</p>
    <p>The second phase of digest computation involves compressing the large amount of information about the audio into a digest. Because audio rarely changes on millisecond time scales, the representation L is highly redundant. To compress this redundant data, RSH uses the two-dimensional discrete</p>
    <p>cosine transform (DCT). The DCT is related to the Fourier transform, is computationally efficient, and is commonly used in compression algorithms (e.g., JPEG, MP3). RSH computes the DCT over different sections of the matrix L to produce the final digest. RSH only uses first eight DCT coefficients (corresponding to the highest energy components and discarding high-frquency information).</p>
    <p>The second phase of digest computation  the compression function  uses the DCT algorithm in the computation of the bitwise representation of the audio sample. The following process generates 8 bits of a digest; it is repeated 64 times to generate a 512 bit digest.</p>
    <p>We note that sections of audio are selected probabilistically; we show in Appendix A that the probability that a section of audio is not used in a digest is negligible. This simply means that digests cover practically all content in the call.</p>
    <p>An important consideration is to note that the digest is keyed. These digests are clearly not intended to be used for the same purposes as a cryptographic hash, and the use of a key in these functions is for a different purpose than keying in a cryptographic construction. By using a pseudorandom function, digests become dependent on time. This dependence adds entropy to digest construction so that repeated phrases generate unique digests. It also has the advantage that it makes it difficult to compute digests for audio without knowledge of the key, which in AuthentiCall is derived during the handshake for each call. In AuthentiCall, digests themselves are also</p>
    <p>RSH compresses 1 second of audio into 512 bits Audio differences can be measured with bit error</p>
    <p>Y. Jiao, L. Ji, and X. Niu, Robust Speech Hashing for Content Authentication, IEEE Signal Processing Letters, vol. 16, no. 9, pp. 818821, Sep. 2009.</p>
  </div>
  <div class="page">
    <p>RSH: Our Contribution  RSH was not intended for this domain and only briefly analyzed in the</p>
    <p>literature</p>
    <p>We need to show:  That the randomized construction indeed protects all of the audio  That the algorithm will work in real systems  That the algorithm will work in an adversarial setting</p>
  </div>
  <div class="page">
    <p>Audio Digest Performance</p>
    <p>Legitimate changes to audio result in small changes to digests while substituting content results in large changes</p>
    <p>Making adversaries easy to detect</p>
    <p>Fig. 8. This graph shows the histogram and kernel density estimate of digest of adversarial audio on over 250 million pairs of 1-second speech samples. While the majority of legitimately modified audio has digest errors less than 35%, adversarial audio has digest BERs averaging 47.8%.</p>
    <p>error is close to the optimal, best possible distance between two adversarial digests.</p>
    <p>Because the TIMIT corpus contains speakers speaking several identical sentences, we can investigate the resilience of the digest to more specific adversarial scenarios in two important ways. First, we can look at whether using different speech from the same speaker can create a false positive. If so, this would be a serious problem because an adversary could use recorded words from the target speaker undetected. Second, we can determine if a different speaker uttering the same words causes false positives. This test indicates to what extent the digest is protecting content instead of speaker characteristics. We found that digests from the same speaker speaking different content are accepted at practically the same rate as audio that differs in speaker and content. At a BER detection threshold of 0.384 (derived and discussed in the following subsection), the detection rate for different content spoken by the same speaker is 0.901482, while the detection rate for different content spoken by a different speaker is 0.901215. However, identical phrases spoken by different speakers results in a much higher rate of collision and a detection rate of 0.680353. This lower detection rate is not a problem for AuthentiCall because it is still high enough to detect modified call audio with high probability. More importantly, it indicates that RSH is highly sensitive to changes in call content.</p>
    <p>Fig. 9. The digest performance ROC graph shows that digests can easily distinguish between legitimate and substituted audio, even in the presence of transcoding, loss, delay, and noise. These results are computed over digests of a single second. The graph is scaled to show the extreme upper corner.</p>
    <p>combination of GSM, AMR-NB, 5% frame loss, 10ms delay, and 30dB of white noise. This combination represents an approximate worst case of legitimate audio. Figure 9 shows excellent performance in terms of distinguishing audio. For GSM-only audio, we see an area-under-curve of 0.998, and for the worst case audio, we see an area-under-curve of 0.992. However, because digests will be used at a high rate (one per second), even with a very small false positive rate, alerting users for every individual detection will likely result in warning fatigue. As a result, the most important metric for evaluating a threshold is minimizing the userss likelihood of a false positive. This problem suggests trading off sensitivity to short changes in call content for a lower false positive rate. To reduce overhead and network load, AuthentiCall sends digests in groups of five. To provide high detection rates while limiting false positives, AuthentiCall alerts the user if any 3 out of 5 digests are greater than the BER threshold. We model true and false performance of this scheme as a set of five Bernouli trials  successful authentication for true positives and successful digest collision for false positives. Thus, we can compute 3out-of-5 performance using the binomial distribution.</p>
    <p>After this analysis, we selected an individual-digest BER threshold of 0.384. This corresponds to an individual adversary audio true positive detection rate of 0.90, while presenting a 0.0058 false positive rate against our worst-case audio and a 0.00089 false positive rate against clean GSM-FR encoded audio. Using our three-out-of-five alerting scheme, the probability of detecting 3 or more seconds of tampered audio is 0.992. The false positive rate is drastically reduced: the false positive rate is 1.96  106, and for clean GSM-FR audio the false positive rate is 7.02109. This corresponds to a false alert on average every 425.1 hours of talk time for worst case audio, and for GSM-FR audio one false positive every 118,766 hours. For reference, the average British mobile phone user only places 176 minutes per month of outbound calls [79];</p>
    <p>Difference in digests between different sentences of audio Average case: 48% error</p>
    <p>authenticated using an HMAC to guarantee digest integrity in transit.</p>
    <p>Digests are computed by the caller and are received and verified by the callee. The verifying party computes the digest of the received audio, then computes the hamming distance between the calculated and received digests. Because degradation of audio over a phone call is expected, digests will not match exactly. However, the Hamming distance between two audio digests  or bit error rate (BER)  is related to the amount of change in the audio. By setting an appropriate threshold on BER, legitimate audio can be distinguished from incorrect audio.</p>
    <p>B. Implementation and Evaluation</p>
    <p>Now that we have seen how RSH digests are computed, we can evaluate properties of RSH digests. This includes effects of legitimate transformations and the results of comparing digests of unrelated audio samples (as might be generated by an adversary). We also describe how we use digests to detect tampered audio.</p>
    <p>We implement RSH using Matlab, and we deploy it in our AuthentiCall prototype by using the Matlab Coder toolbox to generate C code that is compiled as an Android native code library. We use the TIMIT audio corpus [37] which is a standard test dataset for speech processing systems. It consists of high-fidelity recordings of 630 male and female speakers reading 10 English sentences constructed for phonetic diversity. Because RSH computes hashes of one second of audio, we split the TIMIT audio data into discrete seconds of audio corresponding to a unique section of audio from a speaker and sentence. This resulted in 22,487 seconds of unique audio.</p>
    <p>Fig. 7. These box plots show the distribution of digests bit error rates as a result of various audio degradations. These error rates are well below the rates seen by adversarial audio, shown in Figure 8</p>
    <p>Matlabs agwn function to add Gaussian white noise at a 30 decibel signal to noise ratio.</p>
    <p>Figure 7 shows boxplots representing the distribution of BER rates of each type of degradation tested. All degradations show a fairly tight BER distribution near the median with a long tail. We see that of the effects tested, 10ms delay has the least effect; this is a result of the fact that the digest windows the audio with a high overlap. For most digests, addition of white noise also has little effect; this is because LSF analysis discards all frequency information except for the most important frequencies. We see higher error rates caused by the use of audio codecs like GSM-FR and AMR-NB; these codecs significantly alter the frequency content of the audio. We can also see that a 5% loss rate has negligible effect on the audio digests. Finally, we see that combining transcoding, loss, delay, and noise has an additive effect on the resulting digest error  in other words, the more degradation that takes place, the higher the bit error. These experiments show that RSH is robust to common audio modifications.</p>
    <p>We find that the mean BER between two distinct audio pairs is 0.478. A histogram and kernel density estimate of these values is also shown in Figure 8. This plot shows that the bit error is normally distributed with a mean and median of 0.478 and 0.480 (respectively). The expected bit error for two random bit strings is 50%, and the mean seen for RSH bit</p>
    <p>Change in digests before and after network</p>
    <p>transmission Average case: 10-20% of bits</p>
  </div>
  <div class="page">
    <p>Individual seconds of audio: 90% detection (false positives: 0.58%, or 1 every 3 minutes)</p>
    <p>3-out-of-5 seconds: 99%(with a single FP roughly every 6 years)</p>
    <p>This ensures both users are on the correct call (channel binding) and that call audio is</p>
    <p>unmodified</p>
    <p>Audio Digest Performance</p>
    <p>Fig. 8. This graph shows the histogram and kernel density estimate of digest of adversarial audio on over 250 million pairs of 1-second speech samples. While the majority of legitimately modified audio has digest errors less than 35%, adversarial audio has digest BERs averaging 47.8%.</p>
    <p>error is close to the optimal, best possible distance between two adversarial digests.</p>
    <p>Because the TIMIT corpus contains speakers speaking several identical sentences, we can investigate the resilience of the digest to more specific adversarial scenarios in two important ways. First, we can look at whether using different speech from the same speaker can create a false positive. If so, this would be a serious problem because an adversary could use recorded words from the target speaker undetected. Second, we can determine if a different speaker uttering the same words causes false positives. This test indicates to what extent the digest is protecting content instead of speaker characteristics. We found that digests from the same speaker speaking different content are accepted at practically the same rate as audio that differs in speaker and content. At a BER detection threshold of 0.384 (derived and discussed in the following subsection), the detection rate for different content spoken by the same speaker is 0.901482, while the detection rate for different content spoken by a different speaker is 0.901215. However, identical phrases spoken by different speakers results in a much higher rate of collision and a detection rate of 0.680353. This lower detection rate is not a problem for AuthentiCall because it is still high enough to detect modified call audio with high probability. More importantly, it indicates that RSH is highly sensitive to changes in call content.</p>
    <p>Fig. 9. The digest performance ROC graph shows that digests can easily distinguish between legitimate and substituted audio, even in the presence of transcoding, loss, delay, and noise. These results are computed over digests of a single second. The graph is scaled to show the extreme upper corner.</p>
    <p>combination of GSM, AMR-NB, 5% frame loss, 10ms delay, and 30dB of white noise. This combination represents an approximate worst case of legitimate audio. Figure 9 shows excellent performance in terms of distinguishing audio. For GSM-only audio, we see an area-under-curve of 0.998, and for the worst case audio, we see an area-under-curve of 0.992. However, because digests will be used at a high rate (one per second), even with a very small false positive rate, alerting users for every individual detection will likely result in warning fatigue. As a result, the most important metric for evaluating a threshold is minimizing the userss likelihood of a false positive. This problem suggests trading off sensitivity to short changes in call content for a lower false positive rate. To reduce overhead and network load, AuthentiCall sends digests in groups of five. To provide high detection rates while limiting false positives, AuthentiCall alerts the user if any 3 out of 5 digests are greater than the BER threshold. We model true and false performance of this scheme as a set of five Bernouli trials  successful authentication for true positives and successful digest collision for false positives. Thus, we can compute 3out-of-5 performance using the binomial distribution.</p>
    <p>After this analysis, we selected an individual-digest BER threshold of 0.384. This corresponds to an individual adversary audio true positive detection rate of 0.90, while presenting a 0.0058 false positive rate against our worst-case audio and a 0.00089 false positive rate against clean GSM-FR encoded audio. Using our three-out-of-five alerting scheme, the probability of detecting 3 or more seconds of tampered audio is 0.992. The false positive rate is drastically reduced: the false positive rate is 1.96  106, and for clean GSM-FR audio the false positive rate is 7.02109. This corresponds to a false alert on average every 425.1 hours of talk time for worst case audio, and for GSM-FR audio one false positive every 118,766 hours. For reference, the average British mobile phone user only places 176 minutes per month of outbound calls [79];</p>
  </div>
  <div class="page">
    <p>AuthentiCall can authenticate calls before answering  mitigating fraud and unwanted robocalls while increasing trust in the phone system</p>
    <p>We can protect call content from modification</p>
    <p>All at negligible cost to call experience!</p>
    <p>Take Away</p>
    <p>increasingly common social engineering attack is swatting, which uses Caller ID spoofing to dial 911 claiming an active shooter or other situation that prompts a rapid, heavily armed response. These attacks endanger the lives of their targets and the police who respond. With AuthentiCall, authorities would have greater confidence in the source of a report allowing for an appropriately measured response.</p>
    <p>B. Cellular Network Load</p>
    <p>Cellular networks use expensive and heavy weight signaling protocols for voice calls and SMS, and under heavy load can face signaling storms that make network services unavailable [33], [50], [74]. Accordingly, any system that affects call signaling must be careful not to increase signaling load on the network. We believe that AuthentiCall will not significantly increase signaling load for two reasons. First, in modern networks (3G and 4G), data signaling is no longer as expensive as a voice call, and simultaneous voice and data use is common place. This simply means that from a network perspective, AuthentiCall will appear like normal user traffic. Second, the caller only contacts AuthentiCall when placing a call, and the callee is notified using a popular push messaging service shared by many other apps, so the marginal data load is minimal.</p>
    <p>C. Certificate Expiration and Revocation</p>
    <p>Any system that relies upon certificates faces the problem of setting expiration policies and handling certificate revocation. AuthentiCalls centralized model provides a simple revocation mechanism. While keys are securely established end-to-end, certificates used in the handshake are visible to the server. While passing messages, the server can verify that the certificate identifier is not in a list of revoked certificates. Certificate lifetime is another matter. Certificate lifetime policies must balance a number of considerations. Short expirations are preferred because they reduce the likelihood that a user can authenticate phone numbers for a number no longer under her control. Short expirations also reduce the impact of a private key compromise. The main argument for longer certificate lifetimes is to minimize the cost and effort of renewing a certificate. However, as we show in Section IV, certificate authentication is a simple, automated process. (Our inspiration for this requirement was Lets Encrypt [7]). Accordingly, setting very short lifetimes is not costly, and monthly renewal is a practical method of ensuring that users still control the phone number associated with their accounts. As mentioned in Section IV, AuthentiCall could also make use of the proposed Telephony PKI [68]. In this scenario, certificate lifetime would be determined by the TPKI, and revocation managed by a certificate revocation list (CRL) published by the TPKI.</p>
    <p>D. Design Alternatives</p>
    <p>In designing AuthentiCall we faced many design decisions. This section explains why we made the decisions we did as opposed to alternative approaches.</p>
    <p>(b)(a)</p>
    <p>Fig. 13. Here we show the AuthentiCall system detecting Caller ID fraud before the user answers the call.</p>
    <p>One decision was the use of an IP data channel, which we chose for several reasons. The first was that an IP channel is already immediately available to most devices. Landline-only telephony devices are also drastically decreasing in use [6]. Still, we believe that for legacy landline systems it would be possible to build auxilliary hardware with data access to participate in AuthentiCall.</p>
    <p>A possible alternative to cellular data is SMS. This is impractical even after assuming reliable realtime transmission of SMS, which is not actually guaranteed by any carrier [83]. We rejected SMS not only because it would exclude VoIP devices, but also because it is simply impractical. As a crude estimate, our current protocol requires a minimum of six messages. The average time to send one SMS message is 6.4 seconds [65], meaning that AuthentiCall using SMS would require a minimum of 38.4 seconds  effectively increasing time to place a call by a factor of 5. However, our protocol is also 6,386 bytes in total, which after encoding as ASCII857 grows to 7983 messages. Given that SMS is limited to 160byte messages, the worst case delivery time is approximately 319 seconds  over 5 minutes to set up a call.</p>
    <p>Another decision was the use of speech digests instead of an alternative like a continuous voice biometric. We believe speech digests are superior for several reasons. The primary reason is that voice authentication is simply not secure in adversarial settings [48]. Given prior speech samples, an adversary can generate arbitrary audio that defeats state-of-the-art voice authentication. Other arguments against voice biometrics deal with feasibility. Maintaining and distributing a voice biometric would be problematic; any call party would receive a permanent irrevocable description of their interlocutors voice.</p>
  </div>
  <div class="page">
    <p>Questions?</p>
    <p>Brad Reaves BradReaves.net</p>
    <p>Takeaway: AuthentiCall cryptographically authenticates both call parties and call content end-to-end for regular phone calls through an auxiliary data channel</p>
  </div>
</Presentation>
