<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>An Introduction to PVS Metamodelling with PVS</p>
    <p>Richard Paige</p>
    <p>Department of Computer Science</p>
    <p>University of York, York, U.K.</p>
    <p>paige@cs.york.ac.uk</p>
    <p>and</p>
    <p>Department of Computer Science</p>
    <p>York University, Toronto, Canada.</p>
  </div>
  <div class="page">
    <p>PVS: What Is It?</p>
    <p>A verification system with  a general-purpose formal specification language,</p>
    <p>associated with a theorem prover, model checker, and related tools (browser, doc. generator).</p>
    <p>Freely distributed by SRI, currently on v2.4  Runs on Solaris and Linux, UI based on Emacs and</p>
    <p>Tcl/Tk  Used in both academia and industry  Rich specification language, powerful prover, expressive</p>
    <p>libraries, wealth of support.  Applications: safety critical systems, hardware,</p>
    <p>mathematics, distributed algorithms</p>
  </div>
  <div class="page">
    <p>Overview</p>
    <p>Introduction to the PVS specification language  Look-and-feel of the prover.</p>
    <p>Some key prover commands.  Several little examples.  Using PVS for</p>
    <p>meta-modelling  expressing object-oriented models (particularly BON)  conformance and consistency checking</p>
  </div>
  <div class="page">
    <p>PVS Specification Language</p>
    <p>... is an enriched typed -calculus.</p>
    <p>If youre comfortable with functional programming, youll be comfortable with PVS.</p>
    <p>Key aspects:  Type constructors for restricting the domain and range</p>
    <p>of operations.  Rich expression language.  Parameterized and hierarchical specification.</p>
  </div>
  <div class="page">
    <p>Types</p>
    <p>Base types: eg., bool, int, nat</p>
    <p>Function types, eg., [int -&gt; [bool -&gt; int]]</p>
    <p>Enumeration types {a,b,c}</p>
    <p>Tuple types [A,B]</p>
    <p>Record types [#a:A, b:B #]</p>
    <p>Mutually recursive data types (ADTs).</p>
    <p>Predicate subtypes:  A: TYPE = {x:B | p(x)}  A: TYPE = (p)</p>
  </div>
  <div class="page">
    <p>More on Types Lots of predefined subtypes, eg.,</p>
    <p>nat: TYPE = { n:int | n &gt;=0 } subrange(n,m:int): TYPE =</p>
    <p>{ i:int | n&lt;=i &amp; i&lt;=m }</p>
    <p>Dependent types allow later types to depend on earlier ones. date:TYPE =</p>
    <p>[# month:subrange(1,12),</p>
    <p>day:subrange(1,num_of_days(month))</p>
    <p>#]</p>
    <p>Predicate subtypes are used to constrain domain/range of operations and to define partial functions.</p>
  </div>
  <div class="page">
    <p>Expressions</p>
    <p>Higher-order logic (&amp;, OR, =&gt;, .., FORALL, EXISTS)</p>
    <p>Conditionals  IF c THEN e1 ELSE e2 ENDIF  COND c1-&gt;e1, c2-&gt;e2, c3-&gt;e3 ENDCOND</p>
    <p>Record overriding  id WITH [(0):=42,(1):=12]</p>
    <p>Recursive functions fac(n:nat): RECURSIVE nat = IF n=0 THEN 1 ELSE n*fac(n-1) ENDIF</p>
    <p>MEASURE n</p>
    <p>Inductive definitions, tables</p>
  </div>
  <div class="page">
    <p>Type Correctness Conditions (TCCs)</p>
    <p>PVS must check that the expressions that you write are well-typed.</p>
    <p>fac(n:nat): RECURSIVE nat =</p>
    <p>IF n=0 THEN 1 ELSE n*fac(n-1) ENDIF</p>
    <p>MEASURE n</p>
    <p>Function fac is well-typed if  n/=0 =&gt; n-1&gt;=0 (the argument is a nat)  n/=0 =&gt; n-1&lt;n (termination). The type checker (M-x tc) generates type correctness</p>
    <p>conditions (TCCs)</p>
  </div>
  <div class="page">
    <p>Example TCCs for factorial</p>
    <p>fac_TCC1: OBLIGATION</p>
    <p>FORALL (n:nat): n/=0 =&gt; n-1 &gt;= 0</p>
    <p>fac_TCC2: OBLIGATION</p>
    <p>FORALL (n:nat): n/=0 =&gt; n-1 &lt; n</p>
  </div>
  <div class="page">
    <p>TCCs (Continued)</p>
    <p>Expressions are only considered to be well-typed after all TCCs have been proven.</p>
    <p>- Type checking in PVS is undecidable (because of predicate subtypes).</p>
    <p>+ The PVS prover will automatically discharge most TCCs that crop up in practice.</p>
    <p>Why arent there more TCCs in preceding, eg., for n*fac(n-1) of type nat?</p>
  </div>
  <div class="page">
    <p>Suppressing TCC Generation</p>
    <p>The type checker knows that JUDGEMENT *(i,j) HAS_TYPE nat JUDGEMENT 1 HAS_TYPE posint</p>
    <p>Judgements are a means for controlling the generation of TCCs.</p>
    <p>Inference is carried out behind-the-scenes. Judgements can be arbitrarily complex and useful.</p>
    <p>JUDGEMENT inverse(f:(bijective?[D,R])) HAS_TYPE (bijective?[R,D])</p>
    <p>JUDGEMENT union(a:(nonempty?), b:set)</p>
    <p>HAS_TYPE (nonempty?)</p>
  </div>
  <div class="page">
    <p>Theories</p>
    <p>Specifications are built from theories.  Declarations introduce types, variables, constants, formulae, etc.</p>
    <p>div: THEORY % natural division BEGIN posnat: TYPE = { n:nat | n&gt;0 } a: VAR nat; b: VAR posnat below(b): TYPE = { n:nat | n&lt;b } div(a,b): [ nat, below(b) ] % tuple</p>
    <p>divchar: AXIOM LET (q,r) = div(a,b) IN a=q*b+r</p>
    <p>END div</p>
  </div>
  <div class="page">
    <p>Theories (II)</p>
    <p>Theories may be parametric in types, constants, and functions.</p>
    <p>wf_induction[T:TYPE,&lt;:(well_founded?[T])]: THEORY</p>
    <p>Theories are hierarchical and can import others. IMPORTING wf_induction[nat, &lt;]</p>
    <p>The built-in prelude and loadable libraries provide standard specs and proven facts for a large number of theories.</p>
  </div>
  <div class="page">
    <p>Example: Division Algorithm</p>
    <p>euclid: THEORY BEGIN div(a:nat, b:nat): RECURSIVE [nat,below(b)] = IF a&lt;b THEN (0,a) ELSE LET (q,r)=div(a-b,b) IN (q+1,r) ENDIF MEASURE a</p>
    <p>END euclid</p>
    <p>Type checking (M-x tcp) yields two TCCs % proved - complete</p>
    <p>div_TCC1: OBLIGATION FORALL (a,b:nat)</p>
    <p>a&gt;=b IMPLIES a-b&gt;=0;</p>
    <p>% unfinished</p>
    <p>div_TCC2: OBLIGATION FORALL (a,b:nat)</p>
    <p>a&gt;=b IMPLIES a-b&lt;a;</p>
  </div>
  <div class="page">
    <p>Division Algorithm (Corrected)</p>
    <p>euclid: THEORY BEGIN div(a:nat, b:posnat): RECURSIVE [nat,below(b)] = IF a&lt;b THEN (0,a) ELSE LET (q,r)=div(a-b,b) IN (q+1,r) ENDIF MEASURE a</p>
    <p>END euclid</p>
    <p>Type checking yields 2 TCCs, 2 proved, 0 unproved</p>
    <p>which does not necessarily mean div is correct!</p>
  </div>
  <div class="page">
    <p>Division Alternative Specification</p>
    <p>div: THEORY BEGIN a: VAR nat; b: VAR posnat; q: VAR nat rem(a,b,q): TYPE = { r:below(b) | a=q*b+r }</p>
    <p>div(a,b): RECURSIVE [# q:nat, r: rem(a,b,q) #] = IF a&lt;b THEN (# q:=0, r:=a #)</p>
    <p>ELSE LET rec=div(a-b,b) IN (# q:=recq+1, r:=recr #)</p>
    <p>ENDIF MEASURE a</p>
    <p>END div</p>
  </div>
  <div class="page">
    <p>Division TCCs</p>
    <p>div_TCC1: OBLIGATION</p>
    <p>FORALL (a,b): a&lt;b IMPLIES a&lt;b AND a=a</p>
    <p>div_TCC2: OBLIGATION</p>
    <p>FORALL (a,b): a&gt;=b IMPLIES a-b &gt;= 0</p>
    <p>div_TCC3: OBLIGATION</p>
    <p>FORALL (a,b): a&gt;=b IMPLIES a-b&lt;a</p>
    <p>All TCCs are proved automatically by the typechecker.</p>
  </div>
  <div class="page">
    <p>Animation</p>
    <p>Instead of doing full verification, functions can be validated in PVS via execution:  M-x pvs-ground-evaluator</p>
    <p>&lt;GndEval&gt; div(234565123,23123543)</p>
    <p>; cpu time (total) 0 msec user, 0 msec system</p>
    <p>==&gt;</p>
    <p>(# q:=101, r:= 10167280 #)</p>
    <p>Question: is this useful in metamodel validation?</p>
  </div>
  <div class="page">
    <p>Design Elements in the PVS Prover</p>
    <p>Heuristic automation for obvious cases.  Leave the human free to concentrate on and direct steps</p>
    <p>that require real insight.</p>
    <p>Sequent calculus presentation {-1} A {-2} B [-3] C |----------------[1] S {2} T</p>
    <p>Intuitive interpretation: A &amp; B &amp; C =&gt; S OR T  PVS maintains proof tree of sequents.</p>
  </div>
  <div class="page">
    <p>Interaction</p>
    <p>Basic tactics exist to manipulate these sequents.  Propositional rules</p>
    <p>(flatten), (split), (lift-if)  Quantifier rules</p>
    <p>(skolem), (inst)  Tactic language (try), (then), (repeat) for</p>
    <p>defining higher-level proof strategies. (defstep prop ()</p>
    <p>(try (flatten) (prop) (try (split) (prop) (skip))) ...)</p>
  </div>
  <div class="page">
    <p>Automation</p>
    <p>Automate (almost) everything that is decidable!  Propositional calculus (prop), (bddsimp)  Equality reasoning with uninterpreted function symbols x=y &amp; f(f(f(x))) = f(x) =&gt; f(f(f(f(f(y))))) = f(x)</p>
    <p>Model checking (model-check)  Automated instantiation and skolemization (skosimp)  Workhorse: (grind)</p>
    <p>combination of simplifications, rewriting, propositional reasoning, decision procedures, quantifier reasoning.</p>
    <p>Induction strategies.</p>
  </div>
  <div class="page">
    <p>Prover Infrastructure</p>
    <p>Browsing facilities locate and display definitions and find formulae that reference a name.</p>
    <p>Proof replay, stepping, editing.  Graphical display of proof trees.  Lemmas can be proved in any order.  Introduce/modify lemmas on the fly.  Proof chain analysis keeps you honest!</p>
  </div>
  <div class="page">
    <p>Metamodelling</p>
    <p>A modelling language (eg., BON, UML, OCL) consists of  a notation (syntax and presentation style)  a metamodel: well-formedness constraints</p>
    <p>A metamodel captures the rules that good (wellformed) models in the language must obey.</p>
    <p>Examples:  Associations are directed between from a class or cluster to a</p>
    <p>class or cluster.</p>
    <p>Classes cannot inherit from themselves.</p>
  </div>
  <div class="page">
    <p>Metamodelling</p>
    <p>Distinction between well-formedness rules (semantic/contextual analysis) and syntactic rules (grammar/tokens) is fuzzy.  2uworks.org RFP for UML 2.0 includes both abstract</p>
    <p>syntax and contextual analysis rules in metamodel.</p>
    <p>If a metamodel is viewed as a specification to be given to tool builders, then this is not unreasonable.  ...but it can make your metamodel much larger and</p>
    <p>thus in need of better structuring mechanisms.</p>
  </div>
  <div class="page">
    <p>Metamodelling with PVS</p>
    <p>Using a tool like PVS to express a metamodel has a number of benefits:  Machine-checkable syntax.  Type checker.  Prover can be used to validate metamodel.  Ground evaluator can be used for testing.  Built-in theories can simplify the process of</p>
    <p>expressing the metamodel.</p>
    <p>But metamodels are usually expressed in OO languages ... and PVS is not OO!</p>
  </div>
  <div class="page">
    <p>Typical Metamodel for BON</p>
    <p>invariant</p>
    <p>disjoint_clusters;</p>
    <p>unique_abstraction_names; no_bidir_agg; objects_typed; parameters_named;</p>
    <p>ABSTRACTIONSRELATIONSHIPS</p>
    <p>abs:SET[..]labels_unique;</p>
    <p>covariant(f1,f2:FEATURE):BOOLEAN closure:SET[INHERITANCE]</p>
    <p>inh_wo_cycles;</p>
    <p>rels: SET[RELATIONSHIP] NONE</p>
    <p>MODEL</p>
    <p>unique_root_class; single_inst_of_root;</p>
    <p>primitives model_covariance;</p>
  </div>
  <div class="page">
    <p>Abstractions Cluster</p>
    <p>contains+:SET[ABSTRACTION]</p>
    <p>contains+:SET[ABSTRACTION]class:CLASS</p>
    <p>contains+: SET[ABSTRACTION]</p>
    <p>invariant invariant</p>
    <p>contents:SET[..]</p>
    <p>DYNAMIC_ABSTRACTION*</p>
    <p>CLUSTER+</p>
    <p>OBJECT+ OBJECT_CLUSTER+</p>
    <p>ABSTRACTION*</p>
    <p>invariant source_is_current</p>
    <p>STATIC_ABSTRACTION* contents:SET[..]</p>
    <p>rels++:SET[MESSAGE]</p>
    <p>contains*:SET[ABSTRACTION] rels: SET[RELATIONSHIP]</p>
    <p>rels++:SET[STATIC_RELATIONSHIP]</p>
    <p>no_self_containment no_self_containment</p>
    <p>FEATURESclient_features, features: SET[..]</p>
    <p>add_client_features; calls_are_queries; no_name_clashes; is_deferred_class; deferred /= root;</p>
    <p>deferred /= effective; valid_class_inv;</p>
    <p>feature_unique_names; valid_static_rels;</p>
    <p>invariant all_names:SET[STRING] redefined:SET[FEATURE]</p>
    <p>external, root : BOOLEAN deferred, effective, persistent, super(f:FEATURE):FEATURE parents: SET[CLASS] rename_class renamings:SET[RENAMING] calls_in_inv:SET[CALL]</p>
    <p>ASSERTION invariant: DOUBLE_STATE_ contains+:SET[ABSTRACTION]</p>
    <p>valid_pre_calls;</p>
    <p>CLASS+</p>
    <p>valid_post_calls; valid_frames;</p>
    <p>inv_consistency; contract_consistency;</p>
  </div>
  <div class="page">
    <p>Relationships Cluster</p>
    <p>STATIC_RELATIONSHIP*</p>
    <p>CLIENT_SUPPLIER*</p>
    <p>label: STRINGinvariant source /= target</p>
    <p>invariant source /= target</p>
    <p>source++, target++: STATIC_ABSTRACTION source++, target++: DYNAMIC_ABSTRACTION</p>
    <p>RELATIONSHIP*</p>
    <p>source, target: ABSTRACTION</p>
    <p>MESSAGE+</p>
    <p>INHERITANCE+</p>
    <p>AGGREGATION+ ASSOCIATION+</p>
  </div>
  <div class="page">
    <p>Expressing the BON Metamodel in PVS</p>
    <p>Easiest approach: map the BON specification of the metamodel directly into PVS.</p>
    <p>Key questions to answer:  How to represent classes and objects in PVS?  How to represent client-supplier and inheritance?  How to represent the class invariants?  How to represent clusters?  How to represent features of classes?</p>
    <p>Answering such questions will let us represent not only the BON metamodel in PVS, but BON models as well!</p>
    <p>Question: how does an instantiated metamodel compare with a model in PVS for reasoning?</p>
  </div>
  <div class="page">
    <p>Basic Approach</p>
    <p>Specify class hierarchies as PVS types and subtypes. ABSTRACTION: TYPE+ STATICABS, DYNABS: TYPE+ FROM ABSTRACTION CLUSTER, CLASS: TYPE+ FROM STATICABS</p>
    <p>OBJECT, OBJECTCLUSTER: TYPE+ FROM DYNABS</p>
    <p>FEATURE: TYPE+ QUERY, COMMAND: TYPE+ FROM FEATURE</p>
    <p>Features of BON classes become functions:</p>
    <p>deferred_class: [ CLASS -&gt; bool]</p>
    <p>class_features: [ CLASS -&gt; set[FEATURE] ]</p>
    <p>feature_frame: [ FEATURE -&gt; set[QUERY] ]</p>
  </div>
  <div class="page">
    <p>What is a BON Model?</p>
    <p>A BON model, in PVS, is just a record.</p>
    <p>MODEL: TYPE+ =</p>
    <p>[# abst:set[ABS], rels: set[REL] #]</p>
    <p>Note that all abstractions (static and dynamic) are combined into one set.</p>
    <p>Projections from this to produce different views.</p>
  </div>
  <div class="page">
    <p>Clusters and Invariants</p>
    <p>Note that the BON metamodel has a number of clusters (Abstractions and Relationships).</p>
    <p>These are mapped to PVS theories.  Is there any need to parameterize these theories?</p>
    <p>What about the invariant clauses of classes in the metamodel?</p>
    <p>These can be mapped to PVS axioms.  In general, wed like to avoid axioms when possible since they</p>
    <p>can introduce inconsistency.</p>
    <p>Use definitions if possible.</p>
  </div>
  <div class="page">
    <p>Example Axioms</p>
    <p>% Inheritance relations cannot be from an abstraction to itself.</p>
    <p>% A class cannot be its own parent.</p>
    <p>inh_ax: AXIOM</p>
    <p>(FORALL (i:INH): not (inh_source(i) = inh_target(i)))</p>
    <p>% Clusters cannot contain themselves.</p>
    <p>no_nesting_of_clusters: AXIOM</p>
    <p>(FORALL (cl:CLUSTER) : not member(cl,cluster_contents(cl)))</p>
    <p>% A deferred feature cannot also be effective.</p>
    <p>deferred_not_effective: AXIOM</p>
    <p>(FORALL (c:CLASS): (FORALL (f:FEATURE):</p>
    <p>(NOT (deferred_feature(c,f) IFF effective_feature(c,f)))))</p>
  </div>
  <div class="page">
    <p>Example Axioms (II)</p>
    <p>% All feature calls that appear in a precondition obey the</p>
    <p>% information hiding model.</p>
    <p>valid_precondition_calls: AXIOM</p>
    <p>(FORALL (c:CLASS):</p>
    <p>(FORALL (f:FEATURE):</p>
    <p>member(f, class_features(c)) IMPLIES</p>
    <p>(FORALL (call:CALL): member(call, calls_in_pre(f))</p>
    <p>IMPLIES</p>
    <p>QUERY_pred(f(call)) AND</p>
    <p>call_isvalid(f(call)))))</p>
  </div>
  <div class="page">
    <p>Type and Conformance Checking</p>
    <p>Running the type checker over the existing metamodel theories generates approximately 7 TCCs that are automatically proved.</p>
    <p>Earlier versions did not type check and revealed errors and omissions.</p>
    <p>What can we now do with the metamodel?  Conformance checking  Extension to view consistency checking.</p>
  </div>
  <div class="page">
    <p>Conformance Checking</p>
    <p>Does a BON model satisfy the metamodel constraints?  In practice this is implemented via a constrained GUI and by</p>
    <p>suitable algorithms (eg., no cycles in inheritance graph -&gt; cycle detection algorithm).</p>
    <p>In practice and in general it cannot be implemented fully automatically.</p>
    <p>Approach 1: express a BON model in PVS and check that it satisfies the axioms.  If it does not, counterexamples will be generated, though</p>
    <p>sometimes they will be difficult to interpret.</p>
    <p>Approach 2: express that a BON model cannot exist, and show that fails to satisfy an axiom. (Often easier.)</p>
  </div>
  <div class="page">
    <p>Example</p>
    <p>invariant c.m</p>
    <p>B</p>
    <p>A</p>
    <p>?</p>
    <p>!</p>
    <p>a.h and a.b.w</p>
    <p>.....</p>
    <p>C</p>
    <p>NONE</p>
    <p>a</p>
    <p>b</p>
    <p>c</p>
    <p>m:BOOLEAN</p>
    <p>w:BOOLEAN C</p>
    <p>A</p>
    <p>h:BOOLEAN</p>
  </div>
  <div class="page">
    <p>PVS Theory info2: THEORY</p>
    <p>BEGIN</p>
    <p>IMPORTING metamodel</p>
    <p>a, b, c: VAR CLASS</p>
    <p>h, w, m: VAR QUERY</p>
    <p>ea, eb, ec: VAR ENTITY</p>
    <p>xm: VAR MODEL</p>
    <p>call1, call2, call_anon: VAR DIRECT_CALL</p>
    <p>call3: VAR CHAINED_CALL</p>
    <p>test_info_hiding: CONJECTURE</p>
    <p>(NOT (EXISTS (xm:MODEL): EXISTS (a,b,c: CLASS):</p>
    <p>EXISTS (h,w,m: QUERY): (EXISTS (ea,eb,ec:ENTITY):</p>
    <p>EXISTS (call1, call2, call_anon: DIRECT_CALL):</p>
    <p>EXISTS (call3: CHAINED_CALL):</p>
    <p>member(c, accessors(h)) AND member(a,accessors(w)) AND</p>
    <p>empty?(accessors(m)) AND call_entity(call2)=ec AND</p>
    <p>call_entity(call2) = ec AND call_entity(call_anon)=eb AND</p>
    <p>call_entity(call3) = ea AND member(call1,calls_in_pre(m)) AND</p>
    <p>member(call3, calls_in_pre(m)) AND member(call_anon,calls_in_pre(m)) AND</p>
    <p>member(call2, calls_in_inv(b)))))</p>
    <p>END info2</p>
  </div>
  <div class="page">
    <p>View Consistency</p>
    <p>BON provides two views of systems:  static (architectural) view, represented using class diagrams and</p>
    <p>contracts.</p>
    <p>dynamic (message-passing) view, represented using collaboration diagrams</p>
    <p>The views may be constructed separately and thus may be inconsistent.</p>
    <p>Examples:  object in dynamic view has no class in static view  message in dynamic view is not enabled (precondition of routine</p>
    <p>in static view is not true)</p>
  </div>
  <div class="page">
    <p>BON Dynamic Diagrams</p>
  </div>
  <div class="page">
    <p>Extension of Metamodel</p>
    <p>In general, checking view consistency will require theorem proving support.  Key check: prove that message i in the dynamic view has its</p>
    <p>precondition enabled by preceding messages 1,..,i-1</p>
    <p>Effectively we want to show that for a collaboration diagram cd with sequence of calls cd.calls,</p>
    <p>i:2,..,cd.calls.length  cd.occurs (init; cd.calls(1).spec ; .. ; cd.calls(i-1).spec</p>
    <p>cd.calls(i).pre)</p>
  </div>
  <div class="page">
    <p>Expression in PVS</p>
    <p>... is non-trivial.  Need the following:</p>
    <p>formalization of specifications (pre- and poststate) as new PVS type SPECTYPE</p>
    <p>formalization of sequencing ;  formalization of specification state</p>
    <p>Add extra functions to the metamodel:  projection of static and dynamic views  sequence of routine calls in dynamic view</p>
  </div>
  <div class="page">
    <p>Specifications and Routines</p>
    <p>Each routine is formalized as a SPECTYPE.</p>
    <p>SPECTYPE: TYPE+ =</p>
    <p>[# old_state: set[ENTITY], new_state: set[ENTITY],</p>
    <p>value: [ set[ENTITY], set[ENTITY] -&gt; bool ] #]</p>
    <p>Given a routine and its pre/poststate we can produce a SPECTYPE using function</p>
    <p>spec: [ ROUTINE, set[ENTITY], set[ENTITY] -&gt; SPECTYPE ]</p>
    <p>Axiom needed to combine pre/postcondition of the routine into a single predicate.</p>
  </div>
  <div class="page">
    <p>Additional Infrastructure</p>
    <p>Two functions are needed:  seqspecs: the sequential composition of two SPECTYPEs  seqspecsn: lifted version of seqspecs to finite sequences</p>
    <p>seqspecs(s1,s2:SPECTYPE): SPECTYPE =</p>
    <p>(# old_state := old_state(s1),</p>
    <p>new_state := new_state(s2),</p>
    <p>value := (LAMBDA (o:{p1:set[ENTITY] | p1=old_state(s1)}),</p>
    <p>(n:{p2:set[ENTITY] | p2=new_state(s2)}):</p>
    <p>(EXISTS (i: set[ENTITY]):</p>
    <p>value(s1)(o,i) AND value(s2)(i,n)))</p>
    <p>#)</p>
  </div>
  <div class="page">
    <p>View Consistency Axiom</p>
    <p>views_consistent_ax2: AXIOM</p>
    <p>(FORALL (mod1:MODEL): FORALL (c:CLASS):</p>
    <p>(FORALL (i:{j:nat|0&lt;j &amp; j&lt;length(calls_model(mod1))}):</p>
    <p>LET</p>
    <p>loc_spec:SPECTYPE =</p>
    <p>seq(spec(init(mod1)(c),oldstate(init(mod1)(c)),</p>
    <p>newstate(init(mod1)(c)),</p>
    <p>(seqspecsn(convert(sequence_model(mod1)^(0,i-1))))</p>
    <p>IN</p>
    <p>(value(loc_spec)(old_state(loc_spec),new_state(loc_spec)) IMPLIES</p>
    <p>feature_pre(calls_model(mod1)(i),</p>
    <p>oldstate(calls_model(mod1)(i), object_class(msg_target(sequence_model(mod1)(i))))))))</p>
  </div>
  <div class="page">
    <p>Just Off the Press...</p>
    <p>... there is a small example of a consistency checking attempt in PVS in</p>
    <p>R. Paige, J. Ostroff, P. Brooke, Theorem Proving Support for View Consistency Checking, submitted to LObjet, July 2002. (Draft available from the authors.)</p>
  </div>
</Presentation>
