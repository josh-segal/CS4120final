<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Non-intrusive Performance Profiling for</p>
    <p>Entire Software Stacks based on</p>
    <p>The Flow Reconstruction Principle</p>
    <p>Xu Zhao, Kirk Rodrigues, Yu Luo, Ding Yuan, Michael Stumm</p>
  </div>
  <div class="page">
    <p>Motivations</p>
    <p>Debugging distributed system stacks is difficult</p>
    <p>Existing tools are limited</p>
    <p>Intrusive: manually built-in domain knowledge</p>
    <p>Machine learning on logs: unable to reconstruct execution flow</p>
    <p>Static analysis [Zhao OSDI14]: cannot cross different software components</p>
    <p>Use programmers intuition in postmortem execution analysis</p>
  </div>
  <div class="page">
    <p>The Flow Reconstruction Principle</p>
    <p>Programmers log sufficient information so that they can reconstruct</p>
    <p>the execution flow in distributed stacks</p>
    <p>Three rules</p>
    <p>Log events at critical points in the control path</p>
    <p>Log object identifiers to differentiate concurrent runs</p>
    <p>Log sufficient identifiers to unambiguously identify an object</p>
    <p>Thread1</p>
    <p>Thread2</p>
  </div>
  <div class="page">
    <p>The Flow Reconstruction Principle</p>
    <p>Programmers log sufficient information so that they can reconstruct</p>
    <p>the execution flow in distributed stacks</p>
    <p>Three rules</p>
    <p>Log events at critical points in the control path</p>
    <p>Log object identifiers to differentiate concurrent runs</p>
    <p>Log sufficient identifiers to unambiguously identify an object</p>
    <p>Thread1</p>
    <p>Thread2</p>
  </div>
  <div class="page">
    <p>The Flow Reconstruction Principle</p>
    <p>Programmers log sufficient information so that they can reconstruct</p>
    <p>the execution flow in distributed stacks</p>
    <p>Three rules</p>
    <p>Log events at critical points in the control path</p>
    <p>Log object identifiers to differentiate concurrent runs</p>
    <p>Log sufficient identifiers to unambiguously identify an object</p>
    <p>Thread1</p>
    <p>Thread2</p>
  </div>
  <div class="page">
    <p>The Flow Reconstruction Principle</p>
    <p>Programmers log sufficient information so that they can reconstruct</p>
    <p>the execution flow in distributed stacks</p>
    <p>Three rules</p>
    <p>Log events at critical points in the control path</p>
    <p>Log object identifiers to differentiate concurrent runs</p>
    <p>Log sufficient identifiers to unambiguously identify an object</p>
    <p>Thread1</p>
    <p>Thread2</p>
  </div>
  <div class="page">
    <p>Stitch: A Non-intrusive Profiler for Entire Server Stacks</p>
    <p>Works without any built-in domain knowledge</p>
    <p>Purely based on IDs, throws away constant text</p>
    <p>Reconstructs objects, infers their lifetimes and hierarchies</p>
    <p>Node 1 2016-05-02 23:23:00,762 INFO</p>
    <p>org.apache.hadoop.yarn.server.resour</p>
    <p>cemanager.ResourceManager:</p>
    <p>registered UNIX signal handlers for</p>
    <p>[TERM, HUP, INT]</p>
    <p>org.apache.hadoop.conf.Configuration:</p>
    <p>found resource core-site.xml at</p>
    <p>file:/home/dev/hadoop/hadoop</p>
    <p>Node 2 2016-05-02 23:27:00,792 INFO</p>
    <p>org.apache.hadoop.yarn.server.resour</p>
    <p>cemanager.ResourceManager:</p>
    <p>registered UNIX signal handlers for</p>
    <p>[TERM, HUP, INT]</p>
    <p>org.apache.hadoop.conf.Configuration:</p>
    <p>found resource core-site.xml at</p>
    <p>file:/home/dev/hadoop/hadoop</p>
    <p>Centralized Server</p>
    <p>Visualization</p>
    <p>User_Alice</p>
    <p>Query 1</p>
    <p>Query 2</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Real world example</p>
    <p>Design of Stitch</p>
    <p>User study and correctness evaluation</p>
  </div>
  <div class="page">
    <p>Real World Example</p>
    <p>User study on 14 programmers</p>
    <p>We reproduced a real world performance anomaly: YARN-4610</p>
    <p>Symptom: user Alice reports her Hive query takes longer than expected</p>
    <p>Separate programmers into 2 groups: debug using raw log or with Stitch</p>
    <p>45 mins time limit</p>
  </div>
  <div class="page">
    <p>Debugging with Raw Log</p>
    <p>Only 2 users using raw log can diagnose within the time limit</p>
    <p>Reading each log message is infeasible: over 5,000 lines of logs</p>
    <p>Users take two approaches: bottom-up and top-down</p>
    <p>Bottom-up results in a wild goose chase</p>
    <p>$ grep ERROR\|WARN R logs/</p>
    <p>./node0/userlogs/application_1462245782384_0024/container_1462245782384_0024_01</p>
    <p>_000576/syslog:2016-05-02 23:46:37,010 ERROR [Thread-50]</p>
    <p>org.apache.hadoop.mapreduce.v2.app.rm.RMContainerAllocator: Could not</p>
    <p>deallocate container for task attemptId attempt_1462245782384_0024_r_000001_1</p>
    <p>... [707 more]</p>
  </div>
  <div class="page">
    <p>Debugging with Raw Log</p>
    <p>Only 2 users using raw log can diagnose within the time limit</p>
    <p>Reading each log message is infeasible: over 5,000 lines of logs</p>
    <p>Users take two approaches: bottom-up and top-down</p>
    <p>Bottom-up results in a wild goose chase</p>
    <p>Top-down gets closer, but still cannot diagnose failure within time limit</p>
    <p>Determine slowest map task</p>
  </div>
  <div class="page">
    <p>Debugging with Stitch</p>
    <p>All 7 Stitch users succeeded, spending 13 mins on average</p>
    <p>Stitch speeds-up debugging time by a factor of 3.5</p>
    <p>Demo</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Real world example</p>
    <p>Design of Stitch</p>
    <p>User study and correctness evaluation</p>
  </div>
  <div class="page">
    <p>Client: Log Parsing</p>
    <p>Detect log printing processes and log files</p>
    <p>Periodically read /proc</p>
    <p>Log parsing: separate dynamic and constant parts of the raw log</p>
    <p>Extract string constants from binaries, match against the log</p>
    <p>Filter non-identifiers using a blacklist (memsize, ms, progress, etc.)</p>
    <p>// Code that prints this msg:</p>
    <p>l &lt;&lt; &quot;MongoDB starting : pid=&quot; &lt;&lt; pid &lt;&lt; &quot; port=&quot; &lt;&lt;</p>
    <p>serverGlobalParams.port &lt;&lt; &quot; dbpath=&quot; &lt;&lt; storageGlobalParams.dbpath;</p>
    <p>Parsed Log</p>
    <p>Timestamp Identifier Type</p>
    <p>/var/lib/mongodb filePath</p>
  </div>
  <div class="page">
    <p>Server: Identifier Relations</p>
    <p>1:1 relation</p>
    <p>Can be used interchangeably</p>
    <p>1:n relation</p>
    <p>Hierarchical relationship</p>
    <p>m:n relation</p>
    <p>Combination is required to unambiguously identify an object</p>
    <p>Host1 IP 192.168.0.100</p>
    <p>Process 42 Thread 1</p>
    <p>Thread 2Process 43</p>
    <p>Query 20161102_0001</p>
    <p>User Bob</p>
    <p>Query 20161102_0002</p>
  </div>
  <div class="page">
    <p>m:n Relation</p>
    <p>Example: Host, Process and Thread</p>
    <p>Not every combination is meaningful</p>
    <p>Meaningful ones: {Host}, {Host, Process}, {Host, Process, Thread}</p>
    <p>Meaningless combination: {Host, Thread}</p>
    <p>Developers only log the meaningful combinations</p>
    <p>Developers will never log {Host, Thread} without Process 16</p>
    <p>Host1</p>
    <p>Host2 Process2</p>
    <p>Process1 Thread1</p>
    <p>Thread2</p>
  </div>
  <div class="page">
    <p>Lifetime and Hierarchy</p>
    <p>Lifetime of objects inferred from event timestamps</p>
    <p>Hierarchy is inferred from 1:n relation</p>
    <p>User_Bob</p>
    <p>Query 20161102_0001</p>
    <p>Query 20161102_0002</p>
    <p>OBJECT EVENT TIMELINE</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Real world example</p>
    <p>Design of Stitch</p>
    <p>User study and correctness evaluation</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>How much time does Stitch save in debugging?</p>
    <p>How accurate is Stitch in identifying objects?</p>
    <p>Do real-world systems follow the Flow Reconstruction Principle?</p>
  </div>
  <div class="page">
    <p>User Study Evaluation</p>
    <p>14 users work with 3 cases</p>
    <p>Performance debugging  An anomaly caused by a YARN scheduler bug</p>
    <p>Bottleneck identification  Identify slow node in a MapReduce job</p>
    <p>Hierarchy identification  OpenStack components involved in request</p>
    <p>At least 4.6x faster debugging with Stitch 20</p>
  </div>
  <div class="page">
    <p>Correctness Evaluation</p>
    <p>Hive, Spark and OpenStack workload: 200 nodes run for 24 hours</p>
    <p>Production workload: 24-node cluster running for four months</p>
    <p>Together there are 19 software components</p>
    <p>Stitch correctly identifies 96% of all objects in four software stacks 21</p>
    <p>System Objects Object Types Object Accuracy</p>
    <p>Hive 295,042 32 90%</p>
    <p>Spark 192,969 31 94%</p>
    <p>OpenStack 214,882 14 100%</p>
    <p>Production 8,141 24 100%</p>
    <p>Total 711,034 101 96%</p>
  </div>
  <div class="page">
    <p>Limitations</p>
    <p>Stitch does not capture causal relations</p>
    <p>Stitchs efficacy relies on developers following the Flow Reconstruction</p>
    <p>Principle</p>
    <p>Violations of the principle will mislead human debugging</p>
    <p>Stitchs accuracy is sensitive to the quality of identifiers and type-extraction</p>
    <p>Log parsing is a solved problem</p>
    <p>Industrial solutions exist, e.g., Splunk, VMWare LogInsight, LogStash</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>Intrusive tools [Aguilera SOSP03] [Barham OSDI04] [Chanda</p>
    <p>EuroSys07]</p>
    <p>Captures causal relationships</p>
    <p>Built-in domain knowledge</p>
    <p>Static analysis tools [Zhao OSDI14] [Yuan ASPLOS10]</p>
    <p>Captures causal relationships</p>
    <p>Cannot cross layers</p>
    <p>Machine learning solutions [Xu SOSP09] [Nagaraj NSDI12]</p>
    <p>[Yu ASPLOS16]</p>
    <p>Cannot reconstruct execution flow</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>The Flow Reconstruction Principle</p>
    <p>Log events at critical points in the control path</p>
    <p>Log object identifiers to differentiate concurrent runs</p>
    <p>Log sufficient identifiers to unambiguously identify an object</p>
    <p>Node 1 2016-05-02 23:23:00,762 INFO</p>
    <p>org.apache.hadoop.yarn.server.resource</p>
    <p>manager.ResourceManager: registered</p>
    <p>UNIX signal handlers for [TERM, HUP,</p>
    <p>INT]</p>
    <p>org.apache.hadoop.conf.Configuration:</p>
    <p>found resource core-site.xml at</p>
    <p>file:/home/dev/hadoop/hadoop</p>
    <p>org.apache.hadoop.security.Groups:</p>
    <p>clearing userToGroupsMap cache</p>
    <p>org.apache.hadoop.conf.Configuration:</p>
    <p>Node 2 2016-05-02 23:23:00,762 INFO</p>
    <p>org.apache.hadoop.yarn.server.resource</p>
    <p>manager.ResourceManager: registered</p>
    <p>UNIX signal handlers for [TERM, HUP,</p>
    <p>INT]</p>
    <p>org.apache.hadoop.conf.Configuration:</p>
    <p>found resource core-site.xml at</p>
    <p>file:/home/dev/hadoop/hadoop</p>
    <p>org.apache.hadoop.security.Groups:</p>
    <p>clearing userToGroupsMap cache</p>
    <p>org.apache.hadoop.conf.Configuration:</p>
    <p>Stitch</p>
    <p>Stitch: non-intrusive profiler for distributed stacks</p>
    <p>Visualization</p>
    <p>User_Alice</p>
    <p>Query 1</p>
    <p>Query 2</p>
  </div>
  <div class="page">
    <p>Q &amp; A</p>
  </div>
  <div class="page">
    <p>Source of Inaccuracy</p>
    <p>Hive ID: Stage- : violating Flow Reconstruction Principle</p>
    <p>Stage- and Query ID in separate log messages</p>
    <p>Spark ID: inode and HostName - small scale of workload</p>
    <p>inode and HostName are 1:1 instead of m:n</p>
    <p>Appear together in an error log message</p>
  </div>
</Presentation>
