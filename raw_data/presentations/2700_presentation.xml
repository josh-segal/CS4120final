<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>A SYSTEM TO VERIFY NETWORK BEHAVIOR OF KNOWN CRYPTOGRAPHIC CLIENTS</p>
    <p>Andrew Chi, Robert A. Cochran, Marie Nesfield, Michael K. Reiter, Cynthia Sturton</p>
    <p>University of North Carolina at Chapel Hill</p>
  </div>
  <div class="page">
    <p>CLIENT</p>
    <p>INVALID COMMAND ATTACKS INVALID COMMAND</p>
    <p>Client exhibits behavior, as seen by the server, that is inconsistent with the sanctioned client software.</p>
    <p>Forms of Exploit: 1. Maliciously crafted packet 2. Valid packets; illegal sequence</p>
    <p>SERVER</p>
    <p>CLIENT SERVER Constrained attacker (valid commands only)</p>
    <p>Goal: constrain all attackers to this limited behavior.</p>
  </div>
  <div class="page">
    <p>TRANSPORT LAYER SECURITY (TLS) - RFC 5246</p>
    <p>Handshake Protocol  Select cipher, authentication, key exchange</p>
    <p>Record Layer  Provides confidentiality and integrity  Encapsulates other protocols</p>
    <p>Alerts and Heartbeats</p>
    <p>Application (HTTP, IMAP, etc.)</p>
    <p>Transport Layer Security (TLS)</p>
    <p>TCP</p>
    <p>IP</p>
    <p>From Jan 2014 to Aug 2016, most of the server-side vulnerabilities in OpenSSL involved invalid commands (23 of 37 required tampering with client behavior).</p>
  </div>
  <div class="page">
    <p>HEARTBLEED (CVE-2014-0160)</p>
    <p>Implementation bug in OpenSSL TLS Heartbeat handler Nearly all OpenSSL applications vulnerable for 2 years 17% (~500,000) of the Internets web servers</p>
  </div>
  <div class="page">
    <p>HEARTBLEED</p>
    <p>xkcd.com/1354 5</p>
  </div>
  <div class="page">
    <p>HOW CAN WE DEFEND THE SERVER?</p>
    <p>Behavioral verification: permit authorized client softwares behavior only  Eliminates entire classes of attack without knowing about them  Usually requires client modification or sending of client inputs</p>
    <p>Goal: rapid detection of exploit attempts 6</p>
  </div>
  <div class="page">
    <p>BEHAVIORAL VERIFICATION OF A CLIENT</p>
    <p>General case: undecidable  Specific instances: may be practical  E.g., detect cheating in online games (Cochran &amp; Reiter 2013)</p>
    <p>Given: * client program P * network messages M</p>
    <p>Not given: * client-side inputs</p>
    <p>Question: Could P have produced M?</p>
    <p>Permit client to continue</p>
    <p>Disconnect client, alert admin, etc.</p>
    <p>Yes</p>
    <p>No</p>
  </div>
  <div class="page">
    <p>SYMBOLIC EXECUTION</p>
    <p>x = sym_input(); y = sym_input(); testme(x,y);</p>
    <p>void testme(int x, int y) {</p>
    <p>int z = 2*y; if (z == x) {</p>
    <p>if (x &gt; y+10) printf(lol);</p>
    <p>} }</p>
    <p>x &gt; y+10</p>
    <p>true</p>
    <p>truefalse</p>
    <p>false</p>
    <p>!,# unconstrained</p>
    <p>!  2#</p>
    <p>! = 2#  (!  # + 10) ! = 2# (! &gt; # + 10)</p>
    <p>lol</p>
    <p>x=30 y=15</p>
    <p>Apply SAT solver to obtain concrete test case.</p>
  </div>
  <div class="page">
    <p>USING SYMBOLIC EXECUTION TO DETECT INVALID COMMAND ATTACKS</p>
    <p>x = sym_input(); y = sym_input(); testme(x,y);</p>
    <p>void testme(int x, int y) {</p>
    <p>int z = 2*y; if (z == x) {</p>
    <p>if (x &gt; y+10) send(z);</p>
    <p>} }</p>
    <p>x &gt; y+10</p>
    <p>true</p>
    <p>truefalse</p>
    <p>false</p>
    <p>!,# unconstrained</p>
    <p>!  2#</p>
    <p>! = 2# (!  # + 10) ! = 2#(! &gt; # + 10)Can this program produce</p>
    <p>. = 42? Yes (! = 42,# = 21)  . = 41? No (. = 2# so it must be even)</p>
    <p>2# = 42</p>
    <p>z</p>
  </div>
  <div class="page">
    <p>CHALLENGES IN VALIDATING CLIENTS IN CRYPTOGRAPHIC PROTOCOLS (1)</p>
    <p>Symbolic execution generally accommodates program variables with unknown values, but their sizes must be known</p>
    <p>Crypto protocols that hide sizes of client-side inputs (e.g., using padding) dramatically grow the search space</p>
    <p>Solution: Explore inputs of different sizes in parallel</p>
    <p>Plaintext Padding</p>
    <p>Plaintext Padding</p>
    <p>or</p>
  </div>
  <div class="page">
    <p>CHALLENGES IN VALIDATING CLIENTS IN CRYPTOGRAPHIC PROTOCOLS (2)  Some functions are too costly to execute on symbolic inputs  Example: cryptographic functions  AES block cipher is a very complex formula of key and plaintext</p>
    <p>Solution:  Give the verifier the session key  Defer executing prohibitive functions until inputs can be inferred  Any functions not executed then amount to assumptions</p>
    <p>AES</p>
    <p>Key</p>
    <p>CiphertextPlaintext</p>
  </div>
  <div class="page">
    <p>MULTIPASS SYMBOLIC EXECUTION</p>
    <p>Input: user specifies prohibitive functions, using an API  Algorithm:</p>
  </div>
  <div class="page">
    <p>RNG</p>
    <p>RNG</p>
    <p>STDIN</p>
    <p>iv AES</p>
    <p>ECDH A</p>
    <p>GHASH</p>
    <p>a k</p>
    <p>p</p>
    <p>s c t t</p>
    <p>A</p>
    <p>c</p>
    <p>iv</p>
    <p>Unobserved Inputs (symbolic)</p>
    <p>Observed Outputs (concrete)</p>
    <p>EXAMPLE: TLS CLIENT VALIDATION</p>
    <p>x</p>
    <p>x</p>
    <p>Symbolic (unknown) value</p>
    <p>Concrete (known) value</p>
    <p>We assume knowledge of AES symmetric key, k, which is part of server state. 13</p>
    <p>Message to verify</p>
  </div>
  <div class="page">
    <p>RNG</p>
    <p>RNG</p>
    <p>STDIN</p>
    <p>iv AES</p>
    <p>ECDH A</p>
    <p>GHASH</p>
    <p>a k</p>
    <p>p</p>
    <p>s c t t</p>
    <p>A</p>
    <p>c</p>
    <p>iv</p>
    <p>Unobserved Inputs (symbolic)</p>
    <p>Observed Outputs (concrete)</p>
    <p>TLS CLIENT VALIDATION PASS 1(A): SYMBOLIC EXECUTION</p>
    <p>x</p>
    <p>x</p>
    <p>Symbolic (unknown) value</p>
    <p>Concrete (known) value</p>
  </div>
  <div class="page">
    <p>RNG</p>
    <p>RNG</p>
    <p>STDIN</p>
    <p>iv AES</p>
    <p>ECDH A</p>
    <p>GHASH</p>
    <p>a k</p>
    <p>p</p>
    <p>s c t t</p>
    <p>A</p>
    <p>c</p>
    <p>iv</p>
    <p>Unobserved Inputs (symbolic)</p>
    <p>Observed Outputs (concrete)</p>
    <p>TLS CLIENT VALIDATION PASS 1(B): CONCRETIZATION</p>
    <p>x</p>
    <p>x</p>
    <p>Symbolic (unknown) value</p>
    <p>Concrete (known) value</p>
  </div>
  <div class="page">
    <p>RNG</p>
    <p>RNG</p>
    <p>STDIN</p>
    <p>iv AES</p>
    <p>ECDH A</p>
    <p>GHASH</p>
    <p>a k</p>
    <p>p</p>
    <p>s c t t</p>
    <p>A</p>
    <p>c</p>
    <p>iv</p>
    <p>Unobserved Inputs (symbolic)</p>
    <p>Observed Outputs (concrete)</p>
    <p>TLS CLIENT VALIDATION PASS 2(A): SYMBOLIC EXECUTION</p>
    <p>x</p>
    <p>x</p>
    <p>Symbolic (unknown) value</p>
    <p>Concrete (known) value</p>
  </div>
  <div class="page">
    <p>RNG</p>
    <p>RNG</p>
    <p>STDIN</p>
    <p>iv AES</p>
    <p>ECDH A</p>
    <p>GHASH</p>
    <p>a k</p>
    <p>p</p>
    <p>s c t t</p>
    <p>A</p>
    <p>c</p>
    <p>iv</p>
    <p>Unobserved Inputs (symbolic)</p>
    <p>Observed Outputs (concrete)</p>
    <p>TLS CLIENT VALIDATION PASS 2(B): CONCRETIZATION</p>
    <p>x</p>
    <p>x</p>
    <p>Symbolic (unknown) value</p>
    <p>Concrete (known) value</p>
  </div>
  <div class="page">
    <p>ASSESSMENT: DETECTING HEARTBLEED (WITHOUT LOOKING FOR IT)  Malicious s_client  performs handshake  sends Heartbleed exploit</p>
    <p>Validation  Handshake is verified  No explanation found for</p>
    <p>malicious Heartbeat</p>
    <p>Detection in ~2s 18</p>
  </div>
  <div class="page">
    <p>MEASURING PERFORMANCE</p>
    <p>VERIFIER</p>
    <p>CLIENT SERVER</p>
    <p>MESSAGE QUEUE</p>
    <p>Verification Cost</p>
    <p>Time</p>
    <p>Arrival</p>
    <p>M es</p>
    <p>sa ge</p>
  </div>
  <div class="page">
    <p>PERFORMANCE EVALUATION</p>
    <p>Diamond = mean</p>
    <p>21 TLS 1.2 sessions from 3 min. of Gmail activity</p>
    <p>OpenSSL &amp; BoringSSL command line clients</p>
    <p>Single-core verifier (3.2 GHz)  Cost: 49ms per TLS record  Lag: median 0.85s, max 15s</p>
    <p>NOTE: without server-to-client appdata packets 20</p>
  </div>
  <div class="page">
    <p>OTHER EVALUATION MEASURES  Parallelization / Stress Test  TLS 1.2 + up to 128 bytes of padding (from draft TLS 1.3)  16-thread verifier keeps pace</p>
    <p>Invalid command attack: valid packets, illegal sequence  CVE-2015-0205 client authentication vulnerability  Verifier rejects attack traffic</p>
    <p>Confirm appropriateness of command line client  Unmodified Chrome browser interacting with Apache server  Verified using BoringSSL command line client 21</p>
  </div>
  <div class="page">
    <p>SUMMARY</p>
    <p>Behavioral verification for cryptographic clients  Multipass symbolic execution handles cryptographic functions  Parallelization optimizes search of large state spaces</p>
    <p>Detection of previously unknown client misbehavior  E.g., a Heartbleed exploit with no Heartbleed-specific configuration</p>
    <p>Performance roughly keeps pace with real workload  Behavioral verification on Gmail TLS sessions</p>
  </div>
</Presentation>
