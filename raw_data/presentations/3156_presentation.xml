<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>ByteWeight: Learning to Recognize Func5ons in Binary Code</p>
    <p>Tiffany Bao Jonathan Burket Maverick Woo Rafael Turner David Brumley Carnegie Mellon University</p>
    <p>USENIX Security 14</p>
  </div>
  <div class="page">
    <p>Binary Analysis</p>
    <p>Decompiler Control Flow Integrity</p>
    <p>(CFI)</p>
    <p>Function Information Function 1 Function 3 Function 2</p>
    <p>Binary Reuse</p>
    <p>Malware Analysis  Vulnerability Signature Generation</p>
  </div>
  <div class="page">
    <p>Binary Analysis</p>
    <p>Decompiler Control Flow Integrity</p>
    <p>(CFI) Binary Reuse</p>
    <p>Malware Analysis  Vulnerability Signature Generation</p>
    <p>Function Information Function 1 Function 3 Function 2 Stripped</p>
    <p>Can we automatically and accurately recover function</p>
    <p>information from stripped binaries?</p>
  </div>
  <div class="page">
    <p>#include &lt;stdio.h&gt;! int fac(int x){! if (x == 1) !</p>
    <p>return 1;! else!</p>
    <p>return x * fac(x - 1);! }! ! void main(int argc, char **argv){! printf(&quot;%d&quot;, fac(10));! }!</p>
    <p>Source Code</p>
    <p>Example: GCC</p>
  </div>
  <div class="page">
    <p>O0: Default</p>
    <p>Example: GCC</p>
  </div>
  <div class="page">
    <p>! 0804841c &lt;fac&gt;:! push %ebx! sub $0x18,%esp! mov 0x20(%esp),%ebx! mov $0x1,%eax! cmp $0x1,%ebx! !</p>
    <p>O1: Optimize O2: Optimize Even More</p>
    <p>Example: GCC</p>
  </div>
  <div class="page">
    <p>Current Industry Solu5on: IDA</p>
    <p>#include&lt;stdio.h&gt;! #include&lt;string.h&gt;! #define MAX 128! !</p>
    <p>void sum(char a[MAX], char b[MAX]){! printf(&quot;%s + %s = %d\n&quot;, a, b, atoi(a) + atoi(b));! }! ! void sub(char a[MAX], char b[MAX]){! printf(&quot;%s - %s = %d\n&quot;, a, b, atoi(a) - atoi(b));! }! ! void assign(char a[MAX], char b[MAX]){! char pre_b[MAX];!</p>
    <p>strcpy(pre_b, b);! strcpy(b, a);! printf(&quot;b is changed from %s to %s\n&quot;, pre_b, b);! }! ! int main(){! void (*funcs[3]) (char x[MAX], char y[MAX]);! int f;! char a[MAX], b[MAX];! funcs[0] = sum;! funcs[1] = sub;! funcs[2] = assign;! scanf(&quot;%d %s %s&quot;, &amp;f, &amp;a, &amp;b);! (*funcs[f])(a, b);! return 0;! }!</p>
    <p>IDA Misses</p>
    <p>IDA Misses</p>
    <p>IDA Misses</p>
  </div>
  <div class="page">
    <p>Func5on Iden5fica5on Problems Given a stripped binary, return 1. A list of function start addresses  Function Start Identi3ication (FSI) Problem</p>
  </div>
  <div class="page">
    <p>ByteWeight A machine learning + program analysis approach</p>
    <p>to function identiWication Training: 1. Creates a model of function start patterns using supervised</p>
    <p>machine learning Usage: 1. Use trained models to match function start on stripped</p>
    <p>binaries  Function Start IdentiWication 2. Use program analysis to identify all bytes associated with a</p>
    <p>function  Function IdentiWication 3. Calculate the minimum and maximum addresses of each</p>
    <p>function  Function Boundary IdentiWication</p>
  </div>
  <div class="page">
    <p>Func5on Start Iden5fica5on 1. Previous approaches 2. Our approach</p>
  </div>
  <div class="page">
    <p>b1 b2 b3 b4 b5 b6 b7 b8</p>
    <p>Entry Idiom: push ebp | * | mov esp,ebp!</p>
    <p>PreWix Idiom: ret | int3!</p>
    <p>Previous Work: Rosenblum et al.[1]</p>
    <p>[1] N. E. Rosenblum, X. Zhu, B. P. Miller, and K. Hunt. Learning to Analyze Binary Computer Code. In Proceedings of the 23rd National Conference on ArtiWicial Intelligence (2008), AAAI, pp. 798804.</p>
    <p>Method: Select instruction idioms up to length 4; learn idiom parameters; label test binaries</p>
    <p>Feature (idiom) selection for all three data sets (1,171 binaries) consumed over 150 compute-days</p>
    <p>of machine computation</p>
  </div>
  <div class="page">
    <p>ByteWeight: Lighter (Linear) Method</p>
    <p>Testing Binary</p>
    <p>Weight Calculation</p>
    <p>Training Binaries</p>
    <p>Weighted Sequences</p>
    <p>Weighted Prefix Tree</p>
    <p>Extraction</p>
    <p>Training</p>
    <p>Function Start</p>
    <p>Function Bytes</p>
    <p>Function Boundary</p>
    <p>CFG Recovery</p>
    <p>Function Boundary</p>
    <p>Identification RFCR</p>
    <p>Classification Function</p>
    <p>Identification</p>
    <p>Tree Generation</p>
    <p>Extracted Sequences</p>
  </div>
  <div class="page">
    <p>Step 1: Extract All  K-length Sequences</p>
    <p>! 0000000100000e3b &lt;func_1&gt;:! 55 push %rbp! 48 89 e5 mov %rsp,%rbp! 48 83 ec 10 sub $0x10,%rsp! 89 7d fc mov %edi,-0x4(%rbp)! 89 75 f8 mov %esi,-0x8(%rbp)! 8b 55 f8 mov -0x8(%rbp),%edx! 8b 45 fc mov -0x4(%rbp),%eax! 89 c6 mov %eax,%esi! 48 8d 3d c0 00 00 00 lea 0xc0(%rip),%rdi! b8 00 00 00 00 mov $0x0,%eax! e8 86 00 00 00 callq 100000ee8! c9 leaveq! c3 retq! !</p>
    <p>! 0000000100000e3b &lt;func_1&gt;:! 55 48 89 e5 48 83 ec 10 89 7d fc 89 75 f8 8b 55 f8 8b 45 fc 89 c6 48 8d 3d c0 00 00 00 b8 00 00 00 00 e8 86 00 00 00 c9 c3! !</p>
    <p>55!  55 48!  55 48 89 !  55 48 89 e5!  !</p>
    <p>Bytes</p>
    <p>push %rbp!  push %rbp; mov %rsp,%rbp!  push %rbp; mov %rsp,%rbp; sub $0x10,%rsp!  push %rbp; mov %rsp,%rbp; sub $0x10,%rsp; mov %edi,-0x4(%rbp)!  !</p>
    <p>Instructions</p>
    <p>! 0000000100000e3b &lt;_func_1&gt;:! push %rbp! mov %rsp,%rbp! sub $0x10,%rsp! mov %edi,-0x4(%rbp)! mov %esi,-0x8(%rbp)! mov -0x8(%rbp),%edx! mov -0x4(%rbp),%eax! mov %eax,%esi! lea 0xc0(%rip),%rdi! mov $0x0,%eax! callq 100000ee8! leaveq! retq! !</p>
  </div>
  <div class="page">
    <p>Step 2: Weight Sequences ! 0000000100000e3b &lt;_func_1&gt;:! 55 push %rbp! 48 89 e5 mov %rsp,%rbp! 48 83 ec 10 sub $0x10,%rsp! 89 7d fc mov %edi,-0x4(%rbp)! 89 75 f8 mov %esi,-0x8(%rbp)! 8b 55 f8 mov -0x8(%rbp),%edx! 8b 45 fc mov -0x4(%rbp),%eax! 89 c6 mov %eax,%esi! 48 8d 3d c0 00 00 00 lea 0xc0(%rip),%rdi! b8 00 00 00 00 mov $0x0,%eax! e8 86 00 00 00 callq 100000ee8! c9 leaveq! c3 retq! ! 0000000100000e64 &lt;_func_2&gt;:! 55 push %rbp! 48 89 e5 mov %rsp,%rbp! 48 83 ec 16 sub $0x16,%rsp! 89 7d fc mov %edi,-0x4(%rbp)! 89 75 f8 mov %esi,-0x8(%rbp)! 8b 55 f8 mov -0x8(%rbp),%edx! 8b 45 fc mov -0x4(%rbp),%eax! 89 c6 mov %eax,%esi! 48 8d 3d a6 00 00 00 lea 0xa6(%rip),%rdi! b8 00 00 00 00 mov $0x0,%eax! e8 5d 00 00 00 callq 100000ee8! c9 leaveq! c3 retq! 14</p>
    <p>push %rbp  55!</p>
    <p>score: 2 / (2 + 2) = 0.5</p>
  </div>
  <div class="page">
    <p>Step 2: Weight Sequences ! 0000000100000e3b &lt;_func_1&gt;:! 55 push %rbp! 48 89 e5 mov %rsp,%rbp! 48 83 ec 10 sub $0x10,%rsp! 89 7d fc mov %edi,-0x4(%rbp)! 89 75 f8 mov %esi,-0x8(%rbp)! 8b 55 f8 mov -0x8(%rbp),%edx! 8b 45 fc mov -0x4(%rbp),%eax! 89 c6 mov %eax,%esi! 48 8d 3d c0 00 00 00 lea 0xc0(%rip),%rdi! b8 00 00 00 00 mov $0x0,%eax! e8 86 00 00 00 callq 100000ee8! c9 leaveq! c3 retq! ! 0000000100000e64 &lt;_func_2&gt;:! 55 push %rbp! 48 89 e5 mov %rsp,%rbp! 48 83 ec 16 sub $0x16,%rsp! 89 7d fc mov %edi,-0x4(%rbp)! 89 75 f8 mov %esi,-0x8(%rbp)! 8b 55 f8 mov -0x8(%rbp),%edx! 8b 45 fc mov -0x4(%rbp),%eax! 89 c6 mov %eax,%esi! 48 8d 3d a6 00 00 00 lea 0xa6(%rip),%rdi! b8 00 00 00 00 mov $0x0,%eax! e8 5d 00 00 00 callq 100000ee8! c9 leaveq! c3 retq! 15</p>
    <p>push %rbp; mov %rsp,%rbp!  55 48 89 e5!</p>
    <p>score: 2 / (2 + 0) = 1.0</p>
  </div>
  <div class="page">
    <p>push %rbp!  2/(2+2)=0.5!</p>
    <p>push %rbp; mov %rsp,%rbp!  2/(2+0)=1.0!</p>
    <p>...!</p>
    <p>Step 3: Generate Weighted Prefix Tree</p>
    <p>push %rbp! (55)!</p>
    <p>mov %rsp,%rbp! (48 89 e5)!</p>
    <p>!</p>
    <p>sub $0x10,%rsp! (48 83 ec 10)!</p>
    <p>!</p>
  </div>
  <div class="page">
    <p>Classifica5on</p>
    <p>push %rbp! (55)!</p>
    <p>mov %rsp,%rbp! (48 89 e5)!</p>
    <p>!</p>
    <p>sub $0x10,%rsp! (48 83 ec 10)!</p>
    <p>!</p>
    <p>sub $0x16,%rsp! (48 83 ec 16)!</p>
    <p>Test Binary</p>
  </div>
  <div class="page">
    <p>Normaliza5on (Op5onal)</p>
    <p>sub $0x16,%rsp! (48 83 ec 16)!</p>
    <p>jne 0x12345678! (0f 85 1c 01 00 00)!</p>
    <p>jne 0x[0-9a-f]*!</p>
    <p>sub $0x60,%rsp!</p>
    <p>push %rbp! (55)!</p>
    <p>mov %rsp,%rbp! (48 89 e5)!</p>
    <p>sub $0x10,%rsp! (48 83 ec 10)!</p>
    <p>!</p>
    <p>!</p>
    <p>sub $0x[1-9a-f][0-9a-f]*,%rsp!</p>
  </div>
  <div class="page">
    <p>Func5on (Boundary) Iden5fica5on Identify all bytes associated with a function, and extract the lowest and highest addresses</p>
  </div>
  <div class="page">
    <p>ByteWeight: Func5on (Boundary) Iden5fica5on</p>
    <p>Testing Binary</p>
    <p>Function Start</p>
    <p>Function Bytes</p>
    <p>Function Boundary</p>
    <p>Control Flow Graph Recovery</p>
    <p>Function Boundary</p>
    <p>Identification RFCR</p>
    <p>Classification Function</p>
    <p>Identification</p>
    <p>[2] G. Balakrishan. WYSINWYX: What You See Is Not What You Execute. PhD thesis, University of Wisconsin- Madison, 2007.</p>
    <p>Weight Calculation</p>
    <p>Training Binaries</p>
    <p>Weighted Sequences</p>
    <p>Weighted Prefix Tree</p>
    <p>Extraction</p>
    <p>Training</p>
    <p>Tree Generation</p>
    <p>Extracted Sequences</p>
  </div>
  <div class="page">
    <p>ByteWeight: Func5on (Boundary) Iden5fica5on</p>
    <p>Testing Binary</p>
    <p>Function Start</p>
    <p>Function Bytes</p>
    <p>Function Boundary</p>
    <p>Function Boundary</p>
    <p>Identification RFCR</p>
    <p>Classification Function</p>
    <p>Identification</p>
    <p>[2] G. Balakrishan. WYSINWYX: What You See Is Not What You Execute. PhD thesis, University of Wisconsin- Madison, 2007.</p>
    <p>(instr1, instr101) instr1, instr2, instr3, instr6, instr10, instr12,</p>
    <p>, instr100, instr101.</p>
    <p>F1</p>
    <p>Control Flow Graph Recovery</p>
  </div>
  <div class="page">
    <p>Experiment Results Compilers: GCC , ICC, and MSVS Platforms: Linux and Windows Optimizations: O0(Od), O1, O2, and O3(Ox)</p>
  </div>
  <div class="page">
    <p>Training Performance ByteWeight:  10-fold cross-validation, 2200 binaries  6.1 days to train from all platforms and all compilers including logging</p>
    <p>Rosenblum et al.:  ??? (They reported 150 compute days for one step of training, but did not report total time, or make their training implementation available.)  training data and code both unavailable</p>
  </div>
  <div class="page">
    <p>Precision and Recall</p>
    <p>Precision = TP</p>
    <p>TP + FP Recall =</p>
    <p>TP TP + FN</p>
    <p>TP FN FP</p>
    <p>Tool Truth</p>
  </div>
  <div class="page">
    <p>Func5on Start Iden5fica5on: Comparison with Rosenblum et al.</p>
    <p>GCC ICC</p>
    <p>Precision</p>
    <p>Rosenblum et al.</p>
    <p>ByteWeight (K=3)</p>
    <p>ByteWeight (no norm)</p>
    <p>ByteWeight</p>
    <p>GCC ICC</p>
    <p>Recall</p>
    <p>Rosenblum et al.</p>
    <p>ByteWeight (K=3)</p>
    <p>ByteWeight (no norm)</p>
    <p>ByteWeight</p>
  </div>
  <div class="page">
    <p>Func5on Start Iden5fica5on: Exis5ng Binary Analysis Tools</p>
    <p>ELF x86 ELF x86-64 PE x86 PE x86-64</p>
    <p>Precision Nave Dyninst BAP IDA ByteWeight (no RFCR) ByteWeight</p>
    <p>ELF x86 ELF x86-64 PE x86 PE x86-64</p>
    <p>Recall Nave Dyninst BAP IDA ByteWeight (no RFCR) ByteWeight</p>
  </div>
  <div class="page">
    <p>Func5on Boundary Iden5fica5on: Exis5ng Binary Analysis Tools</p>
    <p>ELF x86 ELF x86-64 PE x86 PE x86-64</p>
    <p>Precision Nave Dyninst BAP IDA ByteWeight (no RFCR) ByteWeight</p>
    <p>ELF x86 ELF x86-64 PE x86 PE x86-64</p>
    <p>Recall Nave Dyninst BAP IDA ByteWeight (no RFCR) ByteWeight</p>
  </div>
  <div class="page">
    <p>Summary: ByteWeight Machine-learning based approach  Creates a model of function start patterns using supervised machine learning</p>
    <p>Matches model on new samples  Uses program analysis to identify all bytes associated with a function</p>
    <p>Faster and more accurate than previous work</p>
  </div>
  <div class="page">
    <p>Thank You</p>
    <p>Our experiment VM is available at: http://security.ece.cmu.edu/byteweight/</p>
    <p>Tiffany Bao tiffanybao@cmu.edu</p>
  </div>
</Presentation>
