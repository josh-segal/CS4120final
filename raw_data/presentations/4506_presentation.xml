<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Formal Verification and its Impact on the Snooping versus Directory Protocol Debate</p>
    <p>Milo M. K. Martin University of Pennsylvania</p>
    <p>milom@cis.upenn.edu</p>
  </div>
  <div class="page">
    <p>[ 2 ]</p>
    <p>Acknowledgements</p>
    <p>Many thanks to my collaborators  Mark Hill, David Wood, Mike Marty @ Wisconsin</p>
    <p>Dan Sorin @ Duke</p>
    <p>Alan Hu and Jesse Bingham @ UBC</p>
    <p>Rajeev Alur, Sebastian Burckhardt @ Penn</p>
    <p>Supported by  IBM Graduate Fellowship, Sun, Intel</p>
    <p>NSF</p>
  </div>
  <div class="page">
    <p>[ 3 ]</p>
    <p>Overview</p>
    <p>Multiprocessor cache coherence protocols  Allows a multiprocessor look like a multi-programmed</p>
    <p>uniprocessor to software  Complex, concurrent, and performance critical  No consensus on general design approach</p>
    <p>Multi-decade debate still raging</p>
    <p>Formal verification  Used in finding bugs in cache coherence protocols  A great success in real-world use of formal verification</p>
    <p>This presentation:  Revisiting debate in the context of formal verification  Some observations on protocol design &amp; verification</p>
  </div>
  <div class="page">
    <p>[ 4 ]</p>
    <p>Caveats</p>
    <p>Im not a verification expert  Primary expertise is computer architecture</p>
    <p>Especially multiprocessor memory systems</p>
    <p>Some dabbling in formal verification</p>
    <p>Im only an academic  Limited industrial experience</p>
    <p>But lots of conversations with designers</p>
    <p>Some of what I will say is controversial  Not all of it is new, as well</p>
  </div>
  <div class="page">
    <p>[ 5 ]</p>
    <p>Outline</p>
    <p>Multiprocessors and coherence background</p>
    <p>Formal verification and coherence protocols</p>
    <p>Revisit the snooping vs directory protocol debate</p>
    <p>A new alternative: Token Coherence</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>[ 6 ]</p>
    <p>Multiprocessors</p>
    <p>Multiprocessors are becoming ubiquitous  All servers, multi-core desktops, multi-core embedded  After decades of research and niche deployment</p>
    <p>Why now?  Todays workload (server and media workloads)</p>
    <p>SQL and OpenGL most used parallel languages  Commodity multiprocessor software (e.g., Linux)  Power-efficient way to multiply performance</p>
    <p>E.g., StrongARM 1Ghz  200Mhz, 30x less power  Use 5 cores, 6x power reduction, same net speed</p>
    <p>Difficult software transition from one to two cores  Much easier after that exciting times</p>
  </div>
  <div class="page">
    <p>[ 7 ]</p>
    <p>Multiprocessor Hardware</p>
    <p>P1 P2 P3 P4</p>
    <p>Memory System</p>
    <p>Provide a shared-memory abstraction  Familiar and efficient for programmers</p>
  </div>
  <div class="page">
    <p>[ 8 ]</p>
    <p>Provide a shared-memory abstraction  Familiar and efficient for programmers</p>
    <p>Multiprocessor Hardware</p>
    <p>Interconnection Network</p>
    <p>P1</p>
    <p>Cache M1 Interface</p>
    <p>P2</p>
    <p>Cache M2 Interface</p>
    <p>P3</p>
    <p>Cache M3 Interface</p>
    <p>P4</p>
    <p>Cache M4 Interface</p>
    <p>Cache coherence protocol provides transparency  Distributed, complicated, performance critical</p>
  </div>
  <div class="page">
    <p>[ 9 ]</p>
    <p>Invalidation-based Cache-Coherence</p>
    <p>Goal: provide a consistent view of memory</p>
    <p>Permissions in each cache per block  One read/write -or- exclusive block  Many readers shared block</p>
    <p>Cache coherence protocols  Distributed &amp; complex  Correctness critical</p>
    <p>Performance critical</p>
    <p>Races: the main source of complexity  Requests for the same block at the same time</p>
  </div>
  <div class="page">
    <p>[ 10 ]</p>
    <p>Snooping multiprocessors  Uses broadcast  Virtual bus interconnect + Directly locate data (2 hops)</p>
    <p>Directory-based multiprocessors  Directory tracks writer or readers + Avoids broadcast + Avoids virtual bus interconnect  Indirection for cache-to-cache (3 hops)</p>
    <p>Method for ordering racing requests is key</p>
    <p>Two classes of multiprocessors</p>
    <p>P P P M</p>
    <p>P P P M</p>
  </div>
  <div class="page">
    <p>[ 11 ]</p>
    <p>Snooping Protocols</p>
    <p>Original designs  Bus-based broadcast</p>
    <p>High-speed point-to-point links  No (multi-drop) busses  Build virtual bus  Increasingly not globally</p>
    <p>synchronous</p>
    <p>Other enhancements  Split transaction  Multiple request and response interconnects  Snoop response combining  Distribute memory on each processor node</p>
  </div>
  <div class="page">
    <p>[ 12 ]</p>
    <p>Snooping Example</p>
    <p>P2</p>
    <p>Read/Write</p>
    <p>P0</p>
    <p>Requestor</p>
    <p>P1</p>
    <p>Requestor</p>
    <p>M0</p>
    <p>Home</p>
    <p>Root</p>
    <p>Virtual bus (totally-ordered)</p>
    <p>Interconnect</p>
  </div>
  <div class="page">
    <p>[ 13 ]</p>
    <p>Snooping Example</p>
    <p>P2</p>
    <p>No Copy</p>
    <p>P0</p>
    <p>Requestor</p>
    <p>P1</p>
    <p>Read/Write</p>
    <p>M0</p>
    <p>Home</p>
    <p>Root</p>
    <p>Virtual bus (totally-ordered)</p>
    <p>Interconnect ordered interconnect orders requests</p>
  </div>
  <div class="page">
    <p>[ 14 ]</p>
    <p>Directory Protocols</p>
    <p>Send all requests to directory  Avoids broadcast</p>
    <p>Scalable, but who cares?  Most systems sold are modest in size</p>
    <p>Does not require interconnect ordering</p>
    <p>(Bad) alternative names:  CC-NUMA  Distributed shared memory  Scalable cache coherence  Why bad names? dont capture the fundamental</p>
    <p>differences</p>
    <p>P P P M</p>
  </div>
  <div class="page">
    <p>[ 15 ]</p>
    <p>Directory Example</p>
    <p>P2</p>
    <p>Read/Write</p>
    <p>P0</p>
    <p>Requestor</p>
    <p>P1</p>
    <p>Requestor</p>
    <p>M0</p>
    <p>Home</p>
    <p>Request</p>
    <p>Fwd</p>
  </div>
  <div class="page">
    <p>[ 16 ]</p>
    <p>Directory Example</p>
    <p>Request</p>
    <p>Fwd Data</p>
    <p>Done</p>
    <p>P2</p>
    <p>No Copy</p>
    <p>P0</p>
    <p>Requestor</p>
    <p>P1</p>
    <p>Read/Write</p>
    <p>M0</p>
    <p>Home</p>
  </div>
  <div class="page">
    <p>[ 17 ]</p>
    <p>Directory Example</p>
    <p>Request</p>
    <p>Fwd</p>
    <p>P2</p>
    <p>No Copy</p>
    <p>P0</p>
    <p>Requestor</p>
    <p>P1</p>
    <p>Read/Write</p>
    <p>M0</p>
    <p>Home</p>
  </div>
  <div class="page">
    <p>[ 18 ]</p>
    <p>Directory Example</p>
    <p>Request</p>
    <p>Fwd</p>
    <p>Data</p>
    <p>Done</p>
    <p>P2</p>
    <p>No Copy</p>
    <p>P0</p>
    <p>Read/Write</p>
    <p>P1</p>
    <p>No Copy</p>
    <p>M0</p>
    <p>Home</p>
    <p>No ordered interconnect, directory orders requests</p>
  </div>
  <div class="page">
    <p>[ 19 ]</p>
    <p>The Debate: Snooping v. Directories</p>
    <p>Which approach is better?</p>
    <p>Debated for 20+ years</p>
    <p>Mostly debated in terms of  Scalable performance  Performance</p>
    <p>Lets revisit the debate in terms of  Design complexity  Verifications impact on the above</p>
  </div>
  <div class="page">
    <p>[ 20 ]</p>
    <p>Outline</p>
    <p>Multiprocessors and coherence background</p>
    <p>Formal verification and coherence protocols</p>
    <p>Revisit the snooping vs directory protocol debate</p>
    <p>A new alternative: Token Coherence</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>[ 21 ]</p>
    <p>Formal Verification &amp; Coherence Protocols</p>
    <p>Model the protocol at a high level  Abstract away some implementation details</p>
    <p>Capture concurrent races</p>
    <p>Find protocol bugs (earlier the better)</p>
    <p>Alternative: verify implementation vs high-level model</p>
    <p>Multitude of formal techniques  Model checking, theorem proving, SAT solvers, etc.</p>
    <p>Apply to scaled down system  Few processors, two data values, two addresses,</p>
    <p>limited traces, etc.</p>
  </div>
  <div class="page">
    <p>[ 22 ]</p>
    <p>Explicit Role of Formal Verification</p>
    <p>Post-design verification  Used more like traditional design verification  Can help find bugs, but many false bugs</p>
    <p>Out of date or incomplete specification  Or previously found and fixed</p>
    <p>Many case studies, e.g., [Hu et al., ICCD 1997]</p>
    <p>During-design verification  Model creation part of design specification process  Formal verifiers part of cross-functional design team  Find bugs early  easier, cleaner fixes  Becoming more common, fewer anecdotes</p>
  </div>
  <div class="page">
    <p>[ 23 ]</p>
    <p>Implicit Role of Verification</p>
    <p>Once formal verification is part of design</p>
    <p>Has implicit impact on the actual design  A series of bugs might change high-level design</p>
    <p>Forces deep systematic think about the design</p>
    <p>Gives designers confidence</p>
    <p>Just making the model can find bugs (story)</p>
    <p>Verifiability becomes a design constraint  Designers react to it (story)</p>
    <p>Encourages modular, cleaner, documented designs</p>
  </div>
  <div class="page">
    <p>[ 24 ]</p>
    <p>Implicit Role of Verification (continued)</p>
    <p>Is a verifiable design a better design?  principles of good design, keeps designers honest</p>
    <p>Avoid problems before bugs develop</p>
    <p>Easier alternative? just trick the designers</p>
    <p>Design systems to be formally verified?  How might doing so affect low-level concurrent</p>
    <p>protocols?</p>
    <p>What might such a coherence protocol look like?</p>
    <p>Ill talk about one possibility later in talk</p>
  </div>
  <div class="page">
    <p>[ 25 ]</p>
    <p>Two Desirable Coherence Properties</p>
    <p>What properties might a coherence protocol  To make it verifiable</p>
    <p>To make it simple</p>
    <p>To make it flexible</p>
    <p>Two desirable decoupling properties  Decouple interconnect properties from protocol</p>
    <p>Decouple consistency from coherence</p>
  </div>
  <div class="page">
    <p>[ 26 ]</p>
    <p>Decouple Interconnect from Protocol (1 of 2)</p>
    <p>Unordered interconnections  Simple, modular interface</p>
    <p>Deadlock avoidance via virtual networks</p>
    <p>Constrains design and model the least</p>
    <p>Point-to-point ordered interconnects  Disallows adaptive routing</p>
    <p>Reduces symmetry of model (state space)</p>
    <p>Not so bad, but better to avoid</p>
    <p>Most directory protocol fall into these categories</p>
  </div>
  <div class="page">
    <p>[ 27 ]</p>
    <p>Decouple Interconnect from Protocol (2 of 2)</p>
    <p>Totally-ordered interconnects  Requires a bus or virtual bus, snoop combining</p>
    <p>Sometimes timing sensitive</p>
    <p>Complicate interface, implementation, modeling</p>
    <p>What protocols require this property?  Snooping (all)</p>
    <p>Is snooping defined by broadcast or ordering?</p>
    <p>Few directory protocols (e.g., GS320)</p>
  </div>
  <div class="page">
    <p>[ 28 ]</p>
    <p>Decouple Coherence from Consistency</p>
    <p>Memory consistency models  Defines consistent view of memory  Coherence: for a single location  Consistency: ordering among multiple locations</p>
    <p>Example: Initial state: A = B = 0</p>
    <p>Thread #0 Thread #1 while(A == 0) { /* nothing */ } Store B  1 Load B Store A  1</p>
    <p>Load B should return?  Under sequential consistency, always one  Can return zero under weaker models</p>
  </div>
  <div class="page">
    <p>[ 29 ]</p>
    <p>Enforcing A Memory Consistency Model</p>
    <p>Option#1  Coherence protocol provides coherence invariant</p>
    <p>Single-reader/writer --or-- multiple readers</p>
    <p>Processor internally allows or disallows reorderings</p>
    <p>All sync instructions internal to processor core</p>
    <p>Example: Alpha 21364</p>
    <p>Option #2  Intertwine and disperse enforcement through system</p>
    <p>Totally order all requests</p>
    <p>Send sync instructions into memory system</p>
    <p>Maybe write-through L1 caches in multi-core systems</p>
    <p>Example: IBM Power4</p>
  </div>
  <div class="page">
    <p>[ 30 ]</p>
    <p>Decoupling Implications</p>
    <p>For verification  Easier to model each piece independently &amp; together</p>
    <p>Reuse models over time</p>
    <p>For design  More compartmentalized</p>
    <p>Easier incremental improvement over time</p>
    <p>Reuse of design components</p>
  </div>
  <div class="page">
    <p>[ 31 ]</p>
    <p>Revisiting Snooping vs Directory Protocols</p>
    <p>Snooping Protocols  Simple snooping is seductively simple</p>
    <p>Atomic with simple bus</p>
    <p>More aggressive implementations are quite complex</p>
    <p>Violate the two decoupling properties</p>
    <p>Directory Protocols  Have the decoupling properties</p>
    <p>Complex, but in all the ways formal methods can help</p>
    <p>Better complexity scalability over time</p>
  </div>
  <div class="page">
    <p>[ 32 ]</p>
    <p>Time Time</p>
    <p>C o</p>
    <p>m p</p>
    <p>le xi</p>
    <p>ty</p>
    <p>C o</p>
    <p>m p</p>
    <p>le xi</p>
    <p>ty</p>
    <p>Interconnect Protocol Controller impl.</p>
    <p>Snooping Directory</p>
    <p>Complexity Scaling</p>
    <p>Initial designs  Simple bus-based snooping simple, directory less so</p>
    <p>As design evolves  Snooping quickly becomes complex, directory less so</p>
    <p>Caveat: few second-system directory systems</p>
  </div>
  <div class="page">
    <p>[ 33 ]</p>
    <p>Why Arent Directory Protocols More Common?</p>
    <p>Complexity disconnect  No evolutionary path to directory protocols  Radical design departure  Designers are good at incrementally improving</p>
    <p>working approaches over time</p>
    <p>Scalability trap  Previous idea: scalability at all costs!  Should only be a means to an ends, not an end goal  Scalable cache coherence is synonymous with</p>
    <p>directory protocols</p>
    <p>Often used to bridge between snooping systems  Reputation for high latency</p>
  </div>
  <div class="page">
    <p>[ 34 ]</p>
    <p>My Opinion on the Coherence Debate?</p>
    <p>I now advocate against snooping protocols  But for different reasons than others</p>
    <p>i.e., not performance scalability  Main reason: decoupling properties</p>
    <p>A reversal of my previous opinion!  Previously, I explored evolving snooping protocols</p>
    <p>[ASPLOS 2000, HPCA 2002]  Now, tightly-coupled directory protocols attractive</p>
    <p>AMDs Operton protocol is interesting  Directory-less directory protocol  Glueless, point-to-point interconnect, non-scalable</p>
    <p>Or, a new alternative</p>
  </div>
  <div class="page">
    <p>[ 35 ]</p>
    <p>A New Alternative: Token Coherence [ISCA 2003]</p>
    <p>A protocol design to be verified formally  Fast, simple, flexible, too.</p>
    <p>Decoupling correctness and performance  Correctness substrate</p>
    <p>Safety via token counting</p>
    <p>Forward progress via persistent requests</p>
    <p>Separate performance policies</p>
    <p>Target the common case</p>
    <p>Separate correctness and performance  Example of Better Then Worst-Case Design</p>
  </div>
  <div class="page">
    <p>[ 36 ]</p>
    <p>Key Observation: Token Counting</p>
    <p>Explicitly encode permissions with tokens  At all times, all blocks have T tokens</p>
    <p>E.g., one token per processor  Components exchange tokens &amp; data</p>
    <p>Tokens: in caches, memory, or in transit</p>
    <p>Controls reading &amp; writing of data  One or more to read  All tokens to write</p>
    <p>Provides safety in all cases</p>
  </div>
  <div class="page">
    <p>[ 37 ]</p>
    <p>Store BLoad B</p>
    <p>Token Counting Example Load B</p>
    <p>Each memory block initialized with T tokens  At least one token to read a block</p>
    <p>All tokens to write a block</p>
    <p>P0 L1 I&amp;D</p>
    <p>L2</p>
    <p>P1 L1 I&amp;D</p>
    <p>L2</p>
    <p>P2 L1 I&amp;D</p>
    <p>L2</p>
    <p>P3 L1 I&amp;D</p>
    <p>L2</p>
    <p>interconnect</p>
    <p>Store B</p>
    <p>mem 0 mem 3</p>
  </div>
  <div class="page">
    <p>[ 38 ]</p>
    <p>Guaranteeing Starvation-Freedom</p>
    <p>Handle pathological cases  Infrequently invoked</p>
    <p>Can be slow, inefficient, and simple</p>
    <p>When normal requests fail to succeed (4x)  Longer timeout and issue a persistent request</p>
    <p>Request persists until satisfied</p>
    <p>Table at each processor</p>
    <p>Deactivate upon completion</p>
    <p>Implementation  Arbiter at memory orders persistent requests</p>
  </div>
  <div class="page">
    <p>[ 39 ]</p>
    <p>Performance Policies</p>
    <p>Opportunities  Aggressively target the common case  Requests are just hints to move data &amp; tokens</p>
    <p>Robust  Cant cause correctness violations  A null or random policy is correct  Rely on correctness substrate</p>
    <p>Examples  TokenB - broadcast policy  TokenD - performance characteristics of directory  TokenM - predictive multicast protocols  TokenCMP [HPCA 2005] - multi-level coherence</p>
    <p>Flat for correctness, hierarchical for performance</p>
  </div>
  <div class="page">
    <p>[ 40 ]</p>
    <p>Ramifications of T.C. on Design Verification</p>
    <p>Divide and conquer complexity  Formally verified Token Coherence [HPCA 2005]</p>
    <p>Difficult to quantify, but promising</p>
    <p>All races handled uniformly (reissuing)</p>
    <p>E.g. simple replacements (no handshake)</p>
    <p>Local invariants  Safety is response-centric; independent of requests</p>
    <p>Locally enforced with tokens</p>
    <p>Further innovation  no correctness worries</p>
  </div>
  <div class="page">
    <p>[ 41 ]</p>
    <p>Token Coherence vs Directory Protocols</p>
    <p>Similarities  Decouple interconnect from protocol</p>
    <p>Decouple coherence from consistency</p>
    <p>Token Coherence more explicitly gives you a serial coherence</p>
    <p>Differences  Token Coherence can avoid directory indirection</p>
    <p>Token Coherence is more flexible, decoupled</p>
    <p>However, Token Coherence has separate persistent requests, which add complexity</p>
    <p>Result: an interesting alternative</p>
  </div>
  <div class="page">
    <p>[ 42 ]</p>
    <p>Outline</p>
    <p>Multiprocessors and coherence background</p>
    <p>Formal verification and coherence protocols</p>
    <p>Revisit the snooping vs directory protocol debate</p>
    <p>A new alternative: Token Coherence</p>
    <p>Conclusion</p>
  </div>
  <div class="page">
    <p>[ 43 ]</p>
    <p>Conclusions</p>
    <p>The age of multiprocessors and multi-core chips  Coherence protocol is key design to such designs</p>
    <p>Formal verification has an important role to play  Leverage formal methods early in design process</p>
    <p>Both explicit and implicit benefits</p>
    <p>Two decoupling properties  Decouple interconnect from protocol</p>
    <p>Decouple coherence and consistency</p>
    <p>Snooping vs directory protocols?  Directory protocols have these decoupling properties</p>
    <p>Token Coherence further embraces them</p>
  </div>
  <div class="page">
    <p>[ 44 ]</p>
  </div>
  <div class="page">
    <p>[ 45 ]</p>
    <p>mem 0</p>
    <p>Starvation Avoidance CMP 0</p>
    <p>interconnect</p>
    <p>P0 Store B</p>
    <p>interconnect</p>
    <p>P1</p>
    <p>mem 1</p>
    <p>CMP 1</p>
    <p>interconnect</p>
    <p>P2 Store B</p>
    <p>P3</p>
    <p>Tokens move freely in the system  Transient Requests can miss in-flight tokens  Incorrect speculation, filters, prediction, etc</p>
    <p>Shared L2 Shared L2</p>
    <p>Store B</p>
    <p>GETX GETX GETX</p>
    <p>L1 I&amp;D L1 I&amp;D L1 I&amp;D L1 I&amp;D</p>
  </div>
  <div class="page">
    <p>[ 46 ]</p>
    <p>mem 0</p>
    <p>Starvation Avoidance CMP 0</p>
    <p>interconnect</p>
    <p>P0</p>
    <p>interconnect</p>
    <p>P1</p>
    <p>mem 1</p>
    <p>CMP 1</p>
    <p>interconnect</p>
    <p>P2 P3</p>
    <p>Shared L2 Shared L2</p>
    <p>L1 I&amp;D L1 I&amp;D L1 I&amp;D L1 I&amp;D</p>
    <p>Solution: issue Persistent Requests  Heavyweight request guaranteed to succeed</p>
    <p>Store B Store BStore B</p>
  </div>
  <div class="page">
    <p>[ 47 ]</p>
    <p>mem 0</p>
    <p>Persistent Requests CMP 0</p>
    <p>interconnect</p>
    <p>P0 Store B</p>
    <p>interconnect</p>
    <p>P1</p>
    <p>mem 1</p>
    <p>CMP 1</p>
    <p>interconnect</p>
    <p>P2 Store B</p>
    <p>P3</p>
    <p>Processors issue persistent requests</p>
    <p>Shared L2 Shared L2</p>
    <p>Store B</p>
    <p>L1 I&amp;D L1 I&amp;D L1 I&amp;D L1 I&amp;D</p>
    <p>arbiter 0</p>
    <p>arbiter 0B: P0 B: P2 B: P1</p>
    <p>timeout timeout timeout</p>
  </div>
  <div class="page">
    <p>[ 48 ]</p>
    <p>mem 0</p>
    <p>Persistent Requests CMP 0</p>
    <p>interconnect</p>
    <p>P0 Store B</p>
    <p>interconnect</p>
    <p>P1</p>
    <p>mem 1</p>
    <p>CMP 1</p>
    <p>interconnect</p>
    <p>P2 Store B</p>
    <p>P3</p>
    <p>Processors issue persistent requests</p>
    <p>Arbiter orders and broadcasts activate</p>
    <p>Shared L2 Shared L2</p>
    <p>Store B</p>
    <p>L1 I&amp;D L1 I&amp;D L1 I&amp;D L1 I&amp;D</p>
    <p>arbiter 0</p>
    <p>arbiter 0B: P0 B: P2 B: P1</p>
    <p>B: P0</p>
    <p>B: P0 B: P0 B: P0 B: P0</p>
    <p>B: P0</p>
    <p>Store B</p>
  </div>
  <div class="page">
    <p>[ 49 ]</p>
    <p>mem 0</p>
    <p>Persistent Requests CMP 0</p>
    <p>interconnect</p>
    <p>P0</p>
    <p>interconnect</p>
    <p>P1</p>
    <p>mem 1</p>
    <p>CMP 1</p>
    <p>interconnect</p>
    <p>P2 Store B</p>
    <p>P3</p>
    <p>Processor sends deactivate to arbiter</p>
    <p>Arbiter broadcasts deactivate (and next activate)</p>
    <p>Shared L2 Shared L2</p>
    <p>Store B</p>
    <p>L1 I&amp;D L1 I&amp;D L1 I&amp;D L1 I&amp;D</p>
    <p>arbiter 0</p>
    <p>arbiter 0</p>
    <p>B: P2 B: P1</p>
    <p>B: P0</p>
    <p>B: P0 B: P0 B: P0 B: P0</p>
    <p>B: P0</p>
    <p>B: P2</p>
    <p>B: P2</p>
    <p>B: P2 B: P2</p>
    <p>B: P2</p>
    <p>B: P2B: P2</p>
    <p>Store B</p>
    <p>B: P0</p>
  </div>
</Presentation>
