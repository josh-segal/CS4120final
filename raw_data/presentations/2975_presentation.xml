<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Ding Yuan, Yu Luo, Xin Zhuang, Guilherme Rodrigues, Xu Zhao,</p>
    <p>Yongle Zhang, Pranay U. Jain and Michael Stumm</p>
    <p>University of Toronto</p>
    <p>Simple testing can prevent most critical failures -- An analysis of production failures in</p>
    <p>distributed data-intensive systems</p>
    <p>Code and dataset: http://www.eecg.toronto.edu/failureAnalysis/</p>
  </div>
  <div class="page">
    <p>Key findings</p>
    <p>} Failures are the results of complex sequence of events</p>
    <p>} Catastrophic failures are caused by incorrect error handling } Many are caused by a small set of trivial bug patterns</p>
    <p>} Aspirator: a simple rule-based static checker } Found 143 confirmed new bugs and bad practices</p>
  </div>
  <div class="page">
    <p>Distributed system failures can be deadly</p>
    <p>Amazon AWS outage downs Reddit, Quora, Foursquare, Instagram, NetFlix, and about 70 other sites.</p>
    <p>Google outage: Internet traffic plunges 40%.</p>
    <p>Facebook goes down; users called 911.</p>
  </div>
  <div class="page">
    <p>} Study end-to-end failure propagation sequence</p>
    <p>} Reveal the minimum conditions to expose failures } Reveal the weakest link</p>
    <p>} Previous works only studied elements in isolation</p>
    <p>A thorough analysis of real-world failures</p>
    <p>Fault (root cause), e.g., bug, h/w fault,</p>
    <p>misconfiguration, etc.</p>
    <p>Failure, visible to user/admin.</p>
    <p>Error (exception), e.g., system-call error return</p>
  </div>
  <div class="page">
    <p>} Randomly sampled 198 user-reported failures* } Carefully studied the discussion and related code/patch } Reproduced 73 to understand them</p>
    <p>} 48 are catastrophic --- they affect all or a majority of users</p>
    <p>Study methodology</p>
    <p>Software Program language</p>
    <p>Sampled failures</p>
    <p>Total Catastrophic</p>
    <p>Cassandra Java 40 2</p>
    <p>HBase Java 41 21</p>
    <p>HDFS Java 41 9</p>
    <p>Hadoop MapReduce Java 38 8</p>
    <p>Redis C 38 8</p>
    <p>Total - 198 48</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>} Failures are the results of complex sequence of events</p>
    <p>} Catastrophic failures are caused by incorrect error handling } Many are caused by trivial bugs</p>
    <p>} Aspirator: a simple rule-based static checker</p>
  </div>
  <div class="page">
    <p>/* Master: delete the * ZooKeeper znode after * the region is opened */ try { deleteZNode(); } catch (KeeperException e) { cluster.abort();</p>
    <p>An example</p>
    <p>User: Sudden outage on the entire HBase cluster.</p>
    <p>Not handled properly</p>
    <p>Event 1: Load balance: transfer Region R from slave A to B</p>
    <p>Event 2: Slave B dies</p>
    <p>R is assigned to slave C</p>
    <p>Slave B opens R</p>
    <p>Slave C opens R</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>/* Master: delete the * ZooKeeper node after * the region is opened */ try { deleteZNode(); } catch (KeeperException e) { cluster.abort(); }</p>
    <p>Finding I: multiple events are required</p>
    <p>Event 1: Load balance: transfer Region R from slave A to B</p>
    <p>Event 2: Slave B dies</p>
    <p>R is assigned to slave C</p>
    <p>Slave B opens R</p>
    <p>Slave C opens R</p>
    <p>Only occur on long-running system (38%)</p>
  </div>
  <div class="page">
    <p>/* Master: delete the * ZooKeeper node after * the region is opened */ try { deleteZNode(); } catch (KeeperException e) { cluster.abort(); }</p>
    <p>Finding II: event order matters</p>
    <p>Event 1: Load balance: transfer Region R from slave A to B</p>
    <p>Event 2: Slave B dies</p>
    <p>R is assigned to slave C</p>
    <p>Slave B opens R</p>
    <p>Slave C opens R</p>
    <p>Order of events is important in 88% of the multi-events failures</p>
  </div>
  <div class="page">
    <p>/* Master: delete the * ZooKeeper node after * the region is opened */ try { deleteZNode(); } catch (KeeperException e) { cluster.abort(); }</p>
    <p>Finding III: timing matters</p>
    <p>Event 1: Load balance: transfer Region R from slave A to B</p>
    <p>Event 2: Slave B dies</p>
    <p>R is assigned to slave C</p>
    <p>Slave B opens R</p>
    <p>Slave C opens R</p>
  </div>
  <div class="page">
    <p>Complexity is not surprising</p>
    <p>} These systems undergo thorough testing } Must provide unit test for every patch } Use static checker on every check-in } Use fault injection testing [HadoopFaultInjection]</p>
    <p>} Designed to provide high availability } E.g., automatic failover on master failures</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>} Failures are the results of complex sequence of events</p>
    <p>} Catastrophic failures are caused by incorrect error handling } Catastrophic failures: those affect all or a majority of the users</p>
    <p>} Aspirator: a rule-based static checker</p>
  </div>
  <div class="page">
    <p>Breakdown of catastrophic failures C</p>
    <p>atastro phic failures (100%</p>
    <p>)</p>
    <p>Undetected Error</p>
    <p>Error detected, but wrongly handled</p>
    <p>Faults</p>
    <p>} Error handling code is the last line of defense [Marinescu&amp;Candea11]</p>
  </div>
  <div class="page">
    <p>Trivial mistakes in error handling code C</p>
    <p>atastro phic failures (100%</p>
    <p>)</p>
    <p>Faults</p>
    <p>Undetected Error</p>
    <p>Error detected, but wrongly handled</p>
    <p>Trivial mistakes (35%)</p>
    <p>Complex bugs (34%)</p>
    <p>System specific, but easily detectable (23%)</p>
    <p>Errors ignored (25%) Abort in over-catch (8%) TODO in handler (2%)</p>
    <p>} catch (Throwable t) { abort (); }</p>
    <p>NonFatalException FatalException</p>
    <p>Example of abort in over-catch</p>
  </div>
  <div class="page">
    <p>A failure caused by trivial mistake</p>
    <p>User: MapReduce jobs hang when a rare Resource Manager restart occurs. I have to ssh to every one of our 4000 nodes in a cluster and kill all jobs.</p>
    <p>catch (RebootException) { // TODO LOG(Error event from RM: shutting down...); } + eventHandler.handle(exception_response);</p>
  </div>
  <div class="page">
    <p>Easily detectable bugs C</p>
    <p>atastro phic failures (100%</p>
    <p>)</p>
    <p>Faults</p>
    <p>Undetected Error</p>
    <p>Error detected, but wrongly handled</p>
    <p>Trivial mistakes (35%)</p>
    <p>Complex bugs (34%)</p>
    <p>System specific, but easily detectable (23%)</p>
    <p>Completely wrong</p>
  </div>
  <div class="page">
    <p>/* Master: delete the * ZooKeeper znode after * the region is opened */ try { deleteZNode(); } catch (KeeperException e) { cluster.abort(); }</p>
    <p>The HBase example: an easily detectable bug</p>
    <p>Completely wrong</p>
    <p>Event 1: Load balance: transfer Region R from slave A to B</p>
    <p>Event 2: Slave B dies</p>
    <p>R is assigned to slave C</p>
    <p>Slave B opens R</p>
    <p>Slave C opens R</p>
    <p>} Difficult to be triggered; easily detectable by code review</p>
  </div>
  <div class="page">
    <p>Over half are trivial or easily detectable bugs C</p>
    <p>atastro phic failures (100%</p>
    <p>)</p>
    <p>Faults</p>
    <p>Undetected Error</p>
    <p>Error detected, but wrongly handled</p>
    <p>Trivial mistakes (35%)</p>
    <p>Complex bugs (34%)</p>
    <p>System specific, but easily detectable (23%)</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>} Failures are the results of complex sequence of events</p>
    <p>} Catastrophic failures are caused by incorrect error handling</p>
    <p>} Aspirator: a simple rule-based static checker</p>
  </div>
  <div class="page">
    <p>Aspirator: a static checker for Java programs</p>
    <p>} Three rules on exception handling } Not empty } Not abort on exception over-catch } No TODO or FIXME comment</p>
    <p>} False positive suppression techniques (details in paper)</p>
    <p>} Over 1/3 of catastrophic failures could have been prevented } If aspirator has been used and identified bugs fixed</p>
  </div>
  <div class="page">
    <p>Checking real-world systems</p>
    <p>System Bugs Bad practice False positive</p>
    <p>Cassandra 2 2 9</p>
    <p>HBase 16 43 20</p>
    <p>HDFS 24 32 16</p>
    <p>Hadoop MapRed.2 13 15 1</p>
    <p>Cloudstack 27 185 20</p>
    <p>Hive 25 54 8</p>
    <p>Tomcat 7 23 30</p>
    <p>Spark 2 1 2</p>
    <p>Zookeeper 5 24 9</p>
    <p>Total 121 379 115</p>
    <p>new bugs in every system</p>
    <p>Training set</p>
    <p>Testing set</p>
  </div>
  <div class="page">
    <p>New bugs can lead to catastrophic failures</p>
    <p>} Hang system</p>
    <p>} Data loss</p>
    <p>} Cluster crash } E.g., bugs found by abort in over-catch check</p>
    <p>try { tableLock.release(); } catch (IOException e) { LOG(&quot;Can't release lock, e); }</p>
    <p>try { journal.recover(); } catch (IOException ex) { }</p>
    <p>Cannot recover updates from journal</p>
  </div>
  <div class="page">
    <p>Mixed feedbacks from developers</p>
    <p>} Reported 171 new bugs/bad practices } 143 confirmed/fixed; 17 rejected; no response for the rest</p>
    <p>I fail to see the reason to handle every exception.</p>
    <p>No one would have looked at this hidden feature; ignoring exceptions is bad precisely for this reason</p>
    <p>I really want to fix issues in this line, because I really want us to use exceptions properly and never ignore them</p>
  </div>
  <div class="page">
    <p>Why do developers ignore error handling?</p>
    <p>} Developers think the errors will never happen } Code evolution may enable the errors } The judgment can be wrong</p>
    <p>} Error handling is difficult</p>
    <p>} Errors can be returned by 3rd party libraries</p>
    <p>} Feature development is prioritized</p>
    <p>} catch (IOException e) { // will never happen }</p>
    <p>} catch (NoTransitionException e) { /* Why this can happen? Ask God not me. */ }</p>
  </div>
  <div class="page">
    <p>Other findings in the paper</p>
    <p>} Failures require no more than 3 nodes to manifest</p>
    <p>} Failures can be reproduced offline by unit tests } The triggering events are recorded in system log</p>
    <p>} Non-deterministic failures can still be deterministically reproduced</p>
  </div>
  <div class="page">
    <p>Related work</p>
    <p>} Error handling code is often buggy [Gunawi08, Marinescu10, Rubio-Gonzlez09, Sullivan91, etc.]</p>
    <p>} Studies on distributed system failures [Gray85, Oppenheimer03, Rabkin13, etc.]</p>
    <p>} Distributed system testing [ChaosMonkey, Gunawi11, Guo11, HadoopFaultInjection, Killian07, Leesatapornwongsa14, Yang09, etc.]</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>} Failures are the results of complex sequence of events</p>
    <p>} Catastrophic failures are caused by incorrect error handling } Many are caused by a small set of trivial bug patterns</p>
    <p>} Aspirator: a simple rule-based static checker } Found 143 confirmed new bugs and bad practices</p>
  </div>
  <div class="page">
    <p>Unexpected fun: comments in error handlers</p>
    <p>/* FIXME: this is a buggy logic, check with alex. */</p>
    <p>/* TODO: this whole thing is extremely brittle. */</p>
    <p>/* If this happens, hell will unleash on earth. */</p>
    <p>/* TODO: are we sure this is OK? */</p>
    <p>/* I really thing we should do a better handling of these * exceptions. I really do. */</p>
    <p>Source code and dataset: http://www.eecg.toronto.edu/failureAnalysis/</p>
    <p>/* I hate there was no piece of comment for code * handling race condition. * God knew what race condition the code dealt with! */</p>
    <p>Thanks!</p>
  </div>
</Presentation>
