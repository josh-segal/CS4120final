<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Parallelizing Time With Polynomial Circuits</p>
    <p>Ryan Williams</p>
    <p>Carnegie Mellon University and</p>
    <p>Microsoft Research (Intern)</p>
  </div>
  <div class="page">
    <p>RED GREEN BLUE ORANGE</p>
  </div>
  <div class="page">
    <p>Parallelism and Serialism: Some Questions</p>
  </div>
  <div class="page">
    <p>Parallelism and Serialism: Some Questions</p>
    <p>To what extent can arbitrary serial computations be parallelized?</p>
  </div>
  <div class="page">
    <p>Parallelism and Serialism: Some Questions</p>
    <p>To what extent can arbitrary serial computations be parallelized?</p>
    <p>To what extent can serial algorithms running in time t(n) be</p>
    <p>parallelized?</p>
    <p>Assuming a robust serial machine model.</p>
  </div>
  <div class="page">
    <p>Parallelism and Serialism: Some Questions</p>
    <p>To what extent can arbitrary serial computations be parallelized?</p>
    <p>To what extent can serial algorithms running in time t(n) be</p>
    <p>parallelized?</p>
    <p>Assuming a robust serial machine model.</p>
    <p>What is the smallest f (n) = o(n) such that a serial time t algorithm</p>
    <p>can be represented by a circuit of depth at most f (t)?</p>
    <p>Note could always have an exponential sized circuit of O(1) depth</p>
    <p>and unbounded fan-in</p>
  </div>
  <div class="page">
    <p>Parallelism and Serialism: Some Questions</p>
    <p>To what extent can arbitrary serial computations be parallelized?</p>
    <p>To what extent can serial algorithms running in time t(n) be</p>
    <p>parallelized?</p>
    <p>Assuming a robust serial machine model.</p>
    <p>What is the smallest f (n) = o(n) such that a serial time t algorithm</p>
    <p>can be represented by a circuit of depth at most f (t)?</p>
    <p>Note could always have an exponential sized circuit of O(1) depth</p>
    <p>and unbounded fan-in</p>
    <p>What is the smallest f such that a serial time t algorithm can be</p>
    <p>represented by a t(n)O(1)-size circuit of depth at most f (t(n))?</p>
    <p>Can circuits with only poly(t) gates speed up serial time t</p>
    <p>computations? 2-d</p>
  </div>
  <div class="page">
    <p>Can circuits with only poly(t) gates</p>
    <p>speed up serial time t computations?</p>
    <p>This is the question we address.</p>
  </div>
  <div class="page">
    <p>Can circuits with only poly(t) gates</p>
    <p>speed up serial time t computations?</p>
    <p>This is the question we address.</p>
    <p>Short Answer:</p>
    <p>YES, ... but some gates in the circuits have unbounded fan-in</p>
  </div>
  <div class="page">
    <p>Prior Work, in brief</p>
    <p>Relatively old area</p>
    <p>All prior work for general computational models focused on extending</p>
    <p>Hopcroft-Paul-Valiants seminal and deep result:</p>
    <p>TIME[t(n)]  SPACE[t(n)/ log t(n)]</p>
  </div>
  <div class="page">
    <p>Prior Work, in brief</p>
    <p>Relatively old area</p>
    <p>All prior work for general computational models focused on extending</p>
    <p>Hopcroft-Paul-Valiants seminal and deep result:</p>
    <p>TIME[t(n)]  SPACE[t(n)/ log t(n)]</p>
    <p>Main Idea of TIME[t(n)]  SPACE[t(n)/ log t(n)]:</p>
  </div>
  <div class="page">
    <p>Prior Work, in brief</p>
    <p>Relatively old area</p>
    <p>All prior work for general computational models focused on extending</p>
    <p>Hopcroft-Paul-Valiants seminal and deep result:</p>
    <p>TIME[t(n)]  SPACE[t(n)/ log t(n)]</p>
    <p>Main Idea of TIME[t(n)]  SPACE[t(n)/ log t(n)]:</p>
    <p>Divide-and-conquer on Computation Graph:</p>
    <p>DAG with a node for each timestep (or block of timesteps)</p>
    <p>Value of node i is state and symbols read/written in step(s)</p>
    <p>corresponding to i</p>
    <p>Arcs: represent read/write/state dependencies</p>
  </div>
  <div class="page">
    <p>Main Idea of TIME[t(n)]  SPACE[t(n)/ log t(n)]</p>
  </div>
  <div class="page">
    <p>Main Idea of TIME[t(n)]  SPACE[t(n)/ log t(n)]</p>
    <p>G1,  t/2 nodes</p>
    <p>G2,  t/2 nodes</p>
    <p>accept/ reject</p>
    <p>in it ia l</p>
    <p>E</p>
    <p>u1 v</p>
    <p>u2</p>
    <p>?</p>
  </div>
  <div class="page">
    <p>Main Idea of TIME[t(n)]  SPACE[t(n)/ log t(n)]</p>
    <p>G1,  t/2 nodes</p>
    <p>G2,  t/2 nodes</p>
    <p>accept/ reject</p>
    <p>in it ia l</p>
    <p>E</p>
    <p>u1 v</p>
    <p>u2</p>
    <p>?</p>
    <p>|E|  t/ log t = Guess values at endpoints of E, recurse on G1 and G2 separately</p>
  </div>
  <div class="page">
    <p>Main Idea of TIME[t(n)]  SPACE[t(n)/ log t(n)]</p>
    <p>G1,  t/2 nodes</p>
    <p>G2,  t/2 nodes</p>
    <p>accept/ reject</p>
    <p>in it ia l</p>
    <p>E</p>
    <p>u1 v</p>
    <p>u2</p>
    <p>?</p>
    <p>|E|  t/ log t = Guess values at endpoints of E, recurse on G1 and G2 separately</p>
    <p>|E| &gt; t/ log t = To get value of v in G2, recurse on G1 for value of u1 and u2</p>
  </div>
  <div class="page">
    <p>Known: Big barriers to this approach</p>
    <p>Lower bounds on how well divide-and-conquer can do</p>
    <p>E.g. To get o(t) depth circuits, need a super-polynomial number of gates</p>
  </div>
  <div class="page">
    <p>Known: Big barriers to this approach</p>
    <p>Lower bounds on how well divide-and-conquer can do</p>
    <p>E.g. To get o(t) depth circuits, need a super-polynomial number of gates</p>
    <p>Intuition:</p>
    <p>Too much information to be stored when one tries to guess all</p>
    <p>possible E in parallel!</p>
  </div>
  <div class="page">
    <p>Random Access TM Model</p>
    <p>(The serial model were going to simulate in parallel)</p>
  </div>
  <div class="page">
    <p>Random Access TM Model</p>
    <p>(The serial model were going to simulate in parallel)</p>
    <p>Have:</p>
    <p>Registers storing O(1) bits each</p>
    <p>Index tape I of O(log t) bits</p>
  </div>
  <div class="page">
    <p>Random Access TM Model</p>
    <p>(The serial model were going to simulate in parallel)</p>
    <p>Have:</p>
    <p>Registers storing O(1) bits each</p>
    <p>Index tape I of O(log t) bits</p>
    <p>In a single step, can:</p>
    <p>Robust model  can simulate log-cost RAMs (unbounded registers) with</p>
    <p>constant factor overhead</p>
  </div>
  <div class="page">
    <p>Main Result</p>
    <p>Time t(n) random access TMs can be simulated by a</p>
    <p>tO(1)-size circuit family of depth O(t/ log t).</p>
    <p>(Note: More general result in paper; can tradeoff depth and size)</p>
  </div>
  <div class="page">
    <p>Main Result</p>
    <p>Time t(n) random access TMs can be simulated by a</p>
    <p>tO(1)-size circuit family of depth O(t/ log t).</p>
    <p>(Note: More general result in paper; can tradeoff depth and size)</p>
    <p>Bad news: Some of the circuits gates have unbounded fan-in.</p>
  </div>
  <div class="page">
    <p>Main Result</p>
    <p>Time t(n) random access TMs can be simulated by a</p>
    <p>tO(1)-size circuit family of depth O(t/ log t).</p>
    <p>(Note: More general result in paper; can tradeoff depth and size)</p>
    <p>Bad news: Some of the circuits gates have unbounded fan-in.</p>
    <p>Good news: Construction is uniform</p>
    <p>Gives explicit, efficiently constructed circuits.</p>
  </div>
  <div class="page">
    <p>Our Approach:</p>
    <p>A less extreme type of divide-and-conquer</p>
  </div>
  <div class="page">
    <p>Our Approach:</p>
    <p>A less extreme type of divide-and-conquer</p>
    <p>Blocks are succinctly representable: O(log t) bits</p>
  </div>
  <div class="page">
    <p>Our Approach:</p>
    <p>A less extreme type of divide-and-conquer</p>
    <p>Blocks are succinctly representable: O(log t) bits</p>
    <p>String these together</p>
    <p>= O(t/ log t) depth over all blocks</p>
  </div>
  <div class="page">
    <p>Local Actions and Blocks</p>
    <p>Define local action of A(x) at step i to be ` = (i, r, I), where</p>
    <p>r is transition, I is description of index tape at step i</p>
    <p>Note |`| = O(log t)</p>
  </div>
  <div class="page">
    <p>Local Actions and Blocks</p>
    <p>Define local action of A(x) at step i to be ` = (i, r, I), where</p>
    <p>r is transition, I is description of index tape at step i</p>
    <p>Note |`| = O(log t)</p>
    <p>Define SA(x) to be the (unique) string of the form</p>
    <p>`0 ~r0 `1 ~r1    `(t/ log t)1 ~r(t/ log t)1,</p>
  </div>
  <div class="page">
    <p>Local Actions and Blocks</p>
    <p>Define local action of A(x) at step i to be ` = (i, r, I), where</p>
    <p>r is transition, I is description of index tape at step i</p>
    <p>Note |`| = O(log t)</p>
    <p>Define SA(x) to be the (unique) string of the form</p>
    <p>`0 ~r0 `1 ~r1    `(t/ log t)1 ~r(t/ log t)1,</p>
    <p>where `i is local action of A(x) at step i  (log t) + 1,</p>
  </div>
  <div class="page">
    <p>Local Actions and Blocks</p>
    <p>Define local action of A(x) at step i to be ` = (i, r, I), where</p>
    <p>r is transition, I is description of index tape at step i</p>
    <p>Note |`| = O(log t)</p>
    <p>Define SA(x) to be the (unique) string of the form</p>
    <p>`0 ~r0 `1 ~r1    `(t/ log t)1 ~r(t/ log t)1,</p>
    <p>where `i is local action of A(x) at step i  (log t) + 1,</p>
    <p>~ri is vector of (log t)  1 transitions taken, starting at step i  (log t) + 2.</p>
  </div>
  <div class="page">
    <p>Local Actions and Blocks</p>
    <p>Define local action of A(x) at step i to be ` = (i, r, I), where</p>
    <p>r is transition, I is description of index tape at step i</p>
    <p>Note |`| = O(log t)</p>
    <p>Define SA(x) to be the (unique) string of the form</p>
    <p>`0 ~r0 `1 ~r1    `(t/ log t)1 ~r(t/ log t)1,</p>
    <p>where `i is local action of A(x) at step i  (log t) + 1,</p>
    <p>~ri is vector of (log t)  1 transitions taken, starting at step i  (log t) + 2.</p>
    <p>I.e. Write O(t/ log t) local actions that are O(log t) steps apart from</p>
    <p>each other. Then add in the transitions for the missing steps.</p>
  </div>
  <div class="page">
    <p>Local Actions and Blocks</p>
    <p>Define local action of A(x) at step i to be ` = (i, r, I), where</p>
    <p>r is transition, I is description of index tape at step i</p>
    <p>Note |`| = O(log t)</p>
    <p>Define SA(x) to be the (unique) string of the form</p>
    <p>`0 ~r0 `1 ~r1    `(t/ log t)1 ~r(t/ log t)1,</p>
    <p>where `i is local action of A(x) at step i  (log t) + 1,</p>
    <p>~ri is vector of (log t)  1 transitions taken, starting at step i  (log t) + 2.</p>
    <p>I.e. Write O(t/ log t) local actions that are O(log t) steps apart from</p>
    <p>each other. Then add in the transitions for the missing steps.</p>
    <p>|SA(x)| = O(t)</p>
  </div>
  <div class="page">
    <p>Local Actions and Blocks</p>
    <p>Define local action of A(x) at step i to be ` = (i, r, I), where</p>
    <p>r is transition, I is description of index tape at step i</p>
    <p>Note |`| = O(log t)</p>
    <p>Define SA(x) to be the (unique) string of the form</p>
    <p>`0 ~r0 `1 ~r1    `(t/ log t)1 ~r(t/ log t)1,</p>
    <p>where `i is local action of A(x) at step i  (log t) + 1,</p>
    <p>~ri is vector of (log t)  1 transitions taken, starting at step i  (log t) + 2.</p>
    <p>I.e. Write O(t/ log t) local actions that are O(log t) steps apart from</p>
    <p>each other. Then add in the transitions for the missing steps.</p>
    <p>|SA(x)| = O(t)</p>
    <p>Define a block to be an `i ~ri substring of SA(x).</p>
  </div>
  <div class="page">
    <p>Sketch of the Simulating Circuit</p>
    <p>Circuit on input x constructs SA(x) in parallel, one block at a time</p>
  </div>
  <div class="page">
    <p>Sketch of the Simulating Circuit</p>
    <p>Circuit on input x constructs SA(x) in parallel, one block at a time</p>
    <p>Circuit implements two procedures, VERIFY and LAST-WRITE:</p>
  </div>
  <div class="page">
    <p>Sketch of the Simulating Circuit</p>
    <p>Circuit on input x constructs SA(x) in parallel, one block at a time</p>
    <p>Circuit implements two procedures, VERIFY and LAST-WRITE:</p>
    <p>symbol  is written at register I in the most recent timestep (over blocks</p>
  </div>
  <div class="page">
    <p>Sketch of the Simulating Circuit</p>
    <p>Circuit on input x constructs SA(x) in parallel, one block at a time</p>
    <p>Circuit implements two procedures, VERIFY and LAST-WRITE:</p>
    <p>symbol  is written at register I in the most recent timestep (over blocks</p>
    <p>Fairly involved procedures</p>
    <p>They invoke a number of deterministic logspace checks on a block</p>
  </div>
  <div class="page">
    <p>Sketch of the Simulating Circuit</p>
    <p>Circuit on input x constructs SA(x) in parallel, one block at a time</p>
    <p>Circuit implements two procedures, VERIFY and LAST-WRITE:</p>
    <p>symbol  is written at register I in the most recent timestep (over blocks</p>
    <p>Fairly involved procedures</p>
    <p>They invoke a number of deterministic logspace checks on a block</p>
    <p>= Simulate a check with an O(log2 t) depth, O(poly(n)) size circuit</p>
  </div>
  <div class="page">
    <p>Sketch of the Simulating Circuit</p>
    <p>Circuit on input x constructs SA(x) in parallel, one block at a time</p>
    <p>Circuit implements two procedures, VERIFY and LAST-WRITE:</p>
    <p>symbol  is written at register I in the most recent timestep (over blocks</p>
    <p>Fairly involved procedures</p>
    <p>They invoke a number of deterministic logspace checks on a block</p>
    <p>= Simulate a check with an O(log2 t) depth, O(poly(n)) size circuit</p>
    <p>Can guess a checks answer, then</p>
    <p>Run the check AND Continue simulation in parallel</p>
  </div>
  <div class="page">
    <p>Sketch of the Simulating Circuit</p>
    <p>Circuit on input x constructs SA(x) in parallel, one block at a time</p>
    <p>Circuit implements two procedures, VERIFY and LAST-WRITE:</p>
    <p>symbol  is written at register I in the most recent timestep (over blocks</p>
    <p>Fairly involved procedures</p>
    <p>They invoke a number of deterministic logspace checks on a block</p>
    <p>= Simulate a check with an O(log2 t) depth, O(poly(n)) size circuit</p>
    <p>Can guess a checks answer, then</p>
    <p>Run the check AND Continue simulation in parallel</p>
    <p>= Checks dont contribute to overall depth by more than a constant 11-f</p>
  </div>
  <div class="page">
    <p>Sketch of VERIFY(`~r, i):</p>
    <p>(Top-down description, starting from output gate)</p>
    <p>Use an AND to simultaneously pick a transition in ~r, AND pick `</p>
  </div>
  <div class="page">
    <p>Sketch of VERIFY(`~r, i):</p>
    <p>(Top-down description, starting from output gate)</p>
    <p>Use an AND to simultaneously pick a transition in ~r, AND pick `</p>
    <p>If ` is picked:</p>
    <p>Use OR to guess the (i  1)th block `~r,</p>
    <p>Call VERIFY(`~r, i  1) to check state and index tape of `.</p>
    <p>Call LAST-WRITE to check that the symbol read in ` is correct.</p>
  </div>
  <div class="page">
    <p>Sketch of VERIFY(`~r, i):</p>
    <p>(Top-down description, starting from output gate)</p>
    <p>Use an AND to simultaneously pick a transition in ~r, AND pick `</p>
    <p>If ` is picked:</p>
    <p>Use OR to guess the (i  1)th block `~r,</p>
    <p>Call VERIFY(`~r, i  1) to check state and index tape of `.</p>
    <p>Call LAST-WRITE to check that the symbol read in ` is correct.</p>
    <p>If the jth component rj of ~r is picked:</p>
    <p>Use OR to guess I, index tape for the step</p>
    <p>Use ` and ~r to check that the state of rj , I are correct</p>
    <p>Call LAST-WRITE on I to check that symbol claimed to be read in rj is correct</p>
  </div>
  <div class="page">
    <p>Sketch of LAST-WRITE(I, i, ):</p>
    <p>Use OR to guess ith block: `i~ri.</p>
    <p>Use AND to simultaneously:</p>
    <p>if so, then verify  is written,</p>
    <p>if not, then call LAST-WRITE(I, i  1, ).</p>
  </div>
  <div class="page">
    <p>Sketch of LAST-WRITE(I, i, ):</p>
    <p>Use OR to guess ith block: `i~ri.</p>
    <p>Use AND to simultaneously:</p>
    <p>if so, then verify  is written,</p>
    <p>if not, then call LAST-WRITE(I, i  1, ).</p>
    <p>Observations:</p>
    <p>Constant number of OR/AND switches between two recursive calls.</p>
    <p>Depth of recursion = O(t/ log t)</p>
  </div>
  <div class="page">
    <p>VERIFY(b1, (t/ log t)  1) VERIFY(b tO(1)</p>
    <p>, (t/ log t)  1)</p>
    <p>LAST-WRITE(I, t/ log t, )</p>
    <p>CHECKS</p>
    <p>LAST-WRITE(I, (t/ log t)  1, )</p>
    <p>LAST-WRITE(I, 1, )</p>
    <p>VERIFY(b tO(1)</p>
    <p>, 1)VERIFY(b1, 1)</p>
    <p>to CHECKS</p>
    <p>to CHECKS</p>
    <p>to CHECKS to CHECKS</p>
    <p>to CHECKS</p>
    <p>log2(t) depth</p>
    <p>tO(1) size</p>
    <p>to CHECKS</p>
    <p>from VERIFY</p>
    <p>VERIFY(b tO(1)</p>
    <p>, t/ log t)</p>
    <p>VERIFY(b1, t/ log t)</p>
    <p>I  {1, . . . , log t},</p>
    <p>all possible blocks of O(log t) bits</p>
    <p>d ep</p>
    <p>th =</p>
    <p>O (t</p>
    <p>/ lo</p>
    <p>g t)</p>
  </div>
  <div class="page">
    <p>Implications for Parallel Simulations</p>
    <p>Corollary. Every log-cost time t RAM can be simulated by a log-cost</p>
    <p>CRCW PRAM in O(t/ log t) time with tO(1) processors.</p>
    <p>Previous parallel simulations required 2(t/ log t) processors</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Allow some unbounded fan-in</p>
    <p>= Get poly(t) size, O(t/ log t) depth circuits, for time t algorithms.</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Allow some unbounded fan-in</p>
    <p>= Get poly(t) size, O(t/ log t) depth circuits, for time t algorithms.</p>
    <p>Can the same be done in the case of bounded fan-in?</p>
    <p>Can we improve upon t/ log t depth?</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Allow some unbounded fan-in</p>
    <p>= Get poly(t) size, O(t/ log t) depth circuits, for time t algorithms.</p>
    <p>Can the same be done in the case of bounded fan-in?</p>
    <p>Can we improve upon t/ log t depth?</p>
    <p>Perhaps possible</p>
    <p>combine our ideas with Hopcroft-Paul-Valiant divide-and-conquer(?)</p>
  </div>
</Presentation>
