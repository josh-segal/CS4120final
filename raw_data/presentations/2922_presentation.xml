<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Efficient Patch-based Auditing for Web Application Vulnerabilities</p>
    <p>Taesoo Kim, Ramesh Chandra, Nickolai Zeldovich</p>
    <p>MIT CSAIL</p>
  </div>
  <div class="page">
    <p>Example: Github</p>
    <p>Github hosts projects (git repository)  Users have own projects  Authentication based on SSH public key</p>
  </div>
  <div class="page">
    <p>Vulnerability: attacker can modify any user's public key</p>
    <p>Publicly announced in March 2012  Unauthorized user modified Ruby-on-Rails</p>
    <p>project after modifying a developer's public key.</p>
  </div>
  <div class="page">
    <p>Problem: who exploited this vulnerability?</p>
    <p>Other attackers may have known about the vulnerability for months or years</p>
    <p>Adversaries could have modified many users' public keys, repositories, etc.</p>
    <p>Ideally, would like to detect past attacks that exploited this vulnerability</p>
  </div>
  <div class="page">
    <p>Github's actual response</p>
    <p>Immediately blocked all users  Asked users to audit own public key</p>
  </div>
  <div class="page">
    <p>Detecting past attacks is hard</p>
    <p>Current tools require manual log analysis  Logs may be incomplete  Logs may be large (Github: 18M req/day)</p>
  </div>
  <div class="page">
    <p>Too many vulnerabilities to inspect manually</p>
    <p>CVE database: 4,000 vulnerabilities per year  Hard enough for administrator to apply patches  Auditing each vulnerability for past attacks is</p>
    <p>impractical</p>
  </div>
  <div class="page">
    <p>Approach: automate auditing using patches</p>
    <p>Insight: security patch renders attack harmless  Technique: compare execution of each request</p>
    <p>before and after patch is applied  Same result: no attack  Different results: potential attack!</p>
  </div>
  <div class="page">
    <p>Example: Github vulnerability</p>
    <p>&lt;form&gt; &lt;input type=&quot;text&quot; name=&quot;key&quot;&gt; &lt;input type=&quot;hidden&quot; value=&quot;taesoo&quot; name=&quot;id&quot; &gt; &lt;/form&gt;</p>
  </div>
  <div class="page">
    <p>Example: Github vulnerability</p>
    <p>def update_pubkey</p>
    <p>@key = PublicKey.find_by_id(params['id'])</p>
    <p>@key.update_attributes(params['key'])</p>
    <p>end</p>
    <p>params = {</p>
    <p>&quot;key&quot; =&gt; &quot;ssh-rsa AAA  &quot;,</p>
    <p>&quot;id&quot; =&gt; &quot;taesoo&quot;</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Example: Github vulnerability</p>
    <p>def update_pubkey</p>
    <p>@key = PublicKey.find_by_id(params['id'])</p>
    <p>@key.update_attributes(params['key'])</p>
    <p>end</p>
    <p>params = {</p>
    <p>&quot;key&quot; =&gt; &quot;ssh-rsa AAA  &quot;,</p>
    <p>&quot;id&quot; =&gt; &quot;taesoo&quot;</p>
    <p>}</p>
    <p>attacker?</p>
  </div>
  <div class="page">
    <p>Example: Github vulnerability</p>
    <p>def update_pubkey</p>
    <p>@key = PublicKey.find_by_id(&quot;victim&quot;)</p>
    <p>@key.update_attributes(&quot;attacker's public key&quot;)</p>
    <p>end</p>
    <p>params = {</p>
    <p>&quot;key&quot; =&gt; &quot;attacker's public key&quot;,</p>
    <p>&quot;id&quot; =&gt; &quot;victim&quot;</p>
    <p>}</p>
    <p>Attackers can overwrite any user's public key, and thus can modify user's repositories.</p>
  </div>
  <div class="page">
    <p>Simplified patch for Github's vulnerability</p>
    <p>def update_pubkey</p>
    <p>- @key = PublicKey.find_by_id(params['id'])</p>
    <p>+ @key = PublicKey.find_by_id(cur_user.id)</p>
    <p>@key.update_attributes(params['key'])</p>
    <p>end</p>
    <p>Login-ed user's id</p>
  </div>
  <div class="page">
    <p>Patch-based auditing finds attack</p>
    <p>def update_pubkey</p>
    <p>- @key = PublicKey.find_by_id(params['id'])</p>
    <p>+ @key = PublicKey.find_by_id(cur_user.id)</p>
    <p>@key.update_attributes(params['key'])</p>
    <p>end</p>
    <p>Replay each request using old(-) &amp; new(+) code  Attack request generates different SQL queries</p>
    <p>UPDATE  WHERE KEY= ID=victim</p>
    <p>UPDATE  WHERE KEY= ID=attacker</p>
    <p>+</p>
  </div>
  <div class="page">
    <p>Challenge: auditing many requests</p>
    <p>Necessary to audit huge amount of requests  Vulnerability may have existed for a long time  Busy web applications may have many requests</p>
    <p>(Github: 18M req/day)</p>
    <p>Auditing one month traffic requires two months  Naive approach requires two re-executions</p>
    <p>(old &amp; new code) per request</p>
  </div>
  <div class="page">
    <p>Contribution</p>
    <p>Efficient patch-based auditing for web apps.</p>
    <p>12  51x faster than original execution for challenging patches  Worst case, auditing one month worth of requests</p>
    <p>takes 14  60 hours</p>
  </div>
  <div class="page">
    <p>Overview of design</p>
    <p>suspect requestsPHP</p>
    <p>Audit log</p>
    <p>Runtime</p>
    <p>HTTPD</p>
    <p>Replayer</p>
    <p>Audit Ctrl</p>
    <p>Auditing patch</p>
    <p>Admin</p>
  </div>
  <div class="page">
    <p>Logging during normal execution</p>
    <p>PHP</p>
    <p>HTML</p>
    <p>rand()</p>
    <p>mysql_query()non-deterministic input external input</p>
    <p>CGI, GET, POST  initial input</p>
  </div>
  <div class="page">
    <p>Auditing a request</p>
    <p>PHP</p>
    <p>rand()</p>
    <p>mysql_query()</p>
    <p>Auditing</p>
    <p>PHP</p>
    <p>rand()</p>
    <p>mysql_query()</p>
    <p>patched</p>
    <p>HTML HTML</p>
    <p>compare?</p>
    <p>patched function</p>
    <p>original</p>
    <p>original function</p>
  </div>
  <div class="page">
    <p>Auditing a request</p>
    <p>PHP</p>
    <p>rand()</p>
    <p>mysql_query()</p>
    <p>Auditing</p>
    <p>PHP</p>
    <p>rand()</p>
    <p>mysql_query()</p>
    <p>patched</p>
    <p>HTML HTML</p>
    <p>compare?</p>
    <p>patched function</p>
    <p>original</p>
    <p>original function</p>
    <p>Naive approach requires two complete re-executions for every request</p>
  </div>
  <div class="page">
    <p>Opportunities to improve auditing performance</p>
    <p>Patch might not affect every request  How to determine affected requests?</p>
    <p>Original and patched runs execute common code  How to share common code during re-execution?</p>
    <p>Multiple requests execute similar code  How to reuse similar code across multiple requests?</p>
  </div>
  <div class="page">
    <p>Key ideas</p>
    <p>Idea 1: Control flow filtering  Auditing only affected requests</p>
    <p>Idea 2: Function-level auditing  Sharing common code during re-execution</p>
    <p>Idea 3: Memoized re-execution  Reusing memoized code across multiple requests</p>
  </div>
  <div class="page">
    <p>Idea 1: Control flow filtering</p>
    <p>Step 1: Normal execution  Record the control flow trace (CFT) of each request</p>
    <p>Step 2: Indexing  Map the control flow trace (CFT) to the basic blocks</p>
    <p>Step 3: Auditing  Compute the basic blocks modified by the patch  Filter out requests if did not execute any patched</p>
    <p>basic blocks</p>
  </div>
  <div class="page">
    <p>Static analysis of source code</p>
    <p>Computing basic blocks of source code</p>
    <p>function get_name() {  return $_GET['name'];  }  if ($_GET['q'] == 'echo') {  echo get_name();  }</p>
    <p>start</p>
  </div>
  <div class="page">
    <p>Static analysis of source code</p>
    <p>Computing basic blocks of source code</p>
    <p>function get_name() {  return $_GET['name'];  }  if ($_GET['q'] == 'echo') {  echo get_name();  }</p>
    <p>JMP,BRK</p>
    <p>start</p>
  </div>
  <div class="page">
    <p>Recording control flow trace</p>
    <p>Normal execution:</p>
    <p>logging control flow trace (CFT) of each request</p>
    <p>function get_name() {  return $_GET['name'];  }  if ($_GET['q'] == 'echo') {  echo get_name();  }</p>
    <p>/s.php?q=test</p>
    <p>start</p>
    <p>'test'!='echo'</p>
    <p>CFT: [ , ] (file, scope, func, #instruction)</p>
  </div>
  <div class="page">
    <p>Computing executed basic blocks</p>
    <p>Basic Blocks</p>
    <p>Indexing:</p>
    <p>computing executed basic blocks of each request</p>
    <p>[ , , ]</p>
    <p>[ ] [ ] [ ]</p>
    <p>function get_name() {  return $_GET['name'];  }</p>
    <p>if ($_GET['q'] == 'echo') {  echo get_name();  }</p>
    <p>/s.php?q=test</p>
  </div>
  <div class="page">
    <p>Computing modified basic blocks</p>
    <p>Auditing:</p>
    <p>compute the basic blocks modified by the patch</p>
    <p>function get_name() { - return $_GET['name']; + return sanitize($_GET['name']);  }  if ($_GET['q'] == 'echo') {  echo get_name();  }</p>
    <p>Basic Blocks</p>
    <p>[ , , ]</p>
    <p>[ ] [ ] [ ]</p>
  </div>
  <div class="page">
    <p>Comparing basic blocks</p>
    <p>Auditing:</p>
    <p>filter out the requests that did not execute patched basic blocks</p>
    <p>Executed Patched</p>
    <p>[ , , ]</p>
    <p>[ ] [ ] [ ]</p>
    <p>[ , , ]</p>
    <p>[ ] [ ] [ ]</p>
  </div>
  <div class="page">
    <p>Summary: control flow filtering</p>
    <p>Recorded requests Affected requests</p>
    <p>modified basic block</p>
    <p>Filtered</p>
  </div>
  <div class="page">
    <p>Idea 2: Function-level auditing</p>
    <p>Optimization 1: sharing common code  Share code up to the patched function</p>
    <p>Optimization 2: early termination  Stop after the last invocation of the patched functions</p>
    <p>PHP PHP</p>
    <p>optimization 1</p>
    <p>optimization 2</p>
    <p>patched function</p>
    <p>original function</p>
  </div>
  <div class="page">
    <p>Function-level auditing</p>
    <p>Auditing</p>
    <p>fork()</p>
    <p>PHP</p>
    <p>compare side-effects?</p>
    <p>Intercept side-effects inside the patched functions  Stop after the last invocation of the patched functions  Compare intercepted side-effects</p>
    <p>patched function</p>
    <p>original function</p>
  </div>
  <div class="page">
    <p>Intercepting side-effects</p>
    <p>class PublicKey {</p>
    <p>function update($key) {</p>
    <p>$this-&gt;last = date();</p>
    <p>echo &quot;updated&quot;;</p>
    <p>$rtn = mysql_query(&quot;UPDATE  $key &quot;);</p>
    <p>return $rtn;</p>
    <p>}</p>
    <p>}</p>
    <p>global writes</p>
    <p>return value external calls (e.g., header, sql-query )</p>
    <p>html output</p>
    <p>&lt;the worst case example&gt;</p>
    <p>(e.g., global, class)</p>
  </div>
  <div class="page">
    <p>Comparing side-effects</p>
    <p>fork()</p>
    <p>PHP</p>
    <p>compare side-effects?</p>
    <p>[output] s:102:&lt;html&gt; .</p>
    <p>[globals] s:29:Fri Sept ; s:6:updated;</p>
    <p>[return] r:1</p>
    <p>Serialized</p>
    <p>[output] s:102:&lt;html&gt; .</p>
    <p>[globals] s:29:Fri Sept ; s:7:patched;</p>
    <p>[return] r:1</p>
    <p>Serialized</p>
    <p>If different, mark the request suspect</p>
    <p>If same, stop and audit next request</p>
  </div>
  <div class="page">
    <p>Summary: function-level auditing</p>
    <p>...Affected requests Naive auditing</p>
    <p>Function-level auditing</p>
    <p>Optimize</p>
  </div>
  <div class="page">
    <p>,, , , ,   ,, , ,  ,,, , ,,,,,,,</p>
    <p>Idea 3: Memoized re-execution</p>
    <p>Motivation: many requests run similar code</p>
    <p>function get_name() {  return $_GET['name'];  }  if ($_GET['q'] == 'echo') {  echo get_name();  }</p>
    <p>start</p>
    <p>CFT: [ ]</p>
  </div>
  <div class="page">
    <p>Idea 3: Memoized re-execution</p>
    <p>Motivation: many requests run similar code</p>
    <p>function get_name() {  return $_GET['name'];  }  if ($_GET['q'] == 'echo') {  echo get_name();  }</p>
    <p>start</p>
    <p>CFT: [ , , , ,  , ]</p>
  </div>
  <div class="page">
    <p>Idea 3: Memoized re-execution</p>
    <p>Motivation: many requests run similar code</p>
    <p>function get_name() {  return $_GET['name'];  }  if ($_GET['q'] == 'echo') {  echo get_name();  }</p>
    <p>start</p>
    <p>CFT: [ , , , ,  , ]</p>
    <p>Control flow group (CFG)</p>
  </div>
  <div class="page">
    <p>Idea 3: Memoized re-execution</p>
    <p>Step 1: normal execution  Record control flow trace (CFT) of each request  Classify the corresponding control flow group (CFG)</p>
    <p>Step 2: auditing (each CFG)  Determine input differences among requests</p>
    <p>(template variables)  Generate a template: efficient way to re-execute</p>
    <p>request given an assignment of template variables  Re-execute each request using the template</p>
  </div>
  <div class="page">
    <p>Determining template variables</p>
    <p>Template variables are input differences among all requests in the same CFG (e.g., GET/POST, CGI variables, )</p>
    <p>(e.g., $GET[name] = Template variable)</p>
  </div>
  <div class="page">
    <p>Generating a template</p>
    <p>function get_name() {  return $_GET['name'];  }  if ($_GET['q'] == 'echo') {  echo get_name();  }</p>
    <p>/s.php?q=echo&amp;name=alice</p>
    <p>start</p>
    <p>Template variable</p>
    <p>Template: [,]</p>
  </div>
  <div class="page">
    <p>Re-executing the template</p>
    <p>return $_GET['name'];  echo return of ;</p>
    <p>(e.g., $GET['name'] = 'bob' and '&lt;script&gt;...')</p>
  </div>
  <div class="page">
    <p>Auditing with template re-execution</p>
    <p>function get_name() { - return $_GET['name']; + return sanitize($_GET['name']);  }  if ($_GET['q'] == 'echo') {  echo get_name();  }</p>
  </div>
  <div class="page">
    <p>Summary: template re-execution</p>
    <p>CFG CFG</p>
    <p>Affected requests</p>
    <p>Template re-execution</p>
    <p>Template</p>
    <p>CFG</p>
  </div>
  <div class="page">
    <p>PHP</p>
    <p>CFG-2</p>
    <p>Optimization: collapsing templates</p>
    <p>Motivation: different CFGs can share common code up to the patched function (given patch)</p>
    <p>PHP</p>
    <p>CFG-1</p>
    <p>PHP</p>
    <p>+ =</p>
    <p>Collapsed CFG (CCFG)</p>
  </div>
  <div class="page">
    <p>CFG CCFG</p>
    <p>Summary: collapsing template</p>
    <p>Template re-execution</p>
    <p>Template</p>
    <p>Auditing</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>POIROT: a prototype for PHP  Based on PHP-5.3.6  Using PHP Vulcan Logic Dumper  15,000 LoC changes</p>
    <p>No changes in application source code</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Does POIROT detect attacks of real vulnerabilities?</p>
    <p>Does POIROT audit efficiently?</p>
    <p>Does POIROT impose reasonable runtime overhead?</p>
  </div>
  <div class="page">
    <p>POIROT detects real attacks</p>
    <p>MediaWiki: detected 5 different types of attacks</p>
    <p>(using realistic Wikipedia traces)  HotCRP: detected 4 information leak vulnerabilities</p>
    <p>(using synthetic workloads)</p>
    <p>CVE Description Detected? F+</p>
    <p>MediaWikiMediaWiki</p>
    <p>BUG Detected? F+</p>
    <p>f30eb Yes 0</p>
    <p>HotCRP</p>
  </div>
  <div class="page">
    <p>POIROT efficiently audits attacks</p>
    <p>CVE Naive</p>
    <p>Time (h) POIROT</p>
    <p>Time (min)</p>
    <p>34 CVEs (security patches 2004 ~ 2011)</p>
    <p>Trace containing 100K Wikipedia requests (3.4 h)</p>
    <p>Auditing time:</p>
    <p>29 CVEs: &lt;0.2 sec  5 CVEs: ~9.2 min (12x ~ 51x faster than the original execution)</p>
    <p>* *</p>
  </div>
  <div class="page">
    <p>Control flow filtering is effective for many patches</p>
    <p>CVE Naive</p>
    <p>Time (h) POIROT</p>
    <p>Time (min)</p>
    <p>34 CVEs (security patches 2004 ~ 2011)</p>
    <p>Trace containing 100K Wikipedia requests (3.4 h)</p>
    <p>Auditing time:</p>
    <p>29 CVEs: &lt;0.2 sec  5 CVEs: ~9.2 min (12x ~ 51x faster than the original execution)</p>
    <p>* *</p>
  </div>
  <div class="page">
    <p>Control flow filtering is effective for many patches</p>
    <p>CVE Naive</p>
    <p>Time (h) POIROT</p>
    <p>Time (min)</p>
    <p>34 CVEs (security patches 2004 ~ 2011)</p>
    <p>Trace containing 100K Wikipedia requests (3.4 h)</p>
    <p>Auditing time:</p>
    <p>29 CVEs: &lt;0.2 sec  5 CVEs: ~9.2 min (12x ~ 51x faster than the original execution)</p>
    <p>* *</p>
    <p>Function-level auditing Memoized re-execution</p>
  </div>
  <div class="page">
    <p>Function-level auditing improves performance</p>
    <p>Naive: 7.3 h  Func-level: 3.5 h</p>
    <p>Re-execute 2  60% (avg. 16%) instructions</p>
    <p>CVE #re-exec. Instructions</p>
    <p>/ #total instructions Func-level</p>
    <p>Re-exec (hour)</p>
  </div>
  <div class="page">
    <p>CVE #CFG #instruction in a template</p>
    <p>/ #total instruction</p>
    <p>Templates reduce re-executed instructions</p>
    <p>100K requests  ~840 #CFG</p>
    <p>Templates contain 0.1% ~ 2.7% (avg. 0.7%) instruction</p>
  </div>
  <div class="page">
    <p>Collapsing reduces number of templates</p>
    <p>CVE #CCFG / #CFG Collapsing time (sec)</p>
    <p>Memoized POIROT (min)</p>
    <p>100K  ~840 #CFG  1 ~ 589 #CCFG</p>
    <p>30.5 s to collapse templates on average</p>
    <p>Auditing 100K requests (3.4h)  avg. 9.2 min</p>
  </div>
  <div class="page">
    <p>POIROT imposes moderate runtime overhead</p>
    <p>Testing with 100K Wikipedia requests</p>
    <p>14.1% latency overhead  15.3% throughput overhead  5.4 KB/req storage overhead (compressed online)</p>
  </div>
  <div class="page">
    <p>Related work  Record-and-replay with patches:</p>
    <p>Warp: repairing web apps with retroactive patching  Rad: fork-and-compare, auditing memory writes</p>
    <p>Testing patched programs:  TACHYON: automatic/live patch testing  Delta execution: validate patched version (split/merge)</p>
    <p>Program slicing (adjustable computation):  Static slicing: all stmts. that possibly affect the variable  Dynamic slicing: all stmts. that really affected the variable</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>POIROT: efficient patch-based auditing system  Detected real attacks in MediaWiki / HotCRP</p>
    <p>without any modification  12  51x faster than original execution</p>
    <p>Three partial re-execution techniques  Control flow filtering  Function-level auditing  Memoized re-execution</p>
  </div>
</Presentation>
