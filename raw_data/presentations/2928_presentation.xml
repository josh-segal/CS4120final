<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Experiences from a Decade of Development</p>
    <p>Philip Levis Stanford University</p>
    <p>@OSDI 2012</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Back to 1999...</p>
    <p>The motes [EmNet nodes] preview a future pervaded by networks of wireless battery-powered sensors that monitor our environment, our machines, and even us. 2</p>
    <p>Information technology (IT) is on the verge of another revolution The use of EmNets [embedded networks] throughout society could well dwarf previous milestones. 1</p>
  </div>
  <div class="page">
    <p>TinyOS</p>
    <p>Idea: operating system for sensor networks  Microcontrollers (bah, virtual memory and 32-bit words)  Low-power (2A - 4mA)  Wireless communication (good luck with that)  Started as Perl scripts used by a handful of academics</p>
    <p>13 years later...  ~25,000 downloads a year, hundreds of thousands of nodes!  Worldwide community of hundreds of contributors!  Hundreds of research papers!  The Internet of Things!</p>
  </div>
  <div class="page">
    <p>This Talk</p>
    <p>Two design principles for embedded software  Minimize resource use  Structure interfaces and code to prevent bugs</p>
    <p>A technical result: static virtualization  A lesson: avoid the island syndrome</p>
  </div>
  <div class="page">
    <p>TinyOS is the work of hundreds of contributors over a decade. (of which I am only one, the core WG chair, who joined 18 months in)</p>
    <p>This paper and talk are my personal opinions and observations.</p>
    <p>Disclaimer</p>
  </div>
  <div class="page">
    <p>This Talk</p>
    <p>Two design principles for embedded software  Minimize resource use  Structure interfaces and code to prevent bugs</p>
    <p>A technical result: static virtualization  A lesson: avoid the island syndrome</p>
  </div>
  <div class="page">
    <p>Minimize Resource Use</p>
    <p>Model ROM RAM Sleep Price</p>
    <p>F2002 1kB 128B 1.3A $0.94</p>
    <p>F1232 8kB 256B 1.6A $2.73</p>
    <p>F155 16kB 512B 2.0A $6.54</p>
    <p>F168 48kB 2048B 2.0A $9.11</p>
    <p>F1611 48kB 10240B 2.0A $12.86</p>
    <p>TI MSP430 Microcontrollers</p>
  </div>
  <div class="page">
    <p>Model ROM RAM Sleep Price</p>
    <p>F2002 1kB 128B 1.3A $0.94</p>
    <p>F1232 8kB 256B 1.6A $2.73</p>
    <p>F155 16kB 512B 2.0A $6.54</p>
    <p>F168 48kB 2048B 2.0A $9.11</p>
    <p>F1611 48kB 10240B 2.0A $12.86</p>
    <p>TI MSP430 Microcontrollers</p>
    <p>Minimize Resource Use</p>
  </div>
  <div class="page">
    <p>Model ROM RAM Sleep Price</p>
    <p>F2002 1kB 128B 1.3A $0.94</p>
    <p>F1232 8kB 256B 1.6A $2.73</p>
    <p>F155 16kB 512B 2.0A $6.54</p>
    <p>F168 48kB 2048B 2.0A $9.11</p>
    <p>F1611 48kB 10240B 2.0A $12.86</p>
    <p>Model ROM RAM Sleep Price</p>
    <p>LM2S600 32kB 8kB 950A $2.73</p>
    <p>LM3S1608 128kB 32kB 950A $4.59</p>
    <p>LM3S1968 256kB 64kB 950A $6.27</p>
    <p>TI MSP430 Microcontrollers TI ARM CortexM3 Processors</p>
    <p>Minimize Resource Use</p>
  </div>
  <div class="page">
    <p>Model ROM RAM Sleep Price</p>
    <p>F2002 1kB 128B 1.3A $0.94</p>
    <p>F1232 8kB 256B 1.6A $2.73</p>
    <p>F155 16kB 512B 2.0A $6.54</p>
    <p>F168 48kB 2048B 2.0A $9.11</p>
    <p>F1611 48kB 10240B 2.0A $12.86</p>
    <p>Model ROM RAM Sleep Price</p>
    <p>LM2S600 32kB 8kB 950A $2.73</p>
    <p>LM3S1608 128kB 32kB 950A $4.59</p>
    <p>LM3S1968 256kB 64kB 950A $6.27</p>
    <p>TI MSP430 Microcontrollers TI ARM CortexM3 Processors</p>
    <p>Minimize Resource Use</p>
  </div>
  <div class="page">
    <p>Model ROM RAM Sleep Price</p>
    <p>F2002 1kB 128B 1.3A $0.94</p>
    <p>F1232 8kB 256B 1.6A $2.73</p>
    <p>F155 16kB 512B 2.0A $6.54</p>
    <p>F168 48kB 2048B 2.0A $9.11</p>
    <p>F1611 48kB 10240B 2.0A $12.86</p>
    <p>Model ROM RAM Sleep Price</p>
    <p>LM2S600 32kB 8kB 950A $2.73</p>
    <p>LM3S1608 128kB 32kB 950A $4.59</p>
    <p>LM3S1968 256kB 64kB 950A $6.27</p>
    <p>TI MSP430 Microcontrollers TI ARM CortexM3 Processors</p>
    <p>Sleep current necessitates microcontrollers. Advanced applications run into ROM/RAM limits.</p>
    <p>Minimize Resource Use</p>
  </div>
  <div class="page">
    <p>Two Principles</p>
  </div>
  <div class="page">
    <p>Vision</p>
  </div>
  <div class="page">
    <p>Black Box</p>
    <p>Sensor Readings Wireless</p>
    <p>??</p>
    <p>Debugging these systems is exceedingly hard.</p>
    <p>Output ?</p>
  </div>
  <div class="page">
    <p>This Talk</p>
    <p>Two design principles for embedded software  Minimize resource use  Structure interfaces and code to prevent bugs</p>
    <p>A technical result: static virtualization  A lesson: avoid the island syndrome</p>
  </div>
  <div class="page">
    <p>Static Virtualization</p>
    <p>Operating System</p>
  </div>
  <div class="page">
    <p>Static Virtualization</p>
    <p>Operating System</p>
    <p>A pplicatio</p>
    <p>n</p>
  </div>
  <div class="page">
    <p>Static Virtualization</p>
    <p>Operating System</p>
    <p>A pplicatio</p>
    <p>n</p>
  </div>
  <div class="page">
    <p>Static Virtualization</p>
    <p>Operating System</p>
    <p>A pplicatio</p>
    <p>n</p>
  </div>
  <div class="page">
    <p>Static Virtualization</p>
    <p>Operating System</p>
    <p>A pplicatio</p>
    <p>n</p>
  </div>
  <div class="page">
    <p>Static Virtualization</p>
    <p>Operating System</p>
    <p>A pplicatio</p>
    <p>n</p>
    <p>Allocates exact RAM  No pointers  Cross-call optimization  Dead code elimination  Compile-time certainty</p>
  </div>
  <div class="page">
    <p>Result</p>
    <p>Year Version Multihop yield</p>
    <p>aSzewczyk et al. An Analysis of a Large Scale Habitat Monitoring Application. SenSys 2004. The multi-hop burrow motes perform worse (with a median yield of 58% ) but within tolerance</p>
    <p>bWerner-Allen et al. Fidelity and Yield in a Volcano Monitoring Sensor Network. OSDI 2006. the median event yield was 68.5% (events, not packets)</p>
    <p>cChipara et al. Reliable Clinical Monitoring using Wireless Sensor Networks: Experiences in a Step-down Hospital Unit. Sensys 2010. the system achieved a median network reliability of 99.68% (range 95.2%  100%). In contrast, the sensing reliability was significantly lower.</p>
  </div>
  <div class="page">
    <p>Result</p>
    <p>Year Version Multihop yield</p>
    <p>aSzewczyk et al. An Analysis of a Large Scale Habitat Monitoring Application. SenSys 2004. The multi-hop burrow motes perform worse (with a median yield of 58% ) but within tolerance</p>
    <p>bWerner-Allen et al. Fidelity and Yield in a Volcano Monitoring Sensor Network. OSDI 2006. the median event yield was 68.5% (events, not packets)</p>
    <p>cChipara et al. Reliable Clinical Monitoring using Wireless Sensor Networks: Experiences in a Step-down Hospital Unit. Sensys 2010. the system achieved a median network reliability of 99.68% (range 95.2%  100%). In contrast, the sensing reliability was significantly lower.</p>
    <p>Static virtualization enabled applications to be highly robust, dependable, and efficient.</p>
  </div>
  <div class="page">
    <p>This Talk</p>
    <p>Two design principles for embedded software  Minimize resource use  Structure interfaces and code to prevent bugs</p>
    <p>A technical result: static virtualization  A lesson: avoid the island syndrome</p>
  </div>
  <div class="page">
    <p>Applications</p>
  </div>
  <div class="page">
    <p>Research vs. Practice</p>
    <p>TinyOS technically focused on enabling users to build larger, more complex applications</p>
    <p>Doing so increased the learning curve to building simple ones</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>Fi rs</p>
    <p>t T iny</p>
    <p>OS co</p>
    <p>de</p>
    <p>AS PL</p>
    <p>OS p</p>
    <p>ap er</p>
    <p>v0 .6</p>
    <p>NE ST</p>
    <p>b oo</p>
    <p>tca m</p>
    <p>p v1</p>
    <p>v1 .1</p>
    <p>Co re</p>
    <p>W G</p>
    <p>fo rm</p>
    <p>s</p>
    <p>v1 .1</p>
    <p>NE ST</p>
    <p>co nc</p>
    <p>lud es</p>
    <p>v2 .0</p>
    <p>b et</p>
    <p>a1 v2</p>
    <p>et a2</p>
    <p>v2 .0</p>
    <p>v2 .0</p>
    <p>v2 .1</p>
    <p>v2 .1</p>
    <p>atomic, uniqueCount</p>
    <p>generics, nx_types</p>
    <p>safe, threads</p>
    <p>nesC, bidirectional and parameterized interfaces</p>
    <p>Timeline</p>
  </div>
  <div class="page">
    <p>Fi rs</p>
    <p>t T iny</p>
    <p>OS co</p>
    <p>de</p>
    <p>AS PL</p>
    <p>OS p</p>
    <p>ap er</p>
    <p>v0 .6</p>
    <p>NE ST</p>
    <p>b oo</p>
    <p>tca m</p>
    <p>p v1</p>
    <p>v1 .1</p>
    <p>Co re</p>
    <p>W G</p>
    <p>fo rm</p>
    <p>s</p>
    <p>v1 .1</p>
    <p>NE ST</p>
    <p>co nc</p>
    <p>lud es</p>
    <p>v2 .0</p>
    <p>b et</p>
    <p>a1 v2</p>
    <p>et a2</p>
    <p>v2 .0</p>
    <p>v2 .0</p>
    <p>v2 .1</p>
    <p>v2 .1</p>
    <p>atomic, uniqueCount</p>
    <p>generics, nx_types</p>
    <p>safe, threads</p>
    <p>nesC, bidirectional and parameterized interfaces</p>
    <p>Timeline</p>
  </div>
  <div class="page">
    <p>Statically Virtualized Timer (TinyOS 2.x)</p>
    <p>AppP.nc</p>
    <p>T = new TimerC() AppP.Timer -&gt; TimerC.Timer</p>
    <p>AppC.nc</p>
    <p>Control.start() { Timer.start(..) }</p>
    <p>Timer.fired() { send_packet(); }</p>
  </div>
  <div class="page">
    <p>Implementation (TinyOS 2.x)</p>
    <p>AppP.nc #define TS unique(T) TimerC.Timer = TimerP.Timer[TS]</p>
    <p>TimerC.nc</p>
    <p>#define NT uCount(T) timer_t ts[NT];</p>
    <p>clock_interrupt { update_ts() for i = 0 to NT-1 if (ts[i].fire) Timer[i].fired(); }</p>
    <p>Timer[i].start(...) { startTimer(i, ..) }</p>
    <p>TimerP.nc</p>
    <p>T = new TimerC() AppP.Timer -&gt; TimerC.Timer</p>
    <p>AppC.nc</p>
    <p>Control.start() { Timer.start(..) }</p>
    <p>Timer.fired() { send_packet(); }</p>
  </div>
  <div class="page">
    <p>Implementation (TinyOS 2.x)</p>
    <p>AppP.nc #define TS unique(T) TimerC.Timer = TimerP.Timer[TS]</p>
    <p>TimerC.nc</p>
    <p>#define NT uCount(T) timer_t ts[NT];</p>
    <p>clock_interrupt { update_ts() for i = 0 to NT-1 if (ts[i].fire) Timer[i].fired(); }</p>
    <p>Timer[i].start(...) { startTimer(i, ..) }</p>
    <p>TimerP.nc</p>
    <p>T = new TimerC() AppP.Timer -&gt; TimerC.Timer</p>
    <p>AppC.nc</p>
    <p>Control.start() { Timer.start(..) }</p>
    <p>Timer.fired() { send_packet(); }</p>
  </div>
  <div class="page">
    <p>TinyOS 0.6</p>
    <p>timer_t ts;</p>
    <p>TIMER_START(...) { set_ts(); init_interrupt(); }</p>
    <p>clock_interrupt { update_ts() TIMER_FIRE(); }</p>
    <p>APP_START() { APP_TIMER_INIT(..); }</p>
    <p>APP_TIMER() { send_packet(); }</p>
    <p>APP.c TIMER.c</p>
    <p>APP_TIMER_INIT TIMER_START TIMER_FIRE APP_TIMER</p>
    <p>APP.desc</p>
  </div>
  <div class="page">
    <p>Code Evolution</p>
    <p>Code evolved to use nesC features in more complex and intricate ways  Improved software dependability  Allowed more complex applications  Served the needs of the community</p>
    <p>Increased barrier to entry: island syndrome</p>
  </div>
  <div class="page">
    <p>Death by Components</p>
    <p>Fine-grained component toolkits are great for building and evolving a system</p>
    <p>The end result is difficult for a new user to understand: increases the learning curve</p>
    <p>Need to transition to structurally simpler implementations</p>
  </div>
  <div class="page">
    <p>Death by Components</p>
    <p>TimerC</p>
    <p>AlarmCounterP</p>
    <p>AlarmSyncC</p>
    <p>HplTimer0C</p>
    <p>HplTimer0P McuSleepC</p>
    <p>AlarmAsyncP</p>
    <p>VirtualizeTimerC</p>
    <p>CounterToTimeC AlarmToTimerC</p>
  </div>
  <div class="page">
    <p>Another Approach</p>
    <p>TimerC</p>
    <p>McuSleepCHplAlarmP</p>
    <p>TimerP</p>
  </div>
  <div class="page"/>
  <div class="page"/>
  <div class="page">
    <p>TinyOS</p>
    <p>Tremendously successful academic project  Started as Perl scripts used by a handful of academics  Now ~100 downloads a day, hundreds of thousands of nodes  Has a worldwide community of hundreds of contributors</p>
    <p>But it could have been more so  Missed being a platform for simple sensing apps (Arduino)  Missed being a platform for the Internet of Things (Contiki)  Applications became hard applications  Should have focused on the simple as much as the complex</p>
    <p>(the island syndrome)</p>
  </div>
  <div class="page">
    <p>TinyOS is the work of hundreds of contributors over a decade. (of which I am only one, the core WG chair, who joined 18 months in)</p>
    <p>This paper and talk are my personal opinions and observations.</p>
    <p>Disclaimer</p>
  </div>
  <div class="page"/>
  <div class="page">
    <p>I'd like to especially acknowledge Jason Hill, David Culler, David Gay, Cory Sharp, Eric Brewer, Shankar Sastry, Joe Polastre, Vlado Handziski, Jan Heinrich-Hauer, Kevin Klues, David Moss, Omprakash Gnawali, Jonathan Hui, John Regehr, Matt Welsh, Alec Woo, Robert Szewczyk, Kamin Whitehouse, Philip Buonadonna, Ben Greenstein, Miklos Maroti, Andreas Koepke, and Janos Sallai, as well as Razvan Musaloiu-E., JeongGil Ko, Philipp Huppertz, Antonio Linan, Steve Ayers, Kristin Wright, Steven DawsonHaggerty, Jan Beutel, Branislav Kusy, Prabal Dutta, Gilman Tolle, Thomas Schmid, Chad Metcalf, Henri Dubois-Ferriere, Deepak Ganesan, Laurynas Riliskis, Eric Decker, Martin Turon, and Peter Bigot.</p>
    <p>TinyOS is also deeply indebted to its users, their bug reports, feature requests, and hard work.</p>
  </div>
</Presentation>
