<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>An Efficient Nominal Unification Algorithm</p>
    <p>Jordi Levy IIIA, CSIC, Barcelona, Spain</p>
    <p>Mateu Villaret IMA, UdG, Girona, Spain</p>
    <p>RTA10, Edinburgh</p>
  </div>
  <div class="page">
    <p>Related Work</p>
    <p>Nominal techniques [Gabbay and Pitts, 2001...]</p>
    <p>Nominal Unification [Urban, Pitts and Gabbay, 2003]</p>
    <p>Nominal Unification is polynomial [Calves and Fernandez, 2008]</p>
    <p>Nominal Unification is quadratic (by reduction to Higher-Order Pattern Unification) [Levy and Villaret, 2008]</p>
    <p>Nominal Unification is quadratic (by mimicking Paterson-Wegman algorithm) [this paper, and independently Calves and Fernandez, 2010]</p>
    <p>Equivariant Unification [Cheney, 2005]</p>
    <p>Permissive Nominal Unification [Dowek, Gabbay and Mulligan, 2009]</p>
  </div>
  <div class="page">
    <p>Paterson-Wegman Algorithm</p>
    <p>X Y</p>
    <p>g h</p>
    <p>f</p>
    <p>Z a</p>
    <p>g h</p>
    <p>f</p>
  </div>
  <div class="page">
    <p>Paterson-Wegman Algorithm</p>
    <p>X Y</p>
    <p>g h</p>
    <p>f</p>
    <p>Z a</p>
    <p>g h</p>
    <p>f</p>
  </div>
  <div class="page">
    <p>Paterson-Wegman Algorithm</p>
    <p>X Y</p>
    <p>g h</p>
    <p>f</p>
    <p>Z a</p>
    <p>g h</p>
    <p>f</p>
  </div>
  <div class="page">
    <p>Paterson-Wegman Algorithm</p>
    <p>X Y</p>
    <p>g h</p>
    <p>f</p>
    <p>Z a</p>
    <p>g h</p>
    <p>f</p>
  </div>
  <div class="page">
    <p>Paterson-Wegman Algorithm</p>
    <p>X Y</p>
    <p>g h</p>
    <p>f</p>
    <p>Z a</p>
    <p>g h</p>
    <p>f</p>
  </div>
  <div class="page">
    <p>Paterson-Wegman Algorithm as Transformations</p>
    <p>X Y</p>
    <p>g h</p>
    <p>f</p>
    <p>Z a</p>
    <p>g h</p>
    <p>f</p>
  </div>
  <div class="page">
    <p>Paterson-Wegman Algorithm as Transformations</p>
    <p>X Y</p>
    <p>g h</p>
    <p>f</p>
    <p>Z a</p>
    <p>g h</p>
    <p>f</p>
    <p>H3 H4</p>
    <p>H1</p>
    <p>H7</p>
    <p>H5 H6</p>
    <p>H2</p>
  </div>
  <div class="page">
    <p>Paterson-Wegman Algorithm as Transformations</p>
    <p>X Y</p>
    <p>g h</p>
    <p>f</p>
    <p>Z a</p>
    <p>g h</p>
    <p>f</p>
    <p>H3 H4</p>
    <p>H1</p>
    <p>H7</p>
    <p>H5 H6</p>
    <p>H2</p>
    <p>{H1} = f (H3, H4) {H2} = f (H5, H6) {H3} = g(X) {H5} = g(Z) {H6} = h(Z, H7) {H4} = h(Y , X) {X} =  {H7} = a {Y} =  {Z} =  H1 = H2</p>
  </div>
  <div class="page">
    <p>Paterson-Wegman Algorithm as Transformations</p>
    <p>X Y</p>
    <p>g h</p>
    <p>f</p>
    <p>Z a</p>
    <p>g h</p>
    <p>f</p>
    <p>H3 H4</p>
    <p>H1</p>
    <p>H7</p>
    <p>H5 H6</p>
    <p>H2</p>
    <p>{H1, H2} = f (H3, H4) {H2} = f (H5, H6) {H3} = g(X) {H5} = g(Z) {H6} = h(Z, H7) {H4} = h(Y , X) {X} =  {H7} = a {Y} =  {Z} =  H3 = H5 H4 = H6</p>
  </div>
  <div class="page">
    <p>Paterson-Wegman Algorithm as Transformations</p>
    <p>Simplification:</p>
    <p>{X1, X</p>
    <p>}</p>
    <p>{X1, X</p>
    <p>Ym = Zm</p>
    <p>Variable:</p>
    <p>{X1, X</p>
    <p>}</p>
    <p>={X1, X</p>
  </div>
  <div class="page">
    <p>Nominal Terms</p>
    <p>Terms:</p>
    <p>t ::= a | f (t1, . . . , tn) |a.t | X</p>
  </div>
  <div class="page">
    <p>Nominal Terms</p>
    <p>Terms:</p>
    <p>t ::= a | f (t1, . . . , tn) |a.t | X</p>
    <p>-Equality:</p>
    <p>a  a (-atom)</p>
    <p>a#X  for all a such that a 6= a</p>
    <p>X    X (-susp.)</p>
    <p>t1  t</p>
    <p>n</p>
    <p>f(t1, . . . , tn)  f(t</p>
    <p>n) (-application)</p>
    <p>t  t</p>
    <p>a.t  a.t (-abst-1)</p>
    <p>a 6= a  t  (a a)t  a#t</p>
    <p>a.t  a.t (-abst-2)</p>
  </div>
  <div class="page">
    <p>Nominal Terms</p>
    <p>Terms:</p>
    <p>t ::= a | f (t1, . . . , tn) |a.t | X</p>
    <p>-Equality:</p>
    <p>a  a (-atom)</p>
    <p>a#X  for all a such that a 6= a</p>
    <p>X    X (-susp.)</p>
    <p>t1  t</p>
    <p>n</p>
    <p>f(t1, . . . , tn)  f(t</p>
    <p>n) (-application)</p>
    <p>t  t</p>
    <p>a.t  a.t (-abst-1)</p>
    <p>a 6= a  t  (a a)t  a#t</p>
    <p>a.t  a.t (-abst-2)</p>
    <p>Freshness:</p>
    <p>a 6= a</p>
    <p>a#a (#-atom)</p>
    <p>(1a #X)</p>
    <p>a#  X (#-susp.)</p>
    <p>a#t1     a#tn  a#f(t1, . . . , tn)</p>
    <p>(#-application)</p>
    <p>a#a.t (#-abst-1)</p>
    <p>a 6= a  a#t</p>
    <p>a#a.t (#-abst-2)</p>
  </div>
  <div class="page">
    <p>Three Simplifications</p>
    <p>Lemma 1</p>
    <p>P {a#t} and P {a.b.t ?  b.b.t} are equivalent</p>
    <p>.... t  t</p>
    <p>a#t .... (lemma)</p>
    <p>b#(a b) t</p>
    <p>b.t  a.(a b) t (-abst-2)</p>
    <p>a#t</p>
    <p>a#b.t (#-abst-2)</p>
    <p>a.b.t  b.b.t (-abst-2)</p>
  </div>
  <div class="page">
    <p>Three Simplifications</p>
    <p>Lemma 1</p>
    <p>P {a#t} and P {a.b.t ?  b.b.t} are equivalent</p>
    <p>Lemma 2</p>
    <p>P {t ?  (a b)u} and P {a.b.t</p>
    <p>?  b.a.u} are equivalent</p>
    <p>t  (a b)u</p>
    <p>b.t  b.(a b)u (-abst-1)</p>
    <p>a#a.u (#-abst-1)</p>
    <p>a.b.t  b.a.u (-abst-2)</p>
  </div>
  <div class="page">
    <p>Three Simplifications</p>
    <p>Lemma 1</p>
    <p>P {a#t} and P {a.b.t ?  b.b.t} are equivalent</p>
    <p>Lemma 2</p>
    <p>P {t ?  (a b)u} and P {a.b.t</p>
    <p>?  b.a.u} are equivalent</p>
    <p>Lemma 3</p>
    <p>P {a.t ?  u} and P {a.X</p>
    <p>?  u, X</p>
    <p>?  t} are equivalent</p>
    <p>P {f (. . . , ti, . . . ) ?  u} and P {f (. . . , X, . . . )</p>
    <p>?  u, X</p>
    <p>?  ti} are</p>
    <p>equivalent,</p>
    <p>P {(a b) t ?  u} and P {(a b) X</p>
    <p>?  u, X</p>
    <p>?  t} are equivalent,</p>
    <p>P {t1 ?  t2} and P {X</p>
    <p>?  t1, X</p>
    <p>?  t2} are equivalent, and</p>
    <p>P {Y1 ?  Y2} and [Y1 7 Y2]P are equivalent.</p>
  </div>
  <div class="page">
    <p>Three Simplifications</p>
    <p>Theorem</p>
    <p>There exists a linear reduction from Nominal Unification to a simplified version of Nominal Unification where all equations are of</p>
    <p>the form X ?  a, X</p>
    <p>?  f (Y1, . . . , Yn) or X</p>
    <p>?  a.Y .</p>
  </div>
  <div class="page">
    <p>Replacings</p>
    <p>Definition of Replacing</p>
    <p>L ::= Id | (a  b) :: L | L1 L2 | L 1</p>
    <p>Predicate t =L u defined inductively as:</p>
    <p>t =Id u, if t  u,</p>
    <p>t =(ab)::L u, if a.t =L b.u,</p>
    <p>t =L1L2 u, if v . t =L1 v  v =L2 u</p>
    <p>t =L1 u, if u =L t.</p>
  </div>
  <div class="page">
    <p>Replacings</p>
    <p>Definition of Replacing</p>
    <p>L ::= Id | (a  b) :: L | L1 L2 | L 1</p>
    <p>Predicate t =L u defined inductively as:</p>
    <p>t =Id u, if t  u,</p>
    <p>t =(ab)::L u, if a.t =L b.u,</p>
    <p>t =L1L2 u, if v . t =L1 v  v =L2 u</p>
    <p>t =L1 u, if u =L t.</p>
    <p>For simple replacings:</p>
    <p>t =(a1b1)::::(anbn)::Id u</p>
    <p>written t =(a1b1)...(anbn) u</p>
    <p>iff an.   a1.t  bn.   b1.u</p>
  </div>
  <div class="page">
    <p>Permutations vs. Replacings</p>
    <p>Definition of Permutation Associated to a Replacing</p>
    <p>Given L, define the permutation L as</p>
    <p>Id = Id</p>
    <p>(ab)::L = (a Lb)L</p>
    <p>Lemma</p>
    <p>Given t, u and L = (a1  b1)   (an  bn) t =L u iff</p>
    <p>t  Lu and</p>
    <p>for any i = 1, . . . , n, if ai 6= (ai+1bi+1)...(anbn)bj for all j = i, . . . , 1, then ai#(ai+1bi+1)...(anbn)u</p>
  </div>
  <div class="page">
    <p>Permutations vs. Replacings</p>
    <p>Lemma</p>
    <p>t =(a1b1)(anbn) u iff</p>
    <p>t  (a1b1)(anbn)u and</p>
    <p>i = 1, . . . , n. (j = i, . . . , 1. ai 6= (ai+1bi+1)...(anbn)bj)  ai#(ai+1bi+1)...(anbn)u</p>
    <p>(ab) = (ba) = (ba)(ab) = (ab)(ba) = (ab)(ab)</p>
    <p>= (a b) = (b a)</p>
    <p>However, assuming a 6= b, we have</p>
    <p>t =(ab) u  t =(ab)(ab) u  t = (a b)u  a#u t =(ba) u  t =(ba)(ba) u  t = (a b)u  b#u</p>
    <p>t =(ba)(ab) u  t =(ab)(ba) u  t = (a b)u</p>
  </div>
  <div class="page">
    <p>Sets of Rewritten and Forbidden Atoms</p>
    <p>Definition</p>
    <p>Given L, define</p>
    <p>Rew(L) = {(a  b)  AA | a 6= b a =L b}</p>
    <p>For(L) = {a  A | (a =L a)}</p>
    <p>Lemma</p>
    <p>t, u. t =L u  t =L u iff</p>
    <p>Rew(L) = Rew(L) and For(L) = For(L)</p>
  </div>
  <div class="page">
    <p>Computing Rew(L) and For(L)</p>
    <p>Rew(Id) = For(Id) =</p>
    <p>Rew ( (a  b) :: L</p>
    <p>) = Rew(L) \{a  c | c  A}\{c  b | c  A}</p>
    <p>{ {a  b} if a 6= b  if a = b</p>
    <p>For ( (a  b) :: L</p>
    <p>) = For(L){c | a  c  Rew(L) c  b  Rew(L)}</p>
    <p>Rew(L1 L2) = {a  c | b  A. a  b  Rew(L1)  b  c  Rew(L2)}</p>
    <p>{a  b | a  b  Rew(L1)b 6 For(L2)} {a  b | a  b  Rew(L2)a 6 For(L1)}</p>
    <p>For(L1 L2) = For(L1)For(L2)</p>
    <p>Rew(L1) = {(b  a) | (a  b)  Rew(L)}</p>
    <p>For(L1) = For(L)</p>
  </div>
  <div class="page">
    <p>A Paterson-Wegman Style Algorithm</p>
    <p>Application:</p>
    <p>{L1X1, L1X</p>
    <p>=</p>
    <p>{ L1X1, L1X</p>
    <p>L1LX2, L1LL12 L</p>
    <p>}</p>
    <p>= f (Y1, ...,</p>
    <p>Y1 =L1LL12 Z1</p>
    <p>...</p>
    <p>Ym =L1LL12 Zm</p>
    <p>Abstraction: {L1X1, L1X</p>
    <p>=</p>
    <p>{ L1X1, L1X</p>
    <p>L1LX2, L1LL12 L</p>
    <p>}</p>
    <p>= a.Y</p>
    <p>Y =(ab)::(L1LL12 ) Z</p>
    <p>Atom: {L1X1, L1X</p>
    <p>=</p>
    <p>{ L1X1, L1X</p>
    <p>L1LX2, L1LL12 L</p>
    <p>}</p>
    <p>= a</p>
    <p>a = L1LL</p>
    <p>1 2</p>
    <p>b</p>
    <p>Variable: {L1X1, L1X</p>
    <p>=</p>
    <p>{ L1X1, L1X</p>
    <p>L1LX2, L1LL12 L</p>
    <p>}</p>
    <p>= t</p>
  </div>
  <div class="page">
    <p>Results</p>
    <p>Soundness and Completeness</p>
    <p>P is solvable iff the rules transform P into a set of the form{ {L11</p>
    <p>X 11 , . . . , Lr11 X</p>
    <p>r1 1 } = t1,    ,{L1mX</p>
    <p>rm m } = tm</p>
    <p>a1 =L1 b1, . . . , an =Ln bn</p>
    <p>}</p>
    <p>where for i = 1, . . . , n, ai =Li bi holds, and</p>
    <p>for i = 1, . . . , m, j = 1, . . . , ri, ti =Lj i</p>
    <p>X j i are solvable.</p>
    <p>Reconstruction of the Solution</p>
    <p>When P is solvable, then set of equations ti =Lj</p>
    <p>i</p>
    <p>X j i encode a solution.</p>
    <p>Complexity</p>
    <p>The size of the DAG representing the new set of equations is O(|P|), and it can be obtained in time O(|P|)</p>
  </div>
  <div class="page">
    <p>Forbidden Atoms in a Variable</p>
    <p>Compute For(X) as the minimal set satisfy 1</p>
    <p>If P contains {L1X1, . . . , Lr Xr} = t, then</p>
    <p>L 1 j</p>
    <p>( Li</p>
    <p>( For(Xi)</p>
    <p>) For(Li)</p>
    <p>)  For(Xj)</p>
    <p>Lemma</p>
    <p>For a set of equations of the form {LX, . . .} = t and a =L b, we can compute For(X) for all variables in quadratic time.</p>
  </div>
  <div class="page">
    <p>An Example</p>
    <p>Consider a.b.X ?  b.b.X</p>
  </div>
  <div class="page">
    <p>An Example</p>
    <p>Consider a. b.X</p>
    <p>Y3</p>
    <p>Y1</p>
    <p>? b. b.X</p>
    <p>Y4</p>
    <p>Y2</p>
    <p>After the three simplification we get:</p>
    <p>{X} = , {Y1} = a.Y3 {Y2} = b.Y4 {Y3} = b.X {Y4} = b.X Y1 =Id Y2</p>
  </div>
  <div class="page">
    <p>An Example</p>
    <p>Consider a.b.X ?  b.b.X</p>
    <p>{X} = , {Y1} = a.Y3 {Y2} = b.Y4 {Y3} = b.X {Y4} = b.X Y1 =Id Y2</p>
    <p>{X} = , {Y1, Y2} = a.Y3 {Y3} = b.X {Y4} = b.X Y3 =(ab)::Id Y4</p>
  </div>
  <div class="page">
    <p>An Example</p>
    <p>Consider a.b.X ?  b.b.X</p>
    <p>{X} = , {Y1} = a.Y3 {Y2} = b.Y4 {Y3} = b.X {Y4} = b.X Y1 =Id Y2</p>
    <p>{X} = , {Y1, Y2} = a.Y3 {Y3} = b.X {Y4} = b.X Y3 =(ab)::Id Y4</p>
    <p>{X} =  {Y1, Y2} = a.Y3 {Y3, (ab)::IdY4} = b.X X =(bb)::(ab)::Id X</p>
  </div>
  <div class="page">
    <p>An Example</p>
    <p>Consider a.b.X ?  b.b.X</p>
    <p>{X} = , {Y1, Y2} = a.Y3 {Y3} = b.X {Y4} = b.X Y3 =(ab)::Id Y4</p>
    <p>{X} =  {Y1, Y2} = a.Y3 {Y3, (ab)::IdY4} = b.X X =(bb)::(ab)::Id X</p>
    <p>{Y1, Y2} = a.Y3, {Y3, (ab)::IdY4} = b.X {X, (bb)::(ab)::IdX} =</p>
  </div>
  <div class="page">
    <p>An Example</p>
    <p>Consider a.b.X ?  b.b.X</p>
    <p>{Y1, Y2} = a.Y3, {Y3, (ab)::IdY4} = b.X {X, (bb)::(ab)::IdX} =</p>
    <p>Represented as a DAG:</p>
    <p>{Y1, Y2} = a.Y3 {Y3, Y4} = b.X {X, X} =</p>
    <p>(b  b) ::</p>
    <p>(a  b) ::</p>
    <p>Id</p>
    <p>Rew = {} For = {a}</p>
    <p>Rew = {a  b} For = {}</p>
    <p>Rew = {} For = {}</p>
  </div>
  <div class="page">
    <p>An Example</p>
    <p>Consider a.b.X ?  b.b.X</p>
    <p>{Y1, Y2} = a.Y3 {Y3, Y4} = b.X {X, X} =</p>
    <p>(b  b) ::</p>
    <p>(a  b) ::</p>
    <p>Id</p>
    <p>Rew = {} For = {a}</p>
    <p>Rew = {a  b} For = {}</p>
    <p>Rew = {} For = {}</p>
    <p>Forbidden atoms in variables:</p>
    <p>For(Y3) = For(X) = {a} For(Y4) = {b} For(Y1) = For(Y2) =</p>
    <p>The solution is a#X Jordi Levy, Mateu Villaret An Efficient Nominal Unification Algorithm</p>
  </div>
  <div class="page">
    <p>Can we do it better?</p>
    <p>Given  with m = || and n, construct</p>
    <p>a 1 .    .a</p>
    <p>m .f (f (. . . f (Y , Xn) . . . , X2), X1)</p>
    <p>a1.    .am.f (X1, f (X2, . . . f (Xn, Y ) . . . ))</p>
    <p>Y  f (a1, f (a2, . . . f (am1, am) . . . ))</p>
    <p>This problem is solvable iff 2 n</p>
    <p>= Id Seems difficult to answer this question faster than O(n m).</p>
  </div>
  <div class="page">
    <p>Can we do it better?</p>
    <p>Given  with m = || and n, construct</p>
    <p>a 1 .    .a</p>
    <p>m .f (f (. . . f (Y , Xn) . . . , X2), X1)</p>
    <p>a1.    .am.f (X1, f (X2, . . . f (Xn, Y ) . . . ))</p>
    <p>Y  f (a1, f (a2, . . . f (am1, am) . . . ))</p>
    <p>a1 = a1 a2 = a2 am = am</p>
    <p>(a m  am) ::</p>
    <p>(a 1  a1) ::</p>
    <p>Id</p>
    <p>n</p>
    <p>m</p>
  </div>
</Presentation>
