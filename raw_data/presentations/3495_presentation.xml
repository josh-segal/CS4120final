<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Debloating Software through Piece-Wise Compilation &amp;</p>
    <p>Loading</p>
    <p>Anh Quach, Aravind Prakash Binghamton University</p>
    <p>Lok Yan Air Force Research Laboratory</p>
  </div>
  <div class="page">
    <p>Programs are bloated</p>
    <p>int main() {return 1;}</p>
    <p>mov $1, %eax</p>
    <p>retq</p>
    <p>libc 165k instr</p>
    <p>__libc_start_main</p>
  </div>
  <div class="page">
    <p>glibc footprint (Ubuntu 16.04 LTS Desktop) Program % glibc functions Imported</p>
    <p>vlc 21%</p>
    <p>rhythmbox 20%</p>
    <p>unpkg 19%</p>
    <p>gst-xmlinspect-0.10 19%</p>
    <p>kubuntu-debug-installer 19%</p>
    <p>soffice.bin 19%</p>
    <p>... ...</p>
    <p>Mean 5%</p>
  </div>
  <div class="page">
    <p>Popular Shared Libraries (Ubuntu 16.04)</p>
    <p>Library # Programs Use the Library</p>
    <p>Average % of Functions Used</p>
    <p>glibc 1932 24.64</p>
    <p>libm 284 7.06</p>
    <p>libstdc++ 266 37.77</p>
    <p>...</p>
    <p>libXau 86 7.13</p>
    <p>libselinux 72 8.57</p>
    <p>Mean (top 15) 279 10.22</p>
  </div>
  <div class="page">
    <p>Static Dead Code Elimination</p>
    <p>Compiler: intra-procedural optimization</p>
    <p>Static Linker: inter-module optimization</p>
  </div>
  <div class="page">
    <p>Our Approach: Remove Unused Code</p>
    <p>Piece-wise: Inter-module late stage debloating framework</p>
    <p>Piece-wise compiler: generate intra-module dependencies (dependency graph)</p>
    <p>Piece-wise loader:  Identify inter-module dependency using dependency graph  Remove unused code</p>
    <p>Bridge the gap between early (compilation) and late (loading) stages.</p>
  </div>
  <div class="page">
    <p>Challenges</p>
    <p>Modular Interdependencies: one module depends on multiple modules</p>
    <p>Late Symbol Binding: statically unknown, depends on runtime information</p>
    <p>Code Pointers: indirect branches</p>
    <p>Hand-written Assembly: assembly code not analyzed by compiler</p>
    <p>Dynamically Loaded Libraries: statically unknown dependencies</p>
  </div>
  <div class="page">
    <p>Piece-wise System Design</p>
    <p>Piece-wise compiler</p>
    <p>Source code</p>
  </div>
  <div class="page">
    <p>Piece-wise System Design</p>
    <p>Piece-wise compiler Code</p>
    <p>Dependency graph</p>
    <p>Source code</p>
    <p>Code Module</p>
  </div>
  <div class="page">
    <p>Piece-wise System Design</p>
    <p>Piece-wise compiler Code</p>
    <p>Dependency graph</p>
    <p>Piece-wise loader</p>
    <p>Source code</p>
    <p>Code Module</p>
  </div>
  <div class="page">
    <p>Piece-wise System Design</p>
    <p>Piece-wise compiler Code</p>
    <p>Dependency graph</p>
    <p>Piece-wise loader</p>
    <p>Source code</p>
    <p>Code ModuleCode Module</p>
  </div>
  <div class="page">
    <p>Piece-wise System Design</p>
    <p>Piece-wise compiler Code</p>
    <p>Dependency graph</p>
    <p>Piece-wise loader</p>
    <p>Source code</p>
    <p>Code Module Debloated Code Module</p>
  </div>
  <div class="page">
    <p>Backwards Compatibility</p>
    <p>Piece-wise compiler</p>
    <p>Dependency graph</p>
    <p>Unmodified loader</p>
    <p>Source code</p>
  </div>
  <div class="page">
    <p>Backwards Compatibility</p>
    <p>Unmodified Code Module</p>
    <p>Piece-wise loader</p>
    <p>Unmodified Code Module</p>
  </div>
  <div class="page">
    <p>Piece-wise Compiler</p>
    <p>Generate call graph</p>
    <p>Perform code pointer analysis  Global Scan</p>
    <p>Localized Scan  Pointer Analysis</p>
    <p>C++: object-sensitive analysis</p>
    <p>Analyze inlined/hand-written assembly</p>
    <p>Generate code dependency graph</p>
  </div>
  <div class="page">
    <p>Libc Example: Dependency Graph (Call Graph only)</p>
    <p>fdopen</p>
    <p>memset</p>
    <p>open_memstream close_file</p>
    <p>void close_file(FILE *f) { f-&gt;write(); }</p>
    <p>FILE *fdopen() { FILE *f = malloc(...); f-&gt;write = stdio_write; memset(); ... return f; }</p>
    <p>FILE *open_memstream(){ FILE *f = malloc(sizeof *f + UNGET + BUFSIZ); f-&gt;write = ms_write; memset(); ... return f; }</p>
  </div>
  <div class="page">
    <p>Libc Example: Dependency Graph (Call Graph only)</p>
    <p>fdopen</p>
    <p>memset</p>
    <p>open_memstream close_file</p>
    <p>void close_file(FILE *f) { f-&gt;write(); }</p>
    <p>FILE *fdopen() { FILE *f = malloc(...); f-&gt;write = stdio_write; memset(); ... return f; }</p>
    <p>FILE *open_memstream(){ FILE *f = malloc(sizeof *f + UNGET + BUFSIZ); f-&gt;write = ms_write; memset(); ... return f; }</p>
    <p>Missing: stdio_write ms_write</p>
  </div>
  <div class="page">
    <p>Libc Example: Global Scan</p>
    <p>Global Dependency: stdio_write, ms_write</p>
    <p>fdopen: memset open_memstream: memset close_file:</p>
    <p>void close_file(FILE *f) { f-&gt;write(); }</p>
    <p>FILE *fdopen() { FILE *f = malloc(...); f-&gt;write = stdio_write; memset(); ... return f; }</p>
    <p>FILE *open_memstream(){ FILE *f = malloc(sizeof *f + UNGET + BUFSIZ); f-&gt;write = ms_write; memset(); ... return f; }</p>
    <p>fdopen</p>
    <p>memset</p>
    <p>open_memstream close_file</p>
    <p>stdio_write ms_write</p>
  </div>
  <div class="page">
    <p>Libc Example: Pointer Analysis</p>
    <p>fdopen: memset open_memstream: memset close_file: stdio_write, ms_write</p>
    <p>fdopen</p>
    <p>memset</p>
    <p>open_memstream close_file</p>
    <p>stdio_write ms_write</p>
    <p>void close_file(FILE *f) { f-&gt;write(); }</p>
    <p>FILE *fdopen() { FILE *f = malloc(...); f-&gt;write = stdio_write; memset(); ... return f; }</p>
    <p>FILE *open_memstream(){ FILE *f = malloc(sizeof *f + UNGET + BUFSIZ); f-&gt;write = ms_write; memset(); ... return f; }</p>
  </div>
  <div class="page">
    <p>Libc Example: Localized Scan</p>
    <p>fdopen: stdio_write, memset open_memstream: ms_write, memset close_file:</p>
    <p>fdopen</p>
    <p>memset</p>
    <p>open_memstream close_fil e</p>
    <p>ms_writestdio_write</p>
    <p>void close_file(FILE *f) { f-&gt;write(); }</p>
    <p>FILE *fdopen() { FILE *f = malloc(...); f-&gt;write = stdio_write; memset(); ... return f; }</p>
    <p>FILE *open_memstream(){ FILE *f = malloc(sizeof *f + UNGET + BUFSIZ); f-&gt;write = ms_write; memset(); ... return f; }</p>
  </div>
  <div class="page">
    <p>Libc Example: Localized Scan</p>
    <p>fdopen: stdio_write, memset open_memstream: ms_write, memset close_file:</p>
    <p>fdopen</p>
    <p>memset</p>
    <p>open_memstream close_fil e</p>
    <p>ms_writestdio_write</p>
    <p>void close_file(FILE *f) { f-&gt;write(); }</p>
    <p>FILE *fdopen() { FILE *f = malloc(...); f-&gt;write = stdio_write; memset(); ... return f; }</p>
    <p>FILE *open_memstream(){ FILE *f = malloc(sizeof *f + UNGET + BUFSIZ); f-&gt;write = ms_write; memset(); ... return f; }</p>
  </div>
  <div class="page">
    <p>Libc Example: Localized Scan</p>
    <p>fdopen: stdio_write, memset open_memstream: ms_write, memset close_file:</p>
    <p>fdopen</p>
    <p>memset</p>
    <p>open_memstream close_file</p>
    <p>ms_writestdio_write</p>
    <p>void close_file(FILE *f) { f-&gt;write(); }</p>
    <p>FILE *fdopen() { FILE *f = malloc(...); f-&gt;write = stdio_write; memset(); ... return f; }</p>
    <p>FILE *open_memstream(){ FILE *f = malloc(sizeof *f + UNGET + BUFSIZ); f-&gt;write = ms_write; memset(); ... return f; }</p>
  </div>
  <div class="page">
    <p>Piece-wise Loader</p>
    <p>Reads dependency graph</p>
    <p>Preloads libraries</p>
    <p>Performs early binding</p>
    <p>Identifies unused code</p>
    <p>Removes dead code</p>
    <p>A: B, C, D B: C: D D:</p>
    <p>C();</p>
    <p>Binary</p>
    <p>C</p>
    <p>D</p>
    <p>Retained code</p>
    <p>Removed code</p>
    <p>A</p>
    <p>B</p>
  </div>
  <div class="page">
    <p>CFI and Piece-wise</p>
    <p>Piece-wise is complimentary to CFI:</p>
    <p>Reduces attack surface</p>
    <p>Provides post-compromise protection</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
  </div>
  <div class="page">
    <p>Compile Time (millisecond)</p>
  </div>
  <div class="page">
    <p>Piece-wise vs Static Linking for libc</p>
  </div>
  <div class="page">
    <p>Debloating curl</p>
  </div>
  <div class="page">
    <p>Gadget Reduction for libc</p>
  </div>
  <div class="page">
    <p>Vulnerability Elimination</p>
    <p>Library CVE Functions Program Vulnerability Type</p>
    <p>zlib CVE-2016-9842 inflateMark git, curl, LibreOffice, firefox</p>
    <p>Undefined Behavior</p>
    <p>libcurl</p>
    <p>CVE-2016-7167 curl_escape, curl_easy_escape, curl_unescape, curl_easy_unescape</p>
    <p>curl Integer Overflow</p>
    <p>CVE-2014-3707 curl_easy_duphandle curl, cmake Out-of-bound Read</p>
    <p>CVE-2016-9586 curl_mprintf cmake Buffer Overflow</p>
  </div>
  <div class="page">
    <p>Artifact</p>
    <p>A docker image of piece-wise toolchain is available at:</p>
    <p>https://github.com/bingseclab/piecewise</p>
    <p>Email: aquach1@binghamton.edu</p>
  </div>
  <div class="page"/>
</Presentation>
