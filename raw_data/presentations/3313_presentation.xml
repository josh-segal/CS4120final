<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Evaluating, Combining and Generalizing Recommendations with Prerequisites</p>
    <p>Aditya Parameswaran Stanford University</p>
    <p>(with Profs. Hector Garcia-Molina and Jeffrey D. Ullman)</p>
  </div>
  <div class="page">
    <p>Statistics (at Stanford): &gt;10,000 registered users 37,000 listed courses 160,000 evaluations Overall</p>
    <p>Statistics (at Stanford): &gt;10,000 registered users 37,000 listed courses 160,000 evaluations Overall</p>
  </div>
  <div class="page">
    <p>Course Recommendations  Instead of a traditional ranked list   Recommend a good package satisfying</p>
    <p>Prerequisites (e.g., algebra  calculus)  Requirements (e.g., &gt; 3 math courses)  Planning constraints (e.g., no two in same slot)</p>
    <p>Recent work on recommending packages  Yahoo! Travel Plans [De Choudhury et. al. WWW 10]</p>
    <p>Yahoo! Composite items [Roy et. al. SIGMOD 10]  Minimizing Cost [Xie et. al. RecSys 10]</p>
    <p>Prior Work</p>
  </div>
  <div class="page">
    <p>Intuitive Example  Nodes represent all items not taken yet  Edges imply prerequisites</p>
    <p>E(2)B(6)</p>
    <p>I(2)K(9)</p>
    <p>C(3)</p>
    <p>J(8) H(8)</p>
    <p>A(5)</p>
    <p>G(7)</p>
    <p>D(7)</p>
    <p>Prerequisites: NO score: 32</p>
    <p>Prerequisites: YES score: 29</p>
  </div>
  <div class="page">
    <p>Example: General Prerequisites</p>
    <p>Algebra</p>
    <p>Optimization Algorithms</p>
    <p>Geometry</p>
    <p>Arithmetic</p>
    <p>Statistics</p>
    <p>Adv. Math</p>
    <p>Set Theory</p>
    <p>Probability</p>
    <p>Information Theory</p>
  </div>
  <div class="page">
    <p>Formal Problem</p>
    <p>Directed acyclic graph G(V, E)  with some nodes Labeled AND or OR</p>
    <p>Every node x has a score(x)  Recommend k = |A| courses such that</p>
    <p>score(a) is maximized</p>
    <p>{a  A}  Prerequisites of all nodes are met</p>
    <p>OR Graphs</p>
    <p>AND-OR Graphs</p>
    <p>AND Graphs</p>
    <p>Chain Graphs</p>
  </div>
  <div class="page">
    <p>Outline of Work</p>
    <p>Complexity  Chain Graphs: PTIME DP  AND / OR / AND-OR: NP-Hard</p>
    <p>Adaptable Approx Algorithms 1) Breadth First 2) Greedy 3) Top Down  Worst case per structure  Complexity: DP &gt; Greedy &gt; Top Down &gt; BF</p>
    <p>Merge Algorithm  Experiments  Extensions to Fuzzy Prerequisites</p>
    <p>Complexity  Chain Graphs: PTIME DP  AND / OR / AND-OR: NP-Hard</p>
    <p>Adaptable Approx Algorithms 1) Breadth First 2) Greedy 3) Top Down  Worst case per structure  Complexity: DP &gt; Greedy &gt; Top Down &gt; BF</p>
    <p>Merge Algorithm  Experiments  Extensions to Fuzzy Prerequisites</p>
    <p>OR Graphs</p>
    <p>AND-OR Graphs</p>
    <p>AND Graphs</p>
    <p>Chain Graphs</p>
    <p>For Chain Graphs</p>
    <p>Sample</p>
  </div>
  <div class="page">
    <p>Chain Graph Algorithm Chain 0 Chain 1 . Chain i -1 Chain i Chain n</p>
    <p>j</p>
    <p>To pick j items from i chains: Pick  x items from i-1 chains  First j  x items from the ith chain</p>
    <p>Score of best feasible set of j items from first</p>
    <p>i chains</p>
    <p>B [j, i] = max over all x {B [x, i1] + 1  (jx) of ith chain}</p>
    <p>Complexity: O(nk2)</p>
    <p>k</p>
  </div>
  <div class="page">
    <p>Breadth First Algorithm Illustration  K = 4  Add items until k = 4  Swap items</p>
    <p>E(2)B(6)</p>
    <p>I(2)K(9)</p>
    <p>C(3)</p>
    <p>J(8) H(8)</p>
    <p>A(5)</p>
    <p>G(7)</p>
    <p>D(7)</p>
  </div>
  <div class="page">
    <p>Top Down &amp; Greedy Algorithms</p>
    <p>Algorithms between extremes  Efficient: Breadth First  Inefficient but Exact: Dynamic Programming</p>
    <p>Top Down is the reverse of Breadth First  Add best items first, then try to add prerequisites</p>
    <p>Greedy reasons about entire chains at once  Tries to add prefixes of chains with high avg score</p>
  </div>
  <div class="page">
    <p>Outline of Work</p>
    <p>Complexity  Chain Graphs: PTIME DP  AND / OR / AND-OR: NP-Hard</p>
    <p>Adaptable Approx Algorithms 1) Breadth First 2) Greedy 3) Top Down  Worst case per structure  Complexity: DP &gt; Greedy &gt; Top Down &gt; BF</p>
    <p>Merge Algorithm  Experiments  Extensions to Fuzzy Prerequisites</p>
    <p>Complexity  Chain Graphs: PTIME DP  AND / OR / AND-OR: NP-Hard</p>
    <p>Adaptable Approx Algorithms 1) Breadth First 2) Greedy 3) Top Down  Worst case per structure  Complexity: DP &gt; Greedy &gt; Top Down &gt; BF</p>
    <p>Merge Algorithm  Experiments  Extensions to Fuzzy Prerequisites</p>
    <p>OR Graphs</p>
    <p>AND-OR Graphs</p>
    <p>AND Graphs</p>
    <p>Chain Graphs</p>
    <p>For Chain Graphs</p>
    <p>Sample</p>
  </div>
  <div class="page">
    <p>Breadth First: Worst Case  Worst case in terms of:</p>
    <p>d: maximum length of chain  m: max difference in score in a given chain</p>
    <p>a+m-</p>
    <p>a -</p>
    <p>a+m-</p>
    <p>a+m-</p>
    <p>a -</p>
    <p>a+m-</p>
    <p>a+m-</p>
    <p>a -</p>
    <p>a+m-</p>
    <p>a a a</p>
    <p>lots of chains of depth d lots of singleton elements</p>
    <p>difference = k/d x (da + (d-1)m) - ka</p>
    <p>= k/d x (d-1)m</p>
  </div>
  <div class="page">
    <p>Experimental Setup</p>
    <p>Measure How we perform  As fraction of DP (for chains) &amp; no-prereqs (for AND graphs)  Vary:</p>
    <p>n: number of components  d: max depth of chain / component  p: probability of a long chain / large component  k: size of package</p>
    <p>Score: exponentially distributed 13</p>
    <p>Chain Graphs AND Graphs Three Algorithms: greedy, td, bf Three Algorithms: greedy, td, bf Top-2 of td, bf Top-2 of td, bf Merge-2 of td, bf Top-3 of greedy, td, bf</p>
  </div>
  <div class="page">
    <p>Chain Graphs on Varying k</p>
    <p>R</p>
    <p>a tio</p>
    <p>o f</p>
    <p>D yn</p>
    <p>a m</p>
    <p>ic P</p>
    <p>ro g</p>
    <p>ra m</p>
    <p>m in</p>
    <p>g S</p>
    <p>o lu</p>
    <p>tio n</p>
  </div>
  <div class="page">
    <p>AND Graphs on Varying</p>
    <p>R</p>
    <p>a tio</p>
    <p>o f</p>
    <p>N o</p>
    <p>-p re</p>
    <p>re q u</p>
    <p>is ite</p>
    <p>S</p>
    <p>o lu</p>
    <p>tio n</p>
  </div>
  <div class="page">
    <p>Conclusions  Dynamic Programming Algorithm</p>
    <p>Only for Chain Graphs  Guaranteed best recommendations</p>
    <p>Greedy Value Algorithm  Adaptable to any structure  Almost as good recommendations as DP  With less complexity</p>
    <p>Top Down and Breadth First  Even better complexity  Not as good recommendations as Greedy  Can be improved using Merge algorithm</p>
  </div>
  <div class="page">
    <p>Chain Graphs on Varying p</p>
    <p>R a tio</p>
    <p>o f</p>
    <p>D yn</p>
    <p>a m</p>
    <p>ic P</p>
    <p>ro g ra</p>
    <p>m m</p>
    <p>in g</p>
    <p>S o</p>
    <p>lu tio</p>
    <p>n</p>
  </div>
</Presentation>
