<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Specification-Driven Development of an</p>
    <p>Executable Metamodel in Eiffel</p>
    <p>Richard Paige, Phil Brooke, and Jonathan Ostroff</p>
    <p>paige@cs.york.ac.uk, phil.brooke@plymouth.ac.uk, jonathan@cs.yorku.ca</p>
    <p>Department of Computer Science, University of York, UK.</p>
    <p>School of Computing, University of Plymouth, UK.</p>
    <p>Department of Computer Science, York University, Canada.</p>
  </div>
  <div class="page">
    <p>Motivation  Test-driven development (TDD) due to Beck is increasingly</p>
    <p>popular for building systems with reliability and maintainability requirements.</p>
    <p>Three steps: 1. Write a test (which will fail).</p>
    <p>TDD uses tests as specifications that drive the development process.</p>
    <p>Two main limitations: code-based only; and tests have expressiveness limitations.</p>
    <p>Despite these limitations, we claim that TDD could be useful for building metamodels, which are systems with substantial reliability and maintainability requirements.</p>
    <p>But how do we deal with the above limitations?</p>
  </div>
  <div class="page">
    <p>Specification-Driven Design A model-driven extension of TDD. With this approach, models (with contracts) and tests</p>
    <p>can be used to drive the design process. The rest of the presentation:</p>
    <p>A very short overview of SDD.  An overview of its application in building an executable</p>
    <p>metamodel in Eiffel.  The key idea: in SDD for metamodeling, a test is an encoding of</p>
    <p>a model (in Eiffel).  Running the test automatically checks the model against the</p>
    <p>(partial, incomplete) metamodel.  So the development process also gives us a framework for fully</p>
    <p>automatic conformance checking of models against metamodels.</p>
  </div>
  <div class="page">
    <p>SDD  SDD is an integration of TDD and Meyers Design-by-Contract</p>
    <p>(DbC).</p>
    <p>Start anywhere - writing tests, contracts, etc.  Emphasis is always on producing compilable and executable code.  Some tests (collaborative specifications) are scenarios.</p>
  </div>
  <div class="page">
    <p>Design-by-Contract  Annotate classes with properties, and methods of classes with</p>
    <p>pre/postconditions.  These properties are the best form of documentation: they execute with</p>
    <p>the code, and are guaranteed to be consistent with the code.</p>
    <p>Example of a class in Eiffel class MATH feature</p>
    <p>square_root(x: DOUBLE): DOUBLE is</p>
    <p>require x&gt;=0</p>
    <p>do -- your algorithm goes here, e.g., Newton's method</p>
    <p>ensure</p>
    <p>(Result*Result - x).abs &lt;= epsilon;</p>
    <p>epsilon = old epsilon</p>
    <p>end</p>
    <p>epsilon: DOUBLE -- accuracy</p>
    <p>invariant</p>
    <p>end -- MATH</p>
  </div>
  <div class="page">
    <p>Some Observations about SDD Though one can start development with writing</p>
    <p>contracts, there are reasons to prefer writing tests first. 1. Closure: a unit test gives you a clear stopping point: write</p>
    <p>enough code to get it to work. Contracts may allow unnecessary design.</p>
    <p>In summary:  Contracts are good for fleshing out the design while making</p>
    <p>assumptions explicit.  Contracts spell out assumptions more completely, and often</p>
    <p>more concisely, than unit tests.  Tests are good for writing collaborative specifications, and as</p>
    <p>such are more likely to be used early in development.</p>
  </div>
  <div class="page">
    <p>SDD of a Metamodel in Eiffel The metamodel is equivalent to a subset of UML,</p>
    <p>consisting of class and collaboration diagrams.  The class diagrams include an OCL-like contract language for</p>
    <p>pre/post/invariants.</p>
    <p>From this, we automatically generated Eiffel class stubs.  Methods were extended with simple preconditions to ensure non</p>
    <p>NULL arguments.</p>
  </div>
  <div class="page">
    <p>Writing Acceptance Tests The SDD process continued by writing acceptance tests. One test per metamodel well-formedness constraint. Tests took the form of simple Eiffel programs that</p>
    <p>encoded models that either satisfied or invalidated constraints.  e.g., a test generating a model with an inheritance cycle, a test</p>
    <p>generating a model with clashes in a namespace.</p>
    <p>Constraints were prioritised based on complexity and our opinion of how essential it was to capture immediately.  e.g., constraint ensuring valid method calls in assertions was</p>
    <p>postponed for three iterations (existing tools could handle it initially).</p>
    <p>e.g., cycle-free property for aggregation was first iteration since it involved constraints on graphical syntax.</p>
  </div>
  <div class="page">
    <p>Example: Model Encoding Testclass ACCEPTANCE_TEST inherit UNIT_TEST</p>
    <p>creation make feature {ANY} no_aggregation_cycles: BOOLEAN is local a, b, c: E_CLASS; c_to_a, a_to_b, b_to_c: AGGREGATION; m: MODEL do create a.make(&quot;A&quot;); create b.make(&quot;B&quot;); create c.make(&quot;C&quot;); create c_to_a; create a_to_b; create b_to_c; create m.make; ... c_to_a.set_source(c); c_to_a.set_target(a); b_to_c.set_source(b); b_to_c.set_target(c); a_to_b.set_source(a); a_to_b.set_target(b); ... m.prepare Result := true end</p>
    <p>make is do make_test; add_violation_test( agent no_aggregation_cycles ); to_html(&quot;accept.html&quot;) end end</p>
  </div>
  <div class="page">
    <p>Encoding Constraints in Eiffel We used Eiffels declarative specification technique</p>
    <p>agents - to capture constraints. This promotes understandability, readability, and direct</p>
    <p>mapping from OCL/OCL-like constraints to code. Example: no_inheritance_cycles: BOOLEAN is do</p>
    <p>Result := closure.for_all((i1:INHERITANCE): BOOLEAN do</p>
    <p>Result := closure.for_all((i2: INHERITANCE): BOOLEAN do</p>
    <p>-- return true iff i1 and i2 do not form a cycle</p>
    <p>Result := not (i1.source=i2.target and</p>
    <p>i1.target=i2.source)</p>
    <p>end) end) end  Clauses like the above are added to class invariants, to be checked when unit tests</p>
    <p>are run.  Each constraint is implemented within the SDD process.</p>
  </div>
  <div class="page">
    <p>Gaps between Tests and CodeOccasionally the gap between the unit test (capturing a</p>
    <p>model) and the agent-based code needed was substantial.</p>
    <p>e.g., checking that method calls were legitimate according to a classs information hiding policy.</p>
    <p>The simple case (single-dispatch) was straightforward to test and implement.</p>
    <p>The fun case (multi-dispatch) was initially missed (a unit test failed).  Added additional agent code, which duplicated much of the</p>
    <p>original agent code for single dispatch.  Refactored this.</p>
  </div>
  <div class="page">
    <p>Some Observations Useful approach. We emphasised the TDD parts of SDD. Contracts were predominantly for guarding routine calls</p>
    <p>(i.e., preconditions) and for capturing invariants. Sometimes contracts got very complex, e.g., for</p>
    <p>checking covariant overriding.  In this case we wrote a unit test with a simple example of</p>
    <p>covariance overriding, and refactored the agent code.  This was much simpler because we could use sequencing to</p>
    <p>capture the well-formedness condition.</p>
    <p>Generally, minimal class-level refactoring was done; wed need this if we added new views.</p>
    <p>Deliverable: a testing suite as application evidence for correctness of the metamodel.</p>
  </div>
  <div class="page">
    <p>Conclusions and Future Work Fast, reliable way to build executable metamodels. Useful to be able to switch between testing and</p>
    <p>modeling. Side-effect: we can fully automatically check models for</p>
    <p>conformance to the metamodel. Further work:</p>
    <p>Improving support for encoding contracts within the metamodel. Its not easy to use right now.</p>
    <p>Adding a state chart view.  Additional metamodels, particularly MOF.</p>
  </div>
  <div class="page">
    <p>Conclusions Contracts and tests both make useful forms of</p>
    <p>specification. They are complementary and can be used</p>
    <p>synergistically. Contracts are good at making design decisions explicit</p>
    <p>(but be sure to keep these in your code). Tests can express collaborations more easily, and</p>
    <p>appear to be more useful early in the design process. Contracts dont reduce the amount of tests that need to</p>
    <p>be written.  Its easy to underspecify contracts, or simply get them wrong.  Need tests to catch these errors.</p>
  </div>
</Presentation>
