<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>On the Complexity of Deriving Schema Mappings from Database Instances</p>
    <p>Pierre Senellart1;2;3 Georg Gottlob4</p>
    <p>Principles Of Database Systems, 9 June 2008</p>
  </div>
  <div class="page">
    <p>Different sources organize the same data differently</p>
    <p>Jeffrey D. Ullman List of publications from the DBLP Bibliography Server  FAQ</p>
    <p>Coauthor Index  Ask others: ACM DL/Guide  CiteSeer  CSB  Google  MSN  Yahoo</p>
    <p>Home Page</p>
    <p>queries. J. Comput. Syst. Sci. 73(5): 703724 (2007) 2005</p>
    <p>David J. DeWitt, Michael J. Franklin, Hector GarciaMolina, Dieter Gawlick, Jim Gray, Laura M. Haas, Alon Y. Halevy, Joseph M. Hellerstein, Yannis E. Ioannidis, Martin L. Kersten, Michael J. Pazzani, Michael Lesk, David Maier, Jeffrey F. Naughton, HansJrg Schek, Timos K. Sellis, Avi Silberschatz, Michael Stonebraker, Richard T. Snodgrass, Jeffrey D. Ullman, Gerhard Weikum, Jennifer Widom, Stanley B. Zdonik: The Lowell database research selfassessment. Commun. ACM 48(5): 111118 (2005)</p>
    <p>Conference 2003: 680 233 EE Serge Abiteboul, Rakesh Agrawal, Philip A. Bernstein, Michael J. Carey, Stefano Ceri, W. Bruce Croft,</p>
    <p>David J. DeWitt, Michael J. Franklin, Hector GarciaMolina, Dieter Gawlick, Jim Gray, Laura M. Haas, Alon Y. Halevy, Joseph M. Hellerstein, Yannis E. Ioannidis, Martin L. Kersten, Michael J. Pazzani, Michael Lesk, David Maier, Jeffrey F. Naughton, HansJrg Schek, Timos K. Sellis, Avi Silberschatz, Michael Stonebraker, Richard T. Snodgrass, Jeffrey D. Ullman, Gerhard Weikum, Jennifer Widom, Stanley B. Zdonik: The Lowell Database Research Self Assessment CoRR cs.DB/0310006: (2003)</p>
    <p>ICDT 2001: 99113 230 EE Anand Rajaraman, Jeffrey D. Ullman: Querying Websites Using Compact Skeletons. PODS 2001 229 EE Foto N. Afrati, Chen Li, Jeffrey D. Ullman: Generating Efficient Plans for Queries Using Views. SIGMOD</p>
    <p>Conference 2001: 319330 228 EE Edith Cohen, Mayur Datar, Shinji Fujiwara, Aristides Gionis, Piotr Indyk, Rajeev Motwani, Jeffrey D.</p>
    <p>Ullman, Cheng Yang: Finding Interesting Associations without Support Pruning. IEEE Trans. Knowl. Data Eng. 13(1): 6478 (2001)</p>
    <p>Ullman, Cheng Yang: Finding Interesting Associations without Support Pruning. ICDE 2000: 489499 224 EE Shinji Fujiwara, Jeffrey D. Ullman, Rajeev Motwani: Dynamic MissCounting Algorithms: Finding</p>
  </div>
  <div class="page">
    <p>Different sources organize the same data differently</p>
    <p>Advanc ed Sc holar Searc h Sc holar Preferenc es Sc holar Help</p>
    <p>Scholar All articles  Recent articles Results 1  10 of about 12 f or author:&quot;jd ullm an&quot;. (0.07 seconds)</p>
    <p>jd ullm an J Ullman J Hopcrof t A Rajaraman B Konikow ska A Aho</p>
    <p>Querying websites using com pact skeletons  all 11 versions  A Rajaraman, JD Ullm an  Journal of Computer and System Sciences, 2003  Elsevier Several commercial applications, such as online comparison shopping and process automation, require integrating inf ormation that is scattered across multiple w ebsites or XML documents. Much research has been devoted to this problem, ... Cited by 13  Related Articles  Web Search</p>
    <p>[BOOK] Wprowadzenie do teorii autom atw, jezykw i obliczen JE Hopcrof t, JD Ullm an, B Konikow ska  2003  Wydaw . Naukow e PWN Cited by 15  Related Articles  Web Search</p>
    <p>Im proving the efficiency of databasesystem teaching  all 3 versions  JD Ullm an  Proceedings of the 2003 ACM SIGMOD international conf erence , 2003  portal.acm.org ABSTRACT The education industry has a very poor record of produc tivity gains. In this brief article, I outline some of the w ays the teaching of a college course in database systems could be made more ecient, and sta time used ... Cited by 4  Related Articles  Web Search</p>
    <p>A survey of new directions in database system s  all 5 versions  JD Ullm an  Database Systems f or Advanced Applications, 2003.(DASFAA , 2003  ieeexplore.ieee.org A survey of new directions in database systems. Ullman, JD Stanf ord University This paper appears in: Database Systems f or Advanced Applications, 2003. (DASFAA 2003). Proceedings. Eighth International ... Cited by 3  Related Articles  Web Search</p>
    <p>[CITATION] ???? AV Aho, R Sethi, JD Ullm an  2003  ??: ??????? Cited by 6  Related Articles  Web Search</p>
    <p>[BOOK] Autom i, linguaggi e calcolabilit  Hopcrof t, R Motw ani, JD Ullm an, L Bernardinello, L   2003  Pearson Education Italia Cited by 5  Related Articles  Web Search</p>
    <p>[CITATION] ??????? H GarciaMolina, JD Ullm an, J Widom  2003  ??: ??????? Cited by 4  Related Articles  Web Search</p>
    <p>[BOOK] Im plem entacja system w baz danych H GarciaMolina, J Widom, M Jurkiew icz, JD Ullm an  2003  Wydaw nictw a Naukow oTechniczne Cited by 3  Related Articles  Web Search</p>
    <p>[BOOK] Projektowanie i analiza algorytm w: klasyczna praca z teorii algorytm w kom puterowych AV Aho, JE Hopcrof t, JD Ullm an, W Derechow ski  2003  Helion Cited by 2  Related Articles  Web Search</p>
    <p>[CITATION] ??????? AV AHO, JE HOPCROFT, JD ULLMAN  2003  ??: ??????? Cited by 1  Related Articles  Web Search</p>
    <p>Result Page: 1 2 Next</p>
    <p>Google Home  About Google  About Google Scholar</p>
    <p>2007 Google</p>
  </div>
  <div class="page">
    <p>Motivation</p>
    <p>Context Multiple data sources containing information about similar entities, with some redundancy (e.g., sources of the deep Web).</p>
    <p>Several different ways to present this information, i.e., several different schemata.</p>
    <p>No a priori information about (some of) these schemata.</p>
    <p>How to know the relationships between these schemata, by just looking at the instances?</p>
    <p>Other way to see this problem: Match operator on schema mappings, in the setting of data exchange.</p>
  </div>
  <div class="page">
    <p>Motivation</p>
    <p>Context Multiple data sources containing information about similar entities, with some redundancy (e.g., sources of the deep Web).</p>
    <p>Several different ways to present this information, i.e., several different schemata.</p>
    <p>No a priori information about (some of) these schemata.</p>
    <p>How to know the relationships between these schemata, by just looking at the instances?</p>
    <p>Other way to see this problem: Match operator on schema mappings, in the setting of data exchange.</p>
  </div>
  <div class="page">
    <p>Motivation</p>
    <p>Context Multiple data sources containing information about similar entities, with some redundancy (e.g., sources of the deep Web).</p>
    <p>Several different ways to present this information, i.e., several different schemata.</p>
    <p>No a priori information about (some of) these schemata.</p>
    <p>How to know the relationships between these schemata, by just looking at the instances?</p>
    <p>Other way to see this problem: Match operator on schema mappings, in the setting of data exchange.</p>
  </div>
  <div class="page">
    <p>Problem definition</p>
    <p>Problem Given two (relational) database instances I and J with different schemata, what is the optimal description  of J knowing I (with  a finite set of formulas in some logical language)?</p>
    <p>What does optimal implies:</p>
    <p>Conciseness of description.</p>
    <p>Validity of facts predicted by I and .</p>
    <p>All facts of J explained by I and .</p>
    <p>(Note the asymmetry between I and J; context of data exchange where J is computed from I and ).</p>
  </div>
  <div class="page">
    <p>Problem definition</p>
    <p>Problem Given two (relational) database instances I and J with different schemata, what is the optimal description  of J knowing I (with  a finite set of formulas in some logical language)?</p>
    <p>What does optimal implies:</p>
    <p>Conciseness of description.</p>
    <p>Validity of facts predicted by I and .</p>
    <p>All facts of J explained by I and .</p>
    <p>(Note the asymmetry between I and J; context of data exchange where J is computed from I and ).</p>
  </div>
  <div class="page">
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Source-to-target tuple-generating dependencies</p>
    <p>Definition (Source-to-target tgd) First-order formula of the form:</p>
    <p>with:</p>
    <p>' conjunction of source relation atoms;</p>
    <p>conjunction of target relation atoms;</p>
    <p>all variables of x bound in '.</p>
    <p>Example</p>
  </div>
  <div class="page">
    <p>Particular tgds</p>
    <p>Two ways of having simpler tgds:</p>
    <p>Disallow existential quantifiers on the right hand-side: full tgds.</p>
    <p>Disallow cycles on both left- and right-hand sides: acyclic tgds. (Classical notion of acyclicity on hypergraphs extending the basic notion of acyclicity on graphs.)</p>
    <p>Examples 8x18x28x3 R1(x1; x2) ^ R2(x2; x3) ^ R3(x3; x1) ! R0(x1) is cyclic (and full). 8x18x28x3 R1(x1; x2) ^ R2(x2; x3) ! R0(x1) is acyclic (and full).</p>
    <p>Ltgd: arbitrary source-to-target tgds;</p>
    <p>Lfull: full tgds;</p>
    <p>Lacyc: acyclic tgds;</p>
    <p>Lfacyc: full and acyclic tgds.</p>
  </div>
  <div class="page">
    <p>Particular tgds</p>
    <p>Two ways of having simpler tgds:</p>
    <p>Disallow existential quantifiers on the right hand-side: full tgds.</p>
    <p>Disallow cycles on both left- and right-hand sides: acyclic tgds. (Classical notion of acyclicity on hypergraphs extending the basic notion of acyclicity on graphs.)</p>
    <p>Examples 8x18x28x3 R1(x1; x2) ^ R2(x2; x3) ^ R3(x3; x1) ! R0(x1) is cyclic (and full). 8x18x28x3 R1(x1; x2) ^ R2(x2; x3) ! R0(x1) is acyclic (and full).</p>
    <p>Ltgd: arbitrary source-to-target tgds;</p>
    <p>Lfull: full tgds;</p>
    <p>Lacyc: acyclic tgds;</p>
    <p>Lfacyc: full and acyclic tgds.</p>
  </div>
  <div class="page">
    <p>Particular tgds</p>
    <p>Two ways of having simpler tgds:</p>
    <p>Disallow existential quantifiers on the right hand-side: full tgds.</p>
    <p>Disallow cycles on both left- and right-hand sides: acyclic tgds. (Classical notion of acyclicity on hypergraphs extending the basic notion of acyclicity on graphs.)</p>
    <p>Examples 8x18x28x3 R1(x1; x2) ^ R2(x2; x3) ^ R3(x3; x1) ! R0(x1) is cyclic (and full). 8x18x28x3 R1(x1; x2) ^ R2(x2; x3) ! R0(x1) is acyclic (and full).</p>
    <p>Ltgd: arbitrary source-to-target tgds;</p>
    <p>Lfull: full tgds;</p>
    <p>Lacyc: acyclic tgds;</p>
    <p>Lfacyc: full and acyclic tgds.</p>
  </div>
  <div class="page">
    <p>How to define the pertinence of a set of tgds?</p>
    <p>Example</p>
    <p>R R0</p>
    <p>a b c d</p>
    <p>a a b b c a d d g h</p>
    <p>0 = ?</p>
    <p>1 = f8x R(x) ! R 0(x; x)g</p>
    <p>2 = f8x R(x) ! 9y R 0(x; y)g</p>
    <p>3 = f8x18x2 R(x1) ^ R(x2) ! R 0(x1; x2)g</p>
    <p>4 = f9y19y2 R 0(y1; y2)g</p>
  </div>
  <div class="page">
    <p>How to define the pertinence of a set of tgds?</p>
    <p>Example</p>
    <p>R R0</p>
    <p>a b c d</p>
    <p>a a b b c a d d g h</p>
    <p>0 = ?</p>
    <p>1 = f8x R(x) ! R 0(x; x)g</p>
    <p>2 = f8x R(x) ! 9y R 0(x; y)g</p>
    <p>3 = f8x18x2 R(x1) ^ R(x2) ! R 0(x1; x2)g</p>
    <p>4 = f9y19y2 R 0(y1; y2)g</p>
  </div>
  <div class="page">
    <p>Idea</p>
    <p>Size of a formula: number of occurrences of variables and constants.</p>
    <p>Cost of a schema mapping : Size of the minimum repair of  that is valid and explains all facts of J.</p>
    <p>Types of repairs considered:</p>
    <p>fix a universal quantifier by adding conditions (x = a or x 6= a); fix an existential quantifier by giving corresponding constants ((x) ! y = a with  a conjunction of conditions on universally quantified variables); add ground facts to the target instance.</p>
    <p>The problem is then to find a schema mapping of minimal cost.</p>
  </div>
  <div class="page">
    <p>Example of cost computation</p>
    <p>Example</p>
    <p>R R0</p>
    <p>a b c d</p>
    <p>a a b b c a d d g h</p>
    <p>Cost: 17</p>
    <p>Predicted R0 a a b b c c d d</p>
  </div>
  <div class="page">
    <p>Example of cost computation</p>
    <p>Example</p>
    <p>R R0</p>
    <p>a b c d</p>
    <p>a a b b c a d d g h</p>
    <p>Cost: 17</p>
    <p>Predicted R0 a a b b d d</p>
  </div>
  <div class="page">
    <p>Example of cost computation</p>
    <p>Example</p>
    <p>R R0</p>
    <p>a b c d</p>
    <p>a a b b c a d d g h</p>
    <p>R0(g; h)</p>
    <p>Cost: 17</p>
    <p>Predicted R0 a a b b c a d d</p>
  </div>
  <div class="page">
    <p>Example of cost computation</p>
    <p>Example</p>
    <p>R R0</p>
    <p>a b c d</p>
    <p>a a b b c a d d g h</p>
    <p>Cost: 17</p>
    <p>Predicted R0 a a b b c c d d g h</p>
  </div>
  <div class="page">
    <p>Example of cost computation</p>
    <p>Example</p>
    <p>R R0</p>
    <p>a b c d</p>
    <p>a a b b c a d d g h</p>
    <p>Cost: 17</p>
    <p>Predicted R0 a a b b c c d d g h</p>
  </div>
  <div class="page">
    <p>Example of cost computation</p>
    <p>Example</p>
    <p>R R0</p>
    <p>a b c d</p>
    <p>a a b b c a d d g h</p>
    <p>Cost: 17</p>
    <p>Predicted R0 a a b b c c d d g h</p>
  </div>
  <div class="page">
    <p>Problems considered</p>
    <p>Decision problems of interest:</p>
    <p>Cost: Is the cost of a given schema mapping less than K ?</p>
    <p>Optimality: Is a given schema mapping optimal?</p>
    <p>Complexity? Algorithms?</p>
  </div>
  <div class="page">
    <p>Problems considered</p>
    <p>Decision problems of interest:</p>
    <p>Cost: Is the cost of a given schema mapping less than K ?</p>
    <p>Optimality: Is a given schema mapping optimal?</p>
    <p>Complexity? Algorithms?</p>
  </div>
  <div class="page">
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Behavior for simple operators</p>
    <p>Consider the elementary operators of the relational algebra:</p>
    <p>Projection</p>
    <p>Intersection</p>
    <p>Selection (conjunction of atomic conditions)</p>
    <p>Cross Product</p>
    <p>Join (on a given attribute)</p>
    <p>Theorem For any elementary operator , the tgd naturally associated with is optimal with respect to (I ; (I )) (or ( (J); J)), under some basic assumptions.</p>
  </div>
  <div class="page">
    <p>Behavior for simple operators</p>
    <p>Consider the elementary operators of the relational algebra:</p>
    <p>Projection</p>
    <p>Intersection</p>
    <p>Selection (conjunction of atomic conditions)</p>
    <p>Cross Product</p>
    <p>Join (on a given attribute)</p>
    <p>Theorem For any elementary operator , the tgd naturally associated with is optimal with respect to (I ; (I )) (or ( (J); J)), under some basic assumptions.</p>
  </div>
  <div class="page">
    <p>Examples of naturally associated tgds</p>
    <p>Examples</p>
    <p>Condition I and J Optimal tgd</p>
    <p>Projection I 6= ? J = 1(I ) R(x; y) ! R0(x)</p>
    <p>1(J) \ 2(J) = ?, j1(J)j &gt; 2</p>
    <p>I = 1(J) R(x) ! 9y R0(x; y)</p>
    <p>Selection j'(I )j &gt;</p>
    <p>size(')+2 3 J = '(I ) R(x) ! R</p>
    <p>Product RI1 6= ?, R</p>
    <p>I 2 6= ? J = R</p>
    <p>I 1  R</p>
    <p>I 2 R1(x) ^ R2(y) ! R</p>
    <p>J 6= ?, R02</p>
    <p>J 6= ? I = R01</p>
    <p>J  R02</p>
    <p>J R(x; y) ! R01(x) ^ R 0</p>
  </div>
  <div class="page">
    <p>The Polynomial Hierarchy</p>
    <p>P polynomial deterministic algorithm NP</p>
    <p>=P1</p>
    <p>polynomial non-deterministic algorithm coNP</p>
    <p>=P1</p>
    <p>complement NP</p>
    <p>P2 polynomial non-deterministic with  P 1 oracle</p>
    <p>P2 complement  P 2</p>
    <p>Pn+1 polynomial non-deterministic with  P n oracle</p>
    <p>Pn+1 complement  P n+1</p>
    <p>Union of all these classes: PH  PSPACE, the polynomial hierarchy.</p>
  </div>
  <div class="page">
    <p>The Polynomial Hierarchy</p>
    <p>P polynomial deterministic algorithm NP=P1 polynomial non-deterministic algorithm coNP=P1 complement NP</p>
    <p>P2 polynomial non-deterministic with  P 1 oracle</p>
    <p>P2 complement  P 2</p>
    <p>Pn+1 polynomial non-deterministic with  P n oracle</p>
    <p>Pn+1 complement  P n+1</p>
    <p>Union of all these classes: PH  PSPACE, the polynomial hierarchy.</p>
  </div>
  <div class="page">
    <p>The Polynomial Hierarchy</p>
    <p>P polynomial deterministic algorithm NP=P1 polynomial non-deterministic algorithm coNP=P1 complement NP</p>
    <p>P2 polynomial non-deterministic with  P 1 oracle</p>
    <p>P2 complement  P 2</p>
    <p>Pn+1 polynomial non-deterministic with  P n oracle</p>
    <p>Pn+1 complement  P n+1</p>
    <p>Union of all these classes: PH  PSPACE, the polynomial hierarchy.</p>
  </div>
  <div class="page">
    <p>The Polynomial Hierarchy</p>
    <p>P polynomial deterministic algorithm NP=P1 polynomial non-deterministic algorithm coNP=P1 complement NP</p>
    <p>P2 polynomial non-deterministic with  P 1 oracle</p>
    <p>P2 complement  P 2</p>
    <p>Pn+1 polynomial non-deterministic with  P n oracle</p>
    <p>Pn+1 complement  P n+1</p>
    <p>Union of all these classes: PH  PSPACE, the polynomial hierarchy.</p>
  </div>
  <div class="page">
    <p>The Polynomial Hierarchy</p>
    <p>P polynomial deterministic algorithm NP=P1 polynomial non-deterministic algorithm coNP=P1 complement NP</p>
    <p>P2 polynomial non-deterministic with  P 1 oracle</p>
    <p>P2 complement  P 2</p>
    <p>Pn+1 polynomial non-deterministic with  P n oracle</p>
    <p>Pn+1 complement  P n+1</p>
    <p>Union of all these classes: PH  PSPACE, the polynomial hierarchy.</p>
  </div>
  <div class="page">
    <p>(Combined) Complexity Results</p>
    <p>Ltgd Lfull</p>
    <p>Cost P3 ,  P 2 -hard</p>
    <p>P 2 , (co)NP-hard</p>
    <p>Optimality P4 , (co)NP-hard  P 3 , (co)NP-hard</p>
    <p>Lacyc Lfacyc</p>
    <p>Cost P2 , (co)NP-hard NP-complete Optimality P3 , (co)NP-hard</p>
    <p>P 2 , (co)NP-hard</p>
  </div>
  <div class="page">
    <p>(Combined) Complexity Results</p>
    <p>Ltgd Lfull</p>
    <p>Cost P3 ,  P 2 -hard</p>
    <p>P 2 , (co)NP-hard</p>
    <p>Optimality P4 , (co)NP-hard  P 3 , (co)NP-hard</p>
    <p>Lacyc Lfacyc</p>
    <p>Cost P2 , (co)NP-hard NP-complete Optimality P3 , (co)NP-hard</p>
    <p>P 2 , (co)NP-hard</p>
  </div>
  <div class="page">
    <p>(Combined) Complexity Results</p>
    <p>Ltgd Lfull</p>
    <p>Cost P3 ,  P 2 -hard</p>
    <p>P 2 , (co)NP-hard</p>
    <p>Optimality P4 , (co)NP-hard  P 3 , (co)NP-hard</p>
    <p>Lacyc Lfacyc</p>
    <p>Cost P2 , (co)NP-hard NP-complete Optimality P3 , (co)NP-hard</p>
    <p>P 2 , (co)NP-hard</p>
  </div>
  <div class="page">
    <p>(Combined) Complexity Results</p>
    <p>Ltgd Lfull</p>
    <p>Cost P3 ,  P 2 -hard</p>
    <p>P 2 , (co)NP-hard</p>
    <p>Optimality P4 , (co)NP-hard  P 3 , (co)NP-hard</p>
    <p>Lacyc Lfacyc</p>
    <p>Cost P2 , (co)NP-hard NP-complete Optimality P3 , (co)NP-hard</p>
    <p>P 2 , (co)NP-hard</p>
  </div>
  <div class="page">
    <p>(Combined) Complexity Results</p>
    <p>Ltgd Lfull</p>
    <p>Cost P3 ,  P 2 -hard</p>
    <p>P 2 , (co)NP-hard</p>
    <p>Optimality P4 , (co)NP-hard  P 3 , (co)NP-hard</p>
    <p>Lacyc Lfacyc</p>
    <p>Cost P2 , (co)NP-hard NP-complete Optimality P3 , (co)NP-hard</p>
    <p>P 2 , (co)NP-hard</p>
  </div>
  <div class="page">
    <p>Vertex-Cover in r-partite r-uniform hypergraph</p>
    <p>Vertex-Cover: find a set of vertices of minimal size that cover all (hyper)edges in a (hyper)graph.</p>
    <p>NP-complete for general (hyper)graphs.</p>
    <p>PTIME for bipartite graphs (Knigs theorem).</p>
    <p>Lemma Vertex-Cover is NP-complete for r-partite r -uniform hypergraphs for r &gt; 3.</p>
    <p>r-partite: partition of the set of vertices into r sets, with no hyperedge spanning two vertices of the same set.</p>
    <p>r-uniform: every hyperedge spans r vertices.</p>
  </div>
  <div class="page">
    <p>Vertex-Cover in r-partite r-uniform hypergraph</p>
    <p>Vertex-Cover: find a set of vertices of minimal size that cover all (hyper)edges in a (hyper)graph.</p>
    <p>NP-complete for general (hyper)graphs.</p>
    <p>PTIME for bipartite graphs (Knigs theorem).</p>
    <p>Lemma Vertex-Cover is NP-complete for r-partite r -uniform hypergraphs for r &gt; 3.</p>
    <p>r-partite: partition of the set of vertices into r sets, with no hyperedge spanning two vertices of the same set.</p>
    <p>r-uniform: every hyperedge spans r vertices.</p>
  </div>
  <div class="page">
    <p>Encoding of 3-SAT</p>
    <p>x1</p>
    <p>x1</p>
    <p>x2</p>
    <p>x2</p>
    <p>x3</p>
    <p>x3</p>
    <p>y1</p>
    <p>y1</p>
    <p>y2</p>
    <p>y2</p>
    <p>y3</p>
    <p>y3</p>
    <p>z1</p>
    <p>z1 z2</p>
    <p>z2</p>
    <p>z3</p>
    <p>z3</p>
    <p>:z _ x _ y</p>
  </div>
  <div class="page">
    <p>Cost is NP-hard for Lfacyc</p>
    <p>Reduction from Vertex-Cover in 3-partite 3-uniform hypergraphs.</p>
    <p>Without x = a repairs on the left-hand side of a tgd:</p>
    <p>R(x1; x2; x3) ! R0(x1)</p>
    <p>Source instance: hypergraph</p>
    <p>Target instance: empty</p>
    <p>Cost: size of the tgd plus twice the minimum size of a vertex cover.</p>
    <p>With x = a repairs: a little more difficult, but feasible!</p>
  </div>
  <div class="page">
    <p>Cost is NP-hard for Lfacyc</p>
    <p>Reduction from Vertex-Cover in 3-partite 3-uniform hypergraphs.</p>
    <p>Without x = a repairs on the left-hand side of a tgd:</p>
    <p>R(x1; x2; x3) ! R0(x1)</p>
    <p>Source instance: hypergraph</p>
    <p>Target instance: empty</p>
    <p>Cost: size of the tgd plus twice the minimum size of a vertex cover.</p>
    <p>With x = a repairs: a little more difficult, but feasible!</p>
  </div>
  <div class="page">
    <p>Cost is NP-hard for Lfacyc</p>
    <p>Reduction from Vertex-Cover in 3-partite 3-uniform hypergraphs.</p>
    <p>Without x = a repairs on the left-hand side of a tgd:</p>
    <p>R(x1; x2; x3) ! R0(x1)</p>
    <p>Source instance: hypergraph</p>
    <p>Target instance: empty</p>
    <p>Cost: size of the tgd plus twice the minimum size of a vertex cover.</p>
    <p>With x = a repairs: a little more difficult, but feasible!</p>
  </div>
  <div class="page">
    <p>Cost is NP-hard for Lfacyc</p>
    <p>Reduction from Vertex-Cover in 3-partite 3-uniform hypergraphs.</p>
    <p>Without x = a repairs on the left-hand side of a tgd:</p>
    <p>R(x1; x2; x3) ! R0(x1)</p>
    <p>Source instance: hypergraph</p>
    <p>Target instance: empty</p>
    <p>Cost: size of the tgd plus twice the minimum size of a vertex cover.</p>
    <p>With x = a repairs: a little more difficult, but feasible!</p>
  </div>
  <div class="page">
    <p>Outline</p>
  </div>
  <div class="page">
    <p>Extension to Relational Calculus</p>
    <p>Definition of repairs can be extended to relational calculus.</p>
    <p>Same definition of cost, optimality.</p>
    <p>Cost is not recursive (but co-r.e.).</p>
    <p>Computability of Optimality: open (!).</p>
  </div>
  <div class="page">
    <p>Other Cost Functions</p>
    <p>Why not counting the number of tuples to add or remove in J? . . . because it can be exponential in the size of the schema mapping!</p>
    <p>Why not counting the number of tuples to add or remove in I or J? . . . because selections are not captured!</p>
  </div>
  <div class="page">
    <p>Other Cost Functions</p>
    <p>Why not counting the number of tuples to add or remove in J? . . . because it can be exponential in the size of the schema mapping!</p>
    <p>Why not counting the number of tuples to add or remove in I or J? . . . because selections are not captured!</p>
  </div>
  <div class="page">
    <p>Other Cost Functions</p>
    <p>Why not counting the number of tuples to add or remove in J? . . . because it can be exponential in the size of the schema mapping!</p>
    <p>Why not counting the number of tuples to add or remove in I or J? . . . because selections are not captured!</p>
  </div>
  <div class="page">
    <p>Other Cost Functions</p>
    <p>Why not counting the number of tuples to add or remove in J? . . . because it can be exponential in the size of the schema mapping!</p>
    <p>Why not counting the number of tuples to add or remove in I or J? . . . because selections are not captured!</p>
  </div>
  <div class="page">
    <p>Outline</p>
  </div>
  <div class="page">
    <p>In summary...</p>
    <p>Formal framework for the discovery of symbolic relations between two data sources.</p>
    <p>High complexity (up to fourth level of PH).</p>
    <p>Link with Inductive Logic Programming?</p>
    <p>Heuristics?</p>
    <p>Approximation algorithms?</p>
    <p>Generalization of acyclicity?</p>
  </div>
  <div class="page">
    <p>In summary...</p>
    <p>Formal framework for the discovery of symbolic relations between two data sources.</p>
    <p>High complexity (up to fourth level of PH).</p>
    <p>Link with Inductive Logic Programming?</p>
    <p>Heuristics?</p>
    <p>Approximation algorithms?</p>
    <p>Generalization of acyclicity?</p>
  </div>
  <div class="page">
    <p>Merci.</p>
  </div>
</Presentation>
