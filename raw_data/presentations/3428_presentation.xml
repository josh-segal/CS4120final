<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Venerable Variadic Vulnerabilities Vanquished</p>
    <p>Priyam Biswas* Alessandro Di Federico* Scott A. Carr* Prabhu Rajasekaran</p>
    <p>Stijn Volckaert Yeoul Na Michael Franz Mathias Payer*</p>
    <p>*Purdue University  Politecnico di Milano University of California, Irvine</p>
  </div>
  <div class="page">
    <p>Variadic Function</p>
    <p>C and C++ support variadic functions</p>
    <p>Variable number of arguments</p>
    <p>Implicit contract between caller and callee</p>
    <p>Cannot statically check the argument types</p>
    <p>int add(int n, ...)</p>
    <p>{</p>
    <p>va_list list;</p>
    <p>va_start(list, n);</p>
    <p>for (int i=0; i &lt; n; i++)</p>
    <p>total=total + va_arg(list, int);</p>
    <p>va_end(list);</p>
    <p>return total;</p>
    <p>}</p>
    <p>int main(int argc, const char * argv[])</p>
    <p>{</p>
    <p>result = add(3, val1, val2, val3);</p>
    <p>result = add(2, val1, val2);</p>
    <p>return 0;</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>Motivation</p>
    <p>Parameters of variadic functions cannot be statically checked</p>
    <p>Attacks violate the implicit contract between caller and callee</p>
    <p>Attacks cause disparity: more/less arguments or wrong argument type</p>
    <p>Existing defenses do not prevent such attacks</p>
  </div>
  <div class="page">
    <p>Prevalence of Variadic Functions Program Call Sites Functions Prototype</p>
    <p>Total Indirect Total Address Taken</p>
    <p>Firefox 30,225 1,664 421 18 241</p>
    <p>Chromium 83,792 1,728 794 44 396</p>
    <p>FreeBSD 189,908 7,508 1,368 197 367</p>
    <p>Apache 7,121 0 94 29 41</p>
    <p>CPython 4,183 0 382 0 38</p>
    <p>Nginx 1,085 0 26 0 14</p>
    <p>OpenSSL 4,072 1 23 0 15</p>
    <p>Wireshark 37,717 0 469 1 110</p>
  </div>
  <div class="page">
    <p>Threat Model</p>
    <p>Program contains arbitrary memory corruption</p>
    <p>Existing defense mechanisms such as DEP, ASLR, CFI are deployed</p>
    <p>Capabilities of the attacker  Directly overwriting the arguments of a variadic function</p>
    <p>Hijacking indirect calls and call variadic functions over control-flow edges</p>
  </div>
  <div class="page">
    <p>Control Flow Integrity (CFI)  Verifies indirect control flow transfers based on statically determined set</p>
    <p>Allows all targets with the same prototype</p>
    <p>int foo (int n, ) int baz(int n, ) int bar(int n, ) int boo (n) void func(int n, ) Void func2(int n, )</p>
    <p>int*(int)</p>
    <p>Attacker controlled callsite</p>
    <p>Illegal variadic function target</p>
    <p>Legal variadic function target</p>
    <p>Legal args.</p>
    <p>Illegal args.</p>
    <p>Legal args.</p>
    <p>Illegal args.</p>
  </div>
  <div class="page">
    <p>Variadic Calls: Current CFI Mechanisms Intended</p>
    <p>target Actual target LLVM-CFI1 pi-CFI2 CCFI3 VTV4 CFG5 HexVASAN</p>
    <p>Prototype Addr. Taken</p>
    <p>Variadic Same Yes X X X X X</p>
    <p>No X  X X X</p>
    <p>Different Yes   X X X</p>
    <p>No   X X X</p>
    <p>NonVariadic</p>
    <p>Same Yes   X X X</p>
    <p>No   X X X</p>
    <p>Different Yes   X X X</p>
    <p>No    X X</p>
    <p>Original Overwritten Arguments X X X X X</p>
  </div>
  <div class="page">
    <p>Our Approach</p>
    <p>Enforce contract between caller and callee</p>
    <p>Verify argument types at runtime</p>
    <p>Abort if there is an error</p>
  </div>
  <div class="page">
    <p>HexVASAN Design</p>
    <p>int a, b;</p>
    <p>foo(a, b);</p>
    <p>caller</p>
    <p>arg. count = 2 arg[0].type = int arg[1].type = int</p>
    <p>MetaData Storage</p>
    <p>void foo ( ) { x = va_arg(int); ..</p>
    <p>z = va_arg(char*); }</p>
    <p>callee</p>
    <p>record</p>
    <p>read</p>
    <p>check_arg (0, int)</p>
    <p>check_arg (1, char*)</p>
    <p>?</p>
    <p>OK</p>
    <p>Verification</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Implemented as LLVM pass</p>
    <p>Statically instrument code</p>
    <p>Dynamically verify types</p>
    <p>of variadic arguments (library)</p>
  </div>
  <div class="page">
    <p>Real Code Is Hard!  Handling multiple va_list</p>
    <p>HexVASAN supports it by recording each va_list separately</p>
    <p>Floating-point arguments</p>
    <p>Handles floating point and non-floating point arguments separately</p>
    <p>Handling aggregate data types</p>
    <p>Caller unpacks the fields if arguments fit into registers</p>
    <p>Traces back to get the correct data type</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Comparison with state-of-the-art CFI mechanisms</p>
    <p>Usage of variadic functions in existing software</p>
    <p>Performance overhead in SPEC CPU2006 benchmark &amp; Firefox</p>
  </div>
  <div class="page">
    <p>Exploit Detection</p>
    <p>Format string vulnerability in sudo CVE-2012-0809</p>
    <p>Attacker can escalate the privileges</p>
    <p>Not detected by -Wformat</p>
    <p>HexVASAN detects exploit</p>
    <p>Error: Type Mismatch</p>
    <p>Index is 1</p>
    <p>Callee Type: 43 (32-bit integer)</p>
    <p>Caller Type: 15 (Pointer)</p>
    <p>Backtrace:</p>
    <p>[0] 0x4019ff &lt;_vasan_backtrace+0x1f&gt; at test</p>
    <p>[1] 0x401837 &lt;_vasan_check_arg+0x187&gt; at test</p>
    <p>[2] 0x8011b3afa &lt;__vfprintf+0x20fa&gt; at libc.so.7</p>
    <p>[3] 0x8011b1816 &lt;vfprintf_l+0x86&gt; at libc.so.7</p>
    <p>[4] 0x801200e50 &lt;printf+0xc0&gt; at libc.so.7</p>
    <p>[5] 0x4024ae &lt;main+0x3e&gt; at test</p>
    <p>[6] 0x4012ff &lt;_start+0x17f&gt; at test</p>
  </div>
  <div class="page">
    <p>Performance Overhead: SPEC CPU2006</p>
    <p>Native HexVASAN</p>
  </div>
  <div class="page">
    <p>Interesting Cases: Spec CPU2006  Omnetpp</p>
    <p>Caller : NULL</p>
    <p>Callee: char*</p>
    <p>Perlbench</p>
    <p>Caller : Subtraction of two char pointers (64 bit)</p>
    <p>Callee: int ( 32 bit)</p>
  </div>
  <div class="page">
    <p>Performance Overhead: Firefox Benchmark Native HexVASAN</p>
    <p>Octane AVERAGE 33,824.40 33717.40</p>
    <p>STDDEV 74.96 125.89</p>
    <p>OVERHEAD 0.32%</p>
    <p>JetStream AVERAGE 194.86 193.68</p>
    <p>STDDEV 1.30 0.58</p>
    <p>OVERHEAD 0.61%</p>
    <p>Kraken AVERAGE 885.52 887.12</p>
    <p>STDDEV 11.02 7.31</p>
    <p>OVERHEAD 0.18%</p>
  </div>
  <div class="page">
    <p>Sample Findings: Firefox</p>
    <p>Case 1</p>
    <p>Caller : unsigned long</p>
    <p>Callee: unsigned int</p>
    <p>Case 2</p>
    <p>Caller : Bool</p>
    <p>Callee: unsigned long</p>
    <p>Case 3</p>
    <p>Caller : void*</p>
    <p>Callee: unsigned long</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>HexVASAN successfully monitors variadic arguments</p>
    <p>Detects bugs due to type mismatch in variadic functions</p>
    <p>Negligible overhead in SPEC CPU2006 and Firefox</p>
    <p>Open Source at https://github.com/HexHive/HexVASAN</p>
  </div>
  <div class="page">
    <p>Thank you! Questions?</p>
    <p>Open Source at https://github.com/HexHive/HexVASAN</p>
  </div>
  <div class="page">
    <p>int add(int n, ...)</p>
    <p>{</p>
    <p>va_list list;</p>
    <p>va_start(list, n);</p>
    <p>for (int i=0; i &lt; n; i++)</p>
    <p>total=total + va_arg(list, int);</p>
    <p>va_end(list);</p>
    <p>return total;</p>
    <p>}</p>
    <p>int main(int argc, const char * argv[])</p>
    <p>{</p>
    <p>result = add(3, val1, val2, val3);</p>
    <p>return 0;</p>
    <p>}</p>
    <p>int add(int n, ...)</p>
    <p>{</p>
    <p>va_list list;</p>
    <p>va_start(list, n);</p>
    <p>list_init(&amp;list);</p>
    <p>for (int i=0; i &lt; n; i++) {</p>
    <p>check_arg(&amp;list, typeid(int));</p>
    <p>total=total + va_arg(list, int);}</p>
    <p>va_end(list);</p>
    <p>list_free(&amp;list);</p>
    <p>return total;</p>
    <p>}</p>
    <p>int main(int argc, const char * argv[])</p>
    <p>{</p>
    <p>precall(vcsd);</p>
    <p>result = add(3, val1, val2, val3);</p>
    <p>postcall(vcsd);</p>
    <p>return 0;</p>
    <p>}</p>
  </div>
</Presentation>
