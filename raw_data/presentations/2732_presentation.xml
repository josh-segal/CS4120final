<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>2016 VMware Inc. All rights reserved. 2016 VMware Inc. All rights reserved.</p>
    <p>vCorfu A Cloud-Scale Object Store on a Shared Log Michael Wei, Amy Tai, Christopher J. Rossbach, Ittai Abraham, Maithem Munshed, Medhavi Dhawan, Jim Stabile, Udi Wieder, Scott Fritchie, Steven Swanson, Michael J. Freedman, Dahlia Malkhi</p>
    <p>Michael Wei NSDI 2017 March 27th, 2017</p>
  </div>
  <div class="page">
    <p>Background Shared Logs and Consistency</p>
  </div>
  <div class="page">
    <p>Scalability and Consistency</p>
    <p>Systems which are scalable</p>
    <p>yet consistent can be difficult to build</p>
  </div>
  <div class="page">
    <p>Shared Log Systems</p>
    <p>Shared log systems represent a point in the design space</p>
    <p>which provides scalability without compromising consistency</p>
    <p>however, these systems make a different set of tradeoffs</p>
    <p>S ca</p>
    <p>la bi</p>
    <p>lit y</p>
    <p>Consistency</p>
    <p>S ca</p>
    <p>la bi</p>
    <p>lit y</p>
    <p>Consistency</p>
  </div>
  <div class="page">
    <p>Writing vs Reading</p>
    <p>While writing to a shared log provides strong consistency and &gt;1/2M appends/s,</p>
    <p>To provide the strongest level of consistency, only updates are logged,</p>
    <p>So reads are more expensive, as clients now have to read multiple updates</p>
    <p>increment</p>
    <p>increment</p>
    <p>increment increment</p>
  </div>
  <div class="page">
    <p>Improving Read Scalability</p>
    <p>Clients may read unnecessary updates to service requests</p>
    <p>There is no locality, so clients will have to jump around on the log</p>
    <p>Clients have to do more work to figure out the results of a transaction</p>
    <p>A++ B++</p>
    <p>B=? 1 2 3 4 5</p>
    <p>B++ Read A@1</p>
  </div>
  <div class="page">
    <p>vCorfu addresses read scalability by</p>
    <p>Stream materialization, which localizes related updates and enables reads without playback</p>
    <p>Composable SMR, which enables large state machines without forcing clients to replicate the entire state machine</p>
    <p>Lightweight Transaction Resolution, which eliminates the need for clients to determine whether transactions in a log were aborted</p>
    <p>A - M</p>
    <p>N - Z</p>
    <p>B++</p>
    <p>A@2 A@1</p>
    <p>A@2</p>
  </div>
  <div class="page">
    <p>vCorfu Offers Another Point in the Design Space</p>
    <p>Different point in the design space</p>
    <p>Better read scalability, but at a penalty to writes</p>
    <p>We can now service more clients without consuming the entire log</p>
    <p>W rit</p>
    <p>e S</p>
    <p>ca la</p>
    <p>bi lit</p>
    <p>y</p>
    <p>Consistency</p>
    <p>Commit</p>
  </div>
  <div class="page">
    <p>and we will show</p>
    <p>That we can now scale shared log systems to cloud-scale data sets</p>
    <p>Offer comparable performance to, and often outperform state-of-the-art NoSQL systems</p>
    <p>While retaining the strong consistency benefits of a shared log</p>
  </div>
  <div class="page">
    <p>Shared Log Systems Interface and Approach</p>
  </div>
  <div class="page">
    <p>Shared Log [1] Basic Operations</p>
    <p>Read(address): Read an entry from the log</p>
    <p>Append(entry): Append an entry to the log and return the address it was written at</p>
    <p>[1] CORFU: A Shared Log Design for Flash Clusters. (NSDI '12)</p>
  </div>
  <div class="page">
    <p>Shared Log Systems are Composed of</p>
    <p>Sequencer, which issues addresses in a log</p>
    <p>Log replicas, which store data in the log</p>
    <p>Layout, which maps addresses in the log to log replicas</p>
    <p>Log Tail 10</p>
  </div>
  <div class="page">
    <p>To Append to a Shared Log, Clients</p>
    <p>First contact the sequencer, which issues an address</p>
    <p>Using the layout, determine which log replicas to write to</p>
    <p>Perform a write using the address given by the sequencer</p>
    <p>Log Tail 2  3</p>
    <p>Next? 2</p>
  </div>
  <div class="page">
    <p>We Take the Tango [2] Approach</p>
    <p>Clients dont interact with the log directly, rather, they interact with objects</p>
    <p>Objects are stored in virtualized logs called streams</p>
    <p>Entries in the stream represent updates to the object state</p>
    <p>++-</p>
    <p>[2] Tango: Distributed Data Structures over a Shared Log. (SOSP 13)</p>
  </div>
  <div class="page">
    <p>Including Support For Transactions</p>
    <p>The system leverages the log to provide rich support for transactions</p>
    <p>Transactions execute optimistically on the clients in-memory views</p>
    <p>And the log serves as the ground truth in case of conflicts</p>
    <p>if (A==1) {</p>
    <p>A++; B++;</p>
    <p>}</p>
  </div>
  <div class="page">
    <p>vCorfu Stream Store Architecture and Design</p>
  </div>
  <div class="page">
    <p>Materialized Streams</p>
    <p>In vCorfu, a fundamental building block is a materialized stream</p>
    <p>Stream replicas implement the storage for a materialized stream</p>
    <p>The vCorfu sequencer keeps track of the global tail as well as stream tails (global, stream)</p>
    <p>0 1 2 Z ? ?</p>
    <p>0 1 2 X Y ?</p>
    <p>Log Tail 2</p>
    <p>: G0/0 : G2/1</p>
    <p>Gx (Global Address) /y (Stream Address)</p>
  </div>
  <div class="page">
    <p>Materializing Streams</p>
    <p>Sequencer issues global address (2) and stream address (1)</p>
    <p>Write to log replica using the global address (2)</p>
    <p>Write to stream replica using the stream ID () and stream address (1)</p>
    <p>0 1 2</p>
    <p>Log Tail 1  2</p>
    <p>: 0  1 : 0</p>
    <p>Next, ? 2, 1 0 2</p>
    <p>Log Replica Stream Replica</p>
  </div>
  <div class="page">
    <p>Materializing Streams</p>
    <p>Client must commit data to every log and stream replica</p>
    <p>Log replicas and stream replicas only serve committed data</p>
    <p>Extra commit message reduces append throughput</p>
    <p>K A</p>
    <p>pp en</p>
    <p>ds /s</p>
    <p>Total Replicas</p>
    <p>Materialized Stream Stream</p>
  </div>
  <div class="page">
    <p>Reading From a Materialized Stream</p>
    <p>Stream replicas contain all updates for a given stream</p>
    <p>This enables reading a stream by contacting only one replica</p>
    <p>Not having to jump from replica to replica greatly improves read performance</p>
    <p>M ill</p>
    <p>is ec</p>
    <p>on ds</p>
    <p># of Entries in Stream</p>
    <p>Materialized Stream Stream0 2</p>
    <p>0 1 1 3</p>
    <p>0 1</p>
    <p>0 1 2 0 1</p>
  </div>
  <div class="page">
    <p>Local / Remote Views</p>
    <p>Local views enable clients to obtain in-memory objects by following updates</p>
    <p>Remote views enable to delegate playback to stream replicas</p>
    <p>Remote views keep latency constant with a heavily modified object and many clients reading</p>
    <p>++++</p>
    <p>0 1 2 ++ ++</p>
    <p>La te</p>
    <p>nc y</p>
    <p>(m s)</p>
    <p># of Clients Reading</p>
    <p>Local Remote</p>
  </div>
  <div class="page">
    <p>Transactional Execution</p>
    <p>We support optimistic transaction execution based on versioned object views</p>
    <p>The client tracks the version of each object it accesses</p>
    <p>And generates a list of modifications it will make</p>
    <p>if (==1) { ++;</p>
    <p>} V0</p>
    <p>V1</p>
    <p>V1 Read Set</p>
    <p>++ Write Set</p>
    <p>V0</p>
    <p>V1</p>
  </div>
  <div class="page">
    <p>Lightweight Transaction Resolution</p>
    <p>Send sequencer version of read and write set, address issued if read set versions are equal</p>
    <p>And a client encountering this entry does not need to determine the read set</p>
    <p>Read G2 1</p>
    <p>Log Tail 1</p>
    <p>: G1/0 : G0/0</p>
    <p>V1 Write</p>
    <p>This enables only the write set to be written, since we know that the read set will not have changed</p>
    <p>0 1 2 ++ ++</p>
    <p>0 1 2 ++ ++</p>
  </div>
  <div class="page">
    <p>Large State Machines</p>
    <p>Objects can contain large amounts of state, which pose a difficulty for SMR</p>
    <p>They pose a burden for a client, which has to play all these updates in memory</p>
    <p>They pose a burden on the log because they contain many updates</p>
    <p>0 1 2 ++ ++ ++ ++++</p>
  </div>
  <div class="page">
    <p>CSMR: Composing vCorfu Objects</p>
    <p>vCorfu objects can be composed of other vCorfu objects with a pointer</p>
    <p>Reduces playback burden by naturally dividing objects</p>
    <p>Leverages transactional features of vCorfu</p>
    <p>A - L</p>
    <p>L - Z TX</p>
  </div>
  <div class="page">
    <p>CSMR Example: Map</p>
    <p>Instead of a single map, compose a map from multiple buckets</p>
    <p>Most operations only need to access a single bucket</p>
    <p>Certain operations, like clear() or size() are more expensive with CSMR</p>
    <p>A - G</p>
    <p>H - L</p>
    <p>M - Z</p>
    <p>map A - G</p>
    <p>get(apple) A - G</p>
    <p>H - L</p>
    <p>M - Z</p>
    <p>size</p>
  </div>
  <div class="page">
    <p>vCorfu vs. Cassandra YCSB</p>
  </div>
  <div class="page">
    <p>Conclusion vCorfu Benefits</p>
  </div>
  <div class="page">
    <p>vCorfu addresses the read burden by</p>
    <p>Stream materialization, which localizes related updates and enables reads without playback</p>
    <p>Composable SMR, which enables large state machines without forcing clients to replicate the entire state machine</p>
    <p>Lightweight Transaction Resolution, which eliminates the need for clients to determine whether transactions in a log were aborted</p>
    <p>A - M</p>
    <p>N - Z</p>
    <p>B++</p>
    <p>A@2 A@1</p>
    <p>A@2</p>
  </div>
  <div class="page">
    <p>Special thanks to the Corfu Team: Past and Present</p>
    <p>Original Corfu Paper Mahesh Balakrishnan Dahlia Malkhi Vijayan Prabhakaran Ted Wobber John D. Davis</p>
    <p>Tango Ming Wu Sriram Rao Tao Zou Aviad Zuck</p>
    <p>Replex Amy Tai Michael J. Freedman Ittai Abraham</p>
    <p>VMware NSX Maithem Munshed Zeeshan Lokhandwala Medhavi Dhawan Jim Stabile Kapil Goyal Guprit Johal Konstain Spriov James Chang Jim Yang Kevin James Anny Manzanil Ragnar Edholm</p>
    <p>vCorfu Christopher J. Rossbach Udi Wieder Scott Fritchie</p>
  </div>
  <div class="page">
    <p>Corfu is Available on GitHub</p>
    <p>github.com/CorfuDB/CorfuDB</p>
    <p>CONFIDENTIAL 31</p>
  </div>
  <div class="page">
    <p>fin Questions?</p>
  </div>
  <div class="page">
    <p>We Take the Tango [1] Approach</p>
    <p>Where clients interact with objects, and a runtime manages interactions with the log. Each object is contained within a stream, which is the set of updates for that object.</p>
    <p>Log Tail -1</p>
    <p>A: -1 B: -1</p>
    <p>Counter A 0</p>
    <p>Get</p>
    <p>Increment</p>
    <p>Counter B 0</p>
    <p>[1] Tango: Distributed Data Structures over a Shared Log. Mahesh Balakrishnan, Dahlia Malkhi, Ted Wobber, Ming Wu, Vijayan Prabhakaran, Michael Wei, John D. Davis, Sriram Rao, Tao Zou, Aviad Zuck. SOSP 2013: The 24th ACM Symposium on Operating Systems Principles.</p>
  </div>
  <div class="page">
    <p>Example: Incrementing a Counter</p>
    <p>When the client increments the counter, the runtime asks the sequencer for the next address for the stream of the given counter</p>
    <p>Log Tail -1</p>
    <p>A: -1 B: -1</p>
    <p>Counter A 0</p>
    <p>Increment</p>
    <p>Counter B 0</p>
    <p>Next, A?</p>
  </div>
  <div class="page">
    <p>Example: Incrementing a Counter</p>
    <p>And the runtime can now write a increment record to the log replica, writing the previous stream address given in the record, known as a backpointer.</p>
    <p>Log Tail 0</p>
    <p>A: 0 B: -1</p>
    <p>Counter A 0</p>
    <p>Increment</p>
    <p>Counter B 0</p>
    <p>Next, A?</p>
    <p>Global: 0, A:-1</p>
    <p>A:-1 A++</p>
  </div>
  <div class="page">
    <p>Example: Incrementing a Counter</p>
    <p>And the runtime can now write a increment record to the log replica, writing the previous stream address given in the record, known as a backpointer.</p>
    <p>Log Tail 1</p>
    <p>A: 1 B: -1</p>
    <p>Counter A 0</p>
    <p>Increment</p>
    <p>Counter B 0</p>
    <p>Next, A?</p>
    <p>Global: 1, A:0</p>
    <p>A:-1 A++</p>
    <p>A:0 A++</p>
  </div>
  <div class="page">
    <p>Example: Incrementing a Counter</p>
    <p>And the runtime can now write a increment record to the log replica, writing the previous stream address given in the record, known as a backpointer.</p>
    <p>Log Tail 2</p>
    <p>A: 1 B: 2</p>
    <p>Counter A 0</p>
    <p>Counter B 0</p>
    <p>Next, B?</p>
    <p>Global: 2, B:-1</p>
    <p>A:-1 A++</p>
    <p>A:0 A++</p>
    <p>B:-1 B++</p>
  </div>
  <div class="page">
    <p>Example: Reading a Counter</p>
    <p>To read, the runtime contacts the sequencer for the latest address issued to stream A. The client then reads all the updates, traversing the backpointers.</p>
    <p>Log Tail 2</p>
    <p>A: 1 B: 2</p>
    <p>Counter A 0</p>
    <p>Counter B 0</p>
    <p>Last, A?</p>
    <p>A: 1</p>
    <p>A:-1 A++</p>
    <p>A:0 A++</p>
    <p>B:-1 B++</p>
    <p>Get</p>
  </div>
  <div class="page">
    <p>Example: Reading a Counter</p>
    <p>The runtime keeps all the updates in memory until the entire stream has been read.</p>
    <p>Log Tail 2</p>
    <p>A: 1 B: 2</p>
    <p>Counter A 0</p>
    <p>Counter B 0</p>
    <p>Last, A?</p>
    <p>A: 1</p>
    <p>A:-1 A++</p>
    <p>A:0 A++</p>
    <p>B:-1 B++</p>
    <p>Get</p>
  </div>
  <div class="page">
    <p>Example: Reading a Counter</p>
    <p>Once the entire stream is read, the runtime applies the updates and returns the new value of the counter to the client.</p>
    <p>Log Tail 2</p>
    <p>A: 1 B: 2</p>
    <p>Counter A 2</p>
    <p>Counter B 0</p>
    <p>Last, A?</p>
    <p>A: 1</p>
    <p>A:-1 A++</p>
    <p>A:0 A++</p>
    <p>B:-1 B++</p>
    <p>Get</p>
  </div>
  <div class="page">
    <p>Example: Holes</p>
    <p>Holes due to failed clients can be a problem  they contain no information about backpointers, and require a linear scan if encountered.</p>
    <p>Log Tail 3</p>
    <p>A: 3 B: 2</p>
    <p>Counter A 2</p>
    <p>Counter B 0</p>
    <p>A:-1 A++</p>
    <p>A:0 A++</p>
    <p>B:-1 B++</p>
  </div>
  <div class="page">
    <p>Example: Incrementing Multiple Counters</p>
    <p>A multi-put is implemented by generating a single entry which is part of both streams.</p>
    <p>Log Tail 0</p>
    <p>A: 0 B: 0</p>
    <p>Counter A 0</p>
    <p>Increment</p>
    <p>Counter B 0</p>
    <p>Next, A,B?</p>
    <p>Global: 0, A:-1, B:-1 Increment</p>
    <p>A:-1, A++</p>
    <p>B:-1, B++</p>
  </div>
  <div class="page">
    <p>Example: Incrementing Multiple Counters... Conditionally</p>
    <p>To increment multiple counters conditionally, a transaction is created. The runtime keeps track of the read set (address or version of read objects) and the write set. At commit time, an entry with the read set and write set is written.</p>
    <p>Log Tail 1</p>
    <p>A: 0 B: 1</p>
    <p>Counter A 1</p>
    <p>Counter B 0</p>
    <p>Next, B?</p>
    <p>Global: 1 B:0</p>
    <p>A:-1, A++</p>
    <p>B:-1, B++ B: 0 A@0? B++</p>
    <p>if (A==1) {</p>
    <p>B++; }</p>
  </div>
  <div class="page">
    <p>vCorfu Stream Store Materializing Streams</p>
  </div>
  <div class="page">
    <p>Introducing a New Component: The Stream Replica</p>
    <p>In vCorfu, we add an additional component, a stream replica, which stores data indexed not on the log address, but a combination of the stream ID and the address in the stream.</p>
    <p>Log Replica Stream Replica</p>
    <p>B0 B1 B2 Z ? ?</p>
    <p>A0 A1 A2 X Y ?A</p>
    <p>B</p>
  </div>
  <div class="page">
    <p>Modifying an Existing Component: Sequencer now tracks Stream Addresses</p>
    <p>We also make a modification to the sequencer so it tracks the stream addresses used as an index for the stream replicas. This is a small counter with a small amount of state.</p>
    <p>Streaming Sequencer</p>
    <p>Log Tail 2</p>
    <p>A: G0/0 B: G2/2</p>
    <p>Gx (Global Address) /y (Stream Address)</p>
  </div>
  <div class="page">
    <p>Corfu / Tango Replica Sets</p>
    <p>In Corfu/Tango, the log is striped across replica sets, as described by the layout, and each replica set is replicated via chain replication.</p>
    <p>Log Tail -1</p>
    <p>A: -1 B: -1</p>
    <p>Counter A 0</p>
    <p>Counter B 0</p>
    <p>Replica Set Layout</p>
  </div>
  <div class="page">
    <p>Materialized Streams</p>
    <p>In vCorfu, the layout also maps each stream to a stream replica, which serve materialized views of each stream.</p>
    <p>Log Tail -1</p>
    <p>A: G-1/-1 B: G-1/-1</p>
    <p>Counter A 0</p>
    <p>Counter B 0</p>
    <p>Layout</p>
  </div>
  <div class="page">
    <p>Example: Incrementing a Counter</p>
    <p>To append to stream A, we now obtain a global address, backpointer and stream address from the sequencer</p>
    <p>Log Tail 0</p>
    <p>A: G0/0 B: G-1/-1</p>
    <p>Counter A 0</p>
    <p>Counter B 0</p>
    <p>Increment Next, A?</p>
    <p>Global: 0, A:G-1,0</p>
  </div>
  <div class="page">
    <p>Example: Incrementing a Counter</p>
    <p>Using the global (log) address, we write to the log replica</p>
    <p>Log Tail 0</p>
    <p>A: G0/0 B: G-1/-1</p>
    <p>Counter A 0</p>
    <p>Counter B 0</p>
    <p>Increment Next, A?</p>
    <p>Global: 0, A:G-1,0</p>
    <p>A:-1 A++</p>
  </div>
  <div class="page">
    <p>Example: Incrementing a Counter</p>
    <p>Then using the stream address, we write to the stream replica. Since this is the last write we will perform, we also indicate that it is okay to commit this write.</p>
    <p>Log Tail 0</p>
    <p>A: G0/0 B: G-1/-1</p>
    <p>Counter A 0</p>
    <p>Counter B 0</p>
    <p>Increment Next, A?</p>
    <p>Global: 0, A:G-1,0</p>
    <p>A:-1 A++</p>
    <p>A++</p>
  </div>
  <div class="page">
    <p>Example: Incrementing a Counter</p>
    <p>We then broadcast commit to any replicas we have written to. Replicas only serve committed data.</p>
    <p>Log Tail 0</p>
    <p>A: G0/0 B: G-1/-1</p>
    <p>Counter A 0</p>
    <p>Counter B 0</p>
    <p>Increment Next, A?</p>
    <p>Global: 0, A:-1</p>
    <p>A:-1 A++</p>
    <p>A++</p>
  </div>
  <div class="page">
    <p>Example: Incrementing a Counter</p>
    <p>As a result, each stream replica holds only the updates for each stream, which we refer to as a materialized stream when a stream replica is available.</p>
    <p>Log Tail 1</p>
    <p>A: G0/0 B: G1/0</p>
    <p>Counter A 0</p>
    <p>Counter B 0</p>
    <p>A:-1 A++</p>
    <p>A++ B++</p>
    <p>B:-1 B++</p>
    <p>Increment</p>
  </div>
  <div class="page">
    <p>Dynamic Replica Sets</p>
    <p>In vCorfu, replica sets are no longer static. Instead, we dynamically generate replica sets based on two indexes, the log address and the stream id plus stream address.</p>
    <p>Log Tail 1</p>
    <p>A: G0/0 B: G1/0</p>
    <p>Counter A 0</p>
    <p>Counter B 0</p>
    <p>A:-1 A++</p>
    <p>A++ B++</p>
    <p>B:-1 B++</p>
    <p>Increment</p>
    <p>Replica Set Replica Set</p>
  </div>
  <div class="page">
    <p>Dynamic Replica Sets</p>
    <p>So that in this example, three different replica sets are constructed, instead of the static chain replication protocol in Corfu/Tango.</p>
    <p>Log Tail 1</p>
    <p>A: G0/0 B: G1/0</p>
    <p>Counter A 0</p>
    <p>Counter B 0</p>
    <p>A:-1 A++</p>
    <p>A++ B++</p>
    <p>B:-1 B++</p>
    <p>Increment</p>
    <p>Replica Set Replica Set Replica Set</p>
    <p>B:1 B++</p>
  </div>
  <div class="page">
    <p>Example: Reading a Counter</p>
    <p>With materialized streams, reading is greatly simplified. Now instead of reading backpointers in sequence, we can read an entire stream with one request.</p>
    <p>Log Tail 2</p>
    <p>A: G0/0 B: G2/1</p>
    <p>Counter A 0</p>
    <p>Counter B 0</p>
    <p>A:-1 A++</p>
    <p>A++ B++</p>
    <p>B:-1 B++</p>
    <p>B++</p>
    <p>B:1 B++</p>
    <p>Get</p>
  </div>
  <div class="page">
    <p>Example: Reading a Counter</p>
    <p>Now we can easily update counter B without contacting multiple replicas.</p>
    <p>Log Tail 2</p>
    <p>A: G0/0 B: G2/1</p>
    <p>Counter A 0</p>
    <p>Counter B 2</p>
    <p>A:-1 A++</p>
    <p>A++ B++</p>
    <p>B:-1 B++</p>
    <p>B++</p>
    <p>B:1 B++</p>
    <p>Get</p>
  </div>
  <div class="page">
    <p>Remote Views and Local Views</p>
    <p>Having a single replica hold all the updates for a stream allows us to delegate playback to that replica.</p>
    <p>Log Tail 2</p>
    <p>A: G0/0 B: G2/1</p>
    <p>Counter A 0</p>
    <p>Counter B 2</p>
    <p>A:-1 A++</p>
    <p>A++ B++</p>
    <p>B:-1 B++</p>
    <p>B++</p>
    <p>B:1 B++</p>
    <p>Counter B 2</p>
    <p>Local View</p>
    <p>Remote View</p>
  </div>
  <div class="page">
    <p>Example: Reading a Counter with a Remote View</p>
    <p>With a remote view, the client doesnt need to have the updates or the state machine in memory.</p>
    <p>Log Tail 2</p>
    <p>A: G0/0 B: G2/1</p>
    <p>Counter A 0</p>
    <p>Counter B 2</p>
    <p>A:-1 A++</p>
    <p>A++ B++</p>
    <p>B:-1 B++</p>
    <p>B++</p>
    <p>B:1 B++</p>
    <p>Counter B 2</p>
    <p>Local View</p>
    <p>Remote View</p>
    <p>Get</p>
  </div>
  <div class="page">
    <p>Modifying an Existing Component: Lightweight Transaction Resolution</p>
    <p>By adding conditional address issuance, the sequencer can perform transaction resolution.</p>
    <p>Stream Sequencer w/ Lightweight</p>
    <p>Transaction Resolution</p>
    <p>Log Tail 2</p>
    <p>A: G0/0 B: G2/1</p>
    <p>Log Tail 2</p>
    <p>A: G0/0 B: G2/1</p>
    <p>Current, A?</p>
    <p>A: 0 Next, A?</p>
    <p>Next B@2, A?</p>
    <p>Reject</p>
  </div>
  <div class="page">
    <p>Example: Incrementing Multiple Counters Conditionally</p>
    <p>The transaction in this example reads counter B and increments counter A if counter B is equal to two.</p>
    <p>Log Tail 2</p>
    <p>A: G0/0 B: G2/1</p>
    <p>Counter A 0</p>
    <p>Counter B 2</p>
    <p>A:-1 A++</p>
    <p>A++ B++</p>
    <p>B:-1 B++</p>
    <p>B++</p>
    <p>B:1 B++</p>
    <p>if (B==2) {</p>
    <p>A++; }</p>
  </div>
  <div class="page">
    <p>Example: Incrementing Multiple Counters Conditionally</p>
    <p>The client performs this transaction optimistically, and requests an address only if counter B has not changed since the client accessed it. In this case, it has not, so the address is granted.</p>
    <p>Log Tail 3</p>
    <p>A: G3/1 B: G2/1</p>
    <p>Counter A 0</p>
    <p>Counter B 2</p>
    <p>A:-1 A++</p>
    <p>A++ B++</p>
    <p>B:-1 B++</p>
    <p>B++</p>
    <p>B:1 B++</p>
    <p>if (B==2) {</p>
    <p>A++; }</p>
    <p>Next B@2, A?</p>
  </div>
  <div class="page">
    <p>Example: Incrementing Multiple Counters Conditionally</p>
    <p>Now, clients can read this update directly, and a client trying to determine Counter As state does not need to read counter B at all.</p>
    <p>Log Tail 3</p>
    <p>A: G3/1 B: G2/2</p>
    <p>Counter A 0</p>
    <p>Counter B 2</p>
    <p>A:-1 A++</p>
    <p>A++ B++</p>
    <p>B:-1 B++</p>
    <p>B++</p>
    <p>B:1 B++</p>
    <p>if (B==2) {</p>
    <p>A++; }</p>
    <p>Next B@2, A?</p>
    <p>A:0 A++</p>
    <p>A++</p>
  </div>
  <div class="page">
    <p>Example: Incrementing Multiple Counters Conditionally</p>
    <p>In the case that another client modifies a read object, causing the optimistic view of counter B to become invalid</p>
    <p>Log Tail 3</p>
    <p>A: G0/0 B: G3/2</p>
    <p>Counter A 0</p>
    <p>Counter B 2</p>
    <p>A:-1 A++</p>
    <p>A++ B++</p>
    <p>B:-1 B++</p>
    <p>B++</p>
    <p>B:1 B++</p>
    <p>if (B==2) {</p>
    <p>A++; }</p>
    <p>A:0 A++</p>
    <p>B++</p>
    <p>B:2 B++</p>
  </div>
  <div class="page">
    <p>Example: Incrementing Multiple Counters Conditionally</p>
    <p>The sequencer will reject the clients request for an address  all by doing a simple comparison (B@0 &lt; 3).</p>
    <p>Log Tail 3</p>
    <p>A: G0/0 B: G3/2</p>
    <p>Counter A 0</p>
    <p>Counter B 2</p>
    <p>A:-1 A++</p>
    <p>A++ B++</p>
    <p>B:-1 B++</p>
    <p>B++</p>
    <p>B:1 B++</p>
    <p>if (B==2) {</p>
    <p>A++; }</p>
    <p>A:0 A++</p>
    <p>B++</p>
    <p>B:2 B++</p>
    <p>Next B@0, A?</p>
    <p>Reject</p>
  </div>
  <div class="page">
    <p>Example: Incrementing a Counter</p>
    <p>And the sequencer responds with the current global address and previous stream addresses, incrementing the counters for the log and the stream.</p>
    <p>Log Tail 0</p>
    <p>A: 0 B: -1</p>
    <p>Counter A 0</p>
    <p>Increment</p>
    <p>Counter B 0</p>
    <p>Next, A?</p>
    <p>Global: 0, A:-1</p>
  </div>
</Presentation>
