<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Considerations for Mondriaan-like Systems</p>
    <p>Emmett Witchel</p>
    <p>University of Texas at Austin</p>
  </div>
  <div class="page">
    <p>Mondriaan Aint Pixie Dust Say, I need some metadata for my research project.</p>
    <p>You do?</p>
    <p>Yeah, fine-grained with no alignment</p>
    <p>restrictions.</p>
    <p>Dude, check out this Mondriaan</p>
    <p>pixie dust!</p>
    <p>Researcher A Researcher B</p>
    <p>NO</p>
  </div>
  <div class="page">
    <p>The Fate of Multi-Paper Projects</p>
    <p>I love computer science conferences  But they emphasize novelty</p>
    <p>Features disappear because they dont work  Features disappear for lack of space  Difficult to summarize lessons learned</p>
    <p>Field will benefit from more reflection  Hey, isnt it called computer science?</p>
    <p>Give other researchers easier access  Here is how to make a convincing case</p>
  </div>
  <div class="page">
    <p>Why Mondriaan Attracts</p>
    <p>For every data word, I want metadata bits  Access permissions  Synchronization group  Information flow control tag</p>
    <p>Mondriaan memory protection (MMP)  Metadata for every 32-bit word  No alignment restrictions  Compatible with ISAs, no segments, no warts</p>
    <p>Data</p>
    <p>Metadata</p>
  </div>
  <div class="page">
    <p>MMP Hardware</p>
    <p>Memory Permissions Table</p>
    <p>Refill</p>
    <p>Software writes table</p>
    <p>Hardware reads it</p>
    <p>CPU Protection Lookaside Buffer (PLB)</p>
    <p>Perm. Table Base</p>
    <p>Similar to page table</p>
  </div>
  <div class="page">
    <p>Mondriaan Trade-of</p>
    <p>For a high-performance Mondriaan-like design, these must balance</p>
    <p>Space  More metadata, more space for table</p>
    <p>PLB refill (from memory) penalty  Minimize refills (maximize reach) &amp; fast refills</p>
    <p>Software overheads writing table entries  Infrequent updates &amp;/or simple table entries</p>
  </div>
  <div class="page">
    <p>Satisfying A Mondriaan Design</p>
    <p>Space</p>
    <p>WritesPLB</p>
    <p>It works! (high performance)</p>
    <p>Probability of a design just falling into the working region on its own = 0</p>
  </div>
  <div class="page">
    <p>Example Mondriaan Issue</p>
    <p>Space</p>
    <p>WritesPLB</p>
    <p>Table entries space overhead is acceptable  PLB misses too much and/or expensive misses  Permissions table is fast to write</p>
  </div>
  <div class="page">
    <p>Engineering a Mondriaan System</p>
    <p>Space</p>
    <p>WritesPLB</p>
    <p>Table entries space overhead is acceptable  Increase the size of the PLB  Permissions table is fast to write</p>
  </div>
  <div class="page">
    <p>Talk Outline</p>
    <p>Motivation  Mondriaan primer  Comparison of Mondriaan-like systems</p>
    <p>Goal is to give researchers a quick way to justify a Mondriaan-like design  Any design should address these 3 issues  It took me a while to see the relationship</p>
  </div>
  <div class="page">
    <p>Mondriaan Overview</p>
    <p>Redzone memory allocations  Prevent accidental overwrite  Example has 3 permission zones</p>
    <p>CPU checks load, store, execute</p>
    <p>Read/write</p>
    <p>No access</p>
    <p>Returned from</p>
    <p>malloc</p>
  </div>
  <div class="page">
    <p>Permissions Table Design  Organized like a heirarchical page table (trie)</p>
    <p>with three levels.  Space overhead mostly in lowest level</p>
    <p>Last level, 4B entry for 16 words  ~6.3% space overhead</p>
    <p>Measure ratio size of MMP tables to data in use  0.4%  8.3% measured (fragmentation)</p>
    <p>P</p>
    <p>P</p>
    <p>Find perm. for 0x1004</p>
  </div>
  <div class="page">
    <p>Lowest Level Entries</p>
    <p>Bitmapped entry  2 bit permissions values for 16 data words</p>
    <p>Run-length (RLE) encoded entry  Break data into fixed number of zones (4)  Specify length of each permission zone</p>
    <p>Perm. 0 Length 0 Perm. 1 Length 1 Perm. 2 Length 2 Perm. 3 Length 3</p>
  </div>
  <div class="page">
    <p>Run-length Encoded (RLE) Entries</p>
    <p>RLE Entries are harder for software to write than bitmapped entries</p>
    <p>RLE Entries cannot represent every pattern of metadata  Need bitmapped entries as fallback</p>
    <p>Perm. 0 Length 0 Perm. 1 Length 1 Perm. 2 Length 2 Perm. 3 Length 3</p>
    <p>Only works if number of zones  4 for 16 words</p>
    <p>YES NO</p>
  </div>
  <div class="page">
    <p>RLE Dangers</p>
    <p>The more RLEs save space, they will require more bitmap fallbacks  1 RLE for 16 words allows 4 zones  1 RLE for 32 words allows 4 zones</p>
    <p>A bitmap fallback entry  Adds a memory reference to PLB refill  Roughly doubles space overhead</p>
    <p>Space optimization can hurt PLB refill cost and potentially increase space used</p>
  </div>
  <div class="page">
    <p>i = 0</p>
    <p>PLB Entries Need Reach  For fine-grained metadata, bitvector</p>
    <p>entries only cover 16 words.</p>
    <p>Permissions Table</p>
    <p>PLB</p>
    <p>for(i = 0; i &lt; 24; ++i) { A[i] = 0; }</p>
    <p>Table Entry Executing code</p>
    <p>Execution history</p>
    <p>A+0 0 3rd X</p>
    <p>A+16 0 3rd</p>
    <p>i=1</p>
    <p>X X</p>
    <p>i=15</p>
    <p>X</p>
    <p>i=16</p>
    <p>Addr. PD Lev</p>
  </div>
  <div class="page">
    <p>Overlapping Entries Increase Reach Permissions Table</p>
    <p>Run-length encoding allows entry to hold information outside owning region  Only possible if entry has small (4 or fewer)</p>
    <p>number of permission zones  Usually must update multiple entries for each</p>
    <p>table write</p>
  </div>
  <div class="page">
    <p>i = 0</p>
    <p>For fine-grained data, overlapping entries can cover 79 words.</p>
    <p>Permissions Table</p>
    <p>PLBTable Entry</p>
    <p>Execution history</p>
    <p>A+0 0 3rd X</p>
    <p>for(i = 0; i &lt; 24; ++i) { A[i] = 0; }</p>
    <p>Executing code X</p>
    <p>i=23</p>
    <p>X</p>
    <p>i=1</p>
    <p>Overlapping Entries Reduce PLB Misses</p>
    <p>Addr. PD Lev</p>
  </div>
  <div class="page">
    <p>MMPs use of RLE Entries</p>
    <p>Same space as bitmap entries  4B per 16 words</p>
    <p>Increases PLB reach  Entry contains protection information outside</p>
    <p>those 16 words</p>
    <p>Increases table write cost  Information for adjacent entries overlap  Must write multiple entries on each update</p>
  </div>
  <div class="page">
    <p>Mondriaan-like Systems</p>
    <p>SPEC 2000  2 bit permissions  RLE entries for PLB reach</p>
    <p>Mondrix (Linux + MMP)  2 bit permissions  Modify kernel allocators for PLB reach  Bitmap entries to keep down software costs</p>
    <p>Colorama  14 bit ColorID  RLE entries for space and PLB reach</p>
    <p>Loki  32 bit information flow control tag  RLE entries to save space</p>
  </div>
  <div class="page">
    <p>SPEC 2000 [ASPLOS 2002]</p>
    <p>Space overhead acceptable (0.4%  8.3%)  PLB has insufficiently small reach (too much refill)  Did not evaluate software cost of writing table</p>
  </div>
  <div class="page">
    <p>SPEC 2000 [ASPLOS 2002]</p>
    <p>Use overlapping RLE entries  Does not change space  Increases PLB reach  Most entries represented with 4 zones in 16 words</p>
    <p>Did not evaluate software cost of writing table</p>
  </div>
  <div class="page">
    <p>Mondrix [SOSP 2005]</p>
    <p>Space overhead acceptable  PLB has insufficiently small reach (too much refill)  Writing RLE entries 3x slower than writing bitmaps</p>
    <p>A lot of writing permissions tables  E.g., twice on every network packet received</p>
  </div>
  <div class="page">
    <p>Mondrix [SOSP 2005]</p>
    <p>Space is good (less than 1%)  Use bitmap entries, modify kernel memory allocator</p>
    <p>Coarser-grained protection  PLB refills (0.4%  4%)  Optimize writing bitmapped entries (1.3  9%)</p>
    <p>Read/write</p>
    <p>No access</p>
    <p>Returned from</p>
    <p>malloc Returned from</p>
    <p>malloc</p>
  </div>
  <div class="page">
    <p>Colorama</p>
    <p>Ceze et. al. [HPCA 2007]  Explicitly uses Mondriaan</p>
    <p>Some data structures given a ColorID (14 bits)  Updates to data of the same color happen</p>
    <p>atomically and in isolation  Processor checks ColorIDs to synchronize</p>
    <p>Any dynamic memory allocation might be colored  Allocation is frequent (e.g., every 1,900 inst)</p>
  </div>
  <div class="page">
    <p>Colorama [HPCA 2007]</p>
    <p>Space overhead an issue  Uses RLE entries with 14-bit IDs (~19%)</p>
    <p>PLB miss rate should be comparable to MMP  Did not evaluate software cost of writing table</p>
  </div>
  <div class="page">
    <p>Colorama [HPCA 2007]</p>
    <p>Space</p>
    <p>WritesPLB</p>
    <p>Space overheads measured 3  25%  Most data structures have 1 color (optimize more?)  Therefore RLE representability should be fine (few zones)</p>
    <p>PLB has sufficient reach using RLE entries  Did not evaluate software cost of writing table</p>
  </div>
  <div class="page">
    <p>Loki</p>
    <p>Zeldovich et. al. [OSDI 2008]  All data has a 32-bit security tag</p>
    <p>Tag per page, space overhead is ~0.1%  Tag per word, space overhead is 100%</p>
    <p>PLB structure is diferent  Map from address to tag  Independent map from tag to access permissions</p>
  </div>
  <div class="page">
    <p>Loki [OSDI 2008]</p>
    <p>Space</p>
    <p>WritesPLB</p>
    <p>Space overhead an issue (up to 65%)  PLB has sufficient reach  Tags are updated infrequently</p>
  </div>
  <div class="page">
    <p>Loki [OSDI 2008]</p>
    <p>Space</p>
    <p>WritesPLB</p>
    <p>Space overhead an issue (up to 65%)  RLE could help, but representability an issue</p>
    <p>PLB has sufficient reach  Tags are updated infrequently</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>For a high-performance Mondriaan-like design, you must balance these factors</p>
    <p>Space  Estimate worst-case ratio of metadata to data</p>
    <p>PLB refill (sufficient reach + fast refill)  Fine-grained entries kill PLB performance</p>
    <p>Software overheads writing tables  Measure frequency &amp; benchmark code</p>
  </div>
</Presentation>
