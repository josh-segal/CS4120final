<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Jitk: A trustworthy in-kernel interpreter infrastructure</p>
    <p>Xi Wang, David Lazar, Nickolai Zeldovich, Adam Chlipala, Zachary Tatlock MIT and University of Washington</p>
  </div>
  <div class="page">
    <p>Modern OSes run untrusted user code in kernel</p>
    <p>In-kernel interpreters Seccomp: sandboxing (Linux) BPF: packet filtering INET_DIAG: socket monitoring Dtrace: instrumentation</p>
    <p>Critical to overall system security Any interpreter bugs are serious!</p>
  </div>
  <div class="page">
    <p>Many bugs have been found in interpreters</p>
    <p>See our paper for a case study of bugs</p>
    <p>Kernel space bugs</p>
    <p>Kernel-user interface bugs</p>
    <p>User space bugs</p>
    <p>Some have security consequences: CVE-2014-2889, ...</p>
    <p>Control flow errors: incorrect jump offset, ... Arithmetic errors: incorrect result, ... Memory errors: buffer overflow, ... Information leak: uninitialized read</p>
    <p>Incorrect encoding/decoding</p>
    <p>Incorrect input generated by tools/libraries</p>
  </div>
  <div class="page">
    <p>How to get rid of all these bugs at once?</p>
  </div>
  <div class="page">
    <p>Theorem proving can help kill all these bugs</p>
    <p>seL4: provably correct microkernel [SOSP'09]</p>
    <p>CompCert: provably correct C compiler [CACM'09]</p>
    <p>This talk: Jitk</p>
    <p>Provably correct interpreter for running untrusted user code</p>
    <p>Drop-in replacement for Linux's seccomp</p>
    <p>Built using Coq proof assistant + CompCert</p>
  </div>
  <div class="page">
    <p>Theorem proving: overview</p>
    <p>specification proof implementation</p>
    <p>Proof is machine-checkable: Coq proof assistant Proof: correct specification correct implementation Specification should be much simpler than implementation</p>
  </div>
  <div class="page">
    <p>Challenges</p>
    <p>What is the specification?</p>
    <p>How to translate systems properties into proofs?</p>
    <p>How to extract a running system?</p>
  </div>
  <div class="page">
    <p>Contributions &amp; outline</p>
    <p>Specifications: capture systems properties Theorems: ensure correctness of implementation Integrate Jitk with Linux kernel</p>
  </div>
  <div class="page">
    <p>Seccomp: reduce allowed syscalls</p>
    <p>Example: if syscall is open, return some errno App cannot open new files, even if it's compromised later</p>
  </div>
  <div class="page">
    <p>Seccomp/BPF example: OpenSSH</p>
    <p>ld [0] ; load syscall number jeq #SYS_open, L1, L2</p>
    <p>L1: ret #RET_ERRNO|#EACCES ; deny open() with errno = EACCES L2: jeq #SYS_gettimeofday, L3, L4</p>
    <p>L3: ret #RET_ALLOW ; allow gettimeofday() L4: ...</p>
    <p>ret #RET_KILL ; default: kill current process</p>
    <p>Deny open() with errno EACCES Allow gettimeofday(), ... Kill the current process if seeing other syscalls</p>
  </div>
  <div class="page">
    <p>Summary of seccomp</p>
    <p>Security critical: sandboxing mechanism Widely used: by Chrome, OpenSSH, QEMU, Tor, ... Performance critical: invoked for each syscall Non-trivial to do right: many bugs have been found General: similar design found in multiple OS kernels</p>
  </div>
  <div class="page">
    <p>Specification: what seccomp should do</p>
    <p>Goal: enforce user-specified syscall policies in kernel</p>
    <p>What kernel executes is what user specifies Kernel: BPF-to-x86 for execution BPF transferred from user space to kernel User space: write down policies as BPF</p>
    <p>Non-interference with kernel Termination: no crash nor infinite loop Bounded stack usage: no kernel stack overflow</p>
  </div>
  <div class="page">
    <p>Jitk 1/3: BPF-to-x86 for execution</p>
    <p>JIT: translate BPF to x86 for in-kernel execution</p>
    <p>JIT is error-prone: CVE-2014-2889</p>
    <p>jcc = ...; /* conditional jump opcode */ if (filter[i].jf)</p>
    <p>true_offset += is_near(false_offset) ? 2 : 6; EMIT_COND_JMP(jcc, true_offset);</p>
    <p>if (filter[i].jf)</p>
    <p>EMIT_JMP(false_offset);</p>
    <p>Goal: Jitk's output x86 code preserves the behavior of input BPF x86 code cannot have buffer overflow, control-flow bugs, ...</p>
  </div>
  <div class="page">
    <p>BPF-to-x86 correctness: state machine simulation</p>
    <p>Model BPF and x86 as two state machines: by reading manuals</p>
    <p>Theorem (backward simulation):</p>
    <p>BPF state: 2 regs, fixed-size memory, input, program counter BPF instruction: state transition x86: [...] - reused from CompCert</p>
    <p>If JIT succeeds, every state transition in output x86 corresponds to some state transition(s) in input BPF.</p>
  </div>
  <div class="page">
    <p>Jitk's approach for BPF-to-x86</p>
    <p>Strawman: write &amp; prove BPF-to-x86 translator Backward simulation is hard to prove Big semantic gap between BPF and x86</p>
    <p>Prove forward simulation and convert Every state transition in BPF corresponds to some state transition(s) in output x86 Conversion possible if lower level (x86) is deterministic</p>
    <p>Add intermediate languages between BPF and x86 Choose Cminor (&quot;simpler&quot; C) from CompCert as detour BPF-to-x86: BPF-to-Cminor + CompCert's Cminor-to-x86</p>
  </div>
  <div class="page">
    <p>Jitk 2/3: user-kernel interface correctness</p>
    <p>Goal: BPF is correctly decoded in kernel</p>
    <p>App submits BPF in bytecode from user space to kernel Kernel decodes bytecode back to BPF - bugs happened!</p>
    <p>Alternative approach: state machine simulation Spec: state machine for bytecode representation Simulation: bytecode BPF  BPF Challenge: spec is as complex as implementation</p>
  </div>
  <div class="page">
    <p>Jitk's approach: user-kernel BPF equivalence</p>
    <p>Two functions: encode() and decode() Choose a much simpler spec: equivalence</p>
    <p>Trade-off: can have &quot;consistent&quot; bugs</p>
    <p>f : encode(f) = b decode(b) = f</p>
    <p>encode() and decode() could make the same mistake decode() could behave differently from existing BPF</p>
  </div>
  <div class="page">
    <p>Jitk 3/3: input BPF correctness</p>
    <p>Goal: input BPF is &quot;correct&quot;</p>
    <p>ld [0] ; load syscall number jeq #SYS_open, L1, L2</p>
    <p>L1: ret #RET_ERRNO|#EACCES ; deny open() with errno = EACCES L2: jeq #SYS_gettimeofday, L3, L4</p>
    <p>L3: ret #RET_ALLOW ; allow gettimeofday() L4: ...</p>
    <p>ret #RET_KILL ; default: kill current process</p>
    <p>BPF</p>
    <p>Does this BPF correctly implement policies? Is the BPF spec correct?</p>
  </div>
  <div class="page">
    <p>Jitk's approach: add a higher level</p>
    <p>SCPL: domain-specific language for writing syscall policies</p>
    <p>{ default_action = Kill; rules = [ { action = Errno EACCES; syscall = SYS_open }; { action = Allow; syscall = SYS_gettimeofday }; ... ] }</p>
    <p>Much simpler than BPF  unlikely to make mistakes SCPL-to-x86 = SCPL-to-BPF + BPF-to-x86</p>
    <p>Proof: state machine simulation Use SCPL: don't need to trust BPF spec Improve confidence in BPF spec</p>
  </div>
  <div class="page">
    <p>Summary of Jitk's approaches</p>
    <p>State machine simulation: BPF-to-x86 and SCPL-to-BPF</p>
    <p>Equivalence: user-kernel data passing</p>
    <p>Add extra levels in-between to bridge gap Forward simulation to backward simulation More abstraction, more confidence</p>
    <p>Trade-off: simpler spec vs. can have &quot;consistent&quot; bugs</p>
  </div>
  <div class="page">
    <p>Development: write shaded boxes</p>
  </div>
  <div class="page">
    <p>Integrate Jitk (shaded boxes) with Linux kernel SCPL rules</p>
    <p>SCPL compiler</p>
    <p>BPF JIT</p>
    <p>Native code</p>
    <p>User</p>
    <p>Kernel</p>
    <p>ApplicationBPF bytecode</p>
    <p>Syscall</p>
    <p>Helper</p>
    <p>Modify Linux kernel to invoke BPF-to-x86 translator</p>
    <p>Modify Linux kernel to invoke output x86 code for each syscall</p>
    <p>Run the translator as a trusted user-space process</p>
    <p>The translator includes OCaml runtime &amp; GNU assembler</p>
  </div>
  <div class="page">
    <p>Jitk's theorems can stop a large class of bugs</p>
    <p>Manually inspected existing bugs</p>
    <p>Kernel space bugs: BPF-to-x86 correctness</p>
    <p>Kernel-user interface bugs: user-kernel BPF equivalence</p>
    <p>User space bugs: SCPL-to-BPF correctness</p>
    <p>Control flow errors] Arithmetic errors] Memory errors] Information leak]</p>
    <p>Incorrect encoding/decoding]</p>
    <p>Incorrect input generated by tools/libraries]</p>
  </div>
  <div class="page">
    <p>What Jitk's theorems cannot stop</p>
    <p>Over-strict: Jitk could reject correct input SCPL/BPF</p>
    <p>Side channel: JIT spraying attacks</p>
    <p>Bugs in specifications: SCPL, BPF, x86</p>
    <p>Bugs in CompCert's TCB: Coq, OCaml runtime, GNU assembler</p>
    <p>Bugs in other parts of Linux kernel</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>How much effort does it take to build Jitk?</p>
    <p>What is the end-to-end performance?</p>
    <p>Does Jitks JIT produce efficient x86 code?</p>
  </div>
  <div class="page">
    <p>Building effort is moderate</p>
  </div>
  <div class="page">
    <p>End-to-end performance overhead is low</p>
    <p>Base</p>
    <p>Stock Linux</p>
    <p>Jitk</p>
    <p>Time for 1M gettimeofday syscalls (msec)</p>
    <p>OpenSSH on Linux/x86</p>
    <p>Jitk's BPF-to-x86 one-time overhead: 20 msec per session Time for 1M gettimeofday syscalls: smaller is better (in msec)</p>
    <p>Stock Linux: interpreter (no x86 JIT support) Jitk: JIT</p>
  </div>
  <div class="page">
    <p>Jitk produces good (often better) code</p>
    <p>Output x86 code size comparison (smaller is better)</p>
    <p>FreeBSD Jitk</p>
    <p>OpenSSH vsftpd NaCl QEMU Firefox Chrome Tor 0</p>
    <p>Existing BPF JITs have very limited optimizations</p>
    <p>Jitk leverages optimizations from CompCert</p>
  </div>
  <div class="page">
    <p>Related work</p>
    <p>Theorem proving: seL4, CompCert Model checking &amp; testing: EXE, KLEE Microkernel, SFI, type-safe languages</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>Jitk: run untrusted user code in kernel with theorem proving</p>
    <p>Strong correctness guarantee Good performance Approaches for proving systems properties</p>
  </div>
</Presentation>
