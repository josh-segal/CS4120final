<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Dowsing for overflows: a guided fuzzer to find buffer boundary violations</p>
    <p>Istvan Haller, Asia Slowinska, Matthias Neugschwandtner, Herbert Bos</p>
    <p>Usenix Security 2013 August 14, 2013</p>
  </div>
  <div class="page">
    <p>Bugs, bugs everywhere</p>
    <p>Buffer overflows still represent a top 3 threat (after 40 years)</p>
    <p>Applications grow at a rapid pace, testing cannot keep up</p>
    <p>Containment of software faults?</p>
    <p>Solve the root cause via automated testing!</p>
  </div>
  <div class="page">
    <p>Possibility of automated testing</p>
    <p>Static analysis</p>
    <p>Deployed in practice</p>
    <p>Difficult to make path-sensitive and inter-procedural</p>
    <p>Lack of accuracy makes for many FPs/FNs</p>
    <p>Symbolic execution</p>
    <p>Observations only relevant for given execution path</p>
    <p>Core focus is on input generation</p>
    <p>Goal is to achieve significant code coverage</p>
    <p>Exponential in nature (input/code)</p>
  </div>
  <div class="page">
    <p>Testing model</p>
    <p>Search for buffer overflows</p>
    <p>Dowser focuses on complex loops</p>
    <p>Other approaches for simple pointer computation</p>
    <p>Source code available: Typical in testing</p>
    <p>Existing test inputs to reach every complex loop</p>
  </div>
  <div class="page">
    <p>Example</p>
    <p>Nginx web server, buffer overflow in URI parser</p>
    <p>Application too complex for traditional tools</p>
    <p>Complete code coverage may not even the trigger bug!</p>
    <p>while (p &lt;= r-&gt;uri_end) // &gt;300 lines of code</p>
    <p>switch (state)</p>
    <p>case sw_usual: *u++ = ch; ... case sw_slash: *u++ = ch; ... ...</p>
    <p>case sw_dot: *u++ = ch; ... if (ch == /) u--; ...</p>
    <p>case sw_dot_dot: *u++ = ch; ... if (ch == /) u -= 4; ...</p>
    <p>...</p>
  </div>
  <div class="page">
    <p>Testing with Dowser</p>
    <p>Objective: focus the testing effort around specific high-priority code fragments</p>
    <p>Spot-checking instead of looking at general picture</p>
    <p>Builds on symbolic execution, guided by in-depth analysis</p>
    <p>End-to-end solution starting from source-code:</p>
  </div>
  <div class="page">
    <p>Dowsing</p>
    <p>Identify and rank loops based on bug probability</p>
  </div>
  <div class="page">
    <p>Dowsing in a nutshell</p>
    <p>Static analysis during compilation process</p>
    <p>Search for loops containing pointer dereference</p>
    <p>Analyze data-flow graph to infer complexity measure</p>
  </div>
  <div class="page">
    <p>Applied to real software</p>
    <p>Compare the ranking efficiency of the proposed heuristic to instruction counting and random order</p>
    <p>Buffer overflows reported in CVE for: nginx, ffmpeg, inspircd, libexif, poppler, snort, sendmail</p>
    <p>% of analysis groups analyzed</p>
    <p>% o</p>
    <p>f b u g s</p>
    <p>d e te</p>
    <p>ct e d</p>
    <p>Dowser Count Random</p>
  </div>
  <div class="page">
    <p>Input tracking</p>
    <p>Only sub-set of input is relevant for spot-checking Infer relationships between inputs and candidate loops</p>
  </div>
  <div class="page">
    <p>Example input: HTTP Request</p>
    <p>Long input with multiple tokens.</p>
    <p>GET /long/path/file HTTP/1.1 Host: thisisthehost.com Content-Type: application/x-www-form-urlencoded Content-Length: 1337</p>
  </div>
  <div class="page">
    <p>Highlight of HTTP Request</p>
    <p>Only small part influences given loop</p>
    <p>GET /long/path/file HTTP/1.1 Host: thisisthehost.com Content-Type: application/x-www-form-urlencoded Content-Length: 1337</p>
    <p>Dynamic information flow tracking</p>
    <p>Track the influence of input on variables</p>
    <p>Can be performed at different granularities (details in paper)</p>
  </div>
  <div class="page">
    <p>Benefits of input reduction</p>
    <p>Symbolic execution is input driven in nature</p>
    <p>Provides implicit fine-grained modularization</p>
    <p>Enables symbolic execution for applications with large input</p>
    <p>Conversion table in movie file for ffmpeg Font description in PDF file for poppler</p>
  </div>
  <div class="page">
    <p>Bug search</p>
    <p>Guide symbolic execution towards potential bug</p>
  </div>
  <div class="page">
    <p>Basics of symbolic execution</p>
    <p>White-box fuzzing</p>
    <p>Avoid generating input that replicates execution path</p>
    <p>Run-time feed-back about possible execution paths</p>
    <p>Aimed at test-case generation</p>
  </div>
  <div class="page">
    <p>Snippet of symbolic execution</p>
    <p>Constraint solver used to check for possible divergence</p>
  </div>
  <div class="page">
    <p>Analyzing symbolic execution</p>
    <p>In practice input reduction was found to be insufficient</p>
    <p>Large number of conditional branches still to be covered</p>
    <p>Only some conditional statements are relevant</p>
    <p>if (a[i] == A)</p>
    <p>printf(...);</p>
    <p>Focus on the branches influencing pointer value</p>
    <p>Value Coverage search strategy</p>
  </div>
  <div class="page">
    <p>Value Coverage vs traditional search strategies</p>
    <p>S e a rc</p>
    <p>h t im</p>
    <p>e (</p>
    <p>s e c o n</p>
    <p>d s )</p>
    <p>Symbolic Input Bytes</p>
    <p>Depth First Search</p>
    <p>Code Coverage</p>
    <p>Value Coverage</p>
  </div>
  <div class="page">
    <p>Details behind Value Coverage Search</p>
    <p>Only some execution paths are relevant to pointer arithmetic</p>
    <p>Learn the general behavior of conditionals using small inputs</p>
    <p>Result: 66% of conditionals eliminated</p>
    <p>Influence on example:</p>
    <p>while (p &lt;= r-&gt;uri_end)</p>
    <p>switch (state)</p>
    <p>case sw_usual: *u++ = ch; case sw_slash: *u++ = ch; case sw_dot: *u++ = ch;</p>
    <p>if (ch == /) u--; case sw_dot_dot: *u++ = ch;</p>
    <p>if (ch == /) u -= 4;</p>
  </div>
  <div class="page">
    <p>Details behind Value Coverage Search</p>
    <p>Only some execution paths are relevant to pointer arithmetic</p>
    <p>Learn the general behavior of conditionals using small inputs</p>
    <p>Result: 66% of conditionals eliminated</p>
    <p>Influence on example:</p>
    <p>while (p &lt;= r-&gt;uri_end)</p>
    <p>switch (state)</p>
    <p>case sw_usual: *u++ = ch; case sw_slash: *u++ = ch; case sw_dot: *u++ = ch;</p>
    <p>if (ch == /) u--; case sw_dot_dot: *u++ = ch;</p>
    <p>if (ch == /) u -= 4;</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Program LoC Symbolic Symbolic execution Input Symbex M-Symbex Dowser</p>
    <p>nginx 0.6.32 66k URI field &gt; 8 h &gt; 8 h 253 sec</p>
    <p>ffmpeg 0.5 300k Huffman table &gt; 8 h &gt; 8 h 48 sec</p>
    <p>inspircd 1.1.22 45k DNS response 200 sec 200 sec 32 sec</p>
    <p>poppler 0.15.0 120k JPEG image &gt; 8 h &gt; 8 h 14 sec</p>
    <p>poppler 0.15.0 120k Embedded font &gt; 8 h &gt; 8 h 762 sec</p>
    <p>libexif 0.6.20 10k EXIF tag/length &gt; 8 h 652 sec 652 sec</p>
    <p>libexif 0.6.20 10k EXIF tag/length &gt; 8 h 347 sec 347 sec</p>
    <p>libexif 0.6.20 10k EXIF tag/length &gt; 8 h 277 sec 277 sec</p>
    <p>snort 2.4.0 75k UDP packet &gt; 8 h &gt; 8 h 617 sec</p>
    <p>Table: Bugs detected with Dowser.</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>End-to-end solution for guided symbolic execution</p>
    <p>The spot-check approach enables focused search</p>
    <p>Built-in prioritization mechanism to optimize testing effort</p>
    <p>Heuristics geared towards buffer overflow type bugs</p>
    <p>Dowser shows scalability beyond traditional tools</p>
  </div>
</Presentation>
