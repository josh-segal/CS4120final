<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>Coordinated and Efficient Huge Page Management with Ingens</p>
    <p>Youngjin Kwon, Hangchen Yu, Simon Peter, Christopher J. Rossbach, and Emmett Witchel</p>
  </div>
  <div class="page">
    <p>High address translation cost  Modern applications: large memory footprint, low memory access locality  TLB coverage using base pages is insufficient</p>
    <p>C pu</p>
    <p>c yc</p>
    <p>le s</p>
    <p>% of cpu cycles spent by page walk Virtual address</p>
    <p>Physical address</p>
    <p>Page table</p>
  </div>
  <div class="page">
    <p>High address translation cost</p>
    <p>C pu</p>
    <p>c yc</p>
    <p>le s</p>
    <p>Guest page table walk Host page table walk</p>
    <p>% of cpu cycles spent by page walk Virtual address</p>
    <p>Guest physical address</p>
    <p>Host physical address</p>
    <p>Guest page table</p>
    <p>Host page table</p>
    <p>Virtualization requires additional address translation</p>
  </div>
  <div class="page">
    <p>Huge pages improve TLB coverage  Architecture supports larger page size (e.g., 2MB page)</p>
    <p>Intel: 0 to 1,536 entries in 2 years (2013 ~ 2015)</p>
    <p>Operating system has the burden of better huge page support</p>
    <p>Sandy Bridge Ivy Bridge Haswell Skylake</p>
    <p>TLB coverage proportional to 64 GB DRAM</p>
  </div>
  <div class="page">
    <p>Operating system support for huge pages  OS transparently allocates/deallocates huge pages</p>
    <p>Huge pages in both guest and host</p>
    <p>Linux</p>
    <p>FreeBSD</p>
    <p>LWN.net, 2011</p>
  </div>
  <div class="page">
    <p>Huge pages improve performance  Application speed up over using base pages only</p>
    <p>S pe</p>
    <p>ed u</p>
    <p>p</p>
    <p>cf</p>
    <p>(S pe</p>
    <p>c C PU</p>
    <p>)</p>
    <p>Ca nn</p>
    <p>ea l</p>
    <p>(P AR</p>
    <p>SE C)</p>
    <p>SV M</p>
    <p>(L ibl</p>
    <p>ine ar</p>
    <p>)</p>
    <p>Gr ap</p>
    <p>h a na</p>
    <p>lyt ics</p>
    <p>(P ow</p>
    <p>er Gr</p>
    <p>ap h)</p>
    <p>Ma ch</p>
    <p>ine le</p>
    <p>ar nin</p>
    <p>g</p>
    <p>(S pa</p>
    <p>rk ML</p>
    <p>lib )</p>
    <p>W eb</p>
    <p>se rve</p>
    <p>r</p>
    <p>(C lou</p>
    <p>ds ton</p>
    <p>e) Re dis</p>
    <p>Mo ng</p>
    <p>oD B</p>
    <p>B et</p>
    <p>te r</p>
    <p>Av er ag e</p>
  </div>
  <div class="page">
    <p>Are huge pages a free lunch?</p>
  </div>
  <div class="page">
    <p>Are huge pages a free lunch?</p>
  </div>
  <div class="page">
    <p>Are huge pages a free lunch?</p>
  </div>
  <div class="page">
    <p>Are huge pages a free lunch?</p>
  </div>
  <div class="page">
    <p>Are huge pages a free lunch?</p>
  </div>
  <div class="page">
    <p>Huge page pathologies in Linux</p>
    <p>High page fault latency</p>
    <p>Memory bloating</p>
    <p>Unfair huge page allocation</p>
    <p>Uncoordinated memory management</p>
  </div>
  <div class="page">
    <p>Huge page pathologies in Linux</p>
    <p>High page fault latency</p>
    <p>Memory bloating</p>
    <p>Unfair huge page allocation</p>
    <p>Uncoordinated memory management</p>
  </div>
  <div class="page">
    <p>Ingens Efficient huge page management system</p>
    <p>Linux Ingens</p>
    <p>Synchronous allocation</p>
    <p>Asynchronous allocation</p>
    <p>Greedy allocation Spatial utilization based allocation</p>
    <p>How to allocate huge pages?</p>
    <p>Problems</p>
    <p>High page fault latency</p>
    <p>Memory bloating</p>
  </div>
  <div class="page">
    <p>High page fault latency</p>
  </div>
  <div class="page">
    <p>Huge page allocation increases page fault latency</p>
    <p>Page allocation path of both base and huge page</p>
    <p>Allocate page(s) Get page(s) from free page list</p>
    <p>Zero the page(s)Map the page(s) to page table</p>
    <p>Page fault handler Physical memory manager</p>
    <p>Application pause</p>
    <p>Application resume</p>
    <p>Page fault latency  4KB page : 3.6 us  2MB page : 378.0 us (mostly from page zeroing)  Increases tail latency</p>
  </div>
  <div class="page">
    <p>Huge page allocation might require extra memory copying</p>
    <p>Page allocation path of huge page</p>
    <p>Get page(s) from free page list</p>
    <p>Zero the page(s)Map the page(s) to page table</p>
    <p>Page fault handler Physical memory manager</p>
    <p>Application pause</p>
    <p>Application resume</p>
    <p>Allocate page(s)</p>
  </div>
  <div class="page">
    <p>Huge page allocation might require extra memory copying</p>
    <p>Page allocation path of huge page</p>
    <p>Get page(s) from free page list</p>
    <p>Zero the page(s)Map the page(s) to page table</p>
    <p>Page fault handler Physical memory manager</p>
    <p>Not enough contiguous memory</p>
    <p>Application pause</p>
    <p>Application resume</p>
    <p>Allocate page(s)</p>
  </div>
  <div class="page">
    <p>External fragmentation</p>
    <p>Not enough contiguous memory</p>
  </div>
  <div class="page">
    <p>External fragmentation</p>
    <p>Virtual address</p>
    <p>Physical address</p>
    <p>Huge page boundary B</p>
    <p>B</p>
    <p>B</p>
    <p>B</p>
    <p>B</p>
    <p>B Allocated Base page</p>
    <p>Not enough contiguous memory</p>
    <p>B  As system ages, physical memory is</p>
    <p>fragmented</p>
    <p>2 minutes to fragment 24 GB</p>
    <p>All memory sizes eventually fragment</p>
    <p>Linux compacts physical memory to create contiguous pages</p>
  </div>
  <div class="page">
    <p>External fragmentation</p>
    <p>Virtual address</p>
    <p>Physical address</p>
    <p>Huge page boundary</p>
    <p>B</p>
    <p>B</p>
    <p>B</p>
    <p>B Allocated Base page</p>
    <p>Not enough contiguous memory</p>
    <p>B</p>
    <p>B  As system ages, physical memory is</p>
    <p>fragmented</p>
    <p>2 minutes to fragment 24 GB</p>
    <p>All memory sizes eventually fragment</p>
    <p>Linux compacts physical memory to create contiguous pages</p>
  </div>
  <div class="page">
    <p>External fragmentation</p>
    <p>As system ages, physical memory is fragmented</p>
    <p>2 minutes to fragment 24 GB</p>
    <p>All memory sizes eventually fragment</p>
    <p>Linux compacts physical memory to create contiguous pages</p>
    <p>Virtual address</p>
    <p>Physical address</p>
    <p>Huge page boundary</p>
    <p>B</p>
    <p>B</p>
    <p>B</p>
    <p>B</p>
    <p>B</p>
    <p>B Allocated Base page</p>
    <p>Not enough contiguous memory</p>
    <p>H</p>
  </div>
  <div class="page">
    <p>External fragmentation Not enough</p>
    <p>contiguous memory</p>
  </div>
  <div class="page">
    <p>Huge page allocation might require extra memory copying</p>
    <p>Page allocation path of huge page includes memory compaction</p>
    <p>Get page(s) from free page list</p>
    <p>Zero the page(s)Map the page(s) to page table</p>
    <p>Page fault handler Physical memory manager</p>
    <p>Not enough contiguous memory</p>
    <p>Application pause</p>
    <p>Application resume</p>
    <p>Allocate page(s)</p>
  </div>
  <div class="page">
    <p>Huge page allocation might require extra memory copying</p>
    <p>Page allocation path of huge page includes memory compaction</p>
    <p>Get page(s) from free page list</p>
    <p>Zero the page(s)Map the page(s) to page table</p>
    <p>Page fault handler Physical memory manager</p>
    <p>Not enough contiguous memory</p>
    <p>Compact physical memory</p>
    <p>Application pause</p>
    <p>Application resume</p>
    <p>Allocate page(s)</p>
  </div>
  <div class="page">
    <p>Huge page allocation might require extra memory copying</p>
    <p>Page allocation path of huge page includes memory compaction</p>
    <p>Get page(s) from free page list</p>
    <p>Zero the page(s)Map the page(s) to page table</p>
    <p>Page fault handler Physical memory manager</p>
    <p>Not enough contiguous memory</p>
    <p>Compact physical memory</p>
    <p>Compaction may or may not succeed</p>
    <p>Application pause</p>
    <p>Application resume</p>
    <p>Allocate page(s)</p>
  </div>
  <div class="page">
    <p>Ingens: asynchronous allocation</p>
    <p>Page fault handler</p>
    <p>Asynchronous promotion</p>
    <p>Page fault handler only allocates base pages</p>
    <p>Huge page allocation in background</p>
    <p>Memory compaction in background</p>
    <p>No extra page fault latency  No huge page zeroing  No compaction</p>
    <p>bit vector 1 bit per</p>
    <p>base page</p>
    <p>Read/update on each base page fault</p>
    <p>Promotion Kernel thread</p>
    <p>Fast page fault handling</p>
  </div>
  <div class="page">
    <p>Page fault latency experiment  Machine specification</p>
    <p>Two Intel Xeon E5-2640 2.60GHz CPUs</p>
    <p>64GB memory and two 250 MB SSDs</p>
    <p>Cloudstone workload (latency sensitive)</p>
    <p>Web service for social event planning</p>
    <p>nginx/PHP/MySQL running in virtual machines</p>
    <p>85% read, 10% login, 5% write workloads</p>
    <p>2 of 7 web pages modified to use modern web page sizes  The average web page is 2.1 MB</p>
    <p>https://www.soasta.com/blog/page-bloat-average-web-page-2-mb/</p>
  </div>
  <div class="page">
    <p>Cloudstone result</p>
    <p>Memory is highly fragmented</p>
    <p>Ingens reduces  average latency up to 29.2%  tail latency up to 41.4%</p>
    <p>Linux page fault handler performs 461,383 memory compactions</p>
    <p>Linux Ingens</p>
    <p>Throughput (requests/s)</p>
    <p>Latency (millisecond)</p>
    <p>Avg. 90th Avg. 90th</p>
    <p>Linux Ingens</p>
    <p>View event Visit home page</p>
    <p>B et</p>
    <p>te r</p>
  </div>
  <div class="page">
    <p>Cloudstone result</p>
    <p>Memory is highly fragmented</p>
    <p>Ingens reduces  average latency up to 29.2%  tail latency up to 41.4%</p>
    <p>Linux page fault handler performs 461,383 memory compactions</p>
    <p>Linux Ingens</p>
    <p>Throughput (requests/s)</p>
    <p>Latency (millisecond)</p>
    <p>Avg. 90th Avg. 90th</p>
    <p>Linux Ingens</p>
    <p>View event Visit home page</p>
    <p>B et</p>
    <p>te r</p>
  </div>
  <div class="page">
    <p>Memory bloating</p>
    <p>Application occupies more memory than it uses</p>
  </div>
  <div class="page">
    <p>Internal fragmentation</p>
    <p>Greedy allocation in Linux</p>
    <p>Allocate a huge page on first fault to huge page region</p>
    <p>The huge page region may not be fully used</p>
    <p>Greedy allocation causes severe internal fragmentation</p>
    <p>Memory use often sparse</p>
    <p>Virtual address</p>
    <p>Physical address</p>
    <p>Huge page boundary</p>
    <p>H</p>
    <p>H</p>
    <p>Used virtual address</p>
    <p>Unused virtual address</p>
    <p>Huge page region</p>
    <p>H</p>
  </div>
  <div class="page">
    <p>Memory bloating experiment</p>
    <p>Redis</p>
    <p>Delete 70% objects after populating 8KB objects</p>
    <p>MongoDB</p>
    <p>15 million get requests for 1KB object with YCSB</p>
    <p>Using huge page</p>
    <p>Using only base page</p>
    <p>Redis 20.7GB (+69%)</p>
    <p>MongoDB 12.4GB (+23%) 10.1GB</p>
    <p>Physical memory consumption</p>
    <p>Bloating makes memory consumption unpredictable Memory-intensive applications cant provision to avoid swap</p>
  </div>
  <div class="page">
    <p>Ingens: Spatial utilization based allocation</p>
    <p>Ingens monitors spatial utilization of each huge page region</p>
    <p>Utilization-based allocation</p>
    <p>Page fault handler requests promotion when the utilization is beyond a threshold (e.g., 90%)</p>
    <p>Bounds the size of internal fragmentation</p>
    <p>Virtual address</p>
    <p>Physical address</p>
    <p>H</p>
    <p>B</p>
    <p>B</p>
    <p>B</p>
    <p>B</p>
  </div>
  <div class="page">
    <p>Redis memory bloating experiment</p>
    <p>Physical memory consumption</p>
    <p>GET throughput</p>
    <p>Linux (base only)</p>
    <p>Linux (huge)Ingens</p>
    <p>Linux (base only) Linux (huge)</p>
    <p>Ingens</p>
    <p>- 4%+ 10%</p>
    <p>Better</p>
    <p>Better</p>
    <p>Huge : 2MB page Base : 4KB page</p>
  </div>
  <div class="page">
    <p>Ingens overhead  Overhead for memory intensive application</p>
    <p>Overhead for non-memory intensive application</p>
    <p>Kernel build Grep Parsec 3.0 Benchmark</p>
    <p>Ingens overhead is negligible</p>
  </div>
  <div class="page">
    <p>Linux Ingens</p>
    <p>Synchronous allocation</p>
    <p>Asynchronous allocation</p>
    <p>Greedy allocation Spatial utilization based allocation</p>
    <p>Ingens Make huge pages widely used in practice</p>
    <p>Source code is available at https://github.com/ut-osa/ingens</p>
    <p>Advantages</p>
    <p>No extra page fault latency</p>
    <p>Bound memory bloating</p>
  </div>
  <div class="page">
    <p>Backup slides</p>
  </div>
  <div class="page">
    <p>Other operating systems  Window, MacOS</p>
    <p>Does not support transparent huge page</p>
    <p>FreeBSD</p>
    <p>Very conservative approach</p>
    <p>No memory compaction functionality</p>
    <p>Performance speedup in Linux and FreeBSD</p>
    <p>SVM Canneal Redis FreeBSD 1.28 1.13 1.02 Linux 1.30 1.21 1.15 Ingens 1.29 1.19 1.15</p>
  </div>
  <div class="page">
    <p>User-controlled huge page management  Admin reserves huge page in advance  New APIs for memory allocation/deallocation  It could fail to reserve huge pages when memory is</p>
    <p>fragmented</p>
    <p>Transparent huge page management  Developers do not know about huge page  OS Transparently allocates/deallocates huge pages  OS manages memory fragmentation</p>
    <p>Operating system support for huge pages</p>
  </div>
</Presentation>
