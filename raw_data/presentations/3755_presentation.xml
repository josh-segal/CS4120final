<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>FuzzGuard: Filtering out Unreachable Inputs in Directed Grey-box Fuzzing through Deep Learning</p>
    <p>Peiyuan Zong1,2, Tao Lv1,2, Dawei Wang1,2, Zizhuang Deng1,2, Ruigang Liang1,2, Kai Chen1,2 * 1 SKLOIS, Institute of Information Engineering, Chinese Academy of Sciences, Beijing, China</p>
  </div>
  <div class="page">
    <p>Mutation based Grey-box Fuzzing Overview</p>
    <p>Coverage-based Grey-box Fuzzing (CGF)</p>
    <p>Directed Grey-box Fuzzing (DGF)</p>
    <p>Seed Mutator Seed Queue Target Program</p>
    <p>Execution ResultsInteresting SeedsFuzzer</p>
  </div>
  <div class="page">
    <p>Mutation based Grey-box Fuzzing Overview</p>
    <p>Seed Mutator Seed Queue Target Program</p>
    <p>Execution ResultsInteresting SeedsFuzzer</p>
    <p>Crash!</p>
    <p>Crash!</p>
    <p>Coverage-based Grey-box Fuzzing (CGF) Trigger more crashes.</p>
  </div>
  <div class="page">
    <p>Mutation based Grey-box Fuzzing Overview</p>
    <p>Coverage-based Grey-box Fuzzing (CGF) Trigger more crashes.</p>
    <p>Directed Grey-box Fuzzing (DGF) Check whether a target code really contains a bug.</p>
    <p>Seed Mutator Seed Queue Target Program</p>
    <p>Execution ResultsInteresting SeedsFuzzer</p>
    <p>Crash!</p>
    <p>Crash!</p>
    <p>Crash!</p>
  </div>
  <div class="page">
    <p>DGF: lots of inputs cannot reach the buggy code</p>
    <p>Vulnerable code</p>
    <p>Crash reproduction</p>
    <p>Patch testing</p>
    <p>Potentially vulnerable code checking</p>
  </div>
  <div class="page">
    <p>Annealing-based Power Schedules</p>
    <p>Fuzz the input closer to the target longer.</p>
    <p>DGF: lots of inputs cannot reach the buggy code</p>
    <p>Vulnerable code</p>
    <p>How to reach the vulnerable code? Crash reproduction</p>
    <p>Patch testing</p>
    <p>Potentially vulnerable code checking</p>
  </div>
  <div class="page">
    <p>Annealing-based Power Schedules</p>
    <p>Fuzz the input closer to the target longer.</p>
    <p>DGF: lots of inputs cannot reach the buggy code</p>
    <p>Vulnerable code</p>
    <p>Over 91.7% of the inputs missed the vulnerable code!</p>
    <p>How to reach the vulnerable code? Crash reproduction</p>
    <p>Patch testing</p>
    <p>Potentially vulnerable code checking</p>
  </div>
  <div class="page">
    <p>DGF: lots of inputs cannot reach the buggy code</p>
    <p>Vulnerable code</p>
    <p>Over 91.7% of the inputs missed the vulnerable code!</p>
    <p>How to reach the vulnerable code?</p>
    <p>Annealing-based Power Schedules</p>
    <p>Fuzz the input closer to the target longer.</p>
    <p>Symbolic execution</p>
    <p>Solve path conditions for each new path.</p>
    <p>Crash reproduction</p>
    <p>Patch testing</p>
    <p>Potentially vulnerable code checking</p>
  </div>
  <div class="page">
    <p>DGF: lots of inputs cannot reach the buggy code</p>
    <p>Vulnerable code</p>
    <p>Over 91.7% of the inputs missed the vulnerable code!</p>
    <p>How to reach the vulnerable code?</p>
    <p>High overhead requires!</p>
    <p>Annealing-based Power Schedules</p>
    <p>Fuzz the input closer to the target longer.</p>
    <p>Symbolic execution</p>
    <p>Solve path conditions for each new path.</p>
    <p>Crash reproduction</p>
    <p>Patch testing</p>
    <p>Potentially vulnerable code checking</p>
  </div>
  <div class="page">
    <p>Our approach: Build an input filter for the Fuzzer</p>
    <p>Build a Deep Learning Model (Filter)</p>
    <p>Learn from previous executions.</p>
    <p>To identify the inputs which can reach the buggy code.</p>
    <p>Seed Mutator Seed Queue Target Program</p>
    <p>Execution ResultsInteresting SeedsFuzzer</p>
    <p>Filter</p>
    <p>Without running the target program</p>
  </div>
  <div class="page">
    <p>Challenges  C1: Lack of balanced labeled data.  In the early stage of fuzzing, there is even no reachable input.  Without balanced labeled data, the trained model will be overfitting.</p>
    <p>C2: Lack of representative data.  Newly inputs look quite different from the reachable ones in the training set.  The trained model will fail to predict the reachability of the new inputs.</p>
    <p>C3: Efficiency.  The time cost of training and prediction should be strictly limited.</p>
  </div>
  <div class="page">
    <p>Overview of FuzzGuard</p>
  </div>
  <div class="page">
    <p>Phase 1: Model Initialization</p>
  </div>
  <div class="page">
    <p>Phase 1: Model Initialization C1: Lack of balanced labeled data.</p>
    <p>Step-forwarding approach</p>
    <p>Collect and map the inputs and their execution path.</p>
    <p>Choosing the dominators of the buggy code as the middle-stage targets.</p>
    <p>Letting the execution reach the pre-dominating nodes first.</p>
  </div>
  <div class="page">
    <p>Phase 1: Model Initialization C1: Lack of balanced labeled data.</p>
    <p>Step-forwarding approach</p>
    <p>Collect and map the inputs and their execution path.</p>
    <p>Choosing the dominators of the buggy code as the middle-stage targets.</p>
    <p>Letting the execution reach the pre-dominating nodes first.</p>
  </div>
  <div class="page">
    <p>Phase 2: Model Prediction</p>
  </div>
  <div class="page">
    <p>Phase 2: Model Prediction</p>
    <p>Representative data selection</p>
    <p>Sample training data from each round of mutation.</p>
    <p>Calculate seed similarity degree (SSD) and sample fewer inputs for similar ones.</p>
    <p>C2: Lack of representative data.</p>
    <p>Testing data</p>
    <p>Training data</p>
  </div>
  <div class="page">
    <p>Phase 3: Model Updating</p>
  </div>
  <div class="page">
    <p>Phase 3: Model Updating</p>
    <p>Incremental Learning</p>
    <p>Keep collect training data for updating model.</p>
    <p>Incremental train the model when a new mid-target node gains balanced data.</p>
    <p>C3: Efficiency</p>
  </div>
  <div class="page">
    <p>Effectiveness Summary  Dataset  45 bugs in 10 real-world programs</p>
    <p>with different file formats.</p>
    <p>Results  1.3x -17.1x speedup (5.4x averagely)  The earlier the model is trained, the</p>
    <p>more time could be saved.</p>
    <p>The more reachable inputs generated by the carrier fuzzer, the less effective FuzzGuard is.</p>
  </div>
  <div class="page">
    <p>Contribution of Individual Techniques</p>
    <p>Without the step-forwarding approach  Gain only 2.6x speedup averagely.  14/45 bugs cannot be trained.</p>
  </div>
  <div class="page">
    <p>Contribution of Individual Techniques</p>
    <p>Without the step-forwarding approach  Gain only 2.6x speedup averagely.  14/45 bugs cannot be trained.</p>
    <p>Without the representative data selection  Gain only 4.4x speedup averagely.  The accuracy dramatically decreases</p>
    <p>in some cases.</p>
  </div>
  <div class="page">
    <p>Understanding &amp; Future Work</p>
    <p>Understanding</p>
    <p>The key features learned by the model are related to the key bytes in the PoC.</p>
    <p>Future Work</p>
    <p>The benefit to input mutation.</p>
    <p>Vulnerable code</p>
  </div>
  <div class="page">
    <p>Conclusion</p>
    <p>FuzzGuardA deep-learning-based approach to predict reachability of program inputs without execution.</p>
    <p>Step-forwarding approach for handling unbalanced data training.</p>
    <p>Representative data selection for training data collection.</p>
    <p>Incremental learning for the dynamic model.</p>
    <p>Increase the runtime performance of the vanilla AFLGo from 1.3x to 17.1x.</p>
  </div>
  <div class="page">
    <p>Q&amp;A</p>
    <p>Thanks for Listening!</p>
    <p>Code Release: https://github.com/zongpy/FuzzGuard.</p>
  </div>
</Presentation>
