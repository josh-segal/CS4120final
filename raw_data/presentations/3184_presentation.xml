<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>TRUESET: Faster Verifiable Set Computations</p>
    <p>Ahmed E. Kosba, Dimitrios Papadopoulos, Charalampos Papamanthou</p>
    <p>Mahmoud F. Sayed, Elaine Shi, Nikos Triandopoulos</p>
    <p>University of Maryland, College Park</p>
    <p>Boston University</p>
    <p>RSA Laboratories</p>
    <p>USENIX Security14</p>
    <p>August 22nd, 2014</p>
  </div>
  <div class="page">
    <p>Outsourcing of Storage and Computations</p>
    <p>Integrity/Correctness Concerns</p>
    <p>Making VC practical Short Proof - Short Verification Time - Short Proof Computation Time</p>
    <p>Input u</p>
    <p>Output F(u)  Proof</p>
    <p>Verifier Prover</p>
    <p>Verifiable Computation (VC)</p>
    <p>Client Devices</p>
    <p>Cloud Services</p>
    <p>Not there yet!!</p>
  </div>
  <div class="page">
    <p>Verifiable Set Operations</p>
    <p>The proof computation time is very high for current generic VC systems.</p>
    <p>It can take 100+ seconds to produce a proof for an intersection of two 256element sets.</p>
    <p>TRUESET provides orders of magnitude better performance  More than 100x Speed-up achieving &lt; 1 second in the above case.</p>
    <p>SELECT UNIVERSITY.id</p>
    <p>FROM UNIVERSITY JOIN CS</p>
    <p>ON UNIVERSITY.id = CS.id Similarity =</p>
    <p>| |</p>
    <p>| |</p>
    <p>SQL Join Queries Jaccard index</p>
    <p>A p</p>
    <p>p li</p>
    <p>ca ti</p>
    <p>o n</p>
    <p>s</p>
  </div>
  <div class="page">
    <p>Verifiable Computation</p>
    <p>void func(struct Input* in,</p>
    <p>struct Output* out){</p>
    <p>/* subset of C */</p>
    <p>}</p>
    <p>Approaches:  Secure hardware based  Replication based  Cryptography based</p>
    <p>Characteristics:  Compact Constant-size Proof, e.g. 288 bytes for Pinocchio  Short Verification Time: O(size of IO)  High Proof Computation Time</p>
    <p>+ x</p>
    <p>x</p>
    <p>Each individual operation is mapped to a set of gates or constraints</p>
    <p>BCGTV [Ben-sasson et al, Crypto13] Pinocchio [Parno et al, IEEE S&amp;P13] Pantry [Braun et al, SOSP13]</p>
  </div>
  <div class="page">
    <p>Arithmetic Representation of Set Operations is Expensive</p>
    <p>Set Cardinality</p>
    <p>P ro</p>
    <p>o f</p>
    <p>T im</p>
    <p>e</p>
    <p>Another challenge: Have to account for the worstcase set size during proof computation.</p>
    <p>Arithmetic Set Circuit</p>
    <p>C</p>
    <p>.. ..</p>
    <p>..</p>
    <p>A B</p>
    <p>+ x</p>
    <p>x</p>
    <p>+ x</p>
    <p>x</p>
    <p>+ x</p>
    <p>x</p>
    <p>+ x</p>
    <p>x. . . .</p>
  </div>
  <div class="page">
    <p>TRUESET Goals:</p>
    <p>Reduce proof computation time for set operations</p>
    <p>Achieve input-specific running time for the prover</p>
    <p>Retain the expressiveness of previous techniques</p>
    <p>Main Idea:</p>
    <p>Arithmetic Set Circuit</p>
    <p>D</p>
    <p>.. ..</p>
    <p>..</p>
    <p>A B</p>
    <p>+ x</p>
    <p>x</p>
    <p>+ x</p>
    <p>x</p>
    <p>+ x</p>
    <p>x</p>
    <p>+ x</p>
    <p>x. . . .</p>
    <p>..</p>
    <p>CA B C</p>
    <p>U</p>
    <p>D</p>
    <p>Polynomial Set Circuit</p>
    <p>A(z) B(z) C(z)</p>
    <p>D(z)</p>
    <p>+ x</p>
    <p>x + x</p>
    <p>x</p>
    <p>instead of</p>
  </div>
  <div class="page">
    <p>Sets as Polynomials</p>
    <p>Represent a set A = { a1, a2, , an} by an n-degree polynomial A(z) = (z+a1)(z+a2) .. (z+an)</p>
    <p>Polynomial Intersection Circuit</p>
    <p>(z+1)(z+2) (z+2)(z+3)</p>
    <p>(z+2)</p>
    <p>Polynomial Intersection Circuit</p>
    <p>(z+3)(z+4) (z+5)(z+6)</p>
    <p>Two Primary Advantages:</p>
    <p>The circuit size is constant for set operations.  The effort correlates with the degrees of the polynomials on the wires.</p>
  </div>
  <div class="page">
    <p>How to build O(1) circuits for set operations?</p>
  </div>
  <div class="page">
    <p>Efficient Set Circuits</p>
    <p>Intersection Gate</p>
    <p>)()()(</p>
    <p>)()()(</p>
    <p>)()()()()(</p>
    <p>zBzIz</p>
    <p>zAzIz</p>
    <p>zIzBzzAz</p>
    <p>GCD(A, B)</p>
    <p>The witness polynomials can be calculated by the Extended Euclidean algorithm for polynomials.</p>
    <p>I(z) = GCD(A(z), B(z)) iff there exists polynomials   ,  ,  ,  such that</p>
  </div>
  <div class="page">
    <p>Efficient Set Circuits</p>
    <p>Union and Difference gates can be built similarly.</p>
    <p>)()()(</p>
    <p>)()()(</p>
    <p>)()()(</p>
    <p>)()()()()(</p>
    <p>zUzAz</p>
    <p>zBziz</p>
    <p>zAziz</p>
    <p>zizBzzAz</p>
    <p>)()()(</p>
    <p>)()()(</p>
    <p>)()()()()(</p>
    <p>zBziz</p>
    <p>zAzizD</p>
    <p>zizBzzAz</p>
  </div>
  <div class="page">
    <p>Retaining Expressiveness</p>
    <p>Hybrid Queries:</p>
    <p>TrueSet provides a set of useful gates to ensure expressiveness</p>
    <p>Zero-degree assertion gate.</p>
    <p>Split and Merge gates.</p>
    <p>Cardinality gate.</p>
    <p>Input sets</p>
    <p>Output Value</p>
    <p>SELECT COUNT(UNIVERSITY.id)</p>
    <p>FROM UNIVERSITY JOIN CS</p>
    <p>ON UNIVERSITY.id = CS.id + x</p>
    <p>x</p>
    <p>+ x</p>
    <p>x</p>
    <p>+ x x</p>
    <p>Arith. Circuit</p>
    <p>Set Circuit + x</p>
    <p>x</p>
  </div>
  <div class="page">
    <p>How to build verifiable polynomial circuits protocol?</p>
  </div>
  <div class="page">
    <p>Quadratic Arithmetic Programs (QAPs)</p>
    <p>[Gennaro et al. EUROCRYPT13, Parno et al. IEEE S&amp;P13]</p>
    <p>+ x</p>
    <p>x</p>
    <p>c1 c2 c3 c4</p>
    <p>c5</p>
    <p>c6</p>
    <p>Equivalent Constraints</p>
    <p>c5 = c3.c4 c6 = c5.(c1 + c2)</p>
    <p>( =1  ()) ( =1</p>
    <p>()) - ( =1  ()) = ()()</p>
    <p>where</p>
    <p>t(x) = (x  r1) (x  r2) .. (x  rd)</p>
    <p>vk, wk and yk are polynomials defined based on the circuit structure.</p>
  </div>
  <div class="page">
    <p>Quadratic Polynomial Programs (QPPs)</p>
    <p>Equivalent Constraints</p>
    <p>c5(z) = c3(z).c4(z) c6(z) = c5(z).(c1(z) + c2(z))</p>
    <p>( =1  ()()) ( =1</p>
    <p>()()) - ( =1  ()()) = ()(,)</p>
    <p>where</p>
    <p>t(x) = (x  r1) (x  r2) .. (x  rd)</p>
    <p>vk, wk and yk are polynomials defined based on the circuit structure.</p>
    <p>+ x</p>
    <p>x</p>
    <p>c1(z) c2(z) c3(z) c4(z)</p>
    <p>c5(z)</p>
    <p>c6(z)</p>
    <p>Bivariate Polynomial</p>
  </div>
  <div class="page">
    <p>Verifiable Polynomial Circuits</p>
    <p>Protocol outline:</p>
    <p>u</p>
    <p>F(u),</p>
    <p>Eval. KeyVerif. Key</p>
  </div>
  <div class="page">
    <p>Implementation</p>
    <p>Added support to Pinocchios C++ implementation to handle verifiable polynomial circuits with loops.</p>
    <p>Used open-source libraries to handle field and crypto operations: NTL and nifty ate-pairing.</p>
    <p>Operations are done in a Field Fp where p is a 254-bit prime. Bit security level is 127.</p>
    <p>Comparison with two Pinocchio implementations:  The original executable by Microsoft Research (MS-Pinocchio)  An executable that uses the same polynomial and crypto libraries as</p>
    <p>TrueSet (NTL-ZM Pinocchio)</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Comparison:  Two variants for Pinocchio set circuit programs:</p>
    <p>A pair-wise approach requiring O(n2) equality-check gates.</p>
    <p>A sorting-network approach requiring O(n log2(n)) comparator gates.</p>
    <p>Set 1 Set 2</p>
    <p>Odd Even Merge Sort</p>
    <p>.....</p>
    <p>.</p>
    <p>Check for a duplicate</p>
    <p>O(n log2(n)) comparators</p>
    <p>O(n) equality gates</p>
    <p>Example Intersection Circuit using a Sorting Network</p>
  </div>
  <div class="page">
    <p>Evaluation</p>
    <p>Set Programs:  Single union operation</p>
    <p>Multi set operations</p>
    <p>The input sets contain random elements from the field Fp.</p>
    <p>For each input set size, a different circuit was produced for Pinocchio alternatives.</p>
    <p>U</p>
    <p>A B C D E F G H</p>
    <p>U U</p>
    <p>U</p>
    <p>U</p>
    <p>OUT</p>
  </div>
  <div class="page">
    <p>Proof Computation Speedup</p>
    <p>Proof Computation  Single Gate</p>
    <p>ro o</p>
    <p>f T</p>
    <p>im e</p>
    <p>( se</p>
    <p>c) Input Set Cardinality</p>
    <p>TrueSet</p>
    <p>NTL-ZM Pinocchio (pairwise)</p>
    <p>MS Pinocchio (pairwise)</p>
    <p>Proof Computation  Multi-gate</p>
    <p>P ro</p>
    <p>o f</p>
    <p>T im</p>
    <p>e (</p>
    <p>se c)</p>
    <p>Input Set Cardinality</p>
    <p>TrueSet</p>
    <p>NTL-ZM Pinocchio (pairwise)</p>
    <p>NTL-ZM Pinocchio (sorting network)</p>
    <p>MS Pinocchio (pairwise)</p>
    <p>MS Pinocchio (sorting network)</p>
    <p>&gt; 50x improvement when |s| = 64</p>
    <p>More than 90% savings in the evaluation key sizes.</p>
    <p>Retain almost similar verification times and verification keys sizes. |s| refers to each input set size</p>
  </div>
  <div class="page">
    <p>Optimizations / Extensions</p>
    <p>Optimizations  Bivariate polynomial operations</p>
    <p>Randomized check for output polynomial</p>
    <p>Case of outsourced sets  Usage of Merkle trees and bilinear accumulators.</p>
    <p>TrueSet provides inherent support for multisets, while other approaches will require more complexity.</p>
  </div>
  <div class="page">
    <p>Conclusions</p>
    <p>TRUESET a system that aims at reducing proof computation time for verifiable set computations.</p>
    <p>Modeling set operations as polynomial circuits helped achieve:</p>
    <p>Much better proof computation time (More than 100x when set size is 256)</p>
    <p>Great savings ( &gt; 90%) in the circuit evaluation key size</p>
    <p>Input-specific running time for the prover</p>
    <p>Is this practical yet?</p>
  </div>
  <div class="page">
    <p>Thank You  Questions?</p>
    <p>akosba@cs.umd.edu</p>
  </div>
</Presentation>
