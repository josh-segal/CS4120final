<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>A Novel Improvement to the R*-tree Spatial Index using Gain/Loss Metrics</p>
    <p>Donghui Zhang, Tian Xia</p>
    <p>Northeastern University</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Background and motivation  Definitions of some metrics  Algorithm sketches  Experimental results  Conclusion and future works</p>
  </div>
  <div class="page">
    <p>The R*-tree</p>
    <p>R1</p>
    <p>R2</p>
    <p>R5</p>
    <p>R3</p>
    <p>R4R6</p>
    <p>P1</p>
    <p>P2</p>
    <p>P3</p>
    <p>P4</p>
    <p>P5</p>
    <p>P6 P8</p>
    <p>P7</p>
    <p>P1 P2 P3 P4 P5 P6 P7 P8</p>
    <p>R5 R6</p>
    <p>R1 R2 R3 R4</p>
  </div>
  <div class="page">
    <p>a b</p>
    <p>c</p>
    <p>d</p>
    <p>Forced reinsertion in the R*-tree</p>
  </div>
  <div class="page">
    <p>Two goals</p>
    <p>overlap, therefore improves the range query performance.</p>
    <p>Observation: R*-trees action of picking objects can be improved.</p>
  </div>
  <div class="page">
    <p>a b</p>
    <p>c</p>
    <p>d</p>
    <p>A better choice</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Background and motivation  Definitions of some metrics</p>
    <p>Quality / Gain / Loss  p-boundary / minP-boundary</p>
    <p>Algorithm sketches  Experimental results  Conclusion and future works</p>
  </div>
  <div class="page">
    <p>Three constraints</p>
    <p>With same areas, the quality of a square is larger than a rectangle.</p>
    <p>With same shapes, the quality of a smaller rectangle is larger than a bigger rectangle.</p>
    <p>A rectangle is shrunk to another rectangle, the quality always increases.</p>
  </div>
  <div class="page">
    <p>Quality</p>
    <p>Definition: Given a rectangle r with width w and height h, the quality of r is</p>
    <p>) },max{</p>
    <p>},min{ (</p>
    <p>*</p>
    <p>hw</p>
    <p>hw</p>
    <p>hw rQ</p>
    <p>, [0,1], e.g. 0.5</p>
  </div>
  <div class="page">
    <p>Quality (example)</p>
    <p>Q=1</p>
    <p>Q=4</p>
    <p>Q=2</p>
    <p>Given  = 0.5,</p>
  </div>
  <div class="page">
    <p>Extension to d dimensions</p>
    <p>Given a d-dimensional rectangle r, whose edges have length h1,,hd, the quality of r is</p>
    <p>},...,max{ },...,min{1</p>
    <p>d d</p>
    <p>i i hh</p>
    <p>hh</p>
    <p>h</p>
  </div>
  <div class="page">
    <p>Gain / Loss</p>
    <p>Definition: the gain of shrinking rectangle r1 to r2 is</p>
    <p>Symmetrically, the loss of expanding r2 to r1 is defined as the gain of shrinking r1 to r2.</p>
    <p>)(</p>
    <p>)( 1),(</p>
    <p>rQ</p>
    <p>rQ rrG</p>
  </div>
  <div class="page">
    <p>Extension to a set of objects</p>
    <p>The quality of S is the quality of MBR(S).  The gain of removing a subset P from S, is</p>
    <p>the gain of shrinking MBR(S) to MBR(S-P).</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Background and motivation  Definitions of some metrics</p>
    <p>Quality / Gain / Loss  p-boundary and minP-boundary</p>
    <p>Algorithm sketches  Experimental results  Conclusion and future works</p>
  </div>
  <div class="page">
    <p>p-boundary</p>
    <p>If a page overflows, p objects will be removed fro m the page.</p>
    <p>The p-boundary is the optimal set of such p obje cts, which achieve the largest gain Gp.</p>
    <p>a b</p>
    <p>c</p>
    <p>d</p>
  </div>
  <div class="page">
    <p>minP-boundary</p>
    <p>Given a threshold  (e.g. 0.8), minP-boundary is t he smallest set which achieves gain no less than Gp.</p>
    <p>f</p>
    <p>e</p>
    <p>c</p>
    <p>df</p>
    <p>e</p>
    <p>c</p>
    <p>d</p>
  </div>
  <div class="page">
    <p>Modifications on the R*-tree</p>
    <p>The forced reinsertion algorithm picks the minP-boundary to re-insert.</p>
    <p>Reinsertion is not always enforced.  Apply Gain/Loss metrics on the process of</p>
    <p>choosing a subtree to accommodate a ne w entry.</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Background and motivation  Definitions of some metrics  Algorithm sketches  Experimental results  Conclusion and future works</p>
  </div>
  <div class="page">
    <p>Straightforward solution 1</p>
    <p>Enumerate all possible combinations of p objects in a page.</p>
    <p>The number of combinations is , which can be exponential in n.</p>
    <p>p</p>
    <p>n</p>
  </div>
  <div class="page">
    <p>Straightforward solution 2</p>
    <p>Enumerate all possible combinations among outside objects.</p>
    <p>The number of combinations could be exponential in p.</p>
    <p>e</p>
    <p>a c</p>
    <p>h</p>
    <p>f</p>
    <p>i</p>
    <p>g</p>
    <p>j</p>
    <p>b</p>
    <p>d</p>
    <p>k</p>
    <p>l</p>
    <p>p = 2</p>
    <p>only a, b, d, e, l and k may appear in the p-boundary.</p>
  </div>
  <div class="page">
    <p>Our idea</p>
    <p>Shrink the borders by levels.</p>
    <p>e</p>
    <p>a</p>
    <p>c</p>
    <p>h</p>
    <p>f</p>
    <p>i</p>
    <p>g</p>
    <p>j</p>
    <p>b</p>
    <p>d</p>
    <p>k</p>
    <p>l</p>
    <p>How to store the levels s.t. we can efficiently find and remove one lev el?</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Background and motivation  Definitions of some metrics  Algorithm sketches</p>
    <p>Border structure  Exhaustive algorithms  Greedy algorithms</p>
    <p>Experimental results  Conclusion and future works</p>
  </div>
  <div class="page">
    <p>Border structure</p>
    <p>a b c d e h k l</p>
    <p>TOP LEFT RIGHT BOTTOM</p>
    <p>a, b</p>
    <p>c, d</p>
    <p>e</p>
    <p>a, h b, k</p>
    <p>d</p>
    <p>k</p>
    <p>l</p>
    <p>LX=[5,6,7], LY=[20,21,22], HX=[10,9,8], HY=[25,24,23]</p>
    <p>e</p>
    <p>a</p>
    <p>c</p>
    <p>h</p>
    <p>f</p>
    <p>i</p>
    <p>g</p>
    <p>j</p>
    <p>b</p>
    <p>d</p>
    <p>k</p>
    <p>l</p>
    <p>p = 4</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Background and motivation  Definitions of some metrics  Algorithm sketches</p>
    <p>Border structure  Exhaustive algorithms  Greedy algorithms</p>
    <p>Experimental results  Conclusion and future works</p>
  </div>
  <div class="page">
    <p>Exhaustive search of p-boundary (Algorithm pick-p)</p>
    <p>Shrink the borders by levels.</p>
    <p>e</p>
    <p>a</p>
    <p>c</p>
    <p>h</p>
    <p>f</p>
    <p>i</p>
    <p>g</p>
    <p>j</p>
    <p>b</p>
    <p>d</p>
    <p>k</p>
    <p>l</p>
    <p>LX=[5,6,7], LY=[20,21,22], HX=[10,9,8], HY=[25,24,23]</p>
  </div>
  <div class="page">
    <p>Exhaustive search of p-boundary (Algorithm pick-p)</p>
    <p>A rectangle is valid if:  No more than p objects outside;  it is an MBR of all the objects inside;</p>
  </div>
  <div class="page">
    <p>Exhaustive search of p-boundary (Algorithm pick-p)</p>
    <p>Compute the gain of shrinking the original MBR to a valid rectangle, and keep the lar gest gain Gp and the corresponding combi nation.</p>
  </div>
  <div class="page">
    <p>Exhaustive search of minP-boundary (Algorithm pick-minP)</p>
    <p>To find optimal minP-boundary, store the intermediate results.</p>
    <p>For each distinct gain, only keep the combination which removes the smallest number of objects.</p>
    <p>At the end, choose the combination whose gain is the largest, no less than   Gp.</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Background and motivation  Definitions of some metrics  Algorithm sketches</p>
    <p>Border structure  Exhaustive algorithms  Greedy algorithms</p>
    <p>Experimental results  Conclusion and future works</p>
  </div>
  <div class="page">
    <p>Greedy algorithms</p>
    <p>Idea: always pick the border which, if we remove one level, will result in the largest average gain per removed object.</p>
    <p>a d</p>
    <p>b c</p>
    <p>p = 2</p>
  </div>
  <div class="page">
    <p>Greedy algorithms</p>
    <p>look-ahead: compute the average gains of removing 1,, m levels, and pick the one with largest average gain.</p>
    <p>p = 3</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Background and motivation  Definitions of some metrics  Algorithm sketches  Experimental results  Conclusion and future works</p>
  </div>
  <div class="page">
    <p>Experiments  setup</p>
    <p>Real datasets  the Postal dataset: 123,593 point data (postal</p>
    <p>addresses in Northeast area of USA).  the Street dataset: 131,461 line segments</p>
    <p>(streets of Los Angeles).</p>
    <p>p = 30% of the node capacity (1KB).   = 0.5,  = 0.9 and m = 5.</p>
  </div>
  <div class="page">
    <p>Experiments  Gain comparison</p>
    <p>Comparison of gains under various number of objects</p>
    <p>Comparison of running time of various algorithms</p>
  </div>
  <div class="page">
    <p>Experiments  Index construction</p>
    <p>Greedy Original 0</p>
    <p>the Postal dataset</p>
    <p># D</p>
    <p>is k I</p>
    <p>/O</p>
    <p>Greedy Original 0</p>
    <p>the Street dataset</p>
    <p># D</p>
    <p>is k I</p>
    <p>/O</p>
  </div>
  <div class="page">
    <p>Experiments  Range query by varying query size</p>
    <p>the Postal dataset the Street dataset</p>
    <p>Page size: 1K, buffer size: 128K.</p>
  </div>
  <div class="page">
    <p>Experiments  Range query by varying page size</p>
    <p>the Postal dataset the Street dataset</p>
    <p>Query size: 0.01%, buffer size: 128K.</p>
  </div>
  <div class="page">
    <p>Experiments  Range query by varying buffer size</p>
    <p>the Postal dataset the Street dataset</p>
    <p>Page size: 1K, Query size: 0.01%.</p>
  </div>
  <div class="page">
    <p>Outline</p>
    <p>Background and motivation  Definitions of some metrics  Algorithm sketches  Experimental results  Conclusion and future works</p>
  </div>
  <div class="page">
    <p>Conclusions and future work</p>
    <p>Defined novel quality/gain/loss metrics, considering both area and shape.</p>
    <p>Defined minP-boundary and proposed algorithms to find it.</p>
    <p>Integrated with R*-tree and achieved up to 20% range query improvement.</p>
    <p>Examining the idea to promote outlier objects to index nodes.</p>
  </div>
  <div class="page">
    <p>Thank you!</p>
  </div>
</Presentation>
