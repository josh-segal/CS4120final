<?xml version="1.0" ?>
<Presentation>
  <div class="page">
    <p>STRUCTURAL PATTERNS OF TRACTABLE SEQUENTIALLY-OPTIMAL PLANNING</p>
    <p>Michael Katz Carmel Domshlak</p>
    <p>IE&amp;M, Technion</p>
  </div>
  <div class="page">
    <p>SEQUENTIALLY-OPTIMAL CLASSICAL PLANNING PLAN COST = TOTAL COST OF PLANS ACTIONS</p>
    <p>v1</p>
    <p>v2</p>
    <p>vn</p>
    <p>V I G</p>
    <p>Find such ! ! A!</p>
    <p>minimize !</p>
    <p>a!!</p>
    <p>cost(a)</p>
  </div>
  <div class="page">
    <p>HOW TO SOLVE?</p>
    <p>A/IDA WITH AN ADMISSIBLE HEURISTIC 1 Admissible heuristic  based on optimal cost of solving</p>
    <p>an over-approximating abstraction of the original problem  2 Homomorphism abstractions</p>
    <p>PRINCIPLE Systematic state merging DONE BY Projecting  onto a subset of its state</p>
    <p>variables KNOWN AS Pattern Databases (PDBs)</p>
    <p>ACHILLES HEEL OF PDBS: |Vi| = O(log |V|) Each pattern Vi is required to be small to allow exhaustive search in the state space of [Vi ]</p>
    <p>Typically implies: Limited scalability</p>
  </div>
  <div class="page">
    <p>GENERALIZING PDBS TO STRUCTURAL PATTERNS</p>
    <p>Select a (relatively small) set of subsets V1, . . . , Vk of V such that, for 1  i  k ,</p>
    <p>(not necessarily due to the size of but) due to the specific structure of [Vi ]</p>
    <p>Possibly |Vi| = (|V|)! Similarly to PDBs,</p>
    <p>Disjoint?</p>
    <p>h(s) = k!</p>
    <p>i=1</p>
    <p>h [Vi](s) h(s) = maxk</p>
    <p>i=1 h [Vi](s)</p>
    <p>YES NO</p>
  </div>
  <div class="page">
    <p>STRUCTURAL PATTERNS: THE GOOD, THE BAD, AND THE NEEDED</p>
    <p>WHAT IS GOOD? Generalization of PDBs to homomorphism abstractions of unlimited dimensionality</p>
    <p>WHAT IS BAD? Structural patterns correspond to tractable fragments of optimal planning The palette of such known fragments is extremely limited</p>
    <p>WHAT IS NEEDED? Discovering new islands of tractability of optimal planning This is what we do!</p>
  </div>
  <div class="page">
    <p>ISLANDS OF TRACTABILITY</p>
    <p>OUR FOCUS HERE: UB FRAGMENT OF CLASSICAL PLANNING 1 All actions are unary-effect 2 All state variables V are binary-valued</p>
    <p>A = {a1, . . . , aN }</p>
    <p>ai</p>
    <p>[</p>
    <p>post(ai)pre(ai)</p>
    <p>prv(ai)</p>
    <p>For all actions a ! A, we have |post(a)| = 1</p>
  </div>
  <div class="page">
    <p>ISLANDS OF TRACTABILITY</p>
    <p>OUR FOCUS HERE: UB FRAGMENT OF CLASSICAL PLANNING 1 All actions are unary-effect 2 All state variables V are binary-valued</p>
    <p>TRACTABLE CASES ARE CHARACTERIZED IN TERMS OF 1 Form of the problems causal graph 2 O(1) bounds on causal graphs indegree 3 O(1) bounds on |prv(a)| (k -dependence)</p>
  </div>
  <div class="page">
    <p>CAUSAL GRAPH AND k -DEPENDENCE COMBINING global AND local structure</p>
    <p>v1</p>
    <p>v2</p>
    <p>A = {a1, . . . , aN }</p>
    <p>ai [prv(ai)</p>
    <p>v3</p>
    <p>v4</p>
    <p>v5</p>
    <p>v6</p>
    <p>v7</p>
    <p>[</p>
    <p>aj</p>
    <p>prv(aj )</p>
    <p>CG!</p>
    <p>k -DEPENDENCE Problem is k -dependent iff |prv(a)|  k for all actions a  A</p>
  </div>
  <div class="page">
    <p>FOCUS ON ACYCLIC CAUSAL GRAPHS</p>
    <p>v1 v2 v3</p>
    <p>v4 v5</p>
    <p>v6</p>
    <p>v7</p>
    <p>v1 v2 v3</p>
    <p>v4 v5</p>
    <p>v6v7</p>
    <p>v1 v2 v3</p>
    <p>v4 v5</p>
    <p>v6v7</p>
    <p>v1 v2 v3</p>
    <p>v4 v5</p>
    <p>v6</p>
    <p>v7</p>
    <p>Tree</p>
    <p>Inverted Tree</p>
    <p>Polytree Directed-path Singly Connected</p>
    <p>SP</p>
    <p>I</p>
    <p>T</p>
    <p>!</p>
    <p>!</p>
    <p>!</p>
  </div>
  <div class="page">
    <p>COMPLEXITY RESULTS FOR (REGULAR) UB PLANNING</p>
    <p>S</p>
    <p>Sb S b</p>
    <p>S b b</p>
    <p>P</p>
    <p>Pb</p>
    <p>P b b</p>
    <p>P b</p>
    <p>T I</p>
    <p>NP-hard Polynomial</p>
    <p>[Brafman &amp; Domshlak, JAIR-03]</p>
    <p>[Brafman &amp; Domshlak, JAIR-03]</p>
    <p>[Jonsson &amp; Gimenez, ICAPS-07]</p>
  </div>
  <div class="page">
    <p>OUR RESULTS SHADED ENTRIES</p>
    <p>k = 1 k = 2 k = 3 k = (n)</p>
    <p>Pb(k )    P P(k ) P NPC Sb(k ) NPC   NPC</p>
    <p>Sequentially-optimal planning</p>
    <p>k = 1 k = 2 k = 3 k = (n)</p>
    <p>Pb(k )    P P(k ) P NPC Sb(k ) NPC  NPC</p>
    <p>Satisficing plan generation</p>
  </div>
  <div class="page">
    <p>GENERAL PRINCIPLE</p>
    <p>Compiling a problem  into a constraint optimization problem COP = (X ,F) over variables X , functional components F, and the global objective min</p>
    <p>F (X) such that</p>
    <p>(I) the compilation of a problem  into COP is polynomial in the description size of ,</p>
    <p>(II) the tree-width of the cost network of COP is bounded by a constant,</p>
    <p>(III) if  is unsolvable then all the assignments to X evaluate the objective function to , and otherwise, the optimum of the global objective is obtained on and only on the assignments to X that correspond to optimal solutions for ,</p>
    <p>(IV) given an optimal solution to COP, an optimal plan for  can be reconstructed from the former in polynomial time.</p>
  </div>
  <div class="page">
    <p>FROM GENERAL PRINCIPLE TO CONCRETE ALGORITHMS</p>
    <p>REUSING TRACTABLE CONSTRAINT OPTIMIZATION Having such a compilation scheme, we can</p>
    <p>SAME FRAMEWORK  DIFFERENT INSTANCES Variables X and functional components F = {x | x X} differ from problem class to problem class</p>
  </div>
  <div class="page">
    <p>POLYTREE + BOUNDED INDEGREES (Pb )</p>
    <p>PROPERTY I [BD03] For any solvable P problem  over n state variables, any SO-plan  for , and any state variable v in , the number of value changes of v along  is  n.</p>
  </div>
  <div class="page">
    <p>POLYTREE + BOUNDED INDEGREES (Pb )</p>
    <p>CONSTRAINT OPTIMIZATION PROBLEM COP variables X  State variables V Domain of xv  Possible value changes of v along plan Function components  State variables families</p>
    <p>v1</p>
    <p>!! !</p>
    <p>! !</p>
    <p>! !</p>
    <p>! v2</p>
    <p>&quot;&quot;</p>
    <p>v3</p>
    <p>##&quot; &quot; &quot; &quot; &quot; &quot;</p>
    <p>v4</p>
    <p>##&quot; &quot; &quot; &quot; &quot; &quot;</p>
    <p>!! !</p>
    <p>! !</p>
    <p>! !</p>
    <p>! v5</p>
    <p>&quot;&quot; v7 v6</p>
    <p>xv1</p>
    <p>! !</p>
    <p>! !</p>
    <p>! !</p>
    <p>xv2 xv3</p>
    <p>&quot; &quot; &quot; &quot; &quot; &quot;</p>
    <p>xv4</p>
    <p>&quot; &quot; &quot; &quot; &quot; &quot;</p>
    <p>! !</p>
    <p>! !</p>
    <p>! !</p>
    <p>xv5</p>
    <p>xv7 xv6</p>
    <p>Causal graph of ! Cost network of COP!</p>
  </div>
  <div class="page">
    <p>POLYTREE + 1-DEPENDENCE (P(1))</p>
    <p>PROPERTY II (UNIFORM-COST ACTIONS)</p>
    <p>For any solvable problem , there exists an SO-plan  such that all the changes of each variable to a certain value are performed by the same type of action.</p>
    <p>PROPERTY III (GENERAL ACTIONS)</p>
    <p>For any solvable problem , there exists an SO-plan  such that all the changes of each variable are done using at most three types of actions which are prevailed by at most two parents.</p>
    <p>See the full version for the construction for P(1) with general actions.</p>
  </div>
  <div class="page">
    <p>NOTATION</p>
    <p>Given an S problem  = V , A, I, G, for each variable v  V , bv denotes the initial value I[v ], and wv denotes the opposite value of v .</p>
    <p>(v ) denotes the longest possible sequence of values obtainable by v along a cost-optimal plan , with |(v )| = n + 1, with bv occupying all the odd positions of (v ), and wv occupying all the even positions of (v ).</p>
    <p>D[(v )] denotes the set of all goal-valid prefixes of (v ), that is, prefixes of (v ) that end up with G[v ] if the latter is specified.</p>
  </div>
  <div class="page">
    <p>P(1) WITH UNIFORM-COST ACTIONS</p>
    <p>COP VARIABLES</p>
    <p>X = {xv | v  V}{x uv | ( u, v )  CG()}</p>
    <p>COP VARIABLE DOMAINS</p>
    <p>Dom(xv ) = D [(v )]</p>
    <p>Dom(x uv ) = {[[w, b, ]] | w, b {0, 1}, 0    n}</p>
    <p>COP FUNCTIONAL SCOPES (pred(v ) = {u1, . . . , uk})</p>
    <p>Qx =</p>
    <p>{xv}, x = xv , k = 0 {xv , x</p>
    <p>uk v }, x = xv , k &gt; 0</p>
    <p>{x u1v , xu1}, x = x u1 v , k &gt; 0</p>
    <p>{x ujv , x uj1 v , xuj}, x = x</p>
    <p>uj v , 1 &lt; j  k</p>
  </div>
  <div class="page">
    <p>POLYTREE + 1-DEPENDENCE (P(1))</p>
    <p>v1</p>
    <p>!! !</p>
    <p>! !</p>
    <p>! !</p>
    <p>! !</p>
    <p>! !</p>
    <p>v2</p>
    <p>&quot;&quot;</p>
    <p>v3</p>
    <p>##&quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot;</p>
    <p>v4</p>
    <p>##&quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot;</p>
    <p>!! !</p>
    <p>! !</p>
    <p>! !</p>
    <p>! !</p>
    <p>! !</p>
    <p>v5</p>
    <p>&quot;&quot; v7 v6</p>
    <p>xv1 xv2</p>
    <p>! ! ! !</p>
    <p>xv3</p>
    <p>! ! ! !</p>
    <p>x v1</p>
    <p>v4 x</p>
    <p>v2</p>
    <p>v4 x</p>
    <p>v3</p>
    <p>v4</p>
    <p>xv4</p>
    <p>! ! ! !</p>
    <p>xv5</p>
    <p>! ! ! !</p>
    <p>x v4</p>
    <p>v7 x</p>
    <p>v4</p>
    <p>v6 x</p>
    <p>v5</p>
    <p>v6</p>
    <p>xv7 xv6</p>
    <p>Causal graph of ! Cost network of COP!</p>
  </div>
  <div class="page">
    <p>COP FUNCTIONALS (I) P(1) WITH UNIFORM-COST ACTIONS</p>
    <p>FOR EACH xv WITH pred(v ) =</p>
    <p>xv (v ) =</p>
    <p>xv1 xv2</p>
    <p>! ! ! !</p>
    <p>xv3</p>
    <p>! ! ! !</p>
    <p>x v1</p>
    <p>v4 x</p>
    <p>v2</p>
    <p>v4 x</p>
    <p>v3</p>
    <p>v4</p>
    <p>xv4</p>
    <p>! ! ! !</p>
    <p>xv5</p>
    <p>! ! ! !</p>
    <p>x v4</p>
    <p>v7 x</p>
    <p>v4</p>
    <p>v6 x</p>
    <p>v5</p>
    <p>v6</p>
    <p>xv7 xv6</p>
  </div>
  <div class="page">
    <p>COP FUNCTIONALS (II) P(1) WITH UNIFORM-COST ACTIONS</p>
    <p>FOR EACH xv WITH pred(v ) = {u1, . . . , uk}, k &gt; 0</p>
    <p>xv (v , [[w, b, ]]) =</p>
    <p>xv1 xv2</p>
    <p>! ! ! !</p>
    <p>xv3</p>
    <p>! ! ! !</p>
    <p>x v1</p>
    <p>v4 x</p>
    <p>v2</p>
    <p>v4 x</p>
    <p>v3</p>
    <p>v4</p>
    <p>xv4</p>
    <p>! ! ! !</p>
    <p>xv5</p>
    <p>! ! ! !</p>
    <p>x v4</p>
    <p>v7 x</p>
    <p>v4</p>
    <p>v6 x</p>
    <p>v5</p>
    <p>v6</p>
    <p>xv7 xv6</p>
  </div>
  <div class="page">
    <p>AUXILIARY INDICATOR FUNCTION P(1) WITH UNIFORM-COST ACTIONS</p>
    <p>INDICATOR FUNCTION</p>
    <p>([[w, b, ]] , u ) =</p>
  </div>
  <div class="page">
    <p>COP FUNCTIONALS (III) P(1) WITH UNIFORM-COST ACTIONS</p>
    <p>FOR x u1v</p>
    <p>x u1 v</p>
    <p>` [[w, b, ]] , u1</p>
    <p>=</p>
    <p>` [[w, b, ]] , u1</p>
    <p>xv1 xv2</p>
    <p>! ! ! !</p>
    <p>xv3</p>
    <p>! ! ! !</p>
    <p>x v1</p>
    <p>v4 x</p>
    <p>v2</p>
    <p>v4 x</p>
    <p>v3</p>
    <p>v4</p>
    <p>xv4</p>
    <p>! ! ! !</p>
    <p>xv5</p>
    <p>! ! ! !</p>
    <p>x v4</p>
    <p>v7 x</p>
    <p>v4</p>
    <p>v6 x</p>
    <p>v5</p>
    <p>v6</p>
    <p>xv7 xv6</p>
  </div>
  <div class="page">
    <p>COP FUNCTIONALS (IV) P(1) WITH UNIFORM-COST ACTIONS</p>
    <p>FOR EACH x uj v , j &gt; 1</p>
    <p>x</p>
    <p>uj v</p>
    <p>[[w, b, ]] ,</p>
    <p>w,</p>
    <p>b,</p>
    <p>, uj  = (</p>
    <p>w  w, b  b,</p>
    <p>, uj</p>
    <p>,  =</p>
    <p>otherwise</p>
    <p>xv1 xv2</p>
    <p>! ! ! !</p>
    <p>xv3</p>
    <p>! ! ! !</p>
    <p>x v1</p>
    <p>v4 x</p>
    <p>v2</p>
    <p>v4 x</p>
    <p>v3</p>
    <p>v4</p>
    <p>xv4</p>
    <p>! ! ! !</p>
    <p>xv5</p>
    <p>! ! ! !</p>
    <p>x v4</p>
    <p>v7 x</p>
    <p>v4</p>
    <p>v6 x</p>
    <p>v5</p>
    <p>v6</p>
    <p>xv7 xv6</p>
  </div>
  <div class="page">
    <p>FUTURE WORK</p>
    <p>THIS IS JUST THE BEGINNING ... Discovering new islands of tractability of optimal planning</p>
    <p>- New results for non-binary domains with fork and inverted fork causal graphs [KD07b]</p>
    <p>- Positive evidence of relevance to structural patterns heuristics</p>
    <p>Devising as efficient as possible algorithms for such islands Translating and/or abstracting the general planning problems into such islands</p>
  </div>
</Presentation>
